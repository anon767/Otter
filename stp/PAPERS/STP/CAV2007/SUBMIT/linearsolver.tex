\section{Linear Solver and Variable Elimination}

One of the essential features of STP for software analysis
applications is its efficient handling of linear twos-complement
arithmetic.  The heart of this is an {\em on-the-fly\/} solver.  The
main goal of the solver is to eliminate as many bits of as many
variables as possible, to reduce the size of the transformed problem
for the SAT solver.  In addition, it enables many other
simplifications, and can solve purely linear problems outright, so
that the SAT solver does not need to be used.

The solver solves for one equation for one variable at a time.  That
variable can then be eliminated by substitution in the rest of the
formula, whether the variable occurs in linear equations or other
formulas.  In some cases, it cannot solve an entire variable, so it
solves for some of the low-order bits of the variable.  After
bit-blasting, these bits will not appear as variables in the problem
presented to the SAT solver. Non-linear or word-level terms (extracts,
concats etc.) appearing in linear equations are treated as bit-vector
variables.

The algorithm has worst-case time running time of $O(k^2n)$
multiplications, where $k$ is the number of equations and $n$ is the
number of variables in the input system of linear bit-vector
equations.\footnote{As observed in ~\cite{BDL98}, the theory of linear
mod $2^n$ arithmetic (equations only) in tandem with concatenate and
extract operations is NP-complete. Although STP has concatenate and
extraction operations, terms with those operations are treated as
independent variables in the linear solving process, which is
polynomial. 

A hard NP-complete input problem constructed out of linear operations,
concatenate and extract operations will not be solved completely by
linear solving, and will result in work for the SAT solver.}  If the
input is unsatisfiable the solver terminates with $\stpfalse$. If the
input is satisfiable it terminates with a set of equations in
\textit{solved form}, which symbolically represent all possible
satisfying assignments to the input equations.  So, in the special
case where the formula is a system of linear equations, the solver
leads to a sound and complete polynomial-time decision procedure.
Furthermore, the equations are reduced to a closed form that captures
all of the possible solutions.

\begin{definition}
\emph{Solved Form:} A list of equations is in
\textit{solved form} if the following invariants hold over the
equations in the list.

1) Each equation in the list is of the form $x[i:0] = t$ or $x=t$,
where $x$ is a variable and $t$ is a linear combination of the
variables or constant times a variable (or extractions thereof)
occuring in the equations of the list, except $x$

2) Variables on the left hand side of the equations occuring earlier
in the list may not occur on the right hand side of subsequent
equations. Also, there may not be two equations with the same left
hand side in the list

3) If extractions of variables occur in the list, then they must
always be of the form $x[i:0]$, i.e. the lower extraction index must
be 0, and all extractions must be of the same length

4) If an extraction of a variable $x[i:0]= t$ occurs in the list, then
   an entry is made in the list for $x=x^{1}@t$, where $x^1$ is a new
   variable refering to the top bits of $x$ and $@$ is the
   concatenation symbol
\end{definition}

The algorithm is illustrated on the following system:
\begin{eqnarray}
3x + 4y + 2z &=& 0\nonumber\\
2x + 2y + 2 &=& 0 \nonumber\\
4y + 2x + 2z &=& 0\nonumber
\end{eqnarray}
where all constants, variables and functions are 3 bits long. 

The solver proceeds by first choosing an equation and always checks if
the chosen equation is {\it solvable}. It uses the following theorem
from basic number theory to determine if an equation is solvable:
$\Sigma_{i=1}^n a_ix_i = c_i$ mod $2^b$ is solvable for the unknowns
$x_i$ if and only if the greatest common divisor of
\{$a_1,\ldots,a_n,2^b$\} divides $c_i$.

In the example above, the solver chooses $3x + 4y + 2z = 0$ which is
solvable since the $gcd(3,4,2,2^3)$ does indeed divide $0$. It is also
a basic result from number theory that a number $a$ has a
multiplicative inverse mod $m$ iff $\gcd(a, m) = 1$, and that this
inverse can be computed by the extended greatest-common divisor
algorithm~\cite{CLR} or a method from~\cite{BDL98}. So, if there is a
variable with an odd coefficient, the solver isolates it on the
left-hand-side and multiplies through by the inverse of the
coefficient.  In the example, the multiplicative inverse of $3$ mod
$8$ is also $3$, so $3x + 4y + 2z = 0$ can be solved to yield $x = 4y
+ 6z$.

Substituting $4y+6z$ for $x$ in the remaining two equations yields the
system 
\begin{eqnarray}
2y + 4z + 2 &=& 0 \nonumber\\
4y + 6z &=& 0\nonumber
\end{eqnarray}

where all coefficients are even. Note that even coefficients do not
have multiplicative inverses in arithmetic mod $2^b$, and, hence we
cannot isolate a variable. However, it is possible to solve for {\em
some bits\/} of the remaining variables.

The solver transforms the whole system of solvable equations into a
system which has at least one summand with an odd coefficient. To do
this, the solver chooses an equation which has a summand whose
coefficient has the minimum number of factors of 2. In the example,
this would the equation $2y + 4z + 2 =0$, and the summand would be
$2y$. The whole system is divided by 2, and the high-order bit of each
variable is dropped, to obtain a reduced set of equations

\begin{eqnarray}
 y[1:0] + 2z[1:0] + 1 &=& 0 \nonumber\\
2y[1:0] + 3z[1:0] &=& 0 \nonumber\
\end{eqnarray}

where all constants, variables and operations are 2 bits.  Next,
$y[1:0]$ is solved for to obtain $y[1:0] = 2z[1:0] + 3$. Substituting
for $y[1:0]$ in the system yields a new system of equations $3z[1:0] +
2 = 0$. This equation can be solved for $z[1:0]$ to obtain $z[1:0] =
2$. It follows that original system of equations is satisfiable. It is
important to note here that the bits $y[2:1]$ and $z[2:1]$ are
unconstrained. The solved form in this case is $x=4y+6z$ $\wedge$
$y[1:0] = 2z[1:0] + 3$ $\wedge$ $z[1:0] = 2$ (Note that in the last
two equations all variables, constants and functions are 2 bits long).

Algorithms for deciding the satisfiability of a system of equations
and congruences in modular or residue arithmetic have been well-known
for a long time. However, most of these algorithms do not provide a
solved form that captures all possible solutions.  Some of the ideas
presented here were devised by Clark Barrett and implemented in the
SVC decision procedure~\cite{cheng01,BDL98}, but the SVC algorithm has
exponential worst-case time complexity while STP's linear solver is
polynomial in the worst-case.

The closest related work is probably in a paper by Huang and
Cheng~\cite{cheng01}, which reduces a set of equations to a solved
form by Guassian elimination. On the other hand, STP implements an
online solving and substitution algorithm that gives a closed form
solution. Such algorithms are easier to integrate into complex
decision procedures.
