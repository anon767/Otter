\section{Experimental Results}

STP has been thoroughly tested over thousands of examples derived from
around a dozen different projects in software analysis, bug finding
and hardware verification. Some notable examples include: 1) {\bf EXE}
: Bug finding tool from Stanford~\cite{exe-ccs06} 2) {\bf CATCHCONV} :
A tool for catching conversion errors from Berkeley~\cite{catchconv07}
3) {\bf Replayer} : Automatic binary analysis of protocols from
CMU~\cite{replayer06} 4) {\bf Minesweeper} : Another bug finding tool
from CMU~\cite{minesweeper2007}.

Unfortunately, we could not translate most of our large (called {\it
BigArray Examples} in the logs) benchmarks into SMTLIB format because
the CVC2SMT translator available at~\cite{smtlib} segfaults on these
examples. This prevents us from comparing STP with Yices on the
BigArray examples. Therefore, we present three tables. In Table
\ref{STP-table} STP is compared with all optimizations on (All ON),
Array Optimizations on (Arr-ON,Lin-OFF), linear-solving on
(Arr-OFF,Lin-ON), and all optimizations off (ALL OFF) on the BigArray
examples (these examples are heavy on linear arithmetic and array
reads). In Table \ref{STP-write-abs} we present STP's performance on
big array examples with deeply nested writes. In Table
\ref{STP-Yices-table} we present the comparison of STP with Yices on a
very small version of a BigArray example, and some randomly generated
linear system of equations. Even though the linear solving examples
are randomly generated, they give a clear indication of how Yices will
perform on the real-world inputs since they require good solving. All
experiments were run on a 3.2GHz/2GB RAM Intel machine running Linux.

\begin{table}[t]
%\footnotesize
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
{\bf Example Name (Node Size)} & {\bf Result} & {\bf All ON} & {\bf Arr-ON,Lin-OFF} & {\bf Arr-OFF,Lin-ON} & {\bf All OFF}\\
\hline
testcase15 (0.9M) & sat & 66 & 192 & 64  & MO \\
testcase16 (0.9M) & sat & 67 & 233 & 66  & MO \\
thumbnailout-spin1 (3.2M)& sat & 115 & 111 & 113 & MO \\
thumbnailout-spin1-2 (4.3M)& NR & MO & MO & MO  & MO \\
thumbnailout-noarg (2.7M)& sat & 840 & MO & MO  & MO \\
\hline
\end{tabular}
\end{center}
\caption{STP performance in different modes over BigArray
Examples. Names are followed by the nodesize. Approximate nodesize is
in millions of nodes. 1M is one million nodes. Shared nodes are
counted exactly once. NR stands for No Result.  All timings are in
seconds. MO stands for out of memory error. These examples were
generated using the CATCHCONV tool}
\label{STP-table}
\end{table}

For Table \ref{STP-table} we chose some of the hardest of the BigArray
examples which are usually 10s of MBytes of text, typically 100s of
thousands of 32 bit bit-vector variables, lots of array reads, and
large number of linear constraints derived
from~\cite{catchconv07,replayer06}. The primary reason for timeout was
usually because of out-of-memory exception. Table \ref{STP-table}
shows that all optimizations are required for solving the hardest
realword problems. As expected STP's linear solver is the most
effective in solving these examples.

\begin{table}[t]
%\footnotesize
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
{\bf Example Name (Node Size)} & {\bf Result} & {\bf WRITE Abstraction} & {\bf NO WRITE Abstraction} \\
\hline
grep0084   (69K) & sat & 109 & 506 \\
grep0095   (69K) & sat & 115 & 84 \\
grep0106   (69K) & sat & 270 & $>$ 600 \\
grep0117   (70K) & sat & 218 & $>$ 600 \\
grep0777   (73K) & NR  &  MO & MO \\
610dd9dc   (15K) & sat & 188 & 101 \\
testcase20 (1.2M)& sat & 67  & MO \\
\hline
\end{tabular}
\end{center}
\caption{STP performance in different modes over BigArray Examples
with deep nested writes. Names are followed by the nodesize. 1M is one
million nodes (1K is thousand nodes). Shared nodes are counted exactly
once. NR stands for No Result.  All timings are in seconds. MO stands
for out of memory error.These examples were generated using the
CATCHCONV and MINESWEEPER tools}
\label{STP-write-abs}
\end{table}

For Table \ref{STP-write-abs} we chose examples with lots of deeply
nested array writes and modest amounts of linear constraints derived
very different applications. The grep examples were generated using
the MINESWEEPER tool while trying to find bugs in unix grep program.
The 610dd9c formula is generated by a MINESWEEPER analysis of a
program that is used in botnet attack. The formula testcase20 was
generated by CATCHCONV which does analysis on the VALGRIND IR of C
programs. As expected STP with write abstraction-refinement ON gives a
very large improvement over STP with write abstraction-refinement
switched OFF.

\begin{table}[t]
\footnotesize
\begin{center}
\begin{tabular}{|l|r|r|}
\hline
{\bf Example} & {\bf STP} & {\bf Yices} \\
\hline
25 var/25 equations(unsat) &  0.8s  & 42s  \\
50 var/50 equations(sat)   &  13s  &  TimeOut \\
cookie checksum example(sat) &  2.6s &  218s \\
\hline
\end{tabular}
\end{center}
\caption{STP vs. Yices. Timeout per example: 600sec. The last example
was generated using the Replayer tool}
\label{STP-Yices-table}
\end{table}

We compare Yices~\cite{yices}, one of the best SMTLIB solvers, with
STP on one of the smallest real-world BigArray examples that we
managed to translate using CVC2SMT translator (As mentioned before all
these examples have very similar characterisitics even though they are
generated from very different applications).  Yices is nearly 100x
slower than STP. In order to compare the linear solving of Yices and
STP, we generated some random examples with very small number of
variables and equations, where each variable is a 32 bit
bit-vector. We present two cases for illustration in Table
\ref{STP-Yices-table}. Yices timesout on even a 50 variable 50
equation example, and when it does finish it is much slower than
STP. The STP website~\cite{stpwebsite} provides more complete
regression logs, where STP and Yices are compared on all examples that
we could translate to SMTLIB format.
