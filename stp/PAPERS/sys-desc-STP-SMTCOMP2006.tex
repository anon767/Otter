\documentclass{article}
\title{System Description of STP}

\author{
Vijay Ganesh and David L. Dill \\
\\
Computer Systems Laboratory \\
Stanford University, Stanford, CA, USA \\
\{vganesh, dill\} @cs.stanford.edu}

\begin{document}
\maketitle

\newcommand{\stpread}{{\it read}}
\newcommand{\stpwrite}{{\it write}}
\newcommand{\stpite}{{\it ite}}

\section{Introduction}

STP is a decision procedure for the validity of the quantifier-free
logic of fixed-width bitvectors and one-dimensional arrays (which, in
SMTLIB, double as uninterpeted functions). The functions and
predicates in STP's input language correspond to standard CPU tests
and operations, such as signed/unsigned comparison and $n$-bit
signed/unsigned two's complement arithmetic.  The STP language is
mostly a subset of CVCL~\cite{cvcl}, and is mostly
syntax-compatible. STP generates concrete counterexamples for invalid
inputs. STP is written in C++.

%% We believe it
%% will be competitive, and we know that it is faster than CVCL in some
%% cases.  However, the implementation is rather obvious, so other
%% programs with more careful tuning or more original approaches might be
%% faster.

%% Currently, STP is being used as part
%% of the EXE system at Stanford, where it is used to solve constraints
%% for automatic testing of C programs~\cite{EXEpaper}.  An important
%% feature of STP for EXE (but not for the SMTLIB competition) is the
%% ability to generate concrete counterexamples when a formula is found
%% to be invalid.  These counterexamples are converted into test cases.
%% All
%% expressions are represented as directed acyclic graphs (DAGs), where
%% expressions with identical structure are represented uniquely
%% (expression nodes are looked up in a hash table whenever they are
%% created, to see whether an identical node already exists).

\section{Architecture}

Unlike Nelson-Oppen style solvers, STP preprocesses the input and then
``eagerly'' translates it into a purely propositional problem for a
SAT solver (MINISAT~\cite{minisat}).  There are no separate theories,
and no equalities have to be communicated.

The ideas implemented in STP are rather straight-forward. Our approach
in STP has been to keep it as simple as possible, adding optimizations
only when there is a demonstrated need in the application. The input
to STP is a list of word-level DAG representing the formula, created
by the parser or directly by the application through a C-language
interface. The processing then proceeds in a series of phases:

\begin{enumerate}

%% \item  The assumptions are conjoined with ???.  The resulting formula
%% is satisfiable iff the original input is invalid.

\item Variables that are equal to constants are substituted away.

\item Transformations are applied to lift if's over array read
expressions.

%% \begin{tabular}{ll}

%% {\bf if-lifting} &  $\stpread(\stpite(x, y, z), i) 
%% 	\Rightarrow \stpite(x, \stpread(y, i), \stpread(z, i))$  \\


%% {\bf read-over-write} &   $\stpread(\stpwrite(A, i, v), j) 
%% 	\Rightarrow \stpite(i=j, v, \stpread(A, j))$ \\

%% \end{tabular}

\item Word level simplifications are applied.  Currently, these
simplifications are limited to simple arithmetic identities.

\item After that, all array read expressions are replaced by fresh
variables.  Note that this is an abstraction of the formula that may
produce incorrect claims that the formula is invalid. This is then
bitblasted and fed into MINISAT.

%% \item  The word-level formula is ``bit-blasted'' into a Boolean DAG with
%% standard boolean operations.  Simple Boolean optimizations are applied
%% on-the-fly during this process.

%% \item  The Boolean DAG is converted to CNF using the standard approach of
%% assigning fresh names to intermediate expressions.  There is absolutely
%% no optimization in this phase.

%% \item  The CNF is solved by calling MINISAT.

\item If MINISAT says the formula is unsatisfiable, then STP returns
``Valid.'' If MINISAT says that the formula is satisfiable, then the
satisfying assignment is plugged back into the original input to see
whether the satisfying assignment is indeed a ``good'' one. If it is,
STP returns with ``Invalid.'' Otherwise, it refines the formula and
reiterates the solving process as described below.

\end{enumerate}

One interesting idea in STP is the refinement of array read
expressions. If, in step 5, STP finds that the word-level assignment
does not satisfy the formula, there is only one possible explanation:
There are array reads $A[i]$ and $A[j]$, which were replaced in step 4
by fresh variables $v_i$ and $v_j$, and, in the satisfying assignment
produced by MINISAT, $i = j$ but $v_i \not= v_j$.  In other words, the
substitution axiom $i = j \Rightarrow A[i] = A[j]$ was violated.

STP deals with this by identifying all such axioms that are violated
by its current counterexample, conjoining them with the original
formula, and refining until it gets a correct answer. This refinement
is faster than other approaches when STP ``gets lucky'' and finds a
correct satisfying assignment without explicitly satisfying the
axioms.

%% A final set of ``hacks'' were applied in the last days before
%% submitting the competition.  We turned off ref-counting, so that DAG
%% nodes were not freed, and limited bitvector constants to 64 bits.  
%% With a bit more effort and time, we believe STP could be made just as fast without
%% these compromises.  Of course, there are also additional optimizations that could
%% be implemented.

\section{Problem Division}
STP is an entry in the $\mathrm{QF\_UFBV(32)}$ division.

\bibliography{biblio}
\bibliographystyle{plain}
\end{document}




