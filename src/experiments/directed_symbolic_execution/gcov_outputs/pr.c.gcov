        -:    0:Source:/fs/buzz/kkma/code/wc1/branches/DSE/experiments/directed_symbolic_execution/coreutils-6.10/benchmark/../src/pr.c
        -:    0:Graph:pr.gcno
        -:    0:Data:pr.gcda
        -:    0:Runs:408
        -:    0:Programs:1
        -:    1:#ifdef CIL
        -:    2:extern void __ASSERT(_Bool);
        -:    3:#endif
        -:    4:/* pr -- convert text files for printing.
        -:    5:   Copyright (C) 88, 91, 1995-2007 Free Software Foundation, Inc.
        -:    6:
        -:    7:   This program is free software: you can redistribute it and/or modify
        -:    8:   it under the terms of the GNU General Public License as published by
        -:    9:   the Free Software Foundation, either version 3 of the License, or
        -:   10:   (at your option) any later version.
        -:   11:
        -:   12:   This program is distributed in the hope that it will be useful,
        -:   13:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15:   GNU General Public License for more details.
        -:   16:
        -:   17:   You should have received a copy of the GNU General Public License
        -:   18:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   19:
        -:   20:/*  By Pete TerMaat, with considerable refinement by Roland Huebner.  */
        -:   21:
        -:   22:/* Things to watch: Sys V screws up on ...
        -:   23:   pr -n -3 -s: /usr/dict/words
        -:   24:   pr -m -o10 -n /usr/dict/words{,,,}
        -:   25:   pr -6 -a -n -o5 /usr/dict/words
        -:   26:
        -:   27:   Ideas:
        -:   28:
        -:   29:   Keep a things_to_do list of functions to call when we know we have
        -:   30:   something to print.  Cleaner than current series of checks.
        -:   31:
        -:   32:   Improve the printing of control prefixes.
        -:   33:
        -:   34:   Expand the file name in the centered header line to a full file name.
        -:   35:
        -:   36:
        -:   37:   Concept:
        -:   38:
        -:   39:   If the input_tab_char differs from the default value TAB
        -:   40:   (`-e[CHAR[...]]' is used), any input text tab is expanded to the
        -:   41:   default width of 8 spaces (compare char_to_clump). - Same as SunOS
        -:   42:   does.
        -:   43:
        -:   44:   The treatment of the number_separator (compare add_line_number):
        -:   45:   The default value TAB of the number_separator (`-n[SEP[...]]') doesn't
        -:   46:   be thought to be an input character. An optional `-e'-input has no
        -:   47:   effect.
        -:   48:   -  With single column output
        -:   49:      only one POSIX requirement has to be met:
        -:   50:   The default n-separator should be a TAB. The consequence is a
        -:   51:   different width between the number and the text if the output position
        -:   52:   of the separator changes, i.e. it depends upon the left margin used.
        -:   53:   That's not nice but easy-to-use together with the defaults of other
        -:   54:   utilities, e.g. sort or cut. - Same as SunOS does.
        -:   55:   -  With multicolumn output
        -:   56:      two conflicting POSIX requirements exist:
        -:   57:   First `default n-separator is TAB', second `output text columns shall
        -:   58:   be of equal width'. Moreover POSIX specifies the number+separator a
        -:   59:   part of the column, together with `-COLUMN' and `-a -COLUMN'.
        -:   60:   (With -m output the number shall occupy each line only once. Exactly
        -:   61:   the same situation as single column output exists.)
        -:   62:      GNU pr gives priority to the 2nd requirement and observes POSIX
        -:   63:   column definition. The n-separator TAB is expanded to the same number
        -:   64:   of spaces in each column using the default value 8. Tabification is
        -:   65:   only performed if it is compatible with the output position.
        -:   66:   Consequence: The output text columns are of equal width. The layout
        -:   67:   of a page does not change if the left margin varies. - Looks better
        -:   68:   than the SunOS approach.
        -:   69:      SunOS pr gives priority to the 1st requirement. n-separator TAB
        -:   70:   width varies with each column. Only the width of text part of the
        -:   71:   column is fixed.
        -:   72:   Consequence: The output text columns don't have equal width. The
        -:   73:   widths and the layout of the whole page varies with the left margin.
        -:   74:   An overflow of the line length (without margin) over the input value
        -:   75:   PAGE_WIDTH may occur.
        -:   76:
        -:   77:   The interference of the POSIX-compliant small letter options -w and -s:
        -:   78:   (`interference' means `setting a _separator_ with -s switches off the
        -:   79:   column sturctur and the default - not generally - page_width,
        -:   80:   acts on -w option')
        -:   81:       options:       text form  / separator:     equivalent new options:
        -:   82:       -w l   -s[x]
        -:   83:    --------------------------------------------------------------------
        -:   84:    1.  --     --     columns    / space          --
        -:   85:                      trunc. to page_width = 72
        -:   86:    2.  --    -s[:]   full lines / TAB[:]         -J  --sep-string[="<TAB>"|:]
        -:   87:                      no truncation
        -:   88:    3.  -w l   --     columns    / space          -W l
        -:   89:                      trunc. to page_width = l
        -:   90:    4.  -w l  -s[:]   columns    / no sep.[:]     -W l  --sep-string[=:]
        -:   91:                      trunc. to page_width = l
        -:   92:    --------------------------------------------------------------------
        -:   93:
        -:   94:
        -:   95:   Options:
        -:   96:
        -:   97:   Including version 1.22i:
        -:   98:   Some SMALL LETTER options has been redefined with the object of a
        -:   99:   better POSIX compliance. The output of some further cases has been
        -:  100:   adapted to other UNIXes. A violation of downward compatibility has to
        -:  101:   be accepted.
        -:  102:   Some NEW CAPITAL LETTER options ( -J, -S, -W) has been introduced to
        -:  103:   turn off unexpected interferences of small letter options (-s and -w
        -:  104:   together with the three column options).
        -:  105:   -N option and the second argument LAST_PAGE of +FIRST_PAGE offer more
        -:  106:   flexibility; The detailed handling of form feeds set in the input
        -:  107:   files requires -T option.
        -:  108:
        -:  109:   Capital letter options dominate small letter ones.
        -:  110:
        -:  111:   Some of the option-arguments cannot be specified as separate arguments
        -:  112:   from the preceding option letter (already stated in POSIX specification).
        -:  113:
        -:  114:   Form feeds in the input cause page breaks in the output. Multiple
        -:  115:   form feeds produce empty pages.
        -:  116:
        -:  117:   +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]
        -:  118:		begin [stop] printing with page FIRST_[LAST_]PAGE
        -:  119:
        -:  120:   -COLUMN, --columns=COLUMN
        -:  121:		Produce output that is COLUMN columns wide and
        -:  122:		print columns down, unless -a is used. Balance number of
        -:  123:		lines in the columns on each page.
        -:  124:
        -:  125:   -a, --across		Print columns across rather than down, used
        -:  126:		together with -COLUMN. The input
        -:  127:		one
        -:  128:		two
        -:  129:		three
        -:  130:		four
        -:  131:		will be printed with `-a -3' as
        -:  132:		one	two	three
        -:  133:		four
        -:  134:
        -:  135:   -b		Balance columns on the last page.
        -:  136:		-b is no longer an independent option. It's always used
        -:  137:		together with -COLUMN (unless -a is used) to get a
        -:  138:		consistent formulation with "FF set by hand" in input
        -:  139:		files. Each formfeed found terminates the number of lines
        -:  140:		to be read with the actual page. The situation for
        -:  141:		printing columns down is equivalent to that on the last
        -:  142:		page. So we need a balancing.
        -:  143:
        -:  144:		Keeping -b as an underground option guarantees some
        -:  145:		downward compatibility. Utilities using pr with -b
        -:  146:		(a most frequently used form) still work as usual.
        -:  147:
        -:  148:   -c, --show-control-chars
        -:  149:		Print unprintable characters as control prefixes.
        -:  150:		Control-g is printed as ^G (use hat notation) and
        -:  151:		octal backslash notation.
        -:  152:
        -:  153:   -d, --double-space	Double space the output.
        -:  154:
        -:  155:   -D FORMAT, --date-format=FORMAT  Use FORMAT for the header date.
        -:  156:
        -:  157:   -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]
        -:  158:		Expand tabs to spaces on input.  Optional argument CHAR
        -:  159:		is the input TAB character. (Default is TAB).  Optional
        -:  160:		argument WIDTH is the input TAB character's width.
        -:  161:		(Default is 8.)
        -:  162:
        -:  163:   -F, -f, --form-feed	Use formfeeds instead of newlines to separate
        -:  164:		pages. A three line HEADER is used, no TRAILER with -F,
        -:  165:		without -F both HEADER and TRAILER are made of five lines.
        -:  166:
        -:  167:   -h HEADER, --header=HEADER
        -:  168:		Replace the filename in the header with the string HEADER.
        -:  169:		A centered header is used.
        -:  170:
        -:  171:   -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]
        -:  172:		Replace spaces with tabs on output.  Optional argument
        -:  173:		CHAR is the output TAB character. (Default is TAB).
        -:  174:		Optional argument WIDTH is the output TAB character's
        -:  175:		width. (Default is 8)
        -:  176:
        -:  177:   -J, --join-lines	Merge lines of full length, turns off -W/-w
        -:  178:		line truncation, no column alignment, --sep-string[=STRING]
        -:  179:		sets separators, works with all column options
        -:  180:		(-COLUMN | -a -COLUMN | -m).
        -:  181:		-J has been introduced (together with -W and --sep-string) to
        -:  182:		disentangle the old (POSIX compliant) options -w, -s
        -:  183:		along with the 3 column options.
        -:  184:
        -:  185:   -l PAGE_LENGTH, --length=PAGE_LENGTH
        -:  186:		Set the page length to PAGE_LENGTH lines. Default is 66,
        -:  187:		including 5 lines of HEADER and 5 lines of TRAILER
        -:  188:		without -F, but only 3 lines of HEADER and no TRAILER
        -:  189:		with -F (i.e the number of text lines defaults to 56 or
        -:  190:		63 respectively).
        -:  191:
        -:  192:   -m, --merge		Print files in parallel; pad_across_to align
        -:  193:		columns; truncate lines and print separator strings;
        -:  194:		Do it also with empty columns to get a continuous line
        -:  195:		numbering and column marking by separators throughout
        -:  196:		the whole merged file.
        -:  197:
        -:  198:		Empty pages in some input files produce empty columns
        -:  199:		[marked by separators] in the merged pages. Completely
        -:  200:		empty merged pages show no column separators at all.
        -:  201:
        -:  202:		The layout of a merged page is ruled by the largest form
        -:  203:		feed distance of the single pages at that page. Shorter
        -:  204:		columns will be filled up with empty lines.
        -:  205:
        -:  206:		Together with -J option join lines of full length and
        -:  207:		set separators when -S option is used.
        -:  208:
        -:  209:   -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]
        -:  210:		Provide DIGITS digit line numbering (default for DIGITS
        -:  211:		is 5). With multicolumn output the number occupies the
        -:  212:		first DIGITS column positions of each text column or only
        -:  213:		each line of -m output.
        -:  214:		With single column output the number precedes each line
        -:  215:		just as -m output.
        -:  216:		Optional argument SEP is the character appended to the
        -:  217:		line number to separate it from the text followed.
        -:  218:		The default separator is a TAB. In a strict sense a TAB
        -:  219:		is always printed with single column output only. The
        -:  220:		TAB-width varies with the TAB-position, e.g. with the
        -:  221:		left margin specified by -o option.
        -:  222:		With multicolumn output priority is given to `equal width
        -:  223:		of output columns' (a POSIX specification). The TAB-width
        -:  224:		is fixed to the value of the 1st column and does not
        -:  225:		change with different values of left margin. That means a
        -:  226:		fixed number of spaces is always printed in the place of
        -:  227:		a TAB. The tabification depends upon the output
        -:  228:		position.
        -:  229:
        -:  230:		Default counting of the line numbers starts with 1st
        -:  231:		line of the input file (not the 1st line printed,
        -:  232:		compare the --page option and -N option).
        -:  233:
        -:  234:   -N NUMBER, --first-line-number=NUMBER
        -:  235:		Start line counting with the number NUMBER at the 1st
        -:  236:		line of first page printed (mostly not the 1st line of
        -:  237:		the input file).
        -:  238:
        -:  239:   -o MARGIN, --indent=MARGIN
        -:  240:		Offset each line with a margin MARGIN spaces wide.
        -:  241:		Total page width is the size of the margin plus the
        -:  242:		PAGE_WIDTH set with -W/-w option.
        -:  243:
        -:  244:   -r, --no-file-warnings
        -:  245:		Omit warning when a file cannot be opened.
        -:  246:
        -:  247:   -s[CHAR], --separator[=CHAR]
        -:  248:		Separate columns by a single character CHAR, default for
        -:  249:		CHAR is the TAB character without -w and 'no char' with -w.
        -:  250:		Without `-s' default separator `space' is set.
        -:  251:		-s[CHAR] turns off line truncation of all 3 column options
        -:  252:		(-COLUMN|-a -COLUMN|-m) except -w is set. That is a POSIX
        -:  253:		compliant formulation. The source code translates -s into
        -:  254:		the new options -S and -J, also -W if required.
        -:  255:
        -:  256:   -S STRING, --sep-string[=STRING]
        -:  257:		Separate columns by any string STRING. The -S option
        -:  258:		doesn't react upon the -W/-w option (unlike -s option
        -:  259:		does). It defines a separator nothing else.
        -:  260:		Without -S: Default separator TAB is used with -J and
        -:  261:		`space' otherwise (same as -S" ").
        -:  262:		With -S "": No separator is used.
        -:  263:		Quotes should be used with blanks and some shell active
        -:  264:		characters.
        -:  265:		-S is problematic because in its obsolete form you
        -:  266:		cannot use -S "STRING", but in its standard form you
        -:  267:		must use -S "STRING" if STRING is empty.  Use
        -:  268:		--sep-string to avoid the ambiguity.
        -:  269:
        -:  270:   -t, --omit-header	Do not print headers or footers but retain form
        -:  271:		feeds set in the input files.
        -:  272:
        -:  273:   -T, --omit-pagination
        -:  274:		Do not print headers or footers, eliminate any pagination
        -:  275:		by form feeds set in the input files.
        -:  276:
        -:  277:   -v, --show-nonprinting
        -:  278:		Print unprintable characters as escape sequences. Use
        -:  279:		octal backslash notation. Control-G becomes \007.
        -:  280:
        -:  281:   -w PAGE_WIDTH, --width=PAGE_WIDTH
        -:  282:		Set page width to PAGE_WIDTH characters for multiple
        -:  283:		text-column output only (default for PAGE_WIDTH is 72).
        -:  284:		-s[CHAR] turns off the default page width and any line
        -:  285:		truncation. Lines of full length will be merged,
        -:  286:		regardless of the column options set. A POSIX compliant
        -:  287:		formulation.
        -:  288:
        -:  289:   -W PAGE_WIDTH, --page-width=PAGE_WIDTH
        -:  290:		Set the page width to PAGE_WIDTH characters. That's valid
        -:  291:		with and without a column option. Text lines will be
        -:  292:		truncated, unless -J is used. Together with one of the
        -:  293:		column options (-COLUMN| -a -COLUMN| -m) column alignment
        -:  294:		is always used.
        -:  295:		Default is 72 characters.
        -:  296:		Without -W PAGE_WIDTH
        -:  297:		- but with one of the column options default truncation of
        -:  298:		  72 characters is used (to keep downward compatibility
        -:  299:		  and to simplify most frequently met column tasks).
        -:  300:		  Column alignment and column separators are used.
        -:  301:		- and without any of the column options NO line truncation
        -:  302:		  is used (to keep downward compatibility and to meet most
        -:  303:		  frequent tasks). That's equivalent to  -W 72 -J .
        -:  304:
        -:  305:	        With/without  -W PAGE_WIDTH  the header line is always
        -:  306:		truncated to avoid line overflow.
        -:  307:
        -:  308:		(In pr versions newer than 1.14 -S option does no longer
        -:  309:		affect -W option.)
        -:  310:
        -:  311:*/
        -:  312:
        -:  313:
        -:  314:#include <config.h>
        -:  315:
        -:  316:#include <getopt.h>
        -:  317:#include <sys/types.h>
        -:  318:#include "system.h"
        -:  319:#include "error.h"
        -:  320:#include "hard-locale.h"
        -:  321:#include "inttostr.h"
        -:  322:#include "mbswidth.h"
        -:  323:#include "quote.h"
        -:  324:#include "stat-time.h"
        -:  325:#include "stdio--.h"
        -:  326:#include "strftime.h"
        -:  327:#include "xstrtol.h"
        -:  328:
        -:  329:/* The official name of this program (e.g., no `g' prefix).  */
        -:  330:#define PROGRAM_NAME "pr"
        -:  331:
        -:  332:#define AUTHORS "Pete TerMaat", "Roland Huebner"
        -:  333:
        -:  334:/* Used with start_position in the struct COLUMN described below.
        -:  335:   If start_position == ANYWHERE, we aren't truncating columns and
        -:  336:   can begin printing a column anywhere.  Otherwise we must pad to
        -:  337:   the horizontal position start_position. */
        -:  338:#define ANYWHERE	0
        -:  339:
        -:  340:/* Each column has one of these structures allocated for it.
        -:  341:   If we're only dealing with one file, fp is the same for all
        -:  342:   columns.
        -:  343:
        -:  344:   The general strategy is to spend time setting up these column
        -:  345:   structures (storing columns if necessary), after which printing
        -:  346:   is a matter of flitting from column to column and calling
        -:  347:   print_func.
        -:  348:
        -:  349:   Parallel files, single files printing across in multiple
        -:  350:   columns, and single files printing down in multiple columns all
        -:  351:   fit the same printing loop.
        -:  352:
        -:  353:   print_func		Function used to print lines in this column.
        -:  354:			If we're storing this column it will be
        -:  355:			print_stored(), Otherwise it will be read_line().
        -:  356:
        -:  357:   char_func		Function used to process characters in this column.
        -:  358:			If we're storing this column it will be store_char(),
        -:  359:			otherwise it will be print_char().
        -:  360:
        -:  361:   current_line		Index of the current entry in line_vector, which
        -:  362:			contains the index of the first character of the
        -:  363:			current line in buff[].
        -:  364:
        -:  365:   lines_stored		Number of lines in this column which are stored in
        -:  366:			buff.
        -:  367:
        -:  368:   lines_to_print	If we're storing this column, lines_to_print is
        -:  369:			the number of stored_lines which remain to be
        -:  370:			printed.  Otherwise it is the number of lines
        -:  371:			we can print without exceeding lines_per_body.
        -:  372:
        -:  373:   start_position	The horizontal position we want to be in before we
        -:  374:			print the first character in this column.
        -:  375:
        -:  376:   numbered		True means precede this column with a line number. */
        -:  377:
        -:  378:/* FIXME: There are many unchecked integer overflows in this file,
        -:  379:   that will cause this command to misbehave given large inputs or
        -:  380:   options.  Many of the "int" values below should be "size_t" or
        -:  381:   something else like that.  */
        -:  382:
        -:  383:struct COLUMN;
        -:  384:struct COLUMN
        -:  385:  {
        -:  386:    FILE *fp;			/* Input stream for this column. */
        -:  387:    char const *name;		/* File name. */
        -:  388:    enum
        -:  389:      {
        -:  390:	OPEN,
        -:  391:	FF_FOUND,		/* used with -b option, set with \f, changed
        -:  392:				   to ON_HOLD after print_header */
        -:  393:	ON_HOLD,		/* Hit a form feed. */
        -:  394:	CLOSED
        -:  395:      }
        -:  396:    status;			/* Status of the file pointer. */
        -:  397:
        -:  398:    /* Func to print lines in this col. */
        -:  399:    bool (*print_func) (struct COLUMN *);
        -:  400:
        -:  401:    /* Func to print/store chars in this col. */
        -:  402:    void (*char_func) (char);
        -:  403:
        -:  404:    int current_line;		/* Index of current place in line_vector. */
        -:  405:    int lines_stored;		/* Number of lines stored in buff. */
        -:  406:    int lines_to_print;		/* No. lines stored or space left on page. */
        -:  407:    int start_position;		/* Horizontal position of first char. */
        -:  408:    bool numbered;
        -:  409:    bool full_page_printed;	/* True means printed without a FF found. */
        -:  410:
        -:  411:    /* p->full_page_printed  controls a special case of "FF set by hand":
        -:  412:       True means a full page has been printed without FF found. To avoid an
        -:  413:       additional empty page we have to ignore a FF immediately following in
        -:  414:       the next line. */
        -:  415:  };
        -:  416:
        -:  417:typedef struct COLUMN COLUMN;
        -:  418:
        -:  419:#define NULLCOL (COLUMN *)0
        -:  420:
        -:  421:static int char_to_clump (char c);
        -:  422:static bool read_line (COLUMN *p);
        -:  423:static bool print_page (void);
        -:  424:static bool print_stored (COLUMN *p);
        -:  425:static bool open_file (char *name, COLUMN *p);
        -:  426:static bool skip_to_page (uintmax_t page);
        -:  427:static void print_header (void);
        -:  428:static void pad_across_to (int position);
        -:  429:static void add_line_number (COLUMN *p);
        -:  430:static void getoptarg (char *arg, char switch_char, char *character,
        -:  431:		       int *number);
        -:  432:void usage (int status);
        -:  433:static void print_files (int number_of_files, char **av);
        -:  434:static void init_parameters (int number_of_files);
        -:  435:static void init_header (char const *filename, int desc);
        -:  436:static bool init_fps (int number_of_files, char **av);
        -:  437:static void init_funcs (void);
        -:  438:static void init_store_cols (void);
        -:  439:static void store_columns (void);
        -:  440:static void balance (int total_stored);
        -:  441:static void store_char (char c);
        -:  442:static void pad_down (int lines);
        -:  443:static void read_rest_of_line (COLUMN *p);
        -:  444:static void skip_read (COLUMN *p, int column_number);
        -:  445:static void print_char (char c);
        -:  446:static void cleanup (void);
        -:  447:static void print_sep_string (void);
        -:  448:static void separator_string (const char *optarg_S);
        -:  449:
        -:  450:/* The name under which this program was invoked. */
        -:  451:char *program_name;
        -:  452:
        -:  453:/* All of the columns to print.  */
        -:  454:static COLUMN *column_vector;
        -:  455:
        -:  456:/* When printing a single file in multiple downward columns,
        -:  457:   we store the leftmost columns contiguously in buff.
        -:  458:   To print a line from buff, get the index of the first character
        -:  459:   from line_vector[i], and print up to line_vector[i + 1]. */
        -:  460:static char *buff;
        -:  461:
        -:  462:/* Index of the position in buff where the next character
        -:  463:   will be stored. */
        -:  464:static int buff_current;
        -:  465:
        -:  466:/* The number of characters in buff.
        -:  467:   Used for allocation of buff and to detect overflow of buff. */
        -:  468:static size_t buff_allocated;
        -:  469:
        -:  470:/* Array of indices into buff.
        -:  471:   Each entry is an index of the first character of a line.
        -:  472:   This is used when storing lines to facilitate shuffling when
        -:  473:   we do column balancing on the last page. */
        -:  474:static int *line_vector;
        -:  475:
        -:  476:/* Array of horizonal positions.
        -:  477:   For each line in line_vector, end_vector[line] is the horizontal
        -:  478:   position we are in after printing that line.  We keep track of this
        -:  479:   so that we know how much we need to pad to prepare for the next
        -:  480:   column. */
        -:  481:static int *end_vector;
        -:  482:
        -:  483:/* (-m) True means we're printing multiple files in parallel. */
        -:  484:static bool parallel_files = false;
        -:  485:
        -:  486:/* (-m) True means a line starts with some empty columns (some files
        -:  487:   already CLOSED or ON_HOLD) which we have to align. */
        -:  488:static bool align_empty_cols;
        -:  489:
        -:  490:/* (-m) True means we have not yet found any printable column in a line.
        -:  491:   align_empty_cols = true  has to be maintained. */
        -:  492:static bool empty_line;
        -:  493:
        -:  494:/* (-m) False means printable column output precedes a form feed found.
        -:  495:   Column alignment is done only once. No additional action with that form
        -:  496:   feed.
        -:  497:   True means we found only a form feed in a column. Maybe we have to do
        -:  498:   some column alignment with that form feed. */
        -:  499:static bool FF_only;
        -:  500:
        -:  501:/* (-[0-9]+) True means we're given an option explicitly specifying
        -:  502:   number of columns.  Used to detect when this option is used with -m
        -:  503:   and when translating old options to new/long options. */
        -:  504:static bool explicit_columns = false;
        -:  505:
        -:  506:/* (-t|-T) False means we aren't printing headers and footers. */
        -:  507:static bool extremities = true;
        -:  508:
        -:  509:/* (-t) True means we retain all FF set by hand in input files.
        -:  510:   False is set with -T option. */
        -:  511:static bool keep_FF = false;
        -:  512:static bool print_a_FF = false;
        -:  513:
        -:  514:/* True means we need to print a header as soon as we know we've got input
        -:  515:   to print after it. */
        -:  516:static bool print_a_header;
        -:  517:
        -:  518:/* (-f) True means use formfeeds instead of newlines to separate pages. */
        -:  519:static bool use_form_feed = false;
        -:  520:
        -:  521:/* True means we have read the standard input. */
        -:  522:static bool have_read_stdin = false;
        -:  523:
        -:  524:/* True means the -a flag has been given. */
        -:  525:static bool print_across_flag = false;
        -:  526:
        -:  527:/* True means we're printing one file in multiple (>1) downward columns. */
        -:  528:static bool storing_columns = true;
        -:  529:
        -:  530:/* (-b) True means balance columns on the last page as Sys V does. */
        -:  531:/* That's no longer an independent option. With storing_columns = true
        -:  532:   balance_columns = true is used too (s. function init_parameters).
        -:  533:   We get a consistent formulation with "FF set by hand" in input files. */
        -:  534:static bool balance_columns = false;
        -:  535:
        -:  536:/* (-l) Number of lines on a page, including header and footer lines. */
        -:  537:static int lines_per_page = 66;
        -:  538:
        -:  539:/* Number of lines in the header and footer can be reset to 0 using
        -:  540:   the -t flag. */
        -:  541:enum { lines_per_header = 5 };
        -:  542:static int lines_per_body;
        -:  543:enum { lines_per_footer = 5 };
        -:  544:
        -:  545:/* (-w|-W) Width in characters of the page.  Does not include the width of
        -:  546:   the margin. */
        -:  547:static int chars_per_line = 72;
        -:  548:
        -:  549:/* (-w|W) True means we truncate lines longer than chars_per_column. */
        -:  550:static bool truncate_lines = false;
        -:  551:
        -:  552:/* (-J) True means we join lines without any line truncation. -J
        -:  553:   dominates -w option. */
        -:  554:static bool join_lines = false;
        -:  555:
        -:  556:/* Number of characters in a column.  Based on col_sep_length and
        -:  557:   page width. */
        -:  558:static int chars_per_column;
        -:  559:
        -:  560:/* (-e) True means convert tabs to spaces on input. */
        -:  561:static bool untabify_input = false;
        -:  562:
        -:  563:/* (-e) The input tab character. */
        -:  564:static char input_tab_char = '\t';
        -:  565:
        -:  566:/* (-e) Tabstops are at chars_per_tab, 2*chars_per_tab, 3*chars_per_tab, ...
        -:  567:   where the leftmost column is 1. */
        -:  568:static int chars_per_input_tab = 8;
        -:  569:
        -:  570:/* (-i) True means convert spaces to tabs on output. */
        -:  571:static bool tabify_output = false;
        -:  572:
        -:  573:/* (-i) The output tab character. */
        -:  574:static char output_tab_char = '\t';
        -:  575:
        -:  576:/* (-i) The width of the output tab. */
        -:  577:static int chars_per_output_tab = 8;
        -:  578:
        -:  579:/* Keeps track of pending white space.  When we hit a nonspace
        -:  580:   character after some whitespace, we print whitespace, tabbing
        -:  581:   if necessary to get to output_position + spaces_not_printed. */
        -:  582:static int spaces_not_printed;
        -:  583:
        -:  584:/* (-o) Number of spaces in the left margin (tabs used when possible). */
        -:  585:static int chars_per_margin = 0;
        -:  586:
        -:  587:/* Position where the next character will fall.
        -:  588:   Leftmost position is 0 + chars_per_margin.
        -:  589:   Rightmost position is chars_per_margin + chars_per_line - 1.
        -:  590:   This is important for converting spaces to tabs on output. */
        -:  591:static int output_position;
        -:  592:
        -:  593:/* Horizontal position relative to the current file.
        -:  594:   (output_position depends on where we are on the page;
        -:  595:   input_position depends on where we are in the file.)
        -:  596:   Important for converting tabs to spaces on input. */
        -:  597:static int input_position;
        -:  598:
        -:  599:/* True if there were any failed opens so we can exit with nonzero
        -:  600:   status.  */
        -:  601:static bool failed_opens = false;
        -:  602:
        -:  603:/* The number of spaces taken up if we print a tab character with width
        -:  604:   c_ from position h_. */
        -:  605:#define TAB_WIDTH(c_, h_) ((c_) - ((h_) % (c_)))
        -:  606:
        -:  607:/* The horizontal position we'll be at after printing a tab character
        -:  608:   of width c_ from the position h_. */
        -:  609:#define POS_AFTER_TAB(c_, h_) ((h_) + TAB_WIDTH (c_, h_))
        -:  610:
        -:  611:/* (-NNN) Number of columns of text to print. */
        -:  612:static int columns = 1;
        -:  613:
        -:  614:/* (+NNN:MMM) Page numbers on which to begin and stop printing.
        -:  615:   first_page_number = 0  will be used to check input only. */
        -:  616:static uintmax_t first_page_number = 0;
        -:  617:static uintmax_t last_page_number = UINTMAX_MAX;
        -:  618:
        -:  619:/* Number of files open (not closed, not on hold). */
        -:  620:static int files_ready_to_read = 0;
        -:  621:
        -:  622:/* Current page number.  Displayed in header. */
        -:  623:static uintmax_t page_number;
        -:  624:
        -:  625:/* Current line number.  Displayed when -n flag is specified.
        -:  626:
        -:  627:   When printing files in parallel (-m flag), line numbering is as follows:
        -:  628:   1    foo     goo     moo
        -:  629:   2    hoo     too     zoo
        -:  630:
        -:  631:   When printing files across (-a flag), ...
        -:  632:   1    foo     2       moo     3       goo
        -:  633:   4    hoo     5       too     6       zoo
        -:  634:
        -:  635:   Otherwise, line numbering is as follows:
        -:  636:   1    foo     3       goo     5       too
        -:  637:   2    moo     4       hoo     6       zoo */
        -:  638:static int line_number;
        -:  639:
        -:  640:/* With line_number overflow, we use power_10 to cut off the higher-order
        -:  641:   digits of the line_number */
        -:  642:static int power_10;
        -:  643:
        -:  644:/* (-n) True means lines should be preceded by numbers. */
        -:  645:static bool numbered_lines = false;
        -:  646:
        -:  647:/* (-n) Character which follows each line number. */
        -:  648:static char number_separator = '\t';
        -:  649:
        -:  650:/* (-n) line counting starts with 1st line of input file (not with 1st
        -:  651:   line of 1st page printed). */
        -:  652:static int line_count = 1;
        -:  653:
        -:  654:/* (-n) True means counting of skipped lines starts with 1st line of
        -:  655:   input file. False means -N option is used in addition, counting of
        -:  656:   skipped lines not required. */
        -:  657:static bool skip_count = true;
        -:  658:
        -:  659:/* (-N) Counting starts with start_line_number = NUMBER at 1st line of
        -:  660:   first page printed, usually not 1st page of input file. */
        -:  661:static int start_line_num = 1;
        -:  662:
        -:  663:/* (-n) Width in characters of a line number. */
        -:  664:static int chars_per_number = 5;
        -:  665:
        -:  666:/* Used when widening the first column to accommodate numbers -- only
        -:  667:   needed when printing files in parallel.  Includes width of both the
        -:  668:   number and the number_separator. */
        -:  669:static int number_width;
        -:  670:
        -:  671:/* Buffer sprintf uses to format a line number. */
        -:  672:static char *number_buff;
        -:  673:
        -:  674:/* (-v) True means unprintable characters are printed as escape sequences.
        -:  675:   control-g becomes \007. */
        -:  676:static bool use_esc_sequence = false;
        -:  677:
        -:  678:/* (-c) True means unprintable characters are printed as control prefixes.
        -:  679:   control-g becomes ^G. */
        -:  680:static bool use_cntrl_prefix = false;
        -:  681:
        -:  682:/* (-d) True means output is double spaced. */
        -:  683:static bool double_space = false;
        -:  684:
        -:  685:/* Number of files opened initially in init_files.  Should be 1
        -:  686:   unless we're printing multiple files in parallel. */
        -:  687:static int total_files = 0;
        -:  688:
        -:  689:/* (-r) True means don't complain if we can't open a file. */
        -:  690:static bool ignore_failed_opens = false;
        -:  691:
        -:  692:/* (-S) True means we separate columns with a specified string.
        -:  693:   -S option does not affect line truncation nor column alignment. */
        -:  694:static bool use_col_separator = false;
        -:  695:
        -:  696:/* String used to separate columns if the -S option has been specified.
        -:  697:   Default without -S but together with one of the column options
        -:  698:   -a|COLUMN|-m is a `space' and with the -J option a `tab'. */
        -:  699:static char *col_sep_string = "";
        -:  700:static int col_sep_length = 0;
        -:  701:static char *column_separator = " ";
        -:  702:static char *line_separator = "\t";
        -:  703:
        -:  704:/* Number of separator characters waiting to be printed as soon as we
        -:  705:   know that we have any input remaining to be printed. */
        -:  706:static int separators_not_printed;
        -:  707:
        -:  708:/* Position we need to pad to, as soon as we know that we have input
        -:  709:   remaining to be printed. */
        -:  710:static int padding_not_printed;
        -:  711:
        -:  712:/* True means we should pad the end of the page.  Remains false until we
        -:  713:   know we have a page to print. */
        -:  714:static bool pad_vertically;
        -:  715:
        -:  716:/* (-h) String of characters used in place of the filename in the header. */
        -:  717:static char *custom_header;
        -:  718:
        -:  719:/* (-D) Date format for the header.  */
        -:  720:static char const *date_format;
        -:  721:
        -:  722:/* Date and file name for the header.  */
        -:  723:static char *date_text;
        -:  724:static char const *file_text;
        -:  725:
        -:  726:/* Output columns available, not counting the date and file name.  */
        -:  727:static int header_width_available;
        -:  728:
        -:  729:static char *clump_buff;
        -:  730:
        -:  731:/* True means we read the line no. lines_per_body in skip_read
        -:  732:   called by skip_to_page. That variable controls the coincidence of a
        -:  733:   "FF set by hand" and "full_page_printed", see above the definition of
        -:  734:   structure COLUMN. */
        -:  735:static bool last_line = false;
        -:  736:
        -:  737:/* For long options that have no equivalent short option, use a
        -:  738:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  739:enum
        -:  740:{
        -:  741:  COLUMNS_OPTION = CHAR_MAX + 1,
        -:  742:  PAGES_OPTION
        -:  743:};
        -:  744:
        -:  745:static char const short_options[] =
        -:  746:  "-0123456789D:FJN:S::TW:abcde::fh:i::l:mn::o:rs::tvw:";
        -:  747:
        -:  748:static struct option const long_options[] =
        -:  749:{
        -:  750:  {"pages", required_argument, NULL, PAGES_OPTION},
        -:  751:  {"columns", required_argument, NULL, COLUMNS_OPTION},
        -:  752:  {"across", no_argument, NULL, 'a'},
        -:  753:  {"show-control-chars", no_argument, NULL, 'c'},
        -:  754:  {"double-space", no_argument, NULL, 'd'},
        -:  755:  {"date-format", required_argument, NULL, 'D'},
        -:  756:  {"expand-tabs", optional_argument, NULL, 'e'},
        -:  757:  {"form-feed", no_argument, NULL, 'f'},
        -:  758:  {"header", required_argument, NULL, 'h'},
        -:  759:  {"output-tabs", optional_argument, NULL, 'i'},
        -:  760:  {"join-lines", no_argument, NULL, 'J'},
        -:  761:  {"length", required_argument, NULL, 'l'},
        -:  762:  {"merge", no_argument, NULL, 'm'},
        -:  763:  {"number-lines", optional_argument, NULL, 'n'},
        -:  764:  {"first-line-number", required_argument, NULL, 'N'},
        -:  765:  {"indent", required_argument, NULL, 'o'},
        -:  766:  {"no-file-warnings", no_argument, NULL, 'r'},
        -:  767:  {"separator", optional_argument, NULL, 's'},
        -:  768:  {"sep-string", optional_argument, NULL, 'S'},
        -:  769:  {"omit-header", no_argument, NULL, 't'},
        -:  770:  {"omit-pagination", no_argument, NULL, 'T'},
        -:  771:  {"show-nonprinting", no_argument, NULL, 'v'},
        -:  772:  {"width", required_argument, NULL, 'w'},
        -:  773:  {"page-width", required_argument, NULL, 'W'},
        -:  774:  {GETOPT_HELP_OPTION_DECL},
        -:  775:  {GETOPT_VERSION_OPTION_DECL},
        -:  776:  {NULL, 0, NULL, 0}
        -:  777:};
        -:  778:
        -:  779:/* Return the number of columns that have either an open file or
        -:  780:   stored lines. */
        -:  781:
        -:  782:static int
        -:  783:cols_ready_to_print (void)
    31106:  784:{
        -:  785:  COLUMN *q;
        -:  786:  int i;
        -:  787:  int n;
        -:  788:
    31106:  789:  n = 0;
    95112:  790:  for (q = column_vector, i = 0; i < columns; ++q, ++i)
    64006:  791:    if (q->status == OPEN ||
        -:  792:	q->status == FF_FOUND ||	/* With -b: To print a header only */
        -:  793:	(storing_columns && q->lines_stored > 0 && q->lines_to_print > 0))
    46206:  794:      ++n;
    31106:  795:  return n;
        -:  796:}
        -:  797:
        -:  798:/* Estimate first_ / last_page_number
        -:  799:   using option +FIRST_PAGE:LAST_PAGE */
        -:  800:
        -:  801:static bool
        -:  802:first_last_page (int oi, char c, char const *pages)
      134:  803:{
        -:  804:  char *p;
        -:  805:  uintmax_t first;
      134:  806:  uintmax_t last = UINTMAX_MAX;
      134:  807:  strtol_error err = xstrtoumax (pages, &p, 10, &first, "");
      134:  808:  if (err != LONGINT_OK && err != LONGINT_INVALID_SUFFIX_CHAR)
        3:  809:    xstrtol_fatal (err, oi, c, long_options, pages);
        -:  810:
      131:  811:  if (p == pages || !first)
    #####:  812:    return false;
        -:  813:
      131:  814:  if (*p == ':')
        -:  815:    {
        9:  816:      char const *p1 = p + 1;
        9:  817:      err = xstrtoumax (p1, &p, 10, &last, "");
        9:  818:      if (err != LONGINT_OK)
        1:  819:	xstrtol_fatal (err, oi, c, long_options, pages);
        8:  820:      if (p1 == p || last < first)
    #####:  821:	return false;
        -:  822:    }
        -:  823:
      130:  824:  if (*p)
        1:  825:    return false;
        -:  826:
      129:  827:  first_page_number = first;
      129:  828:  last_page_number = last;
      129:  829:  return true;
        -:  830:}
        -:  831:
        -:  832:/* Parse column count string S, and if it's valid (1 or larger and
        -:  833:   within range of the type of `columns') set the global variables
        -:  834:   columns and explicit_columns and return true.
        -:  835:   Otherwise, exit with a diagnostic.  */
        -:  836:static void
        -:  837:parse_column_count (char const *s)
      283:  838:{
        -:  839:  long int tmp_long;
      283:  840:  if (xstrtol (s, NULL, 10, &tmp_long, "") != LONGINT_OK
        -:  841:      || !(1 <= tmp_long && tmp_long <= INT_MAX))
        4:  842:    error (EXIT_FAILURE, 0,
        -:  843:	   _("invalid number of columns: %s"), quote (s));
        -:  844:
      279:  845:  columns = tmp_long;
      279:  846:  explicit_columns = true;
      279:  847:}
        -:  848:
        -:  849:/* Estimate length of col_sep_string with option -S.  */
        -:  850:
        -:  851:static void
        -:  852:separator_string (const char *optarg_S)
       30:  853:{
       30:  854:  col_sep_length = (int) strlen (optarg_S);
       30:  855:  col_sep_string = xmalloc (col_sep_length + 1);
       30:  856:  strcpy (col_sep_string, optarg_S);
       30:  857:}
        -:  858:
        -:  859:int
        -:  860:main (int argc, char **argv)
      408:  861:{
        -:  862:  int n_files;
      408:  863:  bool old_options = false;
      408:  864:  bool old_w = false;
      408:  865:  bool old_s = false;
        -:  866:  char **file_names;
        -:  867:
        -:  868:  /* Accumulate the digits of old-style options like -99.  */
      408:  869:  char *column_count_string = NULL;
      408:  870:  size_t n_digits = 0;
      408:  871:  size_t n_alloc = 0;
        -:  872:
        -:  873:  initialize_main (&argc, &argv);
      408:  874:  program_name = argv[0];
      408:  875:  setlocale (LC_ALL, "");
        -:  876:  bindtextdomain (PACKAGE, LOCALEDIR);
        -:  877:  textdomain (PACKAGE);
        -:  878:
      408:  879:  atexit (close_stdout);
        -:  880:
      408:  881:  n_files = 0;
      408:  882:  file_names = (argc > 1
        -:  883:		? xmalloc ((argc - 1) * sizeof (char *))
        -:  884:		: NULL);
        -:  885:
        -:  886:  for (;;)
        -:  887:    {
     3187:  888:      int oi = -1;
     3187:  889:      int c = getopt_long (argc, argv, short_options, long_options, &oi);
     3187:  890:      if (c == -1)
      395:  891:	break;
        -:  892:
     2792:  893:      if (ISDIGIT (c))
        -:  894:	{
        -:  895:	  /* Accumulate column-count digits specified via old-style options. */
      241:  896:	  if (n_digits + 1 >= n_alloc)
      143:  897:	    column_count_string
        -:  898:	      = X2REALLOC (column_count_string, &n_alloc);
      241:  899:	  column_count_string[n_digits++] = c;
      241:  900:	  column_count_string[n_digits] = '\0';
      241:  901:	  continue;
        -:  902:	}
        -:  903:
     2551:  904:      n_digits = 0;
        -:  905:
     2551:  906:      switch (c)
        -:  907:	{
        -:  908:	case 1:			/* Non-option argument. */
        -:  909:	  /* long option --page dominates old `+FIRST_PAGE ...'.  */
      568:  910:	  if (! (first_page_number == 0
        -:  911:		 && *optarg == '+' && first_last_page (-2, '+', optarg + 1)))
      439:  912:	    file_names[n_files++] = optarg;
      568:  913:	  break;
        -:  914:
        -:  915:	case PAGES_OPTION:	/* --pages=FIRST_PAGE[:LAST_PAGE] */
        -:  916:	  {			/* dominates old opt +... */
        5:  917:	    if (! optarg)
    #####:  918:	      error (EXIT_FAILURE, 0,
        -:  919:		     _("`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"));
        5:  920:	    else if (! first_last_page (oi, 0, optarg))
        1:  921:	      error (EXIT_FAILURE, 0, _("Invalid page range %s"),
        -:  922:		     quote (optarg));
    #####:  923:	    break;
        -:  924:	  }
        -:  925:
        -:  926:	case COLUMNS_OPTION:	/* --columns=COLUMN */
        -:  927:	  {
      144:  928:	    parse_column_count (optarg);
        -:  929:
        -:  930:	    /* If there was a prior column count specified via the
        -:  931:	       short-named option syntax, e.g., -9, ensure that this
        -:  932:	       long-name-specified value overrides it.  */
      142:  933:	    free (column_count_string);
      142:  934:	    column_count_string = NULL;
      142:  935:	    n_alloc = 0;
      142:  936:	    break;
        -:  937:	  }
        -:  938:
        -:  939:	case 'a':
      106:  940:	  print_across_flag = true;
      106:  941:	  storing_columns = false;
      106:  942:	  break;
        -:  943:	case 'b':
      124:  944:	  balance_columns = true;
      124:  945:	  break;
        -:  946:	case 'c':
    #####:  947:	  use_cntrl_prefix = true;
    #####:  948:	  break;
        -:  949:	case 'd':
        2:  950:	  double_space = true;
        2:  951:	  break;
        -:  952:	case 'D':
      396:  953:	  date_format = optarg;
      396:  954:	  break;
        -:  955:	case 'e':
       14:  956:	  if (optarg)
       14:  957:	    getoptarg (optarg, 'e', &input_tab_char,
        -:  958:		       &chars_per_input_tab);
        -:  959:	  /* Could check tab width > 0. */
       14:  960:	  untabify_input = true;
       14:  961:	  break;
        -:  962:	case 'f':
        -:  963:	case 'F':
      197:  964:	  use_form_feed = true;
      197:  965:	  break;
        -:  966:	case 'h':
      399:  967:	  custom_header = optarg;
      399:  968:	  break;
        -:  969:	case 'i':
        2:  970:	  if (optarg)
        2:  971:	    getoptarg (optarg, 'i', &output_tab_char,
        -:  972:		       &chars_per_output_tab);
        -:  973:	  /* Could check tab width > 0. */
        2:  974:	  tabify_output = true;
        2:  975:	  break;
        -:  976:	case 'J':
       20:  977:	  join_lines = true;
       20:  978:	  break;
        -:  979:	case 'l':
        -:  980:	  {
        -:  981:	    long int tmp_long;
      261:  982:	    if (xstrtol (optarg, NULL, 10, &tmp_long, "") != LONGINT_OK
        -:  983:		|| tmp_long <= 0 || tmp_long > INT_MAX)
        -:  984:	      {
    #####:  985:		error (EXIT_FAILURE, 0,
        -:  986:		       _("`-l PAGE_LENGTH' invalid number of lines: %s"),
        -:  987:		       quote (optarg));
        -:  988:	      }
      261:  989:	    lines_per_page = tmp_long;
      261:  990:	    break;
        -:  991:	  }
        -:  992:	case 'm':
       36:  993:	  parallel_files = true;
       36:  994:	  storing_columns = false;
       36:  995:	  break;
        -:  996:	case 'n':
       99:  997:	  numbered_lines = true;
       99:  998:	  if (optarg)
       87:  999:	    getoptarg (optarg, 'n', &number_separator,
        -: 1000:		       &chars_per_number);
       99: 1001:	  break;
        -: 1002:	case 'N':
        4: 1003:	  skip_count = false;
        -: 1004:	  {
        -: 1005:	    long int tmp_long;
        4: 1006:	    if (xstrtol (optarg, NULL, 10, &tmp_long, "") != LONGINT_OK
        -: 1007:		|| tmp_long > INT_MAX)
        -: 1008:	      {
    #####: 1009:		error (EXIT_FAILURE, 0,
        -: 1010:		       _("`-N NUMBER' invalid starting line number: %s"),
        -: 1011:		       quote (optarg));
        -: 1012:	      }
        4: 1013:	    start_line_num = tmp_long;
        4: 1014:	    break;
        -: 1015:	  }
        -: 1016:	case 'o':
        -: 1017:	  {
        -: 1018:	    long int tmp_long;
       23: 1019:	    if (xstrtol (optarg, NULL, 10, &tmp_long, "") != LONGINT_OK
        -: 1020:		|| tmp_long < 0 || tmp_long > INT_MAX)
    #####: 1021:	      error (EXIT_FAILURE, 0,
        -: 1022:		     _("`-o MARGIN' invalid line offset: %s"), quote (optarg));
       23: 1023:	    chars_per_margin = tmp_long;
       23: 1024:	    break;
        -: 1025:	  }
        -: 1026:	case 'r':
    #####: 1027:	  ignore_failed_opens = true;
    #####: 1028:	  break;
        -: 1029:	case 's':
        9: 1030:	  old_options = true;
        9: 1031:	  old_s = true;
        9: 1032:	  if (!use_col_separator && optarg)
        4: 1033:	    separator_string (optarg);
        9: 1034:	  break;
        -: 1035:	case 'S':
       30: 1036:	  old_s = false;
        -: 1037:	  /* Reset an additional input of -s, -S dominates -s */
       30: 1038:	  col_sep_string = "";
       30: 1039:	  col_sep_length = 0;
       30: 1040:	  use_col_separator = true;
       30: 1041:	  if (optarg)
       26: 1042:	    separator_string (optarg);
       30: 1043:	  break;
        -: 1044:	case 't':
       47: 1045:	  extremities = false;
       47: 1046:	  keep_FF = true;
       47: 1047:	  break;
        -: 1048:	case 'T':
       19: 1049:	  extremities = false;
       19: 1050:	  keep_FF = false;
       19: 1051:	  break;
        -: 1052:	case 'v':
    #####: 1053:	  use_esc_sequence = true;
    #####: 1054:	  break;
        -: 1055:	case 'w':
       10: 1056:	  old_options = true;
       10: 1057:	  old_w = true;
        -: 1058:	  {
        -: 1059:	    long int tmp_long;
       10: 1060:	    if (xstrtol (optarg, NULL, 10, &tmp_long, "") != LONGINT_OK
        -: 1061:	        || tmp_long <= 0 || tmp_long > INT_MAX)
    #####: 1062:	      error (EXIT_FAILURE, 0,
        -: 1063:		     _("`-w PAGE_WIDTH' invalid number of characters: %s"),
        -: 1064:		     quote (optarg));
       10: 1065:	    if (!truncate_lines)
       10: 1066:	      chars_per_line = tmp_long;
       10: 1067:	    break;
        -: 1068:	  }
        -: 1069:	case 'W':
       30: 1070:	  old_w = false;			/* dominates -w */
       30: 1071:	  truncate_lines = true;
        -: 1072:	  {
        -: 1073:	    long int tmp_long;
       30: 1074:	    if (xstrtol (optarg, NULL, 10, &tmp_long, "") != LONGINT_OK
        -: 1075:		|| tmp_long <= 0 || tmp_long > INT_MAX)
    #####: 1076:	      error (EXIT_FAILURE, 0,
        -: 1077:		     _("`-W PAGE_WIDTH' invalid number of characters: %s"),
        -: 1078:		     quote (optarg));
       30: 1079:	    chars_per_line = tmp_long;
       30: 1080:	    break;
        -: 1081:	  }
        3: 1082:	case_GETOPT_HELP_CHAR;
        3: 1083:	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -: 1084:	default:
    #####: 1085:	  usage (EXIT_FAILURE);
        -: 1086:	  break;
        -: 1087:	}
     2779: 1088:    }
        -: 1089:
      395: 1090:  if (column_count_string)
        -: 1091:    {
      139: 1092:      parse_column_count (column_count_string);
      137: 1093:      free (column_count_string);
        -: 1094:    }
        -: 1095:
      393: 1096:  if (! date_format)
        2: 1097:    date_format = (getenv ("POSIXLY_CORRECT") && !hard_locale (LC_TIME)
        -: 1098:		   ? "%b %e %H:%M %Y"
        -: 1099:		   : "%Y-%m-%d %H:%M");
        -: 1100:
        -: 1101:  /* Now we can set a reasonable initial value: */
      393: 1102:  if (first_page_number == 0)
      264: 1103:    first_page_number = 1;
        -: 1104:
      393: 1105:  if (parallel_files & explicit_columns)
    #####: 1106:    error (EXIT_FAILURE, 0,
        -: 1107:	 _("Cannot specify number of columns when printing in parallel."));
        -: 1108:
      393: 1109:  if (parallel_files & print_across_flag)
    #####: 1110:    error (EXIT_FAILURE, 0,
        -: 1111:       _("Cannot specify both printing across and printing in parallel."));
        -: 1112:
        -: 1113:/* Translate some old short options to new/long options.
        -: 1114:   To meet downward compatibility with other UNIX pr utilities
        -: 1115:   and some POSIX specifications. */
        -: 1116:
      393: 1117:  if (old_options)
        -: 1118:    {
       15: 1119:      if (old_w)
        -: 1120:        {
       10: 1121:          if (parallel_files | explicit_columns)
        -: 1122:	    {
        -: 1123:	      /* activate -W */
        8: 1124:	      truncate_lines = true;
        8: 1125:	      if (old_s)
        -: 1126:	        /* adapt HP-UX and SunOS: -s = no separator;
        -: 1127:	           activate -S */
        4: 1128:	        use_col_separator = true;
        -: 1129:	    }
        -: 1130:	  else
        -: 1131:	    /* old -w sets width with columns only
        -: 1132:	       activate -J */
        2: 1133:	    join_lines = true;
        -: 1134:	}
        5: 1135:      else if (!use_col_separator)
        -: 1136:        {
        -: 1137:	  /* No -S option read */
        5: 1138:          if (old_s & (parallel_files | explicit_columns))
        -: 1139:	    {
        5: 1140:	      if (!truncate_lines)
        -: 1141:		{
        -: 1142:		  /* old -s (without -w and -W) annuls column alignment,
        -: 1143:		  uses fields, activate -J */
        5: 1144:		  join_lines = true;
        5: 1145:		  if (col_sep_length > 0)
        -: 1146:		    /* activate -S */
        2: 1147:		    use_col_separator = true;
        -: 1148:		}
        -: 1149:	      else
        -: 1150:		/* with -W */
        -: 1151:		/* adapt HP-UX and SunOS: -s = no separator;
        -: 1152:		   activate -S */
    #####: 1153:		use_col_separator = true;
        -: 1154:	    }
        -: 1155:	}
        -: 1156:    }
        -: 1157:
      393: 1158:  for (; optind < argc; optind++)
        -: 1159:    {
    #####: 1160:      file_names[n_files++] = argv[optind];
        -: 1161:    }
        -: 1162:
      393: 1163:  if (n_files == 0)
        -: 1164:    {
        -: 1165:      /* No file arguments specified;  read from standard input.  */
        1: 1166:      print_files (0, NULL);
        -: 1167:    }
        -: 1168:  else
        -: 1169:    {
      392: 1170:      if (parallel_files)
       36: 1171:	print_files (n_files, file_names);
        -: 1172:      else
        -: 1173:	{
        -: 1174:	  int i;
      712: 1175:	  for (i = 0; i < n_files; i++)
      356: 1176:	    print_files (1, &file_names[i]);
        -: 1177:	}
        -: 1178:    }
        -: 1179:
      393: 1180:  cleanup ();
        -: 1181:
      393: 1182:  if (have_read_stdin && fclose (stdin) == EOF)
    #####: 1183:    error (EXIT_FAILURE, errno, _("standard input"));
      393: 1184:  if (failed_opens)
    #####: 1185:    exit (EXIT_FAILURE);
      393: 1186:  exit (EXIT_SUCCESS);
        -: 1187:}
        -: 1188:
        -: 1189:/* Parse options of the form -scNNN.
        -: 1190:
        -: 1191:   Example: -nck, where 'n' is the option, c is the optional number
        -: 1192:   separator, and k is the optional width of the field used when printing
        -: 1193:   a number. */
        -: 1194:
        -: 1195:static void
        -: 1196:getoptarg (char *arg, char switch_char, char *character, int *number)
      103: 1197:{
      103: 1198:  if (!ISDIGIT (*arg))
       88: 1199:    *character = *arg++;
      103: 1200:  if (*arg)
        -: 1201:    {
        -: 1202:      long int tmp_long;
       94: 1203:      if (xstrtol (arg, NULL, 10, &tmp_long, "") != LONGINT_OK
        -: 1204:	  || tmp_long <= 0 || tmp_long > INT_MAX)
        -: 1205:	{
    #####: 1206:	  error (0, 0,
        -: 1207:	     _("`-%c' extra characters or invalid number in the argument: %s"),
        -: 1208:		 switch_char, quote (arg));
    #####: 1209:	  usage (EXIT_FAILURE);
        -: 1210:	}
       94: 1211:      *number = tmp_long;
        -: 1212:    }
      103: 1213:}
        -: 1214:
        -: 1215:/* Set parameters related to formatting. */
        -: 1216:
        -: 1217:static void
        -: 1218:init_parameters (int number_of_files)
      393: 1219:{
      393: 1220:  int chars_used_by_number = 0;
        -: 1221:
      393: 1222:  lines_per_body = lines_per_page - lines_per_header - lines_per_footer;
      393: 1223:  if (lines_per_body <= 0)
        -: 1224:    {
    #####: 1225:      extremities = false;
    #####: 1226:      keep_FF = true;
        -: 1227:    }
      393: 1228:  if (extremities == false)
       66: 1229:    lines_per_body = lines_per_page;
        -: 1230:
      393: 1231:  if (double_space)
        2: 1232:    lines_per_body = lines_per_body / 2;
        -: 1233:
        -: 1234:  /* If input is stdin, cannot print parallel files.  BSD dumps core
        -: 1235:     on this. */
      393: 1236:  if (number_of_files == 0)
        1: 1237:    parallel_files = false;
        -: 1238:
      393: 1239:  if (parallel_files)
       36: 1240:    columns = number_of_files;
        -: 1241:
        -: 1242:  /* One file, multi columns down: -b option is set to get a consistent
        -: 1243:     formulation with "FF set by hand" in input files. */
      393: 1244:  if (storing_columns)
      251: 1245:    balance_columns = true;
        -: 1246:
        -: 1247:  /* Tabification is assumed for multiple columns. */
      393: 1248:  if (columns > 1)
        -: 1249:    {
      311: 1250:      if (!use_col_separator)
        -: 1251:	{
        -: 1252:	  /* Use default separator */
      275: 1253:	  if (join_lines)
       17: 1254:	    col_sep_string = line_separator;
        -: 1255:	  else
      258: 1256:	    col_sep_string = column_separator;
        -: 1257:
      275: 1258:	  col_sep_length = 1;
      275: 1259:	  use_col_separator = true;
        -: 1260:	}
        -: 1261:      /* It's rather pointless to define a TAB separator with column
        -: 1262:         alignment */
       36: 1263:      else if (!join_lines && *col_sep_string == '\t')
    #####: 1264:        col_sep_string = column_separator;
        -: 1265:
      311: 1266:      truncate_lines = true;
      311: 1267:      tabify_output = true;
        -: 1268:    }
        -: 1269:  else
       82: 1270:    storing_columns = false;
        -: 1271:
        -: 1272:  /* -J dominates -w in any case */
      393: 1273:  if (join_lines)
       26: 1274:    truncate_lines = false;
        -: 1275:
      393: 1276:  if (numbered_lines)
        -: 1277:    {
        -: 1278:      int tmp_i;
       99: 1279:      int chars_per_default_tab = 8;
        -: 1280:
       99: 1281:      line_count = start_line_num;
        -: 1282:
        -: 1283:      /* To allow input tab-expansion (-e sensitive) use:
        -: 1284:	 if (number_separator == input_tab_char)
        -: 1285:	   number_width = chars_per_number +
        -: 1286:	     TAB_WIDTH (chars_per_input_tab, chars_per_number);   */
        -: 1287:
        -: 1288:      /* Estimate chars_per_text without any margin and keep it constant. */
       99: 1289:      if (number_separator == '\t')
       13: 1290:	number_width = chars_per_number +
        -: 1291:	  TAB_WIDTH (chars_per_default_tab, chars_per_number);
        -: 1292:      else
       86: 1293:	number_width = chars_per_number + 1;
        -: 1294:
        -: 1295:      /* The number is part of the column width unless we are
        -: 1296:	 printing files in parallel. */
       99: 1297:      if (parallel_files)
       12: 1298:	chars_used_by_number = number_width;
        -: 1299:
        -: 1300:      /* We use power_10 to cut off the higher-order digits of the
        -: 1301:         line_number in function add_line_number */
       99: 1302:      tmp_i = chars_per_number;
      436: 1303:      for (power_10 = 1; tmp_i > 0; --tmp_i)
      337: 1304:        power_10 = 10 * power_10;
        -: 1305:    }
        -: 1306:
      393: 1307:  chars_per_column = (chars_per_line - chars_used_by_number -
        -: 1308:		     (columns - 1) * col_sep_length) / columns;
        -: 1309:
      393: 1310:  if (chars_per_column < 1)
    #####: 1311:    error (EXIT_FAILURE, 0, _("page width too narrow"));
        -: 1312:
      393: 1313:  if (numbered_lines)
        -: 1314:    {
       99: 1315:      free (number_buff);
       99: 1316:      number_buff = xmalloc (2 * chars_per_number);
        -: 1317:    }
        -: 1318:
        -: 1319:  /* Pick the maximum between the tab width and the width of an
        -: 1320:     escape sequence.
        -: 1321:     The width of an escape sequence (4) isn't the lower limit any longer.
        -: 1322:     We've to use 8 as the lower limit, if we use chars_per_default_tab = 8
        -: 1323:     to expand a tab which is not an input_tab-char. */
      393: 1324:  free (clump_buff);
      393: 1325:  clump_buff = xmalloc (MAX (8, chars_per_input_tab));
      393: 1326:}
        -: 1327:
        -: 1328:/* Open the necessary files,
        -: 1329:   maintaining a COLUMN structure for each column.
        -: 1330:
        -: 1331:   With multiple files, each column p has a different p->fp.
        -: 1332:   With single files, each column p has the same p->fp.
        -: 1333:   Return false if (number_of_files > 0) and no files can be opened,
        -: 1334:   true otherwise.
        -: 1335:
        -: 1336:   With each column/file p, p->full_page_printed is initialized,
        -: 1337:   see also open_file.  */
        -: 1338:
        -: 1339:static bool
        -: 1340:init_fps (int number_of_files, char **av)
      393: 1341:{
        -: 1342:  int i, files_left;
        -: 1343:  COLUMN *p;
        -: 1344:  FILE *firstfp;
        -: 1345:  char const *firstname;
        -: 1346:
      393: 1347:  total_files = 0;
        -: 1348:
      393: 1349:  free (column_vector);
      393: 1350:  column_vector = xnmalloc (columns, sizeof (COLUMN));
        -: 1351:
      393: 1352:  if (parallel_files)
        -: 1353:    {
       36: 1354:      files_left = number_of_files;
      117: 1355:      for (p = column_vector; files_left--; ++p, ++av)
        -: 1356:	{
       81: 1357:	  if (! open_file (*av, p))
        -: 1358:	    {
    #####: 1359:	      --p;
    #####: 1360:	      --columns;
        -: 1361:	    }
        -: 1362:	}
       36: 1363:      if (columns == 0)
    #####: 1364:	return false;
       36: 1365:      init_header ("", -1);
        -: 1366:    }
        -: 1367:  else
        -: 1368:    {
      357: 1369:      p = column_vector;
      357: 1370:      if (number_of_files > 0)
        -: 1371:	{
      356: 1372:	  if (! open_file (*av, p))
    #####: 1373:	    return false;
      356: 1374:	  init_header (*av, fileno (p->fp));
      356: 1375:	  p->lines_stored = 0;
        -: 1376:	}
        -: 1377:      else
        -: 1378:	{
        1: 1379:	  p->name = _("standard input");
        1: 1380:	  p->fp = stdin;
        1: 1381:	  have_read_stdin = true;
        1: 1382:	  p->status = OPEN;
        1: 1383:	  p->full_page_printed = false;
        1: 1384:	  ++total_files;
        1: 1385:	  init_header ("", -1);
        1: 1386:	  p->lines_stored = 0;
        -: 1387:	}
        -: 1388:
      357: 1389:      firstname = p->name;
      357: 1390:      firstfp = p->fp;
      772: 1391:      for (i = columns - 1, ++p; i; --i, ++p)
        -: 1392:	{
      415: 1393:	  p->name = firstname;
      415: 1394:	  p->fp = firstfp;
      415: 1395:	  p->status = OPEN;
      415: 1396:	  p->full_page_printed = false;
      415: 1397:	  p->lines_stored = 0;
        -: 1398:	}
        -: 1399:    }
      393: 1400:  files_ready_to_read = total_files;
      393: 1401:  return true;
        -: 1402:}
        -: 1403:
        -: 1404:/* Determine print_func and char_func, the functions
        -: 1405:   used by each column for printing and/or storing.
        -: 1406:
        -: 1407:   Determine the horizontal position desired when we begin
        -: 1408:   printing a column (p->start_position). */
        -: 1409:
        -: 1410:static void
        -: 1411:init_funcs (void)
      393: 1412:{
        -: 1413:  int i, h, h_next;
        -: 1414:  COLUMN *p;
        -: 1415:
      393: 1416:  h = chars_per_margin;
        -: 1417:
      393: 1418:  if (!truncate_lines)
       99: 1419:    h_next = ANYWHERE;
        -: 1420:  else
        -: 1421:    {
        -: 1422:      /* When numbering lines of parallel files, we enlarge the
        -: 1423:         first column to accomodate the number.  Looks better than
        -: 1424:         the Sys V approach. */
      294: 1425:      if (parallel_files & numbered_lines)
       10: 1426:	h_next = h + chars_per_column + number_width;
        -: 1427:      else
      284: 1428:	h_next = h + chars_per_column;
        -: 1429:    }
        -: 1430:
        -: 1431:  /* Enlarge p->start_position of first column to use the same form of
        -: 1432:     padding_not_printed with all columns. */
      393: 1433:  h = h + col_sep_length;
        -: 1434:
        -: 1435:  /* This loop takes care of all but the rightmost column. */
        -: 1436:
      853: 1437:  for (p = column_vector, i = 1; i < columns; ++p, ++i)
        -: 1438:    {
      460: 1439:      if (storing_columns)	/* One file, multi columns down. */
        -: 1440:	{
      251: 1441:	  p->char_func = store_char;
      251: 1442:	  p->print_func = print_stored;
        -: 1443:	}
        -: 1444:      else
        -: 1445:	/* One file, multi columns across; or parallel files.  */
        -: 1446:	{
      209: 1447:	  p->char_func = print_char;
      209: 1448:	  p->print_func = read_line;
        -: 1449:	}
        -: 1450:
        -: 1451:      /* Number only the first column when printing files in
        -: 1452:         parallel. */
      460: 1453:      p->numbered = numbered_lines && (!parallel_files || i == 1);
      460: 1454:      p->start_position = h;
        -: 1455:
        -: 1456:      /* If we don't truncate lines, all start_positions are
        -: 1457:         ANYWHERE, except the first column's start_position when
        -: 1458:         using a margin. */
        -: 1459:
      460: 1460:      if (!truncate_lines)
        -: 1461:	{
       34: 1462:	  h = ANYWHERE;
       34: 1463:	  h_next = ANYWHERE;
        -: 1464:	}
        -: 1465:      else
        -: 1466:	{
      426: 1467:	  h = h_next + col_sep_length;
      426: 1468:	  h_next = h + chars_per_column;
        -: 1469:	}
        -: 1470:    }
        -: 1471:
        -: 1472:  /* The rightmost column.
        -: 1473:
        -: 1474:     Doesn't need to be stored unless we intend to balance
        -: 1475:     columns on the last page. */
      393: 1476:  if (storing_columns & balance_columns)
        -: 1477:    {
      169: 1478:      p->char_func = store_char;
      169: 1479:      p->print_func = print_stored;
        -: 1480:    }
        -: 1481:  else
        -: 1482:    {
      224: 1483:      p->char_func = print_char;
      224: 1484:      p->print_func = read_line;
        -: 1485:    }
        -: 1486:
      393: 1487:  p->numbered = numbered_lines && (!parallel_files || i == 1);
      393: 1488:  p->start_position = h;
      393: 1489:}
        -: 1490:
        -: 1491:/* Open a file.  Return true if successful.
        -: 1492:
        -: 1493:   With each file p, p->full_page_printed is initialized,
        -: 1494:   see also init_fps. */
        -: 1495:
        -: 1496:static bool
        -: 1497:open_file (char *name, COLUMN *p)
      437: 1498:{
      437: 1499:  if (STREQ (name, "-"))
        -: 1500:    {
    #####: 1501:      p->name = _("standard input");
    #####: 1502:      p->fp = stdin;
    #####: 1503:      have_read_stdin = true;
        -: 1504:    }
        -: 1505:  else
        -: 1506:    {
      437: 1507:      p->name = name;
      437: 1508:      p->fp = fopen (name, "r");
        -: 1509:    }
      437: 1510:  if (p->fp == NULL)
        -: 1511:    {
    #####: 1512:      failed_opens = true;
    #####: 1513:      if (!ignore_failed_opens)
    #####: 1514:	error (0, errno, "%s", name);
    #####: 1515:      return false;
        -: 1516:    }
      437: 1517:  p->status = OPEN;
      437: 1518:  p->full_page_printed = false;
      437: 1519:  ++total_files;
      437: 1520:  return true;
        -: 1521:}
        -: 1522:
        -: 1523:/* Close the file in P.
        -: 1524:
        -: 1525:   If we aren't dealing with multiple files in parallel, we change
        -: 1526:   the status of all columns in the column list to reflect the close. */
        -: 1527:
        -: 1528:static void
        -: 1529:close_file (COLUMN *p)
      431: 1530:{
        -: 1531:  COLUMN *q;
        -: 1532:  int i;
        -: 1533:
      431: 1534:  if (p->status == CLOSED)
    #####: 1535:    return;
      431: 1536:  if (ferror (p->fp))
    #####: 1537:    error (EXIT_FAILURE, errno, "%s", p->name);
      431: 1538:  if (fileno (p->fp) != STDIN_FILENO && fclose (p->fp) != 0)
    #####: 1539:    error (EXIT_FAILURE, errno, "%s", p->name);
        -: 1540:
      431: 1541:  if (!parallel_files)
        -: 1542:    {
     1109: 1543:      for (q = column_vector, i = columns; i; ++q, --i)
        -: 1544:	{
      759: 1545:	  q->status = CLOSED;
      759: 1546:	  if (q->lines_stored == 0)
        -: 1547:	    {
      574: 1548:	      q->lines_to_print = 0;
        -: 1549:	    }
        -: 1550:	}
        -: 1551:    }
        -: 1552:  else
        -: 1553:    {
       81: 1554:      p->status = CLOSED;
       81: 1555:      p->lines_to_print = 0;
        -: 1556:    }
        -: 1557:
      431: 1558:  --files_ready_to_read;
        -: 1559:}
        -: 1560:
        -: 1561:/* Put a file on hold until we start a new page,
        -: 1562:   since we've hit a form feed.
        -: 1563:
        -: 1564:   If we aren't dealing with parallel files, we must change the
        -: 1565:   status of all columns in the column list. */
        -: 1566:
        -: 1567:static void
        -: 1568:hold_file (COLUMN *p)
     1964: 1569:{
        -: 1570:  COLUMN *q;
        -: 1571:  int i;
        -: 1572:
     1964: 1573:  if (!parallel_files)
     5392: 1574:    for (q = column_vector, i = columns; i; ++q, --i)
        -: 1575:      {
     3712: 1576:	if (storing_columns)
     1888: 1577:	  q->status = FF_FOUND;
        -: 1578:	else
     1824: 1579:	  q->status = ON_HOLD;
        -: 1580:      }
        -: 1581:  else
      284: 1582:    p->status = ON_HOLD;
        -: 1583:
     1964: 1584:  p->lines_to_print = 0;
     1964: 1585:  --files_ready_to_read;
     1964: 1586:}
        -: 1587:
        -: 1588:/* Undo hold_file -- go through the column list and change any
        -: 1589:   ON_HOLD columns to OPEN.  Used at the end of each page. */
        -: 1590:
        -: 1591:static void
        -: 1592:reset_status (void)
     2810: 1593:{
     2810: 1594:  int i = columns;
        -: 1595:  COLUMN *p;
        -: 1596:
     8960: 1597:  for (p = column_vector; i; --i, ++p)
     6150: 1598:    if (p->status == ON_HOLD)
        -: 1599:      {
     4108: 1600:	p->status = OPEN;
     4108: 1601:	files_ready_to_read++;
        -: 1602:      }
        -: 1603:
     2810: 1604:  if (storing_columns)
        -: 1605:    {
     1067: 1606:      if (column_vector->status == CLOSED)
        -: 1607:        /* We use the info to output an error message in  skip_to_page. */
      167: 1608:        files_ready_to_read = 0;
        -: 1609:      else
      900: 1610:        files_ready_to_read = 1;
        -: 1611:    }
     2810: 1612:}
        -: 1613:
        -: 1614:/* Print a single file, or multiple files in parallel.
        -: 1615:
        -: 1616:   Set up the list of columns, opening the necessary files.
        -: 1617:   Allocate space for storing columns, if necessary.
        -: 1618:   Skip to first_page_number, if user has asked to skip leading pages.
        -: 1619:   Determine which functions are appropriate to store/print lines
        -: 1620:   in each column.
        -: 1621:   Print the file(s). */
        -: 1622:
        -: 1623:static void
        -: 1624:print_files (int number_of_files, char **av)
      393: 1625:{
      393: 1626:  init_parameters (number_of_files);
      393: 1627:  if (! init_fps (number_of_files, av))
    #####: 1628:    return;
      393: 1629:  if (storing_columns)
      169: 1630:    init_store_cols ();
        -: 1631:
      393: 1632:  if (first_page_number > 1)
        -: 1633:    {
      129: 1634:      if (!skip_to_page (first_page_number))
    #####: 1635:	return;
        -: 1636:      else
      129: 1637:	page_number = first_page_number;
        -: 1638:    }
        -: 1639:  else
      264: 1640:    page_number = 1;
        -: 1641:
      393: 1642:  init_funcs ();
        -: 1643:
      393: 1644:  line_number = line_count;
     2815: 1645:  while (print_page ())
        -: 1646:    ;
        -: 1647:}
        -: 1648:
        -: 1649:/* Initialize header information.
        -: 1650:   If DESC is non-negative, it is a file descriptor open to
        -: 1651:   FILENAME for reading.  */
        -: 1652:
        -: 1653:static void
        -: 1654:init_header (char const *filename, int desc)
      393: 1655:{
      393: 1656:  char *buf = NULL;
        -: 1657:  struct stat st;
        -: 1658:  struct timespec t;
        -: 1659:  int ns;
        -: 1660:  struct tm *tm;
        -: 1661:
        -: 1662:  /* If parallel files or standard input, use current date. */
      393: 1663:  if (STREQ (filename, "-"))
    #####: 1664:    desc = -1;
      749: 1665:  if (0 <= desc && fstat (desc, &st) == 0)
      356: 1666:    t = get_stat_mtime (&st);
        -: 1667:  else
        -: 1668:    {
        -: 1669:      static struct timespec timespec;
       37: 1670:      if (! timespec.tv_sec)
       37: 1671:	gettime (&timespec);
       37: 1672:      t = timespec;
        -: 1673:    }
        -: 1674:
      393: 1675:  ns = t.tv_nsec;
      393: 1676:  tm = localtime (&t.tv_sec);
      393: 1677:  if (tm == NULL)
        -: 1678:    {
    #####: 1679:      buf = xmalloc (INT_BUFSIZE_BOUND (long int)
        -: 1680:		     + MAX (10, INT_BUFSIZE_BOUND (int)));
    #####: 1681:      sprintf (buf, "%ld.%09d", (long int) t.tv_sec, ns);
        -: 1682:    }
        -: 1683:  else
        -: 1684:    {
      393: 1685:      size_t bufsize = nstrftime (NULL, SIZE_MAX, date_format, tm, 0, ns) + 1;
      393: 1686:      buf = xmalloc (bufsize);
      393: 1687:      nstrftime (buf, bufsize, date_format, tm, 0, ns);
        -: 1688:    }
        -: 1689:
      393: 1690:  free (date_text);
      393: 1691:  date_text = buf;
      393: 1692:  file_text = custom_header ? custom_header : desc < 0 ? "" : filename;
      393: 1693:  header_width_available = (chars_per_line
        -: 1694:			    - mbswidth (date_text, 0)
        -: 1695:			    - mbswidth (file_text, 0));
      393: 1696:}
        -: 1697:
        -: 1698:/* Set things up for printing a page
        -: 1699:
        -: 1700:   Scan through the columns ...
        -: 1701:   Determine which are ready to print
        -: 1702:   (i.e., which have lines stored or open files)
        -: 1703:   Set p->lines_to_print appropriately
        -: 1704:   (to p->lines_stored if we're storing, or lines_per_body
        -: 1705:   if we're reading straight from the file)
        -: 1706:   Keep track of this total so we know when to stop printing */
        -: 1707:
        -: 1708:static void
        -: 1709:init_page (void)
     2815: 1710:{
        -: 1711:  int j;
        -: 1712:  COLUMN *p;
        -: 1713:
     2815: 1714:  if (storing_columns)
        -: 1715:    {
     1092: 1716:      store_columns ();
     2798: 1717:      for (j = columns - 1, p = column_vector; j; --j, ++p)
        -: 1718:	{
     1706: 1719:	  p->lines_to_print = p->lines_stored;
        -: 1720:	}
        -: 1721:
        -: 1722:      /* Last column. */
     1092: 1723:      if (balance_columns)
        -: 1724:	{
     1092: 1725:	  p->lines_to_print = p->lines_stored;
        -: 1726:	}
        -: 1727:      /* Since we're not balancing columns, we don't need to store
        -: 1728:         the rightmost column.   Read it straight from the file. */
        -: 1729:      else
        -: 1730:	{
    #####: 1731:	  if (p->status == OPEN)
        -: 1732:	    {
    #####: 1733:	      p->lines_to_print = lines_per_body;
        -: 1734:	    }
        -: 1735:	  else
    #####: 1736:	    p->lines_to_print = 0;
        -: 1737:	}
        -: 1738:    }
        -: 1739:  else
     5106: 1740:    for (j = columns, p = column_vector; j; --j, ++p)
     3383: 1741:      if (p->status == OPEN)
        -: 1742:	{
     2832: 1743:	  p->lines_to_print = lines_per_body;
        -: 1744:	}
        -: 1745:      else
      551: 1746:	p->lines_to_print = 0;
     2815: 1747:}
        -: 1748:
        -: 1749:/* Align empty columns and print separators.
        -: 1750:   Empty columns will be formed by files with status ON_HOLD or CLOSED
        -: 1751:   when printing multiple files in parallel. */
        -: 1752:
        -: 1753:static void
        -: 1754:align_column (COLUMN *p)
     1446: 1755:{
     1446: 1756:  padding_not_printed = p->start_position;
     1446: 1757:  if (padding_not_printed - col_sep_length > 0)
        -: 1758:    {
      781: 1759:      pad_across_to (padding_not_printed - col_sep_length);
      781: 1760:      padding_not_printed = ANYWHERE;
        -: 1761:    }
        -: 1762:
     1446: 1763:  if (use_col_separator)
     1446: 1764:    print_sep_string ();
        -: 1765:
     1446: 1766:  if (p->numbered)
      247: 1767:    add_line_number (p);
     1446: 1768:}
        -: 1769:
        -: 1770:/* Print one page.
        -: 1771:
        -: 1772:   As long as there are lines left on the page and columns ready to print,
        -: 1773:   Scan across the column list
        -: 1774:   if the column has stored lines or the file is open
        -: 1775:   pad to the appropriate spot
        -: 1776:   print the column
        -: 1777:   pad the remainder of the page with \n or \f as requested
        -: 1778:   reset the status of all files -- any files which where on hold because
        -: 1779:   of formfeeds are now put back into the lineup. */
        -: 1780:
        -: 1781:static bool
        -: 1782:print_page (void)
     2815: 1783:{
        -: 1784:  int j;
        -: 1785:  int lines_left_on_page;
        -: 1786:  COLUMN *p;
        -: 1787:
        -: 1788:  /* Used as an accumulator (with | operator) of successive values of
        -: 1789:     pad_vertically.  The trick is to set pad_vertically
        -: 1790:     to false before each run through the inner loop, then after that
        -: 1791:     loop, it tells us whether a line was actually printed (whether a
        -: 1792:     newline needs to be output -- or two for double spacing).  But those
        -: 1793:     values have to be accumulated (in pv) so we can invoke pad_down
        -: 1794:     properly after the outer loop completes. */
        -: 1795:  bool pv;
        -: 1796:
     2815: 1797:  init_page ();
        -: 1798:
     2815: 1799:  if (cols_ready_to_print () == 0)
      385: 1800:    return false;
        -: 1801:
     2430: 1802:  if (extremities)
     2112: 1803:    print_a_header = true;
        -: 1804:
        -: 1805:  /* Don't pad unless we know a page was printed. */
     2430: 1806:  pad_vertically = false;
     2430: 1807:  pv = false;
        -: 1808:
     2430: 1809:  lines_left_on_page = lines_per_body;
     2430: 1810:  if (double_space)
        3: 1811:    lines_left_on_page *= 2;
        -: 1812:
    16068: 1813:  while (lines_left_on_page > 0 && cols_ready_to_print () > 0)
        -: 1814:    {
    11518: 1815:      output_position = 0;
    11518: 1816:      spaces_not_printed = 0;
    11518: 1817:      separators_not_printed = 0;
    11518: 1818:      pad_vertically = false;
    11518: 1819:      align_empty_cols = false;
    11518: 1820:      empty_line = true;
        -: 1821:
    30850: 1822:      for (j = 1, p = column_vector; j <= columns; ++j, ++p)
        -: 1823:	{
    21268: 1824:	  input_position = 0;
    39191: 1825:	  if (p->lines_to_print > 0 || p->status == FF_FOUND)
        -: 1826:	    {
    19859: 1827:	      FF_only = false;
    19859: 1828:	      padding_not_printed = p->start_position;
    19859: 1829:	      if (!(p->print_func) (p))
     6115: 1830:		read_rest_of_line (p);
    19859: 1831:	      pv |= pad_vertically;
        -: 1832:
    19859: 1833:	      --p->lines_to_print;
    19859: 1834:	      if (p->lines_to_print <= 0)
        -: 1835:		{
     3820: 1836:		  if (cols_ready_to_print () <= 0)
     1936: 1837:		    break;
        -: 1838:		}
        -: 1839:
        -: 1840:	      /* File p changed its status to ON_HOLD or CLOSED */
    17923: 1841:	      if (parallel_files && p->status != OPEN)
        -: 1842:		{
      192: 1843:		  if (empty_line)
      100: 1844:		    align_empty_cols = true;
       92: 1845:		  else if (p->status == CLOSED ||
        -: 1846:			   (p->status == ON_HOLD && FF_only))
       44: 1847:		    align_column (p);
        -: 1848:		}
        -: 1849:	    }
     1409: 1850:	  else if (parallel_files)
        -: 1851:	    {
        -: 1852:	      /* File status ON_HOLD or CLOSED */
     1409: 1853:	      if (empty_line)
      724: 1854:		align_empty_cols = true;
        -: 1855:	      else
      685: 1856:		align_column (p);
        -: 1857:	    }
        -: 1858:
        -: 1859:	  /* We need it also with an empty column */
    19332: 1860:	  if (use_col_separator)
    16121: 1861:	    ++separators_not_printed;
        -: 1862:	}
        -: 1863:
    11518: 1864:      if (pad_vertically)
        -: 1865:	{
    11126: 1866:	  putchar ('\n');
    11126: 1867:	  --lines_left_on_page;
        -: 1868:	}
        -: 1869:
    11518: 1870:      if (cols_ready_to_print () <= 0 && !extremities)
      310: 1871:	break;
        -: 1872:
    11208: 1873:      if (double_space & pv)
        -: 1874:	{
        4: 1875:	  putchar ('\n');
        4: 1876:	  --lines_left_on_page;
        -: 1877:	}
        -: 1878:    }
        -: 1879:
     2430: 1880:  if (lines_left_on_page == 0)
     2061: 1881:    for (j = 1, p = column_vector; j <= columns; ++j, ++p)
     1376: 1882:      if (p->status == OPEN)
      931: 1883:	p->full_page_printed = true;
        -: 1884:
     2430: 1885:  pad_vertically = pv;
        -: 1886:
     2430: 1887:  if (pad_vertically & extremities)
     2097: 1888:    pad_down (lines_left_on_page + lines_per_footer);
      333: 1889:  else if (keep_FF & print_a_FF)
        -: 1890:    {
      122: 1891:      putchar ('\f');
      122: 1892:      print_a_FF = false;
        -: 1893:    }
        -: 1894:
     2430: 1895:  if (last_page_number < page_number)
        8: 1896:    return false;		/* Stop printing with LAST_PAGE */
        -: 1897:
     2422: 1898:  reset_status ();		/* Change ON_HOLD to OPEN. */
        -: 1899:
     2422: 1900:  return true;			/* More pages to go. */
        -: 1901:}
        -: 1902:
        -: 1903:/* Allocate space for storing columns.
        -: 1904:
        -: 1905:   This is necessary when printing multiple columns from a single file.
        -: 1906:   Lines are stored consecutively in buff, separated by '\0'.
        -: 1907:
        -: 1908:   The following doesn't apply any longer - any tuning possible?
        -: 1909:   (We can't use a fixed offset since with the '-s' flag lines aren't
        -: 1910:   truncated.)
        -: 1911:
        -: 1912:   We maintain a list (line_vector) of pointers to the beginnings
        -: 1913:   of lines in buff.  We allocate one more than the number of lines
        -: 1914:   because the last entry tells us the index of the last character,
        -: 1915:   which we need to know in order to print the last line in buff. */
        -: 1916:
        -: 1917:static void
        -: 1918:init_store_cols (void)
      169: 1919:{
      169: 1920:  int total_lines = lines_per_body * columns;
      169: 1921:  int chars_if_truncate = total_lines * (chars_per_column + 1);
        -: 1922:
      169: 1923:  free (line_vector);
        -: 1924:  /* FIXME: here's where it was allocated.  */
      169: 1925:  line_vector = xmalloc ((total_lines + 1) * sizeof (int *));
        -: 1926:
      169: 1927:  free (end_vector);
      169: 1928:  end_vector = xmalloc (total_lines * sizeof (int *));
        -: 1929:
      169: 1930:  free (buff);
      169: 1931:  buff_allocated = (use_col_separator
        -: 1932:		    ? 2 * chars_if_truncate
        -: 1933:		    : chars_if_truncate);	/* Tune this. */
      169: 1934:  buff = xmalloc (buff_allocated);
      169: 1935:}
        -: 1936:
        -: 1937:/* Store all but the rightmost column.
        -: 1938:   (Used when printing a single file in multiple downward columns)
        -: 1939:
        -: 1940:   For each column
        -: 1941:   set p->current_line to be the index in line_vector of the
        -: 1942:   first line in the column
        -: 1943:   For each line in the column
        -: 1944:   store the line in buff
        -: 1945:   add to line_vector the index of the line's first char
        -: 1946:   buff_start is the index in buff of the first character in the
        -: 1947:   current line. */
        -: 1948:
        -: 1949:static void
        -: 1950:store_columns (void)
     1092: 1951:{
        -: 1952:  int i, j;
     1092: 1953:  int line = 0;
        -: 1954:  int buff_start;
        -: 1955:  int last_col;		/* The rightmost column which will be saved in buff */
        -: 1956:  COLUMN *p;
        -: 1957:
     1092: 1958:  buff_current = 0;
     1092: 1959:  buff_start = 0;
        -: 1960:
     1092: 1961:  if (balance_columns)
     1092: 1962:    last_col = columns;
        -: 1963:  else
    #####: 1964:    last_col = columns - 1;
        -: 1965:
     3890: 1966:  for (i = 1, p = column_vector; i <= last_col; ++i, ++p)
     2798: 1967:    p->lines_stored = 0;
        -: 1968:
     3399: 1969:  for (i = 1, p = column_vector; i <= last_col && files_ready_to_read;
     1215: 1970:       ++i, ++p)
        -: 1971:    {
     1215: 1972:      p->current_line = line;
     7811: 1973:      for (j = lines_per_body; j && files_ready_to_read; --j)
        -: 1974:
     6596: 1975:	if (p->status == OPEN)	/* Redundant.  Clean up. */
        -: 1976:	  {
     6596: 1977:	    input_position = 0;
        -: 1978:
     6596: 1979:	    if (!read_line (p))
     4420: 1980:	      read_rest_of_line (p);
        -: 1981:
     6596: 1982:	    if (p->status == OPEN
        -: 1983:		|| buff_start != buff_current)
        -: 1984:	      {
     5933: 1985:		++p->lines_stored;
     5933: 1986:		line_vector[line] = buff_start;
     5933: 1987:		end_vector[line++] = input_position;
     5933: 1988:		buff_start = buff_current;
        -: 1989:	      }
        -: 1990:	  }
        -: 1991:    }
        -: 1992:
        -: 1993:  /* Keep track of the location of the last char in buff. */
     1092: 1994:  line_vector[line] = buff_start;
        -: 1995:
     1092: 1996:  if (balance_columns)
     1092: 1997:    balance (line);
     1092: 1998:}
        -: 1999:
        -: 2000:static void
        -: 2001:balance (int total_stored)
     1092: 2002:{
        -: 2003:  COLUMN *p;
        -: 2004:  int i, lines;
     1092: 2005:  int first_line = 0;
        -: 2006:
     3890: 2007:  for (i = 1, p = column_vector; i <= columns; ++i, ++p)
        -: 2008:    {
     2798: 2009:      lines = total_stored / columns;
     2798: 2010:      if (i <= total_stored % columns)
      511: 2011:	++lines;
        -: 2012:
     2798: 2013:      p->lines_stored = lines;
     2798: 2014:      p->current_line = first_line;
        -: 2015:
     2798: 2016:      first_line += lines;
        -: 2017:    }
     1092: 2018:}
        -: 2019:
        -: 2020:/* Store a character in the buffer. */
        -: 2021:
        -: 2022:static void
        -: 2023:store_char (char c)
   149271: 2024:{
   149271: 2025:  if (buff_current >= buff_allocated)
        -: 2026:    {
        -: 2027:      /* May be too generous. */
    #####: 2028:      buff = X2REALLOC (buff, &buff_allocated);
        -: 2029:    }
   149271: 2030:  buff[buff_current++] = c;
   149271: 2031:}
        -: 2032:
        -: 2033:static void
        -: 2034:add_line_number (COLUMN *p)
     3120: 2035:{
        -: 2036:  int i;
        -: 2037:  char *s;
        -: 2038:  int left_cut;
        -: 2039:
        -: 2040:  /* Cutting off the higher-order digits is more informative than
        -: 2041:     lower-order cut off*/
     3120: 2042:  if (line_number < power_10)
     3114: 2043:    sprintf (number_buff, "%*d", chars_per_number, line_number);
        -: 2044:  else
        -: 2045:    {
        6: 2046:      left_cut = line_number % power_10;
        6: 2047:      sprintf (number_buff, "%0*d", chars_per_number, left_cut);
        -: 2048:    }
     3120: 2049:  line_number++;
     3120: 2050:  s = number_buff;
    13298: 2051:  for (i = chars_per_number; i > 0; i--)
    10178: 2052:    (p->char_func) (*s++);
        -: 2053:
     3120: 2054:  if (columns > 1)
        -: 2055:    {
        -: 2056:      /* Tabification is assumed for multiple columns, also for n-separators,
        -: 2057:	 but `default n-separator = TAB' hasn't been given priority over
        -: 2058:	 equal column_width also specified by POSIX. */
     2322: 2059:      if (number_separator == '\t')
        -: 2060:        {
       32: 2061:          i = number_width - chars_per_number;
      160: 2062:          while (i-- > 0)
       96: 2063:	    (p->char_func) (' ');
        -: 2064:        }
        -: 2065:      else
     2290: 2066:        (p->char_func) (number_separator);
        -: 2067:    }
        -: 2068:  else
        -: 2069:    /* To comply with POSIX, we avoid any expansion of default TAB
        -: 2070:       separator with a single column output. No column_width requirement
        -: 2071:       has to be considered. */
        -: 2072:    {
      798: 2073:      (p->char_func) (number_separator);
      798: 2074:      if (number_separator == '\t')
       15: 2075:        output_position = POS_AFTER_TAB (chars_per_output_tab,
        -: 2076:			  output_position);
        -: 2077:    }
        -: 2078:
     3120: 2079:  if (truncate_lines & !parallel_files)
     1316: 2080:    input_position += number_width;
     3120: 2081:}
        -: 2082:
        -: 2083:/* Print (or store) padding until the current horizontal position
        -: 2084:   is position. */
        -: 2085:
        -: 2086:static void
        -: 2087:pad_across_to (int position)
    11259: 2088:{
    11259: 2089:  int h = output_position;
        -: 2090:
    11259: 2091:  if (tabify_output)
    10891: 2092:    spaces_not_printed = position - output_position;
        -: 2093:  else
        -: 2094:    {
      748: 2095:      while (++h <= position)
       12: 2096:	putchar (' ');
      368: 2097:      output_position = position;
        -: 2098:    }
    11259: 2099:}
        -: 2100:
        -: 2101:/* Pad to the bottom of the page.
        -: 2102:
        -: 2103:   If the user has requested a formfeed, use one.
        -: 2104:   Otherwise, use newlines. */
        -: 2105:
        -: 2106:static void
        -: 2107:pad_down (int lines)
     2097: 2108:{
        -: 2109:  int i;
        -: 2110:
     2097: 2111:  if (use_form_feed)
     1088: 2112:    putchar ('\f');
        -: 2113:  else
    13053: 2114:    for (i = lines; i; --i)
    12044: 2115:      putchar ('\n');
     2097: 2116:}
        -: 2117:
        -: 2118:/* Read the rest of the line.
        -: 2119:
        -: 2120:   Read from the current column's file until an end of line is
        -: 2121:   hit.  Used when we've truncated a line and we no longer need
        -: 2122:   to print or store its characters. */
        -: 2123:
        -: 2124:static void
        -: 2125:read_rest_of_line (COLUMN *p)
    10535: 2126:{
        -: 2127:  int c;
    10535: 2128:  FILE *f = p->fp;
        -: 2129:
   194839: 2130:  while ((c = getc (f)) != '\n')
        -: 2131:    {
   173976: 2132:      if (c == '\f')
        -: 2133:	{
      207: 2134:	  if ((c = getc (f)) != '\n')
      131: 2135:	    ungetc (c, f);
      207: 2136:	  if (keep_FF)
    #####: 2137:	    print_a_FF = true;
      207: 2138:	  hold_file (p);
      207: 2139:	  break;
        -: 2140:	}
   173769: 2141:      else if (c == EOF)
        -: 2142:	{
    #####: 2143:	  close_file (p);
    #####: 2144:	  break;
        -: 2145:	}
        -: 2146:    }
    10535: 2147:}
        -: 2148:
        -: 2149:/* Read a line with skip_to_page.
        -: 2150:
        -: 2151:   Read from the current column's file until an end of line is
        -: 2152:   hit.  Used when we read full lines to skip pages.
        -: 2153:   With skip_to_page we have to check for FF-coincidence which is done
        -: 2154:   in function read_line otherwise.
        -: 2155:   Count lines of skipped pages to find the line number of 1st page
        -: 2156:   printed relative to 1st line of input file (start_line_num). */
        -: 2157:
        -: 2158:static void
        -: 2159:skip_read (COLUMN *p, int column_number)
     3018: 2160:{
        -: 2161:  int c;
     3018: 2162:  FILE *f = p->fp;
        -: 2163:  int i;
     3018: 2164:  bool single_ff = false;
        -: 2165:  COLUMN *q;
        -: 2166:
        -: 2167:  /* Read 1st character in a line or any character succeeding a FF */
     3018: 2168:  if ((c = getc (f)) == '\f' && p->full_page_printed)
        -: 2169:    /* A FF-coincidence with a previous full_page_printed.
        -: 2170:       To avoid an additional empty page, eliminate the FF */
       41: 2171:    if ((c = getc (f)) == '\n')
       14: 2172:      c = getc (f);
        -: 2173:
     3018: 2174:  p->full_page_printed = false;
        -: 2175:
        -: 2176:  /* 1st character a FF means a single FF without any printable
        -: 2177:     characters. Don't count it as a line with -n option. */
     3018: 2178:  if (c == '\f')
      200: 2179:    single_ff = true;
        -: 2180:
        -: 2181:  /* Preparing for a FF-coincidence: Maybe we finish that page
        -: 2182:     without a FF found */
     3018: 2183:  if (last_line)
      353: 2184:    p->full_page_printed = true;
        -: 2185:
   113493: 2186:  while (c != '\n')
        -: 2187:    {
   107724: 2188:      if (c == '\f')
        -: 2189:	{
        -: 2190:	  /* No FF-coincidence possible,
        -: 2191:	     no catching up of a FF-coincidence with next page */
      267: 2192:	  if (last_line)
        -: 2193:	    {
       48: 2194:	      if (!parallel_files)
      124: 2195:		for (q = column_vector, i = columns; i; ++q, --i)
       79: 2196:		  q->full_page_printed = false;
        -: 2197:	      else
        3: 2198:		p->full_page_printed = false;
        -: 2199:	    }
        -: 2200:
      267: 2201:	  if ((c = getc (f)) != '\n')
      149: 2202:	    ungetc (c, f);
      267: 2203:	  hold_file (p);
      267: 2204:	  break;
        -: 2205:	}
   107457: 2206:      else if (c == EOF)
        -: 2207:	{
    #####: 2208:	  close_file (p);
    #####: 2209:	  break;
        -: 2210:	}
   107457: 2211:      c = getc (f);
        -: 2212:    }
        -: 2213:
     3018: 2214:  if (skip_count)
     3003: 2215:    if ((!parallel_files || column_number == 1) && !single_ff)
     2650: 2216:      ++line_count;
     3018: 2217:}
        -: 2218:
        -: 2219:/* If we're tabifying output,
        -: 2220:
        -: 2221:   When print_char encounters white space it keeps track
        -: 2222:   of our desired horizontal position and delays printing
        -: 2223:   until this function is called. */
        -: 2224:
        -: 2225:static void
        -: 2226:print_white_space (void)
    36722: 2227:{
        -: 2228:  int h_new;
    36722: 2229:  int h_old = output_position;
    36722: 2230:  int goal = h_old + spaces_not_printed;
        -: 2231:
    91332: 2232:  while (goal - h_old > 1
        -: 2233:	 && (h_new = POS_AFTER_TAB (chars_per_output_tab, h_old)) <= goal)
        -: 2234:    {
    17888: 2235:      putchar (output_tab_char);
    17888: 2236:      h_old = h_new;
        -: 2237:    }
   122517: 2238:  while (++h_old <= goal)
    49073: 2239:    putchar (' ');
        -: 2240:
    36722: 2241:  output_position = goal;
    36722: 2242:  spaces_not_printed = 0;
    36722: 2243:}
        -: 2244:
        -: 2245:/* Print column separators.
        -: 2246:
        -: 2247:   We keep a count until we know that we'll be printing a line,
        -: 2248:   then print_sep_string() is called. */
        -: 2249:
        -: 2250:static void
        -: 2251:print_sep_string (void)
    16593: 2252:{
        -: 2253:  char *s;
    16593: 2254:  int l = col_sep_length;
        -: 2255:
    16593: 2256:  s = col_sep_string;
        -: 2257:
    16593: 2258:  if (separators_not_printed <= 0)
        -: 2259:    {
        -: 2260:      /* We'll be starting a line with chars_per_margin, anything else? */
     7080: 2261:      if (spaces_not_printed > 0)
      660: 2262:	print_white_space ();
        -: 2263:    }
        -: 2264:  else
        -: 2265:    {
    19026: 2266:      for (; separators_not_printed > 0; --separators_not_printed)
        -: 2267:	{
    33303: 2268:	  while (l-- > 0)
        -: 2269:	    {
        -: 2270:	      /* 3 types of sep_strings: spaces only, spaces and chars,
        -: 2271:	      chars only */
    14277: 2272:	      if (*s == ' ')
        -: 2273:		{
        -: 2274:		  /* We're tabifying output; consecutive spaces in
        -: 2275:		  sep_string may have to be converted to tabs */
     6881: 2276:		  s++;
     6881: 2277:		  ++spaces_not_printed;
        -: 2278:		}
        -: 2279:	      else
        -: 2280:		{
     7396: 2281:		  if (spaces_not_printed > 0)
     1181: 2282:		    print_white_space ();
     7396: 2283:		  putchar (*s++);
     7396: 2284:		  ++output_position;
        -: 2285:		}
        -: 2286:	    }
        -: 2287:          /* sep_string ends with some spaces */
     9513: 2288:	  if (spaces_not_printed > 0)
     6881: 2289:	    print_white_space ();
        -: 2290:	}
        -: 2291:    }
    16593: 2292:}
        -: 2293:
        -: 2294:/* Print (or store, depending on p->char_func) a clump of N
        -: 2295:   characters. */
        -: 2296:
        -: 2297:static void
        -: 2298:print_clump (COLUMN *p, int n, char *clump)
   491608: 2299:{
  1475568: 2300:  while (n--)
   492352: 2301:    (p->char_func) (*clump++);
   491608: 2302:}
        -: 2303:
        -: 2304:/* Print a character.
        -: 2305:
        -: 2306:   Update the following comment: process-char hasn't been used any
        -: 2307:   longer.
        -: 2308:   If we're tabifying, all tabs have been converted to spaces by
        -: 2309:   process_char().  Keep a count of consecutive spaces, and when
        -: 2310:   a nonspace is encountered, call print_white_space() to print the
        -: 2311:   required number of tabs and spaces. */
        -: 2312:
        -: 2313:static void
        -: 2314:print_char (char c)
   505714: 2315:{
   505714: 2316:  if (tabify_output)
        -: 2317:    {
   388025: 2318:      if (c == ' ')
        -: 2319:	{
   197181: 2320:	  ++spaces_not_printed;
   197181: 2321:	  return;
        -: 2322:	}
   190844: 2323:      else if (spaces_not_printed > 0)
    25903: 2324:	print_white_space ();
        -: 2325:
        -: 2326:      /* Nonprintables are assumed to have width 0, except '\b'. */
   190844: 2327:      if (! isprint (to_uchar (c)))
        -: 2328:	{
        8: 2329:	  if (c == '\b')
    #####: 2330:	    --output_position;
        -: 2331:	}
        -: 2332:      else
   190836: 2333:	++output_position;
        -: 2334:    }
   308533: 2335:  putchar (c);
        -: 2336:}
        -: 2337:
        -: 2338:/* Skip to page PAGE before printing.
        -: 2339:   PAGE may be larger than total number of pages. */
        -: 2340:
        -: 2341:static bool
        -: 2342:skip_to_page (uintmax_t page)
      129: 2343:{
        -: 2344:  uintmax_t n;
        -: 2345:  int i;
        -: 2346:  int j;
        -: 2347:  COLUMN *p;
        -: 2348:
      517: 2349:  for (n = 1; n < page; ++n)
        -: 2350:    {
     4506: 2351:      for (i = 1; i < lines_per_body; ++i)
        -: 2352:	{
    12496: 2353:	  for (j = 1, p = column_vector; j <= columns; ++j, ++p)
     8378: 2354:	    if (p->status == OPEN)
     2665: 2355:	      skip_read (p, j);
        -: 2356:	}
      388: 2357:      last_line = true;
     1210: 2358:      for (j = 1, p = column_vector; j <= columns; ++j, ++p)
      822: 2359:	if (p->status == OPEN)
      353: 2360:	  skip_read (p, j);
        -: 2361:
      388: 2362:      if (storing_columns)	/* change FF_FOUND to ON_HOLD */
      528: 2363:	for (j = 1, p = column_vector; j <= columns; ++j, ++p)
      384: 2364:	  if (p->status != CLOSED)
      384: 2365:	    p->status = ON_HOLD;
        -: 2366:
      388: 2367:      reset_status ();
      388: 2368:      last_line = false;
        -: 2369:
      388: 2370:      if (files_ready_to_read < 1)
        -: 2371:        {
        -: 2372:	  /* It's very helpful, normally the total number of pages is
        -: 2373:	     not known in advance.  */
    #####: 2374:	  error (0, 0,
        -: 2375:		 _("starting page number %"PRIuMAX
        -: 2376:		   " exceeds page count %"PRIuMAX),
        -: 2377:		 page, n);
    #####: 2378:          break;
        -: 2379:	}
        -: 2380:    }
      129: 2381:  return files_ready_to_read > 0;
        -: 2382:}
        -: 2383:
        -: 2384:/* Print a header.
        -: 2385:
        -: 2386:   Formfeeds are assumed to use up two lines at the beginning of
        -: 2387:   the page. */
        -: 2388:
        -: 2389:static void
        -: 2390:print_header (void)
     2097: 2391:{
        -: 2392:  char page_text[256 + INT_STRLEN_BOUND (page_number)];
        -: 2393:  int available_width;
        -: 2394:  int lhs_spaces;
        -: 2395:  int rhs_spaces;
        -: 2396:
     2097: 2397:  output_position = 0;
     2097: 2398:  pad_across_to (chars_per_margin);
     2097: 2399:  print_white_space ();
        -: 2400:
     2097: 2401:  if (page_number == 0)
    #####: 2402:    error (EXIT_FAILURE, 0, _("Page number overflow"));
        -: 2403:
        -: 2404:  /* The translator must ensure that formatting the translation of
        -: 2405:     "Page %"PRIuMAX does not generate more than (sizeof page_text - 1)
        -: 2406:     bytes.  */
     2097: 2407:  sprintf (page_text, _("Page %"PRIuMAX), page_number++);
     2097: 2408:  available_width = header_width_available - mbswidth (page_text, 0);
     2097: 2409:  available_width = MAX (0, available_width);
     2097: 2410:  lhs_spaces = available_width >> 1;
     2097: 2411:  rhs_spaces = available_width - lhs_spaces;
        -: 2412:
     2097: 2413:  printf ("\n\n%s%*s%s%*s%s\n\n\n",
        -: 2414:	  date_text, lhs_spaces, " ", file_text, rhs_spaces, " ", page_text);
        -: 2415:
     2097: 2416:  print_a_header = false;
     2097: 2417:  output_position = 0;
     2097: 2418:}
        -: 2419:
        -: 2420:/* Print (or store, if p->char_func is store_char()) a line.
        -: 2421:
        -: 2422:   Read a character to determine whether we have a line or not.
        -: 2423:   (We may hit EOF, \n, or \f)
        -: 2424:
        -: 2425:   Once we know we have a line,
        -: 2426:   set pad_vertically = true, meaning it's safe
        -: 2427:   to pad down at the end of the page, since we do have a page.
        -: 2428:   print a header if needed.
        -: 2429:   pad across to padding_not_printed if needed.
        -: 2430:   print any separators which need to be printed.
        -: 2431:   print a line number if it needs to be printed.
        -: 2432:
        -: 2433:   Print the clump which corresponds to the first character.
        -: 2434:
        -: 2435:   Enter a loop and keep printing until an end of line condition
        -: 2436:   exists, or until we exceed chars_per_column.
        -: 2437:
        -: 2438:   Return false if we exceed chars_per_column before reading
        -: 2439:   an end of line character, true otherwise. */
        -: 2440:
        -: 2441:static bool
        -: 2442:read_line (COLUMN *p)
    20180: 2443:{
        -: 2444:  int c;
        -: 2445:  int chars IF_LINT (= 0);
        -: 2446:  int last_input_position;
        -: 2447:  int j, k;
        -: 2448:  COLUMN *q;
        -: 2449:
        -: 2450:  /* read 1st character in each line or any character succeeding a FF: */
    20180: 2451:  c = getc (p->fp);
        -: 2452:
    20180: 2453:  last_input_position = input_position;
        -: 2454:
    20180: 2455:  if (c == '\f' && p->full_page_printed)
      212: 2456:    if ((c = getc (p->fp)) == '\n')
      100: 2457:      c = getc (p->fp);
    20180: 2458:  p->full_page_printed = false;
        -: 2459:
    20180: 2460:  switch (c)
        -: 2461:    {
        -: 2462:    case '\f':
     1309: 2463:      if ((c = getc (p->fp)) != '\n')
      608: 2464:	ungetc (c, p->fp);
     1309: 2465:      FF_only = true;
     1309: 2466:      if (print_a_header & !storing_columns)
        -: 2467:	{
      482: 2468:	  pad_vertically = true;
      482: 2469:	  print_header ();
        -: 2470:	}
      827: 2471:      else if (keep_FF)
      118: 2472:	print_a_FF = true;
     1309: 2473:      hold_file (p);
     1309: 2474:      return true;
        -: 2475:    case EOF:
      431: 2476:      close_file (p);
      431: 2477:      return true;
        -: 2478:    case '\n':
      274: 2479:      break;
        -: 2480:    default:
    18166: 2481:      chars = char_to_clump (c);
        -: 2482:    }
        -: 2483:
    18440: 2484:  if (truncate_lines && input_position > chars_per_column)
        -: 2485:    {
    #####: 2486:      input_position = last_input_position;
    #####: 2487:      return false;
        -: 2488:    }
        -: 2489:
    18440: 2490:  if (p->char_func != store_char)
        -: 2491:    {
    12507: 2492:      pad_vertically = true;
        -: 2493:
    12507: 2494:      if (print_a_header & !storing_columns)
      805: 2495:	print_header ();
        -: 2496:
    12507: 2497:      if (parallel_files & align_empty_cols)
        -: 2498:	{
        -: 2499:	  /* We have to align empty columns at the beginning of a line. */
      581: 2500:	  k = separators_not_printed;
      581: 2501:	  separators_not_printed = 0;
     1298: 2502:	  for (j = 1, q = column_vector; j <= k; ++j, ++q)
        -: 2503:	    {
      717: 2504:	      align_column (q);
      717: 2505:	      separators_not_printed += 1;
        -: 2506:	    }
      581: 2507:	  padding_not_printed = p->start_position;
      581: 2508:	  if (truncate_lines)
      413: 2509:	    spaces_not_printed = chars_per_column;
        -: 2510:	  else
      168: 2511:	    spaces_not_printed = 0;
      581: 2512:	  align_empty_cols = false;
        -: 2513:	}
        -: 2514:
    12507: 2515:      if (padding_not_printed - col_sep_length > 0)
        -: 2516:	{
     4950: 2517:	  pad_across_to (padding_not_printed - col_sep_length);
     4950: 2518:	  padding_not_printed = ANYWHERE;
        -: 2519:	}
        -: 2520:
    12507: 2521:      if (use_col_separator)
     9214: 2522:	print_sep_string ();
        -: 2523:    }
        -: 2524:
    18440: 2525:  if (p->numbered)
     2873: 2526:    add_line_number (p);
        -: 2527:
    18440: 2528:  empty_line = false;
    18440: 2529:  if (c == '\n')
      274: 2530:    return true;
        -: 2531:
    18166: 2532:  print_clump (p, chars, clump_buff);
        -: 2533:
        -: 2534:  for (;;)
        -: 2535:    {
   491608: 2536:      c = getc (p->fp);
        -: 2537:
   491608: 2538:      switch (c)
        -: 2539:	{
        -: 2540:	case '\n':
     7450: 2541:	  return true;
        -: 2542:	case '\f':
      181: 2543:	  if ((c = getc (p->fp)) != '\n')
      148: 2544:	    ungetc (c, p->fp);
      181: 2545:	  if (keep_FF)
        4: 2546:	    print_a_FF = true;
      181: 2547:	  hold_file (p);
      181: 2548:	  return true;
        -: 2549:	case EOF:
    #####: 2550:	  close_file (p);
    #####: 2551:	  return true;
        -: 2552:	}
        -: 2553:
   483977: 2554:      last_input_position = input_position;
   483977: 2555:      chars = char_to_clump (c);
   483977: 2556:      if (truncate_lines && input_position > chars_per_column)
        -: 2557:	{
    10535: 2558:	  input_position = last_input_position;
    10535: 2559:	  return false;
        -: 2560:	}
        -: 2561:
   473442: 2562:      print_clump (p, chars, clump_buff);
   473442: 2563:    }
        -: 2564:}
        -: 2565:
        -: 2566:/* Print a line from buff.
        -: 2567:
        -: 2568:   If this function has been called, we know we have "something to
        -: 2569:   print". But it remains to be seen whether we have a real text page
        -: 2570:   or an empty page (a single form feed) with/without a header only.
        -: 2571:   Therefore first we set pad_vertically to true and print a header
        -: 2572:   if necessary.
        -: 2573:   If FF_FOUND and we are using -t|-T option we omit any newline by
        -: 2574:   setting pad_vertically to false (see print_page).
        -: 2575:   Otherwise we pad across if necessary, print separators if necessary
        -: 2576:   and text of COLUMN *p.
        -: 2577:
        -: 2578:   Return true, meaning there is no need to call read_rest_of_line. */
        -: 2579:
        -: 2580:static bool
        -: 2581:print_stored (COLUMN *p)
     6275: 2582:{
        -: 2583:  COLUMN *q;
        -: 2584:  int i;
        -: 2585:
     6275: 2586:  int line = p->current_line++;
     6275: 2587:  char *first = &buff[line_vector[line]];
        -: 2588:  /* FIXME
        -: 2589:     UMR: Uninitialized memory read:
        -: 2590:     * This is occurring while in:
        -: 2591:     print_stored   [pr.c:2239]
        -: 2592:     * Reading 4 bytes from 0x5148c in the heap.
        -: 2593:     * Address 0x5148c is 4 bytes into a malloc'd block at 0x51488 of 676 bytes
        -: 2594:     * This block was allocated from:
        -: 2595:     malloc         [rtlib.o]
        -: 2596:     xmalloc        [xmalloc.c:94]
        -: 2597:     init_store_cols [pr.c:1648]
        -: 2598:     */
     6275: 2599:  char *last = &buff[line_vector[line + 1]];
        -: 2600:
     6275: 2601:  pad_vertically = true;
        -: 2602:
     6275: 2603:  if (print_a_header)
      810: 2604:    print_header ();
        -: 2605:
     6275: 2606:  if (p->status == FF_FOUND)
        -: 2607:    {
     2242: 2608:      for (i = 1, q = column_vector; i <= columns; ++i, ++q)
     1628: 2609:	q->status = ON_HOLD;
      614: 2610:      if (column_vector->lines_to_print <= 0)
        -: 2611:	{
      342: 2612:	  if (!extremities)
       44: 2613:	    pad_vertically = false;
      342: 2614:	  return true;		/* print a header only */
        -: 2615:	}
        -: 2616:    }
        -: 2617:
     5933: 2618:  if (padding_not_printed - col_sep_length > 0)
        -: 2619:    {
     3431: 2620:      pad_across_to (padding_not_printed - col_sep_length);
     3431: 2621:      padding_not_printed = ANYWHERE;
        -: 2622:    }
        -: 2623:
     5933: 2624:  if (use_col_separator)
     5933: 2625:    print_sep_string ();
        -: 2626:
   161137: 2627:  while (first != last)
   149271: 2628:    print_char (*first++);
        -: 2629:
     5933: 2630:  if (spaces_not_printed == 0)
        -: 2631:    {
     3077: 2632:      output_position = p->start_position + end_vector[line];
     3077: 2633:      if (p->start_position - col_sep_length == chars_per_margin)
     1416: 2634:	output_position -= col_sep_length;
        -: 2635:    }
        -: 2636:
     5933: 2637:  return true;
        -: 2638:}
        -: 2639:
        -: 2640:/* Convert a character to the proper format and return the number of
        -: 2641:   characters in the resulting clump.  Increment input_position by
        -: 2642:   the width of the clump.
        -: 2643:
        -: 2644:   Tabs are converted to clumps of spaces.
        -: 2645:   Nonprintable characters may be converted to clumps of escape
        -: 2646:   sequences or control prefixes.
        -: 2647:
        -: 2648:   Note: the width of a clump is not necessarily equal to the number of
        -: 2649:   characters in clump_buff.  (e.g, the width of '\b' is -1, while the
        -: 2650:   number of characters is 1.) */
        -: 2651:
        -: 2652:static int
        -: 2653:char_to_clump (char c)
   502143: 2654:{
   502143: 2655:  unsigned char uc = c;
   502143: 2656:  char *s = clump_buff;
        -: 2657:  int i;
        -: 2658:  char esc_buff[4];
        -: 2659:  int width;
        -: 2660:  int chars;
   502143: 2661:  int chars_per_c = 8;
        -: 2662:
   502143: 2663:  if (c == input_tab_char)
      154: 2664:    chars_per_c = chars_per_input_tab;
        -: 2665:
   502317: 2666:  if (c == input_tab_char || c == '\t')
        -: 2667:    {
      174: 2668:      width = TAB_WIDTH (chars_per_c, input_position);
        -: 2669:
      174: 2670:      if (untabify_input)
        -: 2671:	{
     1080: 2672:	  for (i = width; i; --i){
        -: 2673:#ifdef CIL
        -: 2674:        __ASSERT(width - i < (8 > chars_per_input_tab ? 8 : chars_per_input_tab));
        -: 2675:#endif
      912: 2676:	    *s++ = ' ';
        -: 2677:      }
      168: 2678:	  chars = width;
        -: 2679:	}
        -: 2680:      else
        -: 2681:	{
        6: 2682:	  *s = c;
        6: 2683:	  chars = 1;
        -: 2684:	}
        -: 2685:
        -: 2686:    }
   501969: 2687:  else if (! isprint (uc))
        -: 2688:    {
    #####: 2689:      if (use_esc_sequence)
        -: 2690:	{
    #####: 2691:	  width = 4;
    #####: 2692:	  chars = 4;
    #####: 2693:	  *s++ = '\\';
    #####: 2694:	  sprintf (esc_buff, "%03o", uc);
    #####: 2695:	  for (i = 0; i <= 2; ++i)
    #####: 2696:	    *s++ = esc_buff[i];
        -: 2697:	}
    #####: 2698:      else if (use_cntrl_prefix)
        -: 2699:	{
    #####: 2700:	  if (uc < 0200)
        -: 2701:	    {
    #####: 2702:	      width = 2;
    #####: 2703:	      chars = 2;
    #####: 2704:	      *s++ = '^';
    #####: 2705:	      *s++ = c ^ 0100;
        -: 2706:	    }
        -: 2707:	  else
        -: 2708:	    {
    #####: 2709:	      width = 4;
    #####: 2710:	      chars = 4;
    #####: 2711:	      *s++ = '\\';
    #####: 2712:	      sprintf (esc_buff, "%03o", uc);
    #####: 2713:	      for (i = 0; i <= 2; ++i)
    #####: 2714:		*s++ = esc_buff[i];
        -: 2715:	    }
        -: 2716:	}
    #####: 2717:      else if (c == '\b')
        -: 2718:	{
    #####: 2719:	  width = -1;
    #####: 2720:	  chars = 1;
    #####: 2721:	  *s = c;
        -: 2722:	}
        -: 2723:      else
        -: 2724:	{
    #####: 2725:	  width = 0;
    #####: 2726:	  chars = 1;
    #####: 2727:	  *s = c;
        -: 2728:	}
        -: 2729:    }
        -: 2730:  else
        -: 2731:    {
   501969: 2732:      width = 1;
   501969: 2733:      chars = 1;
   501969: 2734:      *s = c;
        -: 2735:    }
        -: 2736:
   502143: 2737:  input_position += width;
   502143: 2738:  return chars;
        -: 2739:}
        -: 2740:
        -: 2741:/* We've just printed some files and need to clean up things before
        -: 2742:   looking for more options and printing the next batch of files.
        -: 2743:
        -: 2744:   Free everything we've xmalloc'ed, except `header'. */
        -: 2745:
        -: 2746:static void
        -: 2747:cleanup (void)
      393: 2748:{
      393: 2749:  free (number_buff);
      393: 2750:  free (clump_buff);
      393: 2751:  free (column_vector);
      393: 2752:  free (line_vector);
      393: 2753:  free (end_vector);
      393: 2754:  free (buff);
      393: 2755:}
        -: 2756:
        -: 2757:/* Complain, print a usage message, and die. */
        -: 2758:
        -: 2759:void
        -: 2760:usage (int status)
        3: 2761:{
        3: 2762:  if (status != EXIT_SUCCESS)
    #####: 2763:    fprintf (stderr, _("Try `%s --help' for more information.\n"),
        -: 2764:	     program_name);
        -: 2765:  else
        -: 2766:    {
        3: 2767:      printf (_("\
        -: 2768:Usage: %s [OPTION]... [FILE]...\n\
        -: 2769:"),
        -: 2770:	      program_name);
        -: 2771:
        3: 2772:      fputs (_("\
        -: 2773:Paginate or columnate FILE(s) for printing.\n\
        -: 2774:\n\
        -: 2775:"), stdout);
        3: 2776:      fputs (_("\
        -: 2777:Mandatory arguments to long options are mandatory for short options too.\n\
        -: 2778:"), stdout);
        3: 2779:      fputs (_("\
        -: 2780:  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n\
        -: 2781:                    begin [stop] printing with page FIRST_[LAST_]PAGE\n\
        -: 2782:  -COLUMN, --columns=COLUMN\n\
        -: 2783:                    output COLUMN columns and print columns down,\n\
        -: 2784:                    unless -a is used. Balance number of lines in the\n\
        -: 2785:                    columns on each page.\n\
        -: 2786:"), stdout);
        3: 2787:      fputs (_("\
        -: 2788:  -a, --across      print columns across rather than down, used together\n\
        -: 2789:                    with -COLUMN\n\
        -: 2790:  -c, --show-control-chars\n\
        -: 2791:                    use hat notation (^G) and octal backslash notation\n\
        -: 2792:  -d, --double-space\n\
        -: 2793:                    double space the output\n\
        -: 2794:"), stdout);
        3: 2795:      fputs (_("\
        -: 2796:  -D, --date-format=FORMAT\n\
        -: 2797:                    use FORMAT for the header date\n\
        -: 2798:  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n\
        -: 2799:                    expand input CHARs (TABs) to tab WIDTH (8)\n\
        -: 2800:  -F, -f, --form-feed\n\
        -: 2801:                    use form feeds instead of newlines to separate pages\n\
        -: 2802:                    (by a 3-line page header with -F or a 5-line header\n\
        -: 2803:                    and trailer without -F)\n\
        -: 2804:"), stdout);
        3: 2805:      fputs (_("\
        -: 2806:  -h HEADER, --header=HEADER\n\
        -: 2807:                    use a centered HEADER instead of filename in page header,\n\
        -: 2808:                    -h \"\" prints a blank line, don't use -h\"\"\n\
        -: 2809:  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n\
        -: 2810:                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n\
        -: 2811:  -J, --join-lines  merge full lines, turns off -W line truncation, no column\n\
        -: 2812:                    alignment, --sep-string[=STRING] sets separators\n\
        -: 2813:"), stdout);
        3: 2814:      fputs (_("\
        -: 2815:  -l PAGE_LENGTH, --length=PAGE_LENGTH\n\
        -: 2816:                    set the page length to PAGE_LENGTH (66) lines\n\
        -: 2817:                    (default number of lines of text 56, and with -F 63)\n\
        -: 2818:  -m, --merge       print all files in parallel, one in each column,\n\
        -: 2819:                    truncate lines, but join lines of full length with -J\n\
        -: 2820:"), stdout);
        3: 2821:      fputs (_("\
        -: 2822:  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n\
        -: 2823:                    number lines, use DIGITS (5) digits, then SEP (TAB),\n\
        -: 2824:                    default counting starts with 1st line of input file\n\
        -: 2825:  -N NUMBER, --first-line-number=NUMBER\n\
        -: 2826:                    start counting with NUMBER at 1st line of first\n\
        -: 2827:                    page printed (see +FIRST_PAGE)\n\
        -: 2828:"), stdout);
        3: 2829:      fputs (_("\
        -: 2830:  -o MARGIN, --indent=MARGIN\n\
        -: 2831:                    offset each line with MARGIN (zero) spaces, do not\n\
        -: 2832:                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n\
        -: 2833:  -r, --no-file-warnings\n\
        -: 2834:                    omit warning when a file cannot be opened\n\
        -: 2835:"), stdout);
        3: 2836:      fputs (_("\
        -: 2837:  -s[CHAR],--separator[=CHAR]\n\
        -: 2838:                    separate columns by a single character, default for CHAR\n\
        -: 2839:                    is the <TAB> character without -w and \'no char\' with -w\n\
        -: 2840:                    -s[CHAR] turns off line truncation of all 3 column\n\
        -: 2841:                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n\
        -: 2842:"), stdout);
        3: 2843:      fputs (_("\
        -: 2844:  -SSTRING, --sep-string[=STRING]\n\
        -: 2845:"), stdout);
        3: 2846:      fputs (_("\
        -: 2847:                    separate columns by STRING,\n\
        -: 2848:                    without -S: Default separator <TAB> with -J and <space>\n\
        -: 2849:                    otherwise (same as -S\" \"), no effect on column options\n\
        -: 2850:  -t, --omit-header  omit page headers and trailers\n\
        -: 2851:"), stdout);
        3: 2852:      fputs (_("\
        -: 2853:  -T, --omit-pagination\n\
        -: 2854:                    omit page headers and trailers, eliminate any pagination\n\
        -: 2855:                    by form feeds set in input files\n\
        -: 2856:  -v, --show-nonprinting\n\
        -: 2857:                    use octal backslash notation\n\
        -: 2858:  -w PAGE_WIDTH, --width=PAGE_WIDTH\n\
        -: 2859:                    set page width to PAGE_WIDTH (72) characters for\n\
        -: 2860:                    multiple text-column output only, -s[char] turns off (72)\n\
        -: 2861:"), stdout);
        3: 2862:      fputs (_("\
        -: 2863:  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n\
        -: 2864:                    set page width to PAGE_WIDTH (72) characters always,\n\
        -: 2865:                    truncate lines, except -J option is set, no interference\n\
        -: 2866:                    with -S or -s\n\
        -: 2867:"), stdout);
        3: 2868:      fputs (HELP_OPTION_DESCRIPTION, stdout);
        3: 2869:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
        3: 2870:      fputs (_("\
        -: 2871:\n\
        -: 2872:-t is implied if PAGE_LENGTH <= 10.  With no FILE, or when\n\
        -: 2873:FILE is -, read standard input.\n\
        -: 2874:"), stdout);
        3: 2875:      emit_bug_reporting_address ();
        -: 2876:    }
        3: 2877:  exit (status);
        -: 2878:}
