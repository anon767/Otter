#include "iosim.h"
#include <stdlib.h>

void symtest_initialize() {
	IOSIM_fd[1] = malloc(sizeof(sym_file_stream_t));
	IOSIM_fd[1]->offset = 0;
	IOSIM_fd[1]->fd = 1;
	IOSIM_fd[1]->sym_file = malloc(sizeof(sym_file_t));
	IOSIM_fd[1]->sym_file->contents = NULL;
	IOSIM_fd[1]->sym_file->stat.st_size = 0;
	stdout = IOSIM_fd[1];

	sym_file_t* sed = IOSIM_addfile("uniq.sed", 0);
	sed->contents = "h\n\n:b\n$b\nN\n/^\\(.*\\)\\n\\1$/ {\n    # The two lines are identical.  Undo the effect of\n    # the n command.\n    g\n    bb\n}\n\n$b\n\nP\nD";
	sed->stat.st_size = 127;

	sym_file_t* input = IOSIM_addfile("uniq.inp", 0);
	input->contents = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&& length - re->max_match_size > start_offset)\n((*ecode++ == OP_BEG_WORD) ? prev_is_word : cur_is_word))\n((md->ctypes[*eptr] & ctype_word) != 0);\n((md->ctypes[*eptr] & ctype_word) != 0);\n((md->ctypes[eptr[-1]] & ctype_word) != 0);\n((md->ctypes[eptr[-1]] & ctype_word) != 0);\n(eptr == md->end_subject - 1 && *eptr != '\\n'))\n(eptr == md->end_subject - 1 && *eptr != '\\n'))\n(i.e. keep it out of the loop). Also we can test that there are at least\n(md->ctypes[*eptr++] & ctype_digit) != 0)\n(md->ctypes[*eptr++] & ctype_digit) == 0)\n(md->ctypes[*eptr++] & ctype_space) != 0)\n(md->ctypes[*eptr++] & ctype_space) == 0)\n(md->ctypes[*eptr++] & ctype_word) != 0)\n(md->ctypes[*eptr++] & ctype_word) == 0)\n(offsetcount - 2) * sizeof (int));\n(offsets == NULL && offsetcount > 0))\n(pcre_free) (match_block.offset_vector);\n(pcre_free) (match_block.offset_vector);\n(pcre_free) (save);\n(re->tables + fcc_offset)[req_char] : req_char;\n*          Match a back-reference                *\n*         Execute a Regular Expression           *\n*         Match from current position            *\n*        Debugging function to print chars       *\n*      Perl-Compatible Regular Expressions       *\n*    Macros and tables for character handling    *\n*************************************************/\n*************************************************/\n*************************************************/\n*************************************************/\n*************************************************/\n*************************************************/\n*/\n*/\n*/\n*/\n*/\n*iptr = -1;\n*iptr++ = -1;\n*prev == OP_ASSERTBACK || *prev == OP_ASSERTBACK_NOT ||\n*prev == OP_ONCE)\n-----------------------------------------------------------------------------\n-----------------------------------------------------------------------------\n-1 => failed to match\n/*\n/* "Once" brackets are like assertion brackets except that after a match,\n/* ... else fall through */\n/* ... else fall through */\n/* Advance to a possible match for an initial string after study */\n/* Allow compilation as C++ source code, should anybody want to do that. */\n/* Always fail if not enough characters left */\n/* An alternation is the end of a branch; scan along to find the end of the\n/* Assert before internal newline if multiline, or before a terminating\n/* Assertion brackets. Check the alternative branches in turn - the\n/* At the start of a bracketed group, add the current subject pointer to the\n/* BRAZERO and BRAMINZERO occur just before a bracket group, indicating\n/* Caseful comparisons */\n/* Caseful comparisons */\n/* Change option settings */\n/* Common code for all repeated single character type matches */\n/* Common code for all repeated single-character matches. We can give\n/* Common code for all repeated single-character matches. We can give\n/* Compute the minimum number of offsets that we need to reset each time. Doing\n/* Conditional group: compilation checked that there are no more than\n/* Continue as from after the assertion, updating the offsets high water\n/* Continue from after the assertion, updating the offsets high water\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never gets here */\n/* Control never reaches here */\n/* Control never reaches here */\n/* Copy the offset information from temporary store if necessary */\n/* Do a single test if no case difference is set up */\n/* Do not stick any code in here without much thought; it is assumed\n/* End of a group, repeated or non-repeating. If we are at the end of\n/* End of subject assertion (\\z) */\n/* End of subject or ending \\n assertion (\\Z) */\n/* End of the pattern. If PCRE_NOTEMPTY is set, fail if we have matched\n/* First, ensure the minimum number of matches are present. */\n/* First, ensure the minimum number of matches are present. Use inline\n/* First, ensure the minimum number of matches are present. We get back\n/* Flag bits for the match() function */\n/* For a non-repeating ket, just continue at this level. This also\n/* For a non-repeating ket, just continue at this level. This also\n/* For anchored or unanchored matches, there may be a "last known required\n/* For extended extraction brackets (large number), we have to fish out\n/* For extended extraction brackets (large number), we have to fish out the\n/* For matches anchored to the end of the pattern, we can often avoid\n/* If a back reference hasn't been set, the length that is passed is greater\n/* If checking an assertion for a condition, return TRUE. */\n/* If hit the end of the group (which could be repeated), fail */\n/* If max == min we can continue with the main loop without the\n/* If maximizing it is worth using inline code for speed, doing the type\n/* If maximizing, find the longest possible run, then work backwards. */\n/* If maximizing, find the longest string and work backwards */\n/* If min = max, continue at the same level without recursing */\n/* If min = max, continue at the same level without recursion.\n/* If minimizing, keep testing the rest of the expression and advancing\n/* If minimizing, keep trying and advancing the pointer */\n/* If minimizing, we have to test the rest of the pattern before each\n/* If req_char is set, we know that that character must appear in the subject\n/* If the expression has got more back references than the offsets supplied can\n/* If the length of the reference is zero, just continue with the\n/* If the reference is unset, set the length to be longer than the amount\n/* If we can't find the required character, break the matching loop */\n/* If we have found the required character, save the point where we\n/* In all other cases except a conditional group we have to check the\n/* In case the recursion has set more capturing values, save the final\n/* Include the internals header, which itself includes Standard C headers plus\n/* Insufficient room for saving captured contents */\n/* Loop for handling unanchored repeated matching attempts; for anchored regexs\n/* Match a back reference, possibly repeatedly. Look past the end of the\n/* Match a character class, possibly repeatedly. Look past the end of the\n/* Match a negated single character */\n/* Match a negated single character repeatedly. This is almost a repeat of\n/* Match a run of characters */\n/* Match a single character repeatedly; different opcodes share code. */\n/* Match a single character type repeatedly; several different opcodes\n/* Match a single character type; inline for speed */\n/* Min and max values for the common repeats; for the maxima, 0 => infinity */\n/* Move the subject pointer back. This occurs only at the start of\n/* Negative assertion: all branches must fail to match */\n/* Now start processing the operations. */\n/* OP_KETRMAX */\n/* OP_KETRMAX */\n/* On entry ecode points to the first opcode, and eptr to the first character\n/* Opening capturing bracket. If there is space in the offset vector, save\n/* Or to a non-unique first char after study */\n/* Or to a unique first char if possible */\n/* Or to just after \\n for a multiline match if possible */\n/* Other types of node can be handled by a switch */\n/* Otherwise test for either case */\n/* Print a sequence of chars in printable format, stopping at the end of the\n/* Recursion matches the current regex, nested. If there are any capturing\n/* Reset the maximum number of extractions we might see. */\n/* Reset the value of the ims flags, in case they got changed during\n/* Reset the working variable associated with each extraction. These should\n/* Separate the caselesss case for speed */\n/* Set up for repetition, or handle the non-repeated case */\n/* Set up the first character to match, if available. The first_char value is\n/* Skip over conditional reference data or large extraction number data if\n/* Start of subject assertion */\n/* Start of subject unless notbol, or after internal newline if multiline */\n/* Structure for building a chain of data that actually lives on the\n/* The code is duplicated for the caseless and caseful cases, for speed,\n/* The code is duplicated for the caseless and caseful cases, for speed,\n/* The condition is an assertion. Call match() to evaluate it - setting\n/* The ims options can vary during the matching as a result of the presence\n/* The repeating kets try the rest of the pattern or restart from the\n/* The repeating kets try the rest of the pattern or restart from the\n/* There's been some horrible disaster. */\n/* This "while" is the end of the "do" above */\n/* This function applies a compiled re to a subject string and picks out\n/* Use a macro for debugging printing, 'cause that limits the use of #ifdef\n/* We don't need to repeat the search if we haven't yet reached the\n/* When a match occurs, substrings will be set for all internal extractions;\n/* Word boundary assertions */\n/*************************************************\n/*************************************************\n/*************************************************\n/*************************************************\n/*************************************************\n/*************************************************\n1. This software is distributed in the hope that it will be useful,\n2. The origin of this software must not be misrepresented, either by\n3. Altered versions must be plainly marked as such, and must not be\n4. If PCRE is embedded in any software that is released under the GNU\n5.005. If there is an options reset, it will get obeyed in the normal\n5.005. If there is an options reset, it will get obeyed in the normal\n6 : 3 + (ecode[1] << 8) + ecode[2]),\n< -1 => some kind of unexpected problem\n= 0 => success, but offsets is not big enough\nArguments:\nArguments:\nArguments:\nArguments:\nBOOL anchored;\nBOOL cur_is_word = (eptr < md->end_subject) &&\nBOOL cur_is_word = (eptr < md->end_subject) &&\nBOOL is_subject;\nBOOL minimize = FALSE;\nBOOL prev_is_word = (eptr != md->start_subject) &&\nBOOL prev_is_word = (eptr != md->start_subject) &&\nBOOL rc;\nBOOL startline;\nBOOL using_temporary_offsets = FALSE;\nCopyright (c) 1997-2000 University of Cambridge\nDPRINTF ((">>>> returning %d\\n", match_block.errorcode));\nDPRINTF ((">>>> returning %d\\n", rc));\nDPRINTF (("Copied offsets from temporary memory\\n"));\nDPRINTF (("Freeing temporary memory\\n"));\nDPRINTF (("Freeing temporary memory\\n"));\nDPRINTF (("Got memory to hold back references\\n"));\nDPRINTF (("Unknown opcode %d\\n", *ecode));\nDPRINTF (("bracket %d failed\\n", number));\nDPRINTF (("bracket 0 failed\\n"));\nDPRINTF (("ims reset to %02lx\\n", ims));\nDPRINTF (("ims set to %02lx at group repeat\\n", ims));\nDPRINTF (("ims set to %02lx\\n", ims));\nDPRINTF (("matching %c{%d,%d} against subject %.*s\\n", c, min, max,\nDPRINTF (("negative matching %c{%d,%d} against subject %.*s\\n", c, min, max,\nDPRINTF (("saving %d %d %d\\n", save_offset1, save_offset2, save_offset3));\nDPRINTF (("start bracket 0\\n"));\nGETCHAR (c, eptr)	/* Get character */\nGETCHARINC (c, eptr)	/* Get character; increment eptr */\nGETCHARINC (c, eptr)	/* Get character; increment eptr */\nGeneral Purpose Licence (GPL), then the terms of that licence shall\nHowever, if the referenced string is the empty string, always treat\nIf the bracket fails to match, we need to restore this value and also the\nIf there isn't enough space in the offset vector, treat this as if it were a\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nOtherwise, we can use the vector supplied, rounding down its size to a multiple\nPermission is granted to anyone to use this software for any purpose on any\nREPEATCHAR:\nREPEATNOTCHAR:\nREPEATTYPE:\nReturns:          > 0 => success; value is the number of elements filled in\nReturns:       TRUE if matched\nReturns:      TRUE if matched\nReturns:     nothing\nThey are not both allowed to be zero. */\nThis is a library of functions to support regular expressions whose syntax\nThis is the forcible breaking of infinite loops as implemented in Perl\nThis is the forcible breaking of infinite loops as implemented in Perl\nWriting separate code makes it go faster, as does using an autoincrement and\nWritten by: Philip Hazel <ph10@cam.ac.uk>\na move back into the brackets. Check the alternative branches in turn - the\naddress of eptr, so that eptr can be a register variable. */\nan assertion "group", stop matching and return TRUE, but record the\nan empty string - recursion will then try other alternatives, if any. */\nan error. Save the top 15 values on the stack, and accept that the rest\nan unanchored pattern, of course. If there's no first char and the pattern was\nanalyzing most of the pattern.  length > re->max_match_size is\nanchored = ((re->options | options) & PCRE_ANCHORED) != 0;\nand advance one byte in the pattern code. */\nand reinstate them after the recursion. However, we don't know how many\nand semantics are as close as possible to those of the Perl 5 language. See\nand the required character in fact is caseful. */\nat run time, so we have to test for anchoring. The first char may be unset for\navoid duplicate testing (which takes significant time). This covers the vast\nbacking off on a match. */\nbmtable = extra->data.bmtable;\nboth cases of the character. Otherwise set the two values the same, which will\nbracketed group and go to there. */\nbrackets - for testing for empty matches\nbrackets started but not finished, we have to save their starting points\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbreak;\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nc != md->lcc[*eptr++])\nc = *ecode++ - OP_CRSTAR;\nc = *ecode++ - OP_CRSTAR;\nc = *ecode++ - OP_NOTSTAR;\nc = *ecode++ - OP_STAR;\nc = *ecode++ - OP_TYPESTAR;\nc = *ecode++;\nc = *ecode++;\nc = *eptr++;\nc = 15;\nc = max - min;\nc = md->end_subject - eptr;\nc = md->lcc[c];\nc = md->lcc[c];\nc = md->offset_max;\nc == md->lcc[*eptr++])\ncan't just fail here, because of the possibility of quantifiers with zero\ncase OP_ALT:\ncase OP_ANY:\ncase OP_ANY:\ncase OP_ANY:\ncase OP_ANY:\ncase OP_ASSERT:\ncase OP_ASSERTBACK:\ncase OP_ASSERTBACK_NOT:\ncase OP_ASSERT_NOT:\ncase OP_BEG_WORD:\ncase OP_BRA:		/* Non-capturing bracket: optimized */\ncase OP_BRAMINZERO:\ncase OP_BRANUMBER:\ncase OP_BRAZERO:\ncase OP_CHARS:\ncase OP_CIRC:\ncase OP_CLASS:\ncase OP_COND:\ncase OP_CREF:\ncase OP_CRMINPLUS:\ncase OP_CRMINPLUS:\ncase OP_CRMINQUERY:\ncase OP_CRMINQUERY:\ncase OP_CRMINRANGE:\ncase OP_CRMINRANGE:\ncase OP_CRMINSTAR:\ncase OP_CRMINSTAR:\ncase OP_CRPLUS:\ncase OP_CRPLUS:\ncase OP_CRQUERY:\ncase OP_CRQUERY:\ncase OP_CRRANGE:\ncase OP_CRRANGE:\ncase OP_CRSTAR:\ncase OP_CRSTAR:\ncase OP_DIGIT:\ncase OP_DIGIT:\ncase OP_DIGIT:\ncase OP_DIGIT:\ncase OP_DOLL:\ncase OP_END:\ncase OP_END_WORD:\ncase OP_EOD:\ncase OP_EODN:\ncase OP_EXACT:\ncase OP_KET:\ncase OP_KETRMAX:\ncase OP_KETRMIN:\ncase OP_MINPLUS:\ncase OP_MINQUERY:\ncase OP_MINSTAR:\ncase OP_MINUPTO:\ncase OP_NOT:\ncase OP_NOTEXACT:\ncase OP_NOTMINPLUS:\ncase OP_NOTMINQUERY:\ncase OP_NOTMINSTAR:\ncase OP_NOTMINUPTO:\ncase OP_NOTPLUS:\ncase OP_NOTQUERY:\ncase OP_NOTSTAR:\ncase OP_NOTUPTO:\ncase OP_NOT_DIGIT:\ncase OP_NOT_DIGIT:\ncase OP_NOT_DIGIT:\ncase OP_NOT_DIGIT:\ncase OP_NOT_WHITESPACE:\ncase OP_NOT_WHITESPACE:\ncase OP_NOT_WHITESPACE:\ncase OP_NOT_WHITESPACE:\ncase OP_NOT_WORDCHAR:\ncase OP_NOT_WORDCHAR:\ncase OP_NOT_WORDCHAR:\ncase OP_NOT_WORDCHAR:\ncase OP_NOT_WORD_BOUNDARY:\ncase OP_ONCE:\ncase OP_OPT:\ncase OP_PLUS:\ncase OP_QUERY:\ncase OP_RECURSE:\ncase OP_REF:\ncase OP_REVERSE:\ncase OP_SOD:\ncase OP_STAR:\ncase OP_TYPEEXACT:\ncase OP_TYPEMINPLUS:\ncase OP_TYPEMINQUERY:\ncase OP_TYPEMINSTAR:\ncase OP_TYPEMINUPTO:\ncase OP_TYPEPLUS:\ncase OP_TYPEQUERY:\ncase OP_TYPESTAR:\ncase OP_TYPEUPTO:\ncase OP_UPTO:\ncase OP_WHITESPACE:\ncase OP_WHITESPACE:\ncase OP_WHITESPACE:\ncase OP_WHITESPACE:\ncase OP_WORDCHAR:\ncase OP_WORDCHAR:\ncase OP_WORDCHAR:\ncase OP_WORDCHAR:\ncase OP_WORD_BOUNDARY:\ncase matching may be when this character is hit, so test for it in both its\ncaselessly, or if there are any changes of this flag within the regex, set up\ncases if necessary. However, the different cased versions will not be set up\ncharacter" set. If the PCRE_CASELESS is set, implying that the match starts\ncharacters and work backwards. */\ncharacters and work backwards. */\ncode for maximizing the speed, and do the type test once at the start\ncode to character type repeats - written out again for speed. */\ncommoning these up that doesn't require a test of the positive/negative\ncomputer system, and to redistribute it freely, subject to the following\nconst char *subject;\nconst pcre *re;\nconst pcre_extra *extra;\nconst uschar *bmtable = NULL;\nconst uschar *data = ecode + 1;	/* Save for matching */\nconst uschar *end_subject;\nconst uschar *next = ecode + 1;\nconst uschar *next = ecode + 1;\nconst uschar *p = md->start_subject + md->offset_vector[offset];\nconst uschar *p;\nconst uschar *pp = eptr;\nconst uschar *pp = eptr;\nconst uschar *pp = eptr;\nconst uschar *pp = eptr;\nconst uschar *pp = eptr;\nconst uschar *pp = eptr;\nconst uschar *pp = eptr;\nconst uschar *prev = ecode - (ecode[1] << 8) - ecode[2];\nconst uschar *prev = ecode;\nconst uschar *req_char_ptr = start_match - 1;\nconst uschar *saved_eptr = eptr;\nconst uschar *saved_eptr = eptrb->saved_eptr;\nconst uschar *saved_eptr;\nconst uschar *start_bits = NULL;\nconst uschar *start_match = (const uschar *) subject + start_offset;\ncontinue;	/* With the main loop */\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncontinue;\ncourse of events. */\ncourse of events. */\nctype = *ecode++;	/* Code for the character type */\ncur_is_word == prev_is_word : cur_is_word != prev_is_word)\ncurrent high water mark for use by positive assertions. Do this also\ndefault:		/* No repeat follows */\ndefault:		/* No repeat follows */\ndefault:\ndo\ndo\ndo\ndo\ndo\ndo\ndo\ndo\ndo\ndo\ndo\neach branch of a lookbehind assertion. If we are too close to the start to\neach substring: the offsets to the start and end of the substring.\necode       position in code\necode + ((offset < offset_top && md->offset_vector[offset] >= 0) ?\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += (ecode[1] << 8) + ecode[2];\necode += 2;\necode += 2;\necode += 3 + (ecode[4] << 8) + ecode[5];\necode += 33;	/* Advance past the item */\necode += 3;		/* Advance past the item */\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 3;\necode += 5;\necode += 5;\necode = next + 3;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\necode++;\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse\nelse if ((extra->options & PCRE_STUDY_BM) != 0)\nelse if (first_char >= 0)\nelse if (start_bits != NULL)\nelse if (startline)\nencountered */\nend_subject = match_block.end_subject;\neptr        pointer in subject\neptr        points into the subject\neptr += c;\neptr += length;\neptr += length;\neptr += length;\neptr += length;\neptr += min;\neptr -= (ecode[1] << 8) + ecode[2];\neptr -= length;\neptr = md->end_match_ptr;\neptr = md->end_match_ptr;\neptr++;\neptr++;\neptr++;\neptr++;\neptr++;\neptr++;\neptr++;\neptr++;\neptr++;\neptr++;\neptr++;\neptr++;\neptrb       pointer to chain of blocks containing eptr at start of\neptrb = &newptrb;\neptrb = eptrb->prev;	/* Back up the stack of bracket start pointers */\neptrblock *eptrb;\neptrblock newptrb;\neptrblock;\nexactly what going to the ket would do. */\nexplicit claim or by omission.\nexternal_extra  points to "hints" from pcre_study() or is NULL\nexternal_re     points to the compiled expression\nextraction by setting the offsets and bumping the high water mark. */\nfirst_char = match_block.lcc[first_char];\nfirst_char = re->first_char;\nflags       can contain\nfor (;;)\nfor (i = 1; i <= c; i++)\nfor (i = 1; i <= c; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = 1; i <= min; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min; i < max; i++)\nfor (i = min;; i++)\nfor (i = min;; i++)\nfor (i = min;; i++)\nfor (i = min;; i++)\nfor (i = min;; i++)\nfor (i = min;; i++)\nfor (i = min;; i++)\nfor the "once" (not-backup up) groups. */\nfor the match to succeed. If the first character is set, req_char must be\nfound it, so that we don't search again next time round the loop if\nfrom a previous iteration of this group, and be referred to by a reference\ngoto REPEATCHAR;\ngoto REPEATCHAR;\ngoto REPEATNOTCHAR;\ngoto REPEATNOTCHAR;\ngoto REPEATTYPE;\ngoto REPEATTYPE;\ngroup number back at the start and if necessary complete handling an\nhappens for a repeating ket if no characters were matched in the group.\nhappens for a repeating ket if no characters were matched in the group.\nhere; that is handled in the code for KET. */\nhold, we get a temporary bit of working store to use during the matching.\ni.e. it could be ()* or ()? in the pattern. Brackets with fixed upper\nif (!anchored)\nif (!match (start_match, re->code, 2, &match_block, ims, NULL, match_isgroup))\nif (!match_ref (offset, eptr, length, md, ims))\nif (!match_ref (offset, eptr, length, md, ims))\nif (!match_ref (offset, eptr, length, md, ims))\nif (!md->endonly)\nif (!rc)\nif (!startline && extra != NULL)\nif ((*ecode++ == OP_WORD_BOUNDARY) ?\nif ((data[c / 8] & (1 << (c & 7))) != 0)\nif ((data[c / 8] & (1 << (c & 7))) != 0)\nif ((data[c / 8] & (1 << (c & 7))) == 0)\nif ((extra->options & PCRE_STUDY_MAPPED) != 0)\nif ((flags & match_condassert) != 0)\nif ((flags & match_condassert) != 0)\nif ((flags & match_isgroup) != 0)\nif ((ims & PCRE_CASELESS) != 0)\nif ((ims & PCRE_CASELESS) != 0)\nif ((ims & PCRE_CASELESS) != 0)\nif ((ims & PCRE_CASELESS) != 0)\nif ((ims & PCRE_CASELESS) != 0)\nif ((ims & PCRE_CASELESS) != 0)\nif ((ims & PCRE_CASELESS) != 0)\nif ((ims & PCRE_DOTALL) == 0 && c == '\\n')\nif ((ims & PCRE_DOTALL) == 0 && eptr < md->end_subject && *eptr == '\\n')\nif ((ims & PCRE_DOTALL) == 0)\nif ((ims & PCRE_DOTALL) == 0)\nif ((ims & PCRE_MULTILINE) != 0)\nif ((ims & PCRE_MULTILINE) != 0)\nif ((md->ctypes[*eptr++] & ctype_digit) != 0)\nif ((md->ctypes[*eptr++] & ctype_digit) == 0)\nif ((md->ctypes[*eptr++] & ctype_space) != 0)\nif ((md->ctypes[*eptr++] & ctype_space) == 0)\nif ((md->ctypes[*eptr++] & ctype_word) != 0)\nif ((md->ctypes[*eptr++] & ctype_word) == 0)\nif ((md->ctypes[c] & ctype_digit) != 0)\nif ((md->ctypes[c] & ctype_digit) == 0)\nif ((md->ctypes[c] & ctype_space) != 0)\nif ((md->ctypes[c] & ctype_space) == 0)\nif ((md->ctypes[c] & ctype_word) != 0)\nif ((md->ctypes[c] & ctype_word) == 0)\nif ((options & ~PUBLIC_EXEC_OPTIONS) != 0)\nif ((re->options & PCRE_FIRSTSET) != 0)\nif ((re->options & PCRE_REQCHSET) != 0)\nif ((start_bits[c / 8] & (1 << (c & 7))) == 0)\nif (*ecode != OP_ONCE && *ecode != OP_ALT)\nif (*ecode == OP_KET || eptr == saved_eptr)\nif (*ecode == OP_KET || eptr == saved_eptr)\nif (*ecode == OP_KET)\nif (*ecode == OP_KETRMIN)\nif (*ecode == OP_KETRMIN)\nif (*ecode++ != *eptr++)\nif (*ecode++ == *eptr++)\nif (*eptr != '\\n')\nif (*eptr++ == '\\n')\nif (*p++ != *eptr++)\nif (*p++ == req_char)\nif (*prev != OP_COND)\nif (*prev == OP_ASSERT || *prev == OP_ASSERT_NOT ||\nif (bmtable != NULL)\nif (bmtable[*start_match])\nif (c != *eptr++)\nif (c != md->lcc[*eptr++])\nif (c < 16)\nif (c == *eptr++)\nif (c == md->lcc[*eptr++])\nif (c > md->end_subject - eptr)\nif (cur_is_word == prev_is_word ||\nif (ecode[3] == OP_CREF)	/* Condition is extraction test */\nif (ecode[3] == OP_OPT)\nif (eptr != md->start_subject && eptr[-1] != '\\n')\nif (eptr != md->start_subject)\nif (eptr < md->end_subject - 1 ||\nif (eptr < md->end_subject - 1 ||\nif (eptr < md->end_subject)\nif (eptr < md->end_subject)\nif (eptr < md->start_subject)\nif (eptr >= md->end_subject ||\nif (eptr >= md->end_subject ||\nif (eptr >= md->end_subject ||\nif (eptr >= md->end_subject ||\nif (eptr >= md->end_subject ||\nif (eptr >= md->end_subject ||\nif (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) != 0)\nif (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_digit) == 0)\nif (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) != 0)\nif (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_space) == 0)\nif (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) != 0)\nif (eptr >= md->end_subject || (md->ctypes[*eptr] & ctype_word) == 0)\nif (eptr >= md->end_subject || *eptr == '\\n')\nif (eptr >= md->end_subject || c != *eptr)\nif (eptr >= md->end_subject || c != md->lcc[*eptr])\nif (eptr >= md->end_subject || c == *eptr)\nif (eptr >= md->end_subject || c == md->lcc[*eptr])\nif (eptr >= md->end_subject)\nif (eptr >= md->end_subject)\nif (eptr >= md->end_subject)\nif (eptr >= md->end_subject)\nif (eptr >= md->end_subject)\nif (eptr++ >= md->end_subject)\nif (i >= max || !match_ref (offset, eptr, length, md, ims))\nif (i >= max || eptr >= md->end_subject ||\nif (i >= max || eptr >= md->end_subject ||\nif (i >= max || eptr >= md->end_subject || c != *eptr++)\nif (i >= max || eptr >= md->end_subject || c == *eptr++)\nif (i >= max || eptr >= md->end_subject)\nif (i >= max || eptr >= md->end_subject)\nif (is_subject && length > md->end_subject - p)\nif (isprint (c = *(p++)))\nif (length == 0)\nif (length > md->end_subject - eptr)\nif (length > md->end_subject - eptr)\nif (match (eptr, ecode + 3, offset_top, md, ims, NULL,\nif (match (eptr, ecode + 3, offset_top, md, ims, NULL, match_isgroup))\nif (match (eptr, ecode + 3, offset_top, md, ims, NULL, match_isgroup))\nif (match (eptr, ecode + 3, offset_top, md, ims, eptrb, 0) ||\nif (match (eptr, ecode + 3, offset_top, md, ims, eptrb, 0) ||\nif (match (eptr, ecode + 3, offset_top, md, ims, eptrb, match_isgroup))\nif (match (eptr, ecode + 3, offset_top, md, ims, eptrb, match_isgroup))\nif (match (eptr, ecode + 3, offset_top, md, ims, eptrb, match_isgroup))\nif (match (eptr, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr, next + 3, offset_top, md, ims, eptrb, match_isgroup))\nif (match (eptr, next, offset_top, md, ims, eptrb, match_isgroup))\nif (match (eptr, prev, offset_top, md, ims, eptrb, match_isgroup) ||\nif (match (eptr, prev, offset_top, md, ims, eptrb, match_isgroup) ||\nif (match (eptr--, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr--, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr--, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr--, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr--, ecode, offset_top, md, ims, eptrb, 0))\nif (match (eptr--, ecode, offset_top, md, ims, eptrb, 0))\nif (match_block.end_offset_top > offsetcount)\nif (match_block.offset_vector != NULL)\nif (match_block.offset_vector == NULL)\nif (max == 0)\nif (max == 0)\nif (max == 0)\nif (max == 0)\nif (max == 0)\nif (max == 0)\nif (max == 0)\nif (md->lcc[*ecode++] != md->lcc[*eptr++])\nif (md->lcc[*ecode++] == md->lcc[*eptr++])\nif (md->lcc[*p++] != md->lcc[*eptr++])\nif (md->notbol && eptr == md->start_subject)\nif (md->notempty && eptr == md->start_match)\nif (md->noteol)\nif (md->noteol)\nif (min == max)\nif (min == max)\nif (min == max)\nif (min == max)\nif (min == max)\nif (min == max)\nif (min == max)\nif (min > 0)\nif (min > md->end_subject - eptr)\nif (min > md->end_subject - eptr)\nif (min > md->end_subject - eptr)\nif (minimize)\nif (minimize)\nif (minimize)\nif (minimize)\nif (minimize)\nif (minimize)\nif (minimize)\nif (number > 0)\nif (number > EXTRACT_BASIC_MAX) \nif (number > EXTRACT_BASIC_MAX) \nif (offset < md->offset_max)\nif (offset >= md->offset_max)\nif (offset_top <= offset)\nif (offsetcount < 2)\nif (offsetcount >= 4)\nif (op > OP_BRA)\nif (p > req_char_ptr)\nif (p >= end_subject)\nif (pp == req_char || pp == req_char2)\nif (re == NULL || subject == NULL ||\nif (re->magic_number != MAGIC_NUMBER)\nif (re->max_match_size >= 0\nif (re->top_backref > 0 && re->top_backref >= ocount / 3)\nif (req_char == req_char2)\nif (req_char >= 0)\nif (resetcount > offsetcount)\nif (save != stacksave)\nif (save == NULL)\nif (skipped_chars)\nif (start_match + bmtable[256] > end_subject)\nif (start_match > match_block.start_subject + start_offset)\nif (using_temporary_offsets)\nif (using_temporary_offsets)\nif certain parts of the pattern were not used. */\nif the malloc fails ... there is no way of returning to the top level with\nimplied in the second condition, because start_offset > 0. */\nims         current /i, /m, and /s options\nims         the ims flags\nims = (ims & ~PCRE_IMS) | ecode[4];\nims = ecode[1];\nims = original_ims;\nims = re->options & (PCRE_CASELESS | PCRE_MULTILINE | PCRE_DOTALL);\nin the pattern. */\nin the subject string, while eptrb holds the value of eptr at the start of the\ninitialize them to avoid reading uninitialized locations. */\ninline, and there are *still* stupid compilers about that don't like indented\ninside the group.\nint\nint *offsets;\nint *save;\nint c;\nint first_char = -1;\nint flags;\nint length;\nint length;\nint length;\nint length;\nint min, max, ctype;\nint number = *prev - OP_BRA;\nint number = op - OP_BRA;\nint offset = (ecode[1] << 9) | (ecode[2] << 1);		/* Doubled reference number */\nint offset = (ecode[4] << 9) | (ecode[5] << 1);	/* Doubled reference number */\nint offset;\nint offset;\nint offset;\nint offset_top;\nint offsetcount;\nint op = (int) *ecode;\nint options;\nint rc;\nint req_char = -1;\nint req_char2 = -1;\nint resetcount, ocount;\nint save_offset1 = md->offset_vector[offset];\nint save_offset2 = md->offset_vector[offset + 1];\nint save_offset3 = md->offset_vector[md->offset_end - number];\nint skipped_chars = 0;\nint stacksave[15];\nint start_offset;\nis a bit large to put on the stack, but using malloc for small numbers\nis_subject  TRUE if printing from within md->start_subject\nit as matched, any number of times (otherwise there could be infinite\nitem to see if there is repeat information following. The code is similar\nitem to see if there is repeat information following. Then obey similar\nlast bracketed group - used for breaking infinite loops matching zero-length\nlater in the subject; otherwise the test starts at the match point. This\nlength          length of subject string (may contain binary zeros)\nlength      length to be matched\nlength      number to print\nlength = (offset >= offset_top || md->offset_vector[offset] < 0) ?\nlength = md->end_subject - p;\nlevel without recursing. Otherwise, if minimizing, keep trying the rest of\nlevel without recursing. Otherwise, if minimizing, keep trying the rest of\nloop. */\nloops). */\nmain loop. */\nmajority of cases. It will be suboptimal when the case flag changes in a regex\nmark, since extracts may have been taken during the assertion. */\nmark, since extracts may have been taken. */\nmatch (eptr, ecode + 3, offset_top, md, ims, eptrb, 0))\nmatch (eptr, ecode + 3, offset_top, md, ims, eptrb, 0))\nmatch (eptr, ecode, offset_top, md, ims, eptrb, flags)\nmatch (eptr, prev, offset_top, md, ims, eptrb, match_isgroup))\nmatch (eptr, prev, offset_top, md, ims, eptrb, match_isgroup))\nmatch_block.ctypes = re->tables + ctypes_offset;\nmatch_block.end_subject = match_block.start_subject + length;\nmatch_block.endonly = (re->options & PCRE_DOLLAR_ENDONLY) != 0;\nmatch_block.errorcode = PCRE_ERROR_NOMATCH;	/* Default error */\nmatch_block.errorcode == PCRE_ERROR_NOMATCH &&\nmatch_block.lcc = re->tables + lcc_offset;\nmatch_block.lcc[*start_match] != first_char)\nmatch_block.notbol = (options & PCRE_NOTBOL) != 0;\nmatch_block.notempty = (options & PCRE_NOTEMPTY) != 0;\nmatch_block.noteol = (options & PCRE_NOTEOL) != 0;\nmatch_block.offset_end = ocount;\nmatch_block.offset_max = (2 * ocount) / 3;\nmatch_block.offset_overflow = FALSE;\nmatch_block.offset_overflow = TRUE;\nmatch_block.offset_vector = (int *) (pcre_malloc) (ocount * sizeof (int));\nmatch_block.offset_vector = offsets;\nmatch_block.start_match = start_match;\nmatch_block.start_pattern = re->code;\nmatch_block.start_subject = (const uschar *) subject;\nmatch_condassert - this is an assertion condition\nmatch_condassert | match_isgroup))\nmatch_data *md;\nmatch_data *md;\nmatch_data *md;\nmatch_data match_block;\nmatch_isgroup - this is the start of a bracketed group\nmatch_isgroup);\nmatch_ref (offset, eptr, length, md, ims)\nmatches, we carry on as at the end of a normal bracket, leaving the subject\nmatching won't pass the KET for an assertion. If any one branch matches,\nmatching won't pass the KET for this kind of subpattern. If any one branch\nmax = (ecode[1] << 8) + ecode[2];\nmax = (ecode[1] << 8) + ecode[2];\nmax = (ecode[1] << 8) + ecode[2];\nmax = (ecode[3] << 8) + ecode[4];\nmax = (ecode[3] << 8) + ecode[4];\nmax = INT_MAX;\nmax = INT_MAX;\nmax = INT_MAX;\nmax = INT_MAX;\nmax = INT_MAX;\nmax = INT_MAX;\nmax = INT_MAX;\nmax = rep_max[c];	/* zero for max => infinity */\nmax = rep_max[c];	/* zero for max => infinity */\nmax = rep_max[c];	/* zero for max => infinity */\nmax = rep_max[c];	/* zero for max => infinity */\nmax = rep_max[c];	/* zero for max => infinity */\nmax, eptr));\nmax, eptr));\nmaximum. Alternatively, if maximizing, find the maximum number of\nmaximum. Alternatively, if maximizing, find the maximum number of\nmay be wrong. */\nmd          pointer to "static" info for the match\nmd          pointer to matching data block, if is_subject is TRUE\nmd          points to match data block\nmd->end_match_ptr = eptr;	/* For ONCE */\nmd->end_match_ptr = eptr;	/* Record where we ended */\nmd->end_offset_top = offset_top;	/* and how many extracts were taken */\nmd->end_offset_top = offset_top;\nmd->end_subject - eptr + 1 :\nmd->errorcode = PCRE_ERROR_UNKNOWN_NODE;\nmd->offset_overflow = TRUE;\nmd->offset_vector[md->offset_end - i] = save[i];\nmd->offset_vector[md->offset_end - number] = eptr - md->start_subject;\nmd->offset_vector[md->offset_end - number] = save_offset3;\nmd->offset_vector[md->offset_end - number];\nmd->offset_vector[offset + 1] - md->offset_vector[offset];\nmd->offset_vector[offset + 1] = eptr - md->start_subject;\nmd->offset_vector[offset + 1] = save_offset2;\nmd->offset_vector[offset] =\nmd->offset_vector[offset] = save_offset1;\nmemcpy (offsets + 2, match_block.offset_vector + 2,\nmin = (ecode[1] << 8) + ecode[2];\nmin = (ecode[1] << 8) + ecode[2];\nmin = 0;\nmin = 0;\nmin = 0;\nmin = max = (ecode[1] << 8) + ecode[2];\nmin = max = (ecode[1] << 8) + ecode[2];\nmin = max = (ecode[1] << 8) + ecode[2];\nmin = max = 1;\nmin = rep_min[c];	/* Pick up values from tables; */\nmin = rep_min[c];	/* Pick up values from tables; */\nmin = rep_min[c];	/* Pick up values from tables; */\nmin = rep_min[c];	/* Pick up values from tables; */\nmin = rep_min[c];	/* Pick up values from tables; */\nminima. */\nminimize = (*ecode == OP_CRMINRANGE);\nminimize = (*ecode == OP_CRMINRANGE);\nminimize = (c & 1) != 0;\nminimize = (c & 1) != 0;\nminimize = (c & 1) != 0;\nminimize = (c & 1) != 0;\nminimize = (c & 1) != 0;\nminimize = *ecode == OP_MINUPTO;\nminimize = *ecode == OP_NOTMINUPTO;\nminimize = *ecode == OP_TYPEMINUPTO;\nminimize = TRUE;\nminimum number of matches are present. If min = max, continue at the same\nminimum number of matches are present. If min = max, continue at the same\nmisrepresented as being the original software.\nmove back, this match function fails. */\nmustn't change the current values of the data slot, because they may be set\nneed to recurse. */\nnever be used unless previously set, but they get saved and restored, and so we\nnever set for an anchored regular expression, but the anchoring may be forced\nnewline unless endonly is set, else end of subject unless noteol is set. */\nnewptrb.prev = eptrb;\nnewptrb.saved_eptr = eptr;\nnext += (next[1] << 8) + next[2];\nnext += (next[1] << 8) + next[2];\nnon-capturing bracket. Don't worry about setting the flag for the error case\nnumber = (ecode[4] << 8) | ecode[5];\nnumber = (prev[4] << 8) | prev[5];\nnumber from a dummy opcode at the start. */\nnumber, then move along the subject till after the recursive match,\nocount = offsetcount - (offsetcount % 3);\nocount = re->top_backref * 3 + 3;\nof (?ims) items in the pattern. They are kept in a local variable so that\nof 3. */\nof subject left; this ensures that every attempt at a match fails. We\noffset      index into the offset vector\noffset = number << 1;\noffset = number << 1;\noffset_top  current top pointer\noffset_top = md->end_offset_top;\noffset_top = md->end_offset_top;\noffset_top = md->end_offset_top;\noffset_top = offset + 2;\noffset_top, md, ims, eptrb, match_isgroup);\noffsetcount     the number of elements in the vector\noffsets         points to a vector of ints to be filled in with offsets\noffsets[0] = start_match - match_block.start_subject;\noffsets[1] = match_block.end_match_ptr - match_block.start_subject;\nop = OP_BRA;\nopcode. */\noptimization can save a huge amount of backtracking in patterns with nested\noption for each character match. Maybe that wouldn't add very much to the\noptions         option bits\np           points to characters\np--;\np--;\npast the end if there is only one branch, but that's OK because that is\npchars (ecode, length, FALSE, md);\npchars (eptr, 16, TRUE, md);\npchars (eptr, length, TRUE, md);\npchars (eptr, length, TRUE, md);\npchars (p, length, FALSE, md);\npchars (p, length, is_subject, md)\npchars (start_match, end_subject - start_match, TRUE, &match_block);\npcre_exec (re, extra, subject, length, start_offset, options, offsets, offsetcount)\nplace we found it at last time. */\npointer. */\nportions of the string if it matches. Two elements in the vector are set for\npre-processor statements. I suppose it's only been 10 years... */\npreceded by BRAZERO or BRAMINZERO. */\npreceding bracket, in the appropriate order. */\npreceding bracket, in the appropriate order. We need to reset any options\nprintf (" against backref ");\nprintf (" against pattern ");\nprintf ("%c", c);\nprintf (">>>> Match against: ");\nprintf (">>>>> Skipped %d chars to reach first character\\n",\nprintf ("\\\\x%02x", c);\nprintf ("\\n");\nprintf ("\\n");\nprintf ("\\n");\nprintf ("\\n");\nprintf ("\\n");\nprintf ("end bracket %d", number);\nprintf ("matching subject ");\nprintf ("matching subject ");\nprintf ("matching subject <null> against pattern ");\nprintf ("matching subject <null>");\nprintf ("start bracket %d subject=", number);\nrc = 0;\nrc = match (eptr, md->start_pattern, offset_top, md, ims, eptrb,\nrc = match_block.offset_overflow ? 0 : match_block.end_offset_top / 2;\nregister const uschar *ecode;\nregister const uschar *eptr;\nregister const uschar *eptr;\nregister const uschar *p = start_match + ((first_char >= 0) ? 1 : 0);\nregister int *iend = iptr + resetcount;\nregister int *iend = iptr - resetcount / 2 + 1;\nregister int *iptr = match_block.offset_vector + ocount;\nregister int *iptr = match_block.offset_vector;\nregister int c = *start_match;\nregister int c;\nregister int i;\nregister int length = ecode[1];\nregister int pp = *p++;\nrepeat it in the interests of efficiency. */\nrepeat limits are compiled as a number of copies, with the optional ones\nreq_char = re->req_char;\nreq_char2 = ((re->options & (PCRE_CASELESS | PCRE_ICHANGED)) != 0) ?\nreq_char_ptr = p;\nresetcount = 2 + re->top_bracket * 2;\nresetcount = ocount;\nrestoring at the exit of a group is easy. */\nrestrictions:\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn FALSE;\nreturn PCRE_ERROR_BADMAGIC;\nreturn PCRE_ERROR_BADOPTION;\nreturn PCRE_ERROR_NOMATCH;\nreturn PCRE_ERROR_NOMEMORY;\nreturn PCRE_ERROR_NULL;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn TRUE;\nreturn match (eptr,\nreturn match (eptr, ecode + 3, offset_top, md, ims, eptrb, match_isgroup);\nreturn match_block.errorcode;\nreturn rc;\nsave = (int *) (pcre_malloc) ((c + 1) * sizeof (int));\nsave = stacksave;\nsave = stacksave;\nsave[i] = md->offset_vector[md->offset_end - i];\nseems expensive. As a compromise, the stack is used when there are fewer\nshare code. This is very similar to the code for single characters, but we\nsimilar code to character type repeats - written out again for speed.\nsince matching characters is likely to be quite common. First, ensure the\nsince matching characters is likely to be quite common. First, ensure the\nskipped_chars += bmtable[*start_match],\nskipped_chars += bmtable[256] - 1;\nskipped_chars -= bmtable[256] - 1;\nskipped_chars);\nskipped_chars++,\nskipped_chars++,\nskipped_chars++,\nskipped_chars++,\nstack of such pointers, to be re-instated at the end of the group when we hit\nstack, for holding the values of the subject pointer at the start of each\nstart of each branch to move the current point backwards, so the code at\nstart_bits = extra->data.start_bits;\nstart_match += bmtable[*start_match];\nstart_match += bmtable[256] - 1;\nstart_match -= bmtable[256] - 1;\nstart_match = (const uschar *) subject + length - re->max_match_size;\nstart_match++ < end_subject);\nstart_match++;\nstart_match++;\nstart_match++;\nstart_match++;\nstart_offset    where to start in the subject string\nstartline = (re->options & PCRE_STARTLINE) != 0;\nstatic BOOL\nstatic BOOL\nstatic const char rep_max[] =\nstatic const char rep_min[] =\nstatic void\nstrings.\nstruct eptrblock *prev;\nstudied, there may be a bitmap of possible first characters. */\nsubject         points to the subject string\nsubject if the requested.\nsubpattern - to break infinite loops. */\nsubpattern, so as to detect when an empty string has been matched by a\nsubsequent match. */\nsuch there are (offset_top records the completed total) so we just have\nsupersede any condition above with which it is incompatible.\nswitch (*ecode)\nswitch (*ecode)\nswitch (ctype)\nswitch (ctype)\nswitch (ctype)\nswitch (op)\ntest once at the start (i.e. keep it out of the loop). */\nthan 16 values to store; otherwise malloc is used. A problem is what to do\nthan the number of characters left in the string, so the match fails.\nthat "continue" in the code above comes out to here to repeat the main\nthat changed within the bracket before re-running it, so check the next\nthat it may occur zero times. It may repeat infinitely, or not at all -\nthe assertion is true. Lookbehind assertions have an OP_REVERSE item at the\nthe closing ket. When match() is called in other circumstances, we don't add to\nthe code for a repeated single character, but I haven't found a nice way of\nthe current subject position in the working slot at the top of the vector. We\nthe expression and advancing one matching character if failing, up to the\nthe expression and advancing one matching character if failing, up to the\nthe external pcre header. */\nthe file Tech.Notes for some information on the internals.\nthe final argument TRUE causes it to stop at the end of an assertion. */\nthe group. */\nthe length of the reference string explicitly rather than passing the\nthe loop runs just once. */\nthe minimum number of bytes before we start. */\nthe number from a dummy opcode at the start. */\nthe point in the subject string is not moved back. Thus there can never be\nthe pointer while it matches the class. */\nthe same bracket.\nthe stack. */\nthe start hasn't passed this character yet. */\nthe subject. */\nthe subject. */\nthere were too many extractions, set the return code to zero. In the case\nthis level is identical to the lookahead case. */\nthis makes a huge difference to execution time when there aren't many brackets\nthose back references that we can. In this case there need not be overflow\ntime taken, but character matching *is* what this is all about... */\nto save all the potential data. There may be up to 99 such values, which\nto that for character classes, but repeated for efficiency. Then obey\ntwo branches. If the condition is false, skipping the first branch takes us\ntypedef struct eptrblock\nunless PCRE_CASELESS was given or the casing state changes within the regex.\nunlimited repeats that aren't going to match. We don't know what the state of\nunsigned long int ims = 0;\nunsigned long int ims;\nunsigned long int ims;\nunsigned long int original_ims = ims;		/* Save for resetting on ')' */\nup quickly if there are fewer than the minimum number of characters left in\nup quickly if there are fewer than the minimum number of characters left in\nusing_temporary_offsets = TRUE;\nvalues of the final offsets, in case they were set by a previous iteration of\nwe just need to set up the whole thing as substring 0 before returning. If\nwhere we had to get some local store to hold offsets for backreferences, copy\nwhile (!anchored &&\nwhile (*ecode == OP_ALT)\nwhile (*ecode == OP_ALT);\nwhile (*ecode == OP_ALT);\nwhile (*ecode == OP_ALT);\nwhile (*ecode == OP_ALT);\nwhile (*ecode == OP_ALT);\nwhile (*ecode == OP_ALT);\nwhile (*ecode == OP_ALT);\nwhile (*ecode == OP_ALT);\nwhile (*next == OP_ALT);\nwhile (*next == OP_ALT);\nwhile (--iptr >= iend)\nwhile (eptr >= pp)\nwhile (eptr >= pp)\nwhile (eptr >= pp)\nwhile (eptr >= pp)\nwhile (eptr >= pp)\nwhile (eptr >= pp)\nwhile (eptr >= pp)\nwhile (iptr < iend)\nwhile (length-- > 0)\nwhile (length-- > 0)\nwhile (length-- > 0)\nwhile (length-- > 0)\nwhile (length-- > 0)\nwhile (p < end_subject)\nwhile (p < end_subject)\nwhile (start_match < end_subject &&\nwhile (start_match < end_subject && *start_match != first_char)\nwhile (start_match < end_subject && start_match[-1] != '\\n')\nwhile (start_match < end_subject)\nwhile (start_match < end_subject)\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{\n{0, 0, 0, 0, 1, 1};\n{0, 0, 1, 1, 0, 0};\n}				/* End of main loop */\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}";
	input->stat.st_size = 48940;
}