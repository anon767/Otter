#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdarg.h>
#include <stddef.h>
#include <string.h>
#include <limits.h>

int __otter_libc_remove(const char* name)
{
	return unlink(name);
}

int asprintf(char **bufp, const char *format, ...)
{
	va_list ap;
	int rv;

	va_start(ap, format);
	rv = vasprintf(bufp, format, ap);
	va_end(ap);
	return rv;
}

/* Formats the string into a newly allocated buffer of the needed
	 size, and points *bufp to that string. */
int vasprintf(char **bufp, const char *format, va_list ap)
{
	char buffer[128];

	/* string_size will be the size that the string should be. If buffer
		 is too small, the string will be truncated and we'll have
		 string_size >= sizeof(buffer). See ISO C 7.19.6.5:3 */
	int string_size = vsnprintf(buffer, sizeof(buffer), format, ap);

	if (string_size < 0) // There was an error
		return string_size;

	if (string_size < sizeof(buffer)) { // buffer was big enough
		*bufp = strdup(buffer);
	} else { // buffer was not big enough; allocate a bigger buffer
		*bufp = malloc(string_size + 1);
		__ASSERT(vsnprintf(*bufp, ~(size_t) 0, format, ap) == string_size);
	}

	return string_size;
}

int printf(const char *format, ...)
{
	va_list ap;
	int rv;

	va_start(ap, format);
	rv = vfprintf(stdout, format, ap);
	va_end(ap);
	return rv;
}

int vprintf(const char *format, va_list ap)
{
	return vfprintf(stdout, format, ap);
}

int fprintf(FILE *stream, const char *format, ...)
{
	va_list ap;
	int rv;

	va_start(ap, format);
	rv = vfprintf(stream, format, ap);
	va_end(ap);
	return rv;
}

int vfprintf(FILE * file, const char *format, va_list ap)
{
	char *buffer;

	int string_size = vasprintf(&buffer, format, ap);

	if (string_size < 0) // There was an error
		return string_size;

	int bytes_written = fwrite(buffer, sizeof(char), string_size, file);
	free(buffer);
	return bytes_written;
}

int sprintf(char *buffer, const char *format, ...)
{
	va_list ap;
	int rv;

	va_start(ap, format);
	rv = vsnprintf(buffer, ~(size_t) 0, format, ap);
	va_end(ap);

	return rv;
}

int vsprintf(char *buffer, const char *format, va_list ap)
{
	return vsnprintf(buffer, ~(size_t) 0, format, ap);
}

int snprintf(char *buffer, size_t n, const char *format, ...)
{
	va_list ap;
	int rv;

	va_start(ap, format);
	rv = vsnprintf(buffer, n, format, ap);
	va_end(ap);
	return rv;
}

enum __otter_libc_print_flags {
	__otter_libc_print_FL_ZERO = 0x01,	/* Zero modifier */
	__otter_libc_print_FL_MINUS	= 0x02,	/* Minus modifier */
	__otter_libc_print_FL_PLUS = 0x04,	/* Plus modifier */
	__otter_libc_print_FL_TICK = 0x08,	/* ' modifier */
	__otter_libc_print_FL_SPACE	= 0x10,	/* Space modifier */
	__otter_libc_print_FL_HASH = 0x20,	/* # modifier */
	__otter_libc_print_FL_SIGNED = 0x40,	/* Number is signed */
	__otter_libc_print_FL_UPPER	= 0x80	/* Upper case digits */
};

/* These may have to be adjusted on certain implementations */
enum __otter_libc_print_ranks {
	__otter_libc_print_rank_char = -2,
	__otter_libc_print_rank_short = -1,
	__otter_libc_print_rank_int	= 0,
	__otter_libc_print_rank_long = 1,
	__otter_libc_print_rank_longlong = 2
};

#define __otter_libc_print_MIN_RANK	__otter_libc_print_rank_char
#define __otter_libc_print_MAX_RANK	__otter_libc_print_rank_longlong

#define __otter_libc_print_INTMAX_RANK	__otter_libc_print_rank_longlong
#define __otter_libc_print_SIZE_T_RANK	__otter_libc_print_rank_long
#define __otter_libc_print_PTRDIFF_T_RANK	__otter_libc_print_rank_long

#define __otter_libc_print_EMIT(x) ({ if (o<n){*q++ = (x);} o++; })

static size_t __otter_libc_print_format_int(char *q, size_t n, unsigned long long val, enum __otter_libc_print_flags flags, int base, int width, int prec)
{
	char *qq;
	size_t o = 0, oo;
	static const char lcdigits[] = "0123456789abcdef";
	static const char ucdigits[] = "0123456789ABCDEF";
	const char *digits;
	unsigned long long tmpval;
	int minus = 0;
	int ndigits = 0, nchars;
	int tickskip, b4tick;

	/* Select type of digits */
	digits = (flags & __otter_libc_print_FL_UPPER) ? ucdigits : lcdigits;

	/* If signed, separate out the minus */
	if (flags & __otter_libc_print_FL_SIGNED && (long long) val < 0) {
		minus = 1;
		val = (unsigned long long) (-(long long) val);
	}

	/* Count the number of digits needed.  This returns zero for 0. */
	tmpval = val;
	while (tmpval) {
		tmpval /= base;
		ndigits++;
	}

	/* Adjust ndigits for size of output */

	if (flags & __otter_libc_print_FL_HASH && base == 8) {
		if (prec < ndigits + 1)
			prec = ndigits + 1;
	}

	if (ndigits < prec) {
		ndigits = prec;	/* Mandatory number padding */
	} else if (val == 0) {
		ndigits = 1;	/* Zero still requires space */
	}

	/* For ', figure out what the skip should be */
	if (flags & __otter_libc_print_FL_TICK) {
		tickskip = (base == 16) ? 4 : 3;
	} else {
		tickskip = ndigits;	/* No tick marks */
	}

	/* Tick marks aren't digits, but generated by the number converter */
	ndigits += (ndigits - 1) / tickskip;

	/* Now compute the number of nondigits */
	nchars = ndigits;

	if (minus || (flags & (__otter_libc_print_FL_PLUS | __otter_libc_print_FL_SPACE)))
		nchars++;	/* Need space for sign */
	if ((flags & __otter_libc_print_FL_HASH) && base == 16) {
		nchars += 2;	/* Add 0x for hex */
	}

	/* Emit early space padding */
	if (!(flags & (__otter_libc_print_FL_MINUS | __otter_libc_print_FL_ZERO)) && width > nchars) {
		while (width > nchars) {
			__otter_libc_print_EMIT(' ');
			width--;
		}
	}

	/* Emit nondigits */
	if (minus)
		__otter_libc_print_EMIT('-');
	else if (flags & __otter_libc_print_FL_PLUS)
		__otter_libc_print_EMIT('+');
	else if (flags & __otter_libc_print_FL_SPACE)
		__otter_libc_print_EMIT(' ');

	if ((flags & __otter_libc_print_FL_HASH) && base == 16) {
		__otter_libc_print_EMIT('0');
		__otter_libc_print_EMIT((flags & __otter_libc_print_FL_UPPER) ? 'X' : 'x');
	}

	/* Emit zero padding */
	if ((flags & (__otter_libc_print_FL_MINUS | __otter_libc_print_FL_ZERO)) == __otter_libc_print_FL_ZERO && width > ndigits) {
		while (width > nchars) {
			__otter_libc_print_EMIT('0');
			width--;
		}
	}

	/* Generate the number.  This is done from right to left. */
	q += ndigits;		/* Advance the pointer to end of number */
	o += ndigits;
	qq = q;
	oo = o;			/* Temporary values */

	b4tick = tickskip;
	while (ndigits > 0) {
		if (!b4tick--) {
			qq--;
			oo--;
			ndigits--;
			if (oo < n)
				*qq = '_';
			b4tick = tickskip - 1;
		}
		qq--;
		oo--;
		ndigits--;
		if (oo < n)
			*qq = digits[val % base];
		val /= base;
	}

	/* Emit late space padding */
	while ((flags & __otter_libc_print_FL_MINUS) && width > nchars) {
		__otter_libc_print_EMIT(' ');
		width--;
	}

	return o;
}

int vsnprintf(char *buffer, size_t n, const char *format, va_list ap)
{
	const char *p = format;
	char ch;
	char *q = buffer;
	size_t o = 0;		/* Number of characters output */
	unsigned long long val = 0;
	int rank = __otter_libc_print_rank_int;	/* Default rank */
	int width = 0;
	int prec = -1;
	int base;
	size_t sz;
	enum __otter_libc_print_flags flags = 0;
	enum {
		st_normal,	/* Ground state */
		st_flags,	/* Special flags */
		st_width,	/* Field width */
		st_prec,	/* Field precision */
		st_modifiers	/* Length or conversion modifiers */
	} state = st_normal;
	const char *sarg;	/* %s string argument */
	char carg;		/* %c char argument */
	int slen;		/* String length */

	while ((ch = *p++)) {
		switch (state) {
		case st_normal:
			if (ch == '%') {
				state = st_flags;
				flags = 0;
				rank = __otter_libc_print_rank_int;
				width = 0;
				prec = -1;
			} else {
				__otter_libc_print_EMIT(ch);
			}
			break;

		case st_flags:
			switch (ch) {
			case '-':
				flags |= __otter_libc_print_FL_MINUS;
				break;
			case '+':
				flags |= __otter_libc_print_FL_PLUS;
				break;
			case '\'':
				flags |= __otter_libc_print_FL_TICK;
				break;
			case ' ':
				flags |= __otter_libc_print_FL_SPACE;
				break;
			case '#':
				flags |= __otter_libc_print_FL_HASH;
				break;
			case '0':
				flags |= __otter_libc_print_FL_ZERO;
				break;
			default:
				state = st_width;
				p--;	/* Process this character again */
				break;
			}
			break;

		case st_width:
			if (ch >= '0' && ch <= '9') {
				width = width * 10 + (ch - '0');
			} else if (ch == '*') {
				width = va_arg(ap, int);
				if (width < 0) {
					width = -width;
					flags |= __otter_libc_print_FL_MINUS;
				}
			} else if (ch == '.') {
				prec = 0;	/* Precision given */
				state = st_prec;
			} else {
				state = st_modifiers;
				p--;	/* Process this character again */
			}
			break;

		case st_prec:
			if (ch >= '0' && ch <= '9') {
				prec = prec * 10 + (ch - '0');
			} else if (ch == '*') {
				prec = va_arg(ap, int);
				if (prec < 0)
					prec = -1;
			} else {
				state = st_modifiers;
				p--;	/* Process this character again */
			}
			break;

		case st_modifiers:
			switch (ch) {
				/* Length modifiers - nonterminal sequences */
			case 'h':
				rank--;	/* Shorter rank */
				break;
			case 'l':
				rank++;	/* Longer rank */
				break;
			case 'j':
				rank = __otter_libc_print_INTMAX_RANK;
				break;
			case 'z':
				rank = __otter_libc_print_SIZE_T_RANK;
				break;
			case 't':
				rank = __otter_libc_print_PTRDIFF_T_RANK;
				break;
			case 'L':
			case 'q':
				rank += 2;
				break;
			default:
				/* Output modifiers - terminal sequences */

				/* Next state will be normal */
				state = st_normal;

				/* Canonicalize rank */
				if (rank < __otter_libc_print_MIN_RANK)
					rank = __otter_libc_print_MIN_RANK;
				else if (rank > __otter_libc_print_MAX_RANK)
					rank = __otter_libc_print_MAX_RANK;

				switch (ch) {
				case 'P':	/* Upper case pointer */
					flags |= __otter_libc_print_FL_UPPER;
					/* fall through */
				case 'p':	/* Pointer */
					base = 16;
					prec = (CHAR_BIT*sizeof(void *)+3)/4;
					flags |= __otter_libc_print_FL_HASH;
					val = (unsigned long long)(unsigned int*)va_arg(ap, void *);
					goto is_integer;

				case 'd':	/* Signed decimal output */
				case 'i':
					base = 10;
					flags |= __otter_libc_print_FL_SIGNED;
					switch (rank) {
					case __otter_libc_print_rank_char:
						/* Yes, all these casts are needed... */
						val = (unsigned long long)(long long)(signed char)va_arg(ap, signed int);
						break;
					case __otter_libc_print_rank_short:
						val = (unsigned long long)(long long)(signed short)va_arg(ap, signed int);
						break;
					case __otter_libc_print_rank_int:
						val = (unsigned long long)(long long)va_arg(ap, signed int);
						break;
					case __otter_libc_print_rank_long:
						val = (unsigned long long)(long long)va_arg(ap, signed long);
						break;
					case __otter_libc_print_rank_longlong:
						val = (unsigned long long)(long long)va_arg(ap, signed long long);
						break;
					}
					goto is_integer;
				case 'o':	/* Octal */
					base = 8;
					goto is_unsigned;
				case 'u':	/* Unsigned decimal */
					base = 10;
					goto is_unsigned;
				case 'X':	/* Upper case hexadecimal */
					flags |= __otter_libc_print_FL_UPPER;
					/* fall through */
				case 'x':	/* Hexadecimal */
					base = 16;
					goto is_unsigned;

				is_unsigned:
					switch (rank) {
					case __otter_libc_print_rank_char:
						val = (unsigned long long)(unsigned char)va_arg(ap, unsigned int);
						break;
					case __otter_libc_print_rank_short:
						val = (unsigned long long)(unsigned short)va_arg(ap, unsigned int);
						break;
					case __otter_libc_print_rank_int:
						val = (unsigned long long)va_arg(ap, unsigned int);
						break;
					case __otter_libc_print_rank_long:
						val = (unsigned long long)va_arg(ap, unsigned long);
						break;
					case __otter_libc_print_rank_longlong:
						val = (unsigned long long)va_arg(ap, unsigned long long);
						break;
					}
					/* fall through */

				is_integer:
					sz = __otter_libc_print_format_int(q, (o < n) ? n - o : 0,
							val, flags, base,
							width, prec);
					q += sz;
					o += sz;
					break;

				case 'c':	/* Character */
					carg = (char)va_arg(ap, int);
					sarg = &carg;
					slen = 1;
					goto is_string;
				case 's':	/* String */
					sarg = va_arg(ap, const char *);
					sarg = sarg ? sarg : "(null)";
					slen = strlen(sarg);
					goto is_string;

				is_string:
					{
						char sch;
						int i;

						if (prec != -1 && slen > prec)
							slen = prec;

						if (width > slen
						    && !(flags & __otter_libc_print_FL_MINUS)) {
							char pad = (flags & __otter_libc_print_FL_ZERO) ? '0' : ' ';
							while (width > slen) {
								__otter_libc_print_EMIT(pad);
								width--;
							}
						}
						for (i = slen; i; i--) {
							sch = *sarg++;
							__otter_libc_print_EMIT(sch);
						}
						if (width > slen
						    && (flags & __otter_libc_print_FL_MINUS)) {
							while (width > slen) {
								__otter_libc_print_EMIT(' ');
								width--;
							}
						}
					}
					break;

				case 'n':
					{
						/* Output the number of
						   characters written */

						switch (rank) {
						case __otter_libc_print_rank_char:
							*va_arg(ap, signed char *) = o;
							break;
						case __otter_libc_print_rank_short:
							*va_arg(ap, signed short *) = o;
							break;
						case __otter_libc_print_rank_int:
							*va_arg(ap, signed int *) = o;
							break;
						case __otter_libc_print_rank_long:
							*va_arg(ap, signed long *) = o;
							break;
						case __otter_libc_print_rank_longlong:
							*va_arg(ap, signed long long *) = o;
							break;
						}
					}
					break;

				default:	/* Anything else, including % */
					__otter_libc_print_EMIT(ch);
					break;
				}
			}
		}
	}

	/* Null-terminate the string */
	if (o < n)
		*q = '\0';	/* No overflow */
	else if (n > 0)
		buffer[n - 1] = '\0';	/* Overflow - terminate at end of buffer */

	return o;
}

FILE * fopen (const char * filename, const char * mode)
{
	int openFlags, plus = 0;
	if (!(mode && mode[0])) { // If mode is null or ""
		errno = EINVAL;
		return NULL;
	}

	if (mode[1] == '+' || (mode[1] == 'b' && mode[2] == '+')) {
		plus = 1;
	}

	switch (mode[0]) {
	case 'r':
		openFlags = plus ? O_RDWR : O_RDONLY;
		break;
	case 'w':
		openFlags = O_CREAT | O_TRUNC | (plus ? O_RDWR : O_WRONLY);
		break;
	case 'a':
		openFlags = O_CREAT | O_APPEND | (plus ? O_RDWR : O_WRONLY);
		break;
	default:
		errno = EINVAL;
		return NULL;
	}

	int fd = open(filename, openFlags, 0666); // 0666 is stated in the spec
	if (fd == -1) {
		return NULL;
	}
	FILE *file = calloc(1, sizeof(FILE));
	file->desc = fd;
	/* TODO: What should the buffering be? See ISO 7.19.5.3:7 */
	file->bufmode = _IONBF;
	return file;
}

/* TODO: this should fail with EBADF if stream is an invalid file
	 stream. How would we detect that? If desc is an invalid
	 descriptor? */
int fileno(FILE *stream) { return stream->desc; }

size_t __otter_libc_internal_fwrite(const void *buf, size_t count, FILE *f)
{
	size_t bytes = 0;
	ssize_t rv;
	const char *p = buf;

	while (count) {
		rv = write(fileno(f), p, count);
		if (rv == -1) {
			if (errno == EINTR) {
				errno = 0;
				continue;
			} else
				break;
		} else if (rv == 0) {
			break;
		}

		p += rv;
		bytes += rv;
		count -= rv;
	}

	return bytes;
}

size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE * f)
{
	return __otter_libc_internal_fwrite(ptr, size * nmemb, f) / size;
}
