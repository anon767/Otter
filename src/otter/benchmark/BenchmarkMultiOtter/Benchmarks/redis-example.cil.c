/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 4 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/stddef.h"
typedef unsigned int size_t;
#line 36 "adlist.h"
struct listNode {
   struct listNode *prev ;
   struct listNode *next ;
   void *value ;
};
#line 36 "adlist.h"
typedef struct listNode listNode;
#line 42 "adlist.h"
struct listIter {
   listNode *next ;
   int direction ;
};
#line 42 "adlist.h"
typedef struct listIter listIter;
#line 47 "adlist.h"
struct list {
   listNode *head ;
   listNode *tail ;
   void *(*dup)(void *ptr ) ;
   void (*free)(void *ptr ) ;
   int (*match)(void *ptr , void *key ) ;
   unsigned int len ;
};
#line 47 "adlist.h"
typedef struct list list;
#line 109 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef long time_t;
#line 222 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef long fd_mask;
#line 230 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
struct _types_fd_set {
   fd_mask fds_bits[(64UL + (sizeof(fd_mask ) * 8UL - 1UL)) / (sizeof(fd_mask ) * 8UL)] ;
};
#line 230 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef struct _types_fd_set _types_fd_set;
#line 263 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef long suseconds_t;
#line 17 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/time.h"
struct timeval {
   time_t tv_sec ;
   suseconds_t tv_usec ;
};
#line 55 "ae.h"
struct aeEventLoop;
#line 58 "ae.h"
typedef void aeFileProc(struct aeEventLoop *eventLoop , int fd , void *clientData ,
                        int mask );
#line 59 "ae.h"
typedef int aeTimeProc(struct aeEventLoop *eventLoop , long long id , void *clientData );
#line 60 "ae.h"
typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop , void *clientData );
#line 61 "ae.h"
typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop );
#line 64 "ae.h"
struct aeFileEvent {
   int mask ;
   aeFileProc *rfileProc ;
   aeFileProc *wfileProc ;
   void *clientData ;
};
#line 64 "ae.h"
typedef struct aeFileEvent aeFileEvent;
#line 72 "ae.h"
struct aeTimeEvent {
   long long id ;
   long when_sec ;
   long when_ms ;
   aeTimeProc *timeProc ;
   aeEventFinalizerProc *finalizerProc ;
   void *clientData ;
   struct aeTimeEvent *next ;
};
#line 72 "ae.h"
typedef struct aeTimeEvent aeTimeEvent;
#line 83 "ae.h"
struct aeFiredEvent {
   int fd ;
   int mask ;
};
#line 83 "ae.h"
typedef struct aeFiredEvent aeFiredEvent;
#line 89 "ae.h"
struct aeEventLoop {
   int maxfd ;
   long long timeEventNextId ;
   aeFileEvent events[16] ;
   aeFiredEvent fired[16] ;
   aeTimeEvent *timeEventHead ;
   int stop ;
   void *apidata ;
   aeBeforeSleepProc *beforesleep ;
};
#line 89 "ae.h"
typedef struct aeEventLoop aeEventLoop;
#line 8 "ae_select.c"
struct aeApiState {
   _types_fd_set rfds ;
   _types_fd_set wfds ;
   _types_fd_set _rfds ;
   _types_fd_set _wfds ;
};
#line 8 "ae_select.c"
typedef struct aeApiState aeApiState;
#line 24 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_inode;
#line 25
struct __otter_fs_filelist;
#line 26
struct __otter_fs_dirlist;
#line 27
struct __otter_fs_dnode;
#line 29 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_inode {
   int linkno ;
   int size ;
   int numblocks ;
   int type ;
   int permissions ;
   char *data ;
   int r_openno ;
   int w_openno ;
};
#line 51
struct sockaddr;
#line 66 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_filelist {
   char *name ;
   struct __otter_fs_inode *inode ;
   struct __otter_fs_filelist *next ;
};
#line 73 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dirlist {
   char *name ;
   struct __otter_fs_dnode *dnode ;
   struct __otter_fs_dirlist *next ;
};
#line 80 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dnode {
   int linkno ;
   int numdirs ;
   int numfiles ;
   struct __otter_fs_dirlist *dirs ;
   struct __otter_fs_filelist *files ;
   int permissions ;
   int r_openno ;
};
#line 104 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_open_file_table_entry {
   int mode ;
   int offset ;
   int type ;
   struct __otter_fs_inode *inode ;
   struct __otter_fs_dnode *dnode ;
   int openno ;
};
#line 73 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
typedef unsigned int socklen_t;
#line 74 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
typedef unsigned short sa_family_t;
#line 78 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 15 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[92] ;
};
#line 39 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netinet/in.h"
typedef unsigned short in_port_t;
#line 40 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netinet/in.h"
typedef unsigned int in_addr_t;
#line 13 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/arpa/inet.h"
struct in_addr;
#line 44 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 51 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[8] ;
};
#line 6 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 4 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/stdarg.h"
typedef __builtin_va_list va_list;
#line 45 "dict.h"
struct dictEntry {
   void *key ;
   void *val ;
   struct dictEntry *next ;
};
#line 45 "dict.h"
typedef struct dictEntry dictEntry;
#line 51 "dict.h"
struct dictType {
   unsigned int (*hashFunction)(void const   *key ) ;
   void *(*keyDup)(void *privdata , void const   *key ) ;
   void *(*valDup)(void *privdata , void const   *obj ) ;
   int (*keyCompare)(void *privdata , void const   *key1 , void const   *key2 ) ;
   void (*keyDestructor)(void *privdata , void *key ) ;
   void (*valDestructor)(void *privdata , void *obj ) ;
};
#line 51 "dict.h"
typedef struct dictType dictType;
#line 62 "dict.h"
struct dictht {
   dictEntry **table ;
   unsigned long size ;
   unsigned long sizemask ;
   unsigned long used ;
};
#line 62 "dict.h"
typedef struct dictht dictht;
#line 69 "dict.h"
struct dict {
   dictType *type ;
   void *privdata ;
   dictht ht[2] ;
   int rehashidx ;
   int iterators ;
};
#line 69 "dict.h"
typedef struct dict dict;
#line 77 "dict.h"
struct dictIterator {
   dict *d ;
   int table ;
   int index ;
   dictEntry *entry ;
   dictEntry *nextEntry ;
};
#line 77 "dict.h"
typedef struct dictIterator dictIterator;
#line 11 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/stddef.h"
typedef int wint_t;
#line 59 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/machine/_default_types.h"
typedef unsigned int __uint32_t;
#line 7 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/lock.h"
typedef int _LOCK_RECURSIVE_T;
#line 16 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef long _off_t;
#line 44 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef long _fpos_t;
#line 67 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 67 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 67 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 79 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef _LOCK_RECURSIVE_T _flock_t;
#line 21 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
typedef unsigned long __ULong;
#line 37
struct _reent;
#line 44 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 52 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 71 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 82 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args *_on_exit_args_ptr ;
};
#line 105 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 169 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   int (*_read)(struct _reent * , void * , char * , int  ) ;
   int (*_write)(struct _reent * , void * , char const   * , int  ) ;
   _fpos_t (*_seek)(struct _reent * , void * , _fpos_t  , int  ) ;
   int (*_close)(struct _reent * , void * ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _offset ;
   _flock_t _lock ;
   _mbstate_t _mbstate ;
   int _flags2 ;
};
#line 273 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
typedef struct __sFILE __FILE;
#line 277 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 305 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
   unsigned long long _rand_next ;
};
#line 330 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _mprec {
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
};
#line 340 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _misc_reent {
   char *_strtok_last ;
   _mbstate_t _mblen_state ;
   _mbstate_t _wctomb_state ;
   _mbstate_t _mbtowc_state ;
   char _l64a_buf[8] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
};
#line 358 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char *_emergency ;
   int __sdidinit ;
   int _current_category ;
   char const   *_current_locale ;
   struct _mprec *_mp ;
   void (*__cleanup)(struct _reent * ) ;
   int _gamma_signgam ;
   int _cvtlen ;
   char *_cvtbuf ;
   struct _rand48 *_r48 ;
   struct __tm *_localtime_buf ;
   char *_asctime_buf ;
   void (**_sig_func)(int  ) ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   struct _glue __sglue ;
   __FILE *__sf ;
   struct _misc_reent *_misc ;
   char *_signal_buf ;
};
#line 162 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef _off_t off_t;
#line 171 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef int pid_t;
#line 46 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/sched.h"
struct sched_param {
   int sched_priority ;
};
#line 286 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef __uint32_t pthread_t;
#line 348 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
struct __anonstruct_pthread_attr_t_3 {
   int is_initialized ;
   void *stackaddr ;
   int stacksize ;
   int contentionscope ;
   int inheritsched ;
   int schedpolicy ;
   struct sched_param schedparam ;
   int detachstate ;
};
#line 348 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef struct __anonstruct_pthread_attr_t_3 pthread_attr_t;
#line 408 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef __uint32_t pthread_mutex_t;
#line 50 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
typedef __FILE FILE;
#line 37 "sds.h"
typedef char *sds;
#line 228 "redis.h"
struct redisObject {
   unsigned int type : 4 ;
   unsigned int storage : 2 ;
   unsigned int encoding : 4 ;
   unsigned int lru : 22 ;
   int refcount ;
   void *ptr ;
};
#line 228 "redis.h"
typedef struct redisObject robj;
#line 274 "redis.h"
struct redisDb {
   dict *dict ;
   dict *expires ;
   dict *blocking_keys ;
   dict *io_keys ;
   dict *watched_keys ;
   int id ;
};
#line 274 "redis.h"
typedef struct redisDb redisDb;
#line 284
struct redisCommand;
#line 284 "redis.h"
struct multiCmd {
   robj **argv ;
   int argc ;
   struct redisCommand *cmd ;
};
#line 284 "redis.h"
typedef struct multiCmd multiCmd;
#line 290 "redis.h"
struct multiState {
   multiCmd *commands ;
   int count ;
};
#line 290 "redis.h"
typedef struct multiState multiState;
#line 295 "redis.h"
struct blockingState {
   robj **keys ;
   int count ;
   time_t timeout ;
   robj *target ;
};
#line 295 "redis.h"
typedef struct blockingState blockingState;
#line 307 "redis.h"
struct redisClient {
   int fd ;
   redisDb *db ;
   int dictid ;
   sds querybuf ;
   int argc ;
   robj **argv ;
   int reqtype ;
   int multibulklen ;
   long bulklen ;
   list *reply ;
   int sentlen ;
   time_t lastinteraction ;
   int flags ;
   int slaveseldb ;
   int authenticated ;
   int replstate ;
   int repldbfd ;
   long repldboff ;
   off_t repldbsize ;
   multiState mstate ;
   blockingState bpop ;
   list *io_keys ;
   list *watched_keys ;
   dict *pubsub_channels ;
   list *pubsub_patterns ;
   int bufpos ;
   char buf[7500] ;
};
#line 307 "redis.h"
typedef struct redisClient redisClient;
#line 340 "redis.h"
struct saveparam {
   time_t seconds ;
   int changes ;
};
#line 345 "redis.h"
struct sharedObjectsStruct {
   robj *crlf ;
   robj *ok ;
   robj *err ;
   robj *emptybulk ;
   robj *czero ;
   robj *cone ;
   robj *cnegone ;
   robj *pong ;
   robj *space ;
   robj *colon ;
   robj *nullbulk ;
   robj *nullmultibulk ;
   robj *queued ;
   robj *emptymultibulk ;
   robj *wrongtypeerr ;
   robj *nokeyerr ;
   robj *syntaxerr ;
   robj *sameobjecterr ;
   robj *outofrangeerr ;
   robj *loadingerr ;
   robj *plus ;
   robj *select0 ;
   robj *select1 ;
   robj *select2 ;
   robj *select3 ;
   robj *select4 ;
   robj *select5 ;
   robj *select6 ;
   robj *select7 ;
   robj *select8 ;
   robj *select9 ;
   robj *messagebulk ;
   robj *pmessagebulk ;
   robj *subscribebulk ;
   robj *unsubscribebulk ;
   robj *mbulk3 ;
   robj *mbulk4 ;
   robj *psubscribebulk ;
   robj *punsubscribebulk ;
   robj *integers[10] ;
};
#line 358 "redis.h"
struct redisServer {
   pthread_t mainthread ;
   int port ;
   char *bindaddr ;
   char *unixsocket ;
   int ipfd ;
   int sofd ;
   redisDb *db ;
   long long dirty ;
   long long dirty_before_bgsave ;
   list *clients ;
   dict *commands ;
   int loading ;
   off_t loading_total_bytes ;
   off_t loading_loaded_bytes ;
   time_t loading_start_time ;
   struct redisCommand *delCommand ;
   struct redisCommand *multiCommand ;
   list *slaves ;
   list *monitors ;
   char neterr[256] ;
   aeEventLoop *el ;
   int cronloops ;
   time_t lastsave ;
   time_t stat_starttime ;
   long long stat_numcommands ;
   long long stat_numconnections ;
   long long stat_expiredkeys ;
   long long stat_evictedkeys ;
   long long stat_keyspace_hits ;
   long long stat_keyspace_misses ;
   int verbosity ;
   int maxidletime ;
   int dbnum ;
   int daemonize ;
   int appendonly ;
   int appendfsync ;
   int no_appendfsync_on_rewrite ;
   int shutdown_asap ;
   time_t lastfsync ;
   int appendfd ;
   int appendseldb ;
   char *pidfile ;
   pid_t bgsavechildpid ;
   pid_t bgrewritechildpid ;
   sds bgrewritebuf ;
   sds aofbuf ;
   struct saveparam *saveparams ;
   int saveparamslen ;
   char *logfile ;
   int syslog_enabled ;
   char *syslog_ident ;
   int syslog_facility ;
   char *dbfilename ;
   char *appendfilename ;
   char *requirepass ;
   int rdbcompression ;
   int activerehashing ;
   int isslave ;
   char *masterauth ;
   char *masterhost ;
   int masterport ;
   redisClient *master ;
   int replstate ;
   off_t repl_transfer_left ;
   int repl_transfer_s ;
   int repl_transfer_fd ;
   char *repl_transfer_tmpfile ;
   time_t repl_transfer_lastio ;
   int repl_serve_stale_data ;
   unsigned int maxclients ;
   unsigned long long maxmemory ;
   int maxmemory_policy ;
   int maxmemory_samples ;
   unsigned int bpop_blocked_clients ;
   unsigned int vm_blocked_clients ;
   list *unblocked_clients ;
   int sort_desc ;
   int sort_alpha ;
   int sort_bypattern ;
   int vm_enabled ;
   char *vm_swap_file ;
   off_t vm_page_size ;
   off_t vm_pages ;
   unsigned long long vm_max_memory ;
   size_t hash_max_zipmap_entries ;
   size_t hash_max_zipmap_value ;
   size_t list_max_ziplist_entries ;
   size_t list_max_ziplist_value ;
   size_t set_max_intset_entries ;
   FILE *vm_fp ;
   int vm_fd ;
   off_t vm_next_page ;
   off_t vm_near_pages ;
   unsigned char *vm_bitmap ;
   time_t unixtime ;
   list *io_newjobs ;
   list *io_processing ;
   list *io_processed ;
   list *io_ready_clients ;
   pthread_mutex_t io_mutex ;
   pthread_mutex_t io_swapfile_mutex ;
   pthread_attr_t io_threads_attr ;
   int io_active_threads ;
   int vm_max_threads ;
   int io_ready_pipe_read ;
   int io_ready_pipe_write ;
   unsigned long long vm_stats_used_pages ;
   unsigned long long vm_stats_swapped_objects ;
   unsigned long long vm_stats_swapouts ;
   unsigned long long vm_stats_swapins ;
   dict *pubsub_channels ;
   list *pubsub_patterns ;
   unsigned int lruclock : 22 ;
   unsigned int lruclock_padding : 10 ;
};
#line 502 "redis.h"
typedef void redisCommandProc(redisClient *c );
#line 503 "redis.h"
typedef void redisVmPreloadProc(redisClient *c , struct redisCommand *cmd , int argc ,
                                robj **argv );
#line 504 "redis.h"
struct redisCommand {
   char *name ;
   redisCommandProc *proc ;
   int arity ;
   int flags ;
   redisVmPreloadProc *vm_preload_proc ;
   int vm_firstkey ;
   int vm_lastkey ;
   int vm_keystep ;
};
#line 108 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/signal.h"
typedef void (*_sig_func_ptr)(int  );
#line 9 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
};
#line 39 "sds.h"
struct sdshdr {
   int len ;
   int free ;
   char buf[] ;
};
#line 127 "lzfP.h"
typedef unsigned char u8;
#line 129 "lzfP.h"
typedef u8 const   *LZF_STATE[1 << 16];
#line 80 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef unsigned long uint32_t;
#line 13 "sha1.h"
struct __anonstruct_SHA1_CTX_8 {
   uint32_t state[5] ;
   uint32_t count[2] ;
   unsigned char buffer[64] ;
};
#line 13 "sha1.h"
typedef struct __anonstruct_SHA1_CTX_8 SHA1_CTX;
#line 109 "sha1.c"
union __anonunion_CHAR64LONG16_9 {
   unsigned char c[64] ;
   uint32_t l[16] ;
};
#line 109 "sha1.c"
typedef union __anonunion_CHAR64LONG16_9 CHAR64LONG16;
#line 53 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef short int16_t;
#line 54 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef unsigned short uint16_t;
#line 79 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef long int32_t;
#line 119 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef long long int64_t;
#line 103 "ziplist.c"
struct zlentry {
   unsigned int prevrawlensize ;
   unsigned int prevrawlen ;
   unsigned int lensize ;
   unsigned int len ;
   unsigned int headersize ;
   unsigned char encoding ;
   unsigned char *p ;
};
#line 103 "ziplist.c"
typedef struct zlentry zlentry;
#line 41 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef signed char int8_t;
#line 5 "intset.h"
struct intset {
   uint32_t encoding ;
   uint32_t length ;
   int8_t contents[] ;
};
#line 5 "intset.h"
typedef struct intset intset;
#line 253 "redis.h"
struct vmPointer {
   unsigned int type : 4 ;
   unsigned int storage : 2 ;
   unsigned int notused : 26 ;
   unsigned int vtype ;
   off_t page ;
   off_t usedpages ;
};
#line 253 "redis.h"
typedef struct vmPointer vmpointer;
#line 538
struct zskiplistNode;
#line 538 "redis.h"
struct zskiplistLevel {
   struct zskiplistNode *forward ;
   unsigned int span ;
};
#line 538 "redis.h"
struct zskiplistNode {
   robj *obj ;
   double score ;
   struct zskiplistNode *backward ;
   struct zskiplistLevel level[] ;
};
#line 548 "redis.h"
struct zskiplist {
   struct zskiplistNode *header ;
   struct zskiplistNode *tail ;
   unsigned long length ;
   int level ;
};
#line 548 "redis.h"
typedef struct zskiplist zskiplist;
#line 554 "redis.h"
struct zset {
   dict *dict ;
   zskiplist *zsl ;
};
#line 554 "redis.h"
typedef struct zset zset;
#line 6 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/machine/_types.h"
typedef int blkcnt_t;
#line 7 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/machine/_types.h"
typedef int blksize_t;
#line 24 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef short __dev_t;
#line 29 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef unsigned short __uid_t;
#line 32 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef unsigned short __gid_t;
#line 56 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef int _ssize_t;
#line 133 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned short ino_t;
#line 163 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef __dev_t dev_t;
#line 164 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef __uid_t uid_t;
#line 165 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef __gid_t gid_t;
#line 181 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef _ssize_t ssize_t;
#line 195 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned int mode_t;
#line 200 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned short nlink_t;
#line 101 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct stat;
#line 9 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/stat.h"
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   off_t st_size ;
   time_t st_atime ;
   time_t st_mtime ;
   time_t st_ctime ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
};
#line 42 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef unsigned char uint8_t;
#line 538 "redis.h"
typedef struct zskiplistNode zskiplistNode;
#line 579 "redis.h"
struct __anonstruct_listTypeIterator_12 {
   robj *subject ;
   unsigned char encoding ;
   unsigned char direction ;
   unsigned char *zi ;
   listNode *ln ;
};
#line 579 "redis.h"
typedef struct __anonstruct_listTypeIterator_12 listTypeIterator;
#line 588 "redis.h"
struct __anonstruct_listTypeEntry_13 {
   listTypeIterator *li ;
   unsigned char *zi ;
   listNode *ln ;
};
#line 588 "redis.h"
typedef struct __anonstruct_listTypeEntry_13 listTypeEntry;
#line 595 "redis.h"
struct __anonstruct_setTypeIterator_14 {
   robj *subject ;
   int encoding ;
   int ii ;
   dictIterator *di ;
};
#line 595 "redis.h"
typedef struct __anonstruct_setTypeIterator_14 setTypeIterator;
#line 178 "t_zset.c"
struct __anonstruct_zrangespec_16 {
   double min ;
   double max ;
   int minex ;
   int maxex ;
};
#line 178 "t_zset.c"
typedef struct __anonstruct_zrangespec_16 zrangespec;
#line 548 "t_zset.c"
struct __anonstruct_zsetopsrc_17 {
   dict *dict ;
   double weight ;
};
#line 548 "t_zset.c"
typedef struct __anonstruct_zsetopsrc_17 zsetopsrc;
#line 606 "redis.h"
struct __anonstruct_hashTypeIterator_15 {
   int encoding ;
   unsigned char *zi ;
   unsigned char *zk ;
   unsigned char *zv ;
   unsigned int zklen ;
   unsigned int zvlen ;
   dictIterator *di ;
   dictEntry *de ;
};
#line 606 "redis.h"
typedef struct __anonstruct_hashTypeIterator_15 hashTypeIterator;
#line 125 "config.c"
struct __anonstruct_validSyslogFacilities_16 {
   char const   *name ;
   int value ;
};
#line 262 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned long useconds_t;
#line 410 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
struct __anonstruct_pthread_mutexattr_t_4 {
   int is_initialized ;
   int recursive ;
};
#line 410 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef struct __anonstruct_pthread_mutexattr_t_4 pthread_mutexattr_t;
#line 563 "redis.h"
struct iojob {
   int type ;
   redisDb *db ;
   robj *key ;
   robj *id ;
   robj *val ;
   off_t page ;
   off_t pages ;
   int canceled ;
   pthread_t thread ;
};
#line 563 "redis.h"
typedef struct iojob iojob;
#line 38 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   off_t l_start ;
   off_t l_len ;
   pid_t l_pid ;
};
#line 15 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/signal.h"
typedef unsigned long sigset_t;
#line 497 "redis.h"
struct pubsubPattern {
   redisClient *client ;
   robj *pattern ;
};
#line 497 "redis.h"
typedef struct pubsubPattern pubsubPattern;
#line 137 "multi.c"
struct watchedKey {
   robj *key ;
   redisDb *db ;
};
#line 137 "multi.c"
typedef struct watchedKey watchedKey;
#line 524 "redis.h"
union __anonunion_u_11 {
   double score ;
   robj *cmpobj ;
};
#line 524 "redis.h"
struct _redisSortObject {
   robj *obj ;
   union __anonunion_u_11 u ;
};
#line 524 "redis.h"
typedef struct _redisSortObject redisSortObject;
#line 532 "redis.h"
struct _redisSortOperation {
   int type ;
   robj *pattern ;
};
#line 532 "redis.h"
typedef struct _redisSortOperation redisSortOperation;
#line 21 "sort.c"
struct __anonstruct_keyname_16 {
   int len ;
   int free ;
   char buf[1025] ;
};
#line 79 "deps/hiredis/hiredis.h"
struct redisReply {
   int type ;
   long long integer ;
   int len ;
   char *str ;
   size_t elements ;
   struct redisReply **element ;
};
#line 79 "deps/hiredis/hiredis.h"
typedef struct redisReply redisReply;
#line 88 "deps/hiredis/hiredis.h"
struct redisReadTask {
   int type ;
   int elements ;
   int idx ;
   void *obj ;
   struct redisReadTask *parent ;
   void *privdata ;
};
#line 88 "deps/hiredis/hiredis.h"
typedef struct redisReadTask redisReadTask;
#line 97 "deps/hiredis/hiredis.h"
struct redisReplyObjectFunctions {
   void *(*createString)(redisReadTask const   * , char * , size_t  ) ;
   void *(*createArray)(redisReadTask const   * , int  ) ;
   void *(*createInteger)(redisReadTask const   * , long long  ) ;
   void *(*createNil)(redisReadTask const   * ) ;
   void (*freeObject)(void * ) ;
};
#line 97 "deps/hiredis/hiredis.h"
typedef struct redisReplyObjectFunctions redisReplyObjectFunctions;
#line 105
struct redisContext;
#line 108 "deps/hiredis/hiredis.h"
struct redisContext {
   int fd ;
   int flags ;
   char *obuf ;
   int err ;
   char *errstr ;
   redisReplyObjectFunctions *fn ;
   void *reader ;
};
#line 108 "deps/hiredis/hiredis.h"
typedef struct redisContext redisContext;
#line 17 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/stddef.h"
typedef long long ptrdiff_t;
#line 7 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/stddef.h"
typedef short wchar_t;
#line 47 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/wchar.h"
typedef _mbstate_t mbstate_t;
#line 141 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct __sFILE_fake {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
};
#line 92 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned char u_char;
#line 67 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
union double_union {
   double d ;
   __uint32_t i[2] ;
};
#line 351 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
typedef struct _Bigint _Bigint;
#line 24 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fvwrite.h"
struct __siov {
   void const   *iov_base ;
   size_t iov_len ;
};
#line 28 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fvwrite.h"
struct __suio {
   struct __siov *uio_iov ;
   int uio_iovcnt ;
   int uio_resid ;
};
#line 58 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/machine/_default_types.h"
typedef int __int32_t;
#line 83 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
typedef __int32_t Long;
#line 382
struct FPI;
#line 56 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa.h"
struct FPI {
   int nbits ;
   int emin ;
   int emax ;
   int rounding ;
   int sudden_underflow ;
};
#line 26 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_p_sign_posn ;
};
#line 94 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned int u_int;
#line 88 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
union __anonunion_U_17 {
   double d ;
   __ULong i[2] ;
};
#line 88 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
typedef union __anonunion_U_17 U;
#line 56 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa.h"
typedef struct FPI FPI;
#line 95 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned long u_long;
#line 224 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef long long intmax_t;
#line 184 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
enum __anonenum___CH_CLASS_11 {
    ZERO = 0,
    DIGIT = 1,
    DOLLAR = 2,
    MODFR = 3,
    SPEC = 4,
    DOT = 5,
    STAR = 6,
    FLAG = 7,
    OTHER = 8,
    MAX_CH_CLASS = 9
} ;
#line 184 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
typedef enum __anonenum___CH_CLASS_11 __CH_CLASS;
#line 197
enum __anonenum___STATE_12 {
    START = 0,
    SFLAG = 1,
    WDIG = 2,
    WIDTH = 3,
    SMOD = 4,
    SDOT = 5,
    VARW = 6,
    VARP = 7,
    PREC = 8,
    VWDIG = 9,
    VPDIG = 10,
    DONE = 11,
    MAX_STATE = 12
} ;
#line 197 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
typedef enum __anonenum___STATE_12 __STATE;
#line 213
enum __anonenum___ACTION_13 {
    NOOP = 0,
    NUMBER = 1,
    SKIPNUM = 2,
    GETMOD = 3,
    GETARG = 4,
    GETPW = 5,
    GETPWB = 6,
    GETPOS = 7,
    PWPOS = 8
} ;
#line 213 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
typedef enum __anonenum___ACTION_13 __ACTION;
#line 451 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
typedef long long *quad_ptr_t;
#line 452 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
typedef void *void_ptr_t;
#line 453 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
typedef char *char_ptr_t;
#line 454 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
typedef long *long_ptr_t;
#line 455 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
typedef int *int_ptr_t;
#line 456 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
typedef short *short_ptr_t;
#line 465 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
union arg_val {
   int val_int ;
   u_int val_u_int ;
   long val_long ;
   u_long val_u_long ;
   float val_float ;
   double val_double ;
   long double val__LONG_DOUBLE ;
   int_ptr_t val_int_ptr_t ;
   short_ptr_t val_short_ptr_t ;
   long_ptr_t val_long_ptr_t ;
   char_ptr_t val_char_ptr_t ;
   quad_ptr_t val_quad_ptr_t ;
   void_ptr_t val_void_ptr_t ;
   long long val_quad_t ;
   unsigned long long val_u_quad_t ;
   wint_t val_wint_t ;
};
#line 258 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef unsigned long uintptr_t;
#line 251 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfscanf.c"
typedef unsigned long long u_long_long;
#line 578 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
union __anonunion__double__21 {
   int i ;
   double fp ;
};
#line 593
enum __anonenum_base_22 {
    OCT___1 = 0,
    DEC___1 = 1,
    HEX___1 = 2
} ;
#line 578 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
union __anonunion__double__21___1 {
   int i ;
   double fp ;
};
#line 593
enum __anonenum_base_22___1 {
    OCT___5 = 0,
    DEC___5 = 1,
    HEX___5 = 2
} ;
#line 233 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdint.h"
typedef unsigned long long uintmax_t;
#line 125 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
struct __otter_fs_sock_data;
#line 129
struct __otter_fs_pipe_data;
#line 41 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_pipe_data {
   int rhead ;
   int whead ;
   char *data ;
};
#line 51 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_sock_data {
   struct sockaddr *addr ;
   int state ;
   int options ;
   struct __otter_fs_pipe_data *recv_data ;
   struct __otter_fs_sock_data **sock_queue ;
   int backlog ;
};
#line 114 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/types.h"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
#line 102 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 59 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netinet/in.h"
union __anonunion_in6_u_7 {
   unsigned char u6_addr8[16] ;
   unsigned short u6_addr16[8] ;
   unsigned int u6_addr32[4] ;
};
#line 59 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_7 in6_u ;
};
#line 78 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   int sin6_flowinfo ;
   struct in6_addr sin6_addr ;
};
#line 498 "syscalls/sys/socket/__otter_socket.c"
struct __otter_fd_sock_data;
#line 44 "hiredis.c"
struct redisReader {
   struct redisReplyObjectFunctions *fn ;
   sds error ;
   void *reply ;
   sds buf ;
   size_t pos ;
   size_t len ;
   redisReadTask rstack[3] ;
   int ridx ;
   void *privdata ;
};
#line 44 "hiredis.c"
typedef struct redisReader redisReader;
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "cil-Vpyg8vHf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-desKLMr5.i","")
#line 1 "adlist.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-nZ5LGpB4.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 81 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern void free(void *ptr )  __attribute__((__weak__, __deprecated__)) ;
#line 92
extern void *malloc(size_t __size )  __attribute__((__weak__, __deprecated__)) ;
#line 73 "adlist.h"
list *listCreate(void) ;
#line 74
void listRelease(list *list___0 ) ;
#line 75
list *listAddNodeHead(list *list___0 , void *value ) ;
#line 76
list *listAddNodeTail(list *list___0 , void *value ) ;
#line 77
list *listInsertNode(list *list___0 , listNode *old_node , void *value , int after ) ;
#line 78
void listDelNode(list *list___0 , listNode *node ) ;
#line 79
listIter *listGetIterator(list *list___0 , int direction ) ;
#line 80
listNode *listNext(listIter *iter ) ;
#line 81
void listReleaseIterator(listIter *iter ) ;
#line 82
list *listDup(list *orig ) ;
#line 83
listNode *listSearchKey(list *list___0 , void *key ) ;
#line 84
listNode *listIndex(list *list___0 , int index___0 ) ;
#line 85
void listRewind(list *list___0 , listIter *li ) ;
#line 41 "adlist.c"
list *listCreate(void) 
{ struct list *list___0 ;
  void *__cil_tmp ;
  listNode *__cil_tmp___0 ;

  {
#line 45
  __cil_tmp = malloc((unsigned int )sizeof(*list___0));
#line 45
  list___0 = (struct list *)__cil_tmp;
#line 45
  if ((unsigned int )list___0 == (unsigned int )((void *)0)) {
#line 46
    return ((list *)((void *)0));
  }
#line 47
  __cil_tmp___0 = (listNode *)((void *)0);
#line 47
  list___0->tail = __cil_tmp___0;
#line 47
  list___0->head = __cil_tmp___0;
#line 48
  list___0->len = 0U;
#line 49
  list___0->dup = (void *(*)(void *ptr ))((void *)0);
#line 50
  list___0->free = (void (*)(void *ptr ))((void *)0);
#line 51
  list___0->match = (int (*)(void *ptr , void *key ))((void *)0);
#line 52
  return (list___0);
}
}
#line 58 "adlist.c"
void listRelease(list *list___0 ) 
{ unsigned int len ;
  listNode *current ;
  listNode *next ;
  unsigned int __cil_tmp ;

  {
#line 63
  current = list___0->head;
#line 64
  len = list___0->len;
#line 65
  while (1) {
#line 65
    __cil_tmp = len;
#line 65
    len --;
#line 65
    if (! __cil_tmp) {
#line 65
      break;
    }
#line 66
    next = current->next;
#line 67
    if (list___0->free) {
#line 67
      (*(list___0->free))(current->value);
    }
#line 68
    free((void *)current);
#line 69
    current = next;
  }
#line 71
  free((void *)list___0);
#line 72
  return;
}
}
#line 80 "adlist.c"
list *listAddNodeHead(list *list___0 , void *value ) 
{ listNode *node ;
  void *__cil_tmp ;
  listNode *__cil_tmp___0 ;
  struct listNode *__cil_tmp___1 ;

  {
#line 84
  __cil_tmp = malloc((unsigned int )sizeof(*node));
#line 84
  node = (listNode *)__cil_tmp;
#line 84
  if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 85
    return ((list *)((void *)0));
  }
#line 86
  node->value = value;
#line 87
  if (list___0->len == 0U) {
#line 88
    __cil_tmp___0 = node;
#line 88
    list___0->tail = __cil_tmp___0;
#line 88
    list___0->head = __cil_tmp___0;
#line 89
    __cil_tmp___1 = (struct listNode *)((void *)0);
#line 89
    node->next = __cil_tmp___1;
#line 89
    node->prev = __cil_tmp___1;
  } else {
#line 91
    node->prev = (struct listNode *)((void *)0);
#line 92
    node->next = list___0->head;
#line 93
    (list___0->head)->prev = node;
#line 94
    list___0->head = node;
  }
#line 96
  (list___0->len) ++;
#line 97
  return (list___0);
}
}
#line 106 "adlist.c"
list *listAddNodeTail(list *list___0 , void *value ) 
{ listNode *node ;
  void *__cil_tmp ;
  listNode *__cil_tmp___0 ;
  struct listNode *__cil_tmp___1 ;

  {
#line 110
  __cil_tmp = malloc((unsigned int )sizeof(*node));
#line 110
  node = (listNode *)__cil_tmp;
#line 110
  if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 111
    return ((list *)((void *)0));
  }
#line 112
  node->value = value;
#line 113
  if (list___0->len == 0U) {
#line 114
    __cil_tmp___0 = node;
#line 114
    list___0->tail = __cil_tmp___0;
#line 114
    list___0->head = __cil_tmp___0;
#line 115
    __cil_tmp___1 = (struct listNode *)((void *)0);
#line 115
    node->next = __cil_tmp___1;
#line 115
    node->prev = __cil_tmp___1;
  } else {
#line 117
    node->prev = list___0->tail;
#line 118
    node->next = (struct listNode *)((void *)0);
#line 119
    (list___0->tail)->next = node;
#line 120
    list___0->tail = node;
  }
#line 122
  (list___0->len) ++;
#line 123
  return (list___0);
}
}
#line 126 "adlist.c"
list *listInsertNode(list *list___0 , listNode *old_node , void *value , int after ) 
{ listNode *node ;
  void *__cil_tmp ;

  {
#line 129
  __cil_tmp = malloc((unsigned int )sizeof(*node));
#line 129
  node = (listNode *)__cil_tmp;
#line 129
  if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 130
    return ((list *)((void *)0));
  }
#line 131
  node->value = value;
#line 132
  if (after) {
#line 133
    node->prev = old_node;
#line 134
    node->next = old_node->next;
#line 135
    if ((unsigned int )list___0->tail == (unsigned int )old_node) {
#line 136
      list___0->tail = node;
    }
  } else {
#line 139
    node->next = old_node;
#line 140
    node->prev = old_node->prev;
#line 141
    if ((unsigned int )list___0->head == (unsigned int )old_node) {
#line 142
      list___0->head = node;
    }
  }
#line 145
  if ((unsigned int )node->prev != (unsigned int )((void *)0)) {
#line 146
    (node->prev)->next = node;
  }
#line 148
  if ((unsigned int )node->next != (unsigned int )((void *)0)) {
#line 149
    (node->next)->prev = node;
  }
#line 151
  (list___0->len) ++;
#line 152
  return (list___0);
}
}
#line 159 "adlist.c"
void listDelNode(list *list___0 , listNode *node ) 
{ 

  {
#line 161
  if (node->prev) {
#line 162
    (node->prev)->next = node->next;
  } else {
#line 164
    list___0->head = node->next;
  }
#line 165
  if (node->next) {
#line 166
    (node->next)->prev = node->prev;
  } else {
#line 168
    list___0->tail = node->prev;
  }
#line 169
  if (list___0->free) {
#line 169
    (*(list___0->free))(node->value);
  }
#line 170
  free((void *)node);
#line 171
  (list___0->len) --;
#line 172
  return;
}
}
#line 178 "adlist.c"
listIter *listGetIterator(list *list___0 , int direction ) 
{ listIter *iter ;
  void *__cil_tmp ;

  {
#line 182
  __cil_tmp = malloc((unsigned int )sizeof(*iter));
#line 182
  iter = (listIter *)__cil_tmp;
#line 182
  if ((unsigned int )iter == (unsigned int )((void *)0)) {
#line 182
    return ((listIter *)((void *)0));
  }
#line 183
  if (direction == 0) {
#line 184
    iter->next = list___0->head;
  } else {
#line 186
    iter->next = list___0->tail;
  }
#line 187
  iter->direction = direction;
#line 188
  return (iter);
}
}
#line 192 "adlist.c"
void listReleaseIterator(listIter *iter ) 
{ 

  {
#line 193
  free((void *)iter);
#line 194
  return;
}
}
#line 197 "adlist.c"
void listRewind(list *list___0 , listIter *li ) 
{ 

  {
#line 198
  li->next = list___0->head;
#line 199
  li->direction = 0;
#line 200
  return;
}
}
#line 221 "adlist.c"
listNode *listNext(listIter *iter ) 
{ listNode *current ;

  {
#line 223
  current = iter->next;
#line 225
  if ((unsigned int )current != (unsigned int )((void *)0)) {
#line 226
    if (iter->direction == 0) {
#line 227
      iter->next = current->next;
    } else {
#line 229
      iter->next = current->prev;
    }
  }
#line 231
  return (current);
}
}
#line 242 "adlist.c"
list *listDup(list *orig ) 
{ list *copy ;
  listIter *iter ;
  listNode *node ;
  void *value ;
  list *__cil_tmp ;

  {
#line 248
  copy = listCreate();
#line 248
  if ((unsigned int )copy == (unsigned int )((void *)0)) {
#line 249
    return ((list *)((void *)0));
  }
#line 250
  copy->dup = orig->dup;
#line 251
  copy->free = orig->free;
#line 252
  copy->match = orig->match;
#line 253
  iter = listGetIterator(orig, 0);
#line 254
  while (1) {
#line 254
    node = listNext(iter);
#line 254
    if (! ((unsigned int )node != (unsigned int )((void *)0))) {
#line 254
      break;
    }
#line 257
    if (copy->dup) {
#line 258
      value = (*(copy->dup))(node->value);
#line 259
      if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 260
        listRelease(copy);
#line 261
        listReleaseIterator(iter);
#line 262
        return ((list *)((void *)0));
      }
    } else {
#line 265
      value = node->value;
    }
#line 266
    __cil_tmp = listAddNodeTail(copy, value);
#line 266
    if ((unsigned int )__cil_tmp == (unsigned int )((void *)0)) {
#line 267
      listRelease(copy);
#line 268
      listReleaseIterator(iter);
#line 269
      return ((list *)((void *)0));
    }
  }
#line 272
  listReleaseIterator(iter);
#line 273
  return (copy);
}
}
#line 285 "adlist.c"
listNode *listSearchKey(list *list___0 , void *key ) 
{ listIter *iter ;
  listNode *node ;
  int __cil_tmp ;

  {
#line 290
  iter = listGetIterator(list___0, 0);
#line 291
  while (1) {
#line 291
    node = listNext(iter);
#line 291
    if (! ((unsigned int )node != (unsigned int )((void *)0))) {
#line 291
      break;
    }
#line 292
    if (list___0->match) {
#line 293
      __cil_tmp = (*(list___0->match))(node->value, key);
#line 293
      if (__cil_tmp) {
#line 294
        listReleaseIterator(iter);
#line 295
        return (node);
      }
    } else
#line 298
    if ((unsigned int )key == (unsigned int )node->value) {
#line 299
      listReleaseIterator(iter);
#line 300
      return (node);
    }
  }
#line 304
  listReleaseIterator(iter);
#line 305
  return ((listNode *)((void *)0));
}
}
#line 313 "adlist.c"
listNode *listIndex(list *list___0 , int index___0 ) 
{ listNode *n ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 316
  if (index___0 < 0) {
#line 317
    index___0 = - index___0 - 1;
#line 318
    n = list___0->tail;
#line 319
    while (1) {
#line 319
      __cil_tmp = index___0;
#line 319
      index___0 --;
#line 319
      if (! (__cil_tmp && n)) {
#line 319
        break;
      }
#line 319
      n = n->prev;
    }
  } else {
#line 321
    n = list___0->head;
#line 322
    while (1) {
#line 322
      __cil_tmp___0 = index___0;
#line 322
      index___0 --;
#line 322
      if (! (__cil_tmp___0 && n)) {
#line 322
        break;
      }
#line 322
      n = n->next;
    }
  }
#line 324
  return (n);
}
}
#line 1 "ae.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-9IkBRJbW.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 74 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/time.h"
int gettimeofday(struct timeval *tv , void *tzp ) ;
#line 101 "ae.h"
aeEventLoop *aeCreateEventLoop(void) ;
#line 102
void aeDeleteEventLoop(aeEventLoop *eventLoop ) ;
#line 104
int aeCreateFileEvent(aeEventLoop *eventLoop , int fd , int mask , aeFileProc *proc ,
                      void *clientData ) ;
#line 106
void aeDeleteFileEvent(aeEventLoop *eventLoop , int fd , int mask ) ;
#line 107
long long aeCreateTimeEvent(aeEventLoop *eventLoop , long long milliseconds , aeTimeProc *proc ,
                            void *clientData , aeEventFinalizerProc *finalizerProc ) ;
#line 110
int aeDeleteTimeEvent(aeEventLoop *eventLoop , long long id ) ;
#line 111
int aeProcessEvents(aeEventLoop *eventLoop , int flags ) ;
#line 112
int aeWait(int fd , int mask , long long milliseconds ) ;
#line 113
void aeMain(aeEventLoop *eventLoop ) ;
#line 114
char *aeGetApiName(void) ;
#line 115
void aeSetBeforeSleepProc(aeEventLoop *eventLoop , aeBeforeSleepProc *beforesleep ) ;
#line 24 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
void *memcpy(void *dst0 , void const   *src0 , size_t len0 ) ;
#line 7 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/select.h"
int select(int nfds , _types_fd_set *readfds , _types_fd_set *writefds , _types_fd_set *errorfds ,
           struct timeval * __restrict  timeout ) ;
#line 15 "ae_select.c"
static int aeApiCreate(aeEventLoop *eventLoop ) 
{ aeApiState *state ;
  void *__cil_tmp ;
  size_t __i ;
  char *__tmp ;
  char *__cil_tmp___0 ;
  size_t __i___0 ;
  char *__tmp___0 ;
  char *__cil_tmp___1 ;

  {
#line 16
  __cil_tmp = malloc((unsigned int )sizeof(aeApiState ));
#line 16
  state = (aeApiState *)__cil_tmp;
#line 18
  if (! state) {
#line 18
    return (-1);
  }
#line 19
  __tmp = (char *)(& state->rfds);
#line 19
  __i = 0U;
#line 19
  while ((unsigned long )__i < sizeof(state->rfds)) {
#line 19
    __cil_tmp___0 = __tmp;
#line 19
    __tmp ++;
#line 19
    *__cil_tmp___0 = (char)0;
#line 19
    __i ++;
  }
#line 20
  __tmp___0 = (char *)(& state->wfds);
#line 20
  __i___0 = 0U;
#line 20
  while ((unsigned long )__i___0 < sizeof(state->wfds)) {
#line 20
    __cil_tmp___1 = __tmp___0;
#line 20
    __tmp___0 ++;
#line 20
    *__cil_tmp___1 = (char)0;
#line 20
    __i___0 ++;
  }
#line 21
  eventLoop->apidata = (void *)state;
#line 22
  return (0);
}
}
#line 25 "ae_select.c"
static void aeApiFree(aeEventLoop *eventLoop ) 
{ 

  {
#line 26
  free(eventLoop->apidata);
#line 27
  return;
}
}
#line 29 "ae_select.c"
static int aeApiAddEvent(aeEventLoop *eventLoop , int fd , int mask ) 
{ aeApiState *state ;

  {
#line 30
  state = (aeApiState *)eventLoop->apidata;
#line 32
  if (mask & 1) {
#line 32
    state->rfds.fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] |= 1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL);
  }
#line 33
  if (mask & 2) {
#line 33
    state->wfds.fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] |= 1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL);
  }
#line 34
  return (0);
}
}
#line 37 "ae_select.c"
static void aeApiDelEvent(aeEventLoop *eventLoop , int fd , int mask ) 
{ aeApiState *state ;

  {
#line 38
  state = (aeApiState *)eventLoop->apidata;
#line 40
  if (mask & 1) {
#line 40
    state->rfds.fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] &= ~ (1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL));
  }
#line 41
  if (mask & 2) {
#line 41
    state->wfds.fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] &= ~ (1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL));
  }
#line 42
  return;
}
}
#line 44 "ae_select.c"
static int aeApiPoll(aeEventLoop *eventLoop , struct timeval *tvp ) 
{ aeApiState *state ;
  int retval ;
  int j ;
  int numevents ;
  int mask ;
  aeFileEvent *fe ;

  {
#line 45
  state = (aeApiState *)eventLoop->apidata;
#line 46
  numevents = 0;
#line 48
  memcpy((void *)(& state->_rfds), (void const   *)(& state->rfds), (unsigned int )sizeof(_types_fd_set ));
#line 49
  memcpy((void *)(& state->_wfds), (void const   *)(& state->wfds), (unsigned int )sizeof(_types_fd_set ));
#line 51
  retval = select(eventLoop->maxfd + 1, & state->_rfds, & state->_wfds, (_types_fd_set *)((void *)0),
                  tvp);
#line 53
  if (retval > 0) {
#line 54
    j = 0;
#line 54
    while (j <= eventLoop->maxfd) {
#line 55
      mask = 0;
#line 56
      fe = & eventLoop->events[j];
#line 58
      if (fe->mask == 0) {
#line 58
        goto __Cont;
      }
#line 59
      if (fe->mask & 1 && state->_rfds.fds_bits[(unsigned long )j / (sizeof(fd_mask ) * 8UL)] & (1L << (unsigned long )j % (sizeof(fd_mask ) * 8UL))) {
#line 60
        mask |= 1;
      }
#line 61
      if (fe->mask & 2 && state->_wfds.fds_bits[(unsigned long )j / (sizeof(fd_mask ) * 8UL)] & (1L << (unsigned long )j % (sizeof(fd_mask ) * 8UL))) {
#line 62
        mask |= 2;
      }
#line 63
      eventLoop->fired[numevents].fd = j;
#line 64
      eventLoop->fired[numevents].mask = mask;
#line 65
      numevents ++;
      __Cont: 
#line 54
      j ++;
    }
  }
#line 68
  return (numevents);
}
}
#line 71 "ae_select.c"
static char *aeApiName(void) 
{ 

  {
#line 72
  return ((char *)"select");
}
}
#line 55 "ae.c"
aeEventLoop *aeCreateEventLoop(void) 
{ aeEventLoop *eventLoop ;
  int i ;
  void *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 59
  __cil_tmp = malloc((unsigned int )sizeof(*eventLoop));
#line 59
  eventLoop = (aeEventLoop *)__cil_tmp;
#line 60
  if (! eventLoop) {
#line 60
    return ((aeEventLoop *)((void *)0));
  }
#line 61
  eventLoop->timeEventHead = (aeTimeEvent *)((void *)0);
#line 62
  eventLoop->timeEventNextId = 0LL;
#line 63
  eventLoop->stop = 0;
#line 64
  eventLoop->maxfd = -1;
#line 65
  eventLoop->beforesleep = (aeBeforeSleepProc *)((void *)0);
#line 66
  __cil_tmp___0 = aeApiCreate(eventLoop);
#line 66
  if (__cil_tmp___0 == -1) {
#line 67
    free((void *)eventLoop);
#line 68
    return ((aeEventLoop *)((void *)0));
  }
#line 72
  i = 0;
#line 72
  while (i < 16) {
#line 73
    eventLoop->events[i].mask = 0;
#line 72
    i ++;
  }
#line 74
  return (eventLoop);
}
}
#line 77 "ae.c"
void aeDeleteEventLoop(aeEventLoop *eventLoop ) 
{ 

  {
#line 78
  aeApiFree(eventLoop);
#line 79
  free((void *)eventLoop);
#line 80
  return;
}
}
#line 86 "ae.c"
int aeCreateFileEvent(aeEventLoop *eventLoop , int fd , int mask , aeFileProc *proc ,
                      void *clientData ) 
{ aeFileEvent *fe ;
  int __cil_tmp ;

  {
#line 89
  if (fd >= 16) {
#line 89
    return (-1);
  }
#line 90
  fe = & eventLoop->events[fd];
#line 92
  __cil_tmp = aeApiAddEvent(eventLoop, fd, mask);
#line 92
  if (__cil_tmp == -1) {
#line 93
    return (-1);
  }
#line 94
  fe->mask |= mask;
#line 95
  if (mask & 1) {
#line 95
    fe->rfileProc = proc;
  }
#line 96
  if (mask & 2) {
#line 96
    fe->wfileProc = proc;
  }
#line 97
  fe->clientData = clientData;
#line 98
  if (fd > eventLoop->maxfd) {
#line 99
    eventLoop->maxfd = fd;
  }
#line 100
  return (0);
}
}
#line 103 "ae.c"
void aeDeleteFileEvent(aeEventLoop *eventLoop , int fd , int mask ) 
{ aeFileEvent *fe ;
  int j ;

  {
#line 105
  if (fd >= 16) {
#line 105
    return;
  }
#line 106
  fe = & eventLoop->events[fd];
#line 108
  if (fe->mask == 0) {
#line 108
    return;
  }
#line 109
  fe->mask &= ~ mask;
#line 110
  if (fd == eventLoop->maxfd && fe->mask == 0) {
#line 114
    j = eventLoop->maxfd - 1;
#line 114
    while (j >= 0) {
#line 115
      if (eventLoop->events[j].mask != 0) {
#line 115
        break;
      }
#line 114
      j --;
    }
#line 116
    eventLoop->maxfd = j;
  }
#line 118
  aeApiDelEvent(eventLoop, fd, mask);
#line 119
  return;
}
}
#line 121 "ae.c"
static void aeGetTime(long *seconds , long *milliseconds ) 
{ struct timeval tv ;

  {
#line 125
  gettimeofday(& tv, (void *)0);
#line 126
  *seconds = tv.tv_sec;
#line 127
  *milliseconds = tv.tv_usec / 1000L;
#line 128
  return;
}
}
#line 130 "ae.c"
static void aeAddMillisecondsToNow(long long milliseconds , long *sec , long *ms ) 
{ long cur_sec ;
  long cur_ms ;
  long when_sec ;
  long when_ms ;

  {
#line 133
  aeGetTime(& cur_sec, & cur_ms);
#line 134
  when_sec = (long )((long long )cur_sec + milliseconds / 1000LL);
#line 135
  when_ms = (long )((long long )cur_ms + milliseconds % 1000LL);
#line 136
  if (when_ms >= 1000L) {
#line 137
    when_sec ++;
#line 138
    when_ms -= 1000L;
  }
#line 140
  *sec = when_sec;
#line 141
  *ms = when_ms;
#line 142
  return;
}
}
#line 144 "ae.c"
long long aeCreateTimeEvent(aeEventLoop *eventLoop , long long milliseconds , aeTimeProc *proc ,
                            void *clientData , aeEventFinalizerProc *finalizerProc ) 
{ long long id ;
  long long __cil_tmp ;
  aeTimeEvent *te ;
  void *__cil_tmp___0 ;

  {
#line 148
  __cil_tmp = eventLoop->timeEventNextId;
#line 148
  (eventLoop->timeEventNextId) ++;
#line 148
  id = __cil_tmp;
#line 151
  __cil_tmp___0 = malloc((unsigned int )sizeof(*te));
#line 151
  te = (aeTimeEvent *)__cil_tmp___0;
#line 152
  if ((unsigned int )te == (unsigned int )((void *)0)) {
#line 152
    return (-1LL);
  }
#line 153
  te->id = id;
#line 154
  aeAddMillisecondsToNow(milliseconds, & te->when_sec, & te->when_ms);
#line 155
  te->timeProc = proc;
#line 156
  te->finalizerProc = finalizerProc;
#line 157
  te->clientData = clientData;
#line 158
  te->next = eventLoop->timeEventHead;
#line 159
  eventLoop->timeEventHead = te;
#line 160
  return (id);
}
}
#line 163 "ae.c"
int aeDeleteTimeEvent(aeEventLoop *eventLoop , long long id ) 
{ aeTimeEvent *te ;
  aeTimeEvent *prev ;

  {
#line 165
  prev = (aeTimeEvent *)((void *)0);
#line 167
  te = eventLoop->timeEventHead;
#line 168
  while (te) {
#line 169
    if (te->id == id) {
#line 170
      if ((unsigned int )prev == (unsigned int )((void *)0)) {
#line 171
        eventLoop->timeEventHead = te->next;
      } else {
#line 173
        prev->next = te->next;
      }
#line 174
      if (te->finalizerProc) {
#line 175
        (*(te->finalizerProc))(eventLoop, te->clientData);
      }
#line 176
      free((void *)te);
#line 177
      return (0);
    }
#line 179
    prev = te;
#line 180
    te = te->next;
  }
#line 182
  return (-1);
}
}
#line 196 "ae.c"
static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop ) 
{ aeTimeEvent *te ;
  aeTimeEvent *nearest ;

  {
#line 198
  te = eventLoop->timeEventHead;
#line 199
  nearest = (aeTimeEvent *)((void *)0);
#line 201
  while (te) {
#line 202
    if ((! nearest || te->when_sec < nearest->when_sec) || (te->when_sec == nearest->when_sec && te->when_ms < nearest->when_ms)) {
#line 205
      nearest = te;
    }
#line 206
    te = te->next;
  }
#line 208
  return (nearest);
}
}
#line 212 "ae.c"
static int processTimeEvents(aeEventLoop *eventLoop ) 
{ int processed ;
  aeTimeEvent *te ;
  long long maxId ;
  long now_sec ;
  long now_ms ;
  long long id ;
  int retval ;

  {
#line 213
  processed = 0;
#line 217
  te = eventLoop->timeEventHead;
#line 218
  maxId = eventLoop->timeEventNextId - 1LL;
#line 219
  while (te) {
#line 223
    if (te->id > maxId) {
#line 224
      te = te->next;
#line 225
      continue;
    }
#line 227
    aeGetTime(& now_sec, & now_ms);
#line 228
    if (now_sec > te->when_sec || (now_sec == te->when_sec && now_ms >= te->when_ms)) {
#line 233
      id = te->id;
#line 234
      retval = (*(te->timeProc))(eventLoop, id, te->clientData);
#line 235
      processed ++;
#line 249
      if (retval != -1) {
#line 250
        aeAddMillisecondsToNow((long long )retval, & te->when_sec, & te->when_ms);
      } else {
#line 252
        aeDeleteTimeEvent(eventLoop, id);
      }
#line 254
      te = eventLoop->timeEventHead;
    } else {
#line 256
      te = te->next;
    }
  }
#line 259
  return (processed);
}
}
#line 275 "ae.c"
int aeProcessEvents(aeEventLoop *eventLoop , int flags ) 
{ int processed ;
  int numevents ;
  int j ;
  aeTimeEvent *shortest ;
  struct timeval tv ;
  struct timeval *tvp ;
  long now_sec ;
  long now_ms ;
  aeFileEvent *fe ;
  int mask ;
  int fd ;
  int rfired ;
  int __cil_tmp ;

  {
#line 277
  processed = 0;
#line 280
  if (! (flags & 2) && ! (flags & 1)) {
#line 280
    return (0);
  }
#line 286
  if (eventLoop->maxfd != -1 || (flags & 2 && ! (flags & 4))) {
#line 289
    shortest = (aeTimeEvent *)((void *)0);
#line 292
    if (flags & 2 && ! (flags & 4)) {
#line 293
      shortest = aeSearchNearestTimer(eventLoop);
    }
#line 294
    if (shortest) {
#line 299
      aeGetTime(& now_sec, & now_ms);
#line 300
      tvp = & tv;
#line 301
      tvp->tv_sec = shortest->when_sec - now_sec;
#line 302
      if (shortest->when_ms < now_ms) {
#line 303
        tvp->tv_usec = ((shortest->when_ms + 1000L) - now_ms) * 1000L;
#line 304
        (tvp->tv_sec) --;
      } else {
#line 306
        tvp->tv_usec = (shortest->when_ms - now_ms) * 1000L;
      }
#line 308
      if (tvp->tv_sec < 0L) {
#line 308
        tvp->tv_sec = 0L;
      }
#line 309
      if (tvp->tv_usec < 0L) {
#line 309
        tvp->tv_usec = 0L;
      }
    } else
#line 314
    if (flags & 4) {
#line 315
      tv.tv_usec = 0L;
#line 315
      tv.tv_sec = tv.tv_usec;
#line 316
      tvp = & tv;
    } else {
#line 319
      tvp = (struct timeval *)((void *)0);
    }
#line 323
    numevents = aeApiPoll(eventLoop, tvp);
#line 324
    j = 0;
#line 324
    while (j < numevents) {
#line 325
      fe = & eventLoop->events[eventLoop->fired[j].fd];
#line 326
      mask = eventLoop->fired[j].mask;
#line 327
      fd = eventLoop->fired[j].fd;
#line 328
      rfired = 0;
#line 333
      if ((fe->mask & mask) & 1) {
#line 334
        rfired = 1;
#line 335
        (*(fe->rfileProc))(eventLoop, fd, fe->clientData, mask);
      }
#line 337
      if ((fe->mask & mask) & 2) {
#line 338
        if (! rfired || (unsigned int )fe->wfileProc != (unsigned int )fe->rfileProc) {
#line 339
          (*(fe->wfileProc))(eventLoop, fd, fe->clientData, mask);
        }
      }
#line 341
      processed ++;
#line 324
      j ++;
    }
  }
#line 345
  if (flags & 2) {
#line 346
    __cil_tmp = processTimeEvents(eventLoop);
#line 346
    processed += __cil_tmp;
  }
#line 348
  return (processed);
}
}
#line 353 "ae.c"
int aeWait(int fd , int mask , long long milliseconds ) 
{ struct timeval tv ;
  _types_fd_set rfds ;
  _types_fd_set wfds ;
  _types_fd_set efds ;
  int retmask ;
  int retval ;
  size_t __i ;
  char *__tmp ;
  char *__cil_tmp ;
  size_t __i___0 ;
  char *__tmp___0 ;
  char *__cil_tmp___0 ;
  size_t __i___1 ;
  char *__tmp___1 ;
  char *__cil_tmp___1 ;

  {
#line 356
  retmask = 0;
#line 358
  tv.tv_sec = (long )(milliseconds / 1000LL);
#line 359
  tv.tv_usec = (long )((milliseconds % 1000LL) * 1000LL);
#line 360
  __tmp = (char *)(& rfds);
#line 360
  __i = 0U;
#line 360
  while ((unsigned long )__i < sizeof(rfds)) {
#line 360
    __cil_tmp = __tmp;
#line 360
    __tmp ++;
#line 360
    *__cil_tmp = (char)0;
#line 360
    __i ++;
  }
#line 361
  __tmp___0 = (char *)(& wfds);
#line 361
  __i___0 = 0U;
#line 361
  while ((unsigned long )__i___0 < sizeof(wfds)) {
#line 361
    __cil_tmp___0 = __tmp___0;
#line 361
    __tmp___0 ++;
#line 361
    *__cil_tmp___0 = (char)0;
#line 361
    __i___0 ++;
  }
#line 362
  __tmp___1 = (char *)(& efds);
#line 362
  __i___1 = 0U;
#line 362
  while ((unsigned long )__i___1 < sizeof(efds)) {
#line 362
    __cil_tmp___1 = __tmp___1;
#line 362
    __tmp___1 ++;
#line 362
    *__cil_tmp___1 = (char)0;
#line 362
    __i___1 ++;
  }
#line 364
  if (mask & 1) {
#line 364
    rfds.fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] |= 1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL);
  }
#line 365
  if (mask & 2) {
#line 365
    wfds.fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] |= 1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL);
  }
#line 366
  retval = select(fd + 1, & rfds, & wfds, & efds, & tv);
#line 366
  if (retval > 0) {
#line 367
    if (rfds.fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] & (1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL))) {
#line 367
      retmask |= 1;
    }
#line 368
    if (wfds.fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] & (1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL))) {
#line 368
      retmask |= 2;
    }
#line 369
    return (retmask);
  } else {
#line 371
    return (retval);
  }
}
}
#line 375 "ae.c"
void aeMain(aeEventLoop *eventLoop ) 
{ 

  {
#line 376
  eventLoop->stop = 0;
#line 377
  while (! eventLoop->stop) {
#line 378
    if ((unsigned int )eventLoop->beforesleep != (unsigned int )((void *)0)) {
#line 379
      (*(eventLoop->beforesleep))(eventLoop);
    }
#line 380
    aeProcessEvents(eventLoop, 3);
  }
#line 382
  return;
}
}
#line 384 "ae.c"
char *aeGetApiName(void) 
{ char *__cil_tmp ;

  {
#line 385
  __cil_tmp = aeApiName();
#line 385
  return (__cil_tmp);
}
}
#line 388 "ae.c"
void aeSetBeforeSleepProc(aeEventLoop *eventLoop , aeBeforeSleepProc *beforesleep ) 
{ 

  {
#line 389
  eventLoop->beforesleep = beforesleep;
#line 390
  return;
}
}
#line 1 "anet.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lOjr4Q4m.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 91 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dnode *__otter_fs_root  ;
#line 92 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dnode *__otter_fs_pwd  ;
#line 114 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
int *__otter_fs_fd_table  ;
#line 115 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_open_file_table_entry *__otter_fs_open_file_table  ;
#line 140 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
int __otter_fs_umask  ;
#line 108 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
int socket(int domain , int type , int protocol ) ;
#line 109
int bind(int socket_fd , struct sockaddr  const  *address , socklen_t address_len ) ;
#line 110
int listen(int socket_fd , int backlog ) ;
#line 111
int accept(int socket_fd , struct sockaddr *address , socklen_t *address_len ) ;
#line 112
int connect(int socket_fd , struct sockaddr  const  *address , socklen_t address_len ) ;
#line 118
int setsockopt(int socket_fd , int level , int option_name , void const   *option_value ,
               socklen_t option_len ) ;
#line 124 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
unsigned short __otter_sock_free_port  ;
#line 17 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/arpa/inet.h"
char *inet_ntoa(struct in_addr in ) ;
#line 18
int inet_aton(char const   *cp , struct in_addr *addrptr ) ;
#line 29 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
int close(int fildes ) ;
#line 138
int read(int fd , void *buf , size_t num ) ;
#line 183
int write(int fd , void const   *buf , size_t num ) ;
#line 48 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/fcntl.h"
int fcntl(int fd , int cmd  , ...) ;
#line 26 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
void *memset(void *m , int c , size_t n ) ;
#line 31
char *strcpy(char *dst0 , char const   *src0 ) ;
#line 33
char *strerror(int errnum ) ;
#line 37
char *strncpy(char *dst0 , char const   *src0 , size_t count ) ;
#line 53 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/netdb.h"
extern struct hostent *gethostbyname(char const   *name ) ;
#line 15 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/errno.h"
int *__errno(void) ;
#line 300 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int vsnprintf(char *str , size_t size , char const   *fmt , va_list ap ) ;
#line 42 "anet.h"
int anetTcpConnect(char *err , char *addr , int port ) ;
#line 48
int anetTcpServer(char *err , int port , char *bindaddr ) ;
#line 49
int anetUnixServer(char *err , char *path ) ;
#line 50
int anetTcpAccept(char *err , int s , char *ip , int *port ) ;
#line 51
int anetUnixAccept(char *err , int s ) ;
#line 53
int anetNonBlock(char *err , int fd ) ;
#line 54
int anetTcpNoDelay(char *err , int fd ) ;
#line 49 "anet.c"
static void anetSetError(char *err , char const   *fmt  , ...) 
{ va_list ap ;

  {
#line 53
  if (! err) {
#line 53
    return;
  }
#line 54
  __builtin_va_start(ap, fmt);
#line 55
  vsnprintf(err, 256U, fmt, ap);
#line 56
  __builtin_va_end(ap);
#line 57
  return;
}
}
#line 59 "anet.c"
int anetNonBlock(char *err , int fd ) 
{ int flags ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 66
  flags = fcntl(fd, 4);
#line 66
  if (flags == -1) {
#line 67
    __cil_tmp = __errno();
#line 67
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 67
    anetSetError(err, "fcntl(F_GETFL): %s", __cil_tmp___0);
#line 68
    return (-1);
  }
#line 70
  __cil_tmp___3 = fcntl(fd, 5, flags | 128);
#line 70
  if (__cil_tmp___3 == -1) {
#line 71
    __cil_tmp___1 = __errno();
#line 71
    __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 71
    anetSetError(err, "fcntl(F_SETFL,O_NONBLOCK): %s", __cil_tmp___2);
#line 72
    return (-1);
  }
#line 74
  return (0);
}
}
#line 77 "anet.c"
int anetTcpNoDelay(char *err , int fd ) 
{ int yes ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 79
  yes = 1;
#line 80
  __cil_tmp___1 = setsockopt(fd, 3, 1, (void const   *)(& yes), (unsigned int )sizeof(yes));
#line 80
  if (__cil_tmp___1 == -1) {
#line 82
    __cil_tmp = __errno();
#line 82
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 82
    anetSetError(err, "setsockopt TCP_NODELAY: %s", __cil_tmp___0);
#line 83
    return (-1);
  }
#line 85
  return (0);
}
}
#line 127 "anet.c"
static int anetCreateSocket(char *err , int domain ) 
{ int s ;
  int on ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 128
  on = 1;
#line 129
  s = socket(domain, 2, 0);
#line 129
  if (s == -1) {
#line 130
    __cil_tmp = __errno();
#line 130
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 130
    anetSetError(err, "creating socket: %s", __cil_tmp___0);
#line 131
    return (-1);
  }
#line 136
  __cil_tmp___3 = setsockopt(s, -1, 2048, (void const   *)(& on), (unsigned int )sizeof(on));
#line 136
  if (__cil_tmp___3 == -1) {
#line 137
    __cil_tmp___1 = __errno();
#line 137
    __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 137
    anetSetError(err, "setsockopt SO_REUSEADDR: %s", __cil_tmp___2);
#line 138
    return (-1);
  }
#line 140
  return (s);
}
}
#line 145 "anet.c"
static int anetTcpGenericConnect(char *err , char *addr , int port , int flags ) 
{ int s ;
  struct sockaddr_in sa ;
  struct hostent *he ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 150
  s = anetCreateSocket(err, 2);
#line 150
  if (s == -1) {
#line 151
    return (-1);
  }
#line 153
  sa.sin_family = (unsigned short)2;
#line 154
  sa.sin_port = (unsigned short )(((port & 65280) >> 8) | ((port & 255) << 8));
#line 155
  __cil_tmp = inet_aton((char const   *)addr, & sa.sin_addr);
#line 155
  if (__cil_tmp == 0) {
#line 158
    he = gethostbyname((char const   *)addr);
#line 159
    if ((unsigned int )he == (unsigned int )((void *)0)) {
#line 160
      anetSetError(err, "can\'t resolve: %s", addr);
#line 161
      close(s);
#line 162
      return (-1);
    }
#line 164
    memcpy((void *)(& sa.sin_addr), (void const   *)*(he->h_addr_list + 0), (unsigned int )sizeof(struct in_addr ));
  }
#line 166
  if (flags & 1) {
#line 167
    __cil_tmp___0 = anetNonBlock(err, s);
#line 167
    if (__cil_tmp___0 != 0) {
#line 168
      return (-1);
    }
  }
#line 170
  __cil_tmp___4 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& sa)),
                          (unsigned int )sizeof(sa));
#line 170
  if (__cil_tmp___4 == -1) {
#line 171
    __cil_tmp___1 = __errno();
#line 171
    if (*__cil_tmp___1 == 119 && flags & 1) {
#line 173
      return (s);
    }
#line 175
    __cil_tmp___2 = __errno();
#line 175
    __cil_tmp___3 = strerror(*__cil_tmp___2);
#line 175
    anetSetError(err, "connect: %s", __cil_tmp___3);
#line 176
    close(s);
#line 177
    return (-1);
  }
#line 179
  return (s);
}
}
#line 182 "anet.c"
int anetTcpConnect(char *err , char *addr , int port ) 
{ int __cil_tmp ;

  {
#line 184
  __cil_tmp = anetTcpGenericConnect(err, addr, port, 0);
#line 184
  return (__cil_tmp);
}
}
#line 271 "anet.c"
int *redis_has_called_listen  ;
#line 258 "anet.c"
static int anetListen(char *err , int s , struct sockaddr *sa , socklen_t len ) 
{ int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 259
  __cil_tmp___1 = bind(s, (struct sockaddr  const  *)sa, len);
#line 259
  if (__cil_tmp___1 == -1) {
#line 260
    __cil_tmp = __errno();
#line 260
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 260
    anetSetError(err, "bind: %s", __cil_tmp___0);
#line 261
    close(s);
#line 262
    return (-1);
  }
#line 264
  __cil_tmp___4 = listen(s, 511);
#line 264
  if (__cil_tmp___4 == -1) {
#line 265
    __cil_tmp___2 = __errno();
#line 265
    __cil_tmp___3 = strerror(*__cil_tmp___2);
#line 265
    anetSetError(err, "listen: %s", __cil_tmp___3);
#line 266
    close(s);
#line 267
    return (-1);
  }
#line 272
  *redis_has_called_listen = 1;
#line 274
  return (0);
}
}
#line 277 "anet.c"
int anetTcpServer(char *err , int port , char *bindaddr ) 
{ int s ;
  struct sockaddr_in sa ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 282
  s = anetCreateSocket(err, 2);
#line 282
  if (s == -1) {
#line 283
    return (-1);
  }
#line 285
  memset((void *)(& sa), 0, (unsigned int )sizeof(sa));
#line 286
  sa.sin_family = (unsigned short)2;
#line 287
  sa.sin_port = (unsigned short )(((port & 65280) >> 8) | ((port & 255) << 8));
#line 288
  sa.sin_addr.s_addr = 0U;
#line 289
  if (bindaddr) {
#line 289
    __cil_tmp = inet_aton((char const   *)bindaddr, & sa.sin_addr);
#line 289
    if (__cil_tmp == 0) {
#line 290
      anetSetError(err, "invalid bind address");
#line 291
      close(s);
#line 292
      return (-1);
    }
  }
#line 294
  __cil_tmp___0 = anetListen(err, s, (struct sockaddr *)(& sa), (unsigned int )sizeof(sa));
#line 294
  if (__cil_tmp___0 == -1) {
#line 295
    return (-1);
  }
#line 296
  return (s);
}
}
#line 299 "anet.c"
int anetUnixServer(char *err , char *path ) 
{ int s ;
  struct sockaddr_un sa ;
  int __cil_tmp ;

  {
#line 304
  s = anetCreateSocket(err, 1);
#line 304
  if (s == -1) {
#line 305
    return (-1);
  }
#line 307
  memset((void *)(& sa), 0, (unsigned int )sizeof(sa));
#line 308
  sa.sun_family = (unsigned short)1;
#line 309
  strncpy(sa.sun_path, (char const   *)path, (unsigned int )(sizeof(sa.sun_path) - 1UL));
#line 310
  __cil_tmp = anetListen(err, s, (struct sockaddr *)(& sa), (unsigned int )sizeof(sa));
#line 310
  if (__cil_tmp == -1) {
#line 311
    return (-1);
  }
#line 312
  return (s);
}
}
#line 315 "anet.c"
static int anetGenericAccept(char *err , int s , struct sockaddr *sa , socklen_t *len ) 
{ int fd ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 317
  while (1) {
#line 318
    fd = accept(s, sa, len);
#line 319
    if (fd == -1) {
#line 320
      __cil_tmp___1 = __errno();
#line 320
      if (*__cil_tmp___1 == 4) {
#line 321
        continue;
      } else {
#line 323
        __cil_tmp = __errno();
#line 323
        __cil_tmp___0 = strerror(*__cil_tmp);
#line 323
        anetSetError(err, "accept: %s", __cil_tmp___0);
#line 324
        return (-1);
      }
    }
#line 327
    break;
  }
#line 329
  return (fd);
}
}
#line 332 "anet.c"
int anetTcpAccept(char *err , int s , char *ip , int *port ) 
{ int fd ;
  struct sockaddr_in sa ;
  socklen_t salen ;
  char *__cil_tmp ;

  {
#line 335
  salen = (unsigned int )sizeof(sa);
#line 336
  fd = anetGenericAccept(err, s, (struct sockaddr *)(& sa), & salen);
#line 336
  if (fd == -1) {
#line 337
    return (-1);
  }
#line 339
  if (ip) {
#line 339
    __cil_tmp = inet_ntoa(sa.sin_addr);
#line 339
    strcpy(ip, (char const   *)__cil_tmp);
  }
#line 340
  if (port) {
#line 340
    *port = (((int )sa.sin_port & 65280) >> 8) | (((int )sa.sin_port & 255) << 8);
  }
#line 341
  return (fd);
}
}
#line 344 "anet.c"
int anetUnixAccept(char *err , int s ) 
{ int fd ;
  struct sockaddr_un sa ;
  socklen_t salen ;

  {
#line 347
  salen = (unsigned int )sizeof(sa);
#line 348
  fd = anetGenericAccept(err, s, (struct sockaddr *)(& sa), & salen);
#line 348
  if (fd == -1) {
#line 349
    return (-1);
  }
#line 351
  return (fd);
}
}
#line 1 "dict.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wMNT2Anm.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 182 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int ( /* format attribute */  printf)(char const   *fmt  , ...) ;
#line 78 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
void *calloc(size_t count , size_t size )  __attribute__((__deprecated__)) ;
#line 43 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/ctype.h"
char const   *__ctype_ptr__ ;
#line 124 "dict.h"
dict *dictCreate(dictType *type , void *privDataPtr ) ;
#line 125
int dictExpand(dict *d , unsigned long size ) ;
#line 126
int dictAdd(dict *d , void *key , void *val ) ;
#line 127
int dictReplace(dict *d , void *key , void *val ) ;
#line 128
int dictDelete(dict *ht , void const   *key ) ;
#line 130
void dictRelease(dict *d ) ;
#line 131
dictEntry *dictFind(dict *d , void const   *key ) ;
#line 132
void *dictFetchValue(dict *d , void const   *key ) ;
#line 133
int dictResize(dict *d ) ;
#line 134
dictIterator *dictGetIterator(dict *d ) ;
#line 135
dictEntry *dictNext(dictIterator *iter ) ;
#line 136
void dictReleaseIterator(dictIterator *iter ) ;
#line 137
dictEntry *dictGetRandomKey(dict *d ) ;
#line 139
unsigned int dictGenHashFunction(unsigned char const   *buf , int len ) ;
#line 140
unsigned int dictGenCaseHashFunction(unsigned char const   *buf , int len ) ;
#line 141
void dictEmpty(dict *d ) ;
#line 142
void dictEnableResize(void) ;
#line 143
void dictDisableResize(void) ;
#line 144
int dictRehash(dict *d , int n ) ;
#line 145
int dictRehashMilliseconds(dict *d , int ms ) ;
#line 58 "dict.c"
static int dict_can_resize  =    1;
#line 59 "dict.c"
static unsigned int dict_force_resize_ratio  =    5U;
#line 63
static int _dictExpandIfNeeded(dict *d ) ;
#line 64
static unsigned long _dictNextPower(unsigned long size ) ;
#line 65
static int _dictKeyIndex(dict *d , void const   *key ) ;
#line 66
static int _dictInit(dict *d , dictType *type , void *privDataPtr ) ;
#line 90 "dict.c"
unsigned int dictGenHashFunction(unsigned char const   *buf , int len ) 
{ unsigned int hash ;
  unsigned char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 91
  hash = 5381U;
#line 93
  while (1) {
#line 93
    __cil_tmp___0 = len;
#line 93
    len --;
#line 93
    if (! __cil_tmp___0) {
#line 93
      break;
    }
#line 94
    __cil_tmp = buf;
#line 94
    buf ++;
#line 94
    hash = ((hash << 5) + hash) + (unsigned int )*__cil_tmp;
  }
#line 95
  return (hash);
}
}
#line 99 "dict.c"
unsigned int dictGenCaseHashFunction(unsigned char const   *buf , int len ) 
{ unsigned int hash ;
  unsigned char __x ;
  unsigned char const   *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 100
  hash = 5381U;
#line 102
  while (1) {
#line 102
    __cil_tmp___1 = len;
#line 102
    len --;
#line 102
    if (! __cil_tmp___1) {
#line 102
      break;
    }
#line 103
    __cil_tmp___0 = buf;
#line 103
    buf ++;
#line 103
    __x = (unsigned char )*__cil_tmp___0;
#line 103
    hash = ((hash << 5) + hash) + (unsigned int )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 1 ? ((int )__x - 65) + 97 : (int )__x);
  }
#line 104
  return (hash);
}
}
#line 111 "dict.c"
static void _dictReset(dictht *ht ) 
{ 

  {
#line 113
  ht->table = (dictEntry **)((void *)0);
#line 114
  ht->size = 0UL;
#line 115
  ht->sizemask = 0UL;
#line 116
  ht->used = 0UL;
#line 117
  return;
}
}
#line 120 "dict.c"
dict *dictCreate(dictType *type , void *privDataPtr ) 
{ dict *d ;
  void *__cil_tmp ;

  {
#line 123
  __cil_tmp = malloc((unsigned int )sizeof(*d));
#line 123
  d = (dict *)__cil_tmp;
#line 125
  _dictInit(d, type, privDataPtr);
#line 126
  return (d);
}
}
#line 130 "dict.c"
static int _dictInit(dict *d , dictType *type , void *privDataPtr ) 
{ 

  {
#line 133
  _dictReset(& d->ht[0]);
#line 134
  _dictReset(& d->ht[1]);
#line 135
  d->type = type;
#line 136
  d->privdata = privDataPtr;
#line 137
  d->rehashidx = -1;
#line 138
  d->iterators = 0;
#line 139
  return (0);
}
}
#line 144 "dict.c"
int dictResize(dict *d ) 
{ int minimal ;
  int __cil_tmp ;

  {
#line 148
  if (! dict_can_resize || d->rehashidx != -1) {
#line 148
    return (1);
  }
#line 149
  minimal = (int )d->ht[0].used;
#line 150
  if (minimal < 4) {
#line 151
    minimal = 4;
  }
#line 152
  __cil_tmp = dictExpand(d, (unsigned long )minimal);
#line 152
  return (__cil_tmp);
}
}
#line 156 "dict.c"
int dictExpand(dict *d , unsigned long size ) 
{ dictht n ;
  unsigned long realsize ;
  unsigned long __cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 159
  __cil_tmp = _dictNextPower(size);
#line 159
  realsize = __cil_tmp;
#line 163
  if (d->rehashidx != -1 || d->ht[0].used > size) {
#line 164
    return (1);
  }
#line 167
  n.size = realsize;
#line 168
  n.sizemask = realsize - 1UL;
#line 169
  __cil_tmp___0 = calloc(1U, (unsigned int )(realsize * sizeof(dictEntry *)));
#line 169
  n.table = (dictEntry **)__cil_tmp___0;
#line 170
  n.used = 0UL;
#line 174
  if ((unsigned int )d->ht[0].table == (unsigned int )((void *)0)) {
#line 175
    d->ht[0] = n;
#line 176
    return (0);
  }
#line 180
  d->ht[1] = n;
#line 181
  d->rehashidx = 0;
#line 182
  return (0);
}
}
#line 189 "dict.c"
int dictRehash(dict *d , int n ) 
{ dictEntry *de ;
  dictEntry *nextde ;
  unsigned int h ;
  unsigned int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 190
  if (! (d->rehashidx != -1)) {
#line 190
    return (0);
  }
#line 192
  while (1) {
#line 192
    __cil_tmp___0 = n;
#line 192
    n --;
#line 192
    if (! __cil_tmp___0) {
#line 192
      break;
    }
#line 196
    if (d->ht[0].used == 0UL) {
#line 197
      free((void *)d->ht[0].table);
#line 198
      d->ht[0] = d->ht[1];
#line 199
      _dictReset(& d->ht[1]);
#line 200
      d->rehashidx = -1;
#line 201
      return (0);
    }
#line 206
    while ((unsigned int )*(d->ht[0].table + d->rehashidx) == (unsigned int )((void *)0)) {
#line 206
      (d->rehashidx) ++;
    }
#line 207
    de = *(d->ht[0].table + d->rehashidx);
#line 209
    while (de) {
#line 212
      nextde = de->next;
#line 214
      __cil_tmp = (*((d->type)->hashFunction))((void const   *)de->key);
#line 214
      h = (unsigned int )((unsigned long )__cil_tmp & d->ht[1].sizemask);
#line 215
      de->next = *(d->ht[1].table + h);
#line 216
      *(d->ht[1].table + h) = de;
#line 217
      (d->ht[0].used) --;
#line 218
      (d->ht[1].used) ++;
#line 219
      de = nextde;
    }
#line 221
    *(d->ht[0].table + d->rehashidx) = (dictEntry *)((void *)0);
#line 222
    (d->rehashidx) ++;
  }
#line 224
  return (1);
}
}
#line 227 "dict.c"
long long timeInMilliseconds(void) 
{ struct timeval tv ;

  {
#line 230
  gettimeofday(& tv, (void *)0);
#line 231
  return ((long long )tv.tv_sec * 1000LL + (long long )(tv.tv_usec / 1000L));
}
}
#line 235 "dict.c"
int dictRehashMilliseconds(dict *d , int ms ) 
{ long long start ;
  long long __cil_tmp ;
  int rehashes ;
  long long __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 236
  __cil_tmp = timeInMilliseconds();
#line 236
  start = __cil_tmp;
#line 237
  rehashes = 0;
#line 239
  while (1) {
#line 239
    __cil_tmp___1 = dictRehash(d, 100);
#line 239
    if (! __cil_tmp___1) {
#line 239
      break;
    }
#line 240
    rehashes += 100;
#line 241
    __cil_tmp___0 = timeInMilliseconds();
#line 241
    if (__cil_tmp___0 - start > (long long )ms) {
#line 241
      break;
    }
  }
#line 243
  return (rehashes);
}
}
#line 254 "dict.c"
static void _dictRehashStep(dict *d ) 
{ 

  {
#line 255
  if (d->iterators == 0) {
#line 255
    dictRehash(d, 1);
  }
#line 256
  return;
}
}
#line 259 "dict.c"
int dictAdd(dict *d , void *key , void *val ) 
{ int index___0 ;
  dictEntry *entry ;
  dictht *ht ;
  void *__cil_tmp ;

  {
#line 265
  if (d->rehashidx != -1) {
#line 265
    _dictRehashStep(d);
  }
#line 269
  index___0 = _dictKeyIndex(d, (void const   *)key);
#line 269
  if (index___0 == -1) {
#line 270
    return (1);
  }
#line 273
  ht = d->rehashidx != -1 ? & d->ht[1] : & d->ht[0];
#line 274
  __cil_tmp = malloc((unsigned int )sizeof(*entry));
#line 274
  entry = (dictEntry *)__cil_tmp;
#line 275
  entry->next = *(ht->table + index___0);
#line 276
  *(ht->table + index___0) = entry;
#line 277
  (ht->used) ++;
#line 280
  while (1) {
#line 280
    if ((d->type)->keyDup) {
#line 280
      entry->key = (*((d->type)->keyDup))(d->privdata, (void const   *)key);
    } else {
#line 280
      entry->key = key;
    }
#line 280
    break;
  }
#line 281
  while (1) {
#line 281
    if ((d->type)->valDup) {
#line 281
      entry->val = (*((d->type)->valDup))(d->privdata, (void const   *)val);
    } else {
#line 281
      entry->val = val;
    }
#line 281
    break;
  }
#line 282
  return (0);
}
}
#line 289 "dict.c"
int dictReplace(dict *d , void *key , void *val ) 
{ dictEntry *entry ;
  dictEntry auxentry ;
  int __cil_tmp ;

  {
#line 295
  __cil_tmp = dictAdd(d, key, val);
#line 295
  if (__cil_tmp == 0) {
#line 296
    return (1);
  }
#line 298
  entry = dictFind(d, (void const   *)key);
#line 305
  auxentry = *entry;
#line 306
  while (1) {
#line 306
    if ((d->type)->valDup) {
#line 306
      entry->val = (*((d->type)->valDup))(d->privdata, (void const   *)val);
    } else {
#line 306
      entry->val = val;
    }
#line 306
    break;
  }
#line 307
  if ((d->type)->valDestructor) {
#line 307
    (*((d->type)->valDestructor))(d->privdata, auxentry.val);
  }
#line 308
  return (0);
}
}
#line 312 "dict.c"
static int dictGenericDelete(dict *d , void const   *key , int nofree ) 
{ unsigned int h ;
  unsigned int idx ;
  dictEntry *he ;
  dictEntry *prevHe ;
  int table ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 318
  if (d->ht[0].size == 0UL) {
#line 318
    return (1);
  }
#line 319
  if (d->rehashidx != -1) {
#line 319
    _dictRehashStep(d);
  }
#line 320
  h = (*((d->type)->hashFunction))(key);
#line 322
  table = 0;
#line 322
  while (table <= 1) {
#line 323
    idx = (unsigned int )((unsigned long )h & d->ht[table].sizemask);
#line 324
    he = *(d->ht[table].table + idx);
#line 325
    prevHe = (dictEntry *)((void *)0);
#line 326
    while (he) {
#line 327
      if ((d->type)->keyCompare) {
#line 327
        __cil_tmp = (*((d->type)->keyCompare))(d->privdata, key, (void const   *)he->key);
#line 327
        __cil_tmp___0 = __cil_tmp;
      } else {
#line 327
        __cil_tmp___0 = (unsigned int )key == (unsigned int )he->key;
      }
#line 327
      if (__cil_tmp___0) {
#line 329
        if (prevHe) {
#line 330
          prevHe->next = he->next;
        } else {
#line 332
          *(d->ht[table].table + idx) = he->next;
        }
#line 333
        if (! nofree) {
#line 334
          if ((d->type)->keyDestructor) {
#line 334
            (*((d->type)->keyDestructor))(d->privdata, he->key);
          }
#line 335
          if ((d->type)->valDestructor) {
#line 335
            (*((d->type)->valDestructor))(d->privdata, he->val);
          }
        }
#line 337
        free((void *)he);
#line 338
        (d->ht[table].used) --;
#line 339
        return (0);
      }
#line 341
      prevHe = he;
#line 342
      he = he->next;
    }
#line 344
    if (! (d->rehashidx != -1)) {
#line 344
      break;
    }
#line 322
    table ++;
  }
#line 346
  return (1);
}
}
#line 349 "dict.c"
int dictDelete(dict *ht , void const   *key ) 
{ int __cil_tmp ;

  {
#line 350
  __cil_tmp = dictGenericDelete(ht, key, 0);
#line 350
  return (__cil_tmp);
}
}
#line 358 "dict.c"
int _dictClear(dict *d , dictht *ht ) 
{ unsigned long i ;
  dictEntry *he ;
  dictEntry *nextHe ;

  {
#line 363
  i = 0UL;
#line 363
  while (i < ht->size && ht->used > 0UL) {
#line 366
    he = *(ht->table + i);
#line 366
    if ((unsigned int )he == (unsigned int )((void *)0)) {
#line 366
      goto __Cont;
    }
#line 367
    while (he) {
#line 368
      nextHe = he->next;
#line 369
      if ((d->type)->keyDestructor) {
#line 369
        (*((d->type)->keyDestructor))(d->privdata, he->key);
      }
#line 370
      if ((d->type)->valDestructor) {
#line 370
        (*((d->type)->valDestructor))(d->privdata, he->val);
      }
#line 371
      free((void *)he);
#line 372
      (ht->used) --;
#line 373
      he = nextHe;
    }
    __Cont: 
#line 363
    i ++;
  }
#line 377
  free((void *)ht->table);
#line 379
  _dictReset(ht);
#line 380
  return (0);
}
}
#line 384 "dict.c"
void dictRelease(dict *d ) 
{ 

  {
#line 386
  _dictClear(d, & d->ht[0]);
#line 387
  _dictClear(d, & d->ht[1]);
#line 388
  free((void *)d);
#line 389
  return;
}
}
#line 391 "dict.c"
dictEntry *dictFind(dict *d , void const   *key ) 
{ dictEntry *he ;
  unsigned int h ;
  unsigned int idx ;
  unsigned int table ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 396
  if (d->ht[0].size == 0UL) {
#line 396
    return ((dictEntry *)((void *)0));
  }
#line 397
  if (d->rehashidx != -1) {
#line 397
    _dictRehashStep(d);
  }
#line 398
  h = (*((d->type)->hashFunction))(key);
#line 399
  table = 0U;
#line 399
  while (table <= 1U) {
#line 400
    idx = (unsigned int )((unsigned long )h & d->ht[table].sizemask);
#line 401
    he = *(d->ht[table].table + idx);
#line 402
    while (he) {
#line 403
      if ((d->type)->keyCompare) {
#line 403
        __cil_tmp = (*((d->type)->keyCompare))(d->privdata, key, (void const   *)he->key);
#line 403
        __cil_tmp___0 = __cil_tmp;
      } else {
#line 403
        __cil_tmp___0 = (unsigned int )key == (unsigned int )he->key;
      }
#line 403
      if (__cil_tmp___0) {
#line 404
        return (he);
      }
#line 405
      he = he->next;
    }
#line 407
    if (! (d->rehashidx != -1)) {
#line 407
      return ((dictEntry *)((void *)0));
    }
#line 399
    table ++;
  }
#line 409
  return ((dictEntry *)((void *)0));
}
}
#line 412 "dict.c"
void *dictFetchValue(dict *d , void const   *key ) 
{ dictEntry *he ;

  {
#line 415
  he = dictFind(d, key);
#line 416
  return (he ? he->val : (void *)0);
}
}
#line 419 "dict.c"
dictIterator *dictGetIterator(dict *d ) 
{ dictIterator *iter ;
  void *__cil_tmp ;

  {
#line 421
  __cil_tmp = malloc((unsigned int )sizeof(*iter));
#line 421
  iter = (dictIterator *)__cil_tmp;
#line 423
  iter->d = d;
#line 424
  iter->table = 0;
#line 425
  iter->index = -1;
#line 426
  iter->entry = (dictEntry *)((void *)0);
#line 427
  iter->nextEntry = (dictEntry *)((void *)0);
#line 428
  return (iter);
}
}
#line 431 "dict.c"
dictEntry *dictNext(dictIterator *iter ) 
{ dictht *ht ;

  {
#line 433
  while (1) {
#line 434
    if ((unsigned int )iter->entry == (unsigned int )((void *)0)) {
#line 435
      ht = & (iter->d)->ht[iter->table];
#line 436
      if (iter->index == -1 && iter->table == 0) {
#line 436
        ((iter->d)->iterators) ++;
      }
#line 437
      (iter->index) ++;
#line 438
      if (iter->index >= (int )ht->size) {
#line 439
        if ((iter->d)->rehashidx != -1 && iter->table == 0) {
#line 440
          (iter->table) ++;
#line 441
          iter->index = 0;
#line 442
          ht = & (iter->d)->ht[1];
        } else {
#line 444
          break;
        }
      }
#line 447
      iter->entry = *(ht->table + iter->index);
    } else {
#line 449
      iter->entry = iter->nextEntry;
    }
#line 451
    if (iter->entry) {
#line 454
      iter->nextEntry = (iter->entry)->next;
#line 455
      return (iter->entry);
    }
  }
#line 458
  return ((dictEntry *)((void *)0));
}
}
#line 461 "dict.c"
void dictReleaseIterator(dictIterator *iter ) 
{ 

  {
#line 463
  if (! (iter->index == -1 && iter->table == 0)) {
#line 463
    ((iter->d)->iterators) --;
  }
#line 464
  free((void *)iter);
#line 465
  return;
}
}
#line 479
extern int random() ;
#line 469 "dict.c"
dictEntry *dictGetRandomKey(dict *d ) 
{ dictEntry *he ;
  dictEntry *orighe ;
  unsigned int h ;
  int listlen ;
  int listele ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 475
  if (d->ht[0].used + d->ht[1].used == 0UL) {
#line 475
    return ((dictEntry *)((void *)0));
  }
#line 476
  if (d->rehashidx != -1) {
#line 476
    _dictRehashStep(d);
  }
#line 477
  if (d->rehashidx != -1) {
#line 478
    while (1) {
#line 479
      __cil_tmp = random();
#line 479
      h = (unsigned int )((unsigned long )__cil_tmp % (d->ht[0].size + d->ht[1].size));
#line 480
      he = (unsigned long )h >= d->ht[0].size ? *(d->ht[1].table + ((unsigned long )h - d->ht[0].size)) : *(d->ht[0].table + h);
#line 478
      if (! ((unsigned int )he == (unsigned int )((void *)0))) {
#line 478
        break;
      }
    }
  } else {
#line 484
    while (1) {
#line 485
      __cil_tmp___0 = random();
#line 485
      h = (unsigned int )((unsigned long )__cil_tmp___0 & d->ht[0].sizemask);
#line 486
      he = *(d->ht[0].table + h);
#line 484
      if (! ((unsigned int )he == (unsigned int )((void *)0))) {
#line 484
        break;
      }
    }
  }
#line 494
  listlen = 0;
#line 495
  orighe = he;
#line 496
  while (he) {
#line 497
    he = he->next;
#line 498
    listlen ++;
  }
#line 500
  __cil_tmp___1 = random();
#line 500
  listele = __cil_tmp___1 % listlen;
#line 501
  he = orighe;
#line 502
  while (1) {
#line 502
    __cil_tmp___2 = listele;
#line 502
    listele --;
#line 502
    if (! __cil_tmp___2) {
#line 502
      break;
    }
#line 502
    he = he->next;
  }
#line 503
  return (he);
}
}
#line 509 "dict.c"
static int _dictExpandIfNeeded(dict *d ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 512
  if (d->rehashidx != -1) {
#line 512
    return (0);
  }
#line 515
  if (d->ht[0].size == 0UL) {
#line 515
    __cil_tmp = dictExpand(d, 4UL);
#line 515
    return (__cil_tmp);
  }
#line 521
  if (d->ht[0].used >= d->ht[0].size && (dict_can_resize || d->ht[0].used / d->ht[0].size > (unsigned long )dict_force_resize_ratio)) {
#line 525
    __cil_tmp___0 = dictExpand(d, (d->ht[0].size > d->ht[0].used ? d->ht[0].size : d->ht[0].used) * 2UL);
#line 525
    return (__cil_tmp___0);
  }
#line 528
  return (0);
}
}
#line 532 "dict.c"
static unsigned long _dictNextPower(unsigned long size ) 
{ unsigned long i ;

  {
#line 534
  i = 4UL;
#line 536
  if (size >= 2147483647UL) {
#line 536
    return (2147483647UL);
  }
#line 537
  while (1) {
#line 538
    if (i >= size) {
#line 539
      return (i);
    }
#line 540
    i *= 2UL;
  }
}
}
#line 550 "dict.c"
static int _dictKeyIndex(dict *d , void const   *key ) 
{ unsigned int h ;
  unsigned int idx ;
  unsigned int table ;
  dictEntry *he ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 556
  __cil_tmp = _dictExpandIfNeeded(d);
#line 556
  if (__cil_tmp == 1) {
#line 557
    return (-1);
  }
#line 559
  h = (*((d->type)->hashFunction))(key);
#line 560
  table = 0U;
#line 560
  while (table <= 1U) {
#line 561
    idx = (unsigned int )((unsigned long )h & d->ht[table].sizemask);
#line 563
    he = *(d->ht[table].table + idx);
#line 564
    while (he) {
#line 565
      if ((d->type)->keyCompare) {
#line 565
        __cil_tmp___0 = (*((d->type)->keyCompare))(d->privdata, key, (void const   *)he->key);
#line 565
        __cil_tmp___1 = __cil_tmp___0;
      } else {
#line 565
        __cil_tmp___1 = (unsigned int )key == (unsigned int )he->key;
      }
#line 565
      if (__cil_tmp___1) {
#line 566
        return (-1);
      }
#line 567
      he = he->next;
    }
#line 569
    if (! (d->rehashidx != -1)) {
#line 569
      break;
    }
#line 560
    table ++;
  }
#line 571
  return ((int )idx);
}
}
#line 574 "dict.c"
void dictEmpty(dict *d ) 
{ 

  {
#line 575
  _dictClear(d, & d->ht[0]);
#line 576
  _dictClear(d, & d->ht[1]);
#line 577
  d->rehashidx = -1;
#line 578
  d->iterators = 0;
#line 579
  return;
}
}
#line 634 "dict.c"
void dictEnableResize(void) 
{ 

  {
#line 635
  dict_can_resize = 1;
#line 636
  return;
}
}
#line 638 "dict.c"
void dictDisableResize(void) 
{ 

  {
#line 639
  dict_can_resize = 0;
#line 640
  return;
}
}
#line 1 "redis.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-3P7IEw2B.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 818 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _reent *_impure_ptr ;
#line 173 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int fclose(FILE *fp ) ;
#line 174
int fflush(FILE *fp ) ;
#line 178
int fprintf(FILE *fp , char const   *fmt  , ...) ;
#line 225
FILE *fopen(char const   *file , char const   *mode ) ;
#line 226
int sprintf(char *str , char const   *fmt  , ...) ;
#line 62 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
 __attribute__((__noreturn__)) void abort(void) ;
#line 69
int atoi(char const   *s ) ;
#line 80
 __attribute__((__noreturn__)) void exit(int code ) ;
#line 135
long strtol(char const   *s , char **ptr , int base ) ;
#line 23 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
int memcmp(void const   *m1 , void const   *m2 , size_t n ) ;
#line 29
int strcmp(char const   *s1___0 , char const   *s2___0 ) ;
#line 63
int strcasecmp(char const   *s1___0 , char const   *s2___0 ) ;
#line 65
char *strdup(char const   *str ) ;
#line 49 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/time.h"
time_t time(time_t *t ) ;
#line 17 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 39
int dup2(int fd1 , int fd2 ) ;
#line 67
int fork(void) ;
#line 69
int fsync(int fildes ) ;
#line 95
int getpid(void) ;
#line 164
pid_t setsid(void) ;
#line 171
unsigned int sleep(unsigned int seconds ) ;
#line 180
int unlink(char const   *path ) ;
#line 229 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/pthread.h"
pthread_t pthread_self(void) ;
#line 185 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/syslog.h"
void openlog(char const   *ident , int logstat , int logfac ) ;
#line 194
void syslog(int pri , char const   *fmt  , ...) ;
#line 46 "sds.h"
sds sdsnew(char const   *init ) ;
#line 47
sds sdsempty(void) ;
#line 48
size_t sdslen(sds s ) ;
#line 50
void sdsfree(sds s ) ;
#line 53
sds sdscatlen(sds s , void *t , size_t len ) ;
#line 54
sds sdscat(sds s , char *t ) ;
#line 60
sds sdscatprintf(sds s , char const   *fmt  , ...) ;
#line 41 "zmalloc.h"
size_t zmalloc_used_memory(void) ;
#line 43
float zmalloc_get_fragmentation_ratio(void) ;
#line 44
size_t zmalloc_get_rss(void) ;
#line 45
size_t zmalloc_allocations_for_size(size_t size ) ;
#line 216 "redis.h"
void _redisAssert(char *estr , char *file , int line ) ;
#line 623 "redis.h"
struct redisServer server  ;
#line 624 "redis.h"
struct sharedObjectsStruct shared  ;
#line 625
dictType setDictType ;
#line 626
dictType zsetDictType ;
#line 627 "redis.h"
double R_Zero  ;
#line 627 "redis.h"
double R_PosInf  ;
#line 627 "redis.h"
double R_NegInf  ;
#line 627 "redis.h"
double R_Nan  ;
#line 628
dictType hashDictType ;
#line 636
void closeTimedoutClients(void) ;
#line 638
void resetClient(redisClient *c ) ;
#line 640
void addReply(redisClient *c , robj *obj ) ;
#line 643
void addReplySds(redisClient *c , sds s ) ;
#line 644
void processInputBuffer(redisClient *c ) ;
#line 645
void acceptTcpHandler(aeEventLoop *el , int fd , void *privdata , int mask ) ;
#line 646
void acceptUnixHandler(aeEventLoop *el , int fd , void *privdata , int mask ) ;
#line 647
void readQueryFromClient(aeEventLoop *el , int fd , void *privdata , int mask ) ;
#line 648
void addReplyBulk(redisClient *c , robj *obj ) ;
#line 655
void addReplyError(redisClient *c , char *err ) ;
#line 661
void getClientsMaxBuffers(unsigned long *longest_output_list , unsigned long *biggest_input_buffer ) ;
#line 665
void addReplyErrorFormat(redisClient *c , char const   *fmt  , ...) ;
#line 695
void queueMultiCommand(redisClient *c , struct redisCommand *cmd ) ;
#line 700
void decrRefCount(void *obj ) ;
#line 707
robj *createObject(int type , void *ptr ) ;
#line 708
robj *createStringObject(char *ptr , size_t len ) ;
#line 711
robj *getDecodedObject(robj *o ) ;
#line 728
unsigned long estimateObjectIdleTime(robj *o ) ;
#line 740
void replicationFeedSlaves(list *slaves , int dictid , robj **argv , int argc ) ;
#line 741
void replicationFeedMonitors(list *monitors , int dictid , robj **argv , int argc ) ;
#line 744
void replicationCron(void) ;
#line 752
int rdbLoad(char *filename ) ;
#line 753
int rdbSaveBackground(char *filename ) ;
#line 754
void rdbRemoveTempFile(pid_t childpid ) ;
#line 755
int rdbSave(char *filename ) ;
#line 760
void backgroundSaveDoneHandler(int statloc ) ;
#line 763
void flushAppendOnlyFile(void) ;
#line 764
void feedAppendOnlyFile(struct redisCommand *cmd , int dictid , robj **argv , int argc ) ;
#line 767
int loadAppendOnlyFile(char *filename ) ;
#line 770
void backgroundRewriteDoneHandler(int statloc ) ;
#line 778
void freeMemoryIfNeeded(void) ;
#line 779
int processCommand(redisClient *c ) ;
#line 780
void setupSigSegvAction(void) ;
#line 781
struct redisCommand *lookupCommand(sds name ) ;
#line 782
struct redisCommand *lookupCommandByCString(char *s ) ;
#line 783
void call(redisClient *c , struct redisCommand *cmd ) ;
#line 784
int prepareForShutdown(void) ;
#line 785
void redisLog(int level , char const   *fmt  , ...) ;
#line 786
void usage(void) ;
#line 787
void updateDictResizePolicy(void) ;
#line 788
int htNeedsResize(dict *dict___0 ) ;
#line 789
void oom(char const   *msg ) ;
#line 790
void populateCommandTable(void) ;
#line 793
void vmInit(void) ;
#line 797
int vmSwapOneObjectBlocking(void) ;
#line 798
int vmSwapOneObjectThreaded(void) ;
#line 799
int vmCanSwapOut(void) ;
#line 802
void lockThreadedIO(void) ;
#line 803
void unlockThreadedIO(void) ;
#line 812
void zunionInterBlockClientOnSwappedKeys(redisClient *c , struct redisCommand *cmd ,
                                         int argc , robj **argv ) ;
#line 813
void execBlockClientOnSwappedKeys(redisClient *c , struct redisCommand *cmd , int argc ,
                                  robj **argv ) ;
#line 814
int blockClientOnSwappedKeys(redisClient *c , struct redisCommand *cmd ) ;
#line 852
void freePubsubPattern(void *p ) ;
#line 853
int listMatchPubsubPattern(void *a , void *b ) ;
#line 860
int ll2string(char *s , size_t len , long long value ) ;
#line 866
void loadServerConfig(char *filename ) ;
#line 867
void appendServerSaveParams(time_t seconds , int changes ) ;
#line 868
void resetServerSaveParams(void) ;
#line 872
void propagateExpire(redisDb *db , robj *key ) ;
#line 885
int dbDelete(redisDb *db , robj *key ) ;
#line 890
char *redisGitSHA1(void) ;
#line 891
char *redisGitDirty(void) ;
#line 894
void authCommand(redisClient *c ) ;
#line 895
void pingCommand(redisClient *c ) ;
#line 896
void echoCommand(redisClient *c ) ;
#line 897
void setCommand(redisClient *c ) ;
#line 898
void setnxCommand(redisClient *c ) ;
#line 899
void setexCommand(redisClient *c ) ;
#line 900
void getCommand(redisClient *c ) ;
#line 901
void delCommand(redisClient *c ) ;
#line 902
void existsCommand(redisClient *c ) ;
#line 903
void setbitCommand(redisClient *c ) ;
#line 904
void getbitCommand(redisClient *c ) ;
#line 905
void setrangeCommand(redisClient *c ) ;
#line 906
void getrangeCommand(redisClient *c ) ;
#line 907
void incrCommand(redisClient *c ) ;
#line 908
void decrCommand(redisClient *c ) ;
#line 909
void incrbyCommand(redisClient *c ) ;
#line 910
void decrbyCommand(redisClient *c ) ;
#line 911
void selectCommand(redisClient *c ) ;
#line 912
void randomkeyCommand(redisClient *c ) ;
#line 913
void keysCommand(redisClient *c ) ;
#line 914
void dbsizeCommand(redisClient *c ) ;
#line 915
void lastsaveCommand(redisClient *c ) ;
#line 916
void saveCommand(redisClient *c ) ;
#line 917
void bgsaveCommand(redisClient *c ) ;
#line 918
void bgrewriteaofCommand(redisClient *c ) ;
#line 919
void shutdownCommand(redisClient *c ) ;
#line 920
void moveCommand(redisClient *c ) ;
#line 921
void renameCommand(redisClient *c ) ;
#line 922
void renamenxCommand(redisClient *c ) ;
#line 923
void lpushCommand(redisClient *c ) ;
#line 924
void rpushCommand(redisClient *c ) ;
#line 925
void lpushxCommand(redisClient *c ) ;
#line 926
void rpushxCommand(redisClient *c ) ;
#line 927
void linsertCommand(redisClient *c ) ;
#line 928
void lpopCommand(redisClient *c ) ;
#line 929
void rpopCommand(redisClient *c ) ;
#line 930
void llenCommand(redisClient *c ) ;
#line 931
void lindexCommand(redisClient *c ) ;
#line 932
void lrangeCommand(redisClient *c ) ;
#line 933
void ltrimCommand(redisClient *c ) ;
#line 934
void typeCommand(redisClient *c ) ;
#line 935
void lsetCommand(redisClient *c ) ;
#line 936
void saddCommand(redisClient *c ) ;
#line 937
void sremCommand(redisClient *c ) ;
#line 938
void smoveCommand(redisClient *c ) ;
#line 939
void sismemberCommand(redisClient *c ) ;
#line 940
void scardCommand(redisClient *c ) ;
#line 941
void spopCommand(redisClient *c ) ;
#line 942
void srandmemberCommand(redisClient *c ) ;
#line 943
void sinterCommand(redisClient *c ) ;
#line 944
void sinterstoreCommand(redisClient *c ) ;
#line 945
void sunionCommand(redisClient *c ) ;
#line 946
void sunionstoreCommand(redisClient *c ) ;
#line 947
void sdiffCommand(redisClient *c ) ;
#line 948
void sdiffstoreCommand(redisClient *c ) ;
#line 949
void syncCommand(redisClient *c ) ;
#line 950
void flushdbCommand(redisClient *c ) ;
#line 951
void flushallCommand(redisClient *c ) ;
#line 952
void sortCommand(redisClient *c ) ;
#line 953
void lremCommand(redisClient *c ) ;
#line 954
void rpoplpushCommand(redisClient *c ) ;
#line 955
void infoCommand(redisClient *c ) ;
#line 956
void mgetCommand(redisClient *c ) ;
#line 957
void monitorCommand(redisClient *c ) ;
#line 958
void expireCommand(redisClient *c ) ;
#line 959
void expireatCommand(redisClient *c ) ;
#line 960
void getsetCommand(redisClient *c ) ;
#line 961
void ttlCommand(redisClient *c ) ;
#line 962
void persistCommand(redisClient *c ) ;
#line 963
void slaveofCommand(redisClient *c ) ;
#line 964
void debugCommand(redisClient *c ) ;
#line 965
void msetCommand(redisClient *c ) ;
#line 966
void msetnxCommand(redisClient *c ) ;
#line 967
void zaddCommand(redisClient *c ) ;
#line 968
void zincrbyCommand(redisClient *c ) ;
#line 969
void zrangeCommand(redisClient *c ) ;
#line 970
void zrangebyscoreCommand(redisClient *c ) ;
#line 971
void zrevrangebyscoreCommand(redisClient *c ) ;
#line 972
void zcountCommand(redisClient *c ) ;
#line 973
void zrevrangeCommand(redisClient *c ) ;
#line 974
void zcardCommand(redisClient *c ) ;
#line 975
void zremCommand(redisClient *c ) ;
#line 976
void zscoreCommand(redisClient *c ) ;
#line 977
void zremrangebyscoreCommand(redisClient *c ) ;
#line 978
void multiCommand(redisClient *c ) ;
#line 979
void execCommand(redisClient *c ) ;
#line 980
void discardCommand(redisClient *c ) ;
#line 981
void blpopCommand(redisClient *c ) ;
#line 982
void brpopCommand(redisClient *c ) ;
#line 983
void brpoplpushCommand(redisClient *c ) ;
#line 984
void appendCommand(redisClient *c ) ;
#line 985
void strlenCommand(redisClient *c ) ;
#line 986
void zrankCommand(redisClient *c ) ;
#line 987
void zrevrankCommand(redisClient *c ) ;
#line 988
void hsetCommand(redisClient *c ) ;
#line 989
void hsetnxCommand(redisClient *c ) ;
#line 990
void hgetCommand(redisClient *c ) ;
#line 991
void hmsetCommand(redisClient *c ) ;
#line 992
void hmgetCommand(redisClient *c ) ;
#line 993
void hdelCommand(redisClient *c ) ;
#line 994
void hlenCommand(redisClient *c ) ;
#line 995
void zremrangebyrankCommand(redisClient *c ) ;
#line 996
void zunionstoreCommand(redisClient *c ) ;
#line 997
void zinterstoreCommand(redisClient *c ) ;
#line 998
void hkeysCommand(redisClient *c ) ;
#line 999
void hvalsCommand(redisClient *c ) ;
#line 1000
void hgetallCommand(redisClient *c ) ;
#line 1001
void hexistsCommand(redisClient *c ) ;
#line 1002
void configCommand(redisClient *c ) ;
#line 1003
void hincrbyCommand(redisClient *c ) ;
#line 1004
void subscribeCommand(redisClient *c ) ;
#line 1005
void unsubscribeCommand(redisClient *c ) ;
#line 1006
void psubscribeCommand(redisClient *c ) ;
#line 1007
void punsubscribeCommand(redisClient *c ) ;
#line 1008
void publishCommand(redisClient *c ) ;
#line 1009
void watchCommand(redisClient *c ) ;
#line 1010
void unwatchCommand(redisClient *c ) ;
#line 24 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/signal.h"
_sig_func_ptr signal(int sig , void (*func)(int  ) ) ;
#line 11 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/assert.h"
void __libc_failwith(char *msg ) ;
#line 137 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
void __otter_fs_mount(void) ;
#line 138
void __otter_fs_init_stdin_out_err(void) ;
#line 49 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/fcntl.h"
int open(char const   *path , int oflag  , ...) ;
#line 71 "redis.c"
struct redisCommand readonlyCommandTable[119]  = 
#line 71 "redis.c"
  {      {(char *)"get", & getCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"set", & setCommand, 3, 4, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"setnx", & setnxCommand, 3, 4, (redisVmPreloadProc *)((void *)0), 0,
      0, 0}, 
        {(char *)"setex", & setexCommand, 4, 4, (redisVmPreloadProc *)((void *)0), 0,
      0, 0}, 
        {(char *)"append", & appendCommand, 3, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"strlen", & strlenCommand, 2, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"del", & delCommand, -2, 0, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"exists", & existsCommand, 2, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"setbit", & setbitCommand, 4, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"getbit", & getbitCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"setrange", & setrangeCommand, 4, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"getrange", & getrangeCommand, 4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"substr", & getrangeCommand, 4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"incr", & incrCommand, 2, 4, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"decr", & decrCommand, 2, 4, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"mget", & mgetCommand, -2, 0, (redisVmPreloadProc *)((void *)0), 1,
      -1, 1}, 
        {(char *)"rpush", & rpushCommand, 3, 4, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"lpush", & lpushCommand, 3, 4, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"rpushx", & rpushxCommand, 3, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"lpushx", & lpushxCommand, 3, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"linsert", & linsertCommand, 5, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"rpop", & rpopCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"lpop", & lpopCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"brpop", & brpopCommand, -3, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"brpoplpush", & brpoplpushCommand, 4, 4, (redisVmPreloadProc *)((void *)0),
      1, 2, 1}, 
        {(char *)"blpop", & blpopCommand, -3, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"llen", & llenCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"lindex", & lindexCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"lset", & lsetCommand, 4, 4, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"lrange", & lrangeCommand, 4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"ltrim", & ltrimCommand, 4, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"lrem", & lremCommand, 4, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"rpoplpush", & rpoplpushCommand, 3, 4, (redisVmPreloadProc *)((void *)0),
      1, 2, 1}, 
        {(char *)"sadd", & saddCommand, 3, 4, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"srem", & sremCommand, 3, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"smove", & smoveCommand, 4, 0, (redisVmPreloadProc *)((void *)0), 1,
      2, 1}, 
        {(char *)"sismember", & sismemberCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"scard", & scardCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"spop", & spopCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"srandmember", & srandmemberCommand, 2, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"sinter", & sinterCommand, -2, 4, (redisVmPreloadProc *)((void *)0),
      1, -1, 1}, 
        {(char *)"sinterstore", & sinterstoreCommand, -3, 4, (redisVmPreloadProc *)((void *)0),
      2, -1, 1}, 
        {(char *)"sunion", & sunionCommand, -2, 4, (redisVmPreloadProc *)((void *)0),
      1, -1, 1}, 
        {(char *)"sunionstore", & sunionstoreCommand, -3, 4, (redisVmPreloadProc *)((void *)0),
      2, -1, 1}, 
        {(char *)"sdiff", & sdiffCommand, -2, 4, (redisVmPreloadProc *)((void *)0), 1,
      -1, 1}, 
        {(char *)"sdiffstore", & sdiffstoreCommand, -3, 4, (redisVmPreloadProc *)((void *)0),
      2, -1, 1}, 
        {(char *)"smembers", & sinterCommand, 2, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zadd", & zaddCommand, 4, 4, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"zincrby", & zincrbyCommand, 4, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zrem", & zremCommand, 3, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"zremrangebyscore", & zremrangebyscoreCommand, 4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zremrangebyrank", & zremrangebyrankCommand, 4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zunionstore", & zunionstoreCommand, -4, 4, & zunionInterBlockClientOnSwappedKeys,
      0, 0, 0}, 
        {(char *)"zinterstore", & zinterstoreCommand, -4, 4, & zunionInterBlockClientOnSwappedKeys,
      0, 0, 0}, 
        {(char *)"zrange", & zrangeCommand, -4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zrangebyscore", & zrangebyscoreCommand, -4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zrevrangebyscore", & zrevrangebyscoreCommand, -4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zcount", & zcountCommand, 4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zrevrange", & zrevrangeCommand, -4, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zcard", & zcardCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"zscore", & zscoreCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"zrank", & zrankCommand, 3, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"zrevrank", & zrevrankCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"hset", & hsetCommand, 4, 4, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"hsetnx", & hsetnxCommand, 4, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"hget", & hgetCommand, 3, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"hmset", & hmsetCommand, -4, 4, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"hmget", & hmgetCommand, -3, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"hincrby", & hincrbyCommand, 4, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"hdel", & hdelCommand, 3, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"hlen", & hlenCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"hkeys", & hkeysCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"hvals", & hvalsCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"hgetall", & hgetallCommand, 2, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"hexists", & hexistsCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"incrby", & incrbyCommand, 3, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"decrby", & decrbyCommand, 3, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"getset", & getsetCommand, 3, 4, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"mset", & msetCommand, -3, 4, (redisVmPreloadProc *)((void *)0), 1,
      -1, 2}, 
        {(char *)"msetnx", & msetnxCommand, -3, 4, (redisVmPreloadProc *)((void *)0),
      1, -1, 2}, 
        {(char *)"randomkey", & randomkeyCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"select", & selectCommand, 2, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"move", & moveCommand, 3, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"rename", & renameCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"renamenx", & renamenxCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"expire", & expireCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"expireat", & expireatCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"keys", & keysCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"dbsize", & dbsizeCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"auth", & authCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"ping", & pingCommand, 1, 0, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"echo", & echoCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"save", & saveCommand, 1, 0, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"bgsave", & bgsaveCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"bgrewriteaof", & bgrewriteaofCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"shutdown", & shutdownCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"lastsave", & lastsaveCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"type", & typeCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"multi", & multiCommand, 1, 0, (redisVmPreloadProc *)((void *)0), 0,
      0, 0}, 
        {(char *)"exec", & execCommand, 1, 4, & execBlockClientOnSwappedKeys, 0, 0, 0}, 
        {(char *)"discard",
      & discardCommand, 1, 0, (redisVmPreloadProc *)((void *)0), 0, 0, 0}, 
        {(char *)"sync", & syncCommand, 1, 0, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"flushdb", & flushdbCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"flushall", & flushallCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"sort", & sortCommand, -2, 4, (redisVmPreloadProc *)((void *)0), 1,
      1, 1}, 
        {(char *)"info", & infoCommand, 1, 0, (redisVmPreloadProc *)((void *)0), 0, 0,
      0}, 
        {(char *)"monitor", & monitorCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"ttl", & ttlCommand, 2, 0, (redisVmPreloadProc *)((void *)0), 1, 1,
      1}, 
        {(char *)"persist", & persistCommand, 2, 0, (redisVmPreloadProc *)((void *)0),
      1, 1, 1}, 
        {(char *)"slaveof", & slaveofCommand, 3, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"debug", & debugCommand, -2, 0, (redisVmPreloadProc *)((void *)0), 0,
      0, 0}, 
        {(char *)"config", & configCommand, -2, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"subscribe", & subscribeCommand, -2, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"unsubscribe", & unsubscribeCommand, -1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"psubscribe", & psubscribeCommand, -2, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"punsubscribe", & punsubscribeCommand, -1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"publish", & publishCommand, 3, 8, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}, 
        {(char *)"watch", & watchCommand, -2, 0, (redisVmPreloadProc *)((void *)0), 0,
      0, 0}, 
        {(char *)"unwatch", & unwatchCommand, 1, 0, (redisVmPreloadProc *)((void *)0),
      0, 0, 0}};
#line 195 "redis.c"
void redisLog(int level , char const   *fmt  , ...) 
{ int syslogLevelMap[4] ;
  char const   *c ;
  time_t now ;
  time_t __cil_tmp ;
  va_list ap ;
  FILE *fp ;
  char buf[64] ;
  char msg[1024] ;
  FILE *__cil_tmp___0 ;
  pid_t __cil_tmp___1 ;

  {
#line 196
  syslogLevelMap[0] = 7;
#line 196
  syslogLevelMap[1] = 6;
#line 196
  syslogLevelMap[2] = 5;
#line 196
  syslogLevelMap[3] = 4;
#line 197
  c = ".-*#";
#line 198
  __cil_tmp = time((time_t *)((void *)0));
#line 198
  now = __cil_tmp;
#line 204
  if (level < server.verbosity) {
#line 204
    return;
  }
#line 206
  if ((unsigned int )server.logfile == (unsigned int )((void *)0)) {
#line 206
    fp = _impure_ptr->_stdout;
  } else {
#line 206
    __cil_tmp___0 = fopen((char const   *)server.logfile, "a");
#line 206
    fp = __cil_tmp___0;
  }
#line 207
  if (! fp) {
#line 207
    return;
  }
#line 209
  __builtin_va_start(ap, fmt);
#line 210
  vsnprintf(msg, (unsigned int )sizeof(msg), fmt, ap);
#line 211
  __builtin_va_end(ap);
#line 215
  buf[0] = (char)0;
#line 219
  __cil_tmp___1 = getpid();
#line 219
  fprintf(fp, "[%d] %s %c %s\n", __cil_tmp___1, buf, (int const   )*(c + level), msg);
#line 220
  fflush(fp);
#line 222
  if (server.logfile) {
#line 222
    fclose(fp);
  }
#line 224
  if (server.syslog_enabled) {
#line 224
    syslog(syslogLevelMap[level], "%s", msg);
  }
#line 225
  return;
}
}
#line 232 "redis.c"
void oom(char const   *msg ) 
{ 

  {
#line 233
  redisLog(3, "%s: Out of memory\n", msg);
#line 234
  sleep(1U);
#line 235
  abort();
}
}
#line 250 "redis.c"
void dictListDestructor(void *privdata , void *val ) 
{ 

  {
#line 253
  listRelease((list *)val);
#line 254
  return;
}
}
#line 256 "redis.c"
int dictSdsKeyCompare(void *privdata , void const   *key1 , void const   *key2 ) 
{ int l1 ;
  int l2 ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 262
  __cil_tmp = sdslen((char *)key1);
#line 262
  l1 = (int )__cil_tmp;
#line 263
  __cil_tmp___0 = sdslen((char *)key2);
#line 263
  l2 = (int )__cil_tmp___0;
#line 264
  if (l1 != l2) {
#line 264
    return (0);
  }
#line 265
  __cil_tmp___1 = memcmp(key1, key2, (unsigned int )l1);
#line 265
  return (__cil_tmp___1 == 0);
}
}
#line 269 "redis.c"
int dictSdsKeyCaseCompare(void *privdata , void const   *key1 , void const   *key2 ) 
{ int __cil_tmp ;

  {
#line 274
  __cil_tmp = strcasecmp((char const   *)key1, (char const   *)key2);
#line 274
  return (__cil_tmp == 0);
}
}
#line 277 "redis.c"
void dictRedisObjectDestructor(void *privdata , void *val ) 
{ 

  {
#line 281
  if ((unsigned int )val == (unsigned int )((void *)0)) {
#line 281
    return;
  }
#line 282
  decrRefCount(val);
#line 283
  return;
}
}
#line 285 "redis.c"
void dictSdsDestructor(void *privdata , void *val ) 
{ 

  {
#line 289
  sdsfree((char *)val);
#line 290
  return;
}
}
#line 292 "redis.c"
int dictObjKeyCompare(void *privdata , void const   *key1 , void const   *key2 ) 
{ robj const   *o1 ;
  robj const   *o2 ;
  int __cil_tmp ;

  {
#line 295
  o1 = (robj const   *)key1;
#line 295
  o2 = (robj const   *)key2;
#line 296
  __cil_tmp = dictSdsKeyCompare(privdata, (void const   *)o1->ptr, (void const   *)o2->ptr);
#line 296
  return (__cil_tmp);
}
}
#line 299 "redis.c"
unsigned int dictObjHash(void const   *key ) 
{ robj const   *o ;
  size_t __cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 300
  o = (robj const   *)key;
#line 301
  __cil_tmp = sdslen((char *)o->ptr);
#line 301
  __cil_tmp___0 = dictGenHashFunction((unsigned char const   *)o->ptr, (int )__cil_tmp);
#line 301
  return (__cil_tmp___0);
}
}
#line 304 "redis.c"
unsigned int dictSdsHash(void const   *key ) 
{ size_t __cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 305
  __cil_tmp = sdslen((char *)key);
#line 305
  __cil_tmp___0 = dictGenHashFunction((unsigned char const   *)((unsigned char *)key),
                                      (int )__cil_tmp);
#line 305
  return (__cil_tmp___0);
}
}
#line 308 "redis.c"
unsigned int dictSdsCaseHash(void const   *key ) 
{ size_t __cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 309
  __cil_tmp = sdslen((char *)key);
#line 309
  __cil_tmp___0 = dictGenCaseHashFunction((unsigned char const   *)((unsigned char *)key),
                                          (int )__cil_tmp);
#line 309
  return (__cil_tmp___0);
}
}
#line 312 "redis.c"
int dictEncObjKeyCompare(void *privdata , void const   *key1 , void const   *key2 ) 
{ robj *o1 ;
  robj *o2 ;
  int cmp ;

  {
#line 315
  o1 = (robj *)key1;
#line 315
  o2 = (robj *)key2;
#line 318
  if (o1->encoding == 1U && o2->encoding == 1U) {
#line 320
    return ((unsigned int )o1->ptr == (unsigned int )o2->ptr);
  }
#line 322
  o1 = getDecodedObject(o1);
#line 323
  o2 = getDecodedObject(o2);
#line 324
  cmp = dictSdsKeyCompare(privdata, (void const   *)o1->ptr, (void const   *)o2->ptr);
#line 325
  decrRefCount((void *)o1);
#line 326
  decrRefCount((void *)o2);
#line 327
  return (cmp);
}
}
#line 330 "redis.c"
unsigned int dictEncObjHash(void const   *key ) 
{ robj *o ;
  size_t __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  char buf[32] ;
  int len ;
  unsigned int __cil_tmp___1 ;
  unsigned int hash ;
  size_t __cil_tmp___2 ;

  {
#line 331
  o = (robj *)key;
#line 333
  if (o->encoding == 0U) {
#line 334
    __cil_tmp = sdslen((char *)o->ptr);
#line 334
    __cil_tmp___0 = dictGenHashFunction((unsigned char const   *)o->ptr, (int )__cil_tmp);
#line 334
    return (__cil_tmp___0);
  } else
#line 336
  if (o->encoding == 1U) {
#line 340
    len = ll2string(buf, 32U, (long long )((long )o->ptr));
#line 341
    __cil_tmp___1 = dictGenHashFunction((unsigned char const   *)((unsigned char *)(buf)),
                                        len);
#line 341
    return (__cil_tmp___1);
  } else {
#line 345
    o = getDecodedObject(o);
#line 346
    __cil_tmp___2 = sdslen((char *)o->ptr);
#line 346
    hash = dictGenHashFunction((unsigned char const   *)o->ptr, (int )__cil_tmp___2);
#line 347
    decrRefCount((void *)o);
#line 348
    return (hash);
  }
}
}
#line 354 "redis.c"
dictType setDictType  =    {& dictEncObjHash, (void *(*)(void *privdata , void const   *key ))((void *)0),
    (void *(*)(void *privdata , void const   *obj ))((void *)0), & dictEncObjKeyCompare,
    & dictRedisObjectDestructor, (void (*)(void *privdata , void *obj ))((void *)0)};
#line 364 "redis.c"
dictType zsetDictType  =    {& dictEncObjHash, (void *(*)(void *privdata , void const   *key ))((void *)0),
    (void *(*)(void *privdata , void const   *obj ))((void *)0), & dictEncObjKeyCompare,
    & dictRedisObjectDestructor, (void (*)(void *privdata , void *obj ))((void *)0)};
#line 374 "redis.c"
dictType dbDictType  =    {& dictSdsHash, (void *(*)(void *privdata , void const   *key ))((void *)0), (void *(*)(void *privdata ,
                                                                                           void const   *obj ))((void *)0),
    & dictSdsKeyCompare, & dictSdsDestructor, & dictRedisObjectDestructor};
#line 384 "redis.c"
dictType keyptrDictType  =    {& dictSdsHash, (void *(*)(void *privdata , void const   *key ))((void *)0), (void *(*)(void *privdata ,
                                                                                           void const   *obj ))((void *)0),
    & dictSdsKeyCompare, (void (*)(void *privdata , void *key ))((void *)0), (void (*)(void *privdata ,
                                                                                       void *obj ))((void *)0)};
#line 394 "redis.c"
dictType commandTableDictType  =    {& dictSdsCaseHash, (void *(*)(void *privdata , void const   *key ))((void *)0),
    (void *(*)(void *privdata , void const   *obj ))((void *)0), & dictSdsKeyCaseCompare,
    & dictSdsDestructor, (void (*)(void *privdata , void *obj ))((void *)0)};
#line 404 "redis.c"
dictType hashDictType  =    {& dictEncObjHash, (void *(*)(void *privdata , void const   *key ))((void *)0),
    (void *(*)(void *privdata , void const   *obj ))((void *)0), & dictEncObjKeyCompare,
    & dictRedisObjectDestructor, & dictRedisObjectDestructor};
#line 416 "redis.c"
dictType keylistDictType  =    {& dictObjHash, (void *(*)(void *privdata , void const   *key ))((void *)0), (void *(*)(void *privdata ,
                                                                                           void const   *obj ))((void *)0),
    & dictObjKeyCompare, & dictRedisObjectDestructor, & dictListDestructor};
#line 425 "redis.c"
int htNeedsResize(dict *dict___0 ) 
{ long long size ;
  long long used ;

  {
#line 428
  size = (long long )(dict___0->ht[0].size + dict___0->ht[1].size);
#line 429
  used = (long long )(dict___0->ht[0].used + dict___0->ht[1].used);
#line 430
  return (((size && used) && size > 4LL) && (used * 100LL) / size < 10LL);
}
}
#line 436 "redis.c"
void tryResizeHashTables(void) 
{ int j ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 439
  j = 0;
#line 439
  while (j < server.dbnum) {
#line 440
    __cil_tmp = htNeedsResize((server.db + j)->dict);
#line 440
    if (__cil_tmp) {
#line 441
      dictResize((server.db + j)->dict);
    }
#line 442
    __cil_tmp___0 = htNeedsResize((server.db + j)->expires);
#line 442
    if (__cil_tmp___0) {
#line 443
      dictResize((server.db + j)->expires);
    }
#line 439
    j ++;
  }
#line 445
  return;
}
}
#line 451 "redis.c"
void incrementallyRehash(void) 
{ int j ;

  {
#line 454
  j = 0;
#line 454
  while (j < server.dbnum) {
#line 455
    if (((server.db + j)->dict)->rehashidx != -1) {
#line 456
      dictRehashMilliseconds((server.db + j)->dict, 1);
#line 457
      break;
    }
#line 454
    j ++;
  }
#line 460
  return;
}
}
#line 468 "redis.c"
void updateDictResizePolicy(void) 
{ 

  {
#line 469
  if (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1) {
#line 470
    dictEnableResize();
  } else {
#line 472
    dictDisableResize();
  }
#line 473
  return;
}
}
#line 481 "redis.c"
void activeExpireCycle(void) 
{ int j ;
  int expired ;
  redisDb *db ;
  long num ;
  time_t now ;
  time_t __cil_tmp ;
  dictEntry *de ;
  time_t t ;
  sds key ;
  robj *keyobj ;
  size_t __cil_tmp___0 ;
  robj *__cil_tmp___1 ;
  long __cil_tmp___2 ;

  {
#line 484
  j = 0;
#line 484
  while (j < server.dbnum) {
#line 486
    db = server.db + j;
#line 490
    while (1) {
#line 491
      num = (long )((db->expires)->ht[0].used + (db->expires)->ht[1].used);
#line 492
      __cil_tmp = time((time_t *)((void *)0));
#line 492
      now = __cil_tmp;
#line 494
      expired = 0;
#line 495
      if (num > 10L) {
#line 496
        num = 10L;
      }
#line 497
      while (1) {
#line 497
        __cil_tmp___2 = num;
#line 497
        num --;
#line 497
        if (! __cil_tmp___2) {
#line 497
          break;
        }
#line 501
        de = dictGetRandomKey(db->expires);
#line 501
        if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 501
          break;
        }
#line 502
        t = (long )de->val;
#line 503
        if (now > t) {
#line 504
          key = (char *)de->key;
#line 505
          __cil_tmp___0 = sdslen(key);
#line 505
          __cil_tmp___1 = createStringObject(key, __cil_tmp___0);
#line 505
          keyobj = __cil_tmp___1;
#line 507
          propagateExpire(db, keyobj);
#line 508
          dbDelete(db, keyobj);
#line 509
          decrRefCount((void *)keyobj);
#line 510
          expired ++;
#line 511
          (server.stat_expiredkeys) ++;
        }
      }
#line 490
      if (! (expired > 2)) {
#line 490
        break;
      }
    }
#line 484
    j ++;
  }
#line 516
  return;
}
}
#line 518 "redis.c"
void updateLRUClock(void) 
{ time_t __cil_tmp ;

  {
#line 519
  __cil_tmp = time((time_t *)((void *)0));
#line 519
  server.lruclock = (unsigned int )(__cil_tmp / 10L & (long )((1 << 21) - 1));
#line 521
  return;
}
}
#line 596
extern int wait3() ;
#line 523 "redis.c"
int serverCron(struct aeEventLoop *eventLoop , long long id , void *clientData ) 
{ int j ;
  int loops ;
  int __cil_tmp ;
  long long size ;
  long long used ;
  long long vkeys ;
  size_t __cil_tmp___0 ;
  int statloc ;
  pid_t pid ;
  time_t now ;
  time_t __cil_tmp___1 ;
  struct saveparam *sp ;
  int retval ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  size_t __cil_tmp___5 ;
  size_t __cil_tmp___6 ;
  int __cil_tmp___7 ;

  {
#line 524
  loops = server.cronloops;
#line 533
  server.unixtime = time((time_t *)((void *)0));
#line 546
  updateLRUClock();
#line 550
  if (server.shutdown_asap) {
#line 551
    __cil_tmp = prepareForShutdown();
#line 551
    if (__cil_tmp == 0) {
#line 551
      exit(0);
    }
#line 552
    redisLog(3, "SIGTERM received but errors trying to shut down the server, check the logs for more information");
  }
#line 556
  j = 0;
#line 556
  while (j < server.dbnum) {
#line 559
    size = (long long )(((server.db + j)->dict)->ht[0].size + ((server.db + j)->dict)->ht[1].size);
#line 560
    used = (long long )(((server.db + j)->dict)->ht[0].used + ((server.db + j)->dict)->ht[1].used);
#line 561
    vkeys = (long long )(((server.db + j)->expires)->ht[0].used + ((server.db + j)->expires)->ht[1].used);
#line 562
    if (! (loops % 50) && (used || vkeys)) {
#line 563
      redisLog(1, "DB %d: %lld keys (%lld volatile) in %lld slots HT.", j, used, vkeys,
               size);
    }
#line 556
    j ++;
  }
#line 574
  if (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1) {
#line 575
    if (! (loops % 10)) {
#line 575
      tryResizeHashTables();
    }
#line 576
    if (server.activerehashing) {
#line 576
      incrementallyRehash();
    }
  }
#line 580
  if (! (loops % 50)) {
#line 581
    __cil_tmp___0 = zmalloc_used_memory();
#line 581
    redisLog(1, "%d clients connected (%d slaves), %zu bytes in use", (server.clients)->len - (server.slaves)->len,
             (server.slaves)->len, __cil_tmp___0);
  }
#line 588
  if ((server.maxidletime && ! (loops % 100)) || server.bpop_blocked_clients) {
#line 589
    closeTimedoutClients();
  }
#line 592
  if (server.bgsavechildpid != -1 || server.bgrewritechildpid != -1) {
#line 596
    pid = wait3(& statloc, 4, (void *)0);
#line 596
    if (pid != 0) {
#line 597
      if (pid == server.bgsavechildpid) {
#line 598
        backgroundSaveDoneHandler(statloc);
      } else {
#line 600
        backgroundRewriteDoneHandler(statloc);
      }
#line 602
      updateDictResizePolicy();
    }
  } else {
#line 607
    __cil_tmp___1 = time((time_t *)((void *)0));
#line 607
    now = __cil_tmp___1;
#line 608
    j = 0;
#line 608
    while (j < server.saveparamslen) {
#line 609
      sp = server.saveparams + j;
#line 611
      if (server.dirty >= (long long )sp->changes && now - server.lastsave > sp->seconds) {
#line 613
        redisLog(2, "%d changes in %d seconds. Saving...", sp->changes, sp->seconds);
#line 615
        rdbSaveBackground(server.dbfilename);
#line 616
        break;
      }
#line 608
      j ++;
    }
  }
#line 624
  if ((unsigned int )server.masterhost == (unsigned int )((void *)0)) {
#line 624
    activeExpireCycle();
  }
#line 628
  __cil_tmp___7 = vmCanSwapOut();
#line 628
  if (__cil_tmp___7) {
#line 629
    while (1) {
#line 629
      if (server.vm_enabled) {
#line 629
        __cil_tmp___6 = zmalloc_used_memory();
#line 629
        if (! ((unsigned long long )__cil_tmp___6 > server.vm_max_memory)) {
#line 629
          break;
        }
      } else {
#line 629
        break;
      }
#line 632
      if (server.vm_max_threads == 0) {
#line 632
        __cil_tmp___2 = vmSwapOneObjectBlocking();
#line 632
        __cil_tmp___4 = __cil_tmp___2;
      } else {
#line 632
        __cil_tmp___3 = vmSwapOneObjectThreaded();
#line 632
        __cil_tmp___4 = __cil_tmp___3;
      }
#line 632
      retval = __cil_tmp___4;
#line 635
      if (retval == -1 && ! (loops % 300)) {
#line 635
        __cil_tmp___5 = zmalloc_used_memory();
#line 635
        if ((unsigned long long )__cil_tmp___5 > server.vm_max_memory + server.vm_max_memory / 10ULL) {
#line 639
          redisLog(3, "WARNING: vm-max-memory limit exceeded by more than 10%% but unable to swap more objects out!");
        }
      }
#line 645
      if (retval == -1 || server.vm_max_threads > 0) {
#line 645
        break;
      }
    }
  }
#line 651
  if (! (loops % 10)) {
#line 651
    replicationCron();
  }
#line 653
  (server.cronloops) ++;
#line 654
  return (100);
}
}
#line 660 "redis.c"
void beforeSleep(struct aeEventLoop *eventLoop ) 
{ listNode *ln ;
  redisClient *c ;
  listIter li ;
  struct redisCommand *cmd ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 666
  if (server.vm_enabled && (server.io_ready_clients)->len) {
#line 669
    listRewind(server.io_ready_clients, & li);
#line 670
    while (1) {
#line 670
      ln = listNext(& li);
#line 670
      if (! ln) {
#line 670
        break;
      }
#line 671
      c = (redisClient *)ln->value;
#line 675
      listDelNode(server.io_ready_clients, ln);
#line 676
      c->flags &= -33;
#line 677
      (server.vm_blocked_clients) --;
#line 678
      aeCreateFileEvent(server.el, c->fd, 1, & readQueryFromClient, (void *)c);
#line 680
      cmd = lookupCommand((char *)(*(c->argv + 0))->ptr);
#line 681
      if (! ((unsigned int )cmd != (unsigned int )((void *)0))) {
#line 681
        _redisAssert((char *)"cmd != NULL", (char *)"redis.c", 681);
#line 681
        _exit(1);
      }
#line 682
      call(c, cmd);
#line 683
      resetClient(c);
#line 685
      if (c->querybuf) {
#line 685
        __cil_tmp = sdslen(c->querybuf);
#line 685
        if (__cil_tmp > 0U) {
#line 686
          processInputBuffer(c);
        }
      }
    }
  }
#line 691
  while ((server.unblocked_clients)->len) {
#line 692
    ln = (server.unblocked_clients)->head;
#line 693
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 693
      _redisAssert((char *)"ln != NULL", (char *)"redis.c", 693);
#line 693
      _exit(1);
    }
#line 694
    c = (redisClient *)ln->value;
#line 695
    listDelNode(server.unblocked_clients, ln);
#line 696
    c->flags &= -257;
#line 699
    if (c->querybuf) {
#line 699
      __cil_tmp___0 = sdslen(c->querybuf);
#line 699
      if (__cil_tmp___0 > 0U) {
#line 700
        processInputBuffer(c);
      }
    }
  }
#line 704
  flushAppendOnlyFile();
#line 705
  return;
}
}
#line 709 "redis.c"
void createSharedObjects(void) 
{ int j ;
  sds __cil_tmp ;
  sds __cil_tmp___0 ;
  sds __cil_tmp___1 ;
  sds __cil_tmp___2 ;
  sds __cil_tmp___3 ;
  sds __cil_tmp___4 ;
  sds __cil_tmp___5 ;
  sds __cil_tmp___6 ;
  sds __cil_tmp___7 ;
  sds __cil_tmp___8 ;
  sds __cil_tmp___9 ;
  sds __cil_tmp___10 ;
  sds __cil_tmp___11 ;
  sds __cil_tmp___12 ;
  sds __cil_tmp___13 ;
  sds __cil_tmp___14 ;
  sds __cil_tmp___15 ;
  sds __cil_tmp___16 ;
  sds __cil_tmp___17 ;
  sds __cil_tmp___18 ;
  sds __cil_tmp___19 ;

  {
#line 712
  __cil_tmp = sdsnew("\r\n");
#line 712
  shared.crlf = createObject(0, (void *)__cil_tmp);
#line 713
  __cil_tmp___0 = sdsnew("+OK\r\n");
#line 713
  shared.ok = createObject(0, (void *)__cil_tmp___0);
#line 714
  __cil_tmp___1 = sdsnew("-ERR\r\n");
#line 714
  shared.err = createObject(0, (void *)__cil_tmp___1);
#line 715
  __cil_tmp___2 = sdsnew("$0\r\n\r\n");
#line 715
  shared.emptybulk = createObject(0, (void *)__cil_tmp___2);
#line 716
  __cil_tmp___3 = sdsnew(":0\r\n");
#line 716
  shared.czero = createObject(0, (void *)__cil_tmp___3);
#line 717
  __cil_tmp___4 = sdsnew(":1\r\n");
#line 717
  shared.cone = createObject(0, (void *)__cil_tmp___4);
#line 718
  __cil_tmp___5 = sdsnew(":-1\r\n");
#line 718
  shared.cnegone = createObject(0, (void *)__cil_tmp___5);
#line 719
  __cil_tmp___6 = sdsnew("$-1\r\n");
#line 719
  shared.nullbulk = createObject(0, (void *)__cil_tmp___6);
#line 720
  __cil_tmp___7 = sdsnew("*-1\r\n");
#line 720
  shared.nullmultibulk = createObject(0, (void *)__cil_tmp___7);
#line 721
  __cil_tmp___8 = sdsnew("*0\r\n");
#line 721
  shared.emptymultibulk = createObject(0, (void *)__cil_tmp___8);
#line 722
  __cil_tmp___9 = sdsnew("+PONG\r\n");
#line 722
  shared.pong = createObject(0, (void *)__cil_tmp___9);
#line 723
  __cil_tmp___10 = sdsnew("+QUEUED\r\n");
#line 723
  shared.queued = createObject(0, (void *)__cil_tmp___10);
#line 724
  __cil_tmp___11 = sdsnew("-ERR Operation against a key holding the wrong kind of value\r\n");
#line 724
  shared.wrongtypeerr = createObject(0, (void *)__cil_tmp___11);
#line 726
  __cil_tmp___12 = sdsnew("-ERR no such key\r\n");
#line 726
  shared.nokeyerr = createObject(0, (void *)__cil_tmp___12);
#line 728
  __cil_tmp___13 = sdsnew("-ERR syntax error\r\n");
#line 728
  shared.syntaxerr = createObject(0, (void *)__cil_tmp___13);
#line 730
  __cil_tmp___14 = sdsnew("-ERR source and destination objects are the same\r\n");
#line 730
  shared.sameobjecterr = createObject(0, (void *)__cil_tmp___14);
#line 732
  __cil_tmp___15 = sdsnew("-ERR index out of range\r\n");
#line 732
  shared.outofrangeerr = createObject(0, (void *)__cil_tmp___15);
#line 734
  __cil_tmp___16 = sdsnew("-LOADING Redis is loading the dataset in memory\r\n");
#line 734
  shared.loadingerr = createObject(0, (void *)__cil_tmp___16);
#line 736
  __cil_tmp___17 = sdsnew(" ");
#line 736
  shared.space = createObject(0, (void *)__cil_tmp___17);
#line 737
  __cil_tmp___18 = sdsnew(":");
#line 737
  shared.colon = createObject(0, (void *)__cil_tmp___18);
#line 738
  __cil_tmp___19 = sdsnew("+");
#line 738
  shared.plus = createObject(0, (void *)__cil_tmp___19);
#line 739
  shared.select0 = createStringObject((char *)"select 0\r\n", 10U);
#line 740
  shared.select1 = createStringObject((char *)"select 1\r\n", 10U);
#line 741
  shared.select2 = createStringObject((char *)"select 2\r\n", 10U);
#line 742
  shared.select3 = createStringObject((char *)"select 3\r\n", 10U);
#line 743
  shared.select4 = createStringObject((char *)"select 4\r\n", 10U);
#line 744
  shared.select5 = createStringObject((char *)"select 5\r\n", 10U);
#line 745
  shared.select6 = createStringObject((char *)"select 6\r\n", 10U);
#line 746
  shared.select7 = createStringObject((char *)"select 7\r\n", 10U);
#line 747
  shared.select8 = createStringObject((char *)"select 8\r\n", 10U);
#line 748
  shared.select9 = createStringObject((char *)"select 9\r\n", 10U);
#line 749
  shared.messagebulk = createStringObject((char *)"$7\r\nmessage\r\n", 13U);
#line 750
  shared.pmessagebulk = createStringObject((char *)"$8\r\npmessage\r\n", 14U);
#line 751
  shared.subscribebulk = createStringObject((char *)"$9\r\nsubscribe\r\n", 15U);
#line 752
  shared.unsubscribebulk = createStringObject((char *)"$11\r\nunsubscribe\r\n", 18U);
#line 753
  shared.psubscribebulk = createStringObject((char *)"$10\r\npsubscribe\r\n", 17U);
#line 754
  shared.punsubscribebulk = createStringObject((char *)"$12\r\npunsubscribe\r\n",
                                               19U);
#line 755
  shared.mbulk3 = createStringObject((char *)"*3\r\n", 4U);
#line 756
  shared.mbulk4 = createStringObject((char *)"*4\r\n", 4U);
#line 757
  j = 0;
#line 757
  while (j < 10) {
#line 758
    shared.integers[j] = createObject(0, (void *)((long )j));
#line 759
    (shared.integers[j])->encoding = 1U;
#line 757
    j ++;
  }
#line 761
  return;
}
}
#line 763 "redis.c"
void initServerConfig(void) 
{ 

  {
#line 764
  server.port = 6379;
#line 765
  server.bindaddr = (char *)((void *)0);
#line 766
  server.unixsocket = (char *)((void *)0);
#line 767
  server.ipfd = -1;
#line 768
  server.sofd = -1;
#line 769
  server.dbnum = 16;
#line 770
  server.verbosity = 1;
#line 771
  server.maxidletime = 300;
#line 772
  server.saveparams = (struct saveparam *)((void *)0);
#line 773
  server.loading = 0;
#line 774
  server.logfile = (char *)((void *)0);
#line 775
  server.syslog_enabled = 0;
#line 776
  server.syslog_ident = strdup("redis");
#line 777
  server.syslog_facility = 16 << 3;
#line 778
  server.daemonize = 0;
#line 779
  server.appendonly = 0;
#line 780
  server.appendfsync = 2;
#line 781
  server.no_appendfsync_on_rewrite = 0;
#line 782
  server.lastfsync = time((time_t *)((void *)0));
#line 783
  server.appendfd = -1;
#line 784
  server.appendseldb = -1;
#line 785
  server.pidfile = strdup("/var/run/redis.pid");
#line 786
  server.dbfilename = strdup("dump.rdb");
#line 787
  server.appendfilename = strdup("appendonly.aof");
#line 788
  server.requirepass = (char *)((void *)0);
#line 789
  server.rdbcompression = 1;
#line 790
  server.activerehashing = 1;
#line 791
  server.maxclients = 0U;
#line 792
  server.bpop_blocked_clients = 0U;
#line 793
  server.maxmemory = 0ULL;
#line 794
  server.maxmemory_policy = 0;
#line 795
  server.maxmemory_samples = 3;
#line 796
  server.vm_enabled = 0;
#line 797
  server.vm_swap_file = strdup("/tmp/redis-%p.vm");
#line 798
  server.vm_page_size = 256L;
#line 799
  server.vm_pages = 104857600L;
#line 800
  server.vm_max_memory = 1073741824ULL;
#line 801
  server.vm_max_threads = 4;
#line 802
  server.vm_blocked_clients = 0U;
#line 803
  server.hash_max_zipmap_entries = 512U;
#line 804
  server.hash_max_zipmap_value = 64U;
#line 805
  server.list_max_ziplist_entries = 256U;
#line 806
  server.list_max_ziplist_value = 16U;
#line 807
  server.set_max_intset_entries = 512U;
#line 808
  server.shutdown_asap = 0;
#line 810
  updateLRUClock();
#line 811
  resetServerSaveParams();
#line 813
  appendServerSaveParams(3600L, 1);
#line 814
  appendServerSaveParams(300L, 100);
#line 815
  appendServerSaveParams(60L, 10000);
#line 817
  server.isslave = 0;
#line 818
  server.masterauth = (char *)((void *)0);
#line 819
  server.masterhost = (char *)((void *)0);
#line 820
  server.masterport = 6379;
#line 821
  server.master = (redisClient *)((void *)0);
#line 822
  server.replstate = 0;
#line 823
  server.repl_serve_stale_data = 1;
#line 826
  R_Zero = 0.0;
#line 827
  R_PosInf = 1.0 / R_Zero;
#line 828
  R_NegInf = - 1.0 / R_Zero;
#line 829
  R_Nan = R_Zero / R_Zero;
#line 834
  server.commands = dictCreate(& commandTableDictType, (void *)0);
#line 835
  populateCommandTable();
#line 836
  server.delCommand = lookupCommandByCString((char *)"del");
#line 837
  server.multiCommand = lookupCommandByCString((char *)"multi");
#line 838
  return;
}
}
#line 840 "redis.c"
void initServer(void) 
{ int j ;
  void *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  char *__cil_tmp___3 ;

  {
#line 843
  signal(1, (void (*)(int  ))1);
#line 844
  signal(13, (void (*)(int  ))1);
#line 845
  setupSigSegvAction();
#line 847
  if (server.syslog_enabled) {
#line 848
    openlog((char const   *)server.syslog_ident, 25, server.syslog_facility);
  }
#line 852
  server.mainthread = pthread_self();
#line 853
  server.clients = listCreate();
#line 854
  server.slaves = listCreate();
#line 855
  server.monitors = listCreate();
#line 856
  server.unblocked_clients = listCreate();
#line 857
  createSharedObjects();
#line 858
  server.el = aeCreateEventLoop();
#line 859
  __cil_tmp = malloc((unsigned int )(sizeof(redisDb ) * (unsigned long )server.dbnum));
#line 859
  server.db = (redisDb *)__cil_tmp;
#line 860
  server.ipfd = anetTcpServer(server.neterr, server.port, server.bindaddr);
#line 861
  if (server.ipfd == -1) {
#line 862
    redisLog(3, "Opening port: %s", server.neterr);
#line 863
    exit(1);
  }
#line 865
  if ((unsigned int )server.unixsocket != (unsigned int )((void *)0)) {
#line 866
    unlink((char const   *)server.unixsocket);
#line 867
    server.sofd = anetUnixServer(server.neterr, server.unixsocket);
#line 868
    if (server.sofd == -1) {
#line 869
      redisLog(3, "Opening socket: %s", server.neterr);
#line 870
      exit(1);
    }
  }
#line 873
  if (server.ipfd < 0 && server.sofd < 0) {
#line 874
    redisLog(3, "Configured to not listen anywhere, exiting.");
#line 875
    exit(1);
  }
#line 877
  j = 0;
#line 877
  while (j < server.dbnum) {
#line 878
    (server.db + j)->dict = dictCreate(& dbDictType, (void *)0);
#line 879
    (server.db + j)->expires = dictCreate(& keyptrDictType, (void *)0);
#line 880
    (server.db + j)->blocking_keys = dictCreate(& keylistDictType, (void *)0);
#line 881
    (server.db + j)->watched_keys = dictCreate(& keylistDictType, (void *)0);
#line 882
    if (server.vm_enabled) {
#line 883
      (server.db + j)->io_keys = dictCreate(& keylistDictType, (void *)0);
    }
#line 884
    (server.db + j)->id = j;
#line 877
    j ++;
  }
#line 886
  server.pubsub_channels = dictCreate(& keylistDictType, (void *)0);
#line 887
  server.pubsub_patterns = listCreate();
#line 888
  (server.pubsub_patterns)->free = & freePubsubPattern;
#line 889
  (server.pubsub_patterns)->match = & listMatchPubsubPattern;
#line 890
  server.cronloops = 0;
#line 891
  server.bgsavechildpid = -1;
#line 892
  server.bgrewritechildpid = -1;
#line 893
  server.bgrewritebuf = sdsempty();
#line 894
  server.aofbuf = sdsempty();
#line 895
  server.lastsave = time((time_t *)((void *)0));
#line 896
  server.dirty = 0LL;
#line 897
  server.stat_numcommands = 0LL;
#line 898
  server.stat_numconnections = 0LL;
#line 899
  server.stat_expiredkeys = 0LL;
#line 900
  server.stat_evictedkeys = 0LL;
#line 901
  server.stat_starttime = time((time_t *)((void *)0));
#line 902
  server.stat_keyspace_misses = 0LL;
#line 903
  server.stat_keyspace_hits = 0LL;
#line 904
  server.unixtime = time((time_t *)((void *)0));
#line 905
  aeCreateTimeEvent(server.el, 1LL, & serverCron, (void *)0, (aeEventFinalizerProc *)((void *)0));
#line 906
  if (server.ipfd > 0) {
#line 906
    __cil_tmp___0 = aeCreateFileEvent(server.el, server.ipfd, 1, & acceptTcpHandler,
                                      (void *)0);
#line 906
    if (__cil_tmp___0 == -1) {
#line 907
      oom("creating file event");
    }
  }
#line 908
  if (server.sofd > 0) {
#line 908
    __cil_tmp___1 = aeCreateFileEvent(server.el, server.sofd, 1, & acceptUnixHandler,
                                      (void *)0);
#line 908
    if (__cil_tmp___1 == -1) {
#line 909
      oom("creating file event");
    }
  }
#line 911
  if (server.appendonly) {
#line 912
    server.appendfd = open((char const   *)server.appendfilename, 70, 420);
#line 913
    if (server.appendfd == -1) {
#line 914
      __cil_tmp___2 = __errno();
#line 914
      __cil_tmp___3 = strerror(*__cil_tmp___2);
#line 914
      redisLog(3, "Can\'t open the append-only file: %s", __cil_tmp___3);
#line 916
      exit(1);
    }
  }
#line 920
  if (server.vm_enabled) {
#line 920
    vmInit();
  }
#line 921
  return;
}
}
#line 925 "redis.c"
void populateCommandTable(void) 
{ int j ;
  int numcommands ;
  struct redisCommand *c ;
  int retval ;
  sds __cil_tmp ;

  {
#line 927
  numcommands = (int )(sizeof(readonlyCommandTable) / sizeof(struct redisCommand ));
#line 929
  j = 0;
#line 929
  while (j < numcommands) {
#line 930
    c = readonlyCommandTable + j;
#line 933
    __cil_tmp = sdsnew((char const   *)c->name);
#line 933
    retval = dictAdd(server.commands, (void *)__cil_tmp, (void *)c);
#line 934
    if ((retval == 0) == 0) {
#line 934
      __libc_failwith((char *)"Assertion failed: retval == DICT_OK at redis.c:934");
    }
#line 929
    j ++;
  }
#line 936
  return;
}
}
#line 940 "redis.c"
struct redisCommand *lookupCommand(sds name ) 
{ void *__cil_tmp ;

  {
#line 941
  __cil_tmp = dictFetchValue(server.commands, (void const   *)name);
#line 941
  return ((struct redisCommand *)__cil_tmp);
}
}
#line 944 "redis.c"
struct redisCommand *lookupCommandByCString(char *s ) 
{ struct redisCommand *cmd ;
  sds name ;
  sds __cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 946
  __cil_tmp = sdsnew((char const   *)s);
#line 946
  name = __cil_tmp;
#line 948
  __cil_tmp___0 = dictFetchValue(server.commands, (void const   *)name);
#line 948
  cmd = (struct redisCommand *)__cil_tmp___0;
#line 949
  sdsfree(name);
#line 950
  return (cmd);
}
}
#line 954 "redis.c"
void call(redisClient *c , struct redisCommand *cmd ) 
{ long long dirty ;

  {
#line 957
  dirty = server.dirty;
#line 958
  (*(cmd->proc))(c);
#line 959
  dirty = server.dirty - dirty;
#line 961
  if (server.appendonly && dirty) {
#line 962
    feedAppendOnlyFile(cmd, (c->db)->id, c->argv, c->argc);
  }
#line 963
  if ((dirty || cmd->flags & 8) && (server.slaves)->len) {
#line 965
    replicationFeedSlaves(server.slaves, (c->db)->id, c->argv, c->argc);
  }
#line 966
  if ((server.monitors)->len) {
#line 967
    replicationFeedMonitors(server.monitors, (c->db)->id, c->argv, c->argc);
  }
#line 968
  (server.stat_numcommands) ++;
#line 969
  return;
}
}
#line 979 "redis.c"
int processCommand(redisClient *c ) 
{ struct redisCommand *cmd ;
  int __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 986
  __cil_tmp = strcasecmp((char const   *)(*(c->argv + 0))->ptr, "quit");
#line 986
  if (! __cil_tmp) {
#line 987
    addReply(c, shared.ok);
#line 988
    c->flags |= 128;
#line 989
    return (-1);
  }
#line 994
  cmd = lookupCommand((char *)(*(c->argv + 0))->ptr);
#line 995
  if (! cmd) {
#line 996
    addReplyErrorFormat(c, "unknown command \'%s\'", (char *)(*(c->argv + 0))->ptr);
#line 998
    return (0);
  } else
#line 999
  if ((cmd->arity > 0 && cmd->arity != c->argc) || c->argc < - cmd->arity) {
#line 1001
    addReplyErrorFormat(c, "wrong number of arguments for \'%s\' command", cmd->name);
#line 1003
    return (0);
  }
#line 1007
  if ((server.requirepass && ! c->authenticated) && (unsigned int )cmd->proc != (unsigned int )(& authCommand)) {
#line 1008
    addReplyError(c, (char *)"operation not permitted");
#line 1009
    return (0);
  }
#line 1017
  if (server.maxmemory) {
#line 1017
    freeMemoryIfNeeded();
  }
#line 1018
  if (server.maxmemory && cmd->flags & 4) {
#line 1018
    __cil_tmp___0 = zmalloc_used_memory();
#line 1018
    if ((unsigned long long )__cil_tmp___0 > server.maxmemory) {
#line 1021
      addReplyError(c, (char *)"command not allowed when used memory > \'maxmemory\'");
#line 1022
      return (0);
    }
  }
#line 1026
  if ((((((c->pubsub_channels)->ht[0].used + (c->pubsub_channels)->ht[1].used > 0UL || (c->pubsub_patterns)->len > 0U) && (unsigned int )cmd->proc != (unsigned int )(& subscribeCommand)) && (unsigned int )cmd->proc != (unsigned int )(& unsubscribeCommand)) && (unsigned int )cmd->proc != (unsigned int )(& psubscribeCommand)) && (unsigned int )cmd->proc != (unsigned int )(& punsubscribeCommand)) {
#line 1030
    addReplyError(c, (char *)"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context");
#line 1031
    return (0);
  }
#line 1036
  if ((((server.masterhost && server.replstate != 3) && server.repl_serve_stale_data == 0) && (unsigned int )cmd->proc != (unsigned int )(& infoCommand)) && (unsigned int )cmd->proc != (unsigned int )(& slaveofCommand)) {
#line 1040
    addReplyError(c, (char *)"link with MASTER is down and slave-serve-stale-data is set to no");
#line 1042
    return (0);
  }
#line 1046
  if (server.loading && (unsigned int )cmd->proc != (unsigned int )(& infoCommand)) {
#line 1047
    addReply(c, shared.loadingerr);
#line 1048
    return (0);
  }
#line 1052
  if ((((c->flags & 8 && (unsigned int )cmd->proc != (unsigned int )(& execCommand)) && (unsigned int )cmd->proc != (unsigned int )(& discardCommand)) && (unsigned int )cmd->proc != (unsigned int )(& multiCommand)) && (unsigned int )cmd->proc != (unsigned int )(& watchCommand)) {
#line 1056
    queueMultiCommand(c, cmd);
#line 1057
    addReply(c, shared.queued);
  } else {
#line 1059
    if (server.vm_enabled && server.vm_max_threads > 0) {
#line 1059
      __cil_tmp___1 = blockClientOnSwappedKeys(c, cmd);
#line 1059
      if (__cil_tmp___1) {
#line 1060
        return (-1);
      }
    }
#line 1061
    call(c, cmd);
  }
#line 1063
  return (0);
}
}
#line 1075
int kill(pid_t pid , int sig ) ;
#line 1068 "redis.c"
int prepareForShutdown(void) 
{ int __cil_tmp ;

  {
#line 1069
  redisLog(3, "User requested shutdown, saving DB...");
#line 1073
  if (server.bgsavechildpid != -1) {
#line 1074
    redisLog(3, "There is a live saving child. Killing it!");
#line 1075
    kill(server.bgsavechildpid, 9);
#line 1076
    rdbRemoveTempFile(server.bgsavechildpid);
  }
#line 1078
  if (server.appendonly) {
#line 1080
    fsync(server.appendfd);
#line 1081
    if (server.vm_enabled) {
#line 1081
      unlink((char const   *)server.vm_swap_file);
    }
  } else
#line 1082
  if (server.saveparamslen > 0) {
#line 1084
    __cil_tmp = rdbSave(server.dbfilename);
#line 1084
    if (__cil_tmp != 0) {
#line 1090
      redisLog(3, "Error trying to save the DB, can\'t exit");
#line 1091
      return (-1);
    }
  } else {
#line 1094
    redisLog(3, "Not saving DB.");
  }
#line 1096
  if (server.daemonize) {
#line 1096
    unlink((char const   *)server.pidfile);
  }
#line 1097
  redisLog(3, "Server exit now, bye bye...");
#line 1098
  return (0);
}
}
#line 1103 "redis.c"
void authCommand(redisClient *c ) 
{ int __cil_tmp ;

  {
#line 1104
  if (! server.requirepass) {
#line 1105
    c->authenticated = 1;
#line 1106
    addReply(c, shared.ok);
  } else {
#line 1104
    __cil_tmp = strcmp((char const   *)(*(c->argv + 1))->ptr, (char const   *)server.requirepass);
#line 1104
    if (__cil_tmp) {
#line 1108
      c->authenticated = 0;
#line 1109
      addReplyError(c, (char *)"invalid password");
    } else {
#line 1105
      c->authenticated = 1;
#line 1106
      addReply(c, shared.ok);
    }
  }
#line 1111
  return;
}
}
#line 1113 "redis.c"
void pingCommand(redisClient *c ) 
{ 

  {
#line 1114
  addReply(c, shared.pong);
#line 1115
  return;
}
}
#line 1117 "redis.c"
void echoCommand(redisClient *c ) 
{ 

  {
#line 1118
  addReplyBulk(c, *(c->argv + 1));
#line 1119
  return;
}
}
#line 1123 "redis.c"
void bytesToHuman(char *s , unsigned long long n ) 
{ double d ;

  {
#line 1126
  if (n < 1024ULL) {
#line 1128
    sprintf(s, "%lluB", n);
#line 1129
    return;
  } else
#line 1130
  if (n < 1048576ULL) {
#line 1131
    d = (double )n / (double )1024;
#line 1132
    sprintf(s, "%.2fK", d);
  } else
#line 1133
  if (n < 1073741824ULL) {
#line 1134
    d = (double )n / (double )1048576;
#line 1135
    sprintf(s, "%.2fM", d);
  } else
#line 1136
  if (n < 1099511627776ULL) {
#line 1137
    d = (double )n / (double )1073741824LL;
#line 1138
    sprintf(s, "%.2fG", d);
  }
#line 1140
  return;
}
}
#line 1153
extern int getrusage() ;
#line 1145 "redis.c"
sds genRedisInfoString(void) 
{ sds info ;
  time_t uptime ;
  time_t __cil_tmp ;
  int j ;
  char hmem[64] ;
  struct rusage self_ru ;
  struct rusage c_ru ;
  unsigned long lol ;
  unsigned long bib ;
  size_t __cil_tmp___0 ;
  float __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  pid_t __cil_tmp___4 ;
  char *__cil_tmp___5 ;
  char *__cil_tmp___6 ;
  long __cil_tmp___7 ;
  char *__cil_tmp___8 ;
  sds __cil_tmp___9 ;
  time_t __cil_tmp___10 ;
  int __cil_tmp___11 ;
  time_t __cil_tmp___12 ;
  double perc ;
  time_t eta ;
  time_t elapsed ;
  off_t remaining_bytes ;
  time_t __cil_tmp___13 ;
  size_t count ;
  size_t __cil_tmp___14 ;
  size_t __cil_tmp___15 ;
  long long keys ;
  long long vkeys ;

  {
#line 1147
  __cil_tmp = time((time_t *)((void *)0));
#line 1147
  uptime = __cil_tmp - server.stat_starttime;
#line 1153
  getrusage(0, & self_ru);
#line 1154
  getrusage(-1, & c_ru);
#line 1155
  getClientsMaxBuffers(& lol, & bib);
#line 1157
  __cil_tmp___0 = zmalloc_used_memory();
#line 1157
  bytesToHuman(hmem, (unsigned long long )__cil_tmp___0);
#line 1158
  __cil_tmp___1 = zmalloc_get_fragmentation_ratio();
#line 1158
  __cil_tmp___2 = zmalloc_get_rss();
#line 1158
  __cil_tmp___3 = zmalloc_used_memory();
#line 1158
  __cil_tmp___4 = getpid();
#line 1158
  __cil_tmp___5 = aeGetApiName();
#line 1158
  __cil_tmp___6 = redisGitDirty();
#line 1158
  __cil_tmp___7 = strtol((char const   *)__cil_tmp___6, (char **)((void *)0), 10);
#line 1158
  __cil_tmp___8 = redisGitSHA1();
#line 1158
  __cil_tmp___9 = sdsempty();
#line 1158
  info = sdscatprintf(__cil_tmp___9, "redis_version:%s\r\nredis_git_sha1:%s\r\nredis_git_dirty:%d\r\narch_bits:%s\r\nmultiplexing_api:%s\r\nprocess_id:%ld\r\nuptime_in_seconds:%ld\r\nuptime_in_days:%ld\r\nlru_clock:%ld\r\nused_cpu_sys:%.2f\r\nused_cpu_user:%.2f\r\nused_cpu_sys_childrens:%.2f\r\nused_cpu_user_childrens:%.2f\r\nconnected_clients:%d\r\nconnected_slaves:%d\r\nclient_longest_output_list:%lu\r\nclient_biggest_input_buf:%lu\r\nblocked_clients:%d\r\nused_memory:%zu\r\nused_memory_human:%s\r\nused_memory_rss:%zu\r\nmem_fragmentation_ratio:%.2f\r\nuse_tcmalloc:%d\r\nloading:%d\r\naof_enabled:%d\r\nchanges_since_last_save:%lld\r\nbgsave_in_progress:%d\r\nlast_save_time:%ld\r\nbgrewriteaof_in_progress:%d\r\ntotal_connections_received:%lld\r\ntotal_commands_processed:%lld\r\nexpired_keys:%lld\r\nevicted_keys:%lld\r\nkeyspace_hits:%lld\r\nkeyspace_misses:%lld\r\nhash_max_zipmap_entries:%zu\r\nhash_max_zipmap_value:%zu\r\npubsub_channels:%ld\r\npubsub_patterns:%u\r\nvm_enabled:%d\r\nrole:%s\r\n",
                      "2.1.12", __cil_tmp___8, __cil_tmp___7 > 0L, sizeof(long ) == 8UL ? "64" : "32",
                      __cil_tmp___5, (long )__cil_tmp___4, uptime, uptime / 86400L,
                      (unsigned long )server.lruclock, (double )((float )self_ru.ru_utime.tv_sec + (float )self_ru.ru_utime.tv_usec / (float )1000000),
                      (double )((float )self_ru.ru_stime.tv_sec + (float )self_ru.ru_stime.tv_usec / (float )1000000),
                      (double )((float )c_ru.ru_utime.tv_sec + (float )c_ru.ru_utime.tv_usec / (float )1000000),
                      (double )((float )c_ru.ru_stime.tv_sec + (float )c_ru.ru_stime.tv_usec / (float )1000000),
                      (server.clients)->len - (server.slaves)->len, (server.slaves)->len,
                      lol, bib, server.bpop_blocked_clients, __cil_tmp___3, hmem,
                      __cil_tmp___2, (double )__cil_tmp___1, 0, server.loading, server.appendonly,
                      server.dirty, server.bgsavechildpid != -1, server.lastsave,
                      server.bgrewritechildpid != -1, server.stat_numconnections,
                      server.stat_numcommands, server.stat_expiredkeys, server.stat_evictedkeys,
                      server.stat_keyspace_hits, server.stat_keyspace_misses, server.hash_max_zipmap_entries,
                      server.hash_max_zipmap_value, (server.pubsub_channels)->ht[0].used + (server.pubsub_channels)->ht[1].used,
                      (server.pubsub_patterns)->len, server.vm_enabled != 0, (unsigned int )server.masterhost == (unsigned int )((void *)0) ? "master" : "slave");
#line 1245
  if (server.masterhost) {
#line 1246
    if (server.master) {
#line 1246
      __cil_tmp___10 = time((time_t *)((void *)0));
#line 1246
      __cil_tmp___11 = (int )(__cil_tmp___10 - (server.master)->lastinteraction);
    } else {
#line 1246
      __cil_tmp___11 = -1;
    }
#line 1246
    info = sdscatprintf(info, "master_host:%s\r\nmaster_port:%d\r\nmaster_link_status:%s\r\nmaster_last_io_seconds_ago:%d\r\nmaster_sync_in_progress:%d\r\n",
                        server.masterhost, server.masterport, server.replstate == 3 ? "up" : "down",
                        __cil_tmp___11, server.replstate == 2);
#line 1260
    if (server.replstate == 2) {
#line 1261
      __cil_tmp___12 = time((time_t *)((void *)0));
#line 1261
      info = sdscatprintf(info, "master_sync_left_bytes:%ld\r\nmaster_sync_last_io_seconds_ago:%d\r\n",
                          server.repl_transfer_left, (int )(__cil_tmp___12 - server.repl_transfer_lastio));
    }
  }
#line 1269
  if (server.vm_enabled) {
#line 1270
    lockThreadedIO();
#line 1271
    info = sdscatprintf(info, "vm_conf_max_memory:%llu\r\nvm_conf_page_size:%llu\r\nvm_conf_pages:%llu\r\nvm_stats_used_pages:%llu\r\nvm_stats_swapped_objects:%llu\r\nvm_stats_swappin_count:%llu\r\nvm_stats_swappout_count:%llu\r\nvm_stats_io_newjobs_len:%lu\r\nvm_stats_io_processing_len:%lu\r\nvm_stats_io_processed_len:%lu\r\nvm_stats_io_active_threads:%lu\r\nvm_stats_blocked_clients:%lu\r\n",
                        server.vm_max_memory, (unsigned long long )server.vm_page_size,
                        (unsigned long long )server.vm_pages, server.vm_stats_used_pages,
                        server.vm_stats_swapped_objects, server.vm_stats_swapins,
                        server.vm_stats_swapouts, (unsigned long )(server.io_newjobs)->len,
                        (unsigned long )(server.io_processing)->len, (unsigned long )(server.io_processed)->len,
                        (unsigned long )server.io_active_threads, (unsigned long )server.vm_blocked_clients);
#line 1297
    unlockThreadedIO();
  }
#line 1299
  if (server.loading) {
#line 1302
    remaining_bytes = server.loading_total_bytes - server.loading_loaded_bytes;
#line 1305
    perc = ((double )server.loading_loaded_bytes / (double )server.loading_total_bytes) * (double )100;
#line 1308
    __cil_tmp___13 = time((time_t *)((void *)0));
#line 1308
    elapsed = __cil_tmp___13 - server.loading_start_time;
#line 1309
    if (elapsed == 0L) {
#line 1310
      eta = 1L;
    } else {
#line 1312
      eta = (elapsed * remaining_bytes) / server.loading_loaded_bytes;
    }
#line 1315
    info = sdscatprintf(info, "loading_start_time:%ld\r\nloading_total_bytes:%llu\r\nloading_loaded_bytes:%llu\r\nloading_loaded_perc:%.2f\r\nloading_eta_seconds:%ld\r\n",
                        (unsigned long )server.loading_start_time, (unsigned long long )server.loading_total_bytes,
                        (unsigned long long )server.loading_loaded_bytes, perc, eta);
  }
#line 1329
  info = sdscat(info, (char *)"allocation_stats:");
#line 1330
  j = 0;
#line 1330
  while (j <= 256) {
#line 1331
    __cil_tmp___14 = zmalloc_allocations_for_size((unsigned int )j);
#line 1331
    count = __cil_tmp___14;
#line 1332
    if (count) {
#line 1333
      __cil_tmp___15 = sdslen(info);
#line 1333
      if ((int )*(info + (__cil_tmp___15 - 1U)) != 58) {
#line 1333
        info = sdscatlen(info, (void *)",", 1U);
      }
#line 1334
      info = sdscatprintf(info, "%s%d=%zu", j == 256 ? ">=" : "", j, count);
    }
#line 1330
    j ++;
  }
#line 1339
  info = sdscat(info, (char *)"\r\n");
#line 1341
  j = 0;
#line 1341
  while (j < server.dbnum) {
#line 1344
    keys = (long long )(((server.db + j)->dict)->ht[0].used + ((server.db + j)->dict)->ht[1].used);
#line 1345
    vkeys = (long long )(((server.db + j)->expires)->ht[0].used + ((server.db + j)->expires)->ht[1].used);
#line 1346
    if (keys || vkeys) {
#line 1347
      info = sdscatprintf(info, "db%d:keys=%lld,expires=%lld\r\n", j, keys, vkeys);
    }
#line 1341
    j ++;
  }
#line 1351
  return (info);
}
}
#line 1354 "redis.c"
void infoCommand(redisClient *c ) 
{ sds info ;
  sds __cil_tmp ;
  size_t __cil_tmp___0 ;
  sds __cil_tmp___1 ;
  sds __cil_tmp___2 ;

  {
#line 1355
  __cil_tmp = genRedisInfoString();
#line 1355
  info = __cil_tmp;
#line 1356
  __cil_tmp___0 = sdslen(info);
#line 1356
  __cil_tmp___1 = sdsempty();
#line 1356
  __cil_tmp___2 = sdscatprintf(__cil_tmp___1, "$%lu\r\n", (unsigned long )__cil_tmp___0);
#line 1356
  addReplySds(c, __cil_tmp___2);
#line 1358
  addReplySds(c, info);
#line 1359
  addReply(c, shared.crlf);
#line 1360
  return;
}
}
#line 1362 "redis.c"
void monitorCommand(redisClient *c ) 
{ 

  {
#line 1364
  if (c->flags & 1) {
#line 1364
    return;
  }
#line 1366
  c->flags |= 5;
#line 1367
  c->slaveseldb = 0;
#line 1368
  listAddNodeTail(server.monitors, (void *)c);
#line 1369
  addReply(c, shared.ok);
#line 1370
  return;
}
}
#line 1385 "redis.c"
void freeMemoryIfNeeded(void) 
{ int j ;
  int k ;
  int freed ;
  long bestval ;
  sds bestkey ;
  struct dictEntry *de ;
  redisDb *db ;
  dict *dict___0 ;
  sds thiskey ;
  long thisval ;
  robj *o ;
  unsigned long __cil_tmp ;
  sds thiskey___0 ;
  long thisval___0 ;
  robj *keyobj ;
  size_t __cil_tmp___0 ;
  robj *__cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 1388
  if (server.maxmemory_policy == 5) {
#line 1388
    return;
  }
#line 1390
  while (1) {
#line 1390
    if (server.maxmemory) {
#line 1390
      __cil_tmp___2 = zmalloc_used_memory();
#line 1390
      if (! ((unsigned long long )__cil_tmp___2 > server.maxmemory)) {
#line 1390
        break;
      }
    } else {
#line 1390
      break;
    }
#line 1391
    freed = 0;
#line 1393
    j = 0;
#line 1393
    while (j < server.dbnum) {
#line 1394
      bestval = 0L;
#line 1395
      bestkey = (char *)((void *)0);
#line 1397
      db = server.db + j;
#line 1400
      if (server.maxmemory_policy == 3 || server.maxmemory_policy == 4) {
#line 1403
        dict___0 = (server.db + j)->dict;
      } else {
#line 1405
        dict___0 = (server.db + j)->expires;
      }
#line 1407
      if (dict___0->ht[0].used + dict___0->ht[1].used == 0UL) {
#line 1407
        goto __Cont;
      }
#line 1410
      if (server.maxmemory_policy == 4 || server.maxmemory_policy == 2) {
#line 1413
        de = dictGetRandomKey(dict___0);
#line 1414
        bestkey = (char *)de->key;
      } else
#line 1418
      if (server.maxmemory_policy == 3 || server.maxmemory_policy == 0) {
#line 1421
        k = 0;
#line 1421
        while (k < server.maxmemory_samples) {
#line 1426
          de = dictGetRandomKey(dict___0);
#line 1427
          thiskey = (char *)de->key;
#line 1430
          if (server.maxmemory_policy == 0) {
#line 1431
            de = dictFind(db->dict, (void const   *)thiskey);
          }
#line 1432
          o = (robj *)de->val;
#line 1433
          __cil_tmp = estimateObjectIdleTime(o);
#line 1433
          thisval = (long )__cil_tmp;
#line 1436
          if ((unsigned int )bestkey == (unsigned int )((void *)0) || thisval > bestval) {
#line 1437
            bestkey = thiskey;
#line 1438
            bestval = thisval;
          }
#line 1421
          k ++;
        }
      } else
#line 1444
      if (server.maxmemory_policy == 1) {
#line 1445
        k = 0;
#line 1445
        while (k < server.maxmemory_samples) {
#line 1449
          de = dictGetRandomKey(dict___0);
#line 1450
          thiskey___0 = (char *)de->key;
#line 1451
          thisval___0 = (long )de->val;
#line 1455
          if ((unsigned int )bestkey == (unsigned int )((void *)0) || thisval___0 < bestval) {
#line 1456
            bestkey = thiskey___0;
#line 1457
            bestval = thisval___0;
          }
#line 1445
          k ++;
        }
      }
#line 1463
      if (bestkey) {
#line 1464
        __cil_tmp___0 = sdslen(bestkey);
#line 1464
        __cil_tmp___1 = createStringObject(bestkey, __cil_tmp___0);
#line 1464
        keyobj = __cil_tmp___1;
#line 1465
        dbDelete(db, keyobj);
#line 1466
        (server.stat_evictedkeys) ++;
#line 1467
        decrRefCount((void *)keyobj);
#line 1468
        freed ++;
      }
      __Cont: 
#line 1393
      j ++;
    }
#line 1471
    if (! freed) {
#line 1471
      return;
    }
  }
#line 1473
  return;
}
}
#line 1499 "redis.c"
void createPidFile(void) 
{ FILE *fp ;
  FILE *__cil_tmp ;
  pid_t __cil_tmp___0 ;

  {
#line 1501
  __cil_tmp = fopen((char const   *)server.pidfile, "w");
#line 1501
  fp = __cil_tmp;
#line 1502
  if (fp) {
#line 1503
    __cil_tmp___0 = getpid();
#line 1503
    fprintf(fp, "%d\n", __cil_tmp___0);
#line 1504
    fclose(fp);
  }
#line 1506
  return;
}
}
#line 1508 "redis.c"
void daemonize(void) 
{ int fd ;
  pid_t __cil_tmp ;

  {
#line 1511
  __cil_tmp = fork();
#line 1511
  if (__cil_tmp != 0) {
#line 1511
    exit(0);
  }
#line 1512
  setsid();
#line 1517
  fd = open("/dev/null", 3, 0);
#line 1517
  if (fd != -1) {
#line 1518
    dup2(fd, 0);
#line 1519
    dup2(fd, 1);
#line 1520
    dup2(fd, 2);
#line 1521
    if (fd > 2) {
#line 1521
      close(fd);
    }
  }
#line 1523
  return;
}
}
#line 1525 "redis.c"
void version(void) 
{ char *__cil_tmp ;
  int __cil_tmp___0 ;
  char *__cil_tmp___1 ;

  {
#line 1526
  __cil_tmp = redisGitDirty();
#line 1526
  __cil_tmp___0 = atoi((char const   *)__cil_tmp);
#line 1526
  __cil_tmp___1 = redisGitSHA1();
#line 1526
  printf("Redis server version %s (%s:%d)\n", "2.1.12", __cil_tmp___1, __cil_tmp___0 > 0);
#line 1528
  exit(0);
}
}
#line 1531 "redis.c"
void usage(void) 
{ 

  {
#line 1532
  fprintf(_impure_ptr->_stderr, "Usage: ./redis-server [/path/to/redis.conf]\n");
#line 1533
  fprintf(_impure_ptr->_stderr, "       ./redis-server - (read config from stdin)\n");
#line 1534
  exit(1);
}
}
#line 27 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_scheduler.h"
void __otter_multi_begin_atomic(void) ;
#line 28
void __otter_multi_end_atomic(void) ;
#line 30
void __otter_multi_io_block(void *  , ...) ;
#line 6 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/multiotter_builtins.h"
void *__otter_multi_gmalloc(size_t size ) ;
#line 1543 "redis.c"
void client_main(void) ;
#line 1545 "redis.c"
int main(int argc , char **argv ) 
{ void *__cil_tmp ;
  pid_t __cil_tmp___0 ;
  time_t start ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  time_t __cil_tmp___4 ;
  int __cil_tmp___5 ;
  time_t __cil_tmp___6 ;
  int __cil_tmp___7 ;

  {
#line 1546
  __otter_fs_mount();
#line 1547
  __cil_tmp = __otter_multi_gmalloc((unsigned int )sizeof(int ));
#line 1547
  redis_has_called_listen = (int *)__cil_tmp;
#line 1548
  *redis_has_called_listen = 0;
#line 1549
  __cil_tmp___0 = fork();
#line 1549
  if (! __cil_tmp___0) {
#line 1550
    __otter_multi_begin_atomic();
#line 1550
    while (*redis_has_called_listen == 0) {
#line 1550
      __otter_multi_io_block((void *)redis_has_called_listen);
#line 1550
      __otter_multi_begin_atomic();
    }
#line 1550
    __otter_multi_end_atomic();
#line 1551
    __otter_fs_init_stdin_out_err();
#line 1552
    client_main();
#line 1553
    return (0);
  }
#line 1555
  __otter_fs_init_stdin_out_err();
#line 1561
  initServerConfig();
#line 1562
  if (argc == 2) {
#line 1563
    __cil_tmp___1 = strcmp((char const   *)*(argv + 1), "-v");
#line 1563
    if (__cil_tmp___1 == 0) {
#line 1564
      version();
    } else {
#line 1563
      __cil_tmp___2 = strcmp((char const   *)*(argv + 1), "--version");
#line 1563
      if (__cil_tmp___2 == 0) {
#line 1564
        version();
      }
    }
#line 1565
    __cil_tmp___3 = strcmp((char const   *)*(argv + 1), "--help");
#line 1565
    if (__cil_tmp___3 == 0) {
#line 1565
      usage();
    }
#line 1566
    resetServerSaveParams();
#line 1567
    loadServerConfig(*(argv + 1));
  } else
#line 1568
  if (argc > 2) {
#line 1569
    usage();
  } else {
#line 1571
    redisLog(3, "Warning: no config file specified, using the default config. In order to specify a config file use \'redis-server /path/to/redis.conf\'");
  }
#line 1573
  if (server.daemonize) {
#line 1573
    daemonize();
  }
#line 1574
  initServer();
#line 1575
  if (server.daemonize) {
#line 1575
    createPidFile();
  }
#line 1576
  redisLog(2, "Server started, Redis version 2.1.12");
#line 1580
  start = time((time_t *)((void *)0));
#line 1581
  if (server.appendonly) {
#line 1582
    __cil_tmp___5 = loadAppendOnlyFile(server.appendfilename);
#line 1582
    if (__cil_tmp___5 == 0) {
#line 1583
      __cil_tmp___4 = time((time_t *)((void *)0));
#line 1583
      redisLog(2, "DB loaded from append only file: %ld seconds", __cil_tmp___4 - start);
    }
  } else {
#line 1585
    __cil_tmp___7 = rdbLoad(server.dbfilename);
#line 1585
    if (__cil_tmp___7 == 0) {
#line 1586
      __cil_tmp___6 = time((time_t *)((void *)0));
#line 1586
      redisLog(2, "DB loaded from disk: %ld seconds", __cil_tmp___6 - start);
    }
  }
#line 1588
  if (server.ipfd > 0) {
#line 1589
    redisLog(2, "The server is now ready to accept connections on port %d", server.port);
  }
#line 1590
  if (server.sofd > 0) {
#line 1591
    redisLog(2, "The server is now ready to accept connections at %s", server.unixsocket);
  }
#line 1592
  aeSetBeforeSleepProc(server.el, & beforeSleep);
#line 1593
  aeMain(server.el);
#line 1594
  aeDeleteEventLoop(server.el);
#line 1595
  return (0);
}
}
#line 1697 "redis.c"
void setupSigSegvAction(void) 
{ 

  {
#line 1698
  return;
}
}
#line 1 "sds.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-FV01hOp9.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 45 "sds.h"
sds sdsnewlen(void const   *init , size_t initlen ) ;
#line 49
sds sdsdup(sds s ) ;
#line 51
size_t sdsavail(sds s ) ;
#line 52
sds sdsgrowzero(sds s , size_t len ) ;
#line 58
sds sdscatvprintf(sds s , char const   *fmt , va_list ap ) ;
#line 66
sds sdstrim(sds s , char const   *cset___0 ) ;
#line 67
sds sdsrange(sds s , int start , int end ) ;
#line 69
int sdscmp(sds s1___0 , sds s2___0 ) ;
#line 70
sds *sdssplitlen(char *s , int len , char *sep , int seplen , int *count ) ;
#line 71
void sdsfreesplitres(sds *tokens , int count ) ;
#line 72
void sdstolower(sds s ) ;
#line 74
sds sdsfromlonglong(long long value ) ;
#line 75
sds sdscatrepr(sds s , char *p , size_t len ) ;
#line 76
sds *sdssplitargs(char *line , int *argc ) ;
#line 121 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
void *realloc(void *ptr , size_t size )  __attribute__((__deprecated__)) ;
#line 25 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
void *memmove(void *dst_void , void const   *src_void , size_t length ) ;
#line 28
char *strchr(char const   *s1___0 , int i ) ;
#line 34
size_t strlen(char const   *str ) ;
#line 40 "sds.c"
static void sdsOomAbort(void) 
{ 

  {
#line 41
  fprintf(_impure_ptr->_stderr, "SDS: Out Of Memory (SDS_ABORT_ON_OOM defined)\n");
#line 42
  abort();
}
}
#line 45 "sds.c"
sds sdsnewlen(void const   *init , size_t initlen ) 
{ struct sdshdr *sh ;
  void *__cil_tmp ;

  {
#line 48
  __cil_tmp = malloc((unsigned int )((sizeof(struct sdshdr ) + (unsigned long )initlen) + 1UL));
#line 48
  sh = (struct sdshdr *)__cil_tmp;
#line 50
  if ((unsigned int )sh == (unsigned int )((void *)0)) {
#line 50
    sdsOomAbort();
  }
#line 54
  sh->len = (int )initlen;
#line 55
  sh->free = 0;
#line 56
  if (initlen) {
#line 57
    if (init) {
#line 57
      memcpy((void *)(sh->buf), init, initlen);
    } else {
#line 58
      memset((void *)(sh->buf), 0, initlen);
    }
  }
#line 60
  sh->buf[initlen] = (char )'\000';
#line 61
  return (sh->buf);
}
}
#line 64 "sds.c"
sds sdsempty(void) 
{ sds __cil_tmp ;

  {
#line 65
  __cil_tmp = sdsnewlen((void const   *)"", 0U);
#line 65
  return (__cil_tmp);
}
}
#line 68 "sds.c"
sds sdsnew(char const   *init ) 
{ size_t initlen ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  sds __cil_tmp___1 ;

  {
#line 69
  if ((unsigned int )init == (unsigned int )((void *)0)) {
#line 69
    __cil_tmp___0 = 0U;
  } else {
#line 69
    __cil_tmp = strlen(init);
#line 69
    __cil_tmp___0 = __cil_tmp;
  }
#line 69
  initlen = __cil_tmp___0;
#line 70
  __cil_tmp___1 = sdsnewlen((void const   *)init, initlen);
#line 70
  return (__cil_tmp___1);
}
}
#line 73 "sds.c"
size_t sdslen(sds s ) 
{ struct sdshdr *sh ;

  {
#line 74
  sh = (struct sdshdr *)((void *)(s - sizeof(struct sdshdr )));
#line 75
  return ((unsigned int )sh->len);
}
}
#line 78 "sds.c"
sds sdsdup(sds s ) 
{ size_t __cil_tmp ;
  sds __cil_tmp___0 ;

  {
#line 79
  __cil_tmp = sdslen(s);
#line 79
  __cil_tmp___0 = sdsnewlen((void const   *)s, __cil_tmp);
#line 79
  return (__cil_tmp___0);
}
}
#line 82 "sds.c"
void sdsfree(sds s ) 
{ 

  {
#line 83
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 83
    return;
  }
#line 84
  free((void *)(s - sizeof(struct sdshdr )));
#line 85
  return;
}
}
#line 87 "sds.c"
size_t sdsavail(sds s ) 
{ struct sdshdr *sh ;

  {
#line 88
  sh = (struct sdshdr *)((void *)(s - sizeof(struct sdshdr )));
#line 89
  return ((unsigned int )sh->free);
}
}
#line 99 "sds.c"
static sds sdsMakeRoomFor(sds s , size_t addlen ) 
{ struct sdshdr *sh ;
  struct sdshdr *newsh ;
  size_t free___0 ;
  size_t __cil_tmp ;
  size_t len ;
  size_t newlen ;
  void *__cil_tmp___0 ;

  {
#line 101
  __cil_tmp = sdsavail(s);
#line 101
  free___0 = __cil_tmp;
#line 104
  if (free___0 >= addlen) {
#line 104
    return (s);
  }
#line 105
  len = sdslen(s);
#line 106
  sh = (struct sdshdr *)((void *)(s - sizeof(struct sdshdr )));
#line 107
  newlen = (len + addlen) * 2U;
#line 108
  __cil_tmp___0 = realloc((void *)sh, (unsigned int )((sizeof(struct sdshdr ) + (unsigned long )newlen) + 1UL));
#line 108
  newsh = (struct sdshdr *)__cil_tmp___0;
#line 110
  if ((unsigned int )newsh == (unsigned int )((void *)0)) {
#line 110
    sdsOomAbort();
  }
#line 115
  newsh->free = (int )(newlen - len);
#line 116
  return (newsh->buf);
}
}
#line 121 "sds.c"
sds sdsgrowzero(sds s , size_t len ) 
{ struct sdshdr *sh ;
  size_t totlen ;
  size_t curlen ;

  {
#line 122
  sh = (struct sdshdr *)((void *)(s - sizeof(struct sdshdr )));
#line 123
  curlen = (unsigned int )sh->len;
#line 125
  if (len <= curlen) {
#line 125
    return (s);
  }
#line 126
  s = sdsMakeRoomFor(s, len - curlen);
#line 127
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 127
    return ((char *)((void *)0));
  }
#line 130
  sh = (struct sdshdr *)((void *)(s - sizeof(struct sdshdr )));
#line 131
  memset((void *)(s + curlen), 0, (len - curlen) + 1U);
#line 132
  totlen = (unsigned int )(sh->len + sh->free);
#line 133
  sh->len = (int )len;
#line 134
  sh->free = (int )(totlen - (unsigned int )sh->len);
#line 135
  return (s);
}
}
#line 138 "sds.c"
sds sdscatlen(sds s , void *t , size_t len ) 
{ struct sdshdr *sh ;
  size_t curlen ;
  size_t __cil_tmp ;

  {
#line 140
  __cil_tmp = sdslen(s);
#line 140
  curlen = __cil_tmp;
#line 142
  s = sdsMakeRoomFor(s, len);
#line 143
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 143
    return ((char *)((void *)0));
  }
#line 144
  sh = (struct sdshdr *)((void *)(s - sizeof(struct sdshdr )));
#line 145
  memcpy((void *)(s + curlen), (void const   *)t, len);
#line 146
  sh->len = (int )(curlen + len);
#line 147
  sh->free = (int )((unsigned int )sh->free - len);
#line 148
  *(s + (curlen + len)) = (char )'\000';
#line 149
  return (s);
}
}
#line 152 "sds.c"
sds sdscat(sds s , char *t ) 
{ size_t __cil_tmp ;
  sds __cil_tmp___0 ;

  {
#line 153
  __cil_tmp = strlen((char const   *)t);
#line 153
  __cil_tmp___0 = sdscatlen(s, (void *)t, __cil_tmp);
#line 153
  return (__cil_tmp___0);
}
}
#line 177 "sds.c"
sds sdscatvprintf(sds s , char const   *fmt , va_list ap ) 
{ va_list cpy ;
  char *buf ;
  char *t ;
  size_t buflen ;
  void *__cil_tmp ;

  {
#line 180
  buflen = 16U;
#line 182
  while (1) {
#line 183
    __cil_tmp = malloc(buflen);
#line 183
    buf = (char *)__cil_tmp;
#line 185
    if ((unsigned int )buf == (unsigned int )((void *)0)) {
#line 185
      sdsOomAbort();
    }
#line 189
    *(buf + (buflen - 2U)) = (char )'\000';
#line 190
    __builtin_va_copy(cpy, ap);
#line 191
    vsnprintf(buf, buflen, fmt, cpy);
#line 192
    if ((int )*(buf + (buflen - 2U)) != 0) {
#line 193
      free((void *)buf);
#line 194
      buflen *= 2U;
#line 195
      continue;
    }
#line 197
    break;
  }
#line 199
  t = sdscat(s, buf);
#line 200
  free((void *)buf);
#line 201
  return (t);
}
}
#line 204 "sds.c"
sds sdscatprintf(sds s , char const   *fmt  , ...) 
{ va_list ap ;
  char *t ;

  {
#line 207
  __builtin_va_start(ap, fmt);
#line 208
  t = sdscatvprintf(s, fmt, ap);
#line 209
  __builtin_va_end(ap);
#line 210
  return (t);
}
}
#line 213 "sds.c"
sds sdstrim(sds s , char const   *cset___0 ) 
{ struct sdshdr *sh ;
  char *start ;
  char *end ;
  char *sp ;
  char *ep ;
  size_t len ;
  size_t __cil_tmp ;
  char *__cil_tmp___0 ;
  char *__cil_tmp___1 ;

  {
#line 214
  sh = (struct sdshdr *)((void *)(s - sizeof(struct sdshdr )));
#line 218
  start = s;
#line 218
  sp = start;
#line 219
  __cil_tmp = sdslen(s);
#line 219
  end = (s + __cil_tmp) - 1;
#line 219
  ep = end;
#line 220
  while (1) {
#line 220
    if ((unsigned int )sp <= (unsigned int )end) {
#line 220
      __cil_tmp___0 = strchr(cset___0, (int )*sp);
#line 220
      if (! __cil_tmp___0) {
#line 220
        break;
      }
    } else {
#line 220
      break;
    }
#line 220
    sp ++;
  }
#line 221
  while (1) {
#line 221
    if ((unsigned int )ep > (unsigned int )start) {
#line 221
      __cil_tmp___1 = strchr(cset___0, (int )*ep);
#line 221
      if (! __cil_tmp___1) {
#line 221
        break;
      }
    } else {
#line 221
      break;
    }
#line 221
    ep --;
  }
#line 222
  len = (unsigned int )((unsigned int )sp > (unsigned int )ep ? 0 : (ep - sp) + 1);
#line 223
  if ((unsigned int )(sh->buf) != (unsigned int )sp) {
#line 223
    memmove((void *)(sh->buf), (void const   *)sp, len);
  }
#line 224
  sh->buf[len] = (char )'\000';
#line 225
  sh->free = (int )((unsigned int )sh->free + ((unsigned int )sh->len - len));
#line 226
  sh->len = (int )len;
#line 227
  return (s);
}
}
#line 230 "sds.c"
sds sdsrange(sds s , int start , int end ) 
{ struct sdshdr *sh ;
  size_t newlen ;
  size_t len ;
  size_t __cil_tmp ;

  {
#line 231
  sh = (struct sdshdr *)((void *)(s - sizeof(struct sdshdr )));
#line 232
  __cil_tmp = sdslen(s);
#line 232
  len = __cil_tmp;
#line 234
  if (len == 0U) {
#line 234
    return (s);
  }
#line 235
  if (start < 0) {
#line 236
    start = (int )(len + (unsigned int )start);
#line 237
    if (start < 0) {
#line 237
      start = 0;
    }
  }
#line 239
  if (end < 0) {
#line 240
    end = (int )(len + (unsigned int )end);
#line 241
    if (end < 0) {
#line 241
      end = 0;
    }
  }
#line 243
  newlen = (unsigned int )(start > end ? 0 : (end - start) + 1);
#line 244
  if (newlen != 0U) {
#line 245
    if (start >= (int )len) {
#line 246
      newlen = 0U;
    } else
#line 247
    if (end >= (int )len) {
#line 248
      end = (int )(len - 1U);
#line 249
      newlen = (unsigned int )(start > end ? 0 : (end - start) + 1);
    }
  } else {
#line 252
    start = 0;
  }
#line 254
  if (start && newlen) {
#line 254
    memmove((void *)(sh->buf), (void const   *)(sh->buf + start), newlen);
  }
#line 255
  sh->buf[newlen] = (char)0;
#line 256
  sh->free = (int )((unsigned int )sh->free + ((unsigned int )sh->len - newlen));
#line 257
  sh->len = (int )newlen;
#line 258
  return (s);
}
}
#line 261 "sds.c"
void sdstolower(sds s ) 
{ int len ;
  size_t __cil_tmp ;
  int j ;
  char __x ;

  {
#line 262
  __cil_tmp = sdslen(s);
#line 262
  len = (int )__cil_tmp;
#line 264
  j = 0;
#line 264
  while (j < len) {
#line 264
    __x = *(s + j);
#line 264
    *(s + j) = (char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 1 ? ((int )__x - 65) + 97 : (int )__x);
#line 264
    j ++;
  }
#line 265
  return;
}
}
#line 273 "sds.c"
int sdscmp(sds s1___0 , sds s2___0 ) 
{ size_t l1 ;
  size_t l2 ;
  size_t minlen ;
  int cmp ;

  {
#line 277
  l1 = sdslen(s1___0);
#line 278
  l2 = sdslen(s2___0);
#line 279
  minlen = l1 < l2 ? l1 : l2;
#line 280
  cmp = memcmp((void const   *)s1___0, (void const   *)s2___0, minlen);
#line 281
  if (cmp == 0) {
#line 281
    return ((int )(l1 - l2));
  }
#line 282
  return (cmp);
}
}
#line 301 "sds.c"
sds *sdssplitlen(char *s , int len , char *sep , int seplen , int *count ) 
{ int elements ;
  int slots ;
  int start ;
  int j ;
  sds *tokens ;
  void *__cil_tmp ;
  sds *newtokens ;
  void *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 302
  elements = 0;
#line 302
  slots = 5;
#line 302
  start = 0;
#line 304
  __cil_tmp = malloc((unsigned int )(sizeof(sds ) * (unsigned long )slots));
#line 304
  tokens = (sds *)__cil_tmp;
#line 306
  if ((unsigned int )tokens == (unsigned int )((void *)0)) {
#line 306
    sdsOomAbort();
  }
#line 308
  if ((seplen < 1 || len < 0) || (unsigned int )tokens == (unsigned int )((void *)0)) {
#line 308
    return ((sds *)((void *)0));
  }
#line 309
  if (len == 0) {
#line 310
    *count = 0;
#line 311
    return (tokens);
  }
#line 313
  j = 0;
#line 313
  while (j < len - (seplen - 1)) {
#line 315
    if (slots < elements + 2) {
#line 318
      slots *= 2;
#line 319
      __cil_tmp___0 = realloc((void *)tokens, (unsigned int )(sizeof(sds ) * (unsigned long )slots));
#line 319
      newtokens = (sds *)__cil_tmp___0;
#line 320
      if ((unsigned int )newtokens == (unsigned int )((void *)0)) {
#line 322
        sdsOomAbort();
      }
#line 327
      tokens = newtokens;
    }
#line 330
    if (seplen == 1 && (int )*(s + j) == (int )*(sep + 0)) {
#line 330
      goto _L;
    } else {
#line 330
      __cil_tmp___1 = memcmp((void const   *)(s + j), (void const   *)sep, (unsigned int )seplen);
#line 330
      if (__cil_tmp___1 == 0) {
        _L: 
#line 331
        *(tokens + elements) = sdsnewlen((void const   *)(s + start), (unsigned int )(j - start));
#line 332
        if ((unsigned int )*(tokens + elements) == (unsigned int )((void *)0)) {
#line 334
          sdsOomAbort();
        }
#line 339
        elements ++;
#line 340
        start = j + seplen;
#line 341
        j = (j + seplen) - 1;
      }
    }
#line 313
    j ++;
  }
#line 345
  *(tokens + elements) = sdsnewlen((void const   *)(s + start), (unsigned int )(len - start));
#line 346
  if ((unsigned int )*(tokens + elements) == (unsigned int )((void *)0)) {
#line 348
    sdsOomAbort();
  }
#line 353
  elements ++;
#line 354
  *count = elements;
#line 355
  return (tokens);
}
}
#line 368 "sds.c"
void sdsfreesplitres(sds *tokens , int count ) 
{ int __cil_tmp ;

  {
#line 369
  if (! tokens) {
#line 369
    return;
  }
#line 370
  while (1) {
#line 370
    __cil_tmp = count;
#line 370
    count --;
#line 370
    if (! __cil_tmp) {
#line 370
      break;
    }
#line 371
    sdsfree(*(tokens + count));
  }
#line 372
  free((void *)tokens);
#line 373
  return;
}
}
#line 375 "sds.c"
sds sdsfromlonglong(long long value ) 
{ char buf[32] ;
  char *p ;
  unsigned long long v ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;
  sds __cil_tmp___1 ;

  {
#line 379
  v = (unsigned long long )(value < 0LL ? - value : value);
#line 380
  p = buf + 31;
#line 381
  while (1) {
#line 382
    __cil_tmp = p;
#line 382
    p --;
#line 382
    *__cil_tmp = (char )(48ULL + v % 10ULL);
#line 383
    v /= 10ULL;
#line 381
    if (! v) {
#line 381
      break;
    }
  }
#line 385
  if (value < 0LL) {
#line 385
    __cil_tmp___0 = p;
#line 385
    p --;
#line 385
    *__cil_tmp___0 = (char )'-';
  }
#line 386
  p ++;
#line 387
  __cil_tmp___1 = sdsnewlen((void const   *)p, (unsigned int )(32 - (p - buf)));
#line 387
  return (__cil_tmp___1);
}
}
#line 390 "sds.c"
sds sdscatrepr(sds s , char *p , size_t len ) 
{ size_t __cil_tmp ;
  sds __cil_tmp___0 ;

  {
#line 391
  s = sdscatlen(s, (void *)"\"", 1U);
#line 392
  while (1) {
#line 392
    __cil_tmp = len;
#line 392
    len --;
#line 392
    if (! __cil_tmp) {
#line 392
      break;
    }
#line 393
    switch ((int )*p) {
    case 92: 
    case 34: 
#line 396
    s = sdscatprintf(s, "\\%c", (int )*p);
#line 397
    break;
    case 10: 
#line 398
    s = sdscatlen(s, (void *)"\\n", 1U);
#line 398
    break;
    case 13: 
#line 399
    s = sdscatlen(s, (void *)"\\r", 1U);
#line 399
    break;
    case 9: 
#line 400
    s = sdscatlen(s, (void *)"\\t", 1U);
#line 400
    break;
    case 7: 
#line 401
    s = sdscatlen(s, (void *)"\\a", 1U);
#line 401
    break;
    case 8: 
#line 402
    s = sdscatlen(s, (void *)"\\b", 1U);
#line 402
    break;
    default: 
#line 404
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )*p))) + (int )*p) & 151) {
#line 405
      s = sdscatprintf(s, "%c", (int )*p);
    } else {
#line 407
      s = sdscatprintf(s, "\\x%02x", (int )((unsigned char )*p));
    }
#line 408
    break;
    }
#line 410
    p ++;
  }
#line 412
  __cil_tmp___0 = sdscatlen(s, (void *)"\"", 1U);
#line 412
  return (__cil_tmp___0);
}
}
#line 427 "sds.c"
sds *sdssplitargs(char *line , int *argc ) 
{ char *p ;
  char *current ;
  char **vector ;
  int inq ;
  int done ;
  char c ;
  void *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 428
  p = line;
#line 429
  current = (char *)((void *)0);
#line 430
  vector = (char **)((void *)0);
#line 432
  *argc = 0;
#line 433
  while (1) {
#line 435
    while (*p && (int const   )*((__ctype_ptr__ + sizeof(*("" + (int )*p))) + (int )*p) & 8) {
#line 435
      p ++;
    }
#line 436
    if (*p) {
#line 438
      inq = 0;
#line 439
      done = 0;
#line 441
      if ((unsigned int )current == (unsigned int )((void *)0)) {
#line 441
        current = sdsempty();
      }
#line 442
      while (! done) {
#line 443
        if (inq) {
#line 444
          if ((int )*p == 92 && *(p + 1)) {
#line 447
            p ++;
#line 448
            switch ((int )*p) {
            case 110: 
#line 449
            c = (char )'\n';
#line 449
            break;
            case 114: 
#line 450
            c = (char )'\r';
#line 450
            break;
            case 116: 
#line 451
            c = (char )'\t';
#line 451
            break;
            case 98: 
#line 452
            c = (char )'\b';
#line 452
            break;
            case 97: 
#line 453
            c = (char )'\a';
#line 453
            break;
            default: 
#line 454
            c = *p;
#line 454
            break;
            }
#line 456
            current = sdscatlen(current, (void *)(& c), 1U);
          } else
#line 457
          if ((int )*p == 34) {
#line 459
            if (*(p + 1) && ! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )*(p + 1)))) + (int )*(p + 1)) & 8)) {
#line 459
              goto err;
            }
#line 460
            done = 1;
          } else
#line 461
          if (! *p) {
#line 463
            goto err;
          } else {
#line 465
            current = sdscatlen(current, (void *)p, 1U);
          }
        } else {
#line 468
          switch ((int )*p) {
          case 32: 
          case 10: 
          case 13: 
          case 9: 
          case 0: 
#line 474
          done = 1;
#line 475
          break;
          case 34: 
#line 477
          inq = 1;
#line 478
          break;
          default: 
#line 480
          current = sdscatlen(current, (void *)p, 1U);
#line 481
          break;
          }
        }
#line 484
        if (*p) {
#line 484
          p ++;
        }
      }
#line 487
      __cil_tmp = realloc((void *)vector, (unsigned int )((unsigned long )(*argc + 1) * sizeof(char *)));
#line 487
      vector = (char **)__cil_tmp;
#line 488
      *(vector + *argc) = current;
#line 489
      (*argc) ++;
#line 490
      current = (char *)((void *)0);
    } else {
#line 492
      return (vector);
    }
  }
  err: 
#line 497
  while (1) {
#line 497
    __cil_tmp___0 = *argc;
#line 497
    (*argc) --;
#line 497
    if (! __cil_tmp___0) {
#line 497
      break;
    }
#line 498
    sdsfree(*(vector + *argc));
  }
#line 499
  free((void *)vector);
#line 500
  if (current) {
#line 500
    sdsfree(current);
  }
#line 501
  return ((sds *)((void *)0));
}
}
#line 1 "zmalloc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IA2htUbt.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 76 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/pthread.h"
extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 78
extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 42 "zmalloc.h"
void zmalloc_enable_thread_safeness(void) ;
#line 83 "zmalloc.c"
static size_t used_memory  =    0U;
#line 84 "zmalloc.c"
static int zmalloc_thread_safe  =    0;
#line 85 "zmalloc.c"
pthread_mutex_t used_memory_mutex  =    4294967295U;
#line 87 "zmalloc.c"
size_t zmalloc_allocations[257]  ;
#line 183 "zmalloc.c"
size_t zmalloc_used_memory(void) 
{ size_t um ;

  {
#line 186
  if (zmalloc_thread_safe) {
#line 186
    pthread_mutex_lock(& used_memory_mutex);
  }
#line 187
  um = used_memory;
#line 188
  if (zmalloc_thread_safe) {
#line 188
    pthread_mutex_unlock(& used_memory_mutex);
  }
#line 189
  return (um);
}
}
#line 192 "zmalloc.c"
size_t zmalloc_allocations_for_size(size_t size ) 
{ 

  {
#line 193
  if (size > 256U) {
#line 193
    return (0U);
  }
#line 194
  return (zmalloc_allocations[size]);
}
}
#line 197 "zmalloc.c"
void zmalloc_enable_thread_safeness(void) 
{ 

  {
#line 198
  zmalloc_thread_safe = 1;
#line 199
  return;
}
}
#line 269 "zmalloc.c"
size_t zmalloc_get_rss(void) 
{ size_t __cil_tmp ;

  {
#line 275
  __cil_tmp = zmalloc_used_memory();
#line 275
  return (__cil_tmp);
}
}
#line 280 "zmalloc.c"
float zmalloc_get_fragmentation_ratio(void) 
{ size_t __cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 281
  __cil_tmp = zmalloc_get_rss();
#line 281
  __cil_tmp___0 = zmalloc_used_memory();
#line 281
  return ((float )__cil_tmp / (float )__cil_tmp___0);
}
}
#line 1 "lzf_c.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-s1o4ighe.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 98 "lzf_c.c"
unsigned int lzf_compress(void const   *in_data , unsigned int in_len , void *out_data ,
                          unsigned int out_len ) 
{ LZF_STATE htab___0 ;
  u8 const   **hslot ;
  u8 const   *ip ;
  u8 *op ;
  u8 const   *in_end ;
  u8 *out_end ;
  u8 const   *ref ;
  unsigned long off ;
  unsigned int hval ;
  int lit ;
  unsigned int len ;
  unsigned int maxlen ;
  u8 *__cil_tmp ;
  u8 *__cil_tmp___0 ;
  u8 *__cil_tmp___1 ;
  u8 *__cil_tmp___2 ;
  u8 *__cil_tmp___3 ;
  u8 const   *__cil_tmp___4 ;
  u8 *__cil_tmp___5 ;
  u8 const   *__cil_tmp___6 ;

  {
#line 110
  ip = (u8 const   *)in_data;
#line 111
  op = (u8 *)out_data;
#line 112
  in_end = ip + in_len;
#line 113
  out_end = op + out_len;
#line 131
  if (! in_len || ! out_len) {
#line 132
    return (0U);
  }
#line 142
  lit = 0;
#line 142
  op ++;
#line 144
  hval = (unsigned int )(((int const   )*(ip + 0) << 8) | (int const   )*(ip + 1));
#line 145
  while ((unsigned int )ip < (unsigned int )(in_end - 2)) {
#line 147
    hval = (hval << 8) | (unsigned int )*(ip + 2);
#line 148
    hslot = htab___0 + (((hval >> 8) - hval * 5U) & (unsigned int )((1 << 16) - 1));
#line 149
    ref = *hslot;
#line 149
    *hslot = ip;
#line 151
    off = (unsigned long )((ip - ref) - 1);
#line 151
    if (((((off < (unsigned long )(1 << 13) && (unsigned int )(ip + 4) < (unsigned int )in_end) && (unsigned int )ref > (unsigned int )((u8 *)in_data)) && (int const   )*(ref + 0) == (int const   )*(ip + 0)) && (int const   )*(ref + 1) == (int const   )*(ip + 1)) && (int const   )*(ref + 2) == (int const   )*(ip + 2)) {
#line 169
      len = 2U;
#line 170
      maxlen = (unsigned int )(in_end - ip) - len;
#line 171
      maxlen = maxlen > (unsigned int )((1 << 8) + (1 << 3)) ? (unsigned int )((1 << 8) + (1 << 3)) : maxlen;
#line 173
      *(op + (- lit - 1)) = (unsigned char )(lit - 1);
#line 174
      op -= ! lit;
#line 176
      if (((unsigned int )((op + 3) + 1) >= (unsigned int )out_end) != 0) {
#line 177
        return (0U);
      }
#line 179
      while (1) {
#line 181
        if ((maxlen > 16U) != 0) {
#line 183
          len ++;
#line 183
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 183
            break;
          }
#line 184
          len ++;
#line 184
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 184
            break;
          }
#line 185
          len ++;
#line 185
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 185
            break;
          }
#line 186
          len ++;
#line 186
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 186
            break;
          }
#line 188
          len ++;
#line 188
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 188
            break;
          }
#line 189
          len ++;
#line 189
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 189
            break;
          }
#line 190
          len ++;
#line 190
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 190
            break;
          }
#line 191
          len ++;
#line 191
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 191
            break;
          }
#line 193
          len ++;
#line 193
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 193
            break;
          }
#line 194
          len ++;
#line 194
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 194
            break;
          }
#line 195
          len ++;
#line 195
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 195
            break;
          }
#line 196
          len ++;
#line 196
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 196
            break;
          }
#line 198
          len ++;
#line 198
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 198
            break;
          }
#line 199
          len ++;
#line 199
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 199
            break;
          }
#line 200
          len ++;
#line 200
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 200
            break;
          }
#line 201
          len ++;
#line 201
          if ((int const   )*(ref + len) != (int const   )*(ip + len)) {
#line 201
            break;
          }
        }
#line 204
        while (1) {
#line 205
          len ++;
#line 204
          if (! (len < maxlen && (int const   )*(ref + len) == (int const   )*(ip + len))) {
#line 204
            break;
          }
        }
#line 208
        break;
      }
#line 211
      len -= 2U;
#line 212
      ip ++;
#line 214
      if (len < 7U) {
#line 216
        __cil_tmp = op;
#line 216
        op ++;
#line 216
        *__cil_tmp = (unsigned char )((off >> 8) + (unsigned long )(len << 5));
      } else {
#line 220
        __cil_tmp___0 = op;
#line 220
        op ++;
#line 220
        *__cil_tmp___0 = (unsigned char )((off >> 8) + (unsigned long )(7 << 5));
#line 221
        __cil_tmp___1 = op;
#line 221
        op ++;
#line 221
        *__cil_tmp___1 = (unsigned char )(len - 7U);
      }
#line 224
      __cil_tmp___2 = op;
#line 224
      op ++;
#line 224
      *__cil_tmp___2 = (unsigned char )off;
#line 225
      lit = 0;
#line 225
      op ++;
#line 227
      ip += len + 1U;
#line 229
      if (((unsigned int )ip >= (unsigned int )(in_end - 2)) != 0) {
#line 230
        break;
      }
#line 233
      ip --;
#line 235
      ip --;
#line 237
      hval = (unsigned int )(((int const   )*(ip + 0) << 8) | (int const   )*(ip + 1));
#line 239
      hval = (hval << 8) | (unsigned int )*(ip + 2);
#line 240
      htab___0[((hval >> 8) - hval * 5U) & (unsigned int )((1 << 16) - 1)] = ip;
#line 241
      ip ++;
#line 244
      hval = (hval << 8) | (unsigned int )*(ip + 2);
#line 245
      htab___0[((hval >> 8) - hval * 5U) & (unsigned int )((1 << 16) - 1)] = ip;
#line 246
      ip ++;
    } else {
#line 263
      if (((unsigned int )op >= (unsigned int )out_end) != 0) {
#line 264
        return (0U);
      }
#line 266
      lit ++;
#line 266
      __cil_tmp___3 = op;
#line 266
      op ++;
#line 266
      __cil_tmp___4 = ip;
#line 266
      ip ++;
#line 266
      *__cil_tmp___3 = (unsigned char )*__cil_tmp___4;
#line 268
      if ((lit == 1 << 5) != 0) {
#line 270
        *(op + (- lit - 1)) = (unsigned char )(lit - 1);
#line 271
        lit = 0;
#line 271
        op ++;
      }
    }
  }
#line 276
  if ((unsigned int )(op + 3) > (unsigned int )out_end) {
#line 277
    return (0U);
  }
#line 279
  while ((unsigned int )ip < (unsigned int )in_end) {
#line 281
    lit ++;
#line 281
    __cil_tmp___5 = op;
#line 281
    op ++;
#line 281
    __cil_tmp___6 = ip;
#line 281
    ip ++;
#line 281
    *__cil_tmp___5 = (unsigned char )*__cil_tmp___6;
#line 283
    if ((lit == 1 << 5) != 0) {
#line 285
      *(op + (- lit - 1)) = (unsigned char )(lit - 1);
#line 286
      lit = 0;
#line 286
      op ++;
    }
  }
#line 290
  *(op + (- lit - 1)) = (unsigned char )(lit - 1);
#line 291
  op -= ! lit;
#line 293
  return ((unsigned int )(op - (u8 *)out_data));
}
}
#line 1 "lzf_d.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-b7NuXDf1.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 55 "lzf_d.c"
unsigned int lzf_decompress(void const   *in_data , unsigned int in_len , void *out_data ,
                            unsigned int out_len ) 
{ u8 const   *ip ;
  u8 *op ;
  u8 const   *in_end ;
  u8 *out_end ;
  unsigned int ctrl ;
  u8 const   *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  u8 *__cil_tmp___2 ;
  u8 const   *__cil_tmp___3 ;
  unsigned int len ;
  u8 *ref ;
  int *__cil_tmp___4 ;
  u8 const   *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  u8 const   *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  u8 *__cil_tmp___10 ;
  u8 *__cil_tmp___11 ;
  u8 *__cil_tmp___12 ;
  u8 *__cil_tmp___13 ;
  u8 *__cil_tmp___14 ;
  u8 *__cil_tmp___15 ;

  {
#line 59
  ip = (u8 const   *)in_data;
#line 60
  op = (u8 *)out_data;
#line 61
  in_end = ip + in_len;
#line 62
  out_end = op + out_len;
#line 64
  while (1) {
#line 66
    __cil_tmp = ip;
#line 66
    ip ++;
#line 66
    ctrl = (unsigned int )*__cil_tmp;
#line 68
    if (ctrl < (unsigned int )(1 << 5)) {
#line 70
      ctrl ++;
#line 72
      if ((unsigned int )(op + ctrl) > (unsigned int )out_end) {
#line 74
        __cil_tmp___0 = __errno();
#line 74
        *__cil_tmp___0 = 7;
#line 75
        return (0U);
      }
#line 79
      if ((unsigned int )(ip + ctrl) > (unsigned int )in_end) {
#line 81
        __cil_tmp___1 = __errno();
#line 81
        *__cil_tmp___1 = 22;
#line 82
        return (0U);
      }
#line 89
      while (1) {
#line 90
        __cil_tmp___2 = op;
#line 90
        op ++;
#line 90
        __cil_tmp___3 = ip;
#line 90
        ip ++;
#line 90
        *__cil_tmp___2 = (unsigned char )*__cil_tmp___3;
#line 89
        ctrl --;
#line 89
        if (! ctrl) {
#line 89
          break;
        }
      }
    } else {
#line 96
      len = ctrl >> 5;
#line 98
      ref = (op - ((ctrl & 31U) << 8)) - 1;
#line 101
      if ((unsigned int )ip >= (unsigned int )in_end) {
#line 103
        __cil_tmp___4 = __errno();
#line 103
        *__cil_tmp___4 = 22;
#line 104
        return (0U);
      }
#line 107
      if (len == 7U) {
#line 109
        __cil_tmp___5 = ip;
#line 109
        ip ++;
#line 109
        len += (unsigned int )*__cil_tmp___5;
#line 111
        if ((unsigned int )ip >= (unsigned int )in_end) {
#line 113
          __cil_tmp___6 = __errno();
#line 113
          *__cil_tmp___6 = 22;
#line 114
          return (0U);
        }
      }
#line 119
      __cil_tmp___7 = ip;
#line 119
      ip ++;
#line 119
      ref -= (int const   )*__cil_tmp___7;
#line 121
      if ((unsigned int )((op + len) + 2) > (unsigned int )out_end) {
#line 123
        __cil_tmp___8 = __errno();
#line 123
        *__cil_tmp___8 = 7;
#line 124
        return (0U);
      }
#line 127
      if ((unsigned int )ref < (unsigned int )((u8 *)out_data)) {
#line 129
        __cil_tmp___9 = __errno();
#line 129
        *__cil_tmp___9 = 22;
#line 130
        return (0U);
      }
#line 137
      __cil_tmp___10 = op;
#line 137
      op ++;
#line 137
      __cil_tmp___11 = ref;
#line 137
      ref ++;
#line 137
      *__cil_tmp___10 = *__cil_tmp___11;
#line 138
      __cil_tmp___12 = op;
#line 138
      op ++;
#line 138
      __cil_tmp___13 = ref;
#line 138
      ref ++;
#line 138
      *__cil_tmp___12 = *__cil_tmp___13;
#line 140
      while (1) {
#line 141
        __cil_tmp___14 = op;
#line 141
        op ++;
#line 141
        __cil_tmp___15 = ref;
#line 141
        ref ++;
#line 141
        *__cil_tmp___14 = *__cil_tmp___15;
#line 140
        len --;
#line 140
        if (! len) {
#line 140
          break;
        }
      }
    }
#line 64
    if (! ((unsigned int )ip < (unsigned int )in_end)) {
#line 64
      break;
    }
  }
#line 148
  return ((unsigned int )(op - (u8 *)out_data));
}
}
#line 1 "pqsort.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-n5ONlRTu.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 46 "pqsort.c"
__inline static char *med3(char *a , char *b , char *c , int (*cmp)(void const   * ,
                                                                    void const   * ) ) ;
#line 48
__inline static void swapfunc(char *a , char *b , size_t n , int swaptype ) ;
#line 69 "pqsort.c"
__inline static void swapfunc(char *a , char *b , size_t n , int swaptype ) 
{ size_t i ;
  long *pi ;
  long *pj ;
  long t ;
  long *__cil_tmp ;
  long *__cil_tmp___0 ;
  size_t i___0 ;
  char *pi___0 ;
  char *pj___0 ;
  char t___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;

  {
#line 73
  if (swaptype <= 1) {
#line 74
    i = (unsigned int )((unsigned long )n / sizeof(long ));
#line 74
    pi = (long *)((void *)a);
#line 74
    pj = (long *)((void *)b);
#line 74
    while (1) {
#line 74
      t = *pi;
#line 74
      __cil_tmp = pi;
#line 74
      pi ++;
#line 74
      *__cil_tmp = *pj;
#line 74
      __cil_tmp___0 = pj;
#line 74
      pj ++;
#line 74
      *__cil_tmp___0 = t;
#line 74
      i --;
#line 74
      if (! (i > 0U)) {
#line 74
        break;
      }
    }
  } else {
#line 76
    i___0 = (unsigned int )((unsigned long )n / sizeof(char ));
#line 76
    pi___0 = (char *)((void *)a);
#line 76
    pj___0 = (char *)((void *)b);
#line 76
    while (1) {
#line 76
      t___0 = *pi___0;
#line 76
      __cil_tmp___1 = pi___0;
#line 76
      pi___0 ++;
#line 76
      *__cil_tmp___1 = *pj___0;
#line 76
      __cil_tmp___2 = pj___0;
#line 76
      pj___0 ++;
#line 76
      *__cil_tmp___2 = t___0;
#line 76
      i___0 --;
#line 76
      if (! (i___0 > 0U)) {
#line 76
        break;
      }
    }
  }
#line 77
  return;
}
}
#line 89 "pqsort.c"
__inline static char *med3(char *a , char *b , char *c , int (*cmp)(void const   * ,
                                                                    void const   * ) ) 
{ int __cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___5 ;
  char *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  char *__cil_tmp___8 ;
  int __cil_tmp___9 ;

  {
#line 94
  __cil_tmp___9 = (*cmp)((void const   *)a, (void const   *)b);
#line 94
  if (__cil_tmp___9 < 0) {
#line 94
    __cil_tmp___3 = (*cmp)((void const   *)b, (void const   *)c);
#line 94
    if (__cil_tmp___3 < 0) {
#line 94
      __cil_tmp___2 = b;
    } else {
#line 94
      __cil_tmp___1 = (*cmp)((void const   *)a, (void const   *)c);
#line 94
      __cil_tmp___2 = __cil_tmp___1 < 0 ? c : a;
    }
#line 94
    __cil_tmp___8 = __cil_tmp___2;
  } else {
#line 94
    __cil_tmp___7 = (*cmp)((void const   *)b, (void const   *)c);
#line 94
    if (__cil_tmp___7 > 0) {
#line 94
      __cil_tmp___6 = b;
    } else {
#line 94
      __cil_tmp___5 = (*cmp)((void const   *)a, (void const   *)c);
#line 94
      __cil_tmp___6 = __cil_tmp___5 < 0 ? a : c;
    }
#line 94
    __cil_tmp___8 = __cil_tmp___6;
  }
#line 94
  return (__cil_tmp___8);
}
}
#line 99 "pqsort.c"
static void _pqsort(void *a , size_t n , size_t es , int (*cmp)(void const   * , void const   * ) ,
                    void *lrange , void *rrange ) 
{ char *pa ;
  char *pb ;
  char *pc ;
  char *pd ;
  char *pl ;
  char *pm ;
  char *pn ;
  size_t d ;
  size_t r ;
  int swaptype ;
  int swap_cnt ;
  int cmp_result ;
  long t ;
  int __cil_tmp ;
  long t___0 ;
  long t___1 ;
  long t___2 ;
  long t___3 ;
  long t___4 ;
  int __cil_tmp___0 ;
  void *_l ;
  void *_r ;
  void *_l___0 ;
  void *_r___0 ;

  {
  loop: 
#line 107
  swaptype = (unsigned long )((char *)a - (char *)0) % sizeof(long ) || (unsigned long )es % sizeof(long ) ? 2 : ((unsigned long )es == sizeof(long ) ? 0 : 1);
#line 108
  swap_cnt = 0;
#line 109
  if (n < 7U) {
#line 110
    pm = (char *)a + es;
#line 110
    while ((unsigned int )pm < (unsigned int )((char *)a + n * es)) {
#line 111
      pl = pm;
#line 111
      while (1) {
#line 111
        if ((unsigned int )pl > (unsigned int )((char *)a)) {
#line 111
          __cil_tmp = (*cmp)((void const   *)(pl - es), (void const   *)pl);
#line 111
          if (! (__cil_tmp > 0)) {
#line 111
            break;
          }
        } else {
#line 111
          break;
        }
#line 113
        if (swaptype == 0) {
#line 113
          t = *((long *)((void *)pl));
#line 113
          *((long *)((void *)pl)) = *((long *)((void *)(pl - es)));
#line 113
          *((long *)((void *)(pl - es))) = t;
        } else {
#line 113
          swapfunc(pl, pl - es, es, swaptype);
        }
#line 111
        pl -= es;
      }
#line 110
      pm += es;
    }
#line 114
    return;
  }
#line 116
  pm = (char *)a + (n / 2U) * es;
#line 117
  if (n > 7U) {
#line 118
    pl = (char *)a;
#line 119
    pn = (char *)a + (n - 1U) * es;
#line 120
    if (n > 40U) {
#line 121
      d = (n / 8U) * es;
#line 122
      pl = med3(pl, pl + d, pl + 2U * d, cmp);
#line 123
      pm = med3(pm - d, pm, pm + d, cmp);
#line 124
      pn = med3(pn - 2U * d, pn - d, pn, cmp);
    }
#line 126
    pm = med3(pl, pm, pn, cmp);
  }
#line 128
  if (swaptype == 0) {
#line 128
    t___0 = *((long *)a);
#line 128
    *((long *)a) = *((long *)((void *)pm));
#line 128
    *((long *)((void *)pm)) = t___0;
  } else {
#line 128
    swapfunc((char *)a, pm, es, swaptype);
  }
#line 129
  pb = (char *)a + es;
#line 129
  pa = pb;
#line 131
  pd = (char *)a + (n - 1U) * es;
#line 131
  pc = pd;
#line 132
  while (1) {
#line 133
    while (1) {
#line 133
      if ((unsigned int )pb <= (unsigned int )pc) {
#line 133
        cmp_result = (*cmp)((void const   *)pb, (void const   *)a);
#line 133
        if (! (cmp_result <= 0)) {
#line 133
          break;
        }
      } else {
#line 133
        break;
      }
#line 134
      if (cmp_result == 0) {
#line 135
        swap_cnt = 1;
#line 136
        if (swaptype == 0) {
#line 136
          t___1 = *((long *)((void *)pa));
#line 136
          *((long *)((void *)pa)) = *((long *)((void *)pb));
#line 136
          *((long *)((void *)pb)) = t___1;
        } else {
#line 136
          swapfunc(pa, pb, es, swaptype);
        }
#line 137
        pa += es;
      }
#line 139
      pb += es;
    }
#line 141
    while (1) {
#line 141
      if ((unsigned int )pb <= (unsigned int )pc) {
#line 141
        cmp_result = (*cmp)((void const   *)pc, (void const   *)a);
#line 141
        if (! (cmp_result >= 0)) {
#line 141
          break;
        }
      } else {
#line 141
        break;
      }
#line 142
      if (cmp_result == 0) {
#line 143
        swap_cnt = 1;
#line 144
        if (swaptype == 0) {
#line 144
          t___2 = *((long *)((void *)pc));
#line 144
          *((long *)((void *)pc)) = *((long *)((void *)pd));
#line 144
          *((long *)((void *)pd)) = t___2;
        } else {
#line 144
          swapfunc(pc, pd, es, swaptype);
        }
#line 145
        pd -= es;
      }
#line 147
      pc -= es;
    }
#line 149
    if ((unsigned int )pb > (unsigned int )pc) {
#line 150
      break;
    }
#line 151
    if (swaptype == 0) {
#line 151
      t___3 = *((long *)((void *)pb));
#line 151
      *((long *)((void *)pb)) = *((long *)((void *)pc));
#line 151
      *((long *)((void *)pc)) = t___3;
    } else {
#line 151
      swapfunc(pb, pc, es, swaptype);
    }
#line 152
    swap_cnt = 1;
#line 153
    pb += es;
#line 154
    pc -= es;
  }
#line 156
  if (swap_cnt == 0) {
#line 157
    pm = (char *)a + es;
#line 157
    while ((unsigned int )pm < (unsigned int )((char *)a + n * es)) {
#line 158
      pl = pm;
#line 158
      while (1) {
#line 158
        if ((unsigned int )pl > (unsigned int )((char *)a)) {
#line 158
          __cil_tmp___0 = (*cmp)((void const   *)(pl - es), (void const   *)pl);
#line 158
          if (! (__cil_tmp___0 > 0)) {
#line 158
            break;
          }
        } else {
#line 158
          break;
        }
#line 160
        if (swaptype == 0) {
#line 160
          t___4 = *((long *)((void *)pl));
#line 160
          *((long *)((void *)pl)) = *((long *)((void *)(pl - es)));
#line 160
          *((long *)((void *)(pl - es))) = t___4;
        } else {
#line 160
          swapfunc(pl, pl - es, es, swaptype);
        }
#line 158
        pl -= es;
      }
#line 157
      pm += es;
    }
#line 161
    return;
  }
#line 164
  pn = (char *)a + n * es;
#line 165
  r = (unsigned int )(pa - (char *)a < pb - pa ? pa - (char *)a : pb - pa);
#line 166
  if (r > 0U) {
#line 166
    swapfunc((char *)a, pb - r, r, swaptype);
  }
#line 167
  r = (unsigned int )(pd - pc) < (unsigned int )(pn - pd) - es ? (unsigned int )(pd - pc) : (unsigned int )(pn - pd) - es;
#line 168
  if (r > 0U) {
#line 168
    swapfunc(pb, pn - r, r, swaptype);
  }
#line 169
  r = (unsigned int )(pb - pa);
#line 169
  if (r > es) {
#line 170
    _l = a;
#line 170
    _r = (void *)(((unsigned char *)a + r) - 1);
#line 171
    if (! (((unsigned int )lrange < (unsigned int )_l && (unsigned int )rrange < (unsigned int )_l) || ((unsigned int )lrange > (unsigned int )_r && (unsigned int )rrange > (unsigned int )_r))) {
#line 173
      _pqsort(a, r / es, es, cmp, lrange, rrange);
    }
  }
#line 175
  r = (unsigned int )(pd - pc);
#line 175
  if (r > es) {
#line 179
    a = (void *)(pn - r);
#line 180
    n = r / es;
#line 182
    _l___0 = a;
#line 183
    _r___0 = (void *)(((unsigned char *)a + r) - 1);
#line 184
    if (! (((unsigned int )lrange < (unsigned int )_l___0 && (unsigned int )rrange < (unsigned int )_l___0) || ((unsigned int )lrange > (unsigned int )_r___0 && (unsigned int )rrange > (unsigned int )_r___0))) {
#line 186
      goto loop;
    }
  }
#line 189
  return;
}
}
#line 191 "pqsort.c"
void pqsort(void *a , size_t n , size_t es , int (*cmp)(void const   * , void const   * ) ,
            size_t lrange , size_t rrange ) 
{ 

  {
#line 195
  _pqsort(a, n, es, cmp, (void *)((unsigned char *)a + lrange * es), (void *)(((unsigned char *)a + (rrange + 1U) * es) - 1));
#line 197
  return;
}
}
#line 1 "zipmap.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-v1Shv8hD.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 206 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
size_t fwrite(void const   *buf , size_t size , size_t count , FILE *fp ) ;
#line 97 "zipmap.c"
unsigned char *zipmapNew(void) 
{ unsigned char *zm ;
  int __cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 98
  __cil_tmp___0 = malloc(2U);
#line 98
  __cil_tmp = (int )__cil_tmp___0;
#line 98
  zm = (unsigned char *)__cil_tmp;
#line 100
  *(zm + 0) = (unsigned char)0;
#line 101
  *(zm + 1) = (unsigned char)255;
#line 102
  return (zm);
}
}
#line 106 "zipmap.c"
static unsigned int zipmapDecodeLength(unsigned char *p ) 
{ unsigned int len ;

  {
#line 107
  len = (unsigned int )*p;
#line 109
  if (len < 254U) {
#line 109
    return (len);
  }
#line 110
  memcpy((void *)(& len), (void const   *)(p + 1), (unsigned int )sizeof(unsigned int ));
#line 111
  return (len);
}
}
#line 116 "zipmap.c"
static unsigned int zipmapEncodeLength(unsigned char *p , unsigned int len ) 
{ 

  {
#line 117
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 118
    return ((unsigned int )(len < 254U ? 1UL : sizeof(unsigned int ) + 1UL));
  } else
#line 120
  if (len < 254U) {
#line 121
    *(p + 0) = (unsigned char )len;
#line 122
    return (1U);
  } else {
#line 124
    *(p + 0) = (unsigned char)254;
#line 125
    memcpy((void *)(p + 1), (void const   *)(& len), (unsigned int )sizeof(len));
#line 126
    return ((unsigned int )(1UL + sizeof(len)));
  }
}
}
#line 137 "zipmap.c"
static unsigned char *zipmapLookupRaw(unsigned char *zm , unsigned char *key , unsigned int klen ,
                                      unsigned int *totlen ) 
{ unsigned char *p ;
  unsigned char *k ;
  unsigned int l ;
  unsigned int llen ;
  unsigned char free___0 ;
  int __cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 138
  p = zm + 1;
#line 138
  k = (unsigned char *)((void *)0);
#line 141
  while ((int )*p != 255) {
#line 145
    l = zipmapDecodeLength(p);
#line 146
    llen = zipmapEncodeLength((unsigned char *)((void *)0), l);
#line 147
    if ((unsigned int )k == (unsigned int )((void *)0) && l == klen) {
#line 147
      __cil_tmp = memcmp((void const   *)(p + llen), (void const   *)key, l);
#line 147
      if (! __cil_tmp) {
#line 150
        if ((unsigned int )totlen != (unsigned int )((void *)0)) {
#line 151
          k = p;
        } else {
#line 153
          return (p);
        }
      }
    }
#line 156
    p += llen + l;
#line 158
    l = zipmapDecodeLength(p);
#line 159
    __cil_tmp___0 = zipmapEncodeLength((unsigned char *)((void *)0), l);
#line 159
    p += __cil_tmp___0;
#line 160
    free___0 = *(p + 0);
#line 161
    p += (l + 1U) + (unsigned int )free___0;
  }
#line 163
  if ((unsigned int )totlen != (unsigned int )((void *)0)) {
#line 163
    *totlen = (unsigned int )(p - zm) + 1U;
  }
#line 164
  return (k);
}
}
#line 167 "zipmap.c"
static unsigned long zipmapRequiredLength(unsigned int klen , unsigned int vlen ) 
{ unsigned int l ;

  {
#line 170
  l = (klen + vlen) + 3U;
#line 171
  if (klen >= 254U) {
#line 171
    l += 4U;
  }
#line 172
  if (vlen >= 254U) {
#line 172
    l += 4U;
  }
#line 173
  return ((unsigned long )l);
}
}
#line 177 "zipmap.c"
static unsigned int zipmapRawKeyLength(unsigned char *p ) 
{ unsigned int l ;
  unsigned int __cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 178
  __cil_tmp = zipmapDecodeLength(p);
#line 178
  l = __cil_tmp;
#line 179
  __cil_tmp___0 = zipmapEncodeLength((unsigned char *)((void *)0), l);
#line 179
  return (__cil_tmp___0 + l);
}
}
#line 184 "zipmap.c"
static unsigned int zipmapRawValueLength(unsigned char *p ) 
{ unsigned int l ;
  unsigned int __cil_tmp ;
  unsigned int used ;

  {
#line 185
  __cil_tmp = zipmapDecodeLength(p);
#line 185
  l = __cil_tmp;
#line 188
  used = zipmapEncodeLength((unsigned char *)((void *)0), l);
#line 189
  used += (unsigned int )((int )*(p + used) + 1) + l;
#line 190
  return (used);
}
}
#line 196 "zipmap.c"
static unsigned int zipmapRawEntryLength(unsigned char *p ) 
{ unsigned int l ;
  unsigned int __cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 197
  __cil_tmp = zipmapRawKeyLength(p);
#line 197
  l = __cil_tmp;
#line 198
  __cil_tmp___0 = zipmapRawValueLength(p + l);
#line 198
  return (l + __cil_tmp___0);
}
}
#line 201 "zipmap.c"
__inline static unsigned char *zipmapResize(unsigned char *zm , unsigned int len ) 
{ int __cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 202
  __cil_tmp___0 = realloc((void *)zm, len);
#line 202
  __cil_tmp = (int )__cil_tmp___0;
#line 202
  zm = (unsigned char *)__cil_tmp;
#line 203
  *(zm + (len - 1U)) = (unsigned char)255;
#line 204
  return (zm);
}
}
#line 210 "zipmap.c"
unsigned char *zipmapSet(unsigned char *zm , unsigned char *key , unsigned int klen ,
                         unsigned char *val , unsigned int vlen , int *update ) 
{ unsigned int zmlen ;
  unsigned int offset ;
  unsigned int freelen ;
  unsigned int reqlen ;
  unsigned long __cil_tmp ;
  unsigned int empty___1 ;
  unsigned int vempty ;
  unsigned char *p ;
  unsigned int __cil_tmp___0 ;
  unsigned int __cil_tmp___1 ;
  unsigned char *__cil_tmp___2 ;

  {
#line 212
  __cil_tmp = zipmapRequiredLength(klen, vlen);
#line 212
  reqlen = (unsigned int )__cil_tmp;
#line 216
  freelen = reqlen;
#line 217
  if (update) {
#line 217
    *update = 0;
  }
#line 218
  p = zipmapLookupRaw(zm, key, klen, & zmlen);
#line 219
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 221
    zm = zipmapResize(zm, zmlen + reqlen);
#line 222
    p = (zm + zmlen) - 1;
#line 223
    zmlen += reqlen;
#line 226
    if ((int )*(zm + 0) < 254) {
#line 226
      *(zm + 0) = (unsigned char )((int )*(zm + 0) + 1);
    }
  } else {
#line 230
    if (update) {
#line 230
      *update = 1;
    }
#line 231
    freelen = zipmapRawEntryLength(p);
#line 232
    if (freelen < reqlen) {
#line 236
      offset = (unsigned int )(p - zm);
#line 237
      zm = zipmapResize(zm, (zmlen - freelen) + reqlen);
#line 238
      p = zm + offset;
#line 242
      memmove((void *)(p + reqlen), (void const   *)(p + freelen), zmlen - ((offset + freelen) + 1U));
#line 243
      zmlen = (zmlen - freelen) + reqlen;
#line 244
      freelen = reqlen;
    }
  }
#line 252
  empty___1 = freelen - reqlen;
#line 253
  if (empty___1 >= 4U) {
#line 256
    offset = (unsigned int )(p - zm);
#line 257
    memmove((void *)(p + reqlen), (void const   *)(p + freelen), zmlen - ((offset + freelen) + 1U));
#line 258
    zmlen -= empty___1;
#line 259
    zm = zipmapResize(zm, zmlen);
#line 260
    p = zm + offset;
#line 261
    vempty = 0U;
  } else {
#line 263
    vempty = empty___1;
  }
#line 268
  __cil_tmp___0 = zipmapEncodeLength(p, klen);
#line 268
  p += __cil_tmp___0;
#line 269
  memcpy((void *)p, (void const   *)key, klen);
#line 270
  p += klen;
#line 272
  __cil_tmp___1 = zipmapEncodeLength(p, vlen);
#line 272
  p += __cil_tmp___1;
#line 273
  __cil_tmp___2 = p;
#line 273
  p ++;
#line 273
  *__cil_tmp___2 = (unsigned char )vempty;
#line 274
  memcpy((void *)p, (void const   *)val, vlen);
#line 275
  return (zm);
}
}
#line 280 "zipmap.c"
unsigned char *zipmapDel(unsigned char *zm , unsigned char *key , unsigned int klen ,
                         int *deleted ) 
{ unsigned int zmlen ;
  unsigned int freelen ;
  unsigned char *p ;
  unsigned char *__cil_tmp ;

  {
#line 282
  __cil_tmp = zipmapLookupRaw(zm, key, klen, & zmlen);
#line 282
  p = __cil_tmp;
#line 283
  if (p) {
#line 284
    freelen = zipmapRawEntryLength(p);
#line 285
    memmove((void *)p, (void const   *)(p + freelen), zmlen - (((unsigned int )(p - zm) + freelen) + 1U));
#line 286
    zm = zipmapResize(zm, zmlen - freelen);
#line 289
    if ((int )*(zm + 0) < 254) {
#line 289
      *(zm + 0) = (unsigned char )((int )*(zm + 0) - 1);
    }
#line 291
    if (deleted) {
#line 291
      *deleted = 1;
    }
  } else
#line 293
  if (deleted) {
#line 293
    *deleted = 0;
  }
#line 295
  return (zm);
}
}
#line 299 "zipmap.c"
unsigned char *zipmapRewind(unsigned char *zm ) 
{ 

  {
#line 300
  return (zm + 1);
}
}
#line 314 "zipmap.c"
unsigned char *zipmapNext(unsigned char *zm , unsigned char **key , unsigned int *klen ,
                          unsigned char **value , unsigned int *vlen ) 
{ unsigned int __cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 315
  if ((int )*(zm + 0) == 255) {
#line 315
    return ((unsigned char *)((void *)0));
  }
#line 316
  if (key) {
#line 317
    *key = zm;
#line 318
    *klen = zipmapDecodeLength(zm);
#line 319
    *key += *klen < 254U ? 1UL : sizeof(unsigned int ) + 1UL;
  }
#line 321
  __cil_tmp = zipmapRawKeyLength(zm);
#line 321
  zm += __cil_tmp;
#line 322
  if (value) {
#line 323
    *value = zm + 1;
#line 324
    *vlen = zipmapDecodeLength(zm);
#line 325
    *value += *vlen < 254U ? 1UL : sizeof(unsigned int ) + 1UL;
  }
#line 327
  __cil_tmp___0 = zipmapRawValueLength(zm);
#line 327
  zm += __cil_tmp___0;
#line 328
  return (zm);
}
}
#line 333 "zipmap.c"
int zipmapGet(unsigned char *zm , unsigned char *key , unsigned int klen , unsigned char **value ,
              unsigned int *vlen ) 
{ unsigned char *p ;
  unsigned int __cil_tmp ;

  {
#line 336
  p = zipmapLookupRaw(zm, key, klen, (unsigned int *)((void *)0));
#line 336
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 336
    return (0);
  }
#line 337
  __cil_tmp = zipmapRawKeyLength(p);
#line 337
  p += __cil_tmp;
#line 338
  *vlen = zipmapDecodeLength(p);
#line 339
  *value = (p + (*vlen < 254U ? 1UL : sizeof(unsigned int ) + 1UL)) + 1;
#line 340
  return (1);
}
}
#line 344 "zipmap.c"
int zipmapExists(unsigned char *zm , unsigned char *key , unsigned int klen ) 
{ unsigned char *__cil_tmp ;

  {
#line 345
  __cil_tmp = zipmapLookupRaw(zm, key, klen, (unsigned int *)((void *)0));
#line 345
  return ((unsigned int )__cil_tmp != (unsigned int )((void *)0));
}
}
#line 349 "zipmap.c"
unsigned int zipmapLen(unsigned char *zm ) 
{ unsigned int len ;
  unsigned char *p ;
  unsigned char *__cil_tmp ;

  {
#line 350
  len = 0U;
#line 351
  if ((int )*(zm + 0) < 254) {
#line 352
    len = (unsigned int )*(zm + 0);
  } else {
#line 354
    __cil_tmp = zipmapRewind(zm);
#line 354
    p = __cil_tmp;
#line 355
    while (1) {
#line 355
      p = zipmapNext(p, (unsigned char **)((void *)0), (unsigned int *)((void *)0),
                     (unsigned char **)((void *)0), (unsigned int *)((void *)0));
#line 355
      if (! ((unsigned int )p != (unsigned int )((void *)0))) {
#line 355
        break;
      }
#line 355
      len ++;
    }
#line 358
    if (len < 254U) {
#line 358
      *(zm + 0) = (unsigned char )len;
    }
  }
#line 360
  return (len);
}
}
#line 1 "sha1.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-rMyCpBhU.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 19 "sha1.h"
void SHA1Transform(uint32_t *state , unsigned char const   *buffer ) ;
#line 20
void SHA1Init(SHA1_CTX *context ) ;
#line 21
void SHA1Update(SHA1_CTX *context , unsigned char const   *data , uint32_t len ) ;
#line 22
void SHA1Final(unsigned char *digest , SHA1_CTX *context ) ;
#line 106 "sha1.c"
void SHA1Transform(uint32_t *state , unsigned char const   *buffer ) 
{ uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  CHAR64LONG16 block[1] ;

  {
#line 115
  memcpy((void *)(block), (void const   *)buffer, 64U);
#line 125
  a = *(state + 0);
#line 126
  b = *(state + 1);
#line 127
  c = *(state + 2);
#line 128
  d = *(state + 3);
#line 129
  e = *(state + 4);
#line 131
  block[0].l[0] = (((block[0].l[0] << 24) | (block[0].l[0] >> 8)) & 4278255360UL) | (((block[0].l[0] << 8) | (block[0].l[0] >> 24)) & 16711935UL);
#line 131
  e += ((((b & (c ^ d)) ^ d) + block[0].l[0]) + 1518500249UL) + ((a << 5) | (a >> 27));
#line 131
  b = (b << 30) | (b >> 2);
#line 131
  block[0].l[1] = (((block[0].l[1] << 24) | (block[0].l[1] >> 8)) & 4278255360UL) | (((block[0].l[1] << 8) | (block[0].l[1] >> 24)) & 16711935UL);
#line 131
  d += ((((a & (b ^ c)) ^ c) + block[0].l[1]) + 1518500249UL) + ((e << 5) | (e >> 27));
#line 131
  a = (a << 30) | (a >> 2);
#line 131
  block[0].l[2] = (((block[0].l[2] << 24) | (block[0].l[2] >> 8)) & 4278255360UL) | (((block[0].l[2] << 8) | (block[0].l[2] >> 24)) & 16711935UL);
#line 131
  c += ((((e & (a ^ b)) ^ b) + block[0].l[2]) + 1518500249UL) + ((d << 5) | (d >> 27));
#line 131
  e = (e << 30) | (e >> 2);
#line 131
  block[0].l[3] = (((block[0].l[3] << 24) | (block[0].l[3] >> 8)) & 4278255360UL) | (((block[0].l[3] << 8) | (block[0].l[3] >> 24)) & 16711935UL);
#line 131
  b += ((((d & (e ^ a)) ^ a) + block[0].l[3]) + 1518500249UL) + ((c << 5) | (c >> 27));
#line 131
  d = (d << 30) | (d >> 2);
#line 132
  block[0].l[4] = (((block[0].l[4] << 24) | (block[0].l[4] >> 8)) & 4278255360UL) | (((block[0].l[4] << 8) | (block[0].l[4] >> 24)) & 16711935UL);
#line 132
  a += ((((c & (d ^ e)) ^ e) + block[0].l[4]) + 1518500249UL) + ((b << 5) | (b >> 27));
#line 132
  c = (c << 30) | (c >> 2);
#line 132
  block[0].l[5] = (((block[0].l[5] << 24) | (block[0].l[5] >> 8)) & 4278255360UL) | (((block[0].l[5] << 8) | (block[0].l[5] >> 24)) & 16711935UL);
#line 132
  e += ((((b & (c ^ d)) ^ d) + block[0].l[5]) + 1518500249UL) + ((a << 5) | (a >> 27));
#line 132
  b = (b << 30) | (b >> 2);
#line 132
  block[0].l[6] = (((block[0].l[6] << 24) | (block[0].l[6] >> 8)) & 4278255360UL) | (((block[0].l[6] << 8) | (block[0].l[6] >> 24)) & 16711935UL);
#line 132
  d += ((((a & (b ^ c)) ^ c) + block[0].l[6]) + 1518500249UL) + ((e << 5) | (e >> 27));
#line 132
  a = (a << 30) | (a >> 2);
#line 132
  block[0].l[7] = (((block[0].l[7] << 24) | (block[0].l[7] >> 8)) & 4278255360UL) | (((block[0].l[7] << 8) | (block[0].l[7] >> 24)) & 16711935UL);
#line 132
  c += ((((e & (a ^ b)) ^ b) + block[0].l[7]) + 1518500249UL) + ((d << 5) | (d >> 27));
#line 132
  e = (e << 30) | (e >> 2);
#line 133
  block[0].l[8] = (((block[0].l[8] << 24) | (block[0].l[8] >> 8)) & 4278255360UL) | (((block[0].l[8] << 8) | (block[0].l[8] >> 24)) & 16711935UL);
#line 133
  b += ((((d & (e ^ a)) ^ a) + block[0].l[8]) + 1518500249UL) + ((c << 5) | (c >> 27));
#line 133
  d = (d << 30) | (d >> 2);
#line 133
  block[0].l[9] = (((block[0].l[9] << 24) | (block[0].l[9] >> 8)) & 4278255360UL) | (((block[0].l[9] << 8) | (block[0].l[9] >> 24)) & 16711935UL);
#line 133
  a += ((((c & (d ^ e)) ^ e) + block[0].l[9]) + 1518500249UL) + ((b << 5) | (b >> 27));
#line 133
  c = (c << 30) | (c >> 2);
#line 133
  block[0].l[10] = (((block[0].l[10] << 24) | (block[0].l[10] >> 8)) & 4278255360UL) | (((block[0].l[10] << 8) | (block[0].l[10] >> 24)) & 16711935UL);
#line 133
  e += ((((b & (c ^ d)) ^ d) + block[0].l[10]) + 1518500249UL) + ((a << 5) | (a >> 27));
#line 133
  b = (b << 30) | (b >> 2);
#line 133
  block[0].l[11] = (((block[0].l[11] << 24) | (block[0].l[11] >> 8)) & 4278255360UL) | (((block[0].l[11] << 8) | (block[0].l[11] >> 24)) & 16711935UL);
#line 133
  d += ((((a & (b ^ c)) ^ c) + block[0].l[11]) + 1518500249UL) + ((e << 5) | (e >> 27));
#line 133
  a = (a << 30) | (a >> 2);
#line 134
  block[0].l[12] = (((block[0].l[12] << 24) | (block[0].l[12] >> 8)) & 4278255360UL) | (((block[0].l[12] << 8) | (block[0].l[12] >> 24)) & 16711935UL);
#line 134
  c += ((((e & (a ^ b)) ^ b) + block[0].l[12]) + 1518500249UL) + ((d << 5) | (d >> 27));
#line 134
  e = (e << 30) | (e >> 2);
#line 134
  block[0].l[13] = (((block[0].l[13] << 24) | (block[0].l[13] >> 8)) & 4278255360UL) | (((block[0].l[13] << 8) | (block[0].l[13] >> 24)) & 16711935UL);
#line 134
  b += ((((d & (e ^ a)) ^ a) + block[0].l[13]) + 1518500249UL) + ((c << 5) | (c >> 27));
#line 134
  d = (d << 30) | (d >> 2);
#line 134
  block[0].l[14] = (((block[0].l[14] << 24) | (block[0].l[14] >> 8)) & 4278255360UL) | (((block[0].l[14] << 8) | (block[0].l[14] >> 24)) & 16711935UL);
#line 134
  a += ((((c & (d ^ e)) ^ e) + block[0].l[14]) + 1518500249UL) + ((b << 5) | (b >> 27));
#line 134
  c = (c << 30) | (c >> 2);
#line 134
  block[0].l[15] = (((block[0].l[15] << 24) | (block[0].l[15] >> 8)) & 4278255360UL) | (((block[0].l[15] << 8) | (block[0].l[15] >> 24)) & 16711935UL);
#line 134
  e += ((((b & (c ^ d)) ^ d) + block[0].l[15]) + 1518500249UL) + ((a << 5) | (a >> 27));
#line 134
  b = (b << 30) | (b >> 2);
#line 135
  block[0].l[0] = ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) << 1) | ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) >> 31);
#line 135
  d += ((((a & (b ^ c)) ^ c) + block[0].l[0]) + 1518500249UL) + ((e << 5) | (e >> 27));
#line 135
  a = (a << 30) | (a >> 2);
#line 135
  block[0].l[1] = ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) << 1) | ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) >> 31);
#line 135
  c += ((((e & (a ^ b)) ^ b) + block[0].l[1]) + 1518500249UL) + ((d << 5) | (d >> 27));
#line 135
  e = (e << 30) | (e >> 2);
#line 135
  block[0].l[2] = ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) << 1) | ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) >> 31);
#line 135
  b += ((((d & (e ^ a)) ^ a) + block[0].l[2]) + 1518500249UL) + ((c << 5) | (c >> 27));
#line 135
  d = (d << 30) | (d >> 2);
#line 135
  block[0].l[3] = ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) << 1) | ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) >> 31);
#line 135
  a += ((((c & (d ^ e)) ^ e) + block[0].l[3]) + 1518500249UL) + ((b << 5) | (b >> 27));
#line 135
  c = (c << 30) | (c >> 2);
#line 136
  block[0].l[4] = ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) << 1) | ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) >> 31);
#line 136
  e += ((((b ^ c) ^ d) + block[0].l[4]) + 1859775393UL) + ((a << 5) | (a >> 27));
#line 136
  b = (b << 30) | (b >> 2);
#line 136
  block[0].l[5] = ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) << 1) | ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) >> 31);
#line 136
  d += ((((a ^ b) ^ c) + block[0].l[5]) + 1859775393UL) + ((e << 5) | (e >> 27));
#line 136
  a = (a << 30) | (a >> 2);
#line 136
  block[0].l[6] = ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) << 1) | ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) >> 31);
#line 136
  c += ((((e ^ a) ^ b) + block[0].l[6]) + 1859775393UL) + ((d << 5) | (d >> 27));
#line 136
  e = (e << 30) | (e >> 2);
#line 136
  block[0].l[7] = ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) << 1) | ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) >> 31);
#line 136
  b += ((((d ^ e) ^ a) + block[0].l[7]) + 1859775393UL) + ((c << 5) | (c >> 27));
#line 136
  d = (d << 30) | (d >> 2);
#line 137
  block[0].l[8] = ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) << 1) | ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) >> 31);
#line 137
  a += ((((c ^ d) ^ e) + block[0].l[8]) + 1859775393UL) + ((b << 5) | (b >> 27));
#line 137
  c = (c << 30) | (c >> 2);
#line 137
  block[0].l[9] = ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) << 1) | ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) >> 31);
#line 137
  e += ((((b ^ c) ^ d) + block[0].l[9]) + 1859775393UL) + ((a << 5) | (a >> 27));
#line 137
  b = (b << 30) | (b >> 2);
#line 137
  block[0].l[10] = ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) << 1) | ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) >> 31);
#line 137
  d += ((((a ^ b) ^ c) + block[0].l[10]) + 1859775393UL) + ((e << 5) | (e >> 27));
#line 137
  a = (a << 30) | (a >> 2);
#line 137
  block[0].l[11] = ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) << 1) | ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) >> 31);
#line 137
  c += ((((e ^ a) ^ b) + block[0].l[11]) + 1859775393UL) + ((d << 5) | (d >> 27));
#line 137
  e = (e << 30) | (e >> 2);
#line 138
  block[0].l[12] = ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) << 1) | ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) >> 31);
#line 138
  b += ((((d ^ e) ^ a) + block[0].l[12]) + 1859775393UL) + ((c << 5) | (c >> 27));
#line 138
  d = (d << 30) | (d >> 2);
#line 138
  block[0].l[13] = ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) << 1) | ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) >> 31);
#line 138
  a += ((((c ^ d) ^ e) + block[0].l[13]) + 1859775393UL) + ((b << 5) | (b >> 27));
#line 138
  c = (c << 30) | (c >> 2);
#line 138
  block[0].l[14] = ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) << 1) | ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) >> 31);
#line 138
  e += ((((b ^ c) ^ d) + block[0].l[14]) + 1859775393UL) + ((a << 5) | (a >> 27));
#line 138
  b = (b << 30) | (b >> 2);
#line 138
  block[0].l[15] = ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) << 1) | ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) >> 31);
#line 138
  d += ((((a ^ b) ^ c) + block[0].l[15]) + 1859775393UL) + ((e << 5) | (e >> 27));
#line 138
  a = (a << 30) | (a >> 2);
#line 139
  block[0].l[0] = ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) << 1) | ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) >> 31);
#line 139
  c += ((((e ^ a) ^ b) + block[0].l[0]) + 1859775393UL) + ((d << 5) | (d >> 27));
#line 139
  e = (e << 30) | (e >> 2);
#line 139
  block[0].l[1] = ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) << 1) | ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) >> 31);
#line 139
  b += ((((d ^ e) ^ a) + block[0].l[1]) + 1859775393UL) + ((c << 5) | (c >> 27));
#line 139
  d = (d << 30) | (d >> 2);
#line 139
  block[0].l[2] = ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) << 1) | ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) >> 31);
#line 139
  a += ((((c ^ d) ^ e) + block[0].l[2]) + 1859775393UL) + ((b << 5) | (b >> 27));
#line 139
  c = (c << 30) | (c >> 2);
#line 139
  block[0].l[3] = ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) << 1) | ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) >> 31);
#line 139
  e += ((((b ^ c) ^ d) + block[0].l[3]) + 1859775393UL) + ((a << 5) | (a >> 27));
#line 139
  b = (b << 30) | (b >> 2);
#line 140
  block[0].l[4] = ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) << 1) | ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) >> 31);
#line 140
  d += ((((a ^ b) ^ c) + block[0].l[4]) + 1859775393UL) + ((e << 5) | (e >> 27));
#line 140
  a = (a << 30) | (a >> 2);
#line 140
  block[0].l[5] = ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) << 1) | ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) >> 31);
#line 140
  c += ((((e ^ a) ^ b) + block[0].l[5]) + 1859775393UL) + ((d << 5) | (d >> 27));
#line 140
  e = (e << 30) | (e >> 2);
#line 140
  block[0].l[6] = ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) << 1) | ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) >> 31);
#line 140
  b += ((((d ^ e) ^ a) + block[0].l[6]) + 1859775393UL) + ((c << 5) | (c >> 27));
#line 140
  d = (d << 30) | (d >> 2);
#line 140
  block[0].l[7] = ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) << 1) | ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) >> 31);
#line 140
  a += ((((c ^ d) ^ e) + block[0].l[7]) + 1859775393UL) + ((b << 5) | (b >> 27));
#line 140
  c = (c << 30) | (c >> 2);
#line 141
  block[0].l[8] = ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) << 1) | ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) >> 31);
#line 141
  e += (((((b | c) & d) | (b & c)) + block[0].l[8]) + 2400959708UL) + ((a << 5) | (a >> 27));
#line 141
  b = (b << 30) | (b >> 2);
#line 141
  block[0].l[9] = ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) << 1) | ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) >> 31);
#line 141
  d += (((((a | b) & c) | (a & b)) + block[0].l[9]) + 2400959708UL) + ((e << 5) | (e >> 27));
#line 141
  a = (a << 30) | (a >> 2);
#line 141
  block[0].l[10] = ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) << 1) | ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) >> 31);
#line 141
  c += (((((e | a) & b) | (e & a)) + block[0].l[10]) + 2400959708UL) + ((d << 5) | (d >> 27));
#line 141
  e = (e << 30) | (e >> 2);
#line 141
  block[0].l[11] = ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) << 1) | ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) >> 31);
#line 141
  b += (((((d | e) & a) | (d & e)) + block[0].l[11]) + 2400959708UL) + ((c << 5) | (c >> 27));
#line 141
  d = (d << 30) | (d >> 2);
#line 142
  block[0].l[12] = ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) << 1) | ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) >> 31);
#line 142
  a += (((((c | d) & e) | (c & d)) + block[0].l[12]) + 2400959708UL) + ((b << 5) | (b >> 27));
#line 142
  c = (c << 30) | (c >> 2);
#line 142
  block[0].l[13] = ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) << 1) | ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) >> 31);
#line 142
  e += (((((b | c) & d) | (b & c)) + block[0].l[13]) + 2400959708UL) + ((a << 5) | (a >> 27));
#line 142
  b = (b << 30) | (b >> 2);
#line 142
  block[0].l[14] = ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) << 1) | ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) >> 31);
#line 142
  d += (((((a | b) & c) | (a & b)) + block[0].l[14]) + 2400959708UL) + ((e << 5) | (e >> 27));
#line 142
  a = (a << 30) | (a >> 2);
#line 142
  block[0].l[15] = ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) << 1) | ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) >> 31);
#line 142
  c += (((((e | a) & b) | (e & a)) + block[0].l[15]) + 2400959708UL) + ((d << 5) | (d >> 27));
#line 142
  e = (e << 30) | (e >> 2);
#line 143
  block[0].l[0] = ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) << 1) | ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) >> 31);
#line 143
  b += (((((d | e) & a) | (d & e)) + block[0].l[0]) + 2400959708UL) + ((c << 5) | (c >> 27));
#line 143
  d = (d << 30) | (d >> 2);
#line 143
  block[0].l[1] = ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) << 1) | ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) >> 31);
#line 143
  a += (((((c | d) & e) | (c & d)) + block[0].l[1]) + 2400959708UL) + ((b << 5) | (b >> 27));
#line 143
  c = (c << 30) | (c >> 2);
#line 143
  block[0].l[2] = ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) << 1) | ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) >> 31);
#line 143
  e += (((((b | c) & d) | (b & c)) + block[0].l[2]) + 2400959708UL) + ((a << 5) | (a >> 27));
#line 143
  b = (b << 30) | (b >> 2);
#line 143
  block[0].l[3] = ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) << 1) | ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) >> 31);
#line 143
  d += (((((a | b) & c) | (a & b)) + block[0].l[3]) + 2400959708UL) + ((e << 5) | (e >> 27));
#line 143
  a = (a << 30) | (a >> 2);
#line 144
  block[0].l[4] = ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) << 1) | ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) >> 31);
#line 144
  c += (((((e | a) & b) | (e & a)) + block[0].l[4]) + 2400959708UL) + ((d << 5) | (d >> 27));
#line 144
  e = (e << 30) | (e >> 2);
#line 144
  block[0].l[5] = ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) << 1) | ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) >> 31);
#line 144
  b += (((((d | e) & a) | (d & e)) + block[0].l[5]) + 2400959708UL) + ((c << 5) | (c >> 27));
#line 144
  d = (d << 30) | (d >> 2);
#line 144
  block[0].l[6] = ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) << 1) | ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) >> 31);
#line 144
  a += (((((c | d) & e) | (c & d)) + block[0].l[6]) + 2400959708UL) + ((b << 5) | (b >> 27));
#line 144
  c = (c << 30) | (c >> 2);
#line 144
  block[0].l[7] = ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) << 1) | ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) >> 31);
#line 144
  e += (((((b | c) & d) | (b & c)) + block[0].l[7]) + 2400959708UL) + ((a << 5) | (a >> 27));
#line 144
  b = (b << 30) | (b >> 2);
#line 145
  block[0].l[8] = ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) << 1) | ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) >> 31);
#line 145
  d += (((((a | b) & c) | (a & b)) + block[0].l[8]) + 2400959708UL) + ((e << 5) | (e >> 27));
#line 145
  a = (a << 30) | (a >> 2);
#line 145
  block[0].l[9] = ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) << 1) | ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) >> 31);
#line 145
  c += (((((e | a) & b) | (e & a)) + block[0].l[9]) + 2400959708UL) + ((d << 5) | (d >> 27));
#line 145
  e = (e << 30) | (e >> 2);
#line 145
  block[0].l[10] = ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) << 1) | ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) >> 31);
#line 145
  b += (((((d | e) & a) | (d & e)) + block[0].l[10]) + 2400959708UL) + ((c << 5) | (c >> 27));
#line 145
  d = (d << 30) | (d >> 2);
#line 145
  block[0].l[11] = ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) << 1) | ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) >> 31);
#line 145
  a += (((((c | d) & e) | (c & d)) + block[0].l[11]) + 2400959708UL) + ((b << 5) | (b >> 27));
#line 145
  c = (c << 30) | (c >> 2);
#line 146
  block[0].l[12] = ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) << 1) | ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) >> 31);
#line 146
  e += ((((b ^ c) ^ d) + block[0].l[12]) + 3395469782UL) + ((a << 5) | (a >> 27));
#line 146
  b = (b << 30) | (b >> 2);
#line 146
  block[0].l[13] = ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) << 1) | ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) >> 31);
#line 146
  d += ((((a ^ b) ^ c) + block[0].l[13]) + 3395469782UL) + ((e << 5) | (e >> 27));
#line 146
  a = (a << 30) | (a >> 2);
#line 146
  block[0].l[14] = ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) << 1) | ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) >> 31);
#line 146
  c += ((((e ^ a) ^ b) + block[0].l[14]) + 3395469782UL) + ((d << 5) | (d >> 27));
#line 146
  e = (e << 30) | (e >> 2);
#line 146
  block[0].l[15] = ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) << 1) | ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) >> 31);
#line 146
  b += ((((d ^ e) ^ a) + block[0].l[15]) + 3395469782UL) + ((c << 5) | (c >> 27));
#line 146
  d = (d << 30) | (d >> 2);
#line 147
  block[0].l[0] = ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) << 1) | ((((block[0].l[13] ^ block[0].l[8]) ^ block[0].l[2]) ^ block[0].l[0]) >> 31);
#line 147
  a += ((((c ^ d) ^ e) + block[0].l[0]) + 3395469782UL) + ((b << 5) | (b >> 27));
#line 147
  c = (c << 30) | (c >> 2);
#line 147
  block[0].l[1] = ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) << 1) | ((((block[0].l[14] ^ block[0].l[9]) ^ block[0].l[3]) ^ block[0].l[1]) >> 31);
#line 147
  e += ((((b ^ c) ^ d) + block[0].l[1]) + 3395469782UL) + ((a << 5) | (a >> 27));
#line 147
  b = (b << 30) | (b >> 2);
#line 147
  block[0].l[2] = ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) << 1) | ((((block[0].l[15] ^ block[0].l[10]) ^ block[0].l[4]) ^ block[0].l[2]) >> 31);
#line 147
  d += ((((a ^ b) ^ c) + block[0].l[2]) + 3395469782UL) + ((e << 5) | (e >> 27));
#line 147
  a = (a << 30) | (a >> 2);
#line 147
  block[0].l[3] = ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) << 1) | ((((block[0].l[0] ^ block[0].l[11]) ^ block[0].l[5]) ^ block[0].l[3]) >> 31);
#line 147
  c += ((((e ^ a) ^ b) + block[0].l[3]) + 3395469782UL) + ((d << 5) | (d >> 27));
#line 147
  e = (e << 30) | (e >> 2);
#line 148
  block[0].l[4] = ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) << 1) | ((((block[0].l[1] ^ block[0].l[12]) ^ block[0].l[6]) ^ block[0].l[4]) >> 31);
#line 148
  b += ((((d ^ e) ^ a) + block[0].l[4]) + 3395469782UL) + ((c << 5) | (c >> 27));
#line 148
  d = (d << 30) | (d >> 2);
#line 148
  block[0].l[5] = ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) << 1) | ((((block[0].l[2] ^ block[0].l[13]) ^ block[0].l[7]) ^ block[0].l[5]) >> 31);
#line 148
  a += ((((c ^ d) ^ e) + block[0].l[5]) + 3395469782UL) + ((b << 5) | (b >> 27));
#line 148
  c = (c << 30) | (c >> 2);
#line 148
  block[0].l[6] = ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) << 1) | ((((block[0].l[3] ^ block[0].l[14]) ^ block[0].l[8]) ^ block[0].l[6]) >> 31);
#line 148
  e += ((((b ^ c) ^ d) + block[0].l[6]) + 3395469782UL) + ((a << 5) | (a >> 27));
#line 148
  b = (b << 30) | (b >> 2);
#line 148
  block[0].l[7] = ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) << 1) | ((((block[0].l[4] ^ block[0].l[15]) ^ block[0].l[9]) ^ block[0].l[7]) >> 31);
#line 148
  d += ((((a ^ b) ^ c) + block[0].l[7]) + 3395469782UL) + ((e << 5) | (e >> 27));
#line 148
  a = (a << 30) | (a >> 2);
#line 149
  block[0].l[8] = ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) << 1) | ((((block[0].l[5] ^ block[0].l[0]) ^ block[0].l[10]) ^ block[0].l[8]) >> 31);
#line 149
  c += ((((e ^ a) ^ b) + block[0].l[8]) + 3395469782UL) + ((d << 5) | (d >> 27));
#line 149
  e = (e << 30) | (e >> 2);
#line 149
  block[0].l[9] = ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) << 1) | ((((block[0].l[6] ^ block[0].l[1]) ^ block[0].l[11]) ^ block[0].l[9]) >> 31);
#line 149
  b += ((((d ^ e) ^ a) + block[0].l[9]) + 3395469782UL) + ((c << 5) | (c >> 27));
#line 149
  d = (d << 30) | (d >> 2);
#line 149
  block[0].l[10] = ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) << 1) | ((((block[0].l[7] ^ block[0].l[2]) ^ block[0].l[12]) ^ block[0].l[10]) >> 31);
#line 149
  a += ((((c ^ d) ^ e) + block[0].l[10]) + 3395469782UL) + ((b << 5) | (b >> 27));
#line 149
  c = (c << 30) | (c >> 2);
#line 149
  block[0].l[11] = ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) << 1) | ((((block[0].l[8] ^ block[0].l[3]) ^ block[0].l[13]) ^ block[0].l[11]) >> 31);
#line 149
  e += ((((b ^ c) ^ d) + block[0].l[11]) + 3395469782UL) + ((a << 5) | (a >> 27));
#line 149
  b = (b << 30) | (b >> 2);
#line 150
  block[0].l[12] = ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) << 1) | ((((block[0].l[9] ^ block[0].l[4]) ^ block[0].l[14]) ^ block[0].l[12]) >> 31);
#line 150
  d += ((((a ^ b) ^ c) + block[0].l[12]) + 3395469782UL) + ((e << 5) | (e >> 27));
#line 150
  a = (a << 30) | (a >> 2);
#line 150
  block[0].l[13] = ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) << 1) | ((((block[0].l[10] ^ block[0].l[5]) ^ block[0].l[15]) ^ block[0].l[13]) >> 31);
#line 150
  c += ((((e ^ a) ^ b) + block[0].l[13]) + 3395469782UL) + ((d << 5) | (d >> 27));
#line 150
  e = (e << 30) | (e >> 2);
#line 150
  block[0].l[14] = ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) << 1) | ((((block[0].l[11] ^ block[0].l[6]) ^ block[0].l[0]) ^ block[0].l[14]) >> 31);
#line 150
  b += ((((d ^ e) ^ a) + block[0].l[14]) + 3395469782UL) + ((c << 5) | (c >> 27));
#line 150
  d = (d << 30) | (d >> 2);
#line 150
  block[0].l[15] = ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) << 1) | ((((block[0].l[12] ^ block[0].l[7]) ^ block[0].l[1]) ^ block[0].l[15]) >> 31);
#line 150
  a += ((((c ^ d) ^ e) + block[0].l[15]) + 3395469782UL) + ((b << 5) | (b >> 27));
#line 150
  c = (c << 30) | (c >> 2);
#line 152
  *(state + 0) += a;
#line 153
  *(state + 1) += b;
#line 154
  *(state + 2) += c;
#line 155
  *(state + 3) += d;
#line 156
  *(state + 4) += e;
#line 158
  e = 0UL;
#line 158
  d = e;
#line 158
  c = d;
#line 158
  b = c;
#line 158
  a = b;
#line 160
  memset((void *)(block), '\000', (unsigned int )sizeof(block));
#line 162
  return;
}
}
#line 167 "sha1.c"
void SHA1Init(SHA1_CTX *context ) 
{ uint32_t __cil_tmp ;

  {
#line 170
  context->state[0] = 1732584193UL;
#line 171
  context->state[1] = 4023233417UL;
#line 172
  context->state[2] = 2562383102UL;
#line 173
  context->state[3] = 271733878UL;
#line 174
  context->state[4] = 3285377520UL;
#line 175
  __cil_tmp = 0UL;
#line 175
  context->count[1] = __cil_tmp;
#line 175
  context->count[0] = __cil_tmp;
#line 176
  return;
}
}
#line 181 "sha1.c"
void SHA1Update(SHA1_CTX *context , unsigned char const   *data , uint32_t len ) 
{ uint32_t i ;
  uint32_t j ;
  uint32_t __cil_tmp ;

  {
#line 186
  j = context->count[0];
#line 187
  __cil_tmp = context->count[0] + (len << 3);
#line 187
  context->count[0] = __cil_tmp;
#line 187
  if (__cil_tmp < j) {
#line 188
    (context->count[1]) ++;
  }
#line 189
  context->count[1] += len >> 29;
#line 190
  j = (j >> 3) & 63UL;
#line 191
  if (j + len > 63UL) {
#line 192
    i = 64UL - j;
#line 192
    memcpy((void *)(& context->buffer[j]), (void const   *)data, (unsigned int )i);
#line 193
    SHA1Transform(context->state, (unsigned char const   *)(context->buffer));
#line 194
    while (i + 63UL < len) {
#line 195
      SHA1Transform(context->state, data + i);
#line 194
      i += 64UL;
    }
#line 197
    j = 0UL;
  } else {
#line 199
    i = 0UL;
  }
#line 200
  memcpy((void *)(& context->buffer[j]), (void const   *)(data + i), (unsigned int )(len - i));
#line 201
  return;
}
}
#line 206 "sha1.c"
void SHA1Final(unsigned char *digest , SHA1_CTX *context ) 
{ unsigned int i ;
  unsigned char finalcount[8] ;
  unsigned char c ;

  {
#line 229
  i = 0U;
#line 229
  while (i < 8U) {
#line 230
    finalcount[i] = (unsigned char )((context->count[i >= 4U ? 0 : 1] >> (3U - (i & 3U)) * 8U) & 255UL);
#line 229
    i ++;
  }
#line 234
  c = (unsigned char)128;
#line 235
  SHA1Update(context, (unsigned char const   *)(& c), 1UL);
#line 236
  while ((context->count[0] & 504UL) != 448UL) {
#line 237
    c = (unsigned char)0;
#line 238
    SHA1Update(context, (unsigned char const   *)(& c), 1UL);
  }
#line 240
  SHA1Update(context, (unsigned char const   *)(finalcount), 8UL);
#line 241
  i = 0U;
#line 241
  while (i < 20U) {
#line 242
    *(digest + i) = (unsigned char )((context->state[i >> 2] >> (3U - (i & 3U)) * 8U) & 255UL);
#line 241
    i ++;
  }
#line 246
  memset((void *)context, '\000', (unsigned int )sizeof(*context));
#line 247
  memset((void *)(& finalcount), '\000', (unsigned int )sizeof(finalcount));
#line 248
  return;
}
}
#line 1 "ziplist.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ru7AQlJt.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 189 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
long long strtoll(char const   *s , char **ptr , int base ) ;
#line 4 "ziplist.h"
unsigned char *ziplistNew(void) ;
#line 5
unsigned char *ziplistPush(unsigned char *zl , unsigned char *s , unsigned int slen ,
                           int where ) ;
#line 6
unsigned char *ziplistIndex(unsigned char *zl , int index___0 ) ;
#line 7
unsigned char *ziplistNext(unsigned char *zl , unsigned char *p ) ;
#line 8
unsigned char *ziplistPrev(unsigned char *zl , unsigned char *p ) ;
#line 9
unsigned int ziplistGet(unsigned char *p , unsigned char **sstr , unsigned int *slen ,
                        long long *sval ) ;
#line 10
unsigned char *ziplistInsert(unsigned char *zl , unsigned char *p , unsigned char *s ,
                             unsigned int slen ) ;
#line 11
unsigned char *ziplistDelete(unsigned char *zl , unsigned char **p ) ;
#line 12
unsigned char *ziplistDeleteRange(unsigned char *zl , unsigned int index___0 , unsigned int num ) ;
#line 13
unsigned int ziplistCompare(unsigned char *p , unsigned char *sstr , unsigned int slen ) ;
#line 14
unsigned int ziplistLen(unsigned char *zl ) ;
#line 15
unsigned int ziplistSize(unsigned char *zl ) ;
#line 112 "ziplist.c"
static unsigned int zipEntryEncoding(unsigned char *p ) 
{ unsigned char b ;

  {
#line 114
  b = (unsigned char )((int )*(p + 0) & 192);
#line 115
  if ((int )b < 192) {
#line 116
    return ((unsigned int )b);
  } else {
#line 119
    return ((unsigned int )((int )*(p + 0) & 240));
  }
#line 121
  __libc_failwith((char *)"Assertion failed: NULL at ziplist.c:121");
#line 122
  return (0U);
}
}
#line 126 "ziplist.c"
static unsigned int zipIntSize(unsigned char encoding ) 
{ 

  {
#line 127
  switch ((int )encoding) {
  case 192: 
#line 128
  return ((unsigned int )sizeof(int16_t ));
  case 192 | (1 << 4): 
#line 129
  return ((unsigned int )sizeof(int32_t ));
  case 192 | (2 << 4): 
#line 130
  return ((unsigned int )sizeof(int64_t ));
  }
#line 132
  __libc_failwith((char *)"Assertion failed: NULL at ziplist.c:132");
#line 133
  return (0U);
}
}
#line 138 "ziplist.c"
static unsigned int zipDecodeLength(unsigned char *p , unsigned int *lensize ) 
{ unsigned char encoding ;
  unsigned int __cil_tmp ;
  unsigned int len ;

  {
#line 139
  __cil_tmp = zipEntryEncoding(p);
#line 139
  encoding = (unsigned char )__cil_tmp;
#line 140
  len = 0U;
#line 142
  if (((int )encoding & 192) < 192) {
#line 143
    switch ((int )encoding) {
    case 0: 
#line 145
    len = (unsigned int )((int )*(p + 0) & 63);
#line 146
    if (lensize) {
#line 146
      *lensize = 1U;
    }
#line 147
    break;
    case 1 << 6: 
#line 149
    len = (unsigned int )((((int )*(p + 0) & 63) << 8) | (int )*(p + 1));
#line 150
    if (lensize) {
#line 150
      *lensize = 2U;
    }
#line 151
    break;
    case 2 << 6: 
#line 153
    len = (unsigned int )(((((int )*(p + 1) << 24) | ((int )*(p + 2) << 16)) | ((int )*(p + 3) << 8)) | (int )*(p + 4));
#line 154
    if (lensize) {
#line 154
      *lensize = 5U;
    }
#line 155
    break;
    default: 
#line 157
    __libc_failwith((char *)"Assertion failed: NULL at ziplist.c:157");
    }
  } else {
#line 160
    len = zipIntSize(encoding);
#line 161
    if (lensize) {
#line 161
      *lensize = 1U;
    }
  }
#line 163
  return (len);
}
}
#line 168 "ziplist.c"
static unsigned int zipEncodeLength(unsigned char *p , unsigned char encoding , unsigned int rawlen ) 
{ unsigned char len ;
  unsigned char buf[5] ;

  {
#line 169
  len = (unsigned char)1;
#line 171
  if (((int )encoding & 192) < 192) {
#line 174
    if (rawlen <= 63U) {
#line 175
      if (! p) {
#line 175
        return ((unsigned int )len);
      }
#line 176
      buf[0] = (unsigned char )rawlen;
    } else
#line 177
    if (rawlen <= 16383U) {
#line 178
      len = (unsigned char )((int )len + 1);
#line 179
      if (! p) {
#line 179
        return ((unsigned int )len);
      }
#line 180
      buf[0] = (unsigned char )((unsigned int )(1 << 6) | ((rawlen >> 8) & 63U));
#line 181
      buf[1] = (unsigned char )(rawlen & 255U);
    } else {
#line 183
      len = (unsigned char )((int )len + 4);
#line 184
      if (! p) {
#line 184
        return ((unsigned int )len);
      }
#line 185
      buf[0] = (unsigned char )(2 << 6);
#line 186
      buf[1] = (unsigned char )((rawlen >> 24) & 255U);
#line 187
      buf[2] = (unsigned char )((rawlen >> 16) & 255U);
#line 188
      buf[3] = (unsigned char )((rawlen >> 8) & 255U);
#line 189
      buf[4] = (unsigned char )(rawlen & 255U);
    }
  } else {
#line 193
    if (! p) {
#line 193
      return ((unsigned int )len);
    }
#line 194
    buf[0] = encoding;
  }
#line 198
  memcpy((void *)p, (void const   *)(buf), (unsigned int )len);
#line 199
  return ((unsigned int )len);
}
}
#line 203 "ziplist.c"
static unsigned int zipPrevDecodeLength(unsigned char *p , unsigned int *lensize ) 
{ unsigned int len ;

  {
#line 204
  len = (unsigned int )*p;
#line 205
  if (len < 254U) {
#line 206
    if (lensize) {
#line 206
      *lensize = 1U;
    }
  } else {
#line 208
    if (lensize) {
#line 208
      *lensize = (unsigned int )(1UL + sizeof(len));
    }
#line 209
    memcpy((void *)(& len), (void const   *)(p + 1), (unsigned int )sizeof(len));
  }
#line 211
  return (len);
}
}
#line 216 "ziplist.c"
static unsigned int zipPrevEncodeLength(unsigned char *p , unsigned int len ) 
{ 

  {
#line 217
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 218
    return ((unsigned int )(len < 254U ? 1UL : sizeof(len) + 1UL));
  } else
#line 220
  if (len < 254U) {
#line 221
    *(p + 0) = (unsigned char )len;
#line 222
    return (1U);
  } else {
#line 224
    *(p + 0) = (unsigned char)254;
#line 225
    memcpy((void *)(p + 1), (void const   *)(& len), (unsigned int )sizeof(len));
#line 226
    return ((unsigned int )(1UL + sizeof(len)));
  }
}
}
#line 233 "ziplist.c"
static void zipPrevEncodeLengthForceLarge(unsigned char *p , unsigned int len ) 
{ 

  {
#line 234
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 234
    return;
  }
#line 235
  *(p + 0) = (unsigned char)254;
#line 236
  memcpy((void *)(p + 1), (void const   *)(& len), (unsigned int )sizeof(len));
#line 237
  return;
}
}
#line 241 "ziplist.c"
static int zipPrevLenByteDiff(unsigned char *p , unsigned int len ) 
{ unsigned int prevlensize ;
  unsigned int __cil_tmp ;

  {
#line 243
  zipPrevDecodeLength(p, & prevlensize);
#line 244
  __cil_tmp = zipPrevEncodeLength((unsigned char *)((void *)0), len);
#line 244
  return ((int )(__cil_tmp - prevlensize));
}
}
#line 249 "ziplist.c"
static int zipTryEncoding(unsigned char *entry , unsigned int entrylen , long long *v ,
                          unsigned char *encoding ) 
{ long long value ;
  char *eptr ;
  char buf[32] ;
  int slen ;
  int __cil_tmp ;

  {
#line 254
  if (entrylen >= 32U || entrylen == 0U) {
#line 254
    return (0);
  }
#line 255
  if ((int )*(entry + 0) == 45 || ((int )*(entry + 0) >= 48 && (int )*(entry + 0) <= 57)) {
#line 260
    memcpy((void *)(buf), (void const   *)entry, entrylen);
#line 261
    buf[entrylen] = (char )'\000';
#line 262
    value = strtoll((char const   *)(buf), & eptr, 10);
#line 263
    if ((int )*(eptr + 0) != 0) {
#line 263
      return (0);
    }
#line 264
    slen = ll2string(buf, 32U, value);
#line 265
    if (entrylen != (unsigned int )slen) {
#line 265
      return (0);
    } else {
#line 265
      __cil_tmp = memcmp((void const   *)(buf), (void const   *)entry, (unsigned int )slen);
#line 265
      if (__cil_tmp) {
#line 265
        return (0);
      }
    }
#line 269
    if (value >= -32768LL && value <= 32767LL) {
#line 270
      *encoding = (unsigned char)192;
    } else
#line 271
    if (value >= (-0x7FFFFFFF-1) && value <= 2147483647LL) {
#line 272
      *encoding = (unsigned char )(192 | (1 << 4));
    } else {
#line 274
      *encoding = (unsigned char )(192 | (2 << 4));
    }
#line 276
    *v = value;
#line 277
    return (1);
  }
#line 279
  return (0);
}
}
#line 283 "ziplist.c"
static void zipSaveInteger(unsigned char *p , int64_t value , unsigned char encoding ) 
{ int16_t i16 ;
  int32_t i32 ;
  int64_t i64 ;

  {
#line 287
  if ((int )encoding == 192) {
#line 288
    i16 = (short )value;
#line 289
    memcpy((void *)p, (void const   *)(& i16), (unsigned int )sizeof(i16));
  } else
#line 290
  if ((int )encoding == (192 | (1 << 4))) {
#line 291
    i32 = (long )value;
#line 292
    memcpy((void *)p, (void const   *)(& i32), (unsigned int )sizeof(i32));
  } else
#line 293
  if ((int )encoding == (192 | (2 << 4))) {
#line 294
    i64 = value;
#line 295
    memcpy((void *)p, (void const   *)(& i64), (unsigned int )sizeof(i64));
  } else {
#line 297
    __libc_failwith((char *)"Assertion failed: NULL at ziplist.c:297");
  }
#line 299
  return;
}
}
#line 302 "ziplist.c"
static int64_t zipLoadInteger(unsigned char *p , unsigned char encoding ) 
{ int16_t i16 ;
  int32_t i32 ;
  int64_t i64 ;
  int64_t ret ;

  {
#line 305
  ret = 0LL;
#line 306
  if ((int )encoding == 192) {
#line 307
    memcpy((void *)(& i16), (void const   *)p, (unsigned int )sizeof(i16));
#line 308
    ret = (long long )i16;
  } else
#line 309
  if ((int )encoding == (192 | (1 << 4))) {
#line 310
    memcpy((void *)(& i32), (void const   *)p, (unsigned int )sizeof(i32));
#line 311
    ret = (long long )i32;
  } else
#line 312
  if ((int )encoding == (192 | (2 << 4))) {
#line 313
    memcpy((void *)(& i64), (void const   *)p, (unsigned int )sizeof(i64));
#line 314
    ret = i64;
  } else {
#line 316
    __libc_failwith((char *)"Assertion failed: NULL at ziplist.c:316");
  }
#line 318
  return (ret);
}
}
#line 322 "ziplist.c"
static zlentry zipEntry(unsigned char *p ) 
{ zlentry e ;
  unsigned int __cil_tmp ;

  {
#line 324
  e.prevrawlen = zipPrevDecodeLength(p, & e.prevrawlensize);
#line 325
  e.len = zipDecodeLength(p + e.prevrawlensize, & e.lensize);
#line 326
  e.headersize = e.prevrawlensize + e.lensize;
#line 327
  __cil_tmp = zipEntryEncoding(p + e.prevrawlensize);
#line 327
  e.encoding = (unsigned char )__cil_tmp;
#line 328
  e.p = p;
#line 329
  return (e);
}
}
#line 333 "ziplist.c"
static unsigned int zipRawEntryLength(unsigned char *p ) 
{ zlentry e ;
  zlentry __cil_tmp ;

  {
#line 334
  __cil_tmp = zipEntry(p);
#line 334
  e = __cil_tmp;
#line 335
  return (e.headersize + e.len);
}
}
#line 339 "ziplist.c"
unsigned char *ziplistNew(void) 
{ unsigned int bytes ;
  unsigned char *zl ;
  void *__cil_tmp ;

  {
#line 340
  bytes = (unsigned int )((sizeof(uint32_t ) * 2UL + sizeof(uint16_t )) + 1UL);
#line 341
  __cil_tmp = malloc(bytes);
#line 341
  zl = (unsigned char *)__cil_tmp;
#line 342
  *((uint32_t *)zl) = (unsigned long )bytes;
#line 343
  *((uint32_t *)(zl + sizeof(uint32_t ))) = sizeof(uint32_t ) * 2UL + sizeof(uint16_t );
#line 344
  *((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) = (unsigned short)0;
#line 345
  *(zl + (bytes - 1U)) = (unsigned char)255;
#line 346
  return (zl);
}
}
#line 350 "ziplist.c"
static unsigned char *ziplistResize(unsigned char *zl , unsigned int len ) 
{ void *__cil_tmp ;

  {
#line 351
  __cil_tmp = realloc((void *)zl, len);
#line 351
  zl = (unsigned char *)__cil_tmp;
#line 352
  *((uint32_t *)zl) = (unsigned long )len;
#line 353
  *(zl + (len - 1U)) = (unsigned char)255;
#line 354
  return (zl);
}
}
#line 377 "ziplist.c"
static unsigned char *__ziplistCascadeUpdate(unsigned char *zl , unsigned char *p ) 
{ unsigned int curlen ;
  unsigned int rawlen ;
  unsigned int rawlensize ;
  unsigned int offset ;
  unsigned int noffset ;
  unsigned int extra ;
  unsigned char *np ;
  zlentry cur ;
  zlentry next ;

  {
#line 378
  curlen = (unsigned int )*((uint32_t *)zl);
#line 383
  while ((int )*(p + 0) != 255) {
#line 384
    cur = zipEntry(p);
#line 385
    rawlen = cur.headersize + cur.len;
#line 386
    rawlensize = zipPrevEncodeLength((unsigned char *)((void *)0), rawlen);
#line 389
    if ((int )*(p + rawlen) == 255) {
#line 389
      break;
    }
#line 390
    next = zipEntry(p + rawlen);
#line 393
    if (next.prevrawlen == rawlen) {
#line 393
      break;
    }
#line 395
    if (next.prevrawlensize < rawlensize) {
#line 398
      offset = (unsigned int )(p - zl);
#line 399
      extra = rawlensize - next.prevrawlensize;
#line 400
      zl = ziplistResize(zl, curlen + extra);
#line 401
      *((uint32_t *)(zl + sizeof(uint32_t ))) += (unsigned long )extra;
#line 402
      p = zl + offset;
#line 405
      np = p + rawlen;
#line 406
      noffset = (unsigned int )(np - zl);
#line 407
      memmove((void *)(np + rawlensize), (void const   *)(np + next.prevrawlensize),
              ((curlen - noffset) - next.prevrawlensize) - 1U);
#line 410
      zipPrevEncodeLength(np, rawlen);
#line 413
      p += rawlen;
#line 414
      curlen += extra;
    } else {
#line 416
      if (next.prevrawlensize > rawlensize) {
#line 419
        zipPrevEncodeLengthForceLarge(p + rawlen, rawlen);
      } else {
#line 421
        zipPrevEncodeLength(p + rawlen, rawlen);
      }
#line 425
      break;
    }
  }
#line 428
  return (zl);
}
}
#line 432 "ziplist.c"
static unsigned char *__ziplistDelete(unsigned char *zl , unsigned char *p , unsigned int num ) 
{ unsigned int i ;
  unsigned int totlen ;
  unsigned int deleted ;
  int offset ;
  int nextdiff ;
  zlentry first ;
  zlentry tail ;
  unsigned int __cil_tmp ;

  {
#line 433
  deleted = 0U;
#line 434
  nextdiff = 0;
#line 437
  first = zipEntry(p);
#line 438
  i = 0U;
#line 438
  while ((int )*(p + 0) != 255 && i < num) {
#line 439
    __cil_tmp = zipRawEntryLength(p);
#line 439
    p += __cil_tmp;
#line 440
    deleted ++;
#line 438
    i ++;
  }
#line 443
  totlen = (unsigned int )(p - first.p);
#line 444
  if (totlen > 0U) {
#line 445
    if ((int )*(p + 0) != 255) {
#line 450
      nextdiff = zipPrevLenByteDiff(p, first.prevrawlen);
#line 451
      zipPrevEncodeLength(p - nextdiff, first.prevrawlen);
#line 454
      *((uint32_t *)(zl + sizeof(uint32_t ))) -= (unsigned long )totlen;
#line 459
      tail = zipEntry(p);
#line 460
      if ((int )*(p + (tail.headersize + tail.len)) != 255) {
#line 461
        *((uint32_t *)(zl + sizeof(uint32_t ))) += (unsigned long )nextdiff;
      }
#line 464
      memmove((void *)first.p, (void const   *)(p - nextdiff), (unsigned int )(((*((uint32_t *)zl) - (unsigned long )(p - zl)) - 1UL) + (unsigned long )nextdiff));
    } else {
#line 467
      *((uint32_t *)(zl + sizeof(uint32_t ))) = (unsigned long )((unsigned int )(first.p - zl) - first.prevrawlen);
    }
#line 471
    offset = first.p - zl;
#line 472
    zl = ziplistResize(zl, (unsigned int )((*((uint32_t *)zl) - (unsigned long )totlen) + (unsigned long )nextdiff));
#line 473
    if ((int )*((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) < 65535) {
#line 473
      *((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) = (unsigned short )((unsigned int )*((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) + - deleted);
    }
#line 474
    p = zl + offset;
#line 478
    if (nextdiff != 0) {
#line 479
      zl = __ziplistCascadeUpdate(zl, p);
    }
  }
#line 481
  return (zl);
}
}
#line 485 "ziplist.c"
static unsigned char *__ziplistInsert(unsigned char *zl , unsigned char *p , unsigned char *s ,
                                      unsigned int slen ) 
{ unsigned int curlen ;
  unsigned int reqlen ;
  unsigned int prevlen ;
  unsigned int offset ;
  unsigned int nextdiff ;
  unsigned char encoding ;
  long long value ;
  zlentry entry ;
  zlentry tail ;
  unsigned char *ptail ;
  int __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  unsigned int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  unsigned int __cil_tmp___3 ;
  unsigned int __cil_tmp___4 ;

  {
#line 486
  curlen = (unsigned int )*((uint32_t *)zl);
#line 486
  prevlen = 0U;
#line 487
  nextdiff = 0U;
#line 488
  encoding = (unsigned char)0;
#line 493
  if ((int )*(p + 0) != 255) {
#line 494
    entry = zipEntry(p);
#line 495
    prevlen = entry.prevrawlen;
  } else {
#line 497
    ptail = zl + *((uint32_t *)(zl + sizeof(uint32_t )));
#line 498
    if ((int )*(ptail + 0) != 255) {
#line 499
      prevlen = zipRawEntryLength(ptail);
    }
  }
#line 504
  __cil_tmp = zipTryEncoding(s, slen, & value, & encoding);
#line 504
  if (__cil_tmp) {
#line 506
    reqlen = zipIntSize(encoding);
  } else {
#line 510
    reqlen = slen;
  }
#line 514
  __cil_tmp___0 = zipPrevEncodeLength((unsigned char *)((void *)0), prevlen);
#line 514
  reqlen += __cil_tmp___0;
#line 515
  __cil_tmp___1 = zipEncodeLength((unsigned char *)((void *)0), encoding, slen);
#line 515
  reqlen += __cil_tmp___1;
#line 520
  if ((int )*(p + 0) != 255) {
#line 520
    __cil_tmp___2 = zipPrevLenByteDiff(p, reqlen);
#line 520
    nextdiff = (unsigned int )__cil_tmp___2;
  } else {
#line 520
    nextdiff = 0U;
  }
#line 523
  offset = (unsigned int )(p - zl);
#line 524
  zl = ziplistResize(zl, (curlen + reqlen) + nextdiff);
#line 525
  p = zl + offset;
#line 528
  if ((int )*(p + 0) != 255) {
#line 530
    memmove((void *)(p + reqlen), (void const   *)(p - nextdiff), ((curlen - offset) - 1U) + nextdiff);
#line 533
    zipPrevEncodeLength(p + reqlen, reqlen);
#line 536
    *((uint32_t *)(zl + sizeof(uint32_t ))) += (unsigned long )reqlen;
#line 541
    tail = zipEntry(p + reqlen);
#line 542
    if ((int )*(p + ((reqlen + tail.headersize) + tail.len)) != 255) {
#line 543
      *((uint32_t *)(zl + sizeof(uint32_t ))) += (unsigned long )nextdiff;
    }
  } else {
#line 546
    *((uint32_t *)(zl + sizeof(uint32_t ))) = (unsigned long )(p - zl);
  }
#line 551
  if (nextdiff != 0U) {
#line 552
    offset = (unsigned int )(p - zl);
#line 553
    zl = __ziplistCascadeUpdate(zl, p + reqlen);
#line 554
    p = zl + offset;
  }
#line 558
  __cil_tmp___3 = zipPrevEncodeLength(p, prevlen);
#line 558
  p += __cil_tmp___3;
#line 559
  __cil_tmp___4 = zipEncodeLength(p, encoding, slen);
#line 559
  p += __cil_tmp___4;
#line 560
  if (((int )encoding & 192) < 192) {
#line 561
    memcpy((void *)p, (void const   *)s, slen);
  } else {
#line 563
    zipSaveInteger(p, value, encoding);
  }
#line 565
  if ((int )*((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) < 65535) {
#line 565
    *((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) = (unsigned short )((int )*((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) + 1);
  }
#line 566
  return (zl);
}
}
#line 569 "ziplist.c"
unsigned char *ziplistPush(unsigned char *zl , unsigned char *s , unsigned int slen ,
                           int where ) 
{ unsigned char *p ;
  unsigned char *__cil_tmp ;

  {
#line 571
  p = where == 0 ? zl + (sizeof(uint32_t ) * 2UL + sizeof(uint16_t )) : (zl + *((uint32_t *)zl)) - 1;
#line 572
  __cil_tmp = __ziplistInsert(zl, p, s, slen);
#line 572
  return (__cil_tmp);
}
}
#line 578 "ziplist.c"
unsigned char *ziplistIndex(unsigned char *zl , int index___0 ) 
{ unsigned char *p ;
  zlentry entry ;
  int __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 581
  if (index___0 < 0) {
#line 582
    index___0 = - index___0 - 1;
#line 583
    p = zl + *((uint32_t *)(zl + sizeof(uint32_t )));
#line 584
    if ((int )*(p + 0) != 255) {
#line 585
      entry = zipEntry(p);
#line 586
      while (1) {
#line 586
        if (entry.prevrawlen > 0U) {
#line 586
          __cil_tmp = index___0;
#line 586
          index___0 --;
#line 586
          if (! __cil_tmp) {
#line 586
            break;
          }
        } else {
#line 586
          break;
        }
#line 587
        p -= entry.prevrawlen;
#line 588
        entry = zipEntry(p);
      }
    }
  } else {
#line 592
    p = zl + (sizeof(uint32_t ) * 2UL + sizeof(uint16_t ));
#line 593
    while (1) {
#line 593
      if ((int )*(p + 0) != 255) {
#line 593
        __cil_tmp___1 = index___0;
#line 593
        index___0 --;
#line 593
        if (! __cil_tmp___1) {
#line 593
          break;
        }
      } else {
#line 593
        break;
      }
#line 594
      __cil_tmp___0 = zipRawEntryLength(p);
#line 594
      p += __cil_tmp___0;
    }
  }
#line 597
  return ((int )*(p + 0) == 255 || index___0 > 0 ? (unsigned char *)((void *)0) : p);
}
}
#line 606 "ziplist.c"
unsigned char *ziplistNext(unsigned char *zl , unsigned char *p ) 
{ unsigned int __cil_tmp ;

  {
#line 612
  if ((int )*(p + 0) == 255) {
#line 613
    return ((unsigned char *)((void *)0));
  } else {
#line 615
    __cil_tmp = zipRawEntryLength(p);
#line 615
    p += __cil_tmp;
#line 616
    return ((int )*(p + 0) == 255 ? (unsigned char *)((void *)0) : p);
  }
}
}
#line 621 "ziplist.c"
unsigned char *ziplistPrev(unsigned char *zl , unsigned char *p ) 
{ zlentry entry ;

  {
#line 627
  if ((int )*(p + 0) == 255) {
#line 628
    p = zl + *((uint32_t *)(zl + sizeof(uint32_t )));
#line 629
    return ((int )*(p + 0) == 255 ? (unsigned char *)((void *)0) : p);
  } else
#line 630
  if ((unsigned int )p == (unsigned int )(zl + (sizeof(uint32_t ) * 2UL + sizeof(uint16_t )))) {
#line 631
    return ((unsigned char *)((void *)0));
  } else {
#line 633
    entry = zipEntry(p);
#line 634
    if ((entry.prevrawlen > 0U) == 0) {
#line 634
      __libc_failwith((char *)"Assertion failed: entry.prevrawlen > 0 at ziplist.c:634");
    }
#line 635
    return (p - entry.prevrawlen);
  }
}
}
#line 643 "ziplist.c"
unsigned int ziplistGet(unsigned char *p , unsigned char **sstr , unsigned int *slen ,
                        long long *sval ) 
{ zlentry entry ;

  {
#line 645
  if ((unsigned int )p == (unsigned int )((void *)0) || (int )*(p + 0) == 255) {
#line 645
    return (0U);
  }
#line 646
  if (sstr) {
#line 646
    *sstr = (unsigned char *)((void *)0);
  }
#line 648
  entry = zipEntry(p);
#line 649
  if (((int )entry.encoding & 192) < 192) {
#line 650
    if (sstr) {
#line 651
      *slen = entry.len;
#line 652
      *sstr = p + entry.headersize;
    }
  } else
#line 655
  if (sval) {
#line 656
    *sval = zipLoadInteger(p + entry.headersize, entry.encoding);
  }
#line 659
  return (1U);
}
}
#line 663 "ziplist.c"
unsigned char *ziplistInsert(unsigned char *zl , unsigned char *p , unsigned char *s ,
                             unsigned int slen ) 
{ unsigned char *__cil_tmp ;

  {
#line 664
  __cil_tmp = __ziplistInsert(zl, p, s, slen);
#line 664
  return (__cil_tmp);
}
}
#line 670 "ziplist.c"
unsigned char *ziplistDelete(unsigned char *zl , unsigned char **p ) 
{ unsigned int offset ;

  {
#line 671
  offset = (unsigned int )(*p - zl);
#line 672
  zl = __ziplistDelete(zl, *p, 1U);
#line 678
  *p = zl + offset;
#line 679
  return (zl);
}
}
#line 683 "ziplist.c"
unsigned char *ziplistDeleteRange(unsigned char *zl , unsigned int index___0 , unsigned int num ) 
{ unsigned char *p ;
  unsigned char *__cil_tmp ;
  unsigned char *__cil_tmp___0 ;
  unsigned char *__cil_tmp___1 ;

  {
#line 684
  __cil_tmp = ziplistIndex(zl, (int )index___0);
#line 684
  p = __cil_tmp;
#line 685
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 685
    __cil_tmp___1 = zl;
  } else {
#line 685
    __cil_tmp___0 = __ziplistDelete(zl, p, num);
#line 685
    __cil_tmp___1 = __cil_tmp___0;
  }
#line 685
  return (__cil_tmp___1);
}
}
#line 689 "ziplist.c"
unsigned int ziplistCompare(unsigned char *p , unsigned char *sstr , unsigned int slen ) 
{ zlentry entry ;
  unsigned char sencoding ;
  long long zval ;
  long long sval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 693
  if ((int )*(p + 0) == 255) {
#line 693
    return (0U);
  }
#line 695
  entry = zipEntry(p);
#line 696
  if (((int )entry.encoding & 192) < 192) {
#line 698
    if (entry.len == slen) {
#line 699
      __cil_tmp = memcmp((void const   *)(p + entry.headersize), (void const   *)sstr,
                         slen);
#line 699
      return ((unsigned int )(__cil_tmp == 0));
    } else {
#line 701
      return (0U);
    }
  } else {
#line 705
    __cil_tmp___0 = zipTryEncoding(sstr, slen, & sval, & sencoding);
#line 705
    if (__cil_tmp___0) {
#line 706
      if ((int )entry.encoding == (int )sencoding) {
#line 707
        zval = zipLoadInteger(p + entry.headersize, entry.encoding);
#line 708
        return ((unsigned int )(zval == sval));
      }
    }
  }
#line 712
  return (0U);
}
}
#line 716 "ziplist.c"
unsigned int ziplistLen(unsigned char *zl ) 
{ unsigned int len ;
  unsigned char *p ;
  unsigned int __cil_tmp ;

  {
#line 717
  len = 0U;
#line 718
  if ((int )*((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) < 65535) {
#line 719
    len = (unsigned int )*((uint16_t *)(zl + sizeof(uint32_t ) * 2UL));
  } else {
#line 721
    p = zl + (sizeof(uint32_t ) * 2UL + sizeof(uint16_t ));
#line 722
    while ((int )*p != 255) {
#line 723
      __cil_tmp = zipRawEntryLength(p);
#line 723
      p += __cil_tmp;
#line 724
      len ++;
    }
#line 728
    if (len < 65535U) {
#line 728
      *((uint16_t *)(zl + sizeof(uint32_t ) * 2UL)) = (unsigned short )len;
    }
  }
#line 730
  return (len);
}
}
#line 734 "ziplist.c"
unsigned int ziplistSize(unsigned char *zl ) 
{ 

  {
#line 735
  return ((unsigned int )*((uint32_t *)zl));
}
}
#line 1 "release.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-BPoEyrT5.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 7 "release.c"
char *redisGitSHA1(void) 
{ 

  {
#line 8
  return ((char *)"00000000");
}
}
#line 11 "release.c"
char *redisGitDirty(void) 
{ 

  {
#line 12
  return ((char *)"       0");
}
}
#line 1 "networking.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-3rHRTqWG.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 267 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int ( /* format attribute */  snprintf)(char *str , size_t size , char const   *fmt 
                                        , ...) ;
#line 41 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
char *strstr(char const   *searchee , char const   *lookfor ) ;
#line 217 "redis.h"
void _redisPanic(char *msg , char *file , int line ) ;
#line 635
redisClient *createClient(int fd ) ;
#line 637
void freeClient(redisClient *c ) ;
#line 639
void sendReplyToClient(aeEventLoop *el , int fd , void *privdata , int mask ) ;
#line 641
void *addDeferredMultiBulkLength(redisClient *c ) ;
#line 642
void setDeferredMultiBulkLength(redisClient *c , void *node , long length ) ;
#line 649
void addReplyBulkCString(redisClient *c , char *s ) ;
#line 650
void addReplyBulkCBuffer(redisClient *c , void *p , size_t len ) ;
#line 651
void addReplyBulkLongLong(redisClient *c , long long ll ) ;
#line 656
void addReplyStatus(redisClient *c , char *status ) ;
#line 657
void addReplyDouble(redisClient *c , double d ) ;
#line 658
void addReplyLongLong(redisClient *c , long long ll ) ;
#line 659
void addReplyMultiBulkLen(redisClient *c , long length ) ;
#line 660
void *dupClientReplyValue(void *o ) ;
#line 667
void addReplyStatusFormat(redisClient *c , char const   *fmt  , ...) ;
#line 687
void unblockClientWaitingData(redisClient *c ) ;
#line 692
void unwatchAllKeys(redisClient *c ) ;
#line 693
void initClientMultiState(redisClient *c ) ;
#line 694
void freeClientMultiState(redisClient *c ) ;
#line 701
void incrRefCount(robj *o ) ;
#line 709
robj *dupStringObject(robj *o ) ;
#line 727
int equalStringObjects(robj *a , robj *b ) ;
#line 815
int dontWaitForSwappedKey(redisClient *c , robj *key ) ;
#line 850
int pubsubUnsubscribeAllChannels(redisClient *c , int notify ) ;
#line 851
int pubsubUnsubscribeAllPatterns(redisClient *c , int notify ) ;
#line 887
int selectDb(redisClient *c , int id ) ;
#line 4 "networking.c"
void *dupClientReplyValue(void *o ) 
{ 

  {
#line 5
  incrRefCount((robj *)o);
#line 6
  return (o);
}
}
#line 9 "networking.c"
int listMatchObjects(void *a , void *b ) 
{ int __cil_tmp ;

  {
#line 10
  __cil_tmp = equalStringObjects((robj *)a, (robj *)b);
#line 10
  return (__cil_tmp);
}
}
#line 13 "networking.c"
redisClient *createClient(int fd ) 
{ redisClient *c ;
  void *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 14
  __cil_tmp = malloc((unsigned int )sizeof(redisClient ));
#line 14
  c = (redisClient *)__cil_tmp;
#line 15
  c->bufpos = 0;
#line 17
  anetNonBlock((char *)((void *)0), fd);
#line 18
  anetTcpNoDelay((char *)((void *)0), fd);
#line 19
  if (! c) {
#line 19
    return ((redisClient *)((void *)0));
  }
#line 20
  __cil_tmp___0 = aeCreateFileEvent(server.el, fd, 1, & readQueryFromClient, (void *)c);
#line 20
  if (__cil_tmp___0 == -1) {
#line 23
    close(fd);
#line 24
    free((void *)c);
#line 25
    return ((redisClient *)((void *)0));
  }
#line 28
  selectDb(c, 0);
#line 29
  c->fd = fd;
#line 30
  c->querybuf = sdsempty();
#line 31
  c->reqtype = 0;
#line 32
  c->argc = 0;
#line 33
  c->argv = (robj **)((void *)0);
#line 34
  c->multibulklen = 0;
#line 35
  c->bulklen = -1L;
#line 36
  c->sentlen = 0;
#line 37
  c->flags = 0;
#line 38
  c->lastinteraction = time((time_t *)((void *)0));
#line 39
  c->authenticated = 0;
#line 40
  c->replstate = 0;
#line 41
  c->reply = listCreate();
#line 42
  (c->reply)->free = & decrRefCount;
#line 43
  (c->reply)->dup = & dupClientReplyValue;
#line 44
  c->bpop.keys = (robj **)((void *)0);
#line 45
  c->bpop.count = 0;
#line 46
  c->bpop.timeout = 0L;
#line 47
  c->bpop.target = (robj *)((void *)0);
#line 48
  c->io_keys = listCreate();
#line 49
  c->watched_keys = listCreate();
#line 50
  (c->io_keys)->free = & decrRefCount;
#line 51
  c->pubsub_channels = dictCreate(& setDictType, (void *)0);
#line 52
  c->pubsub_patterns = listCreate();
#line 53
  (c->pubsub_patterns)->free = & decrRefCount;
#line 54
  (c->pubsub_patterns)->match = & listMatchObjects;
#line 55
  listAddNodeTail(server.clients, (void *)c);
#line 56
  initClientMultiState(c);
#line 57
  return (c);
}
}
#line 62 "networking.c"
int _installWriteEvent(redisClient *c ) 
{ int __cil_tmp ;

  {
#line 64
  if (! (! (c->flags & 128))) {
#line 64
    _redisAssert((char *)"!(c->flags & REDIS_CLOSE_AFTER_REPLY)", (char *)"networking.c",
                 64);
#line 64
    _exit(1);
  }
#line 66
  if (c->fd <= 0) {
#line 66
    return (-1);
  }
#line 67
  if ((c->bufpos == 0 && (c->reply)->len == 0U) && (c->replstate == 0 || c->replstate == 6)) {
#line 67
    __cil_tmp = aeCreateFileEvent(server.el, c->fd, 2, & sendReplyToClient, (void *)c);
#line 67
    if (__cil_tmp == -1) {
#line 71
      return (-1);
    }
  }
#line 72
  return (0);
}
}
#line 77 "networking.c"
robj *dupLastObjectIfNeeded(list *reply ) 
{ robj *new ;
  robj *cur ;
  listNode *ln ;

  {
#line 80
  if (! (reply->len > 0U)) {
#line 80
    _redisAssert((char *)"listLength(reply) > 0", (char *)"networking.c", 80);
#line 80
    _exit(1);
  }
#line 81
  ln = reply->tail;
#line 82
  cur = (robj *)ln->value;
#line 83
  if (cur->refcount > 1) {
#line 84
    new = dupStringObject(cur);
#line 85
    decrRefCount((void *)cur);
#line 86
    ln->value = (void *)new;
  }
#line 88
  return ((robj *)ln->value);
}
}
#line 91 "networking.c"
int _addReplyToBuffer(redisClient *c , char *s , size_t len ) 
{ size_t available ;

  {
#line 92
  available = (unsigned int )(sizeof(c->buf) - (unsigned long )c->bufpos);
#line 96
  if ((c->reply)->len > 0U) {
#line 96
    return (-1);
  }
#line 99
  if (len > available) {
#line 99
    return (-1);
  }
#line 101
  memcpy((void *)(c->buf + c->bufpos), (void const   *)s, len);
#line 102
  c->bufpos = (int )((unsigned int )c->bufpos + len);
#line 103
  return (0);
}
}
#line 106 "networking.c"
void _addReplyObjectToList(redisClient *c , robj *o ) 
{ robj *tail ;
  size_t __cil_tmp ;
  sds __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 108
  if ((c->reply)->len == 0U) {
#line 109
    incrRefCount(o);
#line 110
    listAddNodeTail(c->reply, (void *)o);
  } else {
#line 112
    tail = (robj *)((c->reply)->tail)->value;
#line 115
    if ((unsigned int )tail->ptr != (unsigned int )((void *)0)) {
#line 115
      __cil_tmp___1 = sdslen((char *)tail->ptr);
#line 115
      __cil_tmp___2 = sdslen((char *)o->ptr);
#line 115
      if (__cil_tmp___1 + __cil_tmp___2 <= 7500U) {
#line 118
        tail = dupLastObjectIfNeeded(c->reply);
#line 119
        __cil_tmp = sdslen((char *)o->ptr);
#line 119
        __cil_tmp___0 = sdscatlen((char *)tail->ptr, o->ptr, __cil_tmp);
#line 119
        tail->ptr = (void *)__cil_tmp___0;
      } else {
#line 121
        incrRefCount(o);
#line 122
        listAddNodeTail(c->reply, (void *)o);
      }
    } else {
#line 121
      incrRefCount(o);
#line 122
      listAddNodeTail(c->reply, (void *)o);
    }
  }
#line 125
  return;
}
}
#line 129 "networking.c"
void _addReplySdsToList(redisClient *c , sds s ) 
{ robj *tail ;
  robj *__cil_tmp ;
  size_t __cil_tmp___0 ;
  sds __cil_tmp___1 ;
  robj *__cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  size_t __cil_tmp___4 ;

  {
#line 131
  if ((c->reply)->len == 0U) {
#line 132
    __cil_tmp = createObject(0, (void *)s);
#line 132
    listAddNodeTail(c->reply, (void *)__cil_tmp);
  } else {
#line 134
    tail = (robj *)((c->reply)->tail)->value;
#line 137
    if ((unsigned int )tail->ptr != (unsigned int )((void *)0)) {
#line 137
      __cil_tmp___3 = sdslen((char *)tail->ptr);
#line 137
      __cil_tmp___4 = sdslen(s);
#line 137
      if (__cil_tmp___3 + __cil_tmp___4 <= 7500U) {
#line 140
        tail = dupLastObjectIfNeeded(c->reply);
#line 141
        __cil_tmp___0 = sdslen(s);
#line 141
        __cil_tmp___1 = sdscatlen((char *)tail->ptr, (void *)s, __cil_tmp___0);
#line 141
        tail->ptr = (void *)__cil_tmp___1;
#line 142
        sdsfree(s);
      } else {
#line 144
        __cil_tmp___2 = createObject(0, (void *)s);
#line 144
        listAddNodeTail(c->reply, (void *)__cil_tmp___2);
      }
    } else {
#line 144
      __cil_tmp___2 = createObject(0, (void *)s);
#line 144
      listAddNodeTail(c->reply, (void *)__cil_tmp___2);
    }
  }
#line 147
  return;
}
}
#line 149 "networking.c"
void _addReplyStringToList(redisClient *c , char *s , size_t len ) 
{ robj *tail ;
  robj *__cil_tmp ;
  sds __cil_tmp___0 ;
  robj *__cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 151
  if ((c->reply)->len == 0U) {
#line 152
    __cil_tmp = createStringObject(s, len);
#line 152
    listAddNodeTail(c->reply, (void *)__cil_tmp);
  } else {
#line 154
    tail = (robj *)((c->reply)->tail)->value;
#line 157
    if ((unsigned int )tail->ptr != (unsigned int )((void *)0)) {
#line 157
      __cil_tmp___2 = sdslen((char *)tail->ptr);
#line 157
      if (__cil_tmp___2 + len <= 7500U) {
#line 160
        tail = dupLastObjectIfNeeded(c->reply);
#line 161
        __cil_tmp___0 = sdscatlen((char *)tail->ptr, (void *)s, len);
#line 161
        tail->ptr = (void *)__cil_tmp___0;
      } else {
#line 163
        __cil_tmp___1 = createStringObject(s, len);
#line 163
        listAddNodeTail(c->reply, (void *)__cil_tmp___1);
      }
    } else {
#line 163
      __cil_tmp___1 = createStringObject(s, len);
#line 163
      listAddNodeTail(c->reply, (void *)__cil_tmp___1);
    }
  }
#line 166
  return;
}
}
#line 168 "networking.c"
void addReply(redisClient *c , robj *obj ) 
{ int __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 169
  __cil_tmp = _installWriteEvent(c);
#line 169
  if (__cil_tmp != 0) {
#line 169
    return;
  }
#line 170
  if (! (! server.vm_enabled || obj->storage == 0U)) {
#line 170
    _redisAssert((char *)"!server.vm_enabled || obj->storage == REDIS_VM_MEMORY",
                 (char *)"networking.c", 170);
#line 170
    _exit(1);
  }
#line 179
  if (obj->encoding == 0U) {
#line 180
    __cil_tmp___0 = sdslen((char *)obj->ptr);
#line 180
    __cil_tmp___1 = _addReplyToBuffer(c, (char *)obj->ptr, __cil_tmp___0);
#line 180
    if (__cil_tmp___1 != 0) {
#line 181
      _addReplyObjectToList(c, obj);
    }
  } else {
#line 186
    obj = getDecodedObject(obj);
#line 187
    __cil_tmp___2 = sdslen((char *)obj->ptr);
#line 187
    __cil_tmp___3 = _addReplyToBuffer(c, (char *)obj->ptr, __cil_tmp___2);
#line 187
    if (__cil_tmp___3 != 0) {
#line 188
      _addReplyObjectToList(c, obj);
    }
#line 189
    decrRefCount((void *)obj);
  }
#line 191
  return;
}
}
#line 193 "networking.c"
void addReplySds(redisClient *c , sds s ) 
{ int __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 194
  __cil_tmp = _installWriteEvent(c);
#line 194
  if (__cil_tmp != 0) {
#line 196
    sdsfree(s);
#line 197
    return;
  }
#line 199
  __cil_tmp___0 = sdslen(s);
#line 199
  __cil_tmp___1 = _addReplyToBuffer(c, s, __cil_tmp___0);
#line 199
  if (__cil_tmp___1 == 0) {
#line 200
    sdsfree(s);
  } else {
#line 203
    _addReplySdsToList(c, s);
  }
#line 205
  return;
}
}
#line 207 "networking.c"
void addReplyString(redisClient *c , char *s , size_t len ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 208
  __cil_tmp = _installWriteEvent(c);
#line 208
  if (__cil_tmp != 0) {
#line 208
    return;
  }
#line 209
  __cil_tmp___0 = _addReplyToBuffer(c, s, len);
#line 209
  if (__cil_tmp___0 != 0) {
#line 210
    _addReplyStringToList(c, s, len);
  }
#line 211
  return;
}
}
#line 213 "networking.c"
void _addReplyError(redisClient *c , char *s , size_t len ) 
{ 

  {
#line 214
  addReplyString(c, (char *)"-ERR ", 5U);
#line 215
  addReplyString(c, s, len);
#line 216
  addReplyString(c, (char *)"\r\n", 2U);
#line 217
  return;
}
}
#line 219 "networking.c"
void addReplyError(redisClient *c , char *err ) 
{ size_t __cil_tmp ;

  {
#line 220
  __cil_tmp = strlen((char const   *)err);
#line 220
  _addReplyError(c, err, __cil_tmp);
#line 221
  return;
}
}
#line 223 "networking.c"
void addReplyErrorFormat(redisClient *c , char const   *fmt  , ...) 
{ va_list ap ;
  sds s ;
  sds __cil_tmp ;
  sds __cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 225
  __builtin_va_start(ap, fmt);
#line 226
  __cil_tmp = sdsempty();
#line 226
  __cil_tmp___0 = sdscatvprintf(__cil_tmp, fmt, ap);
#line 226
  s = __cil_tmp___0;
#line 227
  __builtin_va_end(ap);
#line 228
  __cil_tmp___1 = sdslen(s);
#line 228
  _addReplyError(c, s, __cil_tmp___1);
#line 229
  sdsfree(s);
#line 230
  return;
}
}
#line 232 "networking.c"
void _addReplyStatus(redisClient *c , char *s , size_t len ) 
{ 

  {
#line 233
  addReplyString(c, (char *)"+", 1U);
#line 234
  addReplyString(c, s, len);
#line 235
  addReplyString(c, (char *)"\r\n", 2U);
#line 236
  return;
}
}
#line 238 "networking.c"
void addReplyStatus(redisClient *c , char *status ) 
{ size_t __cil_tmp ;

  {
#line 239
  __cil_tmp = strlen((char const   *)status);
#line 239
  _addReplyStatus(c, status, __cil_tmp);
#line 240
  return;
}
}
#line 242 "networking.c"
void addReplyStatusFormat(redisClient *c , char const   *fmt  , ...) 
{ va_list ap ;
  sds s ;
  sds __cil_tmp ;
  sds __cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 244
  __builtin_va_start(ap, fmt);
#line 245
  __cil_tmp = sdsempty();
#line 245
  __cil_tmp___0 = sdscatvprintf(__cil_tmp, fmt, ap);
#line 245
  s = __cil_tmp___0;
#line 246
  __builtin_va_end(ap);
#line 247
  __cil_tmp___1 = sdslen(s);
#line 247
  _addReplyStatus(c, s, __cil_tmp___1);
#line 248
  sdsfree(s);
#line 249
  return;
}
}
#line 253 "networking.c"
void *addDeferredMultiBulkLength(redisClient *c ) 
{ int __cil_tmp ;
  robj *__cil_tmp___0 ;

  {
#line 257
  __cil_tmp = _installWriteEvent(c);
#line 257
  if (__cil_tmp != 0) {
#line 257
    return ((void *)0);
  }
#line 258
  __cil_tmp___0 = createObject(0, (void *)0);
#line 258
  listAddNodeTail(c->reply, (void *)__cil_tmp___0);
#line 259
  return ((void *)(c->reply)->tail);
}
}
#line 263 "networking.c"
void setDeferredMultiBulkLength(redisClient *c , void *node , long length ) 
{ listNode *ln ;
  robj *len ;
  robj *next ;
  sds __cil_tmp ;
  sds __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  sds __cil_tmp___2 ;

  {
#line 264
  ln = (listNode *)node;
#line 268
  if ((unsigned int )node == (unsigned int )((void *)0)) {
#line 268
    return;
  }
#line 270
  len = (robj *)ln->value;
#line 271
  __cil_tmp = sdsempty();
#line 271
  __cil_tmp___0 = sdscatprintf(__cil_tmp, "*%ld\r\n", length);
#line 271
  len->ptr = (void *)__cil_tmp___0;
#line 272
  if ((unsigned int )ln->next != (unsigned int )((void *)0)) {
#line 273
    next = (robj *)(ln->next)->value;
#line 276
    if ((unsigned int )next->ptr != (unsigned int )((void *)0)) {
#line 277
      __cil_tmp___1 = sdslen((char *)next->ptr);
#line 277
      __cil_tmp___2 = sdscatlen((char *)len->ptr, next->ptr, __cil_tmp___1);
#line 277
      len->ptr = (void *)__cil_tmp___2;
#line 278
      listDelNode(c->reply, ln->next);
    }
  }
#line 281
  return;
}
}
#line 284 "networking.c"
void addReplyDouble(redisClient *c , double d ) 
{ char dbuf[128] ;
  char sbuf[128] ;
  int dlen ;
  int slen ;

  {
#line 287
  dlen = snprintf(dbuf, (unsigned int )sizeof(dbuf), "%.17g", d);
#line 288
  slen = snprintf(sbuf, (unsigned int )sizeof(sbuf), "$%d\r\n%s\r\n", dlen, dbuf);
#line 289
  addReplyString(c, sbuf, (unsigned int )slen);
#line 290
  return;
}
}
#line 294 "networking.c"
void _addReplyLongLong(redisClient *c , long long ll , char prefix ) 
{ char buf[128] ;
  int len ;

  {
#line 297
  buf[0] = prefix;
#line 298
  len = ll2string(buf + 1, (unsigned int )(sizeof(buf) - 1UL), ll);
#line 299
  buf[len + 1] = (char )'\r';
#line 300
  buf[len + 2] = (char )'\n';
#line 301
  addReplyString(c, buf, (unsigned int )(len + 3));
#line 302
  return;
}
}
#line 304 "networking.c"
void addReplyLongLong(redisClient *c , long long ll ) 
{ 

  {
#line 305
  _addReplyLongLong(c, ll, (char )':');
#line 306
  return;
}
}
#line 308 "networking.c"
void addReplyMultiBulkLen(redisClient *c , long length ) 
{ 

  {
#line 309
  _addReplyLongLong(c, (long long )length, (char )'*');
#line 310
  return;
}
}
#line 313 "networking.c"
void addReplyBulkLen(redisClient *c , robj *obj ) 
{ size_t len ;
  long n ;

  {
#line 316
  if (obj->encoding == 0U) {
#line 317
    len = sdslen((char *)obj->ptr);
  } else {
#line 319
    n = (long )obj->ptr;
#line 322
    len = 1U;
#line 323
    if (n < 0L) {
#line 324
      len ++;
#line 325
      n = - n;
    }
#line 327
    while (1) {
#line 327
      n /= 10L;
#line 327
      if (! (n != 0L)) {
#line 327
        break;
      }
#line 328
      len ++;
    }
  }
#line 331
  _addReplyLongLong(c, (long long )len, (char )'$');
#line 332
  return;
}
}
#line 335 "networking.c"
void addReplyBulk(redisClient *c , robj *obj ) 
{ 

  {
#line 336
  addReplyBulkLen(c, obj);
#line 337
  addReply(c, obj);
#line 338
  addReply(c, shared.crlf);
#line 339
  return;
}
}
#line 342 "networking.c"
void addReplyBulkCBuffer(redisClient *c , void *p , size_t len ) 
{ 

  {
#line 343
  _addReplyLongLong(c, (long long )len, (char )'$');
#line 344
  addReplyString(c, (char *)p, len);
#line 345
  addReply(c, shared.crlf);
#line 346
  return;
}
}
#line 349 "networking.c"
void addReplyBulkCString(redisClient *c , char *s ) 
{ size_t __cil_tmp ;

  {
#line 350
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 351
    addReply(c, shared.nullbulk);
  } else {
#line 353
    __cil_tmp = strlen((char const   *)s);
#line 353
    addReplyBulkCBuffer(c, (void *)s, __cil_tmp);
  }
#line 355
  return;
}
}
#line 358 "networking.c"
void addReplyBulkLongLong(redisClient *c , long long ll ) 
{ char buf[64] ;
  int len ;

  {
#line 362
  len = ll2string(buf, 64U, ll);
#line 363
  addReplyBulkCBuffer(c, (void *)(buf), (unsigned int )len);
#line 364
  return;
}
}
#line 366 "networking.c"
static void acceptCommonHandler(int fd ) 
{ redisClient *c ;
  char *err ;
  size_t __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 368
  c = createClient(fd);
#line 368
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 369
    redisLog(3, "Error allocating resoures for the client");
#line 370
    close(fd);
#line 371
    return;
  }
#line 377
  if (server.maxclients && (server.clients)->len > server.maxclients) {
#line 378
    err = (char *)"-ERR max number of clients reached\r\n";
#line 381
    __cil_tmp = strlen((char const   *)err);
#line 381
    __cil_tmp___0 = write(c->fd, (void const   *)err, __cil_tmp);
#line 381
    if (__cil_tmp___0 == -1) {

    }
#line 384
    freeClient(c);
#line 385
    return;
  }
#line 387
  (server.stat_numconnections) ++;
#line 388
  return;
}
}
#line 390 "networking.c"
void acceptTcpHandler(aeEventLoop *el , int fd , void *privdata , int mask ) 
{ int cport ;
  int cfd ;
  char cip[128] ;

  {
#line 397
  cfd = anetTcpAccept(server.neterr, fd, cip, & cport);
#line 398
  if (cfd == -1) {
#line 399
    redisLog(1, "Accepting client connection: %s", server.neterr);
#line 400
    return;
  }
#line 402
  redisLog(1, "Accepted %s:%d", cip, cport);
#line 403
  acceptCommonHandler(cfd);
#line 404
  return;
}
}
#line 406 "networking.c"
void acceptUnixHandler(aeEventLoop *el , int fd , void *privdata , int mask ) 
{ int cfd ;

  {
#line 412
  cfd = anetUnixAccept(server.neterr, fd);
#line 413
  if (cfd == -1) {
#line 414
    redisLog(1, "Accepting client connection: %s", server.neterr);
#line 415
    return;
  }
#line 417
  redisLog(1, "Accepted connection to %s", server.unixsocket);
#line 418
  acceptCommonHandler(cfd);
#line 419
  return;
}
}
#line 422 "networking.c"
static void freeClientArgv(redisClient *c ) 
{ int j ;

  {
#line 424
  j = 0;
#line 424
  while (j < c->argc) {
#line 425
    decrRefCount((void *)*(c->argv + j));
#line 424
    j ++;
  }
#line 426
  c->argc = 0;
#line 427
  return;
}
}
#line 429 "networking.c"
void freeClient(redisClient *c ) 
{ listNode *ln ;
  list *l ;

  {
#line 437
  sdsfree(c->querybuf);
#line 438
  c->querybuf = (char *)((void *)0);
#line 439
  if (c->flags & 16) {
#line 440
    unblockClientWaitingData(c);
  }
#line 443
  unwatchAllKeys(c);
#line 444
  listRelease(c->watched_keys);
#line 446
  pubsubUnsubscribeAllChannels(c, 0);
#line 447
  pubsubUnsubscribeAllPatterns(c, 0);
#line 448
  dictRelease(c->pubsub_channels);
#line 449
  listRelease(c->pubsub_patterns);
#line 451
  aeDeleteFileEvent(server.el, c->fd, 1);
#line 452
  aeDeleteFileEvent(server.el, c->fd, 2);
#line 453
  listRelease(c->reply);
#line 454
  freeClientArgv(c);
#line 455
  close(c->fd);
#line 457
  ln = listSearchKey(server.clients, (void *)c);
#line 458
  if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 458
    _redisAssert((char *)"ln != NULL", (char *)"networking.c", 458);
#line 458
    _exit(1);
  }
#line 459
  listDelNode(server.clients, ln);
#line 462
  if (c->flags & 256) {
#line 463
    ln = listSearchKey(server.unblocked_clients, (void *)c);
#line 464
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 464
      _redisAssert((char *)"ln != NULL", (char *)"networking.c", 464);
#line 464
      _exit(1);
    }
#line 465
    listDelNode(server.unblocked_clients, ln);
  }
#line 469
  if (c->flags & 32) {
#line 470
    if (! server.vm_enabled) {
#line 470
      _redisAssert((char *)"server.vm_enabled", (char *)"networking.c", 470);
#line 470
      _exit(1);
    }
#line 471
    if ((c->io_keys)->len == 0U) {
#line 472
      ln = listSearchKey(server.io_ready_clients, (void *)c);
#line 476
      if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 476
        _redisAssert((char *)"ln != NULL", (char *)"networking.c", 476);
#line 476
        _exit(1);
      }
#line 477
      listDelNode(server.io_ready_clients, ln);
    } else {
#line 479
      while ((c->io_keys)->len) {
#line 480
        ln = (c->io_keys)->head;
#line 481
        dontWaitForSwappedKey(c, (robj *)ln->value);
      }
    }
#line 484
    (server.vm_blocked_clients) --;
  }
#line 486
  listRelease(c->io_keys);
#line 489
  if (c->flags & 1) {
#line 490
    if (c->replstate == 5 && c->repldbfd != -1) {
#line 491
      close(c->repldbfd);
    }
#line 492
    l = c->flags & 4 ? server.monitors : server.slaves;
#line 493
    ln = listSearchKey(l, (void *)c);
#line 494
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 494
      _redisAssert((char *)"ln != NULL", (char *)"networking.c", 494);
#line 494
      _exit(1);
    }
#line 495
    listDelNode(l, ln);
  }
#line 499
  if (c->flags & 2) {
#line 500
    server.master = (redisClient *)((void *)0);
#line 501
    server.replstate = 1;
#line 507
    while ((server.slaves)->len) {
#line 508
      ln = (server.slaves)->head;
#line 509
      freeClient((redisClient *)ln->value);
    }
  }
#line 513
  free((void *)c->argv);
#line 514
  freeClientMultiState(c);
#line 515
  free((void *)c);
#line 516
  return;
}
}
#line 518 "networking.c"
void sendReplyToClient(aeEventLoop *el , int fd , void *privdata , int mask ) 
{ redisClient *c ;
  int nwritten ;
  int totwritten ;
  int objlen ;
  robj *o ;
  size_t __cil_tmp ;
  int *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 519
  c = (redisClient *)privdata;
#line 520
  nwritten = 0;
#line 520
  totwritten = 0;
#line 525
  while (c->bufpos > 0 || (c->reply)->len) {
#line 526
    if (c->bufpos > 0) {
#line 527
      if (c->flags & 2) {
#line 529
        nwritten = c->bufpos - c->sentlen;
      } else {
#line 531
        nwritten = write(fd, (void const   *)(c->buf + c->sentlen), (unsigned int )(c->bufpos - c->sentlen));
#line 532
        if (nwritten <= 0) {
#line 532
          break;
        }
      }
#line 534
      c->sentlen += nwritten;
#line 535
      totwritten += nwritten;
#line 539
      if (c->sentlen == c->bufpos) {
#line 540
        c->bufpos = 0;
#line 541
        c->sentlen = 0;
      }
    } else {
#line 544
      o = (robj *)((c->reply)->head)->value;
#line 545
      __cil_tmp = sdslen((char *)o->ptr);
#line 545
      objlen = (int )__cil_tmp;
#line 547
      if (objlen == 0) {
#line 548
        listDelNode(c->reply, (c->reply)->head);
#line 549
        continue;
      }
#line 552
      if (c->flags & 2) {
#line 554
        nwritten = objlen - c->sentlen;
      } else {
#line 556
        nwritten = write(fd, (void const   *)((char *)o->ptr + c->sentlen), (unsigned int )(objlen - c->sentlen));
#line 557
        if (nwritten <= 0) {
#line 557
          break;
        }
      }
#line 559
      c->sentlen += nwritten;
#line 560
      totwritten += nwritten;
#line 563
      if (c->sentlen == objlen) {
#line 564
        listDelNode(c->reply, (c->reply)->head);
#line 565
        c->sentlen = 0;
      }
    }
#line 573
    if (totwritten > 65536) {
#line 573
      break;
    }
  }
#line 575
  if (nwritten == -1) {
#line 576
    __cil_tmp___2 = __errno();
#line 576
    if (*__cil_tmp___2 == 11) {
#line 577
      nwritten = 0;
    } else {
#line 579
      __cil_tmp___0 = __errno();
#line 579
      __cil_tmp___1 = strerror(*__cil_tmp___0);
#line 579
      redisLog(1, "Error writing to client: %s", __cil_tmp___1);
#line 581
      freeClient(c);
#line 582
      return;
    }
  }
#line 585
  if (totwritten > 0) {
#line 585
    c->lastinteraction = time((time_t *)((void *)0));
  }
#line 586
  if ((c->reply)->len == 0U) {
#line 587
    c->sentlen = 0;
#line 588
    aeDeleteFileEvent(server.el, c->fd, 2);
#line 591
    if (c->flags & 128) {
#line 591
      freeClient(c);
    }
  }
#line 593
  return;
}
}
#line 596 "networking.c"
void resetClient(redisClient *c ) 
{ 

  {
#line 597
  freeClientArgv(c);
#line 598
  c->reqtype = 0;
#line 599
  c->multibulklen = 0;
#line 600
  c->bulklen = -1L;
#line 601
  return;
}
}
#line 603 "networking.c"
void closeTimedoutClients(void) 
{ redisClient *c ;
  listNode *ln ;
  time_t now ;
  time_t __cil_tmp ;
  listIter li ;

  {
#line 606
  __cil_tmp = time((time_t *)((void *)0));
#line 606
  now = __cil_tmp;
#line 609
  listRewind(server.clients, & li);
#line 610
  while (1) {
#line 610
    ln = listNext(& li);
#line 610
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 610
      break;
    }
#line 611
    c = (redisClient *)ln->value;
#line 612
    if ((((((server.maxidletime && ! (c->flags & 1)) && ! (c->flags & 2)) && ! (c->flags & 16)) && (c->pubsub_channels)->ht[0].used + (c->pubsub_channels)->ht[1].used == 0UL) && (c->pubsub_patterns)->len == 0U) && now - c->lastinteraction > (long )server.maxidletime) {
#line 620
      redisLog(1, "Closing idle client");
#line 621
      freeClient(c);
    } else
#line 622
    if (c->flags & 16) {
#line 623
      if (c->bpop.timeout != 0L && c->bpop.timeout < now) {
#line 624
        addReply(c, shared.nullmultibulk);
#line 625
        unblockClientWaitingData(c);
      }
    }
  }
#line 629
  return;
}
}
#line 631 "networking.c"
int processInlineBuffer(redisClient *c ) 
{ char *newline ;
  char *__cil_tmp ;
  int argc ;
  int j ;
  sds *argv ;
  size_t querylen ;
  void *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 632
  __cil_tmp = strstr((char const   *)c->querybuf, "\r\n");
#line 632
  newline = __cil_tmp;
#line 638
  if ((unsigned int )newline == (unsigned int )((void *)0)) {
#line 639
    return (-1);
  }
#line 642
  querylen = (unsigned int )(newline - c->querybuf);
#line 643
  argv = sdssplitlen(c->querybuf, (int )querylen, (char *)" ", 1, & argc);
#line 646
  c->querybuf = sdsrange(c->querybuf, (int )(querylen + 2U), -1);
#line 649
  if (c->argv) {
#line 649
    free((void *)c->argv);
  }
#line 650
  __cil_tmp___0 = malloc((unsigned int )(sizeof(robj *) * (unsigned long )argc));
#line 650
  c->argv = (robj **)__cil_tmp___0;
#line 653
  c->argc = 0;
#line 653
  j = 0;
#line 653
  while (j < argc) {
#line 654
    __cil_tmp___1 = sdslen(*(argv + j));
#line 654
    if (__cil_tmp___1) {
#line 655
      *(c->argv + c->argc) = createObject(0, (void *)*(argv + j));
#line 656
      (c->argc) ++;
    } else {
#line 658
      sdsfree(*(argv + j));
    }
#line 653
    j ++;
  }
#line 661
  free((void *)argv);
#line 662
  return (0);
}
}
#line 667 "networking.c"
static void setProtocolError(redisClient *c , int pos ) 
{ 

  {
#line 668
  c->flags |= 128;
#line 669
  c->querybuf = sdsrange(c->querybuf, pos, -1);
#line 670
  return;
}
}
#line 672 "networking.c"
int processMultibulkBuffer(redisClient *c ) 
{ char *newline ;
  char *eptr ;
  int pos ;
  int tolerr ;
  long bulklen ;
  long __cil_tmp ;
  void *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 673
  newline = (char *)((void *)0);
#line 675
  pos = 0;
#line 678
  if (c->multibulklen == 0) {
#line 680
    if (! (c->argc == 0)) {
#line 680
      _redisAssert((char *)"c->argc == 0", (char *)"networking.c", 680);
#line 680
      _exit(1);
    }
#line 683
    newline = strstr((char const   *)c->querybuf, "\r\n");
#line 684
    if ((unsigned int )newline == (unsigned int )((void *)0)) {
#line 685
      return (-1);
    }
#line 689
    if (! ((int )*(c->querybuf + 0) == 42)) {
#line 689
      _redisAssert((char *)"c->querybuf[0] == \'*\'", (char *)"networking.c", 689);
#line 689
      _exit(1);
    }
#line 690
    __cil_tmp = strtol((char const   *)(c->querybuf + 1), & eptr, 10);
#line 690
    c->multibulklen = (int )__cil_tmp;
#line 691
    pos = (newline - c->querybuf) + 2;
#line 692
    if (c->multibulklen <= 0) {
#line 693
      c->querybuf = sdsrange(c->querybuf, pos, -1);
#line 694
      return (0);
    } else
#line 695
    if (c->multibulklen > 1048576) {
#line 696
      addReplyError(c, (char *)"Protocol error: invalid multibulk length");
#line 697
      setProtocolError(c, pos);
#line 698
      return (-1);
    }
#line 702
    if (c->argv) {
#line 702
      free((void *)c->argv);
    }
#line 703
    __cil_tmp___0 = malloc((unsigned int )(sizeof(robj *) * (unsigned long )c->multibulklen));
#line 703
    c->argv = (robj **)__cil_tmp___0;
#line 706
    newline = strstr((char const   *)(c->querybuf + pos), "\r\n");
  }
#line 709
  if (! (c->multibulklen > 0)) {
#line 709
    _redisAssert((char *)"c->multibulklen > 0", (char *)"networking.c", 709);
#line 709
    _exit(1);
  }
#line 710
  while (c->multibulklen) {
#line 712
    if (c->bulklen == -1L) {
#line 713
      newline = strstr((char const   *)(c->querybuf + pos), "\r\n");
#line 714
      if ((unsigned int )newline != (unsigned int )((void *)0)) {
#line 715
        if ((int )*(c->querybuf + pos) != 36) {
#line 716
          addReplyErrorFormat(c, "Protocol error: expected \'$\', got \'%c\'", (int )*(c->querybuf + pos));
#line 719
          setProtocolError(c, pos);
#line 720
          return (-1);
        }
#line 723
        bulklen = strtol((char const   *)((c->querybuf + pos) + 1), & eptr, 10);
#line 724
        tolerr = (int )*(eptr + 0) != 13;
#line 725
        if ((((tolerr || bulklen == (-0x7FFFFFFF-1)) || bulklen == 2147483647L) || bulklen < 0L) || bulklen > 536870912L) {
#line 728
          addReplyError(c, (char *)"Protocol error: invalid bulk length");
#line 729
          setProtocolError(c, pos);
#line 730
          return (-1);
        }
#line 732
        pos += (eptr - (c->querybuf + pos)) + 2;
#line 733
        c->bulklen = bulklen;
      } else {
#line 736
        break;
      }
    }
#line 741
    __cil_tmp___2 = sdslen(c->querybuf);
#line 741
    if (__cil_tmp___2 - (unsigned int )pos < (unsigned int )(c->bulklen + 2L)) {
#line 743
      break;
    } else {
#line 745
      __cil_tmp___1 = c->argc;
#line 745
      (c->argc) ++;
#line 745
      *(c->argv + __cil_tmp___1) = createStringObject(c->querybuf + pos, (unsigned int )c->bulklen);
#line 746
      pos = (int )((long )pos + (c->bulklen + 2L));
#line 747
      c->bulklen = -1L;
#line 748
      (c->multibulklen) --;
    }
  }
#line 753
  c->querybuf = sdsrange(c->querybuf, pos, -1);
#line 756
  if (c->multibulklen == 0) {
#line 757
    return (0);
  }
#line 759
  return (-1);
}
}
#line 762 "networking.c"
void processInputBuffer(redisClient *c ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 764
  while (1) {
#line 764
    __cil_tmp___2 = sdslen(c->querybuf);
#line 764
    if (! __cil_tmp___2) {
#line 764
      break;
    }
#line 766
    if (c->flags & 16 || c->flags & 32) {
#line 766
      return;
    }
#line 771
    if (c->flags & 128) {
#line 771
      return;
    }
#line 774
    if (! c->reqtype) {
#line 775
      if ((int )*(c->querybuf + 0) == 42) {
#line 776
        c->reqtype = 2;
      } else {
#line 778
        c->reqtype = 1;
      }
    }
#line 782
    if (c->reqtype == 1) {
#line 783
      __cil_tmp = processInlineBuffer(c);
#line 783
      if (__cil_tmp != 0) {
#line 783
        break;
      }
    } else
#line 784
    if (c->reqtype == 2) {
#line 785
      __cil_tmp___0 = processMultibulkBuffer(c);
#line 785
      if (__cil_tmp___0 != 0) {
#line 785
        break;
      }
    } else {
#line 787
      _redisPanic((char *)"\"Unknown request type\"", (char *)"networking.c", 787);
#line 787
      _exit(1);
    }
#line 791
    if (c->argc == 0) {
#line 792
      resetClient(c);
    } else {
#line 795
      __cil_tmp___1 = processCommand(c);
#line 795
      if (__cil_tmp___1 == 0) {
#line 796
        resetClient(c);
      }
    }
  }
#line 799
  return;
}
}
#line 801 "networking.c"
void readQueryFromClient(aeEventLoop *el , int fd , void *privdata , int mask ) 
{ redisClient *c ;
  char buf[1024] ;
  int nread ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 802
  c = (redisClient *)privdata;
#line 808
  nread = read(fd, (void *)(buf), 1024U);
#line 809
  if (nread == -1) {
#line 810
    __cil_tmp___1 = __errno();
#line 810
    if (*__cil_tmp___1 == 11) {
#line 811
      nread = 0;
    } else {
#line 813
      __cil_tmp = __errno();
#line 813
      __cil_tmp___0 = strerror(*__cil_tmp);
#line 813
      redisLog(1, "Reading from client: %s", __cil_tmp___0);
#line 814
      freeClient(c);
#line 815
      return;
    }
  } else
#line 817
  if (nread == 0) {
#line 818
    redisLog(1, "Client closed connection");
#line 819
    freeClient(c);
#line 820
    return;
  }
#line 822
  if (nread) {
#line 823
    c->querybuf = sdscatlen(c->querybuf, (void *)(buf), (unsigned int )nread);
#line 824
    c->lastinteraction = time((time_t *)((void *)0));
  } else {
#line 826
    return;
  }
#line 828
  processInputBuffer(c);
#line 829
  return;
}
}
#line 831 "networking.c"
void getClientsMaxBuffers(unsigned long *longest_output_list , unsigned long *biggest_input_buffer ) 
{ redisClient *c ;
  listNode *ln ;
  listIter li ;
  unsigned long lol ;
  unsigned long bib ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 836
  lol = 0UL;
#line 836
  bib = 0UL;
#line 838
  listRewind(server.clients, & li);
#line 839
  while (1) {
#line 839
    ln = listNext(& li);
#line 839
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 839
      break;
    }
#line 840
    c = (redisClient *)ln->value;
#line 842
    if ((unsigned long )(c->reply)->len > lol) {
#line 842
      lol = (unsigned long )(c->reply)->len;
    }
#line 843
    __cil_tmp___0 = sdslen(c->querybuf);
#line 843
    if ((unsigned long )__cil_tmp___0 > bib) {
#line 843
      __cil_tmp = sdslen(c->querybuf);
#line 843
      bib = (unsigned long )__cil_tmp;
    }
  }
#line 845
  *longest_output_list = lol;
#line 846
  *biggest_input_buffer = bib;
#line 847
  return;
}
}
#line 1 "util.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-pPBABVXq.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 856 "redis.h"
int stringmatchlen(char const   *pattern , int patternLen , char const   *string ,
                   int stringLen , int nocase ) ;
#line 858
int stringmatch(char const   *pattern , char const   *string , int nocase ) ;
#line 859
long long memtoll(char const   *p , int *err ) ;
#line 861
int isStringRepresentableAsLong(sds s , long *longval ) ;
#line 862
int isStringRepresentableAsLongLong(sds s , long long *llongval ) ;
#line 863
int isObjectRepresentableAsLongLong(robj *o , long long *llongval ) ;
#line 6 "util.c"
int stringmatchlen(char const   *pattern , int patternLen , char const   *string ,
                   int stringLen , int nocase ) 
{ int __cil_tmp ;
  int not ;
  int match___1 ;
  int start ;
  int end ;
  int c ;
  int t ;
  int __x ;
  int __x___0 ;
  int __x___1 ;
  int __x___2 ;
  int __x___3 ;
  int __x___4 ;
  int __x___5 ;

  {
#line 9
  while (patternLen) {
#line 10
    switch ((int )*(pattern + 0)) {
    case 42: 
#line 12
    while ((int const   )*(pattern + 1) == 42) {
#line 13
      pattern ++;
#line 14
      patternLen --;
    }
#line 16
    if (patternLen == 1) {
#line 17
      return (1);
    }
#line 18
    while (stringLen) {
#line 19
      __cil_tmp = stringmatchlen(pattern + 1, patternLen - 1, string, stringLen, nocase);
#line 19
      if (__cil_tmp) {
#line 21
        return (1);
      }
#line 22
      string ++;
#line 23
      stringLen --;
    }
#line 25
    return (0);
#line 26
    break;
    case 63: 
#line 28
    if (stringLen == 0) {
#line 29
      return (0);
    }
#line 30
    string ++;
#line 31
    stringLen --;
#line 32
    break;
    case 91: 
#line 37
    pattern ++;
#line 38
    patternLen --;
#line 39
    not = (int const   )*(pattern + 0) == 94;
#line 40
    if (not) {
#line 41
      pattern ++;
#line 42
      patternLen --;
    }
#line 44
    match___1 = 0;
#line 45
    while (1) {
#line 46
      if ((int const   )*(pattern + 0) == 92) {
#line 47
        pattern ++;
#line 48
        patternLen --;
#line 49
        if ((int const   )*(pattern + 0) == (int const   )*(string + 0)) {
#line 50
          match___1 = 1;
        }
      } else
#line 51
      if ((int const   )*(pattern + 0) == 93) {
#line 52
        break;
      } else
#line 53
      if (patternLen == 0) {
#line 54
        pattern --;
#line 55
        patternLen ++;
#line 56
        break;
      } else
#line 57
      if ((int const   )*(pattern + 1) == 45 && patternLen >= 3) {
#line 58
        start = (int )*(pattern + 0);
#line 59
        end = (int )*(pattern + 2);
#line 60
        c = (int )*(string + 0);
#line 61
        if (start > end) {
#line 62
          t = start;
#line 63
          start = end;
#line 64
          end = t;
        }
#line 66
        if (nocase) {
#line 67
          __x = start;
#line 67
          start = ((int const   )*((__ctype_ptr__ + sizeof(*("" + __x))) + __x) & 3) == 1 ? (__x - 65) + 97 : __x;
#line 68
          __x___0 = end;
#line 68
          end = ((int const   )*((__ctype_ptr__ + sizeof(*("" + __x___0))) + __x___0) & 3) == 1 ? (__x___0 - 65) + 97 : __x___0;
#line 69
          __x___1 = c;
#line 69
          c = ((int const   )*((__ctype_ptr__ + sizeof(*("" + __x___1))) + __x___1) & 3) == 1 ? (__x___1 - 65) + 97 : __x___1;
        }
#line 71
        pattern += 2;
#line 72
        patternLen -= 2;
#line 73
        if (c >= start && c <= end) {
#line 74
          match___1 = 1;
        }
      } else
#line 76
      if (! nocase) {
#line 77
        if ((int const   )*(pattern + 0) == (int const   )*(string + 0)) {
#line 78
          match___1 = 1;
        }
      } else {
#line 80
        __x___2 = (int )*(pattern + 0);
#line 80
        __x___3 = (int )*(string + 0);
#line 80
        if ((((int const   )*((__ctype_ptr__ + sizeof(*("" + __x___2))) + __x___2) & 3) == 1 ? (__x___2 - 65) + 97 : __x___2) == (((int const   )*((__ctype_ptr__ + sizeof(*("" + __x___3))) + __x___3) & 3) == 1 ? (__x___3 - 65) + 97 : __x___3)) {
#line 81
          match___1 = 1;
        }
      }
#line 84
      pattern ++;
#line 85
      patternLen --;
    }
#line 87
    if (not) {
#line 88
      match___1 = ! match___1;
    }
#line 89
    if (! match___1) {
#line 90
      return (0);
    }
#line 91
    string ++;
#line 92
    stringLen --;
#line 93
    break;
    case 92: 
#line 96
    if (patternLen >= 2) {
#line 97
      pattern ++;
#line 98
      patternLen --;
    }
    default: 
#line 102
    if (! nocase) {
#line 103
      if ((int const   )*(pattern + 0) != (int const   )*(string + 0)) {
#line 104
        return (0);
      }
    } else {
#line 106
      __x___4 = (int )*(pattern + 0);
#line 106
      __x___5 = (int )*(string + 0);
#line 106
      if ((((int const   )*((__ctype_ptr__ + sizeof(*("" + __x___4))) + __x___4) & 3) == 1 ? (__x___4 - 65) + 97 : __x___4) != (((int const   )*((__ctype_ptr__ + sizeof(*("" + __x___5))) + __x___5) & 3) == 1 ? (__x___5 - 65) + 97 : __x___5)) {
#line 107
        return (0);
      }
    }
#line 109
    string ++;
#line 110
    stringLen --;
#line 111
    break;
    }
#line 113
    pattern ++;
#line 114
    patternLen --;
#line 115
    if (stringLen == 0) {
#line 116
      while ((int const   )*pattern == 42) {
#line 117
        pattern ++;
#line 118
        patternLen --;
      }
#line 120
      break;
    }
  }
#line 123
  if (patternLen == 0 && stringLen == 0) {
#line 124
    return (1);
  }
#line 125
  return (0);
}
}
#line 128 "util.c"
int stringmatch(char const   *pattern , char const   *string , int nocase ) 
{ size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 129
  __cil_tmp = strlen(string);
#line 129
  __cil_tmp___0 = strlen(pattern);
#line 129
  __cil_tmp___1 = stringmatchlen(pattern, (int )__cil_tmp___0, string, (int )__cil_tmp,
                                 nocase);
#line 129
  return (__cil_tmp___1);
}
}
#line 138 "util.c"
long long memtoll(char const   *p , int *err ) 
{ char const   *u ;
  char buf[128] ;
  long mul ;
  long long val ;
  unsigned int digits ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;

  {
#line 145
  if (err) {
#line 145
    *err = 0;
  }
#line 147
  u = p;
#line 148
  if ((int const   )*u == 45) {
#line 148
    u ++;
  }
#line 149
  while (*u && (int const   )*((__ctype_ptr__ + sizeof(*("" + (int const   )*u))) + (int )*u) & 4) {
#line 149
    u ++;
  }
#line 150
  if ((int const   )*u == 0) {
#line 151
    mul = 1L;
  } else {
#line 150
    __cil_tmp___5 = strcasecmp(u, "b");
#line 150
    if (__cil_tmp___5) {
#line 152
      __cil_tmp___4 = strcasecmp(u, "k");
#line 152
      if (__cil_tmp___4) {
#line 154
        __cil_tmp___3 = strcasecmp(u, "kb");
#line 154
        if (__cil_tmp___3) {
#line 156
          __cil_tmp___2 = strcasecmp(u, "m");
#line 156
          if (__cil_tmp___2) {
#line 158
            __cil_tmp___1 = strcasecmp(u, "mb");
#line 158
            if (__cil_tmp___1) {
#line 160
              __cil_tmp___0 = strcasecmp(u, "g");
#line 160
              if (__cil_tmp___0) {
#line 162
                __cil_tmp = strcasecmp(u, "gb");
#line 162
                if (__cil_tmp) {
#line 165
                  if (err) {
#line 165
                    *err = 1;
                  }
#line 166
                  mul = 1L;
                } else {
#line 163
                  mul = 1073741824L;
                }
              } else {
#line 161
                mul = 1000000000L;
              }
            } else {
#line 159
              mul = 1048576L;
            }
          } else {
#line 157
            mul = 1000000L;
          }
        } else {
#line 155
          mul = 1024L;
        }
      } else {
#line 153
        mul = 1000L;
      }
    } else {
#line 151
      mul = 1L;
    }
  }
#line 168
  digits = (unsigned int )(u - p);
#line 169
  if ((unsigned long )digits >= sizeof(buf)) {
#line 170
    if (err) {
#line 170
      *err = 1;
    }
#line 171
    return (9223372036854775807LL);
  }
#line 173
  memcpy((void *)(buf), (void const   *)p, digits);
#line 174
  buf[digits] = (char )'\000';
#line 175
  val = strtoll((char const   *)(buf), (char **)((void *)0), 10);
#line 176
  return (val * (long long )mul);
}
}
#line 182 "util.c"
int ll2string(char *s , size_t len , long long value ) 
{ char buf[32] ;
  char *p ;
  unsigned long long v ;
  size_t l ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 187
  if (len == 0U) {
#line 187
    return (0);
  }
#line 188
  v = (unsigned long long )(value < 0LL ? - value : value);
#line 189
  p = buf + 31;
#line 190
  while (1) {
#line 191
    __cil_tmp = p;
#line 191
    p --;
#line 191
    *__cil_tmp = (char )(48ULL + v % 10ULL);
#line 192
    v /= 10ULL;
#line 190
    if (! v) {
#line 190
      break;
    }
  }
#line 194
  if (value < 0LL) {
#line 194
    __cil_tmp___0 = p;
#line 194
    p --;
#line 194
    *__cil_tmp___0 = (char )'-';
  }
#line 195
  p ++;
#line 196
  l = (unsigned int )(32 - (p - buf));
#line 197
  if (l + 1U > len) {
#line 197
    l = len - 1U;
  }
#line 198
  memcpy((void *)s, (void const   *)p, l);
#line 199
  *(s + l) = (char )'\000';
#line 200
  return ((int )l);
}
}
#line 210 "util.c"
int isStringRepresentableAsLongLong(sds s , long long *llongval ) 
{ char buf[32] ;
  char *endptr ;
  long long value ;
  int slen ;
  size_t __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 215
  value = strtoll((char const   *)s, & endptr, 10);
#line 216
  if ((int )*(endptr + 0) != 0) {
#line 216
    return (-1);
  }
#line 217
  slen = ll2string(buf, 32U, value);
#line 221
  __cil_tmp = sdslen(s);
#line 221
  if (__cil_tmp != (unsigned int )slen) {
#line 221
    return (-1);
  } else {
#line 221
    __cil_tmp___0 = memcmp((void const   *)(buf), (void const   *)s, (unsigned int )slen);
#line 221
    if (__cil_tmp___0) {
#line 221
      return (-1);
    }
  }
#line 222
  if (llongval) {
#line 222
    *llongval = value;
  }
#line 223
  return (0);
}
}
#line 226 "util.c"
int isStringRepresentableAsLong(sds s , long *longval ) 
{ long long ll ;
  int __cil_tmp ;

  {
#line 229
  __cil_tmp = isStringRepresentableAsLongLong(s, & ll);
#line 229
  if (__cil_tmp == -1) {
#line 229
    return (-1);
  }
#line 230
  if (ll < (-0x7FFFFFFF-1) || ll > 2147483647LL) {
#line 230
    return (-1);
  }
#line 231
  *longval = (long )ll;
#line 232
  return (0);
}
}
#line 235 "util.c"
int isObjectRepresentableAsLongLong(robj *o , long long *llongval ) 
{ int __cil_tmp ;

  {
#line 236
  if (! (o->type == 0U)) {
#line 236
    _redisAssert((char *)"o->type == REDIS_STRING", (char *)"util.c", 236);
#line 236
    _exit(1);
  }
#line 237
  if (o->encoding == 1U) {
#line 238
    if (llongval) {
#line 238
      *llongval = (long long )((long )o->ptr);
    }
#line 239
    return (0);
  } else {
#line 241
    __cil_tmp = isStringRepresentableAsLongLong((char *)o->ptr, llongval);
#line 241
    return (__cil_tmp);
  }
}
}
#line 1 "object.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-9L8aoG5Q.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 126 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
double strtod(char const   *s00 , char **se ) ;
#line 233 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/pthread.h"
int pthread_equal(pthread_t t1 , pthread_t t2 ) ;
#line 11 "intset.h"
intset *intsetNew(void) ;
#line 702 "redis.h"
void freeStringObject(robj *o ) ;
#line 703
void freeListObject(robj *o ) ;
#line 704
void freeSetObject(robj *o ) ;
#line 705
void freeZsetObject(robj *o ) ;
#line 706
void freeHashObject(robj *o ) ;
#line 710
robj *tryObjectEncoding(robj *o ) ;
#line 712
size_t stringObjectLen(robj *o ) ;
#line 713
robj *createStringObjectFromLongLong(long long value ) ;
#line 714
robj *createListObject(void) ;
#line 715
robj *createZiplistObject(void) ;
#line 716
robj *createSetObject(void) ;
#line 717
robj *createIntsetObject(void) ;
#line 718
robj *createHashObject(void) ;
#line 719
robj *createZsetObject(void) ;
#line 720
int getLongFromObjectOrReply(redisClient *c , robj *o , long *target , char const   *msg ) ;
#line 721
int checkType(redisClient *c , robj *o , int type ) ;
#line 722
int getLongLongFromObjectOrReply(redisClient *c , robj *o , long long *target , char const   *msg ) ;
#line 723
int getDoubleFromObjectOrReply(redisClient *c , robj *o , double *target , char const   *msg ) ;
#line 724
int getLongLongFromObject(robj *o , long long *target ) ;
#line 725
char *strEncoding(int encoding ) ;
#line 726
int compareStringObjects(robj *a , robj *b ) ;
#line 773
zskiplist *zslCreate(void) ;
#line 774
void zslFree(zskiplist *zsl ) ;
#line 794
void vmMarkPagesFree(off_t page , off_t count ) ;
#line 801
void vmCancelThreadedIOJob(robj *o ) ;
#line 179 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/math.h"
extern int __fpclassifyf(float x ) ;
#line 180
extern int __fpclassifyd(double x ) ;
#line 5 "object.c"
robj *createObject(int type , void *ptr ) 
{ robj *o ;
  void *__cil_tmp ;

  {
#line 6
  __cil_tmp = malloc((unsigned int )sizeof(*o));
#line 6
  o = (robj *)__cil_tmp;
#line 7
  o->type = (unsigned int )type;
#line 8
  o->encoding = 0U;
#line 9
  o->ptr = ptr;
#line 10
  o->refcount = 1;
#line 20
  o->lru = server.lruclock;
#line 24
  o->storage = 0U;
#line 25
  return (o);
}
}
#line 28 "object.c"
robj *createStringObject(char *ptr , size_t len ) 
{ sds __cil_tmp ;
  robj *__cil_tmp___0 ;

  {
#line 29
  __cil_tmp = sdsnewlen((void const   *)ptr, len);
#line 29
  __cil_tmp___0 = createObject(0, (void *)__cil_tmp);
#line 29
  return (__cil_tmp___0);
}
}
#line 32 "object.c"
robj *createStringObjectFromLongLong(long long value ) 
{ robj *o ;
  sds __cil_tmp ;
  pthread_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 34
  if (value >= 0LL && value < 10LL) {
#line 34
    __cil_tmp___0 = pthread_self();
#line 34
    __cil_tmp___1 = pthread_equal(__cil_tmp___0, server.mainthread);
#line 34
    if (__cil_tmp___1) {
#line 36
      incrRefCount(shared.integers[value]);
#line 37
      o = shared.integers[value];
    } else {
#line 34
      goto _L;
    }
  } else
  _L: 
#line 39
  if (value >= (-0x7FFFFFFF-1) && value <= 2147483647LL) {
#line 40
    o = createObject(0, (void *)0);
#line 41
    o->encoding = 1U;
#line 42
    o->ptr = (void *)((long )value);
  } else {
#line 44
    __cil_tmp = sdsfromlonglong(value);
#line 44
    o = createObject(0, (void *)__cil_tmp);
  }
#line 47
  return (o);
}
}
#line 50 "object.c"
robj *dupStringObject(robj *o ) 
{ size_t __cil_tmp ;
  robj *__cil_tmp___0 ;

  {
#line 51
  if (! (o->encoding == 0U)) {
#line 51
    _redisAssert((char *)"o->encoding == REDIS_ENCODING_RAW", (char *)"object.c",
                 51);
#line 51
    _exit(1);
  }
#line 52
  __cil_tmp = sdslen((char *)o->ptr);
#line 52
  __cil_tmp___0 = createStringObject((char *)o->ptr, __cil_tmp);
#line 52
  return (__cil_tmp___0);
}
}
#line 55 "object.c"
robj *createListObject(void) 
{ list *l ;
  list *__cil_tmp ;
  robj *o ;
  robj *__cil_tmp___0 ;

  {
#line 56
  __cil_tmp = listCreate();
#line 56
  l = __cil_tmp;
#line 57
  __cil_tmp___0 = createObject(1, (void *)l);
#line 57
  o = __cil_tmp___0;
#line 58
  l->free = & decrRefCount;
#line 59
  o->encoding = 4U;
#line 60
  return (o);
}
}
#line 63 "object.c"
robj *createZiplistObject(void) 
{ unsigned char *zl ;
  unsigned char *__cil_tmp ;
  robj *o ;
  robj *__cil_tmp___0 ;

  {
#line 64
  __cil_tmp = ziplistNew();
#line 64
  zl = __cil_tmp;
#line 65
  __cil_tmp___0 = createObject(1, (void *)zl);
#line 65
  o = __cil_tmp___0;
#line 66
  o->encoding = 5U;
#line 67
  return (o);
}
}
#line 70 "object.c"
robj *createSetObject(void) 
{ dict *d ;
  dict *__cil_tmp ;
  robj *o ;
  robj *__cil_tmp___0 ;

  {
#line 71
  __cil_tmp = dictCreate(& setDictType, (void *)0);
#line 71
  d = __cil_tmp;
#line 72
  __cil_tmp___0 = createObject(2, (void *)d);
#line 72
  o = __cil_tmp___0;
#line 73
  o->encoding = 2U;
#line 74
  return (o);
}
}
#line 77 "object.c"
robj *createIntsetObject(void) 
{ intset *is ;
  intset *__cil_tmp ;
  robj *o ;
  robj *__cil_tmp___0 ;

  {
#line 78
  __cil_tmp = intsetNew();
#line 78
  is = __cil_tmp;
#line 79
  __cil_tmp___0 = createObject(2, (void *)is);
#line 79
  o = __cil_tmp___0;
#line 80
  o->encoding = 6U;
#line 81
  return (o);
}
}
#line 84 "object.c"
robj *createHashObject(void) 
{ unsigned char *zm ;
  unsigned char *__cil_tmp ;
  robj *o ;
  robj *__cil_tmp___0 ;

  {
#line 88
  __cil_tmp = zipmapNew();
#line 88
  zm = __cil_tmp;
#line 89
  __cil_tmp___0 = createObject(4, (void *)zm);
#line 89
  o = __cil_tmp___0;
#line 90
  o->encoding = 3U;
#line 91
  return (o);
}
}
#line 94 "object.c"
robj *createZsetObject(void) 
{ zset *zs ;
  void *__cil_tmp ;
  robj *__cil_tmp___0 ;

  {
#line 95
  __cil_tmp = malloc((unsigned int )sizeof(*zs));
#line 95
  zs = (zset *)__cil_tmp;
#line 97
  zs->dict = dictCreate(& zsetDictType, (void *)0);
#line 98
  zs->zsl = zslCreate();
#line 99
  __cil_tmp___0 = createObject(3, (void *)zs);
#line 99
  return (__cil_tmp___0);
}
}
#line 102 "object.c"
void freeStringObject(robj *o ) 
{ 

  {
#line 103
  if (o->encoding == 0U) {
#line 104
    sdsfree((char *)o->ptr);
  }
#line 106
  return;
}
}
#line 108 "object.c"
void freeListObject(robj *o ) 
{ 

  {
#line 109
  switch ((int )o->encoding) {
  case 4: 
#line 111
  listRelease((list *)o->ptr);
#line 112
  break;
  case 5: 
#line 114
  free(o->ptr);
#line 115
  break;
  default: 
#line 117
  _redisPanic((char *)"\"Unknown list encoding type\"", (char *)"object.c", 117);
#line 117
  _exit(1);
  }
#line 119
  return;
}
}
#line 121 "object.c"
void freeSetObject(robj *o ) 
{ 

  {
#line 122
  switch ((int )o->encoding) {
  case 2: 
#line 124
  dictRelease((dict *)o->ptr);
#line 125
  break;
  case 6: 
#line 127
  free(o->ptr);
#line 128
  break;
  default: 
#line 130
  _redisPanic((char *)"\"Unknown set encoding type\"", (char *)"object.c", 130);
#line 130
  _exit(1);
  }
#line 132
  return;
}
}
#line 134 "object.c"
void freeZsetObject(robj *o ) 
{ zset *zs ;

  {
#line 135
  zs = (zset *)o->ptr;
#line 137
  dictRelease(zs->dict);
#line 138
  zslFree(zs->zsl);
#line 139
  free((void *)zs);
#line 140
  return;
}
}
#line 142 "object.c"
void freeHashObject(robj *o ) 
{ 

  {
#line 143
  switch ((int )o->encoding) {
  case 2: 
#line 145
  dictRelease((dict *)o->ptr);
#line 146
  break;
  case 3: 
#line 148
  free(o->ptr);
#line 149
  break;
  default: 
#line 151
  _redisPanic((char *)"\"Unknown hash encoding type\"", (char *)"object.c", 151);
#line 151
  _exit(1);
#line 152
  break;
  }
#line 154
  return;
}
}
#line 156 "object.c"
void incrRefCount(robj *o ) 
{ 

  {
#line 157
  (o->refcount) ++;
#line 158
  return;
}
}
#line 160 "object.c"
void decrRefCount(void *obj ) 
{ robj *o ;
  vmpointer *vp ;

  {
#line 161
  o = (robj *)obj;
#line 164
  if (server.vm_enabled && (o->storage == 1U || o->storage == 3U)) {
#line 167
    vp = (vmpointer *)obj;
#line 168
    if (o->storage == 3U) {
#line 168
      vmCancelThreadedIOJob(o);
    }
#line 169
    vmMarkPagesFree(vp->page, vp->usedpages);
#line 170
    (server.vm_stats_swapped_objects) --;
#line 171
    free((void *)vp);
#line 172
    return;
  }
#line 175
  if (o->refcount <= 0) {
#line 175
    _redisPanic((char *)"\"decrRefCount against refcount <= 0\"", (char *)"object.c",
                175);
#line 175
    _exit(1);
  }
#line 185
  if (server.vm_enabled && o->storage == 2U) {
#line 186
    vmCancelThreadedIOJob(o);
  }
#line 187
  (o->refcount) --;
#line 187
  if (o->refcount == 0) {
#line 188
    switch ((int )o->type) {
    case 0: 
#line 189
    freeStringObject(o);
#line 189
    break;
    case 1: 
#line 190
    freeListObject(o);
#line 190
    break;
    case 2: 
#line 191
    freeSetObject(o);
#line 191
    break;
    case 3: 
#line 192
    freeZsetObject(o);
#line 192
    break;
    case 4: 
#line 193
    freeHashObject(o);
#line 193
    break;
    default: 
#line 194
    _redisPanic((char *)"\"Unknown object type\"", (char *)"object.c", 194);
#line 194
    _exit(1);
#line 194
    break;
    }
#line 196
    o->ptr = (void *)0;
#line 197
    free((void *)o);
  }
#line 199
  return;
}
}
#line 201 "object.c"
int checkType(redisClient *c , robj *o , int type ) 
{ 

  {
#line 202
  if (o->type != (unsigned int )type) {
#line 203
    addReply(c, shared.wrongtypeerr);
#line 204
    return (1);
  }
#line 206
  return (0);
}
}
#line 210 "object.c"
robj *tryObjectEncoding(robj *o ) 
{ long value ;
  sds s ;
  int __cil_tmp ;
  pthread_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 212
  s = (char *)o->ptr;
#line 214
  if (o->encoding != 0U) {
#line 215
    return (o);
  }
#line 220
  if (o->refcount > 1) {
#line 220
    return (o);
  }
#line 223
  if (! (o->type == 0U)) {
#line 223
    _redisAssert((char *)"o->type == REDIS_STRING", (char *)"object.c", 223);
#line 223
    _exit(1);
  }
#line 226
  __cil_tmp = isStringRepresentableAsLong(s, & value);
#line 226
  if (__cil_tmp == -1) {
#line 226
    return (o);
  }
#line 239
  if ((server.maxmemory == 0ULL && value >= 0L) && value < 10L) {
#line 239
    __cil_tmp___0 = pthread_self();
#line 239
    __cil_tmp___1 = pthread_equal(__cil_tmp___0, server.mainthread);
#line 239
    if (__cil_tmp___1) {
#line 241
      decrRefCount((void *)o);
#line 242
      incrRefCount(shared.integers[value]);
#line 243
      return (shared.integers[value]);
    } else {
#line 245
      o->encoding = 1U;
#line 246
      sdsfree((char *)o->ptr);
#line 247
      o->ptr = (void *)value;
#line 248
      return (o);
    }
  } else {
#line 245
    o->encoding = 1U;
#line 246
    sdsfree((char *)o->ptr);
#line 247
    o->ptr = (void *)value;
#line 248
    return (o);
  }
}
}
#line 254 "object.c"
robj *getDecodedObject(robj *o ) 
{ robj *dec ;
  char buf[32] ;
  size_t __cil_tmp ;

  {
#line 257
  if (o->encoding == 0U) {
#line 258
    incrRefCount(o);
#line 259
    return (o);
  }
#line 261
  if (o->type == 0U && o->encoding == 1U) {
#line 264
    ll2string(buf, 32U, (long long )((long )o->ptr));
#line 265
    __cil_tmp = strlen((char const   *)(buf));
#line 265
    dec = createStringObject(buf, __cil_tmp);
#line 266
    return (dec);
  } else {
#line 268
    _redisPanic((char *)"\"Unknown encoding type\"", (char *)"object.c", 268);
#line 268
    _exit(1);
  }
}
}
#line 280 "object.c"
int compareStringObjects(robj *a , robj *b ) 
{ char bufa[128] ;
  char bufb[128] ;
  char *astr ;
  char *bstr ;
  int bothsds ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 281
  if (! (a->type == 0U && b->type == 0U)) {
#line 281
    _redisAssert((char *)"a->type == REDIS_STRING && b->type == REDIS_STRING", (char *)"object.c",
                 281);
#line 281
    _exit(1);
  }
#line 283
  bothsds = 1;
#line 285
  if ((unsigned int )a == (unsigned int )b) {
#line 285
    return (0);
  }
#line 286
  if (a->encoding != 0U) {
#line 287
    ll2string(bufa, (unsigned int )sizeof(bufa), (long long )((long )a->ptr));
#line 288
    astr = bufa;
#line 289
    bothsds = 0;
  } else {
#line 291
    astr = (char *)a->ptr;
  }
#line 293
  if (b->encoding != 0U) {
#line 294
    ll2string(bufb, (unsigned int )sizeof(bufb), (long long )((long )b->ptr));
#line 295
    bstr = bufb;
#line 296
    bothsds = 0;
  } else {
#line 298
    bstr = (char *)b->ptr;
  }
#line 300
  if (bothsds) {
#line 300
    __cil_tmp = sdscmp(astr, bstr);
#line 300
    __cil_tmp___1 = __cil_tmp;
  } else {
#line 300
    __cil_tmp___0 = strcmp((char const   *)astr, (char const   *)bstr);
#line 300
    __cil_tmp___1 = __cil_tmp___0;
  }
#line 300
  return (__cil_tmp___1);
}
}
#line 307 "object.c"
int equalStringObjects(robj *a , robj *b ) 
{ int __cil_tmp ;

  {
#line 308
  if (a->encoding != 0U && b->encoding != 0U) {
#line 309
    return ((unsigned int )a->ptr == (unsigned int )b->ptr);
  } else {
#line 311
    __cil_tmp = compareStringObjects(a, b);
#line 311
    return (__cil_tmp == 0);
  }
}
}
#line 315 "object.c"
size_t stringObjectLen(robj *o ) 
{ size_t __cil_tmp ;
  char buf[32] ;
  int __cil_tmp___0 ;

  {
#line 316
  if (! (o->type == 0U)) {
#line 316
    _redisAssert((char *)"o->type == REDIS_STRING", (char *)"object.c", 316);
#line 316
    _exit(1);
  }
#line 317
  if (o->encoding == 0U) {
#line 318
    __cil_tmp = sdslen((char *)o->ptr);
#line 318
    return (__cil_tmp);
  } else {
#line 322
    __cil_tmp___0 = ll2string(buf, 32U, (long long )((long )o->ptr));
#line 322
    return ((unsigned int )__cil_tmp___0);
  }
}
}
#line 326 "object.c"
int getDoubleFromObject(robj *o , double *target ) 
{ double value ;
  char *eptr ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 330
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 331
    value = (double )0;
  } else {
#line 333
    if (! (o->type == 0U)) {
#line 333
      _redisAssert((char *)"o->type == REDIS_STRING", (char *)"object.c", 333);
#line 333
      _exit(1);
    }
#line 334
    if (o->encoding == 0U) {
#line 335
      value = strtod((char const   *)o->ptr, & eptr);
#line 336
      if ((int )*(eptr + 0) != 0) {
#line 336
        return (-1);
      } else {
#line 336
        if (sizeof(value) == sizeof(float )) {
#line 336
          __cil_tmp = __fpclassifyf((float )value);
#line 336
          __cil_tmp___1 = __cil_tmp;
        } else {
#line 336
          __cil_tmp___0 = __fpclassifyd(value);
#line 336
          __cil_tmp___1 = __cil_tmp___0;
        }
#line 336
        if (__cil_tmp___1 == 0) {
#line 336
          return (-1);
        }
      }
    } else
#line 337
    if (o->encoding == 1U) {
#line 338
      value = (double )((long )o->ptr);
    } else {
#line 340
      _redisPanic((char *)"\"Unknown string encoding\"", (char *)"object.c", 340);
#line 340
      _exit(1);
    }
  }
#line 344
  *target = value;
#line 345
  return (0);
}
}
#line 348 "object.c"
int getDoubleFromObjectOrReply(redisClient *c , robj *o , double *target , char const   *msg ) 
{ double value ;
  int __cil_tmp ;

  {
#line 350
  __cil_tmp = getDoubleFromObject(o, & value);
#line 350
  if (__cil_tmp != 0) {
#line 351
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 352
      addReplyError(c, (char *)msg);
    } else {
#line 354
      addReplyError(c, (char *)"value is not a double");
    }
#line 356
    return (-1);
  }
#line 359
  *target = value;
#line 360
  return (0);
}
}
#line 363 "object.c"
int getLongLongFromObject(robj *o , long long *target ) 
{ long long value ;
  char *eptr ;
  int *__cil_tmp ;

  {
#line 367
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 368
    value = 0LL;
  } else {
#line 370
    if (! (o->type == 0U)) {
#line 370
      _redisAssert((char *)"o->type == REDIS_STRING", (char *)"object.c", 370);
#line 370
      _exit(1);
    }
#line 371
    if (o->encoding == 0U) {
#line 372
      value = strtoll((char const   *)o->ptr, & eptr, 10);
#line 373
      if ((int )*(eptr + 0) != 0) {
#line 373
        return (-1);
      }
#line 374
      __cil_tmp = __errno();
#line 374
      if (*__cil_tmp == 34 && (value == (-0x7FFFFFFFFFFFFFFF-1) || value == 9223372036854775807LL)) {
#line 375
        return (-1);
      }
    } else
#line 376
    if (o->encoding == 1U) {
#line 377
      value = (long long )((long )o->ptr);
    } else {
#line 379
      _redisPanic((char *)"\"Unknown string encoding\"", (char *)"object.c", 379);
#line 379
      _exit(1);
    }
  }
#line 383
  if (target) {
#line 383
    *target = value;
  }
#line 384
  return (0);
}
}
#line 387 "object.c"
int getLongLongFromObjectOrReply(redisClient *c , robj *o , long long *target , char const   *msg ) 
{ long long value ;
  int __cil_tmp ;

  {
#line 389
  __cil_tmp = getLongLongFromObject(o, & value);
#line 389
  if (__cil_tmp != 0) {
#line 390
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 391
      addReplyError(c, (char *)msg);
    } else {
#line 393
      addReplyError(c, (char *)"value is not an integer or out of range");
    }
#line 395
    return (-1);
  }
#line 398
  *target = value;
#line 399
  return (0);
}
}
#line 402 "object.c"
int getLongFromObjectOrReply(redisClient *c , robj *o , long *target , char const   *msg ) 
{ long long value ;
  int __cil_tmp ;

  {
#line 405
  __cil_tmp = getLongLongFromObjectOrReply(c, o, & value, msg);
#line 405
  if (__cil_tmp != 0) {
#line 405
    return (-1);
  }
#line 406
  if (value < (-0x7FFFFFFF-1) || value > 2147483647LL) {
#line 407
    if ((unsigned int )msg != (unsigned int )((void *)0)) {
#line 408
      addReplyError(c, (char *)msg);
    } else {
#line 410
      addReplyError(c, (char *)"value is out of range");
    }
#line 412
    return (-1);
  }
#line 415
  *target = (long )value;
#line 416
  return (0);
}
}
#line 419 "object.c"
char *strEncoding(int encoding ) 
{ 

  {
#line 420
  switch (encoding) {
  case 0: 
#line 421
  return ((char *)"raw");
  case 1: 
#line 422
  return ((char *)"int");
  case 2: 
#line 423
  return ((char *)"hashtable");
  case 3: 
#line 424
  return ((char *)"zipmap");
  case 4: 
#line 425
  return ((char *)"linkedlist");
  case 5: 
#line 426
  return ((char *)"ziplist");
  case 6: 
#line 427
  return ((char *)"intset");
  default: 
#line 428
  return ((char *)"unknown");
  }
}
}
#line 434 "object.c"
unsigned long estimateObjectIdleTime(robj *o ) 
{ 

  {
#line 435
  if (server.lruclock >= o->lru) {
#line 436
    return ((unsigned long )((server.lruclock - o->lru) * 10U));
  } else {
#line 438
    return ((unsigned long )((((unsigned int )((1 << 21) - 1) - o->lru) + server.lruclock) * 10U));
  }
}
}
#line 1 "db.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-XjgtppAD.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 696 "redis.h"
void touchWatchedKey(redisDb *db , robj *key ) ;
#line 697
void touchWatchedKeysOnFlush(int dbid ) ;
#line 795
robj *vmLoadObject(robj *o ) ;
#line 816
void handleClientsBlockedOnSwappedKey(redisDb *db , robj *key ) ;
#line 871
int removeExpire(redisDb *db , robj *key ) ;
#line 873
int expireIfNeeded(redisDb *db , robj *key ) ;
#line 874
time_t getExpire(redisDb *db , robj *key ) ;
#line 875
void setExpire(redisDb *db , robj *key , time_t when ) ;
#line 876
robj *lookupKey(redisDb *db , robj *key ) ;
#line 877
robj *lookupKeyRead(redisDb *db , robj *key ) ;
#line 878
robj *lookupKeyWrite(redisDb *db , robj *key ) ;
#line 879
robj *lookupKeyReadOrReply(redisClient *c , robj *key , robj *reply ) ;
#line 880
robj *lookupKeyWriteOrReply(redisClient *c , robj *key , robj *reply ) ;
#line 881
int dbAdd(redisDb *db , robj *key , robj *val ) ;
#line 882
int dbReplace(redisDb *db , robj *key , robj *val ) ;
#line 883
int dbExists(redisDb *db , robj *key ) ;
#line 884
robj *dbRandomKey(redisDb *db ) ;
#line 886
long long emptyDb(void) ;
#line 9 "db.c"
robj *lookupKey(redisDb *db , robj *key ) 
{ dictEntry *de ;
  dictEntry *__cil_tmp ;
  robj *val ;
  int notify ;

  {
#line 10
  __cil_tmp = dictFind(db->dict, (void const   *)key->ptr);
#line 10
  de = __cil_tmp;
#line 11
  if (de) {
#line 12
    val = (robj *)de->val;
#line 17
    if (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1) {
#line 18
      val->lru = server.lruclock;
    }
#line 20
    if (server.vm_enabled) {
#line 21
      if (val->storage == 0U || val->storage == 2U) {
#line 25
        if (val->storage == 2U) {
#line 26
          vmCancelThreadedIOJob(val);
        }
      } else {
#line 28
        notify = val->storage == 3U;
#line 31
        if (! (val->type == 8U)) {
#line 31
          _redisAssert((char *)"val->type == REDIS_VMPOINTER", (char *)"db.c", 31);
#line 31
          _exit(1);
        }
#line 32
        val = vmLoadObject(val);
#line 33
        de->val = (void *)val;
#line 37
        if (notify) {
#line 37
          handleClientsBlockedOnSwappedKey(db, key);
        }
      }
    }
#line 40
    (server.stat_keyspace_hits) ++;
#line 41
    return (val);
  } else {
#line 43
    (server.stat_keyspace_misses) ++;
#line 44
    return ((robj *)((void *)0));
  }
}
}
#line 48 "db.c"
robj *lookupKeyRead(redisDb *db , robj *key ) 
{ robj *__cil_tmp ;

  {
#line 49
  expireIfNeeded(db, key);
#line 50
  __cil_tmp = lookupKey(db, key);
#line 50
  return (__cil_tmp);
}
}
#line 53 "db.c"
robj *lookupKeyWrite(redisDb *db , robj *key ) 
{ robj *__cil_tmp ;

  {
#line 54
  expireIfNeeded(db, key);
#line 55
  __cil_tmp = lookupKey(db, key);
#line 55
  return (__cil_tmp);
}
}
#line 58 "db.c"
robj *lookupKeyReadOrReply(redisClient *c , robj *key , robj *reply ) 
{ robj *o ;
  robj *__cil_tmp ;

  {
#line 59
  __cil_tmp = lookupKeyRead(c->db, key);
#line 59
  o = __cil_tmp;
#line 60
  if (! o) {
#line 60
    addReply(c, reply);
  }
#line 61
  return (o);
}
}
#line 64 "db.c"
robj *lookupKeyWriteOrReply(redisClient *c , robj *key , robj *reply ) 
{ robj *o ;
  robj *__cil_tmp ;

  {
#line 65
  __cil_tmp = lookupKeyWrite(c->db, key);
#line 65
  o = __cil_tmp;
#line 66
  if (! o) {
#line 66
    addReply(c, reply);
  }
#line 67
  return (o);
}
}
#line 73 "db.c"
int dbAdd(redisDb *db , robj *key , robj *val ) 
{ sds copy ;
  sds __cil_tmp ;
  dictEntry *__cil_tmp___0 ;

  {
#line 76
  __cil_tmp___0 = dictFind(db->dict, (void const   *)key->ptr);
#line 76
  if ((unsigned int )__cil_tmp___0 != (unsigned int )((void *)0)) {
#line 77
    return (-1);
  } else {
#line 79
    __cil_tmp = sdsdup((char *)key->ptr);
#line 79
    copy = __cil_tmp;
#line 80
    dictAdd(db->dict, (void *)copy, (void *)val);
#line 81
    return (0);
  }
}
}
#line 89 "db.c"
int dbReplace(redisDb *db , robj *key , robj *val ) 
{ sds copy ;
  sds __cil_tmp ;
  dictEntry *__cil_tmp___0 ;

  {
#line 90
  __cil_tmp___0 = dictFind(db->dict, (void const   *)key->ptr);
#line 90
  if ((unsigned int )__cil_tmp___0 == (unsigned int )((void *)0)) {
#line 91
    __cil_tmp = sdsdup((char *)key->ptr);
#line 91
    copy = __cil_tmp;
#line 92
    dictAdd(db->dict, (void *)copy, (void *)val);
#line 93
    return (1);
  } else {
#line 95
    dictReplace(db->dict, key->ptr, (void *)val);
#line 96
    return (0);
  }
}
}
#line 100 "db.c"
int dbExists(redisDb *db , robj *key ) 
{ dictEntry *__cil_tmp ;

  {
#line 101
  __cil_tmp = dictFind(db->dict, (void const   *)key->ptr);
#line 101
  return ((unsigned int )__cil_tmp != (unsigned int )((void *)0));
}
}
#line 108 "db.c"
robj *dbRandomKey(redisDb *db ) 
{ struct dictEntry *de ;
  sds key ;
  robj *keyobj ;
  size_t __cil_tmp ;
  int __cil_tmp___0 ;
  dictEntry *__cil_tmp___1 ;

  {
#line 111
  while (1) {
#line 115
    de = dictGetRandomKey(db->dict);
#line 116
    if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 116
      return ((robj *)((void *)0));
    }
#line 118
    key = (char *)de->key;
#line 119
    __cil_tmp = sdslen(key);
#line 119
    keyobj = createStringObject(key, __cil_tmp);
#line 120
    __cil_tmp___1 = dictFind(db->expires, (void const   *)key);
#line 120
    if (__cil_tmp___1) {
#line 121
      __cil_tmp___0 = expireIfNeeded(db, keyobj);
#line 121
      if (__cil_tmp___0) {
#line 122
        decrRefCount((void *)keyobj);
#line 123
        continue;
      }
    }
#line 126
    return (keyobj);
  }
}
}
#line 131 "db.c"
int dbDelete(redisDb *db , robj *key ) 
{ int __cil_tmp ;

  {
#line 136
  if (server.vm_enabled) {
#line 136
    handleClientsBlockedOnSwappedKey(db, key);
  }
#line 139
  if ((db->expires)->ht[0].used + (db->expires)->ht[1].used > 0UL) {
#line 139
    dictDelete(db->expires, (void const   *)key->ptr);
  }
#line 140
  __cil_tmp = dictDelete(db->dict, (void const   *)key->ptr);
#line 140
  return (__cil_tmp == 0);
}
}
#line 144 "db.c"
long long emptyDb(void) 
{ int j ;
  long long removed ;

  {
#line 146
  removed = 0LL;
#line 148
  j = 0;
#line 148
  while (j < server.dbnum) {
#line 149
    removed += (long long )(((server.db + j)->dict)->ht[0].used + ((server.db + j)->dict)->ht[1].used);
#line 150
    dictEmpty((server.db + j)->dict);
#line 151
    dictEmpty((server.db + j)->expires);
#line 148
    j ++;
  }
#line 153
  return (removed);
}
}
#line 156 "db.c"
int selectDb(redisClient *c , int id ) 
{ 

  {
#line 157
  if (id < 0 || id >= server.dbnum) {
#line 158
    return (-1);
  }
#line 159
  c->db = server.db + id;
#line 160
  return (0);
}
}
#line 167 "db.c"
void flushdbCommand(redisClient *c ) 
{ 

  {
#line 168
  server.dirty += (long long )(((c->db)->dict)->ht[0].used + ((c->db)->dict)->ht[1].used);
#line 169
  touchWatchedKeysOnFlush((c->db)->id);
#line 170
  dictEmpty((c->db)->dict);
#line 171
  dictEmpty((c->db)->expires);
#line 172
  addReply(c, shared.ok);
#line 173
  return;
}
}
#line 175 "db.c"
void flushallCommand(redisClient *c ) 
{ long long __cil_tmp ;

  {
#line 176
  touchWatchedKeysOnFlush(-1);
#line 177
  __cil_tmp = emptyDb();
#line 177
  server.dirty += __cil_tmp;
#line 178
  addReply(c, shared.ok);
#line 179
  if (server.bgsavechildpid != -1) {
#line 180
    kill(server.bgsavechildpid, 9);
#line 181
    rdbRemoveTempFile(server.bgsavechildpid);
  }
#line 183
  rdbSave(server.dbfilename);
#line 184
  (server.dirty) ++;
#line 185
  return;
}
}
#line 187 "db.c"
void delCommand(redisClient *c ) 
{ int deleted ;
  int j ;
  int __cil_tmp ;

  {
#line 188
  deleted = 0;
#line 190
  j = 1;
#line 190
  while (j < c->argc) {
#line 191
    __cil_tmp = dbDelete(c->db, *(c->argv + j));
#line 191
    if (__cil_tmp) {
#line 192
      touchWatchedKey(c->db, *(c->argv + j));
#line 193
      (server.dirty) ++;
#line 194
      deleted ++;
    }
#line 190
    j ++;
  }
#line 197
  addReplyLongLong(c, (long long )deleted);
#line 198
  return;
}
}
#line 200 "db.c"
void existsCommand(redisClient *c ) 
{ int __cil_tmp ;

  {
#line 201
  expireIfNeeded(c->db, *(c->argv + 1));
#line 202
  __cil_tmp = dbExists(c->db, *(c->argv + 1));
#line 202
  if (__cil_tmp) {
#line 203
    addReply(c, shared.cone);
  } else {
#line 205
    addReply(c, shared.czero);
  }
#line 207
  return;
}
}
#line 209 "db.c"
void selectCommand(redisClient *c ) 
{ int id ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 210
  __cil_tmp = atoi((char const   *)(*(c->argv + 1))->ptr);
#line 210
  id = __cil_tmp;
#line 212
  __cil_tmp___0 = selectDb(c, id);
#line 212
  if (__cil_tmp___0 == -1) {
#line 213
    addReplyError(c, (char *)"invalid DB index");
  } else {
#line 215
    addReply(c, shared.ok);
  }
#line 217
  return;
}
}
#line 219 "db.c"
void randomkeyCommand(redisClient *c ) 
{ robj *key ;

  {
#line 222
  key = dbRandomKey(c->db);
#line 222
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 223
    addReply(c, shared.nullbulk);
#line 224
    return;
  }
#line 227
  addReplyBulk(c, key);
#line 228
  decrRefCount((void *)key);
#line 229
  return;
}
}
#line 231 "db.c"
void keysCommand(redisClient *c ) 
{ dictIterator *di ;
  dictEntry *de ;
  sds pattern ;
  int plen ;
  size_t __cil_tmp ;
  int allkeys ;
  unsigned long numkeys ;
  void *replylen ;
  void *__cil_tmp___0 ;
  sds key ;
  robj *keyobj ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 234
  pattern = (char *)(*(c->argv + 1))->ptr;
#line 235
  __cil_tmp = sdslen(pattern);
#line 235
  plen = (int )__cil_tmp;
#line 236
  numkeys = 0UL;
#line 237
  __cil_tmp___0 = addDeferredMultiBulkLength(c);
#line 237
  replylen = __cil_tmp___0;
#line 239
  di = dictGetIterator((c->db)->dict);
#line 240
  allkeys = (int )*(pattern + 0) == 42 && (int )*(pattern + 1) == 0;
#line 241
  while (1) {
#line 241
    de = dictNext(di);
#line 241
    if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 241
      break;
    }
#line 242
    key = (char *)de->key;
#line 245
    if (allkeys) {
#line 245
      goto _L;
    } else {
#line 245
      __cil_tmp___3 = sdslen(key);
#line 245
      __cil_tmp___4 = stringmatchlen((char const   *)pattern, plen, (char const   *)key,
                                     (int )__cil_tmp___3, 0);
#line 245
      if (__cil_tmp___4) {
        _L: 
#line 246
        __cil_tmp___1 = sdslen(key);
#line 246
        keyobj = createStringObject(key, __cil_tmp___1);
#line 247
        __cil_tmp___2 = expireIfNeeded(c->db, keyobj);
#line 247
        if (__cil_tmp___2 == 0) {
#line 248
          addReplyBulk(c, keyobj);
#line 249
          numkeys ++;
        }
#line 251
        decrRefCount((void *)keyobj);
      }
    }
  }
#line 254
  dictReleaseIterator(di);
#line 255
  setDeferredMultiBulkLength(c, replylen, (long )numkeys);
#line 256
  return;
}
}
#line 258 "db.c"
void dbsizeCommand(redisClient *c ) 
{ 

  {
#line 259
  addReplyLongLong(c, (long long )(((c->db)->dict)->ht[0].used + ((c->db)->dict)->ht[1].used));
#line 260
  return;
}
}
#line 262 "db.c"
void lastsaveCommand(redisClient *c ) 
{ 

  {
#line 263
  addReplyLongLong(c, (long long )server.lastsave);
#line 264
  return;
}
}
#line 266 "db.c"
void typeCommand(redisClient *c ) 
{ robj *o ;
  char *type ;

  {
#line 270
  o = lookupKeyRead(c->db, *(c->argv + 1));
#line 271
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 272
    type = (char *)"none";
  } else {
#line 274
    switch ((int )o->type) {
    case 0: 
#line 275
    type = (char *)"string";
#line 275
    break;
    case 1: 
#line 276
    type = (char *)"list";
#line 276
    break;
    case 2: 
#line 277
    type = (char *)"set";
#line 277
    break;
    case 3: 
#line 278
    type = (char *)"zset";
#line 278
    break;
    case 4: 
#line 279
    type = (char *)"hash";
#line 279
    break;
    default: 
#line 280
    type = (char *)"unknown";
#line 280
    break;
    }
  }
#line 283
  addReplyStatus(c, type);
#line 284
  return;
}
}
#line 286 "db.c"
void saveCommand(redisClient *c ) 
{ int __cil_tmp ;

  {
#line 287
  if (server.bgsavechildpid != -1) {
#line 288
    addReplyError(c, (char *)"Background save already in progress");
#line 289
    return;
  }
#line 291
  __cil_tmp = rdbSave(server.dbfilename);
#line 291
  if (__cil_tmp == 0) {
#line 292
    addReply(c, shared.ok);
  } else {
#line 294
    addReply(c, shared.err);
  }
#line 296
  return;
}
}
#line 298 "db.c"
void bgsaveCommand(redisClient *c ) 
{ int __cil_tmp ;

  {
#line 299
  if (server.bgsavechildpid != -1) {
#line 300
    addReplyError(c, (char *)"Background save already in progress");
#line 301
    return;
  }
#line 303
  __cil_tmp = rdbSaveBackground(server.dbfilename);
#line 303
  if (__cil_tmp == 0) {
#line 304
    addReplyStatus(c, (char *)"Background saving started");
  } else {
#line 306
    addReply(c, shared.err);
  }
#line 308
  return;
}
}
#line 310 "db.c"
void shutdownCommand(redisClient *c ) 
{ int __cil_tmp ;

  {
#line 311
  __cil_tmp = prepareForShutdown();
#line 311
  if (__cil_tmp == 0) {
#line 312
    exit(0);
  }
#line 313
  addReplyError(c, (char *)"Errors trying to SHUTDOWN. Check logs.");
#line 314
  return;
}
}
#line 316 "db.c"
void renameGenericCommand(redisClient *c , int nx ) 
{ robj *o ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 320
  __cil_tmp = sdscmp((char *)(*(c->argv + 1))->ptr, (char *)(*(c->argv + 2))->ptr);
#line 320
  if (__cil_tmp == 0) {
#line 321
    addReply(c, shared.sameobjecterr);
#line 322
    return;
  }
#line 325
  o = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.nokeyerr);
#line 325
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 326
    return;
  }
#line 328
  incrRefCount(o);
#line 329
  __cil_tmp___0 = dbAdd(c->db, *(c->argv + 2), o);
#line 329
  if (__cil_tmp___0 == -1) {
#line 330
    if (nx) {
#line 331
      decrRefCount((void *)o);
#line 332
      addReply(c, shared.czero);
#line 333
      return;
    }
#line 335
    dbReplace(c->db, *(c->argv + 2), o);
  }
#line 337
  dbDelete(c->db, *(c->argv + 1));
#line 338
  touchWatchedKey(c->db, *(c->argv + 1));
#line 339
  touchWatchedKey(c->db, *(c->argv + 2));
#line 340
  (server.dirty) ++;
#line 341
  addReply(c, nx ? shared.cone : shared.ok);
#line 342
  return;
}
}
#line 344 "db.c"
void renameCommand(redisClient *c ) 
{ 

  {
#line 345
  renameGenericCommand(c, 0);
#line 346
  return;
}
}
#line 348 "db.c"
void renamenxCommand(redisClient *c ) 
{ 

  {
#line 349
  renameGenericCommand(c, 1);
#line 350
  return;
}
}
#line 352 "db.c"
void moveCommand(redisClient *c ) 
{ robj *o ;
  redisDb *src ;
  redisDb *dst ;
  int srcid ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 358
  src = c->db;
#line 359
  srcid = (c->db)->id;
#line 360
  __cil_tmp = atoi((char const   *)(*(c->argv + 2))->ptr);
#line 360
  __cil_tmp___0 = selectDb(c, __cil_tmp);
#line 360
  if (__cil_tmp___0 == -1) {
#line 361
    addReply(c, shared.outofrangeerr);
#line 362
    return;
  }
#line 364
  dst = c->db;
#line 365
  selectDb(c, srcid);
#line 369
  if ((unsigned int )src == (unsigned int )dst) {
#line 370
    addReply(c, shared.sameobjecterr);
#line 371
    return;
  }
#line 375
  o = lookupKeyWrite(c->db, *(c->argv + 1));
#line 376
  if (! o) {
#line 377
    addReply(c, shared.czero);
#line 378
    return;
  }
#line 382
  __cil_tmp___1 = dbAdd(dst, *(c->argv + 1), o);
#line 382
  if (__cil_tmp___1 == -1) {
#line 383
    addReply(c, shared.czero);
#line 384
    return;
  }
#line 386
  incrRefCount(o);
#line 389
  dbDelete(src, *(c->argv + 1));
#line 390
  (server.dirty) ++;
#line 391
  addReply(c, shared.cone);
#line 392
  return;
}
}
#line 398 "db.c"
int removeExpire(redisDb *db , robj *key ) 
{ dictEntry *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 401
  __cil_tmp = dictFind(db->dict, (void const   *)key->ptr);
#line 401
  if (! ((unsigned int )__cil_tmp != (unsigned int )((void *)0))) {
#line 401
    _redisAssert((char *)"dictFind(db->dict,key->ptr) != NULL", (char *)"db.c", 401);
#line 401
    _exit(1);
  }
#line 402
  __cil_tmp___0 = dictDelete(db->expires, (void const   *)key->ptr);
#line 402
  return (__cil_tmp___0 == 0);
}
}
#line 405 "db.c"
void setExpire(redisDb *db , robj *key , time_t when ) 
{ dictEntry *de ;

  {
#line 409
  de = dictFind(db->dict, (void const   *)key->ptr);
#line 410
  if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 410
    _redisAssert((char *)"de != NULL", (char *)"db.c", 410);
#line 410
    _exit(1);
  }
#line 411
  dictReplace(db->expires, de->key, (void *)when);
#line 412
  return;
}
}
#line 416 "db.c"
time_t getExpire(redisDb *db , robj *key ) 
{ dictEntry *de ;
  dictEntry *__cil_tmp ;

  {
#line 420
  if ((db->expires)->ht[0].used + (db->expires)->ht[1].used == 0UL) {
#line 421
    return (-1L);
  } else {
#line 420
    de = dictFind(db->expires, (void const   *)key->ptr);
#line 420
    if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 421
      return (-1L);
    }
  }
#line 425
  __cil_tmp = dictFind(db->dict, (void const   *)key->ptr);
#line 425
  if (! ((unsigned int )__cil_tmp != (unsigned int )((void *)0))) {
#line 425
    _redisAssert((char *)"dictFind(db->dict,key->ptr) != NULL", (char *)"db.c", 425);
#line 425
    _exit(1);
  }
#line 426
  return ((long )de->val);
}
}
#line 437 "db.c"
void propagateExpire(redisDb *db , robj *key ) 
{ robj *argv[2] ;

  {
#line 440
  argv[0] = createStringObject((char *)"DEL", 3U);
#line 441
  argv[1] = key;
#line 442
  incrRefCount(key);
#line 444
  if (server.appendonly) {
#line 445
    feedAppendOnlyFile(server.delCommand, db->id, argv, 2);
  }
#line 446
  if ((server.slaves)->len) {
#line 447
    replicationFeedSlaves(server.slaves, db->id, argv, 2);
  }
#line 449
  decrRefCount((void *)argv[0]);
#line 450
  decrRefCount((void *)argv[1]);
#line 451
  return;
}
}
#line 453 "db.c"
int expireIfNeeded(redisDb *db , robj *key ) 
{ time_t when ;
  time_t __cil_tmp ;
  time_t __cil_tmp___0 ;
  time_t __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 454
  __cil_tmp = getExpire(db, key);
#line 454
  when = __cil_tmp;
#line 456
  if (when < 0L) {
#line 456
    return (0);
  }
#line 465
  if ((unsigned int )server.masterhost != (unsigned int )((void *)0)) {
#line 466
    __cil_tmp___0 = time((time_t *)((void *)0));
#line 466
    return (__cil_tmp___0 > when);
  }
#line 470
  __cil_tmp___1 = time((time_t *)((void *)0));
#line 470
  if (__cil_tmp___1 <= when) {
#line 470
    return (0);
  }
#line 473
  (server.stat_expiredkeys) ++;
#line 474
  propagateExpire(db, key);
#line 475
  __cil_tmp___2 = dbDelete(db, key);
#line 475
  return (__cil_tmp___2);
}
}
#line 482 "db.c"
void expireGenericCommand(redisClient *c , robj *key , robj *param , long offset ) 
{ dictEntry *de ;
  long seconds ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  time_t when ;
  time_t __cil_tmp___1 ;

  {
#line 486
  __cil_tmp = getLongFromObjectOrReply(c, param, & seconds, (char const   *)((void *)0));
#line 486
  if (__cil_tmp != 0) {
#line 486
    return;
  }
#line 488
  seconds -= offset;
#line 490
  de = dictFind((c->db)->dict, (void const   *)key->ptr);
#line 491
  if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 492
    addReply(c, shared.czero);
#line 493
    return;
  }
#line 495
  if (seconds <= 0L) {
#line 496
    __cil_tmp___0 = dbDelete(c->db, key);
#line 496
    if (__cil_tmp___0) {
#line 496
      (server.dirty) ++;
    }
#line 497
    addReply(c, shared.cone);
#line 498
    touchWatchedKey(c->db, key);
#line 499
    return;
  } else {
#line 501
    __cil_tmp___1 = time((time_t *)((void *)0));
#line 501
    when = __cil_tmp___1 + seconds;
#line 502
    setExpire(c->db, key, when);
#line 503
    addReply(c, shared.cone);
#line 504
    touchWatchedKey(c->db, key);
#line 505
    (server.dirty) ++;
#line 506
    return;
  }
}
}
#line 510 "db.c"
void expireCommand(redisClient *c ) 
{ 

  {
#line 511
  expireGenericCommand(c, *(c->argv + 1), *(c->argv + 2), 0L);
#line 512
  return;
}
}
#line 514 "db.c"
void expireatCommand(redisClient *c ) 
{ time_t __cil_tmp ;

  {
#line 515
  __cil_tmp = time((time_t *)((void *)0));
#line 515
  expireGenericCommand(c, *(c->argv + 1), *(c->argv + 2), __cil_tmp);
#line 516
  return;
}
}
#line 518 "db.c"
void ttlCommand(redisClient *c ) 
{ time_t expire ;
  time_t ttl ;
  time_t __cil_tmp ;

  {
#line 519
  ttl = -1L;
#line 521
  expire = getExpire(c->db, *(c->argv + 1));
#line 522
  if (expire != -1L) {
#line 523
    __cil_tmp = time((time_t *)((void *)0));
#line 523
    ttl = expire - __cil_tmp;
#line 524
    if (ttl < 0L) {
#line 524
      ttl = -1L;
    }
  }
#line 526
  addReplyLongLong(c, (long long )ttl);
#line 527
  return;
}
}
#line 529 "db.c"
void persistCommand(redisClient *c ) 
{ dictEntry *de ;
  int __cil_tmp ;

  {
#line 532
  de = dictFind((c->db)->dict, (void const   *)(*(c->argv + 1))->ptr);
#line 533
  if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 534
    addReply(c, shared.czero);
  } else {
#line 536
    __cil_tmp = removeExpire(c->db, *(c->argv + 1));
#line 536
    if (__cil_tmp) {
#line 537
      addReply(c, shared.cone);
#line 538
      (server.dirty) ++;
    } else {
#line 540
      addReply(c, shared.czero);
    }
  }
#line 543
  return;
}
}
#line 1 "replication.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CsfZnrVf.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 229 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int rename(char const   *old , char const   *new ) ;
#line 118 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
off_t lseek(int fd , off_t offset , int whence ) ;
#line 731 "redis.h"
int syncWrite(int fd , char *ptr , ssize_t size , int timeout ) ;
#line 733
int syncReadLine(int fd , char *ptr , ssize_t size , int timeout ) ;
#line 742
int syncWithMaster(void) ;
#line 743
void updateSlavesWaitingBgsave(int bgsaveerr ) ;
#line 766
int rewriteAppendOnlyFileBackground(void) ;
#line 84 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/stat.h"
int fstat(int fildes , struct stat *buf ) ;
#line 10 "replication.c"
void replicationFeedSlaves(list *slaves , int dictid , robj **argv , int argc ) 
{ listNode *ln ;
  listIter li ;
  int outc ;
  int j ;
  robj **outv ;
  robj *static_outv[25] ;
  robj *lenobj ;
  void *__cil_tmp ;
  sds __cil_tmp___0 ;
  sds __cil_tmp___1 ;
  int __cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  sds __cil_tmp___4 ;
  sds __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  redisClient *slave ;
  robj *selectcmd ;
  sds __cil_tmp___9 ;
  sds __cil_tmp___10 ;

  {
#line 13
  outc = 0;
#line 21
  if (argc <= 8) {
#line 22
    outv = static_outv;
  } else {
#line 24
    __cil_tmp = malloc((unsigned int )(sizeof(robj *) * (unsigned long )(argc * 3 + 1)));
#line 24
    outv = (robj **)__cil_tmp;
  }
#line 27
  __cil_tmp___0 = sdsempty();
#line 27
  __cil_tmp___1 = sdscatprintf(__cil_tmp___0, "*%d\r\n", argc);
#line 27
  lenobj = createObject(0, (void *)__cil_tmp___1);
#line 29
  lenobj->refcount = 0;
#line 30
  __cil_tmp___2 = outc;
#line 30
  outc ++;
#line 30
  *(outv + __cil_tmp___2) = lenobj;
#line 31
  j = 0;
#line 31
  while (j < argc) {
#line 32
    __cil_tmp___3 = stringObjectLen(*(argv + j));
#line 32
    __cil_tmp___4 = sdsempty();
#line 32
    __cil_tmp___5 = sdscatprintf(__cil_tmp___4, "$%lu\r\n", (unsigned long )__cil_tmp___3);
#line 32
    lenobj = createObject(0, (void *)__cil_tmp___5);
#line 35
    lenobj->refcount = 0;
#line 36
    __cil_tmp___6 = outc;
#line 36
    outc ++;
#line 36
    *(outv + __cil_tmp___6) = lenobj;
#line 37
    __cil_tmp___7 = outc;
#line 37
    outc ++;
#line 37
    *(outv + __cil_tmp___7) = *(argv + j);
#line 38
    __cil_tmp___8 = outc;
#line 38
    outc ++;
#line 38
    *(outv + __cil_tmp___8) = shared.crlf;
#line 31
    j ++;
  }
#line 44
  j = 0;
#line 44
  while (j < outc) {
#line 44
    incrRefCount(*(outv + j));
#line 44
    j ++;
  }
#line 45
  listRewind(slaves, & li);
#line 46
  while (1) {
#line 46
    ln = listNext(& li);
#line 46
    if (! ln) {
#line 46
      break;
    }
#line 47
    slave = (redisClient *)ln->value;
#line 50
    if (slave->replstate == 3) {
#line 50
      continue;
    }
#line 53
    if (slave->slaveseldb != dictid) {
#line 56
      switch (dictid) {
      case 0: 
#line 57
      selectcmd = shared.select0;
#line 57
      break;
      case 1: 
#line 58
      selectcmd = shared.select1;
#line 58
      break;
      case 2: 
#line 59
      selectcmd = shared.select2;
#line 59
      break;
      case 3: 
#line 60
      selectcmd = shared.select3;
#line 60
      break;
      case 4: 
#line 61
      selectcmd = shared.select4;
#line 61
      break;
      case 5: 
#line 62
      selectcmd = shared.select5;
#line 62
      break;
      case 6: 
#line 63
      selectcmd = shared.select6;
#line 63
      break;
      case 7: 
#line 64
      selectcmd = shared.select7;
#line 64
      break;
      case 8: 
#line 65
      selectcmd = shared.select8;
#line 65
      break;
      case 9: 
#line 66
      selectcmd = shared.select9;
#line 66
      break;
      default: 
#line 68
      __cil_tmp___9 = sdsempty();
#line 68
      __cil_tmp___10 = sdscatprintf(__cil_tmp___9, "select %d\r\n", dictid);
#line 68
      selectcmd = createObject(0, (void *)__cil_tmp___10);
#line 70
      selectcmd->refcount = 0;
#line 71
      break;
      }
#line 73
      addReply(slave, selectcmd);
#line 74
      slave->slaveseldb = dictid;
    }
#line 76
    j = 0;
#line 76
    while (j < outc) {
#line 76
      addReply(slave, *(outv + j));
#line 76
      j ++;
    }
  }
#line 78
  j = 0;
#line 78
  while (j < outc) {
#line 78
    decrRefCount((void *)*(outv + j));
#line 78
    j ++;
  }
#line 79
  if ((unsigned int )outv != (unsigned int )(static_outv)) {
#line 79
    free((void *)outv);
  }
#line 80
  return;
}
}
#line 82 "replication.c"
void replicationFeedMonitors(list *monitors , int dictid , robj **argv , int argc ) 
{ listNode *ln ;
  listIter li ;
  int j ;
  sds cmdrepr ;
  sds __cil_tmp ;
  robj *cmdobj ;
  struct timeval tv ;
  size_t __cil_tmp___0 ;
  redisClient *monitor ;

  {
#line 86
  __cil_tmp = sdsnew("+");
#line 86
  cmdrepr = __cil_tmp;
#line 90
  gettimeofday(& tv, (void *)0);
#line 91
  cmdrepr = sdscatprintf(cmdrepr, "%ld.%06ld ", tv.tv_sec, tv.tv_usec);
#line 92
  if (dictid != 0) {
#line 92
    cmdrepr = sdscatprintf(cmdrepr, "(db %d) ", dictid);
  }
#line 94
  j = 0;
#line 94
  while (j < argc) {
#line 95
    if ((*(argv + j))->encoding == 1U) {
#line 96
      cmdrepr = sdscatprintf(cmdrepr, "\"%ld\"", (long )(*(argv + j))->ptr);
    } else {
#line 98
      __cil_tmp___0 = sdslen((char *)(*(argv + j))->ptr);
#line 98
      cmdrepr = sdscatrepr(cmdrepr, (char *)(*(argv + j))->ptr, __cil_tmp___0);
    }
#line 101
    if (j != argc - 1) {
#line 102
      cmdrepr = sdscatlen(cmdrepr, (void *)" ", 1U);
    }
#line 94
    j ++;
  }
#line 104
  cmdrepr = sdscatlen(cmdrepr, (void *)"\r\n", 2U);
#line 105
  cmdobj = createObject(0, (void *)cmdrepr);
#line 107
  listRewind(monitors, & li);
#line 108
  while (1) {
#line 108
    ln = listNext(& li);
#line 108
    if (! ln) {
#line 108
      break;
    }
#line 109
    monitor = (redisClient *)ln->value;
#line 110
    addReply(monitor, cmdobj);
  }
#line 112
  decrRefCount((void *)cmdobj);
#line 113
  return;
}
}
#line 115 "replication.c"
void syncCommand(redisClient *c ) 
{ redisClient *slave ;
  listNode *ln ;
  listIter li ;
  int __cil_tmp ;

  {
#line 117
  if (c->flags & 1) {
#line 117
    return;
  }
#line 121
  if (server.masterhost && server.replstate != 3) {
#line 122
    addReplyError(c, (char *)"Can\'t SYNC while not connected with my master");
#line 123
    return;
  }
#line 130
  if ((c->reply)->len != 0U) {
#line 131
    addReplyError(c, (char *)"SYNC is invalid with pending input");
#line 132
    return;
  }
#line 135
  redisLog(2, "Slave ask for synchronization");
#line 138
  if (server.bgsavechildpid != -1) {
#line 146
    listRewind(server.slaves, & li);
#line 147
    while (1) {
#line 147
      ln = listNext(& li);
#line 147
      if (! ln) {
#line 147
        break;
      }
#line 148
      slave = (redisClient *)ln->value;
#line 149
      if (slave->replstate == 4) {
#line 149
        break;
      }
    }
#line 151
    if (ln) {
#line 154
      listRelease(c->reply);
#line 155
      c->reply = listDup(slave->reply);
#line 156
      c->replstate = 4;
#line 157
      redisLog(2, "Waiting for end of BGSAVE for SYNC");
    } else {
#line 161
      c->replstate = 3;
#line 162
      redisLog(2, "Waiting for next BGSAVE for SYNC");
    }
  } else {
#line 166
    redisLog(2, "Starting BGSAVE for SYNC");
#line 167
    __cil_tmp = rdbSaveBackground(server.dbfilename);
#line 167
    if (__cil_tmp != 0) {
#line 168
      redisLog(2, "Replication failed, can\'t BGSAVE");
#line 169
      addReplyError(c, (char *)"Unable to perform background save");
#line 170
      return;
    }
#line 172
    c->replstate = 4;
  }
#line 174
  c->repldbfd = -1;
#line 175
  c->flags |= 1;
#line 176
  c->slaveseldb = 0;
#line 177
  listAddNodeTail(server.slaves, (void *)c);
#line 178
  return;
}
}
#line 181 "replication.c"
void sendBulkToSlave(aeEventLoop *el , int fd , void *privdata , int mask ) 
{ redisClient *slave ;
  char buf[1024] ;
  ssize_t nwritten ;
  ssize_t buflen ;
  sds bulkcount ;
  sds __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  char const   *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  char *__cil_tmp___7 ;
  int __cil_tmp___8 ;
  sds __cil_tmp___9 ;

  {
#line 182
  slave = (redisClient *)privdata;
#line 188
  if (slave->repldboff == 0L) {
#line 195
    __cil_tmp = sdsempty();
#line 195
    bulkcount = sdscatprintf(__cil_tmp, "$%lld\r\n", (unsigned long long )slave->repldbsize);
#line 197
    __cil_tmp___0 = sdslen(bulkcount);
#line 197
    __cil_tmp___1 = write(fd, (void const   *)bulkcount, __cil_tmp___0);
#line 197
    __cil_tmp___2 = sdslen(bulkcount);
#line 197
    if (__cil_tmp___1 != (int )__cil_tmp___2) {
#line 199
      sdsfree(bulkcount);
#line 200
      freeClient(slave);
#line 201
      return;
    }
#line 203
    sdsfree(bulkcount);
  }
#line 205
  lseek(slave->repldbfd, slave->repldboff, 0);
#line 206
  buflen = read(slave->repldbfd, (void *)(buf), 1024U);
#line 207
  if (buflen <= 0) {
#line 208
    if (buflen == 0) {
#line 208
      __cil_tmp___5 = "premature EOF";
    } else {
#line 208
      __cil_tmp___3 = __errno();
#line 208
      __cil_tmp___4 = strerror(*__cil_tmp___3);
#line 208
      __cil_tmp___5 = (char const   *)__cil_tmp___4;
    }
#line 208
    redisLog(3, "Read error sending DB to slave: %s", __cil_tmp___5);
#line 210
    freeClient(slave);
#line 211
    return;
  }
#line 213
  nwritten = write(fd, (void const   *)(buf), (unsigned int )buflen);
#line 213
  if (nwritten == -1) {
#line 214
    __cil_tmp___6 = __errno();
#line 214
    __cil_tmp___7 = strerror(*__cil_tmp___6);
#line 214
    redisLog(1, "Write error sending DB to slave: %s", __cil_tmp___7);
#line 216
    freeClient(slave);
#line 217
    return;
  }
#line 219
  slave->repldboff += (long )nwritten;
#line 220
  if (slave->repldboff == slave->repldbsize) {
#line 221
    close(slave->repldbfd);
#line 222
    slave->repldbfd = -1;
#line 223
    aeDeleteFileEvent(server.el, slave->fd, 2);
#line 224
    slave->replstate = 6;
#line 225
    __cil_tmp___8 = aeCreateFileEvent(server.el, slave->fd, 2, & sendReplyToClient,
                                      (void *)slave);
#line 225
    if (__cil_tmp___8 == -1) {
#line 227
      freeClient(slave);
#line 228
      return;
    }
#line 230
    __cil_tmp___9 = sdsempty();
#line 230
    addReplySds(slave, __cil_tmp___9);
#line 231
    redisLog(2, "Synchronization with slave succeeded");
  }
#line 233
  return;
}
}
#line 241 "replication.c"
void updateSlavesWaitingBgsave(int bgsaveerr ) 
{ listNode *ln ;
  int startbgsave ;
  listIter li ;
  redisClient *slave ;
  struct stat buf ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  listIter li___0 ;
  redisClient *slave___0 ;
  int __cil_tmp___4 ;

  {
#line 243
  startbgsave = 0;
#line 246
  listRewind(server.slaves, & li);
#line 247
  while (1) {
#line 247
    ln = listNext(& li);
#line 247
    if (! ln) {
#line 247
      break;
    }
#line 248
    slave = (redisClient *)ln->value;
#line 250
    if (slave->replstate == 3) {
#line 251
      startbgsave = 1;
#line 252
      slave->replstate = 4;
    } else
#line 253
    if (slave->replstate == 4) {
#line 256
      if (bgsaveerr != 0) {
#line 257
        freeClient(slave);
#line 258
        redisLog(3, "SYNC failed. BGSAVE child returned an error");
#line 259
        continue;
      }
#line 261
      __cil_tmp___1 = open((char const   *)server.dbfilename, 1);
#line 261
      slave->repldbfd = __cil_tmp___1;
#line 261
      if (__cil_tmp___1 == -1) {
#line 263
        freeClient(slave);
#line 264
        __cil_tmp = __errno();
#line 264
        __cil_tmp___0 = strerror(*__cil_tmp);
#line 264
        redisLog(3, "SYNC failed. Can\'t open/stat DB after BGSAVE: %s", __cil_tmp___0);
#line 265
        continue;
      } else {
#line 261
        __cil_tmp___2 = fstat(slave->repldbfd, & buf);
#line 261
        if (__cil_tmp___2 == -1) {
#line 263
          freeClient(slave);
#line 264
          __cil_tmp = __errno();
#line 264
          __cil_tmp___0 = strerror(*__cil_tmp);
#line 264
          redisLog(3, "SYNC failed. Can\'t open/stat DB after BGSAVE: %s", __cil_tmp___0);
#line 265
          continue;
        }
      }
#line 267
      slave->repldboff = 0L;
#line 268
      slave->repldbsize = buf.st_size;
#line 269
      slave->replstate = 5;
#line 270
      aeDeleteFileEvent(server.el, slave->fd, 2);
#line 271
      __cil_tmp___3 = aeCreateFileEvent(server.el, slave->fd, 2, & sendBulkToSlave,
                                        (void *)slave);
#line 271
      if (__cil_tmp___3 == -1) {
#line 272
        freeClient(slave);
#line 273
        continue;
      }
    }
  }
#line 277
  if (startbgsave) {
#line 278
    __cil_tmp___4 = rdbSaveBackground(server.dbfilename);
#line 278
    if (__cil_tmp___4 != 0) {
#line 281
      listRewind(server.slaves, & li___0);
#line 282
      redisLog(3, "SYNC failed. BGSAVE failed");
#line 283
      while (1) {
#line 283
        ln = listNext(& li___0);
#line 283
        if (! ln) {
#line 283
          break;
        }
#line 284
        slave___0 = (redisClient *)ln->value;
#line 286
        if (slave___0->replstate == 3) {
#line 287
          freeClient(slave___0);
        }
      }
    }
  }
#line 291
  return;
}
}
#line 296 "replication.c"
void replicationAbortSyncTransfer(void) 
{ 

  {
#line 297
  if (! (server.replstate == 2)) {
#line 297
    _redisAssert((char *)"server.replstate == REDIS_REPL_TRANSFER", (char *)"replication.c",
                 297);
#line 297
    _exit(1);
  }
#line 299
  aeDeleteFileEvent(server.el, server.repl_transfer_s, 1);
#line 300
  close(server.repl_transfer_s);
#line 301
  close(server.repl_transfer_fd);
#line 302
  unlink((char const   *)server.repl_transfer_tmpfile);
#line 303
  free((void *)server.repl_transfer_tmpfile);
#line 304
  server.replstate = 1;
#line 305
  return;
}
}
#line 308 "replication.c"
void readSyncBulkPayload(aeEventLoop *el , int fd , void *privdata , int mask ) 
{ char buf[4096] ;
  ssize_t nread ;
  ssize_t readlen ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  char const   *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  char *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int *__cil_tmp___8 ;
  char *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;

  {
#line 317
  if (server.repl_transfer_left == -1L) {
#line 318
    __cil_tmp___1 = syncReadLine(fd, buf, 1024, 3600);
#line 318
    if (__cil_tmp___1 == -1) {
#line 319
      __cil_tmp = __errno();
#line 319
      __cil_tmp___0 = strerror(*__cil_tmp);
#line 319
      redisLog(3, "I/O error reading bulk count from MASTER: %s", __cil_tmp___0);
#line 322
      replicationAbortSyncTransfer();
#line 323
      return;
    }
#line 325
    if ((int )buf[0] == 45) {
#line 326
      redisLog(3, "MASTER aborted replication with an error: %s", buf + 1);
#line 329
      replicationAbortSyncTransfer();
#line 330
      return;
    } else
#line 331
    if ((int )buf[0] == 0) {
#line 335
      server.repl_transfer_lastio = time((time_t *)((void *)0));
#line 336
      return;
    } else
#line 337
    if ((int )buf[0] != 36) {
#line 338
      redisLog(3, "Bad protocol from MASTER, the first byte is not \'$\', are you sure the host and port are right?");
#line 339
      replicationAbortSyncTransfer();
#line 340
      return;
    }
#line 342
    server.repl_transfer_left = strtol((char const   *)(buf + 1), (char **)((void *)0),
                                       10);
#line 343
    redisLog(2, "MASTER <-> SLAVE sync: receiving %ld bytes from master", server.repl_transfer_left);
#line 346
    return;
  }
#line 350
  readlen = (int )(server.repl_transfer_left < (long )((int )sizeof(buf)) ? server.repl_transfer_left : (long )((int )sizeof(buf)));
#line 352
  nread = read(fd, (void *)(buf), (unsigned int )readlen);
#line 353
  if (nread <= 0) {
#line 354
    if (nread == -1) {
#line 354
      __cil_tmp___2 = __errno();
#line 354
      __cil_tmp___3 = strerror(*__cil_tmp___2);
#line 354
      __cil_tmp___4 = (char const   *)__cil_tmp___3;
    } else {
#line 354
      __cil_tmp___4 = "connection lost";
    }
#line 354
    redisLog(3, "I/O error trying to sync with MASTER: %s", __cil_tmp___4);
#line 356
    replicationAbortSyncTransfer();
#line 357
    return;
  }
#line 359
  server.repl_transfer_lastio = time((time_t *)((void *)0));
#line 360
  __cil_tmp___7 = write(server.repl_transfer_fd, (void const   *)(buf), (unsigned int )nread);
#line 360
  if (__cil_tmp___7 != nread) {
#line 361
    __cil_tmp___5 = __errno();
#line 361
    __cil_tmp___6 = strerror(*__cil_tmp___5);
#line 361
    redisLog(3, "Write error or short write writing to the DB dump file needed for MASTER <-> SLAVE synchrnonization: %s",
             __cil_tmp___6);
#line 362
    replicationAbortSyncTransfer();
#line 363
    return;
  }
#line 365
  server.repl_transfer_left -= (long )nread;
#line 367
  if (server.repl_transfer_left == 0L) {
#line 368
    __cil_tmp___10 = rename((char const   *)server.repl_transfer_tmpfile, (char const   *)server.dbfilename);
#line 368
    if (__cil_tmp___10 == -1) {
#line 369
      __cil_tmp___8 = __errno();
#line 369
      __cil_tmp___9 = strerror(*__cil_tmp___8);
#line 369
      redisLog(3, "Failed trying to rename the temp DB into dump.rdb in MASTER <-> SLAVE synchronization: %s",
               __cil_tmp___9);
#line 370
      replicationAbortSyncTransfer();
#line 371
      return;
    }
#line 373
    redisLog(2, "MASTER <-> SLAVE sync: Loading DB in memory");
#line 374
    emptyDb();
#line 379
    aeDeleteFileEvent(server.el, server.repl_transfer_s, 1);
#line 380
    __cil_tmp___11 = rdbLoad(server.dbfilename);
#line 380
    if (__cil_tmp___11 != 0) {
#line 381
      redisLog(3, "Failed trying to load the MASTER synchronization DB from disk");
#line 382
      replicationAbortSyncTransfer();
#line 383
      return;
    }
#line 386
    free((void *)server.repl_transfer_tmpfile);
#line 387
    close(server.repl_transfer_fd);
#line 388
    server.master = createClient(server.repl_transfer_s);
#line 389
    (server.master)->flags |= 2;
#line 390
    (server.master)->authenticated = 1;
#line 391
    server.replstate = 3;
#line 392
    redisLog(2, "MASTER <-> SLAVE sync: Finished with success");
  }
#line 394
  return;
}
}
#line 396 "replication.c"
int syncWithMaster(void) 
{ char buf[1024] ;
  char tmpfile___0[256] ;
  char authcmd[1024] ;
  int fd ;
  int __cil_tmp ;
  int dfd ;
  int maxtries ;
  int *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int *__cil_tmp___6 ;
  char *__cil_tmp___7 ;
  int __cil_tmp___8 ;
  int *__cil_tmp___9 ;
  char *__cil_tmp___10 ;
  int __cil_tmp___11 ;
  pid_t __cil_tmp___12 ;
  time_t __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int *__cil_tmp___15 ;
  char *__cil_tmp___16 ;
  int __cil_tmp___17 ;

  {
#line 398
  __cil_tmp = anetTcpConnect((char *)((void *)0), server.masterhost, server.masterport);
#line 398
  fd = __cil_tmp;
#line 399
  maxtries = 5;
#line 401
  if (fd == -1) {
#line 402
    __cil_tmp___0 = __errno();
#line 402
    __cil_tmp___1 = strerror(*__cil_tmp___0);
#line 402
    redisLog(3, "Unable to connect to MASTER: %s", __cil_tmp___1);
#line 404
    return (-1);
  }
#line 408
  if (server.masterauth) {
#line 409
    snprintf(authcmd, 1024U, "AUTH %s\r\n", server.masterauth);
#line 410
    __cil_tmp___4 = strlen((char const   *)server.masterauth);
#line 410
    __cil_tmp___5 = syncWrite(fd, authcmd, (int )(__cil_tmp___4 + 7U), 5);
#line 410
    if (__cil_tmp___5 == -1) {
#line 411
      close(fd);
#line 412
      __cil_tmp___2 = __errno();
#line 412
      __cil_tmp___3 = strerror(*__cil_tmp___2);
#line 412
      redisLog(3, "Unable to AUTH to MASTER: %s", __cil_tmp___3);
#line 414
      return (-1);
    }
#line 417
    __cil_tmp___8 = syncReadLine(fd, buf, 1024, 3600);
#line 417
    if (__cil_tmp___8 == -1) {
#line 418
      close(fd);
#line 419
      __cil_tmp___6 = __errno();
#line 419
      __cil_tmp___7 = strerror(*__cil_tmp___6);
#line 419
      redisLog(3, "I/O error reading auth result from MASTER: %s", __cil_tmp___7);
#line 421
      return (-1);
    }
#line 423
    if ((int )buf[0] != 43) {
#line 424
      close(fd);
#line 425
      redisLog(3, "Cannot AUTH to MASTER, is the masterauth password correct?");
#line 426
      return (-1);
    }
  }
#line 431
  __cil_tmp___11 = syncWrite(fd, (char *)"SYNC \r\n", 7, 5);
#line 431
  if (__cil_tmp___11 == -1) {
#line 432
    close(fd);
#line 433
    __cil_tmp___9 = __errno();
#line 433
    __cil_tmp___10 = strerror(*__cil_tmp___9);
#line 433
    redisLog(3, "I/O error writing to MASTER: %s", __cil_tmp___10);
#line 435
    return (-1);
  }
#line 439
  while (1) {
#line 439
    __cil_tmp___14 = maxtries;
#line 439
    maxtries --;
#line 439
    if (! __cil_tmp___14) {
#line 439
      break;
    }
#line 440
    __cil_tmp___12 = getpid();
#line 440
    __cil_tmp___13 = time((time_t *)((void *)0));
#line 440
    snprintf(tmpfile___0, 256U, "temp-%d.%ld.rdb", (int )__cil_tmp___13, (long )__cil_tmp___12);
#line 442
    dfd = open((char const   *)(tmpfile___0), 14, 420);
#line 443
    if (dfd != -1) {
#line 443
      break;
    }
#line 444
    sleep(1U);
  }
#line 446
  if (dfd == -1) {
#line 447
    close(fd);
#line 448
    __cil_tmp___15 = __errno();
#line 448
    __cil_tmp___16 = strerror(*__cil_tmp___15);
#line 448
    redisLog(3, "Opening the temp file needed for MASTER <-> SLAVE synchronization: %s",
             __cil_tmp___16);
#line 449
    return (-1);
  }
#line 453
  __cil_tmp___17 = aeCreateFileEvent(server.el, fd, 1, & readSyncBulkPayload, (void *)0);
#line 453
  if (__cil_tmp___17 == -1) {
#line 456
    close(fd);
#line 457
    redisLog(3, "Can\'t create readable event for SYNC");
#line 458
    return (-1);
  }
#line 460
  server.replstate = 2;
#line 461
  server.repl_transfer_left = -1L;
#line 462
  server.repl_transfer_s = fd;
#line 463
  server.repl_transfer_fd = dfd;
#line 464
  server.repl_transfer_lastio = time((time_t *)((void *)0));
#line 465
  server.repl_transfer_tmpfile = strdup((char const   *)(tmpfile___0));
#line 466
  return (0);
}
}
#line 469 "replication.c"
void slaveofCommand(redisClient *c ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 470
  __cil_tmp = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "no");
#line 470
  if (__cil_tmp) {
    _L: 
#line 482
    sdsfree(server.masterhost);
#line 483
    server.masterhost = sdsdup((char *)(*(c->argv + 1))->ptr);
#line 484
    server.masterport = atoi((char const   *)(*(c->argv + 2))->ptr);
#line 485
    if (server.master) {
#line 485
      freeClient(server.master);
    }
#line 486
    if (server.replstate == 2) {
#line 487
      replicationAbortSyncTransfer();
    }
#line 488
    server.replstate = 1;
#line 489
    redisLog(2, "SLAVE OF %s:%d enabled (user request)", server.masterhost, server.masterport);
  } else {
#line 470
    __cil_tmp___0 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "one");
#line 470
    if (__cil_tmp___0) {
#line 470
      goto _L;
    } else
#line 472
    if (server.masterhost) {
#line 473
      sdsfree(server.masterhost);
#line 474
      server.masterhost = (char *)((void *)0);
#line 475
      if (server.master) {
#line 475
        freeClient(server.master);
      }
#line 476
      if (server.replstate == 2) {
#line 477
        replicationAbortSyncTransfer();
      }
#line 478
      server.replstate = 0;
#line 479
      redisLog(2, "MASTER MODE enabled (user request)");
    }
  }
#line 492
  addReply(c, shared.ok);
#line 493
  return;
}
}
#line 500 "replication.c"
void replicationCron(void) 
{ time_t __cil_tmp ;
  time_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  listIter li ;
  listNode *ln ;
  redisClient *slave ;
  sds __cil_tmp___2 ;

  {
#line 502
  if (server.masterhost && server.replstate == 2) {
#line 502
    __cil_tmp = time((time_t *)((void *)0));
#line 502
    if (__cil_tmp - server.repl_transfer_lastio > 60L) {
#line 505
      redisLog(3, "Timeout receiving bulk data from MASTER...");
#line 506
      replicationAbortSyncTransfer();
    }
  }
#line 510
  if (server.masterhost && server.replstate == 3) {
#line 510
    __cil_tmp___0 = time((time_t *)((void *)0));
#line 510
    if (__cil_tmp___0 - (server.master)->lastinteraction > 60L) {
#line 513
      redisLog(3, "MASTER time out: no data nor PING received...");
#line 514
      freeClient(server.master);
    }
  }
#line 518
  if (server.replstate == 1) {
#line 519
    redisLog(2, "Connecting to MASTER...");
#line 520
    __cil_tmp___1 = syncWithMaster();
#line 520
    if (__cil_tmp___1 == 0) {
#line 521
      redisLog(2, "MASTER <-> SLAVE sync started: SYNC sent");
#line 522
      if (server.appendonly) {
#line 522
        rewriteAppendOnlyFileBackground();
      }
    }
  }
#line 530
  if (! (server.cronloops % 100)) {
#line 534
    listRewind(server.slaves, & li);
#line 535
    while (1) {
#line 535
      ln = listNext(& li);
#line 535
      if (! ln) {
#line 535
        break;
      }
#line 536
      slave = (redisClient *)ln->value;
#line 540
      if (slave->replstate == 5) {
#line 540
        continue;
      }
#line 541
      if (slave->replstate == 6) {
#line 543
        __cil_tmp___2 = sdsnew("PING\r\n");
#line 543
        addReplySds(slave, __cil_tmp___2);
      } else {
#line 550
        write(slave->fd, (void const   *)"\n", 1U);
      }
    }
  }
#line 554
  return;
}
}
#line 1 "rdb.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-pQ6pcmaa.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 186 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int sscanf(char const   *str , char const   *fmt  , ...) ;
#line 205
size_t fread(void *buf , size_t size , size_t count , FILE *fp ) ;
#line 218
long ftell(FILE *fp ) ;
#line 237
long ftello(FILE *fp ) ;
#line 315
int fileno(FILE *f ) ;
#line 12 "intset.h"
intset *intsetAdd(intset *is , int64_t value , uint8_t *success ) ;
#line 16
uint8_t intsetGet(intset *is , uint32_t pos , int64_t *value ) ;
#line 17
uint32_t intsetLen(intset *is ) ;
#line 686 "redis.h"
void listTypeConvert(robj *subject , int enc ) ;
#line 747
void startLoading(FILE *fp ) ;
#line 748
void loadingProgress(off_t pos ) ;
#line 749
void stopLoading(void) ;
#line 756
int rdbSaveObject(FILE *fp , robj *o ) ;
#line 757
off_t rdbSavedObjectLen(robj *o ) ;
#line 758
off_t rdbSavedObjectPages(robj *o ) ;
#line 759
robj *rdbLoadObject(int type , FILE *fp ) ;
#line 775
zskiplistNode *zslInsert(zskiplist *zsl , double score , robj *obj ) ;
#line 796
robj *vmPreviewObject(robj *o ) ;
#line 809
void waitEmptyIOJobsQueue(void) ;
#line 810
void vmReopenSwapFile(void) ;
#line 817
vmpointer *vmSwapObjectBlocking(robj *val ) ;
#line 830
void setTypeConvert(robj *setobj , int enc ) ;
#line 833
void convertToRealHash(robj *o ) ;
#line 16 "rdb.c"
static int rdbWriteRaw(FILE *fp , void *p , size_t len ) 
{ size_t __cil_tmp ;

  {
#line 17
  if ((unsigned int )fp != (unsigned int )((void *)0)) {
#line 17
    __cil_tmp = fwrite((void const   *)p, len, 1U, fp);
#line 17
    if (__cil_tmp == 0U) {
#line 17
      return (-1);
    }
  }
#line 18
  return ((int )len);
}
}
#line 21 "rdb.c"
int rdbSaveType(FILE *fp , unsigned char type ) 
{ int __cil_tmp ;

  {
#line 22
  __cil_tmp = rdbWriteRaw(fp, (void *)(& type), 1U);
#line 22
  return (__cil_tmp);
}
}
#line 25 "rdb.c"
int rdbSaveTime(FILE *fp , time_t t ) 
{ int32_t t32 ;
  int __cil_tmp ;

  {
#line 26
  t32 = t;
#line 27
  __cil_tmp = rdbWriteRaw(fp, (void *)(& t32), 4U);
#line 27
  return (__cil_tmp);
}
}
#line 31 "rdb.c"
int rdbSaveLen(FILE *fp , uint32_t len ) 
{ unsigned char buf[2] ;
  int nwritten ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 35
  if (len < (unsigned long )(1 << 6)) {
#line 37
    buf[0] = (unsigned char )(len & 255UL);
#line 38
    __cil_tmp = rdbWriteRaw(fp, (void *)(buf), 1U);
#line 38
    if (__cil_tmp == -1) {
#line 38
      return (-1);
    }
#line 39
    nwritten = 1;
  } else
#line 40
  if (len < (unsigned long )(1 << 14)) {
#line 42
    buf[0] = (unsigned char )(((len >> 8) & 255UL) | (unsigned long )(1 << 6));
#line 43
    buf[1] = (unsigned char )(len & 255UL);
#line 44
    __cil_tmp___0 = rdbWriteRaw(fp, (void *)(buf), 2U);
#line 44
    if (__cil_tmp___0 == -1) {
#line 44
      return (-1);
    }
#line 45
    nwritten = 2;
  } else {
#line 48
    buf[0] = (unsigned char )(2 << 6);
#line 49
    __cil_tmp___1 = rdbWriteRaw(fp, (void *)(buf), 1U);
#line 49
    if (__cil_tmp___1 == -1) {
#line 49
      return (-1);
    }
#line 50
    len = ((((len & 4278190080UL) >> 24) | ((len & 16711680UL) >> 8)) | ((len & 65280UL) << 8)) | ((len & 255UL) << 24);
#line 51
    __cil_tmp___2 = rdbWriteRaw(fp, (void *)(& len), 4U);
#line 51
    if (__cil_tmp___2 == -1) {
#line 51
      return (-1);
    }
#line 52
    nwritten = 5;
  }
#line 54
  return (nwritten);
}
}
#line 62 "rdb.c"
int rdbEncodeInteger(long long value , unsigned char *enc ) 
{ 

  {
#line 64
  if (value >= (long long )(- (1 << 7)) && value <= (long long )((1 << 7) - 1)) {
#line 65
    *(enc + 0) = (unsigned char )(3 << 6);
#line 66
    *(enc + 1) = (unsigned char )(value & 255LL);
#line 67
    return (2);
  } else
#line 68
  if (value >= (long long )(- (1 << 15)) && value <= (long long )((1 << 15) - 1)) {
#line 69
    *(enc + 0) = (unsigned char )((3 << 6) | 1);
#line 70
    *(enc + 1) = (unsigned char )(value & 255LL);
#line 71
    *(enc + 2) = (unsigned char )((value >> 8) & 255LL);
#line 72
    return (3);
  } else
#line 73
  if (value >= - (1LL << 31) && value <= (1LL << 31) - 1LL) {
#line 74
    *(enc + 0) = (unsigned char )((3 << 6) | 2);
#line 75
    *(enc + 1) = (unsigned char )(value & 255LL);
#line 76
    *(enc + 2) = (unsigned char )((value >> 8) & 255LL);
#line 77
    *(enc + 3) = (unsigned char )((value >> 16) & 255LL);
#line 78
    *(enc + 4) = (unsigned char )((value >> 24) & 255LL);
#line 79
    return (5);
  } else {
#line 81
    return (0);
  }
}
}
#line 88 "rdb.c"
int rdbTryIntegerEncoding(char *s , size_t len , unsigned char *enc ) 
{ long long value ;
  char *endptr ;
  char buf[32] ;
  size_t __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 93
  value = strtoll((char const   *)s, & endptr, 10);
#line 94
  if ((int )*(endptr + 0) != 0) {
#line 94
    return (0);
  }
#line 95
  ll2string(buf, 32U, value);
#line 99
  __cil_tmp = strlen((char const   *)(buf));
#line 99
  if (__cil_tmp != len) {
#line 99
    return (0);
  } else {
#line 99
    __cil_tmp___0 = memcmp((void const   *)(buf), (void const   *)s, len);
#line 99
    if (__cil_tmp___0) {
#line 99
      return (0);
    }
  }
#line 101
  __cil_tmp___1 = rdbEncodeInteger(value, enc);
#line 101
  return (__cil_tmp___1);
}
}
#line 104 "rdb.c"
int rdbSaveLzfStringObject(FILE *fp , unsigned char *s , size_t len ) 
{ size_t comprlen ;
  size_t outlen ;
  unsigned char byte ;
  int n ;
  int nwritten ;
  void *out ;

  {
#line 107
  nwritten = 0;
#line 111
  if (len <= 4U) {
#line 111
    return (0);
  }
#line 112
  outlen = len - 4U;
#line 113
  out = malloc(outlen + 1U);
#line 113
  if ((unsigned int )out == (unsigned int )((void *)0)) {
#line 113
    return (0);
  }
#line 114
  comprlen = lzf_compress((void const   *)s, len, out, outlen);
#line 115
  if (comprlen == 0U) {
#line 116
    free(out);
#line 117
    return (0);
  }
#line 120
  byte = (unsigned char )((3 << 6) | 3);
#line 121
  n = rdbWriteRaw(fp, (void *)(& byte), 1U);
#line 121
  if (n == -1) {
#line 121
    goto writeerr;
  }
#line 122
  nwritten += n;
#line 124
  n = rdbSaveLen(fp, (unsigned long )comprlen);
#line 124
  if (n == -1) {
#line 124
    goto writeerr;
  }
#line 125
  nwritten += n;
#line 127
  n = rdbSaveLen(fp, (unsigned long )len);
#line 127
  if (n == -1) {
#line 127
    goto writeerr;
  }
#line 128
  nwritten += n;
#line 130
  n = rdbWriteRaw(fp, out, comprlen);
#line 130
  if (n == -1) {
#line 130
    goto writeerr;
  }
#line 131
  nwritten += n;
#line 133
  free(out);
#line 134
  return (nwritten);
  writeerr: 
#line 137
  free(out);
#line 138
  return (-1);
}
}
#line 143 "rdb.c"
int rdbSaveRawString(FILE *fp , unsigned char *s , size_t len ) 
{ int enclen ;
  int n ;
  int nwritten ;
  unsigned char buf[5] ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 145
  nwritten = 0;
#line 148
  if (len <= 11U) {
#line 150
    enclen = rdbTryIntegerEncoding((char *)s, len, buf);
#line 150
    if (enclen > 0) {
#line 151
      __cil_tmp = rdbWriteRaw(fp, (void *)(buf), (unsigned int )enclen);
#line 151
      if (__cil_tmp == -1) {
#line 151
        return (-1);
      }
#line 152
      return (enclen);
    }
  }
#line 158
  if (server.rdbcompression && len > 20U) {
#line 159
    n = rdbSaveLzfStringObject(fp, s, len);
#line 160
    if (n == -1) {
#line 160
      return (-1);
    }
#line 161
    if (n > 0) {
#line 161
      return (n);
    }
  }
#line 166
  n = rdbSaveLen(fp, (unsigned long )len);
#line 166
  if (n == -1) {
#line 166
    return (-1);
  }
#line 167
  nwritten += n;
#line 168
  if (len > 0U) {
#line 169
    __cil_tmp___0 = rdbWriteRaw(fp, (void *)s, len);
#line 169
    if (__cil_tmp___0 == -1) {
#line 169
      return (-1);
    }
#line 170
    nwritten = (int )((unsigned int )nwritten + len);
  }
#line 172
  return (nwritten);
}
}
#line 176 "rdb.c"
int rdbSaveLongLongAsStringObject(FILE *fp , long long value ) 
{ unsigned char buf[32] ;
  int n ;
  int nwritten ;
  int enclen ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 178
  nwritten = 0;
#line 179
  __cil_tmp = rdbEncodeInteger(value, buf);
#line 179
  enclen = __cil_tmp;
#line 180
  if (enclen > 0) {
#line 181
    __cil_tmp___0 = rdbWriteRaw(fp, (void *)(buf), (unsigned int )enclen);
#line 181
    return (__cil_tmp___0);
  } else {
#line 184
    enclen = ll2string((char *)(buf), 32U, value);
#line 185
    if (! (enclen < 32)) {
#line 185
      _redisAssert((char *)"enclen < 32", (char *)"rdb.c", 185);
#line 185
      _exit(1);
    }
#line 186
    n = rdbSaveLen(fp, (unsigned long )enclen);
#line 186
    if (n == -1) {
#line 186
      return (-1);
    }
#line 187
    nwritten += n;
#line 188
    n = rdbWriteRaw(fp, (void *)(buf), (unsigned int )enclen);
#line 188
    if (n == -1) {
#line 188
      return (-1);
    }
#line 189
    nwritten += n;
  }
#line 191
  return (nwritten);
}
}
#line 195 "rdb.c"
int rdbSaveStringObject(FILE *fp , robj *obj ) 
{ int __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 198
  if (obj->encoding == 1U) {
#line 199
    __cil_tmp = rdbSaveLongLongAsStringObject(fp, (long long )((long )obj->ptr));
#line 199
    return (__cil_tmp);
  } else {
#line 201
    if (! (obj->encoding == 0U)) {
#line 201
      _redisAssert((char *)"obj->encoding == REDIS_ENCODING_RAW", (char *)"rdb.c",
                   201);
#line 201
      _exit(1);
    }
#line 202
    __cil_tmp___0 = sdslen((char *)obj->ptr);
#line 202
    __cil_tmp___1 = rdbSaveRawString(fp, (unsigned char *)obj->ptr, __cil_tmp___0);
#line 202
    return (__cil_tmp___1);
  }
}
}
#line 214 "rdb.c"
int rdbSaveDoubleValue(FILE *fp , double val ) 
{ unsigned char buf[128] ;
  int len ;
  size_t __cil_tmp ;
  int __cy ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;

  {
#line 218
  if (sizeof(val) == sizeof(float )) {
#line 218
    __cil_tmp___3 = __fpclassifyf((float )val);
#line 218
    __cil_tmp___5 = __cil_tmp___3;
  } else {
#line 218
    __cil_tmp___4 = __fpclassifyd(val);
#line 218
    __cil_tmp___5 = __cil_tmp___4;
  }
#line 218
  if (__cil_tmp___5 == 0) {
#line 219
    buf[0] = (unsigned char)253;
#line 220
    len = 1;
  } else {
#line 221
    if (sizeof(val) == sizeof(float )) {
#line 221
      __cil_tmp___0 = __fpclassifyf((float )val);
#line 221
      __cil_tmp___2 = __cil_tmp___0;
    } else {
#line 221
      __cil_tmp___1 = __fpclassifyd(val);
#line 221
      __cil_tmp___2 = __cil_tmp___1;
    }
#line 221
    __cy = __cil_tmp___2;
#line 221
    if (__cy != 1 && __cy != 0) {
#line 241
      snprintf((char *)(buf) + 1, (unsigned int )(sizeof(buf) - 1UL), "%.17g", val);
#line 242
      __cil_tmp = strlen((char const   *)((char *)(buf) + 1));
#line 242
      buf[0] = (unsigned char )__cil_tmp;
#line 243
      len = (int )buf[0] + 1;
    } else {
#line 222
      len = 1;
#line 223
      buf[0] = (unsigned char )(val < (double )0 ? 255 : 254);
    }
  }
#line 245
  __cil_tmp___6 = rdbWriteRaw(fp, (void *)(buf), (unsigned int )len);
#line 245
  return (__cil_tmp___6);
}
}
#line 249 "rdb.c"
int rdbSaveObject(FILE *fp , robj *o ) 
{ int n ;
  int nwritten ;
  unsigned char *p ;
  unsigned char *vstr ;
  unsigned int vlen ;
  long long vlong ;
  unsigned int __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  list *list___0 ;
  listIter li ;
  listNode *ln ;
  robj *eleobj ;
  dict *set ;
  dictIterator *di ;
  dictIterator *__cil_tmp___1 ;
  dictEntry *de ;
  robj *eleobj___0 ;
  intset *is ;
  int64_t llval ;
  int i ;
  uint32_t __cil_tmp___2 ;
  int __cil_tmp___3 ;
  uint8_t __cil_tmp___4 ;
  zset *zs ;
  dictIterator *di___0 ;
  dictIterator *__cil_tmp___5 ;
  dictEntry *de___0 ;
  robj *eleobj___1 ;
  double *score ;
  unsigned char *p___0 ;
  unsigned char *__cil_tmp___6 ;
  unsigned int count ;
  unsigned int __cil_tmp___7 ;
  unsigned char *key ;
  unsigned char *val ;
  unsigned int klen ;
  unsigned int vlen___0 ;
  dictIterator *di___1 ;
  dictIterator *__cil_tmp___8 ;
  dictEntry *de___1 ;
  robj *key___0 ;
  robj *val___0 ;

  {
#line 250
  nwritten = 0;
#line 252
  if (o->type == 0U) {
#line 254
    n = rdbSaveStringObject(fp, o);
#line 254
    if (n == -1) {
#line 254
      return (-1);
    }
#line 255
    nwritten += n;
  } else
#line 256
  if (o->type == 1U) {
#line 258
    if (o->encoding == 5U) {
#line 264
      __cil_tmp = ziplistLen((unsigned char *)o->ptr);
#line 264
      n = rdbSaveLen(fp, (unsigned long )__cil_tmp);
#line 264
      if (n == -1) {
#line 264
        return (-1);
      }
#line 265
      nwritten += n;
#line 267
      p = ziplistIndex((unsigned char *)o->ptr, 0);
#line 268
      while (1) {
#line 268
        __cil_tmp___0 = ziplistGet(p, & vstr, & vlen, & vlong);
#line 268
        if (! __cil_tmp___0) {
#line 268
          break;
        }
#line 269
        if (vstr) {
#line 270
          n = rdbSaveRawString(fp, vstr, vlen);
#line 270
          if (n == -1) {
#line 271
            return (-1);
          }
#line 272
          nwritten += n;
        } else {
#line 274
          n = rdbSaveLongLongAsStringObject(fp, vlong);
#line 274
          if (n == -1) {
#line 275
            return (-1);
          }
#line 276
          nwritten += n;
        }
#line 278
        p = ziplistNext((unsigned char *)o->ptr, p);
      }
    } else
#line 280
    if (o->encoding == 4U) {
#line 281
      list___0 = (list *)o->ptr;
#line 285
      n = rdbSaveLen(fp, (unsigned long )list___0->len);
#line 285
      if (n == -1) {
#line 285
        return (-1);
      }
#line 286
      nwritten += n;
#line 288
      listRewind(list___0, & li);
#line 289
      while (1) {
#line 289
        ln = listNext(& li);
#line 289
        if (! ln) {
#line 289
          break;
        }
#line 290
        eleobj = (robj *)ln->value;
#line 291
        n = rdbSaveStringObject(fp, eleobj);
#line 291
        if (n == -1) {
#line 291
          return (-1);
        }
#line 292
        nwritten += n;
      }
    } else {
#line 295
      _redisPanic((char *)"\"Unknown list encoding\"", (char *)"rdb.c", 295);
#line 295
      _exit(1);
    }
  } else
#line 297
  if (o->type == 2U) {
#line 299
    if (o->encoding == 2U) {
#line 300
      set = (dict *)o->ptr;
#line 301
      __cil_tmp___1 = dictGetIterator(set);
#line 301
      di = __cil_tmp___1;
#line 304
      n = rdbSaveLen(fp, set->ht[0].used + set->ht[1].used);
#line 304
      if (n == -1) {
#line 304
        return (-1);
      }
#line 305
      nwritten += n;
#line 307
      while (1) {
#line 307
        de = dictNext(di);
#line 307
        if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 307
          break;
        }
#line 308
        eleobj___0 = (robj *)de->key;
#line 309
        n = rdbSaveStringObject(fp, eleobj___0);
#line 309
        if (n == -1) {
#line 309
          return (-1);
        }
#line 310
        nwritten += n;
      }
#line 312
      dictReleaseIterator(di);
    } else
#line 313
    if (o->encoding == 6U) {
#line 314
      is = (intset *)o->ptr;
#line 316
      i = 0;
#line 318
      __cil_tmp___2 = intsetLen(is);
#line 318
      n = rdbSaveLen(fp, __cil_tmp___2);
#line 318
      if (n == -1) {
#line 318
        return (-1);
      }
#line 319
      nwritten += n;
#line 321
      while (1) {
#line 321
        __cil_tmp___3 = i;
#line 321
        i ++;
#line 321
        __cil_tmp___4 = intsetGet(is, (unsigned long )__cil_tmp___3, & llval);
#line 321
        if (! __cil_tmp___4) {
#line 321
          break;
        }
#line 322
        n = rdbSaveLongLongAsStringObject(fp, llval);
#line 322
        if (n == -1) {
#line 322
          return (-1);
        }
#line 323
        nwritten += n;
      }
    } else {
#line 326
      _redisPanic((char *)"\"Unknown set encoding\"", (char *)"rdb.c", 326);
#line 326
      _exit(1);
    }
  } else
#line 328
  if (o->type == 3U) {
#line 330
    zs = (zset *)o->ptr;
#line 331
    __cil_tmp___5 = dictGetIterator(zs->dict);
#line 331
    di___0 = __cil_tmp___5;
#line 334
    n = rdbSaveLen(fp, (zs->dict)->ht[0].used + (zs->dict)->ht[1].used);
#line 334
    if (n == -1) {
#line 334
      return (-1);
    }
#line 335
    nwritten += n;
#line 337
    while (1) {
#line 337
      de___0 = dictNext(di___0);
#line 337
      if (! ((unsigned int )de___0 != (unsigned int )((void *)0))) {
#line 337
        break;
      }
#line 338
      eleobj___1 = (robj *)de___0->key;
#line 339
      score = (double *)de___0->val;
#line 341
      n = rdbSaveStringObject(fp, eleobj___1);
#line 341
      if (n == -1) {
#line 341
        return (-1);
      }
#line 342
      nwritten += n;
#line 343
      n = rdbSaveDoubleValue(fp, *score);
#line 343
      if (n == -1) {
#line 343
        return (-1);
      }
#line 344
      nwritten += n;
    }
#line 346
    dictReleaseIterator(di___0);
  } else
#line 347
  if (o->type == 4U) {
#line 349
    if (o->encoding == 3U) {
#line 350
      __cil_tmp___6 = zipmapRewind((unsigned char *)o->ptr);
#line 350
      p___0 = __cil_tmp___6;
#line 351
      __cil_tmp___7 = zipmapLen((unsigned char *)o->ptr);
#line 351
      count = __cil_tmp___7;
#line 355
      n = rdbSaveLen(fp, (unsigned long )count);
#line 355
      if (n == -1) {
#line 355
        return (-1);
      }
#line 356
      nwritten += n;
#line 358
      while (1) {
#line 358
        p___0 = zipmapNext(p___0, & key, & klen, & val, & vlen___0);
#line 358
        if (! ((unsigned int )p___0 != (unsigned int )((void *)0))) {
#line 358
          break;
        }
#line 359
        n = rdbSaveRawString(fp, key, klen);
#line 359
        if (n == -1) {
#line 359
          return (-1);
        }
#line 360
        nwritten += n;
#line 361
        n = rdbSaveRawString(fp, val, vlen___0);
#line 361
        if (n == -1) {
#line 361
          return (-1);
        }
#line 362
        nwritten += n;
      }
    } else {
#line 365
      __cil_tmp___8 = dictGetIterator((dict *)o->ptr);
#line 365
      di___1 = __cil_tmp___8;
#line 368
      n = rdbSaveLen(fp, ((dict *)o->ptr)->ht[0].used + ((dict *)o->ptr)->ht[1].used);
#line 368
      if (n == -1) {
#line 368
        return (-1);
      }
#line 369
      nwritten += n;
#line 371
      while (1) {
#line 371
        de___1 = dictNext(di___1);
#line 371
        if (! ((unsigned int )de___1 != (unsigned int )((void *)0))) {
#line 371
          break;
        }
#line 372
        key___0 = (robj *)de___1->key;
#line 373
        val___0 = (robj *)de___1->val;
#line 375
        n = rdbSaveStringObject(fp, key___0);
#line 375
        if (n == -1) {
#line 375
          return (-1);
        }
#line 376
        nwritten += n;
#line 377
        n = rdbSaveStringObject(fp, val___0);
#line 377
        if (n == -1) {
#line 377
          return (-1);
        }
#line 378
        nwritten += n;
      }
#line 380
      dictReleaseIterator(di___1);
    }
  } else {
#line 383
    _redisPanic((char *)"\"Unknown object type\"", (char *)"rdb.c", 383);
#line 383
    _exit(1);
  }
#line 385
  return (nwritten);
}
}
#line 392 "rdb.c"
off_t rdbSavedObjectLen(robj *o ) 
{ int len ;
  int __cil_tmp ;

  {
#line 393
  __cil_tmp = rdbSaveObject((FILE *)((void *)0), o);
#line 393
  len = __cil_tmp;
#line 394
  if (! (len != -1)) {
#line 394
    _redisAssert((char *)"len != -1", (char *)"rdb.c", 394);
#line 394
    _exit(1);
  }
#line 395
  return ((long )len);
}
}
#line 399 "rdb.c"
off_t rdbSavedObjectPages(robj *o ) 
{ off_t bytes ;
  off_t __cil_tmp ;

  {
#line 400
  __cil_tmp = rdbSavedObjectLen(o);
#line 400
  bytes = __cil_tmp;
#line 401
  return ((bytes + (server.vm_page_size - 1L)) / server.vm_page_size);
}
}
#line 405 "rdb.c"
int rdbSave(char *filename ) 
{ dictIterator *di ;
  dictEntry *de ;
  FILE *fp ;
  char tmpfile___0[256] ;
  int j ;
  time_t now ;
  time_t __cil_tmp ;
  pid_t __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  redisDb *db ;
  dict *d ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  sds keystr ;
  robj key ;
  robj *o ;
  time_t expiretime ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  robj *po ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int *__cil_tmp___16 ;
  char *__cil_tmp___17 ;
  int __cil_tmp___18 ;
  int *__cil_tmp___19 ;
  char *__cil_tmp___20 ;

  {
#line 406
  di = (dictIterator *)((void *)0);
#line 411
  __cil_tmp = time((time_t *)((void *)0));
#line 411
  now = __cil_tmp;
#line 416
  if (server.vm_enabled) {
#line 417
    waitEmptyIOJobsQueue();
  }
#line 419
  __cil_tmp___0 = getpid();
#line 419
  snprintf(tmpfile___0, 256U, "temp-%d.rdb", __cil_tmp___0);
#line 420
  fp = fopen((char const   *)(tmpfile___0), "w");
#line 421
  if (! fp) {
#line 422
    __cil_tmp___1 = __errno();
#line 422
    __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 422
    redisLog(3, "Failed saving the DB: %s", __cil_tmp___2);
#line 423
    return (-1);
  }
#line 425
  __cil_tmp___3 = fwrite((void const   *)"REDIS0001", 9U, 1U, fp);
#line 425
  if (__cil_tmp___3 == 0U) {
#line 425
    goto werr;
  }
#line 426
  j = 0;
#line 426
  while (j < server.dbnum) {
#line 427
    db = server.db + j;
#line 428
    d = db->dict;
#line 429
    if (d->ht[0].used + d->ht[1].used == 0UL) {
#line 429
      goto __Cont;
    }
#line 430
    di = dictGetIterator(d);
#line 431
    if (! di) {
#line 432
      fclose(fp);
#line 433
      return (-1);
    }
#line 437
    __cil_tmp___4 = rdbSaveType(fp, (unsigned char)254);
#line 437
    if (__cil_tmp___4 == -1) {
#line 437
      goto werr;
    }
#line 438
    __cil_tmp___5 = rdbSaveLen(fp, (unsigned long )j);
#line 438
    if (__cil_tmp___5 == -1) {
#line 438
      goto werr;
    }
#line 441
    while (1) {
#line 441
      de = dictNext(di);
#line 441
      if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 441
        break;
      }
#line 442
      keystr = (char *)de->key;
#line 443
      o = (robj *)de->val;
#line 446
      while (1) {
#line 446
        key.refcount = 1;
#line 446
        key.type = 0U;
#line 446
        key.encoding = 0U;
#line 446
        key.ptr = (void *)keystr;
#line 446
        key.storage = 0U;
#line 446
        break;
      }
#line 447
      expiretime = getExpire(db, & key);
#line 450
      if (expiretime != -1L) {
#line 452
        if (expiretime < now) {
#line 452
          continue;
        }
#line 453
        __cil_tmp___6 = rdbSaveType(fp, (unsigned char)253);
#line 453
        if (__cil_tmp___6 == -1) {
#line 453
          goto werr;
        }
#line 454
        __cil_tmp___7 = rdbSaveTime(fp, expiretime);
#line 454
        if (__cil_tmp___7 == -1) {
#line 454
          goto werr;
        }
      }
#line 458
      if ((! server.vm_enabled || o->storage == 0U) || o->storage == 2U) {
#line 461
        __cil_tmp___8 = rdbSaveType(fp, (unsigned char )o->type);
#line 461
        if (__cil_tmp___8 == -1) {
#line 461
          goto werr;
        }
#line 462
        __cil_tmp___9 = rdbSaveStringObject(fp, & key);
#line 462
        if (__cil_tmp___9 == -1) {
#line 462
          goto werr;
        }
#line 463
        __cil_tmp___10 = rdbSaveObject(fp, o);
#line 463
        if (__cil_tmp___10 == -1) {
#line 463
          goto werr;
        }
      } else {
#line 468
        po = vmPreviewObject(o);
#line 470
        __cil_tmp___11 = rdbSaveType(fp, (unsigned char )po->type);
#line 470
        if (__cil_tmp___11 == -1) {
#line 470
          goto werr;
        }
#line 471
        __cil_tmp___12 = rdbSaveStringObject(fp, & key);
#line 471
        if (__cil_tmp___12 == -1) {
#line 471
          goto werr;
        }
#line 472
        __cil_tmp___13 = rdbSaveObject(fp, po);
#line 472
        if (__cil_tmp___13 == -1) {
#line 472
          goto werr;
        }
#line 474
        decrRefCount((void *)po);
      }
    }
#line 477
    dictReleaseIterator(di);
    __Cont: 
#line 426
    j ++;
  }
#line 480
  __cil_tmp___14 = rdbSaveType(fp, (unsigned char)255);
#line 480
  if (__cil_tmp___14 == -1) {
#line 480
    goto werr;
  }
#line 483
  fflush(fp);
#line 484
  __cil_tmp___15 = fileno(fp);
#line 484
  fsync(__cil_tmp___15);
#line 485
  fclose(fp);
#line 489
  __cil_tmp___18 = rename((char const   *)(tmpfile___0), (char const   *)filename);
#line 489
  if (__cil_tmp___18 == -1) {
#line 490
    __cil_tmp___16 = __errno();
#line 490
    __cil_tmp___17 = strerror(*__cil_tmp___16);
#line 490
    redisLog(3, "Error moving temp DB file on the final destination: %s", __cil_tmp___17);
#line 491
    unlink((char const   *)(tmpfile___0));
#line 492
    return (-1);
  }
#line 494
  redisLog(2, "DB saved on disk");
#line 495
  server.dirty = 0LL;
#line 496
  server.lastsave = time((time_t *)((void *)0));
#line 497
  return (0);
  werr: 
#line 500
  fclose(fp);
#line 501
  unlink((char const   *)(tmpfile___0));
#line 502
  __cil_tmp___19 = __errno();
#line 502
  __cil_tmp___20 = strerror(*__cil_tmp___19);
#line 502
  redisLog(3, "Write error saving DB on disk: %s", __cil_tmp___20);
#line 503
  if (di) {
#line 503
    dictReleaseIterator(di);
  }
#line 504
  return (-1);
}
}
#line 507 "rdb.c"
int rdbSaveBackground(char *filename ) 
{ pid_t childpid ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  char *__cil_tmp___1 ;

  {
#line 510
  if (server.bgsavechildpid != -1) {
#line 510
    return (-1);
  }
#line 511
  if (server.vm_enabled) {
#line 511
    waitEmptyIOJobsQueue();
  }
#line 512
  server.dirty_before_bgsave = server.dirty;
#line 513
  childpid = fork();
#line 513
  if (childpid == 0) {
#line 515
    if (server.vm_enabled) {
#line 515
      vmReopenSwapFile();
    }
#line 516
    if (server.ipfd > 0) {
#line 516
      close(server.ipfd);
    }
#line 517
    if (server.sofd > 0) {
#line 517
      close(server.sofd);
    }
#line 518
    __cil_tmp = rdbSave(filename);
#line 518
    if (__cil_tmp == 0) {
#line 519
      _exit(0);
    } else {
#line 521
      _exit(1);
    }
  } else {
#line 525
    if (childpid == -1) {
#line 526
      __cil_tmp___0 = __errno();
#line 526
      __cil_tmp___1 = strerror(*__cil_tmp___0);
#line 526
      redisLog(3, "Can\'t save in background: fork: %s", __cil_tmp___1);
#line 528
      return (-1);
    }
#line 530
    redisLog(2, "Background saving started by pid %d", childpid);
#line 531
    server.bgsavechildpid = childpid;
#line 532
    updateDictResizePolicy();
#line 533
    return (0);
  }
#line 535
  return (0);
}
}
#line 538 "rdb.c"
void rdbRemoveTempFile(pid_t childpid ) 
{ char tmpfile___0[256] ;

  {
#line 541
  snprintf(tmpfile___0, 256U, "temp-%d.rdb", childpid);
#line 542
  unlink((char const   *)(tmpfile___0));
#line 543
  return;
}
}
#line 545 "rdb.c"
int rdbLoadType(FILE *fp ) 
{ unsigned char type ;
  size_t __cil_tmp ;

  {
#line 547
  __cil_tmp = fread((void *)(& type), 1U, 1U, fp);
#line 547
  if (__cil_tmp == 0U) {
#line 547
    return (-1);
  }
#line 548
  return ((int )type);
}
}
#line 551 "rdb.c"
time_t rdbLoadTime(FILE *fp ) 
{ int32_t t32 ;
  size_t __cil_tmp ;

  {
#line 553
  __cil_tmp = fread((void *)(& t32), 4U, 1U, fp);
#line 553
  if (__cil_tmp == 0U) {
#line 553
    return (-1L);
  }
#line 554
  return (t32);
}
}
#line 562 "rdb.c"
uint32_t rdbLoadLen(FILE *fp , int *isencoded ) 
{ unsigned char buf[2] ;
  uint32_t len ;
  int type ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 567
  if (isencoded) {
#line 567
    *isencoded = 0;
  }
#line 568
  __cil_tmp = fread((void *)(buf), 1U, 1U, fp);
#line 568
  if (__cil_tmp == 0U) {
#line 568
    return (4294967295UL);
  }
#line 569
  type = ((int )buf[0] & 192) >> 6;
#line 570
  if (type == 0) {
#line 572
    return ((unsigned long )((int )buf[0] & 63));
  } else
#line 573
  if (type == 3) {
#line 575
    if (isencoded) {
#line 575
      *isencoded = 1;
    }
#line 576
    return ((unsigned long )((int )buf[0] & 63));
  } else
#line 577
  if (type == 1) {
#line 579
    __cil_tmp___0 = fread((void *)(buf + 1), 1U, 1U, fp);
#line 579
    if (__cil_tmp___0 == 0U) {
#line 579
      return (4294967295UL);
    }
#line 580
    return ((unsigned long )((((int )buf[0] & 63) << 8) | (int )buf[1]));
  } else {
#line 583
    __cil_tmp___1 = fread((void *)(& len), 4U, 1U, fp);
#line 583
    if (__cil_tmp___1 == 0U) {
#line 583
      return (4294967295UL);
    }
#line 584
    return (((((len & 4278190080UL) >> 24) | ((len & 16711680UL) >> 8)) | ((len & 65280UL) << 8)) | ((len & 255UL) << 24));
  }
}
}
#line 592 "rdb.c"
robj *rdbLoadIntegerObject(FILE *fp , int enctype , int encode ) 
{ unsigned char enc[4] ;
  long long val ;
  size_t __cil_tmp ;
  uint16_t v ;
  size_t __cil_tmp___0 ;
  uint32_t v___0 ;
  size_t __cil_tmp___1 ;
  robj *__cil_tmp___2 ;
  sds __cil_tmp___3 ;
  robj *__cil_tmp___4 ;

  {
#line 596
  if (enctype == 0) {
#line 597
    __cil_tmp = fread((void *)(enc), 1U, 1U, fp);
#line 597
    if (__cil_tmp == 0U) {
#line 597
      return ((robj *)((void *)0));
    }
#line 598
    val = (long long )((signed char )enc[0]);
  } else
#line 599
  if (enctype == 1) {
#line 601
    __cil_tmp___0 = fread((void *)(enc), 2U, 1U, fp);
#line 601
    if (__cil_tmp___0 == 0U) {
#line 601
      return ((robj *)((void *)0));
    }
#line 602
    v = (unsigned short )((int )enc[0] | ((int )enc[1] << 8));
#line 603
    val = (long long )((short )v);
  } else
#line 604
  if (enctype == 2) {
#line 606
    __cil_tmp___1 = fread((void *)(enc), 4U, 1U, fp);
#line 606
    if (__cil_tmp___1 == 0U) {
#line 606
      return ((robj *)((void *)0));
    }
#line 607
    v___0 = (unsigned long )((((int )enc[0] | ((int )enc[1] << 8)) | ((int )enc[2] << 16)) | ((int )enc[3] << 24));
#line 608
    val = (long long )((long )v___0);
  } else {
#line 610
    val = 0LL;
#line 611
    _redisPanic((char *)"\"Unknown RDB integer encoding type\"", (char *)"rdb.c",
                611);
#line 611
    _exit(1);
  }
#line 613
  if (encode) {
#line 614
    __cil_tmp___2 = createStringObjectFromLongLong(val);
#line 614
    return (__cil_tmp___2);
  } else {
#line 616
    __cil_tmp___3 = sdsfromlonglong(val);
#line 616
    __cil_tmp___4 = createObject(0, (void *)__cil_tmp___3);
#line 616
    return (__cil_tmp___4);
  }
}
}
#line 619 "rdb.c"
robj *rdbLoadLzfStringObject(FILE *fp ) 
{ unsigned int len ;
  unsigned int clen ;
  unsigned char *c ;
  sds val ;
  uint32_t __cil_tmp ;
  uint32_t __cil_tmp___0 ;
  void *__cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  unsigned int __cil_tmp___3 ;
  robj *__cil_tmp___4 ;

  {
#line 621
  c = (unsigned char *)((void *)0);
#line 622
  val = (char *)((void *)0);
#line 624
  __cil_tmp = rdbLoadLen(fp, (int *)((void *)0));
#line 624
  clen = (unsigned int )__cil_tmp;
#line 624
  if (clen == 4294967295U) {
#line 624
    return ((robj *)((void *)0));
  }
#line 625
  __cil_tmp___0 = rdbLoadLen(fp, (int *)((void *)0));
#line 625
  len = (unsigned int )__cil_tmp___0;
#line 625
  if (len == 4294967295U) {
#line 625
    return ((robj *)((void *)0));
  }
#line 626
  __cil_tmp___1 = malloc(clen);
#line 626
  c = (unsigned char *)__cil_tmp___1;
#line 626
  if ((unsigned int )c == (unsigned int )((void *)0)) {
#line 626
    goto err;
  }
#line 627
  val = sdsnewlen((void const   *)((void *)0), len);
#line 627
  if ((unsigned int )val == (unsigned int )((void *)0)) {
#line 627
    goto err;
  }
#line 628
  __cil_tmp___2 = fread((void *)c, clen, 1U, fp);
#line 628
  if (__cil_tmp___2 == 0U) {
#line 628
    goto err;
  }
#line 629
  __cil_tmp___3 = lzf_decompress((void const   *)c, clen, (void *)val, len);
#line 629
  if (__cil_tmp___3 == 0U) {
#line 629
    goto err;
  }
#line 630
  free((void *)c);
#line 631
  __cil_tmp___4 = createObject(0, (void *)val);
#line 631
  return (__cil_tmp___4);
  err: 
#line 633
  free((void *)c);
#line 634
  sdsfree(val);
#line 635
  return ((robj *)((void *)0));
}
}
#line 638 "rdb.c"
robj *rdbGenericLoadStringObject(FILE *fp , int encode ) 
{ int isencoded ;
  uint32_t len ;
  sds val ;
  robj *__cil_tmp ;
  robj *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  robj *__cil_tmp___2 ;

  {
#line 643
  len = rdbLoadLen(fp, & isencoded);
#line 644
  if (isencoded) {
#line 645
    switch ((int )len) {
    case 0: 
    case 1: 
    case 2: 
#line 649
    __cil_tmp = rdbLoadIntegerObject(fp, (int )len, encode);
#line 649
    return (__cil_tmp);
    case 3: 
#line 651
    __cil_tmp___0 = rdbLoadLzfStringObject(fp);
#line 651
    return (__cil_tmp___0);
    default: 
#line 653
    _redisPanic((char *)"\"Unknown RDB encoding type\"", (char *)"rdb.c", 653);
#line 653
    _exit(1);
    }
  }
#line 657
  if (len == 4294967295UL) {
#line 657
    return ((robj *)((void *)0));
  }
#line 658
  val = sdsnewlen((void const   *)((void *)0), (unsigned int )len);
#line 659
  if (len) {
#line 659
    __cil_tmp___1 = fread((void *)val, (unsigned int )len, 1U, fp);
#line 659
    if (__cil_tmp___1 == 0U) {
#line 660
      sdsfree(val);
#line 661
      return ((robj *)((void *)0));
    }
  }
#line 663
  __cil_tmp___2 = createObject(0, (void *)val);
#line 663
  return (__cil_tmp___2);
}
}
#line 666 "rdb.c"
robj *rdbLoadStringObject(FILE *fp ) 
{ robj *__cil_tmp ;

  {
#line 667
  __cil_tmp = rdbGenericLoadStringObject(fp, 0);
#line 667
  return (__cil_tmp);
}
}
#line 670 "rdb.c"
robj *rdbLoadEncodedStringObject(FILE *fp ) 
{ robj *__cil_tmp ;

  {
#line 671
  __cil_tmp = rdbGenericLoadStringObject(fp, 1);
#line 671
  return (__cil_tmp);
}
}
#line 675 "rdb.c"
int rdbLoadDoubleValue(FILE *fp , double *val ) 
{ char buf[128] ;
  unsigned char len ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 679
  __cil_tmp = fread((void *)(& len), 1U, 1U, fp);
#line 679
  if (__cil_tmp == 0U) {
#line 679
    return (-1);
  }
#line 680
  switch ((int )len) {
  case 255: 
#line 681
  *val = R_NegInf;
#line 681
  return (0);
  case 254: 
#line 682
  *val = R_PosInf;
#line 682
  return (0);
  case 253: 
#line 683
  *val = R_Nan;
#line 683
  return (0);
  default: 
#line 685
  __cil_tmp___0 = fread((void *)(buf), (unsigned int )len, 1U, fp);
#line 685
  if (__cil_tmp___0 == 0U) {
#line 685
    return (-1);
  }
#line 686
  buf[len] = (char )'\000';
#line 687
  sscanf((char const   *)(buf), "%lg", val);
#line 688
  return (0);
  }
}
}
#line 694 "rdb.c"
robj *rdbLoadObject(int type , FILE *fp ) 
{ robj *o ;
  robj *ele ;
  robj *dec ;
  size_t len ;
  unsigned int i ;
  long __cil_tmp ;
  uint32_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  unsigned char *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  uint32_t __cil_tmp___5 ;
  long long llval ;
  intset *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  size_t zsetlen ;
  zset *zs ;
  uint32_t __cil_tmp___8 ;
  robj *ele___0 ;
  double score ;
  zskiplistNode *znode ;
  int __cil_tmp___9 ;
  size_t __cil_tmp___10 ;
  size_t hashlen ;
  uint32_t __cil_tmp___11 ;
  robj *key ;
  robj *val ;
  size_t __cil_tmp___12 ;
  size_t __cil_tmp___13 ;
  unsigned char *zm ;
  robj *deckey ;
  robj *decval ;
  size_t __cil_tmp___14 ;
  size_t __cil_tmp___15 ;
  size_t __cil_tmp___16 ;

  {
#line 699
  __cil_tmp = ftell(fp);
#line 699
  redisLog(0, "LOADING OBJECT %d (at %d)\n", type, __cil_tmp);
#line 700
  if (type == 0) {
#line 702
    o = rdbLoadEncodedStringObject(fp);
#line 702
    if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 702
      return ((robj *)((void *)0));
    }
#line 703
    o = tryObjectEncoding(o);
  } else
#line 704
  if (type == 1) {
#line 706
    __cil_tmp___0 = rdbLoadLen(fp, (int *)((void *)0));
#line 706
    len = (unsigned int )__cil_tmp___0;
#line 706
    if (len == 4294967295U) {
#line 706
      return ((robj *)((void *)0));
    }
#line 709
    if (len > server.list_max_ziplist_entries) {
#line 710
      o = createListObject();
    } else {
#line 712
      o = createZiplistObject();
    }
#line 716
    while (1) {
#line 716
      __cil_tmp___4 = len;
#line 716
      len --;
#line 716
      if (! __cil_tmp___4) {
#line 716
        break;
      }
#line 717
      ele = rdbLoadEncodedStringObject(fp);
#line 717
      if ((unsigned int )ele == (unsigned int )((void *)0)) {
#line 717
        return ((robj *)((void *)0));
      }
#line 721
      if (o->encoding == 5U && ele->encoding == 0U) {
#line 721
        __cil_tmp___1 = sdslen((char *)ele->ptr);
#line 721
        if (__cil_tmp___1 > server.list_max_ziplist_value) {
#line 724
          listTypeConvert(o, 4);
        }
      }
#line 726
      if (o->encoding == 5U) {
#line 727
        dec = getDecodedObject(ele);
#line 728
        __cil_tmp___2 = sdslen((char *)dec->ptr);
#line 728
        __cil_tmp___3 = ziplistPush((unsigned char *)o->ptr, (unsigned char *)dec->ptr,
                                    __cil_tmp___2, 1);
#line 728
        o->ptr = (void *)__cil_tmp___3;
#line 729
        decrRefCount((void *)dec);
#line 730
        decrRefCount((void *)ele);
      } else {
#line 732
        ele = tryObjectEncoding(ele);
#line 733
        listAddNodeTail((list *)o->ptr, (void *)ele);
      }
    }
  } else
#line 736
  if (type == 2) {
#line 738
    __cil_tmp___5 = rdbLoadLen(fp, (int *)((void *)0));
#line 738
    len = (unsigned int )__cil_tmp___5;
#line 738
    if (len == 4294967295U) {
#line 738
      return ((robj *)((void *)0));
    }
#line 741
    if (len > server.set_max_intset_entries) {
#line 742
      o = createSetObject();
#line 745
      if (len > 4U) {
#line 746
        dictExpand((dict *)o->ptr, (unsigned long )len);
      }
    } else {
#line 748
      o = createIntsetObject();
    }
#line 752
    i = 0U;
#line 752
    while (i < len) {
#line 754
      ele = rdbLoadEncodedStringObject(fp);
#line 754
      if ((unsigned int )ele == (unsigned int )((void *)0)) {
#line 754
        return ((robj *)((void *)0));
      }
#line 755
      ele = tryObjectEncoding(ele);
#line 757
      if (o->encoding == 6U) {
#line 759
        __cil_tmp___7 = isObjectRepresentableAsLongLong(ele, & llval);
#line 759
        if (__cil_tmp___7 == 0) {
#line 760
          __cil_tmp___6 = intsetAdd((intset *)o->ptr, llval, (uint8_t *)((void *)0));
#line 760
          o->ptr = (void *)__cil_tmp___6;
        } else {
#line 762
          setTypeConvert(o, 2);
#line 763
          dictExpand((dict *)o->ptr, (unsigned long )len);
        }
      }
#line 769
      if (o->encoding == 2U) {
#line 770
        dictAdd((dict *)o->ptr, (void *)ele, (void *)0);
      } else {
#line 772
        decrRefCount((void *)ele);
      }
#line 752
      i ++;
    }
  } else
#line 775
  if (type == 3) {
#line 780
    __cil_tmp___8 = rdbLoadLen(fp, (int *)((void *)0));
#line 780
    zsetlen = (unsigned int )__cil_tmp___8;
#line 780
    if (zsetlen == 4294967295U) {
#line 780
      return ((robj *)((void *)0));
    }
#line 781
    o = createZsetObject();
#line 782
    zs = (zset *)o->ptr;
#line 784
    while (1) {
#line 784
      __cil_tmp___10 = zsetlen;
#line 784
      zsetlen --;
#line 784
      if (! __cil_tmp___10) {
#line 784
        break;
      }
#line 789
      ele___0 = rdbLoadEncodedStringObject(fp);
#line 789
      if ((unsigned int )ele___0 == (unsigned int )((void *)0)) {
#line 789
        return ((robj *)((void *)0));
      }
#line 790
      ele___0 = tryObjectEncoding(ele___0);
#line 791
      __cil_tmp___9 = rdbLoadDoubleValue(fp, & score);
#line 791
      if (__cil_tmp___9 == -1) {
#line 791
        return ((robj *)((void *)0));
      }
#line 792
      znode = zslInsert(zs->zsl, score, ele___0);
#line 793
      dictAdd(zs->dict, (void *)ele___0, (void *)(& znode->score));
#line 794
      incrRefCount(ele___0);
    }
  } else
#line 796
  if (type == 4) {
#line 799
    __cil_tmp___11 = rdbLoadLen(fp, (int *)((void *)0));
#line 799
    hashlen = (unsigned int )__cil_tmp___11;
#line 799
    if (hashlen == 4294967295U) {
#line 799
      return ((robj *)((void *)0));
    }
#line 800
    o = createHashObject();
#line 802
    if (hashlen > server.hash_max_zipmap_entries) {
#line 803
      convertToRealHash(o);
    }
#line 806
    while (1) {
#line 806
      __cil_tmp___16 = hashlen;
#line 806
      hashlen --;
#line 806
      if (! __cil_tmp___16) {
#line 806
        break;
      }
#line 809
      key = rdbLoadEncodedStringObject(fp);
#line 809
      if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 809
        return ((robj *)((void *)0));
      }
#line 810
      val = rdbLoadEncodedStringObject(fp);
#line 810
      if ((unsigned int )val == (unsigned int )((void *)0)) {
#line 810
        return ((robj *)((void *)0));
      }
#line 813
      if (o->encoding != 2U) {
#line 813
        if (key->encoding == 0U) {
#line 813
          __cil_tmp___12 = sdslen((char *)key->ptr);
#line 813
          if (__cil_tmp___12 > server.hash_max_zipmap_value) {
#line 819
            convertToRealHash(o);
          } else {
#line 813
            goto _L;
          }
        } else
        _L: 
#line 813
        if (val->encoding == 0U) {
#line 813
          __cil_tmp___13 = sdslen((char *)val->ptr);
#line 813
          if (__cil_tmp___13 > server.hash_max_zipmap_value) {
#line 819
            convertToRealHash(o);
          }
        }
      }
#line 822
      if (o->encoding == 3U) {
#line 823
        zm = (unsigned char *)o->ptr;
#line 827
        deckey = getDecodedObject(key);
#line 828
        decval = getDecodedObject(val);
#line 829
        __cil_tmp___14 = sdslen((char *)decval->ptr);
#line 829
        __cil_tmp___15 = sdslen((char *)deckey->ptr);
#line 829
        zm = zipmapSet(zm, (unsigned char *)deckey->ptr, __cil_tmp___15, (unsigned char *)decval->ptr,
                       __cil_tmp___14, (int *)((void *)0));
#line 831
        o->ptr = (void *)zm;
#line 832
        decrRefCount((void *)deckey);
#line 833
        decrRefCount((void *)decval);
#line 834
        decrRefCount((void *)key);
#line 835
        decrRefCount((void *)val);
      } else {
#line 837
        key = tryObjectEncoding(key);
#line 838
        val = tryObjectEncoding(val);
#line 839
        dictAdd((dict *)o->ptr, (void *)key, (void *)val);
      }
    }
  } else {
#line 843
    _redisPanic((char *)"\"Unknown object type\"", (char *)"rdb.c", 843);
#line 843
    _exit(1);
  }
#line 845
  return (o);
}
}
#line 850 "rdb.c"
void startLoading(FILE *fp ) 
{ struct stat sb ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 854
  server.loading = 1;
#line 855
  server.loading_start_time = time((time_t *)((void *)0));
#line 856
  __cil_tmp = fileno(fp);
#line 856
  __cil_tmp___0 = fstat(__cil_tmp, & sb);
#line 856
  if (__cil_tmp___0 == -1) {
#line 857
    server.loading_total_bytes = 1L;
  } else {
#line 859
    server.loading_total_bytes = sb.st_size;
  }
#line 861
  return;
}
}
#line 864 "rdb.c"
void loadingProgress(off_t pos ) 
{ 

  {
#line 865
  server.loading_loaded_bytes = pos;
#line 866
  return;
}
}
#line 869 "rdb.c"
void stopLoading(void) 
{ 

  {
#line 870
  server.loading = 0;
#line 871
  return;
}
}
#line 873 "rdb.c"
int rdbLoad(char *filename ) 
{ FILE *fp ;
  uint32_t dbid ;
  int type ;
  int retval ;
  int rdbver ;
  int swap_all_values ;
  redisDb *db ;
  char buf[1024] ;
  time_t expiretime ;
  time_t now ;
  time_t __cil_tmp ;
  long loops ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  robj *key ;
  robj *val ;
  int force_swapout ;
  off_t __cil_tmp___2 ;
  long __cil_tmp___3 ;
  dictEntry *de ;
  dictEntry *__cil_tmp___4 ;
  vmpointer *vp ;
  size_t __cil_tmp___5 ;
  int __cil_tmp___6 ;
  size_t __cil_tmp___7 ;
  size_t __cil_tmp___8 ;

  {
#line 877
  swap_all_values = 0;
#line 878
  db = server.db + 0;
#line 880
  __cil_tmp = time((time_t *)((void *)0));
#line 880
  now = __cil_tmp;
#line 881
  loops = 0L;
#line 883
  fp = fopen((char const   *)filename, "r");
#line 884
  if (! fp) {
#line 884
    return (-1);
  }
#line 885
  __cil_tmp___0 = fread((void *)(buf), 9U, 1U, fp);
#line 885
  if (__cil_tmp___0 == 0U) {
#line 885
    goto eoferr;
  }
#line 886
  buf[9] = (char )'\000';
#line 887
  __cil_tmp___1 = memcmp((void const   *)(buf), (void const   *)"REDIS", 5U);
#line 887
  if (__cil_tmp___1 != 0) {
#line 888
    fclose(fp);
#line 889
    redisLog(3, "Wrong signature trying to load DB from file");
#line 890
    return (-1);
  }
#line 892
  rdbver = atoi((char const   *)(buf + 5));
#line 893
  if (rdbver != 1) {
#line 894
    fclose(fp);
#line 895
    redisLog(3, "Can\'t handle RDB format version %d", rdbver);
#line 896
    return (-1);
  }
#line 899
  startLoading(fp);
#line 900
  while (1) {
#line 904
    expiretime = -1L;
#line 907
    __cil_tmp___3 = loops;
#line 907
    loops ++;
#line 907
    if (! (__cil_tmp___3 % 1000L)) {
#line 908
      __cil_tmp___2 = ftello(fp);
#line 908
      loadingProgress(__cil_tmp___2);
#line 909
      aeProcessEvents(server.el, 5);
    }
#line 913
    type = rdbLoadType(fp);
#line 913
    if (type == -1) {
#line 913
      goto eoferr;
    }
#line 914
    if (type == 253) {
#line 915
      expiretime = rdbLoadTime(fp);
#line 915
      if (expiretime == -1L) {
#line 915
        goto eoferr;
      }
#line 917
      type = rdbLoadType(fp);
#line 917
      if (type == -1) {
#line 917
        goto eoferr;
      }
    }
#line 919
    if (type == 255) {
#line 919
      break;
    }
#line 921
    if (type == 254) {
#line 922
      dbid = rdbLoadLen(fp, (int *)((void *)0));
#line 922
      if (dbid == 4294967295UL) {
#line 923
        goto eoferr;
      }
#line 924
      if (dbid >= (unsigned long )((unsigned int )server.dbnum)) {
#line 925
        redisLog(3, "FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n",
                 server.dbnum);
#line 926
        exit(1);
      }
#line 928
      db = server.db + dbid;
#line 929
      continue;
    }
#line 932
    key = rdbLoadStringObject(fp);
#line 932
    if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 932
      goto eoferr;
    }
#line 934
    val = rdbLoadObject(type, fp);
#line 934
    if ((unsigned int )val == (unsigned int )((void *)0)) {
#line 934
      goto eoferr;
    }
#line 936
    if (expiretime != -1L && expiretime < now) {
#line 937
      decrRefCount((void *)key);
#line 938
      decrRefCount((void *)val);
#line 939
      continue;
    }
#line 942
    retval = dbAdd(db, key, val);
#line 943
    if (retval == -1) {
#line 944
      redisLog(3, "Loading DB, duplicated key (%s) found! Unrecoverable error, exiting now.",
               key->ptr);
#line 945
      exit(1);
    }
#line 948
    if (expiretime != -1L) {
#line 948
      setExpire(db, key, expiretime);
    }
#line 957
    if (swap_all_values) {
#line 958
      __cil_tmp___4 = dictFind(db->dict, (void const   *)key->ptr);
#line 958
      de = __cil_tmp___4;
#line 961
      if (de) {
#line 963
        val = (robj *)de->val;
#line 965
        if (val->refcount == 1) {
#line 965
          vp = vmSwapObjectBlocking(val);
#line 965
          if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 967
            de->val = (void *)vp;
          }
        }
      }
#line 969
      decrRefCount((void *)key);
#line 970
      continue;
    }
#line 972
    decrRefCount((void *)key);
#line 975
    force_swapout = 0;
#line 976
    __cil_tmp___5 = zmalloc_used_memory();
#line 976
    if ((unsigned long long )__cil_tmp___5 - server.vm_max_memory > 33554432ULL) {
#line 977
      force_swapout = 1;
    }
#line 981
    if ((! swap_all_values && server.vm_enabled) && force_swapout) {
#line 982
      while (1) {
#line 982
        __cil_tmp___7 = zmalloc_used_memory();
#line 982
        if (! ((unsigned long long )__cil_tmp___7 > server.vm_max_memory)) {
#line 982
          break;
        }
#line 983
        __cil_tmp___6 = vmSwapOneObjectBlocking();
#line 983
        if (__cil_tmp___6 == -1) {
#line 983
          break;
        }
      }
#line 985
      __cil_tmp___8 = zmalloc_used_memory();
#line 985
      if ((unsigned long long )__cil_tmp___8 > server.vm_max_memory) {
#line 986
        swap_all_values = 1;
      }
    }
  }
#line 989
  fclose(fp);
#line 990
  stopLoading();
#line 991
  return (0);
  eoferr: 
#line 994
  redisLog(3, "Short read or OOM loading DB. Unrecoverable error, aborting now.");
#line 995
  exit(1);
#line 996
  return (-1);
}
}
#line 1000 "rdb.c"
void backgroundSaveDoneHandler(int statloc ) 
{ int exitcode ;
  int bysignal ;

  {
#line 1001
  exitcode = statloc & 1;
#line 1002
  bysignal = statloc & 8;
#line 1004
  if (! bysignal && exitcode == 0) {
#line 1005
    redisLog(2, "Background saving terminated with success");
#line 1007
    server.dirty -= server.dirty_before_bgsave;
#line 1008
    server.lastsave = time((time_t *)((void *)0));
  } else
#line 1009
  if (! bysignal && exitcode != 0) {
#line 1010
    redisLog(3, "Background saving error");
  } else {
#line 1012
    redisLog(3, "Background saving terminated by signal %d", statloc & 64);
#line 1014
    rdbRemoveTempFile(server.bgsavechildpid);
  }
#line 1016
  server.bgsavechildpid = -1;
#line 1019
  updateSlavesWaitingBgsave(exitcode == 0 ? 0 : -1);
#line 1020
  return;
}
}
#line 1 "t_string.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-iHrxjfuA.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 7 "t_string.c"
static int checkStringLength(redisClient *c , long long size ) 
{ 

  {
#line 8
  if (size > 536870912LL) {
#line 9
    addReplyError(c, (char *)"string exceeds maximum allowed size (512MB)");
#line 10
    return (-1);
  }
#line 12
  return (0);
}
}
#line 15 "t_string.c"
void setGenericCommand(redisClient *c , int nx , robj *key , robj *val , robj *expire ) 
{ int retval ;
  long seconds ;
  int __cil_tmp ;
  time_t __cil_tmp___0 ;

  {
#line 17
  seconds = 0L;
#line 19
  if (expire) {
#line 20
    __cil_tmp = getLongFromObjectOrReply(c, expire, & seconds, (char const   *)((void *)0));
#line 20
    if (__cil_tmp != 0) {
#line 21
      return;
    }
#line 22
    if (seconds <= 0L) {
#line 23
      addReplyError(c, (char *)"invalid expire time in SETEX");
#line 24
      return;
    }
  }
#line 28
  retval = dbAdd(c->db, key, val);
#line 29
  if (retval == -1) {
#line 30
    if (! nx) {
#line 31
      dbReplace(c->db, key, val);
#line 32
      incrRefCount(val);
    } else {
#line 34
      addReply(c, shared.czero);
#line 35
      return;
    }
  } else {
#line 38
    incrRefCount(val);
  }
#line 40
  touchWatchedKey(c->db, key);
#line 41
  (server.dirty) ++;
#line 42
  removeExpire(c->db, key);
#line 43
  if (expire) {
#line 43
    __cil_tmp___0 = time((time_t *)((void *)0));
#line 43
    setExpire(c->db, key, __cil_tmp___0 + seconds);
  }
#line 44
  addReply(c, nx ? shared.cone : shared.ok);
#line 45
  return;
}
}
#line 47 "t_string.c"
void setCommand(redisClient *c ) 
{ 

  {
#line 48
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 49
  setGenericCommand(c, 0, *(c->argv + 1), *(c->argv + 2), (robj *)((void *)0));
#line 50
  return;
}
}
#line 52 "t_string.c"
void setnxCommand(redisClient *c ) 
{ 

  {
#line 53
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 54
  setGenericCommand(c, 1, *(c->argv + 1), *(c->argv + 2), (robj *)((void *)0));
#line 55
  return;
}
}
#line 57 "t_string.c"
void setexCommand(redisClient *c ) 
{ 

  {
#line 58
  *(c->argv + 3) = tryObjectEncoding(*(c->argv + 3));
#line 59
  setGenericCommand(c, 0, *(c->argv + 1), *(c->argv + 3), *(c->argv + 2));
#line 60
  return;
}
}
#line 62 "t_string.c"
int getGenericCommand(redisClient *c ) 
{ robj *o ;

  {
#line 65
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 65
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 66
    return (0);
  }
#line 68
  if (o->type != 0U) {
#line 69
    addReply(c, shared.wrongtypeerr);
#line 70
    return (-1);
  } else {
#line 72
    addReplyBulk(c, o);
#line 73
    return (0);
  }
}
}
#line 77 "t_string.c"
void getCommand(redisClient *c ) 
{ 

  {
#line 78
  getGenericCommand(c);
#line 79
  return;
}
}
#line 81 "t_string.c"
void getsetCommand(redisClient *c ) 
{ int __cil_tmp ;

  {
#line 82
  __cil_tmp = getGenericCommand(c);
#line 82
  if (__cil_tmp == -1) {
#line 82
    return;
  }
#line 83
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 84
  dbReplace(c->db, *(c->argv + 1), *(c->argv + 2));
#line 85
  incrRefCount(*(c->argv + 2));
#line 86
  touchWatchedKey(c->db, *(c->argv + 1));
#line 87
  (server.dirty) ++;
#line 88
  removeExpire(c->db, *(c->argv + 1));
#line 89
  return;
}
}
#line 91 "t_string.c"
static int getBitOffsetFromArgument(redisClient *c , robj *o , size_t *offset ) 
{ long long loffset ;
  char *err ;
  int __cil_tmp ;

  {
#line 93
  err = (char *)"bit offset is not an integer or out of range";
#line 95
  __cil_tmp = getLongLongFromObjectOrReply(c, o, & loffset, (char const   *)err);
#line 95
  if (__cil_tmp != 0) {
#line 96
    return (-1);
  }
#line 99
  if (loffset < 0LL || (unsigned long long )loffset >> 3 >= 536870912ULL) {
#line 101
    addReplyError(c, err);
#line 102
    return (-1);
  }
#line 105
  *offset = (unsigned int )loffset;
#line 106
  return (0);
}
}
#line 109 "t_string.c"
void setbitCommand(redisClient *c ) 
{ robj *o ;
  char *err ;
  size_t bitoffset ;
  int byte ;
  int bit ;
  int byteval ;
  int bitval ;
  long on ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  sds __cil_tmp___1 ;
  int __cil_tmp___2 ;
  robj *decoded ;
  robj *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  sds __cil_tmp___5 ;

  {
#line 111
  err = (char *)"bit is not an integer or out of range";
#line 117
  __cil_tmp = getBitOffsetFromArgument(c, *(c->argv + 2), & bitoffset);
#line 117
  if (__cil_tmp != 0) {
#line 118
    return;
  }
#line 120
  __cil_tmp___0 = getLongFromObjectOrReply(c, *(c->argv + 3), & on, (char const   *)err);
#line 120
  if (__cil_tmp___0 != 0) {
#line 121
    return;
  }
#line 124
  if (on & -2L) {
#line 125
    addReplyError(c, err);
#line 126
    return;
  }
#line 129
  o = lookupKeyWrite(c->db, *(c->argv + 1));
#line 130
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 131
    __cil_tmp___1 = sdsempty();
#line 131
    o = createObject(0, (void *)__cil_tmp___1);
#line 132
    dbAdd(c->db, *(c->argv + 1), o);
  } else {
#line 134
    __cil_tmp___2 = checkType(c, o, 0);
#line 134
    if (__cil_tmp___2) {
#line 134
      return;
    }
#line 137
    if (o->refcount != 1 || o->encoding != 0U) {
#line 138
      __cil_tmp___3 = getDecodedObject(o);
#line 138
      decoded = __cil_tmp___3;
#line 139
      __cil_tmp___4 = sdslen((char *)decoded->ptr);
#line 139
      o = createStringObject((char *)decoded->ptr, __cil_tmp___4);
#line 140
      decrRefCount((void *)decoded);
#line 141
      dbReplace(c->db, *(c->argv + 1), o);
    }
  }
#line 146
  byte = (int )(bitoffset >> 3);
#line 147
  __cil_tmp___5 = sdsgrowzero((char *)o->ptr, (unsigned int )(byte + 1));
#line 147
  o->ptr = (void *)__cil_tmp___5;
#line 150
  byteval = (int )*((char *)o->ptr + byte);
#line 151
  bit = (int )(7U - (bitoffset & 7U));
#line 152
  bitval = byteval & (1 << bit);
#line 155
  byteval &= ~ (1 << bit);
#line 156
  byteval = (int )((long )byteval | ((on & 1L) << bit));
#line 157
  *((char *)o->ptr + byte) = (char )byteval;
#line 158
  touchWatchedKey(c->db, *(c->argv + 1));
#line 159
  (server.dirty) ++;
#line 160
  addReply(c, bitval ? shared.cone : shared.czero);
#line 161
  return;
}
}
#line 163 "t_string.c"
void getbitCommand(redisClient *c ) 
{ robj *o ;
  char llbuf[32] ;
  size_t bitoffset ;
  size_t byte ;
  size_t bit ;
  size_t bitval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 168
  bitval = 0U;
#line 170
  __cil_tmp = getBitOffsetFromArgument(c, *(c->argv + 2), & bitoffset);
#line 170
  if (__cil_tmp != 0) {
#line 171
    return;
  }
#line 173
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 173
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 174
    return;
  } else {
#line 173
    __cil_tmp___0 = checkType(c, o, 0);
#line 173
    if (__cil_tmp___0) {
#line 174
      return;
    }
  }
#line 176
  byte = bitoffset >> 3;
#line 177
  bit = 7U - (bitoffset & 7U);
#line 178
  if (o->encoding != 0U) {
#line 179
    __cil_tmp___1 = ll2string(llbuf, (unsigned int )sizeof(llbuf), (long long )((long )o->ptr));
#line 179
    if (byte < (unsigned int )__cil_tmp___1) {
#line 180
      bitval = (unsigned int )((int )llbuf[byte] & (1 << bit));
    }
  } else {
#line 182
    __cil_tmp___2 = sdslen((char *)o->ptr);
#line 182
    if (byte < __cil_tmp___2) {
#line 183
      bitval = (unsigned int )((int )*((char *)o->ptr + byte) & (1 << bit));
    }
  }
#line 186
  addReply(c, bitval ? shared.cone : shared.czero);
#line 187
  return;
}
}
#line 189 "t_string.c"
void setrangeCommand(redisClient *c ) 
{ robj *o ;
  long offset ;
  sds value ;
  int __cil_tmp ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  sds __cil_tmp___3 ;
  size_t olen ;
  int __cil_tmp___4 ;
  size_t __cil_tmp___5 ;
  size_t __cil_tmp___6 ;
  int __cil_tmp___7 ;
  robj *decoded ;
  robj *__cil_tmp___8 ;
  size_t __cil_tmp___9 ;
  size_t __cil_tmp___10 ;
  sds __cil_tmp___11 ;
  size_t __cil_tmp___12 ;
  size_t __cil_tmp___13 ;
  size_t __cil_tmp___14 ;

  {
#line 192
  value = (char *)(*(c->argv + 3))->ptr;
#line 194
  __cil_tmp = getLongFromObjectOrReply(c, *(c->argv + 2), & offset, (char const   *)((void *)0));
#line 194
  if (__cil_tmp != 0) {
#line 195
    return;
  }
#line 197
  if (offset < 0L) {
#line 198
    addReplyError(c, (char *)"offset is out of range");
#line 199
    return;
  }
#line 202
  o = lookupKeyWrite(c->db, *(c->argv + 1));
#line 203
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 205
    __cil_tmp___0 = sdslen(value);
#line 205
    if (__cil_tmp___0 == 0U) {
#line 206
      addReply(c, shared.czero);
#line 207
      return;
    }
#line 211
    __cil_tmp___1 = sdslen(value);
#line 211
    __cil_tmp___2 = checkStringLength(c, (long long )((unsigned long )offset + (unsigned long )__cil_tmp___1));
#line 211
    if (__cil_tmp___2 != 0) {
#line 212
      return;
    }
#line 214
    __cil_tmp___3 = sdsempty();
#line 214
    o = createObject(0, (void *)__cil_tmp___3);
#line 215
    dbAdd(c->db, *(c->argv + 1), o);
  } else {
#line 220
    __cil_tmp___4 = checkType(c, o, 0);
#line 220
    if (__cil_tmp___4) {
#line 221
      return;
    }
#line 224
    olen = stringObjectLen(o);
#line 225
    __cil_tmp___5 = sdslen(value);
#line 225
    if (__cil_tmp___5 == 0U) {
#line 226
      addReplyLongLong(c, (long long )olen);
#line 227
      return;
    }
#line 231
    __cil_tmp___6 = sdslen(value);
#line 231
    __cil_tmp___7 = checkStringLength(c, (long long )((unsigned long )offset + (unsigned long )__cil_tmp___6));
#line 231
    if (__cil_tmp___7 != 0) {
#line 232
      return;
    }
#line 235
    if (o->refcount != 1 || o->encoding != 0U) {
#line 236
      __cil_tmp___8 = getDecodedObject(o);
#line 236
      decoded = __cil_tmp___8;
#line 237
      __cil_tmp___9 = sdslen((char *)decoded->ptr);
#line 237
      o = createStringObject((char *)decoded->ptr, __cil_tmp___9);
#line 238
      decrRefCount((void *)decoded);
#line 239
      dbReplace(c->db, *(c->argv + 1), o);
    }
  }
#line 243
  __cil_tmp___13 = sdslen(value);
#line 243
  if (__cil_tmp___13 > 0U) {
#line 244
    __cil_tmp___10 = sdslen(value);
#line 244
    __cil_tmp___11 = sdsgrowzero((char *)o->ptr, (unsigned int )((unsigned long )offset + (unsigned long )__cil_tmp___10));
#line 244
    o->ptr = (void *)__cil_tmp___11;
#line 245
    __cil_tmp___12 = sdslen(value);
#line 245
    memcpy((void *)((char *)o->ptr + offset), (void const   *)value, __cil_tmp___12);
#line 246
    touchWatchedKey(c->db, *(c->argv + 1));
#line 247
    (server.dirty) ++;
  }
#line 249
  __cil_tmp___14 = sdslen((char *)o->ptr);
#line 249
  addReplyLongLong(c, (long long )__cil_tmp___14);
#line 250
  return;
}
}
#line 252 "t_string.c"
void getrangeCommand(redisClient *c ) 
{ robj *o ;
  long start ;
  long end ;
  char *str ;
  char llbuf[32] ;
  size_t strlen___0 ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 258
  __cil_tmp = getLongFromObjectOrReply(c, *(c->argv + 2), & start, (char const   *)((void *)0));
#line 258
  if (__cil_tmp != 0) {
#line 259
    return;
  }
#line 260
  __cil_tmp___0 = getLongFromObjectOrReply(c, *(c->argv + 3), & end, (char const   *)((void *)0));
#line 260
  if (__cil_tmp___0 != 0) {
#line 261
    return;
  }
#line 262
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 262
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 263
    return;
  } else {
#line 262
    __cil_tmp___1 = checkType(c, o, 0);
#line 262
    if (__cil_tmp___1) {
#line 263
      return;
    }
  }
#line 265
  if (o->encoding == 1U) {
#line 266
    str = llbuf;
#line 267
    __cil_tmp___2 = ll2string(llbuf, (unsigned int )sizeof(llbuf), (long long )((long )o->ptr));
#line 267
    strlen___0 = (unsigned int )__cil_tmp___2;
  } else {
#line 269
    str = (char *)o->ptr;
#line 270
    strlen___0 = sdslen(str);
  }
#line 274
  if (start < 0L) {
#line 274
    start = (long )((unsigned long )strlen___0 + (unsigned long )start);
  }
#line 275
  if (end < 0L) {
#line 275
    end = (long )((unsigned long )strlen___0 + (unsigned long )end);
  }
#line 276
  if (start < 0L) {
#line 276
    start = 0L;
  }
#line 277
  if (end < 0L) {
#line 277
    end = 0L;
  }
#line 278
  if ((unsigned int )end >= strlen___0) {
#line 278
    end = (long )(strlen___0 - 1U);
  }
#line 282
  if (start > end) {
#line 283
    addReply(c, shared.nullbulk);
  } else {
#line 285
    addReplyBulkCBuffer(c, (void *)(str + start), (unsigned int )((end - start) + 1L));
  }
#line 287
  return;
}
}
#line 289 "t_string.c"
void mgetCommand(redisClient *c ) 
{ int j ;
  robj *o ;
  robj *__cil_tmp ;

  {
#line 292
  addReplyMultiBulkLen(c, (long )(c->argc - 1));
#line 293
  j = 1;
#line 293
  while (j < c->argc) {
#line 294
    __cil_tmp = lookupKeyRead(c->db, *(c->argv + j));
#line 294
    o = __cil_tmp;
#line 295
    if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 296
      addReply(c, shared.nullbulk);
    } else
#line 298
    if (o->type != 0U) {
#line 299
      addReply(c, shared.nullbulk);
    } else {
#line 301
      addReplyBulk(c, o);
    }
#line 293
    j ++;
  }
#line 305
  return;
}
}
#line 307 "t_string.c"
void msetGenericCommand(redisClient *c , int nx ) 
{ int j ;
  int busykeys ;
  robj *__cil_tmp ;

  {
#line 308
  busykeys = 0;
#line 310
  if (c->argc % 2 == 0) {
#line 311
    addReplyError(c, (char *)"wrong number of arguments for MSET");
#line 312
    return;
  }
#line 316
  if (nx) {
#line 317
    j = 1;
#line 317
    while (j < c->argc) {
#line 318
      __cil_tmp = lookupKeyWrite(c->db, *(c->argv + j));
#line 318
      if ((unsigned int )__cil_tmp != (unsigned int )((void *)0)) {
#line 319
        busykeys ++;
      }
#line 317
      j += 2;
    }
  }
#line 323
  if (busykeys) {
#line 324
    addReply(c, shared.czero);
#line 325
    return;
  }
#line 328
  j = 1;
#line 328
  while (j < c->argc) {
#line 329
    *(c->argv + (j + 1)) = tryObjectEncoding(*(c->argv + (j + 1)));
#line 330
    dbReplace(c->db, *(c->argv + j), *(c->argv + (j + 1)));
#line 331
    incrRefCount(*(c->argv + (j + 1)));
#line 332
    removeExpire(c->db, *(c->argv + j));
#line 333
    touchWatchedKey(c->db, *(c->argv + j));
#line 328
    j += 2;
  }
#line 335
  server.dirty += (long long )((c->argc - 1) / 2);
#line 336
  addReply(c, nx ? shared.cone : shared.ok);
#line 337
  return;
}
}
#line 339 "t_string.c"
void msetCommand(redisClient *c ) 
{ 

  {
#line 340
  msetGenericCommand(c, 0);
#line 341
  return;
}
}
#line 343 "t_string.c"
void msetnxCommand(redisClient *c ) 
{ 

  {
#line 344
  msetGenericCommand(c, 1);
#line 345
  return;
}
}
#line 347 "t_string.c"
void incrDecrCommand(redisClient *c , long long incr ) 
{ long long value ;
  long long oldvalue ;
  robj *o ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 351
  o = lookupKeyWrite(c->db, *(c->argv + 1));
#line 352
  if ((unsigned int )o != (unsigned int )((void *)0)) {
#line 352
    __cil_tmp = checkType(c, o, 0);
#line 352
    if (__cil_tmp) {
#line 352
      return;
    }
  }
#line 353
  __cil_tmp___0 = getLongLongFromObjectOrReply(c, o, & value, (char const   *)((void *)0));
#line 353
  if (__cil_tmp___0 != 0) {
#line 353
    return;
  }
#line 355
  oldvalue = value;
#line 356
  value += incr;
#line 357
  if ((incr < 0LL && value > oldvalue) || (incr > 0LL && value < oldvalue)) {
#line 358
    addReplyError(c, (char *)"increment or decrement would overflow");
#line 359
    return;
  }
#line 361
  o = createStringObjectFromLongLong(value);
#line 362
  dbReplace(c->db, *(c->argv + 1), o);
#line 363
  touchWatchedKey(c->db, *(c->argv + 1));
#line 364
  (server.dirty) ++;
#line 365
  addReply(c, shared.colon);
#line 366
  addReply(c, o);
#line 367
  addReply(c, shared.crlf);
#line 368
  return;
}
}
#line 370 "t_string.c"
void incrCommand(redisClient *c ) 
{ 

  {
#line 371
  incrDecrCommand(c, 1LL);
#line 372
  return;
}
}
#line 374 "t_string.c"
void decrCommand(redisClient *c ) 
{ 

  {
#line 375
  incrDecrCommand(c, -1LL);
#line 376
  return;
}
}
#line 378 "t_string.c"
void incrbyCommand(redisClient *c ) 
{ long long incr ;
  int __cil_tmp ;

  {
#line 381
  __cil_tmp = getLongLongFromObjectOrReply(c, *(c->argv + 2), & incr, (char const   *)((void *)0));
#line 381
  if (__cil_tmp != 0) {
#line 381
    return;
  }
#line 382
  incrDecrCommand(c, incr);
#line 383
  return;
}
}
#line 385 "t_string.c"
void decrbyCommand(redisClient *c ) 
{ long long incr ;
  int __cil_tmp ;

  {
#line 388
  __cil_tmp = getLongLongFromObjectOrReply(c, *(c->argv + 2), & incr, (char const   *)((void *)0));
#line 388
  if (__cil_tmp != 0) {
#line 388
    return;
  }
#line 389
  incrDecrCommand(c, - incr);
#line 390
  return;
}
}
#line 392 "t_string.c"
void appendCommand(redisClient *c ) 
{ size_t totlen ;
  robj *o ;
  robj *append ;
  int __cil_tmp ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  robj *decoded ;
  robj *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  size_t __cil_tmp___5 ;
  sds __cil_tmp___6 ;

  {
#line 396
  o = lookupKeyWrite(c->db, *(c->argv + 1));
#line 397
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 399
    *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 400
    dbAdd(c->db, *(c->argv + 1), *(c->argv + 2));
#line 401
    incrRefCount(*(c->argv + 2));
#line 402
    totlen = stringObjectLen(*(c->argv + 2));
  } else {
#line 405
    __cil_tmp = checkType(c, o, 0);
#line 405
    if (__cil_tmp) {
#line 406
      return;
    }
#line 409
    append = *(c->argv + 2);
#line 410
    __cil_tmp___0 = stringObjectLen(o);
#line 410
    __cil_tmp___1 = sdslen((char *)append->ptr);
#line 410
    totlen = __cil_tmp___0 + __cil_tmp___1;
#line 411
    __cil_tmp___2 = checkStringLength(c, (long long )totlen);
#line 411
    if (__cil_tmp___2 != 0) {
#line 412
      return;
    }
#line 415
    if (o->refcount != 1 || o->encoding != 0U) {
#line 416
      __cil_tmp___3 = getDecodedObject(o);
#line 416
      decoded = __cil_tmp___3;
#line 417
      __cil_tmp___4 = sdslen((char *)decoded->ptr);
#line 417
      o = createStringObject((char *)decoded->ptr, __cil_tmp___4);
#line 418
      decrRefCount((void *)decoded);
#line 419
      dbReplace(c->db, *(c->argv + 1), o);
    }
#line 423
    __cil_tmp___5 = sdslen((char *)append->ptr);
#line 423
    __cil_tmp___6 = sdscatlen((char *)o->ptr, append->ptr, __cil_tmp___5);
#line 423
    o->ptr = (void *)__cil_tmp___6;
#line 424
    totlen = sdslen((char *)o->ptr);
  }
#line 426
  touchWatchedKey(c->db, *(c->argv + 1));
#line 427
  (server.dirty) ++;
#line 428
  addReplyLongLong(c, (long long )totlen);
#line 429
  return;
}
}
#line 431 "t_string.c"
void strlenCommand(redisClient *c ) 
{ robj *o ;
  int __cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 433
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 433
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 434
    return;
  } else {
#line 433
    __cil_tmp = checkType(c, o, 0);
#line 433
    if (__cil_tmp) {
#line 434
      return;
    }
  }
#line 435
  __cil_tmp___0 = stringObjectLen(o);
#line 435
  addReplyLongLong(c, (long long )__cil_tmp___0);
#line 436
  return;
}
}
#line 1 "t_list.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lyMf9PR9.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 675 "redis.h"
void listTypeTryConversion(robj *subject , robj *value ) ;
#line 676
void listTypePush(robj *subject , robj *value , int where ) ;
#line 677
robj *listTypePop(robj *subject , int where ) ;
#line 678
unsigned long listTypeLength(robj *subject ) ;
#line 679
listTypeIterator *listTypeInitIterator(robj *subject , int index___0 , unsigned char direction ) ;
#line 680
void listTypeReleaseIterator(listTypeIterator *li ) ;
#line 681
int listTypeNext(listTypeIterator *li , listTypeEntry *entry ) ;
#line 682
robj *listTypeGet(listTypeEntry *entry ) ;
#line 683
void listTypeInsert(listTypeEntry *entry , robj *value , int where ) ;
#line 684
int listTypeEqual(listTypeEntry *entry , robj *o ) ;
#line 685
void listTypeDelete(listTypeEntry *entry ) ;
#line 688
int handleClientsWaitingListPush(redisClient *c , robj *key , robj *ele ) ;
#line 689
void popGenericCommand(redisClient *c , int where ) ;
#line 10 "t_list.c"
void listTypeTryConversion(robj *subject , robj *value ) 
{ size_t __cil_tmp ;

  {
#line 11
  if (subject->encoding != 5U) {
#line 11
    return;
  }
#line 12
  if (value->encoding == 0U) {
#line 12
    __cil_tmp = sdslen((char *)value->ptr);
#line 12
    if (__cil_tmp > server.list_max_ziplist_value) {
#line 14
      listTypeConvert(subject, 4);
    }
  }
#line 15
  return;
}
}
#line 17 "t_list.c"
void listTypePush(robj *subject , robj *value , int where ) 
{ unsigned int __cil_tmp ;
  int pos ;
  size_t __cil_tmp___0 ;
  unsigned char *__cil_tmp___1 ;

  {
#line 19
  listTypeTryConversion(subject, value);
#line 20
  if (subject->encoding == 5U) {
#line 20
    __cil_tmp = ziplistLen((unsigned char *)subject->ptr);
#line 20
    if (__cil_tmp >= server.list_max_ziplist_entries) {
#line 22
      listTypeConvert(subject, 4);
    }
  }
#line 24
  if (subject->encoding == 5U) {
#line 25
    pos = where == 0 ? 0 : 1;
#line 26
    value = getDecodedObject(value);
#line 27
    __cil_tmp___0 = sdslen((char *)value->ptr);
#line 27
    __cil_tmp___1 = ziplistPush((unsigned char *)subject->ptr, (unsigned char *)value->ptr,
                                __cil_tmp___0, pos);
#line 27
    subject->ptr = (void *)__cil_tmp___1;
#line 28
    decrRefCount((void *)value);
  } else
#line 29
  if (subject->encoding == 4U) {
#line 30
    if (where == 0) {
#line 31
      listAddNodeHead((list *)subject->ptr, (void *)value);
    } else {
#line 33
      listAddNodeTail((list *)subject->ptr, (void *)value);
    }
#line 35
    incrRefCount(value);
  } else {
#line 37
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 37);
#line 37
    _exit(1);
  }
#line 39
  return;
}
}
#line 41 "t_list.c"
robj *listTypePop(robj *subject , int where ) 
{ robj *value ;
  unsigned char *p ;
  unsigned char *vstr ;
  unsigned int vlen ;
  long long vlong ;
  int pos ;
  unsigned char *__cil_tmp ;
  unsigned int __cil_tmp___0 ;
  list *list___0 ;
  listNode *ln ;

  {
#line 42
  value = (robj *)((void *)0);
#line 43
  if (subject->encoding == 5U) {
#line 48
    pos = where == 0 ? 0 : -1;
#line 49
    p = ziplistIndex((unsigned char *)subject->ptr, pos);
#line 50
    __cil_tmp___0 = ziplistGet(p, & vstr, & vlen, & vlong);
#line 50
    if (__cil_tmp___0) {
#line 51
      if (vstr) {
#line 52
        value = createStringObject((char *)vstr, vlen);
      } else {
#line 54
        value = createStringObjectFromLongLong(vlong);
      }
#line 57
      __cil_tmp = ziplistDelete((unsigned char *)subject->ptr, & p);
#line 57
      subject->ptr = (void *)__cil_tmp;
    }
  } else
#line 59
  if (subject->encoding == 4U) {
#line 60
    list___0 = (list *)subject->ptr;
#line 62
    if (where == 0) {
#line 63
      ln = list___0->head;
    } else {
#line 65
      ln = list___0->tail;
    }
#line 67
    if ((unsigned int )ln != (unsigned int )((void *)0)) {
#line 68
      value = (robj *)ln->value;
#line 69
      incrRefCount(value);
#line 70
      listDelNode(list___0, ln);
    }
  } else {
#line 73
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 73);
#line 73
    _exit(1);
  }
#line 75
  return (value);
}
}
#line 78 "t_list.c"
unsigned long listTypeLength(robj *subject ) 
{ unsigned int __cil_tmp ;

  {
#line 79
  if (subject->encoding == 5U) {
#line 80
    __cil_tmp = ziplistLen((unsigned char *)subject->ptr);
#line 80
    return ((unsigned long )__cil_tmp);
  } else
#line 81
  if (subject->encoding == 4U) {
#line 82
    return ((unsigned long )((list *)subject->ptr)->len);
  } else {
#line 84
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 84);
#line 84
    _exit(1);
  }
}
}
#line 89 "t_list.c"
listTypeIterator *listTypeInitIterator(robj *subject , int index___0 , unsigned char direction ) 
{ listTypeIterator *li ;
  void *__cil_tmp ;

  {
#line 90
  __cil_tmp = malloc((unsigned int )sizeof(listTypeIterator ));
#line 90
  li = (listTypeIterator *)__cil_tmp;
#line 91
  li->subject = subject;
#line 92
  li->encoding = (unsigned char )subject->encoding;
#line 93
  li->direction = direction;
#line 94
  if ((int )li->encoding == 5) {
#line 95
    li->zi = ziplistIndex((unsigned char *)subject->ptr, index___0);
  } else
#line 96
  if ((int )li->encoding == 4) {
#line 97
    li->ln = listIndex((list *)subject->ptr, index___0);
  } else {
#line 99
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 99);
#line 99
    _exit(1);
  }
#line 101
  return (li);
}
}
#line 105 "t_list.c"
void listTypeReleaseIterator(listTypeIterator *li ) 
{ 

  {
#line 106
  free((void *)li);
#line 107
  return;
}
}
#line 112 "t_list.c"
int listTypeNext(listTypeIterator *li , listTypeEntry *entry ) 
{ 

  {
#line 114
  if (! ((li->subject)->encoding == (unsigned int )li->encoding)) {
#line 114
    _redisAssert((char *)"li->subject->encoding == li->encoding", (char *)"t_list.c",
                 114);
#line 114
    _exit(1);
  }
#line 116
  entry->li = li;
#line 117
  if ((int )li->encoding == 5) {
#line 118
    entry->zi = li->zi;
#line 119
    if ((unsigned int )entry->zi != (unsigned int )((void *)0)) {
#line 120
      if ((int )li->direction == 1) {
#line 121
        li->zi = ziplistNext((unsigned char *)(li->subject)->ptr, li->zi);
      } else {
#line 123
        li->zi = ziplistPrev((unsigned char *)(li->subject)->ptr, li->zi);
      }
#line 124
      return (1);
    }
  } else
#line 126
  if ((int )li->encoding == 4) {
#line 127
    entry->ln = li->ln;
#line 128
    if ((unsigned int )entry->ln != (unsigned int )((void *)0)) {
#line 129
      if ((int )li->direction == 1) {
#line 130
        li->ln = (li->ln)->next;
      } else {
#line 132
        li->ln = (li->ln)->prev;
      }
#line 133
      return (1);
    }
  } else {
#line 136
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 136);
#line 136
    _exit(1);
  }
#line 138
  return (0);
}
}
#line 142 "t_list.c"
robj *listTypeGet(listTypeEntry *entry ) 
{ listTypeIterator *li ;
  robj *value ;
  unsigned char *vstr ;
  unsigned int vlen ;
  long long vlong ;
  unsigned int __cil_tmp ;

  {
#line 143
  li = entry->li;
#line 144
  value = (robj *)((void *)0);
#line 145
  if ((int )li->encoding == 5) {
#line 149
    if (! ((unsigned int )entry->zi != (unsigned int )((void *)0))) {
#line 149
      _redisAssert((char *)"entry->zi != NULL", (char *)"t_list.c", 149);
#line 149
      _exit(1);
    }
#line 150
    __cil_tmp = ziplistGet(entry->zi, & vstr, & vlen, & vlong);
#line 150
    if (__cil_tmp) {
#line 151
      if (vstr) {
#line 152
        value = createStringObject((char *)vstr, vlen);
      } else {
#line 154
        value = createStringObjectFromLongLong(vlong);
      }
    }
  } else
#line 157
  if ((int )li->encoding == 4) {
#line 158
    if (! ((unsigned int )entry->ln != (unsigned int )((void *)0))) {
#line 158
      _redisAssert((char *)"entry->ln != NULL", (char *)"t_list.c", 158);
#line 158
      _exit(1);
    }
#line 159
    value = (robj *)(entry->ln)->value;
#line 160
    incrRefCount(value);
  } else {
#line 162
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 162);
#line 162
    _exit(1);
  }
#line 164
  return (value);
}
}
#line 167 "t_list.c"
void listTypeInsert(listTypeEntry *entry , robj *value , int where ) 
{ robj *subject ;
  unsigned char *next ;
  unsigned char *__cil_tmp ;
  size_t __cil_tmp___0 ;
  unsigned char *__cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  unsigned char *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  unsigned char *__cil_tmp___5 ;

  {
#line 168
  subject = (entry->li)->subject;
#line 169
  if ((int )(entry->li)->encoding == 5) {
#line 170
    value = getDecodedObject(value);
#line 171
    if (where == 1) {
#line 172
      __cil_tmp = ziplistNext((unsigned char *)subject->ptr, entry->zi);
#line 172
      next = __cil_tmp;
#line 176
      if ((unsigned int )next == (unsigned int )((void *)0)) {
#line 177
        __cil_tmp___0 = sdslen((char *)value->ptr);
#line 177
        __cil_tmp___1 = ziplistPush((unsigned char *)subject->ptr, (unsigned char *)value->ptr,
                                    __cil_tmp___0, 1);
#line 177
        subject->ptr = (void *)__cil_tmp___1;
      } else {
#line 179
        __cil_tmp___2 = sdslen((char *)value->ptr);
#line 179
        __cil_tmp___3 = ziplistInsert((unsigned char *)subject->ptr, next, (unsigned char *)value->ptr,
                                      __cil_tmp___2);
#line 179
        subject->ptr = (void *)__cil_tmp___3;
      }
    } else {
#line 182
      __cil_tmp___4 = sdslen((char *)value->ptr);
#line 182
      __cil_tmp___5 = ziplistInsert((unsigned char *)subject->ptr, entry->zi, (unsigned char *)value->ptr,
                                    __cil_tmp___4);
#line 182
      subject->ptr = (void *)__cil_tmp___5;
    }
#line 184
    decrRefCount((void *)value);
  } else
#line 185
  if ((int )(entry->li)->encoding == 4) {
#line 186
    if (where == 1) {
#line 187
      listInsertNode((list *)subject->ptr, entry->ln, (void *)value, 1);
    } else {
#line 189
      listInsertNode((list *)subject->ptr, entry->ln, (void *)value, 0);
    }
#line 191
    incrRefCount(value);
  } else {
#line 193
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 193);
#line 193
    _exit(1);
  }
#line 195
  return;
}
}
#line 198 "t_list.c"
int listTypeEqual(listTypeEntry *entry , robj *o ) 
{ listTypeIterator *li ;
  size_t __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 199
  li = entry->li;
#line 200
  if ((int )li->encoding == 5) {
#line 201
    if (! (o->encoding == 0U)) {
#line 201
      _redisAssert((char *)"o->encoding == REDIS_ENCODING_RAW", (char *)"t_list.c",
                   201);
#line 201
      _exit(1);
    }
#line 202
    __cil_tmp = sdslen((char *)o->ptr);
#line 202
    __cil_tmp___0 = ziplistCompare(entry->zi, (unsigned char *)o->ptr, __cil_tmp);
#line 202
    return ((int )__cil_tmp___0);
  } else
#line 203
  if ((int )li->encoding == 4) {
#line 204
    __cil_tmp___1 = equalStringObjects(o, (robj *)(entry->ln)->value);
#line 204
    return (__cil_tmp___1);
  } else {
#line 206
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 206);
#line 206
    _exit(1);
  }
}
}
#line 211 "t_list.c"
void listTypeDelete(listTypeEntry *entry ) 
{ listTypeIterator *li ;
  unsigned char *p ;
  unsigned char *__cil_tmp ;
  listNode *next ;

  {
#line 212
  li = entry->li;
#line 213
  if ((int )li->encoding == 5) {
#line 214
    p = entry->zi;
#line 215
    __cil_tmp = ziplistDelete((unsigned char *)(li->subject)->ptr, & p);
#line 215
    (li->subject)->ptr = (void *)__cil_tmp;
#line 218
    if ((int )li->direction == 1) {
#line 219
      li->zi = p;
    } else {
#line 221
      li->zi = ziplistPrev((unsigned char *)(li->subject)->ptr, p);
    }
  } else
#line 222
  if ((int )(entry->li)->encoding == 4) {
#line 224
    if ((int )li->direction == 1) {
#line 225
      next = (entry->ln)->next;
    } else {
#line 227
      next = (entry->ln)->prev;
    }
#line 228
    listDelNode((list *)(li->subject)->ptr, entry->ln);
#line 229
    li->ln = next;
  } else {
#line 231
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 231);
#line 231
    _exit(1);
  }
#line 233
  return;
}
}
#line 235 "t_list.c"
void listTypeConvert(robj *subject , int enc ) 
{ listTypeIterator *li ;
  listTypeEntry entry ;
  list *l ;
  list *__cil_tmp ;
  robj *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 238
  if (! (subject->type == 1U)) {
#line 238
    _redisAssert((char *)"subject->type == REDIS_LIST", (char *)"t_list.c", 238);
#line 238
    _exit(1);
  }
#line 240
  if (enc == 4) {
#line 241
    __cil_tmp = listCreate();
#line 241
    l = __cil_tmp;
#line 242
    l->free = & decrRefCount;
#line 245
    li = listTypeInitIterator(subject, 0, (unsigned char)1);
#line 246
    while (1) {
#line 246
      __cil_tmp___1 = listTypeNext(li, & entry);
#line 246
      if (! __cil_tmp___1) {
#line 246
        break;
      }
#line 246
      __cil_tmp___0 = listTypeGet(& entry);
#line 246
      listAddNodeTail(l, (void *)__cil_tmp___0);
    }
#line 247
    listTypeReleaseIterator(li);
#line 249
    subject->encoding = 4U;
#line 250
    free(subject->ptr);
#line 251
    subject->ptr = (void *)l;
  } else {
#line 253
    _redisPanic((char *)"\"Unsupported list conversion\"", (char *)"t_list.c", 253);
#line 253
    _exit(1);
  }
#line 255
  return;
}
}
#line 261 "t_list.c"
void pushGenericCommand(redisClient *c , int where ) 
{ robj *lobj ;
  robj *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  unsigned long __cil_tmp___2 ;

  {
#line 262
  __cil_tmp = lookupKeyWrite(c->db, *(c->argv + 1));
#line 262
  lobj = __cil_tmp;
#line 263
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 264
  if ((unsigned int )lobj == (unsigned int )((void *)0)) {
#line 265
    __cil_tmp___0 = handleClientsWaitingListPush(c, *(c->argv + 1), *(c->argv + 2));
#line 265
    if (__cil_tmp___0) {
#line 266
      addReply(c, shared.cone);
#line 267
      return;
    }
#line 269
    lobj = createZiplistObject();
#line 270
    dbAdd(c->db, *(c->argv + 1), lobj);
  } else {
#line 272
    if (lobj->type != 1U) {
#line 273
      addReply(c, shared.wrongtypeerr);
#line 274
      return;
    }
#line 276
    __cil_tmp___1 = handleClientsWaitingListPush(c, *(c->argv + 1), *(c->argv + 2));
#line 276
    if (__cil_tmp___1) {
#line 277
      touchWatchedKey(c->db, *(c->argv + 1));
#line 278
      addReply(c, shared.cone);
#line 279
      return;
    }
  }
#line 282
  listTypePush(lobj, *(c->argv + 2), where);
#line 283
  __cil_tmp___2 = listTypeLength(lobj);
#line 283
  addReplyLongLong(c, (long long )__cil_tmp___2);
#line 284
  touchWatchedKey(c->db, *(c->argv + 1));
#line 285
  (server.dirty) ++;
#line 286
  return;
}
}
#line 288 "t_list.c"
void lpushCommand(redisClient *c ) 
{ 

  {
#line 289
  pushGenericCommand(c, 0);
#line 290
  return;
}
}
#line 292 "t_list.c"
void rpushCommand(redisClient *c ) 
{ 

  {
#line 293
  pushGenericCommand(c, 1);
#line 294
  return;
}
}
#line 296 "t_list.c"
void pushxGenericCommand(redisClient *c , robj *refval , robj *val , int where ) 
{ robj *subject ;
  listTypeIterator *iter ;
  listTypeEntry entry ;
  int inserted ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  unsigned int __cil_tmp___2 ;
  unsigned long __cil_tmp___3 ;

  {
#line 300
  inserted = 0;
#line 302
  subject = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 302
  if ((unsigned int )subject == (unsigned int )((void *)0)) {
#line 303
    return;
  } else {
#line 302
    __cil_tmp = checkType(c, subject, 1);
#line 302
    if (__cil_tmp) {
#line 303
      return;
    }
  }
#line 305
  if ((unsigned int )refval != (unsigned int )((void *)0)) {
#line 308
    if (! (refval->encoding == 0U)) {
#line 308
      _redisAssert((char *)"refval->encoding == REDIS_ENCODING_RAW", (char *)"t_list.c",
                   308);
#line 308
      _exit(1);
    }
#line 315
    listTypeTryConversion(subject, val);
#line 318
    iter = listTypeInitIterator(subject, 0, (unsigned char)1);
#line 319
    while (1) {
#line 319
      __cil_tmp___1 = listTypeNext(iter, & entry);
#line 319
      if (! __cil_tmp___1) {
#line 319
        break;
      }
#line 320
      __cil_tmp___0 = listTypeEqual(& entry, refval);
#line 320
      if (__cil_tmp___0) {
#line 321
        listTypeInsert(& entry, val, where);
#line 322
        inserted = 1;
#line 323
        break;
      }
    }
#line 326
    listTypeReleaseIterator(iter);
#line 328
    if (inserted) {
#line 330
      if (subject->encoding == 5U) {
#line 330
        __cil_tmp___2 = ziplistLen((unsigned char *)subject->ptr);
#line 330
        if (__cil_tmp___2 > server.list_max_ziplist_entries) {
#line 332
          listTypeConvert(subject, 4);
        }
      }
#line 333
      touchWatchedKey(c->db, *(c->argv + 1));
#line 334
      (server.dirty) ++;
    } else {
#line 337
      addReply(c, shared.cnegone);
#line 338
      return;
    }
  } else {
#line 341
    listTypePush(subject, val, where);
#line 342
    touchWatchedKey(c->db, *(c->argv + 1));
#line 343
    (server.dirty) ++;
  }
#line 346
  __cil_tmp___3 = listTypeLength(subject);
#line 346
  addReplyLongLong(c, (long long )__cil_tmp___3);
#line 347
  return;
}
}
#line 349 "t_list.c"
void lpushxCommand(redisClient *c ) 
{ 

  {
#line 350
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 351
  pushxGenericCommand(c, (robj *)((void *)0), *(c->argv + 2), 0);
#line 352
  return;
}
}
#line 354 "t_list.c"
void rpushxCommand(redisClient *c ) 
{ 

  {
#line 355
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 356
  pushxGenericCommand(c, (robj *)((void *)0), *(c->argv + 2), 1);
#line 357
  return;
}
}
#line 359 "t_list.c"
void linsertCommand(redisClient *c ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 360
  *(c->argv + 4) = tryObjectEncoding(*(c->argv + 4));
#line 361
  __cil_tmp___0 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "after");
#line 361
  if (__cil_tmp___0 == 0) {
#line 362
    pushxGenericCommand(c, *(c->argv + 3), *(c->argv + 4), 1);
  } else {
#line 363
    __cil_tmp = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "before");
#line 363
    if (__cil_tmp == 0) {
#line 364
      pushxGenericCommand(c, *(c->argv + 3), *(c->argv + 4), 0);
    } else {
#line 366
      addReply(c, shared.syntaxerr);
    }
  }
#line 368
  return;
}
}
#line 370 "t_list.c"
void llenCommand(redisClient *c ) 
{ robj *o ;
  robj *__cil_tmp ;
  int __cil_tmp___0 ;
  unsigned long __cil_tmp___1 ;

  {
#line 371
  __cil_tmp = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 371
  o = __cil_tmp;
#line 372
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 372
    return;
  } else {
#line 372
    __cil_tmp___0 = checkType(c, o, 1);
#line 372
    if (__cil_tmp___0) {
#line 372
      return;
    }
  }
#line 373
  __cil_tmp___1 = listTypeLength(o);
#line 373
  addReplyLongLong(c, (long long )__cil_tmp___1);
#line 374
  return;
}
}
#line 376 "t_list.c"
void lindexCommand(redisClient *c ) 
{ robj *o ;
  robj *__cil_tmp ;
  int __cil_tmp___0 ;
  int index___0 ;
  int __cil_tmp___1 ;
  robj *value ;
  unsigned char *p ;
  unsigned char *vstr ;
  unsigned int vlen ;
  long long vlong ;
  unsigned int __cil_tmp___2 ;
  listNode *ln ;
  listNode *__cil_tmp___3 ;

  {
#line 377
  __cil_tmp = lookupKeyReadOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 377
  o = __cil_tmp;
#line 378
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 378
    return;
  } else {
#line 378
    __cil_tmp___0 = checkType(c, o, 1);
#line 378
    if (__cil_tmp___0) {
#line 378
      return;
    }
  }
#line 379
  __cil_tmp___1 = atoi((char const   *)(*(c->argv + 2))->ptr);
#line 379
  index___0 = __cil_tmp___1;
#line 380
  value = (robj *)((void *)0);
#line 382
  if (o->encoding == 5U) {
#line 387
    p = ziplistIndex((unsigned char *)o->ptr, index___0);
#line 388
    __cil_tmp___2 = ziplistGet(p, & vstr, & vlen, & vlong);
#line 388
    if (__cil_tmp___2) {
#line 389
      if (vstr) {
#line 390
        value = createStringObject((char *)vstr, vlen);
      } else {
#line 392
        value = createStringObjectFromLongLong(vlong);
      }
#line 394
      addReplyBulk(c, value);
#line 395
      decrRefCount((void *)value);
    } else {
#line 397
      addReply(c, shared.nullbulk);
    }
  } else
#line 399
  if (o->encoding == 4U) {
#line 400
    __cil_tmp___3 = listIndex((list *)o->ptr, index___0);
#line 400
    ln = __cil_tmp___3;
#line 401
    if ((unsigned int )ln != (unsigned int )((void *)0)) {
#line 402
      value = (robj *)ln->value;
#line 403
      addReplyBulk(c, value);
    } else {
#line 405
      addReply(c, shared.nullbulk);
    }
  } else {
#line 408
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 408);
#line 408
    _exit(1);
  }
#line 410
  return;
}
}
#line 412 "t_list.c"
void lsetCommand(redisClient *c ) 
{ robj *o ;
  robj *__cil_tmp ;
  int __cil_tmp___0 ;
  int index___0 ;
  int __cil_tmp___1 ;
  robj *value ;
  robj *__cil_tmp___2 ;
  unsigned char *p ;
  unsigned char *zl ;
  unsigned char *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  unsigned char *__cil_tmp___5 ;
  listNode *ln ;
  listNode *__cil_tmp___6 ;

  {
#line 413
  __cil_tmp = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.nokeyerr);
#line 413
  o = __cil_tmp;
#line 414
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 414
    return;
  } else {
#line 414
    __cil_tmp___0 = checkType(c, o, 1);
#line 414
    if (__cil_tmp___0) {
#line 414
      return;
    }
  }
#line 415
  __cil_tmp___1 = atoi((char const   *)(*(c->argv + 2))->ptr);
#line 415
  index___0 = __cil_tmp___1;
#line 416
  __cil_tmp___2 = tryObjectEncoding(*(c->argv + 3));
#line 416
  *(c->argv + 3) = __cil_tmp___2;
#line 416
  value = __cil_tmp___2;
#line 418
  listTypeTryConversion(o, value);
#line 419
  if (o->encoding == 5U) {
#line 420
    zl = (unsigned char *)o->ptr;
#line 421
    p = ziplistIndex(zl, index___0);
#line 422
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 423
      addReply(c, shared.outofrangeerr);
    } else {
#line 425
      __cil_tmp___3 = ziplistDelete((unsigned char *)o->ptr, & p);
#line 425
      o->ptr = (void *)__cil_tmp___3;
#line 426
      value = getDecodedObject(value);
#line 427
      __cil_tmp___4 = sdslen((char *)value->ptr);
#line 427
      __cil_tmp___5 = ziplistInsert((unsigned char *)o->ptr, p, (unsigned char *)value->ptr,
                                    __cil_tmp___4);
#line 427
      o->ptr = (void *)__cil_tmp___5;
#line 428
      decrRefCount((void *)value);
#line 429
      addReply(c, shared.ok);
#line 430
      touchWatchedKey(c->db, *(c->argv + 1));
#line 431
      (server.dirty) ++;
    }
  } else
#line 433
  if (o->encoding == 4U) {
#line 434
    __cil_tmp___6 = listIndex((list *)o->ptr, index___0);
#line 434
    ln = __cil_tmp___6;
#line 435
    if ((unsigned int )ln == (unsigned int )((void *)0)) {
#line 436
      addReply(c, shared.outofrangeerr);
    } else {
#line 438
      decrRefCount((void *)((robj *)ln->value));
#line 439
      ln->value = (void *)value;
#line 440
      incrRefCount(value);
#line 441
      addReply(c, shared.ok);
#line 442
      touchWatchedKey(c->db, *(c->argv + 1));
#line 443
      (server.dirty) ++;
    }
  } else {
#line 446
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 446);
#line 446
    _exit(1);
  }
#line 448
  return;
}
}
#line 450 "t_list.c"
void popGenericCommand(redisClient *c , int where ) 
{ robj *o ;
  robj *__cil_tmp ;
  int __cil_tmp___0 ;
  robj *value ;
  robj *__cil_tmp___1 ;
  unsigned long __cil_tmp___2 ;

  {
#line 451
  __cil_tmp = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 451
  o = __cil_tmp;
#line 452
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 452
    return;
  } else {
#line 452
    __cil_tmp___0 = checkType(c, o, 1);
#line 452
    if (__cil_tmp___0) {
#line 452
      return;
    }
  }
#line 454
  __cil_tmp___1 = listTypePop(o, where);
#line 454
  value = __cil_tmp___1;
#line 455
  if ((unsigned int )value == (unsigned int )((void *)0)) {
#line 456
    addReply(c, shared.nullbulk);
  } else {
#line 458
    addReplyBulk(c, value);
#line 459
    decrRefCount((void *)value);
#line 460
    __cil_tmp___2 = listTypeLength(o);
#line 460
    if (__cil_tmp___2 == 0UL) {
#line 460
      dbDelete(c->db, *(c->argv + 1));
    }
#line 461
    touchWatchedKey(c->db, *(c->argv + 1));
#line 462
    (server.dirty) ++;
  }
#line 464
  return;
}
}
#line 466 "t_list.c"
void lpopCommand(redisClient *c ) 
{ 

  {
#line 467
  popGenericCommand(c, 0);
#line 468
  return;
}
}
#line 470 "t_list.c"
void rpopCommand(redisClient *c ) 
{ 

  {
#line 471
  popGenericCommand(c, 1);
#line 472
  return;
}
}
#line 474 "t_list.c"
void lrangeCommand(redisClient *c ) 
{ robj *o ;
  int start ;
  int __cil_tmp ;
  int end ;
  int __cil_tmp___0 ;
  int llen ;
  int rangelen ;
  int __cil_tmp___1 ;
  unsigned long __cil_tmp___2 ;
  unsigned char *p ;
  unsigned char *__cil_tmp___3 ;
  unsigned char *vstr ;
  unsigned int vlen ;
  long long vlong ;
  int __cil_tmp___4 ;
  listNode *ln ;
  listNode *__cil_tmp___5 ;
  int __cil_tmp___6 ;

  {
#line 476
  __cil_tmp = atoi((char const   *)(*(c->argv + 2))->ptr);
#line 476
  start = __cil_tmp;
#line 477
  __cil_tmp___0 = atoi((char const   *)(*(c->argv + 3))->ptr);
#line 477
  end = __cil_tmp___0;
#line 481
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.emptymultibulk);
#line 481
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 482
    return;
  } else {
#line 481
    __cil_tmp___1 = checkType(c, o, 1);
#line 481
    if (__cil_tmp___1) {
#line 482
      return;
    }
  }
#line 483
  __cil_tmp___2 = listTypeLength(o);
#line 483
  llen = (int )__cil_tmp___2;
#line 486
  if (start < 0) {
#line 486
    start = llen + start;
  }
#line 487
  if (end < 0) {
#line 487
    end = llen + end;
  }
#line 488
  if (start < 0) {
#line 488
    start = 0;
  }
#line 492
  if (start > end || start >= llen) {
#line 493
    addReply(c, shared.emptymultibulk);
#line 494
    return;
  }
#line 496
  if (end >= llen) {
#line 496
    end = llen - 1;
  }
#line 497
  rangelen = (end - start) + 1;
#line 500
  addReplyMultiBulkLen(c, (long )rangelen);
#line 501
  if (o->encoding == 5U) {
#line 502
    __cil_tmp___3 = ziplistIndex((unsigned char *)o->ptr, start);
#line 502
    p = __cil_tmp___3;
#line 507
    while (1) {
#line 507
      __cil_tmp___4 = rangelen;
#line 507
      rangelen --;
#line 507
      if (! __cil_tmp___4) {
#line 507
        break;
      }
#line 508
      ziplistGet(p, & vstr, & vlen, & vlong);
#line 509
      if (vstr) {
#line 510
        addReplyBulkCBuffer(c, (void *)vstr, vlen);
      } else {
#line 512
        addReplyBulkLongLong(c, vlong);
      }
#line 514
      p = ziplistNext((unsigned char *)o->ptr, p);
    }
  } else
#line 516
  if (o->encoding == 4U) {
#line 517
    __cil_tmp___5 = listIndex((list *)o->ptr, start);
#line 517
    ln = __cil_tmp___5;
#line 519
    while (1) {
#line 519
      __cil_tmp___6 = rangelen;
#line 519
      rangelen --;
#line 519
      if (! __cil_tmp___6) {
#line 519
        break;
      }
#line 520
      addReplyBulk(c, (robj *)ln->value);
#line 521
      ln = ln->next;
    }
  } else {
#line 524
    _redisPanic((char *)"\"List encoding is not LINKEDLIST nor ZIPLIST!\"", (char *)"t_list.c",
                524);
#line 524
    _exit(1);
  }
#line 526
  return;
}
}
#line 528 "t_list.c"
void ltrimCommand(redisClient *c ) 
{ robj *o ;
  int start ;
  int __cil_tmp ;
  int end ;
  int __cil_tmp___0 ;
  int llen ;
  int j ;
  int ltrim ;
  int rtrim ;
  list *list___0 ;
  listNode *ln ;
  int __cil_tmp___1 ;
  unsigned long __cil_tmp___2 ;
  unsigned char *__cil_tmp___3 ;
  unsigned char *__cil_tmp___4 ;
  unsigned long __cil_tmp___5 ;

  {
#line 530
  __cil_tmp = atoi((char const   *)(*(c->argv + 2))->ptr);
#line 530
  start = __cil_tmp;
#line 531
  __cil_tmp___0 = atoi((char const   *)(*(c->argv + 3))->ptr);
#line 531
  end = __cil_tmp___0;
#line 537
  o = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.ok);
#line 537
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 538
    return;
  } else {
#line 537
    __cil_tmp___1 = checkType(c, o, 1);
#line 537
    if (__cil_tmp___1) {
#line 538
      return;
    }
  }
#line 539
  __cil_tmp___2 = listTypeLength(o);
#line 539
  llen = (int )__cil_tmp___2;
#line 542
  if (start < 0) {
#line 542
    start = llen + start;
  }
#line 543
  if (end < 0) {
#line 543
    end = llen + end;
  }
#line 544
  if (start < 0) {
#line 544
    start = 0;
  }
#line 548
  if (start > end || start >= llen) {
#line 550
    ltrim = llen;
#line 551
    rtrim = 0;
  } else {
#line 553
    if (end >= llen) {
#line 553
      end = llen - 1;
    }
#line 554
    ltrim = start;
#line 555
    rtrim = (llen - end) - 1;
  }
#line 559
  if (o->encoding == 5U) {
#line 560
    __cil_tmp___3 = ziplistDeleteRange((unsigned char *)o->ptr, 0U, (unsigned int )ltrim);
#line 560
    o->ptr = (void *)__cil_tmp___3;
#line 561
    __cil_tmp___4 = ziplistDeleteRange((unsigned char *)o->ptr, (unsigned int )(- rtrim),
                                       (unsigned int )rtrim);
#line 561
    o->ptr = (void *)__cil_tmp___4;
  } else
#line 562
  if (o->encoding == 4U) {
#line 563
    list___0 = (list *)o->ptr;
#line 564
    j = 0;
#line 564
    while (j < ltrim) {
#line 565
      ln = list___0->head;
#line 566
      listDelNode(list___0, ln);
#line 564
      j ++;
    }
#line 568
    j = 0;
#line 568
    while (j < rtrim) {
#line 569
      ln = list___0->tail;
#line 570
      listDelNode(list___0, ln);
#line 568
      j ++;
    }
  } else {
#line 573
    _redisPanic((char *)"\"Unknown list encoding\"", (char *)"t_list.c", 573);
#line 573
    _exit(1);
  }
#line 575
  __cil_tmp___5 = listTypeLength(o);
#line 575
  if (__cil_tmp___5 == 0UL) {
#line 575
    dbDelete(c->db, *(c->argv + 1));
  }
#line 576
  touchWatchedKey(c->db, *(c->argv + 1));
#line 577
  (server.dirty) ++;
#line 578
  addReply(c, shared.ok);
#line 579
  return;
}
}
#line 581 "t_list.c"
void lremCommand(redisClient *c ) 
{ robj *subject ;
  robj *obj ;
  robj *__cil_tmp ;
  int toremove ;
  int __cil_tmp___0 ;
  int removed ;
  listTypeEntry entry ;
  int __cil_tmp___1 ;
  listTypeIterator *li ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  unsigned long __cil_tmp___4 ;

  {
#line 583
  __cil_tmp = tryObjectEncoding(*(c->argv + 3));
#line 583
  *(c->argv + 3) = __cil_tmp;
#line 583
  obj = __cil_tmp;
#line 584
  __cil_tmp___0 = atoi((char const   *)(*(c->argv + 2))->ptr);
#line 584
  toremove = __cil_tmp___0;
#line 585
  removed = 0;
#line 588
  subject = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.czero);
#line 589
  if ((unsigned int )subject == (unsigned int )((void *)0)) {
#line 589
    return;
  } else {
#line 589
    __cil_tmp___1 = checkType(c, subject, 1);
#line 589
    if (__cil_tmp___1) {
#line 589
      return;
    }
  }
#line 592
  if (subject->encoding == 5U) {
#line 593
    obj = getDecodedObject(obj);
  }
#line 596
  if (toremove < 0) {
#line 597
    toremove = - toremove;
#line 598
    li = listTypeInitIterator(subject, -1, (unsigned char)0);
  } else {
#line 600
    li = listTypeInitIterator(subject, 0, (unsigned char)1);
  }
#line 603
  while (1) {
#line 603
    __cil_tmp___3 = listTypeNext(li, & entry);
#line 603
    if (! __cil_tmp___3) {
#line 603
      break;
    }
#line 604
    __cil_tmp___2 = listTypeEqual(& entry, obj);
#line 604
    if (__cil_tmp___2) {
#line 605
      listTypeDelete(& entry);
#line 606
      (server.dirty) ++;
#line 607
      removed ++;
#line 608
      if (toremove && removed == toremove) {
#line 608
        break;
      }
    }
  }
#line 611
  listTypeReleaseIterator(li);
#line 614
  if (subject->encoding == 5U) {
#line 615
    decrRefCount((void *)obj);
  }
#line 617
  __cil_tmp___4 = listTypeLength(subject);
#line 617
  if (__cil_tmp___4 == 0UL) {
#line 617
    dbDelete(c->db, *(c->argv + 1));
  }
#line 618
  addReplyLongLong(c, (long long )removed);
#line 619
  if (removed) {
#line 619
    touchWatchedKey(c->db, *(c->argv + 1));
  }
#line 620
  return;
}
}
#line 638 "t_list.c"
void rpoplpushHandlePush(redisClient *c , robj *dstkey , robj *dstobj , robj *value ) 
{ int __cil_tmp ;

  {
#line 639
  __cil_tmp = handleClientsWaitingListPush(c, dstkey, value);
#line 639
  if (! __cil_tmp) {
#line 641
    if (! dstobj) {
#line 642
      dstobj = createZiplistObject();
#line 643
      dbAdd(c->db, dstkey, dstobj);
    } else {
#line 645
      touchWatchedKey(c->db, dstkey);
#line 646
      (server.dirty) ++;
    }
#line 648
    listTypePush(dstobj, value, 0);
  }
#line 652
  addReplyBulk(c, value);
#line 653
  return;
}
}
#line 655 "t_list.c"
void rpoplpushCommand(redisClient *c ) 
{ robj *sobj ;
  robj *value ;
  int __cil_tmp ;
  robj *dobj ;
  robj *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  unsigned long __cil_tmp___2 ;
  unsigned long __cil_tmp___3 ;

  {
#line 657
  sobj = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 657
  if ((unsigned int )sobj == (unsigned int )((void *)0)) {
#line 658
    return;
  } else {
#line 657
    __cil_tmp = checkType(c, sobj, 1);
#line 657
    if (__cil_tmp) {
#line 658
      return;
    }
  }
#line 660
  __cil_tmp___3 = listTypeLength(sobj);
#line 660
  if (__cil_tmp___3 == 0UL) {
#line 661
    addReply(c, shared.nullbulk);
  } else {
#line 663
    __cil_tmp___0 = lookupKeyWrite(c->db, *(c->argv + 2));
#line 663
    dobj = __cil_tmp___0;
#line 664
    if (dobj) {
#line 664
      __cil_tmp___1 = checkType(c, dobj, 1);
#line 664
      if (__cil_tmp___1) {
#line 664
        return;
      }
    }
#line 665
    value = listTypePop(sobj, 1);
#line 666
    rpoplpushHandlePush(c, *(c->argv + 2), dobj, value);
#line 669
    decrRefCount((void *)value);
#line 672
    __cil_tmp___2 = listTypeLength(sobj);
#line 672
    if (__cil_tmp___2 == 0UL) {
#line 672
      dbDelete(c->db, *(c->argv + 1));
    }
#line 673
    touchWatchedKey(c->db, *(c->argv + 1));
#line 674
    (server.dirty) ++;
  }
#line 676
  return;
}
}
#line 713 "t_list.c"
void blockForKeys(redisClient *c , robj **keys , int numkeys , time_t timeout , robj *target ) 
{ dictEntry *de ;
  list *l ;
  int j ;
  void *__cil_tmp ;
  int retval ;

  {
#line 718
  __cil_tmp = malloc((unsigned int )(sizeof(robj *) * (unsigned long )numkeys));
#line 718
  c->bpop.keys = (robj **)__cil_tmp;
#line 719
  c->bpop.count = numkeys;
#line 720
  c->bpop.timeout = timeout;
#line 721
  c->bpop.target = target;
#line 723
  if ((unsigned int )target != (unsigned int )((void *)0)) {
#line 724
    incrRefCount(target);
  }
#line 727
  j = 0;
#line 727
  while (j < numkeys) {
#line 729
    *(c->bpop.keys + j) = *(keys + j);
#line 730
    incrRefCount(*(keys + j));
#line 733
    de = dictFind((c->db)->blocking_keys, (void const   *)*(keys + j));
#line 734
    if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 738
      l = listCreate();
#line 739
      retval = dictAdd((c->db)->blocking_keys, (void *)*(keys + j), (void *)l);
#line 740
      incrRefCount(*(keys + j));
#line 741
      if (! (retval == 0)) {
#line 741
        _redisAssert((char *)"retval == DICT_OK", (char *)"t_list.c", 741);
#line 741
        _exit(1);
      }
    } else {
#line 743
      l = (list *)de->val;
    }
#line 745
    listAddNodeTail(l, (void *)c);
#line 727
    j ++;
  }
#line 748
  c->flags |= 16;
#line 749
  (server.bpop_blocked_clients) ++;
#line 750
  return;
}
}
#line 753 "t_list.c"
void unblockClientWaitingData(redisClient *c ) 
{ dictEntry *de ;
  list *l ;
  int j ;
  listNode *__cil_tmp ;

  {
#line 758
  if (! ((unsigned int )c->bpop.keys != (unsigned int )((void *)0))) {
#line 758
    _redisAssert((char *)"c->bpop.keys != NULL", (char *)"t_list.c", 758);
#line 758
    _exit(1);
  }
#line 760
  j = 0;
#line 760
  while (j < c->bpop.count) {
#line 762
    de = dictFind((c->db)->blocking_keys, (void const   *)*(c->bpop.keys + j));
#line 763
    if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 763
      _redisAssert((char *)"de != NULL", (char *)"t_list.c", 763);
#line 763
      _exit(1);
    }
#line 764
    l = (list *)de->val;
#line 765
    __cil_tmp = listSearchKey(l, (void *)c);
#line 765
    listDelNode(l, __cil_tmp);
#line 767
    if (l->len == 0U) {
#line 768
      dictDelete((c->db)->blocking_keys, (void const   *)*(c->bpop.keys + j));
    }
#line 769
    decrRefCount((void *)*(c->bpop.keys + j));
#line 760
    j ++;
  }
#line 773
  free((void *)c->bpop.keys);
#line 774
  c->bpop.keys = (robj **)((void *)0);
#line 775
  c->bpop.target = (robj *)((void *)0);
#line 776
  c->flags &= -17;
#line 777
  c->flags |= 256;
#line 778
  (server.bpop_blocked_clients) --;
#line 779
  listAddNodeTail(server.unblocked_clients, (void *)c);
#line 780
  return;
}
}
#line 792 "t_list.c"
int handleClientsWaitingListPush(redisClient *c , robj *key , robj *ele ) 
{ struct dictEntry *de ;
  redisClient *receiver ;
  int numclients ;
  list *clients ;
  listNode *ln ;
  robj *dstkey ;
  robj *dstobj ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 800
  de = dictFind((c->db)->blocking_keys, (void const   *)key);
#line 801
  if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 801
    return (0);
  }
#line 802
  clients = (list *)de->val;
#line 803
  numclients = (int )clients->len;
#line 812
  while (1) {
#line 812
    __cil_tmp___0 = numclients;
#line 812
    numclients --;
#line 812
    if (! __cil_tmp___0) {
#line 812
      break;
    }
#line 813
    ln = clients->head;
#line 814
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 814
      _redisAssert((char *)"ln != NULL", (char *)"t_list.c", 814);
#line 814
      _exit(1);
    }
#line 815
    receiver = (redisClient *)ln->value;
#line 816
    dstkey = receiver->bpop.target;
#line 819
    unblockClientWaitingData(receiver);
#line 820
    if (! ((unsigned int )ln != (unsigned int )clients->head)) {
#line 820
      _redisAssert((char *)"ln != listFirst(clients)", (char *)"t_list.c", 820);
#line 820
      _exit(1);
    }
#line 822
    if ((unsigned int )dstkey == (unsigned int )((void *)0)) {
#line 824
      addReplyMultiBulkLen(receiver, 2L);
#line 825
      addReplyBulk(receiver, key);
#line 826
      addReplyBulk(receiver, ele);
#line 827
      return (1);
    } else {
#line 830
      dstobj = lookupKeyWrite(receiver->db, dstkey);
#line 831
      if (dstobj) {
#line 831
        __cil_tmp = checkType(receiver, dstobj, 1);
#line 831
        if (__cil_tmp) {
#line 832
          decrRefCount((void *)dstkey);
        } else {
#line 834
          rpoplpushHandlePush(receiver, dstkey, dstobj, ele);
#line 835
          decrRefCount((void *)dstkey);
#line 836
          return (1);
        }
      } else {
#line 834
        rpoplpushHandlePush(receiver, dstkey, dstobj, ele);
#line 835
        decrRefCount((void *)dstkey);
#line 836
        return (1);
      }
    }
  }
#line 841
  return (0);
}
}
#line 844 "t_list.c"
int getTimeoutFromObjectOrReply(redisClient *c , robj *object , time_t *timeout ) 
{ long tval ;
  int __cil_tmp ;
  time_t __cil_tmp___0 ;

  {
#line 847
  __cil_tmp = getLongFromObjectOrReply(c, object, & tval, "timeout is not an integer or out of range");
#line 847
  if (__cil_tmp != 0) {
#line 849
    return (-1);
  }
#line 851
  if (tval < 0L) {
#line 852
    addReplyError(c, (char *)"timeout is negative");
#line 853
    return (-1);
  }
#line 856
  if (tval > 0L) {
#line 856
    __cil_tmp___0 = time((time_t *)((void *)0));
#line 856
    tval += __cil_tmp___0;
  }
#line 857
  *timeout = tval;
#line 859
  return (0);
}
}
#line 863 "t_list.c"
void blockingPopGenericCommand(redisClient *c , int where ) 
{ robj *o ;
  time_t timeout ;
  int j ;
  int __cil_tmp ;
  robj *argv[2] ;
  robj **orig_argv ;
  int orig_argc ;
  unsigned long __cil_tmp___0 ;

  {
#line 868
  __cil_tmp = getTimeoutFromObjectOrReply(c, *(c->argv + (c->argc - 1)), & timeout);
#line 868
  if (__cil_tmp != 0) {
#line 869
    return;
  }
#line 871
  j = 1;
#line 871
  while (j < c->argc - 1) {
#line 872
    o = lookupKeyWrite(c->db, *(c->argv + j));
#line 873
    if ((unsigned int )o != (unsigned int )((void *)0)) {
#line 874
      if (o->type != 1U) {
#line 875
        addReply(c, shared.wrongtypeerr);
#line 876
        return;
      } else {
#line 878
        __cil_tmp___0 = listTypeLength(o);
#line 878
        if (__cil_tmp___0 != 0UL) {
#line 886
          orig_argv = c->argv;
#line 887
          orig_argc = c->argc;
#line 888
          argv[1] = *(c->argv + j);
#line 889
          c->argv = argv;
#line 890
          c->argc = 2;
#line 897
          addReplyMultiBulkLen(c, 2L);
#line 898
          addReplyBulk(c, argv[1]);
#line 900
          popGenericCommand(c, where);
#line 903
          c->argv = orig_argv;
#line 904
          c->argc = orig_argc;
#line 906
          return;
        }
      }
    }
#line 871
    j ++;
  }
#line 914
  if (c->flags & 8) {
#line 915
    addReply(c, shared.nullmultibulk);
#line 916
    return;
  }
#line 920
  blockForKeys(c, c->argv + 1, c->argc - 2, timeout, (robj *)((void *)0));
#line 921
  return;
}
}
#line 923 "t_list.c"
void blpopCommand(redisClient *c ) 
{ 

  {
#line 924
  blockingPopGenericCommand(c, 0);
#line 925
  return;
}
}
#line 927 "t_list.c"
void brpopCommand(redisClient *c ) 
{ 

  {
#line 928
  blockingPopGenericCommand(c, 1);
#line 929
  return;
}
}
#line 931 "t_list.c"
void brpoplpushCommand(redisClient *c ) 
{ time_t timeout ;
  int __cil_tmp ;
  robj *key ;
  robj *__cil_tmp___0 ;
  unsigned long __cil_tmp___1 ;

  {
#line 934
  __cil_tmp = getTimeoutFromObjectOrReply(c, *(c->argv + 3), & timeout);
#line 934
  if (__cil_tmp != 0) {
#line 935
    return;
  }
#line 937
  __cil_tmp___0 = lookupKeyWrite(c->db, *(c->argv + 1));
#line 937
  key = __cil_tmp___0;
#line 939
  if ((unsigned int )key == (unsigned int )((void *)0)) {
#line 940
    if (c->flags & 8) {
#line 944
      addReply(c, shared.nullmultibulk);
    } else {
#line 947
      blockForKeys(c, c->argv + 1, 1, timeout, *(c->argv + 2));
    }
  } else
#line 950
  if (key->type != 1U) {
#line 951
    addReply(c, shared.wrongtypeerr);
  } else {
#line 956
    __cil_tmp___1 = listTypeLength(key);
#line 956
    if (! (__cil_tmp___1 > 0UL)) {
#line 956
      _redisAssert((char *)"listTypeLength(key) > 0", (char *)"t_list.c", 956);
#line 956
      _exit(1);
    }
#line 957
    rpoplpushCommand(c);
  }
#line 960
  return;
}
}
#line 1 "t_set.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-q4QbOEAt.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 119 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
void qsort(void *a , size_t n , size_t es , int (*cmp)(void const   * , void const   * ) ) ;
#line 13 "intset.h"
intset *intsetRemove(intset *is , int64_t value , int *success ) ;
#line 14
uint8_t intsetFind(intset *is , int64_t value ) ;
#line 15
int64_t intsetRandom(intset *is ) ;
#line 820 "redis.h"
robj *setTypeCreate(robj *value ) ;
#line 821
int setTypeAdd(robj *subject , robj *value ) ;
#line 822
int setTypeRemove(robj *setobj , robj *value ) ;
#line 823
int setTypeIsMember(robj *subject , robj *value ) ;
#line 824
setTypeIterator *setTypeInitIterator(robj *subject ) ;
#line 825
void setTypeReleaseIterator(setTypeIterator *si ) ;
#line 826
int setTypeNext(setTypeIterator *si , robj **objele , int64_t *llele ) ;
#line 827
robj *setTypeNextObject(setTypeIterator *si ) ;
#line 828
int setTypeRandomElement(robj *setobj , robj **objele , int64_t *llele ) ;
#line 829
unsigned long setTypeSize(robj *subject ) ;
#line 10 "t_set.c"
robj *setTypeCreate(robj *value ) 
{ robj *__cil_tmp ;
  int __cil_tmp___0 ;
  robj *__cil_tmp___1 ;

  {
#line 11
  __cil_tmp___0 = isObjectRepresentableAsLongLong(value, (long long *)((void *)0));
#line 11
  if (__cil_tmp___0 == 0) {
#line 12
    __cil_tmp = createIntsetObject();
#line 12
    return (__cil_tmp);
  }
#line 13
  __cil_tmp___1 = createSetObject();
#line 13
  return (__cil_tmp___1);
}
}
#line 16 "t_set.c"
int setTypeAdd(robj *subject , robj *value ) 
{ long long llval ;
  int __cil_tmp ;
  uint8_t success ;
  intset *__cil_tmp___0 ;
  uint32_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 18
  if (subject->encoding == 2U) {
#line 19
    __cil_tmp = dictAdd((dict *)subject->ptr, (void *)value, (void *)0);
#line 19
    if (__cil_tmp == 0) {
#line 20
      incrRefCount(value);
#line 21
      return (1);
    }
  } else
#line 23
  if (subject->encoding == 6U) {
#line 24
    __cil_tmp___3 = isObjectRepresentableAsLongLong(value, & llval);
#line 24
    if (__cil_tmp___3 == 0) {
#line 25
      success = (unsigned char)0;
#line 26
      __cil_tmp___0 = intsetAdd((intset *)subject->ptr, llval, & success);
#line 26
      subject->ptr = (void *)__cil_tmp___0;
#line 27
      if (success) {
#line 30
        __cil_tmp___1 = intsetLen((intset *)subject->ptr);
#line 30
        if (__cil_tmp___1 > (unsigned long )server.set_max_intset_entries) {
#line 31
          setTypeConvert(subject, 2);
        }
#line 32
        return (1);
      }
    } else {
#line 36
      setTypeConvert(subject, 2);
#line 40
      __cil_tmp___2 = dictAdd((dict *)subject->ptr, (void *)value, (void *)0);
#line 40
      if (! (__cil_tmp___2 == 0)) {
#line 40
        _redisAssert((char *)"dictAdd(subject->ptr,value,NULL) == DICT_OK", (char *)"t_set.c",
                     40);
#line 40
        _exit(1);
      }
#line 41
      incrRefCount(value);
#line 42
      return (1);
    }
  } else {
#line 45
    _redisPanic((char *)"\"Unknown set encoding\"", (char *)"t_set.c", 45);
#line 45
    _exit(1);
  }
#line 47
  return (0);
}
}
#line 50 "t_set.c"
int setTypeRemove(robj *setobj , robj *value ) 
{ long long llval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int success ;
  intset *__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 52
  if (setobj->encoding == 2U) {
#line 53
    __cil_tmp___0 = dictDelete((dict *)setobj->ptr, (void const   *)value);
#line 53
    if (__cil_tmp___0 == 0) {
#line 54
      __cil_tmp = htNeedsResize((dict *)setobj->ptr);
#line 54
      if (__cil_tmp) {
#line 54
        dictResize((dict *)setobj->ptr);
      }
#line 55
      return (1);
    }
  } else
#line 57
  if (setobj->encoding == 6U) {
#line 58
    __cil_tmp___2 = isObjectRepresentableAsLongLong(value, & llval);
#line 58
    if (__cil_tmp___2 == 0) {
#line 60
      __cil_tmp___1 = intsetRemove((intset *)setobj->ptr, llval, & success);
#line 60
      setobj->ptr = (void *)__cil_tmp___1;
#line 61
      if (success) {
#line 61
        return (1);
      }
    }
  } else {
#line 64
    _redisPanic((char *)"\"Unknown set encoding\"", (char *)"t_set.c", 64);
#line 64
    _exit(1);
  }
#line 66
  return (0);
}
}
#line 69 "t_set.c"
int setTypeIsMember(robj *subject , robj *value ) 
{ long long llval ;
  dictEntry *__cil_tmp ;
  uint8_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 71
  if (subject->encoding == 2U) {
#line 72
    __cil_tmp = dictFind((dict *)subject->ptr, (void const   *)value);
#line 72
    return ((unsigned int )__cil_tmp != (unsigned int )((void *)0));
  } else
#line 73
  if (subject->encoding == 6U) {
#line 74
    __cil_tmp___1 = isObjectRepresentableAsLongLong(value, & llval);
#line 74
    if (__cil_tmp___1 == 0) {
#line 75
      __cil_tmp___0 = intsetFind((intset *)subject->ptr, llval);
#line 75
      return ((int )__cil_tmp___0);
    }
  } else {
#line 78
    _redisPanic((char *)"\"Unknown set encoding\"", (char *)"t_set.c", 78);
#line 78
    _exit(1);
  }
#line 80
  return (0);
}
}
#line 83 "t_set.c"
setTypeIterator *setTypeInitIterator(robj *subject ) 
{ setTypeIterator *si ;
  void *__cil_tmp ;

  {
#line 84
  __cil_tmp = malloc((unsigned int )sizeof(setTypeIterator ));
#line 84
  si = (setTypeIterator *)__cil_tmp;
#line 85
  si->subject = subject;
#line 86
  si->encoding = (int )subject->encoding;
#line 87
  if (si->encoding == 2) {
#line 88
    si->di = dictGetIterator((dict *)subject->ptr);
  } else
#line 89
  if (si->encoding == 6) {
#line 90
    si->ii = 0;
  } else {
#line 92
    _redisPanic((char *)"\"Unknown set encoding\"", (char *)"t_set.c", 92);
#line 92
    _exit(1);
  }
#line 94
  return (si);
}
}
#line 97 "t_set.c"
void setTypeReleaseIterator(setTypeIterator *si ) 
{ 

  {
#line 98
  if (si->encoding == 2) {
#line 99
    dictReleaseIterator(si->di);
  }
#line 100
  free((void *)si);
#line 101
  return;
}
}
#line 114 "t_set.c"
int setTypeNext(setTypeIterator *si , robj **objele , int64_t *llele ) 
{ dictEntry *de ;
  dictEntry *__cil_tmp ;
  int __cil_tmp___0 ;
  uint8_t __cil_tmp___1 ;

  {
#line 115
  if (si->encoding == 2) {
#line 116
    __cil_tmp = dictNext(si->di);
#line 116
    de = __cil_tmp;
#line 117
    if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 117
      return (-1);
    }
#line 118
    *objele = (robj *)de->key;
  } else
#line 119
  if (si->encoding == 6) {
#line 120
    __cil_tmp___0 = si->ii;
#line 120
    (si->ii) ++;
#line 120
    __cil_tmp___1 = intsetGet((intset *)(si->subject)->ptr, (unsigned long )__cil_tmp___0,
                              llele);
#line 120
    if (! __cil_tmp___1) {
#line 121
      return (-1);
    }
  }
#line 123
  return (si->encoding);
}
}
#line 133 "t_set.c"
robj *setTypeNextObject(setTypeIterator *si ) 
{ int64_t intele ;
  robj *objele ;
  int encoding ;
  robj *__cil_tmp ;

  {
#line 138
  encoding = setTypeNext(si, & objele, & intele);
#line 139
  switch (encoding) {
  case -1: 
#line 140
  return ((robj *)((void *)0));
  case 6: 
#line 142
  __cil_tmp = createStringObjectFromLongLong(intele);
#line 142
  return (__cil_tmp);
  case 2: 
#line 144
  incrRefCount(objele);
#line 145
  return (objele);
  default: 
#line 147
  _redisPanic((char *)"\"Unsupported encoding\"", (char *)"t_set.c", 147);
#line 147
  _exit(1);
  }
#line 149
  return ((robj *)((void *)0));
}
}
#line 165 "t_set.c"
int setTypeRandomElement(robj *setobj , robj **objele , int64_t *llele ) 
{ dictEntry *de ;
  dictEntry *__cil_tmp ;

  {
#line 166
  if (setobj->encoding == 2U) {
#line 167
    __cil_tmp = dictGetRandomKey((dict *)setobj->ptr);
#line 167
    de = __cil_tmp;
#line 168
    *objele = (robj *)de->key;
  } else
#line 169
  if (setobj->encoding == 6U) {
#line 170
    *llele = intsetRandom((intset *)setobj->ptr);
  } else {
#line 172
    _redisPanic((char *)"\"Unknown set encoding\"", (char *)"t_set.c", 172);
#line 172
    _exit(1);
  }
#line 174
  return ((int )setobj->encoding);
}
}
#line 177 "t_set.c"
unsigned long setTypeSize(robj *subject ) 
{ uint32_t __cil_tmp ;

  {
#line 178
  if (subject->encoding == 2U) {
#line 179
    return (((dict *)subject->ptr)->ht[0].used + ((dict *)subject->ptr)->ht[1].used);
  } else
#line 180
  if (subject->encoding == 6U) {
#line 181
    __cil_tmp = intsetLen((intset *)subject->ptr);
#line 181
    return (__cil_tmp);
  } else {
#line 183
    _redisPanic((char *)"\"Unknown set encoding\"", (char *)"t_set.c", 183);
#line 183
    _exit(1);
  }
}
}
#line 190 "t_set.c"
void setTypeConvert(robj *setobj , int enc ) 
{ setTypeIterator *si ;
  int64_t intele ;
  dict *d ;
  dict *__cil_tmp ;
  robj *element ;
  uint32_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 192
  if (! (setobj->type == 2U && setobj->encoding == 6U)) {
#line 192
    _redisAssert((char *)"setobj->type == REDIS_SET && setobj->encoding == REDIS_ENCODING_INTSET",
                 (char *)"t_set.c", 193);
#line 192
    _exit(1);
  }
#line 195
  if (enc == 2) {
#line 197
    __cil_tmp = dictCreate(& setDictType, (void *)0);
#line 197
    d = __cil_tmp;
#line 201
    __cil_tmp___0 = intsetLen((intset *)setobj->ptr);
#line 201
    dictExpand(d, __cil_tmp___0);
#line 204
    si = setTypeInitIterator(setobj);
#line 205
    while (1) {
#line 205
      __cil_tmp___2 = setTypeNext(si, (robj **)((void *)0), & intele);
#line 205
      if (! (__cil_tmp___2 != -1)) {
#line 205
        break;
      }
#line 206
      element = createStringObjectFromLongLong(intele);
#line 207
      __cil_tmp___1 = dictAdd(d, (void *)element, (void *)0);
#line 207
      if (! (__cil_tmp___1 == 0)) {
#line 207
        _redisAssert((char *)"dictAdd(d,element,NULL) == DICT_OK", (char *)"t_set.c",
                     207);
#line 207
        _exit(1);
      }
    }
#line 209
    setTypeReleaseIterator(si);
#line 211
    setobj->encoding = 2U;
#line 212
    free(setobj->ptr);
#line 213
    setobj->ptr = (void *)d;
  } else {
#line 215
    _redisPanic((char *)"\"Unsupported set conversion\"", (char *)"t_set.c", 215);
#line 215
    _exit(1);
  }
#line 217
  return;
}
}
#line 219 "t_set.c"
void saddCommand(redisClient *c ) 
{ robj *set ;
  int __cil_tmp ;

  {
#line 222
  set = lookupKeyWrite(c->db, *(c->argv + 1));
#line 223
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 224
  if ((unsigned int )set == (unsigned int )((void *)0)) {
#line 225
    set = setTypeCreate(*(c->argv + 2));
#line 226
    dbAdd(c->db, *(c->argv + 1), set);
  } else
#line 228
  if (set->type != 2U) {
#line 229
    addReply(c, shared.wrongtypeerr);
#line 230
    return;
  }
#line 233
  __cil_tmp = setTypeAdd(set, *(c->argv + 2));
#line 233
  if (__cil_tmp) {
#line 234
    touchWatchedKey(c->db, *(c->argv + 1));
#line 235
    (server.dirty) ++;
#line 236
    addReply(c, shared.cone);
  } else {
#line 238
    addReply(c, shared.czero);
  }
#line 240
  return;
}
}
#line 242 "t_set.c"
void sremCommand(redisClient *c ) 
{ robj *set ;
  int __cil_tmp ;
  unsigned long __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 245
  set = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.czero);
#line 245
  if ((unsigned int )set == (unsigned int )((void *)0)) {
#line 246
    return;
  } else {
#line 245
    __cil_tmp = checkType(c, set, 2);
#line 245
    if (__cil_tmp) {
#line 246
      return;
    }
  }
#line 248
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 249
  __cil_tmp___1 = setTypeRemove(set, *(c->argv + 2));
#line 249
  if (__cil_tmp___1) {
#line 250
    __cil_tmp___0 = setTypeSize(set);
#line 250
    if (__cil_tmp___0 == 0UL) {
#line 250
      dbDelete(c->db, *(c->argv + 1));
    }
#line 251
    touchWatchedKey(c->db, *(c->argv + 1));
#line 252
    (server.dirty) ++;
#line 253
    addReply(c, shared.cone);
  } else {
#line 255
    addReply(c, shared.czero);
  }
#line 257
  return;
}
}
#line 259 "t_set.c"
void smoveCommand(redisClient *c ) 
{ robj *srcset ;
  robj *dstset ;
  robj *ele ;
  robj *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  unsigned long __cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 261
  srcset = lookupKeyWrite(c->db, *(c->argv + 1));
#line 262
  dstset = lookupKeyWrite(c->db, *(c->argv + 2));
#line 263
  __cil_tmp = tryObjectEncoding(*(c->argv + 3));
#line 263
  *(c->argv + 3) = __cil_tmp;
#line 263
  ele = __cil_tmp;
#line 266
  if ((unsigned int )srcset == (unsigned int )((void *)0)) {
#line 267
    addReply(c, shared.czero);
#line 268
    return;
  }
#line 273
  __cil_tmp___0 = checkType(c, srcset, 2);
#line 273
  if (__cil_tmp___0) {
#line 274
    return;
  } else
#line 273
  if (dstset) {
#line 273
    __cil_tmp___1 = checkType(c, dstset, 2);
#line 273
    if (__cil_tmp___1) {
#line 274
      return;
    }
  }
#line 277
  if ((unsigned int )srcset == (unsigned int )dstset) {
#line 278
    addReply(c, shared.cone);
#line 279
    return;
  }
#line 283
  __cil_tmp___2 = setTypeRemove(srcset, ele);
#line 283
  if (! __cil_tmp___2) {
#line 284
    addReply(c, shared.czero);
#line 285
    return;
  }
#line 289
  __cil_tmp___3 = setTypeSize(srcset);
#line 289
  if (__cil_tmp___3 == 0UL) {
#line 289
    dbDelete(c->db, *(c->argv + 1));
  }
#line 290
  touchWatchedKey(c->db, *(c->argv + 1));
#line 291
  touchWatchedKey(c->db, *(c->argv + 2));
#line 292
  (server.dirty) ++;
#line 295
  if (! dstset) {
#line 296
    dstset = setTypeCreate(ele);
#line 297
    dbAdd(c->db, *(c->argv + 2), dstset);
  }
#line 301
  __cil_tmp___4 = setTypeAdd(dstset, ele);
#line 301
  if (__cil_tmp___4) {
#line 301
    (server.dirty) ++;
  }
#line 302
  addReply(c, shared.cone);
#line 303
  return;
}
}
#line 305 "t_set.c"
void sismemberCommand(redisClient *c ) 
{ robj *set ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 308
  set = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 308
  if ((unsigned int )set == (unsigned int )((void *)0)) {
#line 309
    return;
  } else {
#line 308
    __cil_tmp = checkType(c, set, 2);
#line 308
    if (__cil_tmp) {
#line 309
      return;
    }
  }
#line 311
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 312
  __cil_tmp___0 = setTypeIsMember(set, *(c->argv + 2));
#line 312
  if (__cil_tmp___0) {
#line 313
    addReply(c, shared.cone);
  } else {
#line 315
    addReply(c, shared.czero);
  }
#line 316
  return;
}
}
#line 318 "t_set.c"
void scardCommand(redisClient *c ) 
{ robj *o ;
  int __cil_tmp ;
  unsigned long __cil_tmp___0 ;

  {
#line 321
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 321
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 322
    return;
  } else {
#line 321
    __cil_tmp = checkType(c, o, 2);
#line 321
    if (__cil_tmp) {
#line 322
      return;
    }
  }
#line 324
  __cil_tmp___0 = setTypeSize(o);
#line 324
  addReplyLongLong(c, (long long )__cil_tmp___0);
#line 325
  return;
}
}
#line 327 "t_set.c"
void spopCommand(redisClient *c ) 
{ robj *set ;
  robj *ele ;
  int64_t llele ;
  int encoding ;
  int __cil_tmp ;
  intset *__cil_tmp___0 ;
  unsigned long __cil_tmp___1 ;

  {
#line 332
  set = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 332
  if ((unsigned int )set == (unsigned int )((void *)0)) {
#line 333
    return;
  } else {
#line 332
    __cil_tmp = checkType(c, set, 2);
#line 332
    if (__cil_tmp) {
#line 333
      return;
    }
  }
#line 335
  encoding = setTypeRandomElement(set, & ele, & llele);
#line 336
  if (encoding == 6) {
#line 337
    addReplyBulkLongLong(c, llele);
#line 338
    __cil_tmp___0 = intsetRemove((intset *)set->ptr, llele, (int *)((void *)0));
#line 338
    set->ptr = (void *)__cil_tmp___0;
  } else {
#line 340
    addReplyBulk(c, ele);
#line 341
    setTypeRemove(set, ele);
  }
#line 343
  __cil_tmp___1 = setTypeSize(set);
#line 343
  if (__cil_tmp___1 == 0UL) {
#line 343
    dbDelete(c->db, *(c->argv + 1));
  }
#line 344
  touchWatchedKey(c->db, *(c->argv + 1));
#line 345
  (server.dirty) ++;
#line 346
  return;
}
}
#line 348 "t_set.c"
void srandmemberCommand(redisClient *c ) 
{ robj *set ;
  robj *ele ;
  int64_t llele ;
  int encoding ;
  int __cil_tmp ;

  {
#line 353
  set = lookupKeyReadOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 353
  if ((unsigned int )set == (unsigned int )((void *)0)) {
#line 354
    return;
  } else {
#line 353
    __cil_tmp = checkType(c, set, 2);
#line 353
    if (__cil_tmp) {
#line 354
      return;
    }
  }
#line 356
  encoding = setTypeRandomElement(set, & ele, & llele);
#line 357
  if (encoding == 6) {
#line 358
    addReplyBulkLongLong(c, llele);
  } else {
#line 360
    addReplyBulk(c, ele);
  }
#line 362
  return;
}
}
#line 364 "t_set.c"
int qsortCompareSetsByCardinality(void const   *s1___0 , void const   *s2___0 ) 
{ unsigned long __cil_tmp ;
  unsigned long __cil_tmp___0 ;

  {
#line 365
  __cil_tmp = setTypeSize(*((robj **)s1___0));
#line 365
  __cil_tmp___0 = setTypeSize(*((robj **)s2___0));
#line 365
  return ((int )(__cil_tmp - __cil_tmp___0));
}
}
#line 368 "t_set.c"
void sinterGenericCommand(redisClient *c , robj **setkeys , unsigned long setnum ,
                          robj *dstkey ) 
{ robj **sets ;
  void *__cil_tmp ;
  setTypeIterator *si ;
  robj *eleobj ;
  robj *dstset ;
  int64_t intobj ;
  void *replylen ;
  unsigned long j ;
  unsigned long cardinality ;
  int encoding ;
  robj *setobj ;
  robj *__cil_tmp___0 ;
  robj *__cil_tmp___1 ;
  robj *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  uint8_t __cil_tmp___6 ;
  int __cil_tmp___7 ;
  uint8_t __cil_tmp___8 ;
  unsigned long __cil_tmp___9 ;
  unsigned long __cil_tmp___10 ;

  {
#line 369
  __cil_tmp = malloc((unsigned int )(sizeof(robj *) * setnum));
#line 369
  sets = (robj **)__cil_tmp;
#line 371
  dstset = (robj *)((void *)0);
#line 373
  replylen = (void *)0;
#line 374
  cardinality = 0UL;
#line 377
  j = 0UL;
#line 377
  while (j < setnum) {
#line 378
    if (dstkey) {
#line 378
      __cil_tmp___0 = lookupKeyWrite(c->db, *(setkeys + j));
#line 378
      __cil_tmp___2 = __cil_tmp___0;
    } else {
#line 378
      __cil_tmp___1 = lookupKeyRead(c->db, *(setkeys + j));
#line 378
      __cil_tmp___2 = __cil_tmp___1;
    }
#line 378
    setobj = __cil_tmp___2;
#line 381
    if (! setobj) {
#line 382
      free((void *)sets);
#line 383
      if (dstkey) {
#line 384
        __cil_tmp___3 = dbDelete(c->db, dstkey);
#line 384
        if (__cil_tmp___3) {
#line 385
          touchWatchedKey(c->db, dstkey);
#line 386
          (server.dirty) ++;
        }
#line 388
        addReply(c, shared.czero);
      } else {
#line 390
        addReply(c, shared.emptymultibulk);
      }
#line 392
      return;
    }
#line 394
    __cil_tmp___4 = checkType(c, setobj, 2);
#line 394
    if (__cil_tmp___4) {
#line 395
      free((void *)sets);
#line 396
      return;
    }
#line 398
    *(sets + j) = setobj;
#line 377
    j ++;
  }
#line 402
  qsort((void *)sets, (unsigned int )setnum, (unsigned int )sizeof(robj *), & qsortCompareSetsByCardinality);
#line 409
  if (! dstkey) {
#line 410
    replylen = addDeferredMultiBulkLength(c);
  } else {
#line 414
    dstset = createIntsetObject();
  }
#line 420
  si = setTypeInitIterator(*(sets + 0));
#line 421
  while (1) {
#line 421
    encoding = setTypeNext(si, & eleobj, & intobj);
#line 421
    if (! (encoding != -1)) {
#line 421
      break;
    }
#line 422
    j = 1UL;
#line 422
    while (j < setnum) {
#line 423
      if (encoding == 6) {
#line 425
        if ((*(sets + j))->encoding == 6U) {
#line 425
          __cil_tmp___6 = intsetFind((intset *)(*(sets + j))->ptr, intobj);
#line 425
          if (__cil_tmp___6) {
#line 425
            goto _L;
          } else {
#line 428
            break;
          }
        } else
        _L: 
#line 432
        if ((*(sets + j))->encoding == 2U) {
#line 433
          eleobj = createStringObjectFromLongLong(intobj);
#line 434
          __cil_tmp___5 = setTypeIsMember(*(sets + j), eleobj);
#line 434
          if (! __cil_tmp___5) {
#line 435
            decrRefCount((void *)eleobj);
#line 436
            break;
          }
#line 438
          decrRefCount((void *)eleobj);
        }
      } else
#line 440
      if (encoding == 2) {
#line 444
        if (eleobj->encoding == 1U && (*(sets + j))->encoding == 6U) {
#line 444
          __cil_tmp___8 = intsetFind((intset *)(*(sets + j))->ptr, (long long )((long )eleobj->ptr));
#line 444
          if (__cil_tmp___8) {
#line 444
            goto _L___0;
          } else {
#line 448
            break;
          }
        } else {
          _L___0: 
#line 451
          __cil_tmp___7 = setTypeIsMember(*(sets + j), eleobj);
#line 451
          if (! __cil_tmp___7) {
#line 452
            break;
          }
        }
      }
#line 422
      j ++;
    }
#line 458
    if (j == setnum) {
#line 459
      if (! dstkey) {
#line 460
        if (encoding == 2) {
#line 461
          addReplyBulk(c, eleobj);
        } else {
#line 463
          addReplyBulkLongLong(c, intobj);
        }
#line 464
        cardinality ++;
      } else
#line 466
      if (encoding == 6) {
#line 467
        eleobj = createStringObjectFromLongLong(intobj);
#line 468
        setTypeAdd(dstset, eleobj);
#line 469
        decrRefCount((void *)eleobj);
      } else {
#line 471
        setTypeAdd(dstset, eleobj);
      }
    }
  }
#line 476
  setTypeReleaseIterator(si);
#line 478
  if (dstkey) {
#line 481
    dbDelete(c->db, dstkey);
#line 482
    __cil_tmp___10 = setTypeSize(dstset);
#line 482
    if (__cil_tmp___10 > 0UL) {
#line 483
      dbAdd(c->db, dstkey, dstset);
#line 484
      __cil_tmp___9 = setTypeSize(dstset);
#line 484
      addReplyLongLong(c, (long long )__cil_tmp___9);
    } else {
#line 486
      decrRefCount((void *)dstset);
#line 487
      addReply(c, shared.czero);
    }
#line 489
    touchWatchedKey(c->db, dstkey);
#line 490
    (server.dirty) ++;
  } else {
#line 492
    setDeferredMultiBulkLength(c, replylen, (long )cardinality);
  }
#line 494
  free((void *)sets);
#line 495
  return;
}
}
#line 497 "t_set.c"
void sinterCommand(redisClient *c ) 
{ 

  {
#line 498
  sinterGenericCommand(c, c->argv + 1, (unsigned long )(c->argc - 1), (robj *)((void *)0));
#line 499
  return;
}
}
#line 501 "t_set.c"
void sinterstoreCommand(redisClient *c ) 
{ 

  {
#line 502
  sinterGenericCommand(c, c->argv + 2, (unsigned long )(c->argc - 2), *(c->argv + 1));
#line 503
  return;
}
}
#line 509 "t_set.c"
void sunionDiffGenericCommand(redisClient *c , robj **setkeys , int setnum , robj *dstkey ,
                              int op ) 
{ robj **sets ;
  void *__cil_tmp ;
  setTypeIterator *si ;
  robj *ele ;
  robj *dstset ;
  int j ;
  int cardinality ;
  robj *setobj ;
  robj *__cil_tmp___0 ;
  robj *__cil_tmp___1 ;
  robj *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  unsigned long __cil_tmp___6 ;
  unsigned long __cil_tmp___7 ;

  {
#line 510
  __cil_tmp = malloc((unsigned int )(sizeof(robj *) * (unsigned long )setnum));
#line 510
  sets = (robj **)__cil_tmp;
#line 512
  dstset = (robj *)((void *)0);
#line 513
  cardinality = 0;
#line 515
  j = 0;
#line 515
  while (j < setnum) {
#line 516
    if (dstkey) {
#line 516
      __cil_tmp___0 = lookupKeyWrite(c->db, *(setkeys + j));
#line 516
      __cil_tmp___2 = __cil_tmp___0;
    } else {
#line 516
      __cil_tmp___1 = lookupKeyRead(c->db, *(setkeys + j));
#line 516
      __cil_tmp___2 = __cil_tmp___1;
    }
#line 516
    setobj = __cil_tmp___2;
#line 519
    if (! setobj) {
#line 520
      *(sets + j) = (robj *)((void *)0);
#line 521
      goto __Cont;
    }
#line 523
    __cil_tmp___3 = checkType(c, setobj, 2);
#line 523
    if (__cil_tmp___3) {
#line 524
      free((void *)sets);
#line 525
      return;
    }
#line 527
    *(sets + j) = setobj;
    __Cont: 
#line 515
    j ++;
  }
#line 533
  dstset = createIntsetObject();
#line 537
  j = 0;
#line 537
  while (j < setnum) {
#line 538
    if ((op == 1 && j == 0) && ! *(sets + j)) {
#line 538
      break;
    }
#line 539
    if (! *(sets + j)) {
#line 539
      goto __Cont___0;
    }
#line 541
    si = setTypeInitIterator(*(sets + j));
#line 542
    while (1) {
#line 542
      ele = setTypeNextObject(si);
#line 542
      if (! ((unsigned int )ele != (unsigned int )((void *)0))) {
#line 542
        break;
      }
#line 543
      if (op == 0 || j == 0) {
#line 544
        __cil_tmp___4 = setTypeAdd(dstset, ele);
#line 544
        if (__cil_tmp___4) {
#line 545
          cardinality ++;
        }
      } else
#line 547
      if (op == 1) {
#line 548
        __cil_tmp___5 = setTypeRemove(dstset, ele);
#line 548
        if (__cil_tmp___5) {
#line 549
          cardinality --;
        }
      }
#line 552
      decrRefCount((void *)ele);
    }
#line 554
    setTypeReleaseIterator(si);
#line 557
    if (op == 1 && cardinality == 0) {
#line 557
      break;
    }
    __Cont___0: 
#line 537
    j ++;
  }
#line 561
  if (! dstkey) {
#line 562
    addReplyMultiBulkLen(c, (long )cardinality);
#line 563
    si = setTypeInitIterator(dstset);
#line 564
    while (1) {
#line 564
      ele = setTypeNextObject(si);
#line 564
      if (! ((unsigned int )ele != (unsigned int )((void *)0))) {
#line 564
        break;
      }
#line 565
      addReplyBulk(c, ele);
#line 566
      decrRefCount((void *)ele);
    }
#line 568
    setTypeReleaseIterator(si);
#line 569
    decrRefCount((void *)dstset);
  } else {
#line 573
    dbDelete(c->db, dstkey);
#line 574
    __cil_tmp___7 = setTypeSize(dstset);
#line 574
    if (__cil_tmp___7 > 0UL) {
#line 575
      dbAdd(c->db, dstkey, dstset);
#line 576
      __cil_tmp___6 = setTypeSize(dstset);
#line 576
      addReplyLongLong(c, (long long )__cil_tmp___6);
    } else {
#line 578
      decrRefCount((void *)dstset);
#line 579
      addReply(c, shared.czero);
    }
#line 581
    touchWatchedKey(c->db, dstkey);
#line 582
    (server.dirty) ++;
  }
#line 584
  free((void *)sets);
#line 585
  return;
}
}
#line 587 "t_set.c"
void sunionCommand(redisClient *c ) 
{ 

  {
#line 588
  sunionDiffGenericCommand(c, c->argv + 1, c->argc - 1, (robj *)((void *)0), 0);
#line 589
  return;
}
}
#line 591 "t_set.c"
void sunionstoreCommand(redisClient *c ) 
{ 

  {
#line 592
  sunionDiffGenericCommand(c, c->argv + 2, c->argc - 2, *(c->argv + 1), 0);
#line 593
  return;
}
}
#line 595 "t_set.c"
void sdiffCommand(redisClient *c ) 
{ 

  {
#line 596
  sunionDiffGenericCommand(c, c->argv + 1, c->argc - 1, (robj *)((void *)0), 1);
#line 597
  return;
}
}
#line 599 "t_set.c"
void sdiffstoreCommand(redisClient *c ) 
{ 

  {
#line 600
  sunionDiffGenericCommand(c, c->argv + 2, c->argc - 2, *(c->argv + 1), 1);
#line 601
  return;
}
}
#line 1 "t_zset.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-nPkSjxFB.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 26 "t_zset.c"
zskiplistNode *zslCreateNode(int level , double score , robj *obj ) 
{ zskiplistNode *zn ;
  void *__cil_tmp ;

  {
#line 27
  __cil_tmp = malloc((unsigned int )(sizeof(*zn) + (unsigned long )level * sizeof(struct zskiplistLevel )));
#line 27
  zn = (zskiplistNode *)__cil_tmp;
#line 28
  zn->score = score;
#line 29
  zn->obj = obj;
#line 30
  return (zn);
}
}
#line 33 "t_zset.c"
zskiplist *zslCreate(void) 
{ int j ;
  zskiplist *zsl ;
  void *__cil_tmp ;

  {
#line 37
  __cil_tmp = malloc((unsigned int )sizeof(*zsl));
#line 37
  zsl = (zskiplist *)__cil_tmp;
#line 38
  zsl->level = 1;
#line 39
  zsl->length = 0UL;
#line 40
  zsl->header = zslCreateNode(32, (double )0, (robj *)((void *)0));
#line 41
  j = 0;
#line 41
  while (j < 32) {
#line 42
    (zsl->header)->level[j].forward = (struct zskiplistNode *)((void *)0);
#line 43
    (zsl->header)->level[j].span = 0U;
#line 41
    j ++;
  }
#line 45
  (zsl->header)->backward = (struct zskiplistNode *)((void *)0);
#line 46
  zsl->tail = (struct zskiplistNode *)((void *)0);
#line 47
  return (zsl);
}
}
#line 50 "t_zset.c"
void zslFreeNode(zskiplistNode *node ) 
{ 

  {
#line 51
  decrRefCount((void *)node->obj);
#line 52
  free((void *)node);
#line 53
  return;
}
}
#line 55 "t_zset.c"
void zslFree(zskiplist *zsl ) 
{ zskiplistNode *node ;
  zskiplistNode *next ;

  {
#line 56
  node = (zsl->header)->level[0].forward;
#line 58
  free((void *)zsl->header);
#line 59
  while (node) {
#line 60
    next = node->level[0].forward;
#line 61
    zslFreeNode(node);
#line 62
    node = next;
  }
#line 64
  free((void *)zsl);
#line 65
  return;
}
}
#line 67 "t_zset.c"
int zslRandomLevel(void) 
{ int level ;
  int __cil_tmp ;

  {
#line 68
  level = 1;
#line 69
  while (1) {
#line 69
    __cil_tmp = random();
#line 69
    if (! ((double )(__cil_tmp & 65535) < 0.25 * (double )65535)) {
#line 69
      break;
    }
#line 70
    level ++;
  }
#line 71
  return (level < 32 ? level : 32);
}
}
#line 74 "t_zset.c"
zskiplistNode *zslInsert(zskiplist *zsl , double score , robj *obj ) 
{ zskiplistNode *update[32] ;
  zskiplistNode *x ;
  unsigned int rank[32] ;
  int i ;
  int level ;
  int __cil_tmp ;

  {
#line 79
  x = zsl->header;
#line 80
  i = zsl->level - 1;
#line 80
  while (i >= 0) {
#line 82
    rank[i] = i == zsl->level - 1 ? 0U : rank[i + 1];
#line 83
    while (1) {
#line 83
      if (x->level[i].forward) {
#line 83
        if (! ((x->level[i].forward)->score < score)) {
#line 83
          if ((x->level[i].forward)->score == score) {
#line 83
            __cil_tmp = compareStringObjects((x->level[i].forward)->obj, obj);
#line 83
            if (! (__cil_tmp < 0)) {
#line 83
              break;
            }
          } else {
#line 83
            break;
          }
        }
      } else {
#line 83
        break;
      }
#line 87
      rank[i] += x->level[i].span;
#line 88
      x = x->level[i].forward;
    }
#line 90
    update[i] = x;
#line 80
    i --;
  }
#line 96
  level = zslRandomLevel();
#line 97
  if (level > zsl->level) {
#line 98
    i = zsl->level;
#line 98
    while (i < level) {
#line 99
      rank[i] = 0U;
#line 100
      update[i] = zsl->header;
#line 101
      (update[i])->level[i].span = (unsigned int )zsl->length;
#line 98
      i ++;
    }
#line 103
    zsl->level = level;
  }
#line 105
  x = zslCreateNode(level, score, obj);
#line 106
  i = 0;
#line 106
  while (i < level) {
#line 107
    x->level[i].forward = (update[i])->level[i].forward;
#line 108
    (update[i])->level[i].forward = x;
#line 111
    x->level[i].span = (update[i])->level[i].span - (rank[0] - rank[i]);
#line 112
    (update[i])->level[i].span = (rank[0] - rank[i]) + 1U;
#line 106
    i ++;
  }
#line 116
  i = level;
#line 116
  while (i < zsl->level) {
#line 117
    ((update[i])->level[i].span) ++;
#line 116
    i ++;
  }
#line 120
  x->backward = (unsigned int )update[0] == (unsigned int )zsl->header ? (zskiplistNode *)((void *)0) : update[0];
#line 121
  if (x->level[0].forward) {
#line 122
    (x->level[0].forward)->backward = x;
  } else {
#line 124
    zsl->tail = x;
  }
#line 125
  (zsl->length) ++;
#line 126
  return (x);
}
}
#line 130 "t_zset.c"
void zslDeleteNode(zskiplist *zsl , zskiplistNode *x , zskiplistNode **update ) 
{ int i ;

  {
#line 132
  i = 0;
#line 132
  while (i < zsl->level) {
#line 133
    if ((unsigned int )(*(update + i))->level[i].forward == (unsigned int )x) {
#line 134
      (*(update + i))->level[i].span += x->level[i].span - 1U;
#line 135
      (*(update + i))->level[i].forward = x->level[i].forward;
    } else {
#line 137
      ((*(update + i))->level[i].span) --;
    }
#line 132
    i ++;
  }
#line 140
  if (x->level[0].forward) {
#line 141
    (x->level[0].forward)->backward = x->backward;
  } else {
#line 143
    zsl->tail = x->backward;
  }
#line 145
  while (zsl->level > 1 && (unsigned int )(zsl->header)->level[zsl->level - 1].forward == (unsigned int )((void *)0)) {
#line 146
    (zsl->level) --;
  }
#line 147
  (zsl->length) --;
#line 148
  return;
}
}
#line 151 "t_zset.c"
int zslDelete(zskiplist *zsl , double score , robj *obj ) 
{ zskiplistNode *update[32] ;
  zskiplistNode *x ;
  int i ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 155
  x = zsl->header;
#line 156
  i = zsl->level - 1;
#line 156
  while (i >= 0) {
#line 157
    while (1) {
#line 157
      if (x->level[i].forward) {
#line 157
        if (! ((x->level[i].forward)->score < score)) {
#line 157
          if ((x->level[i].forward)->score == score) {
#line 157
            __cil_tmp = compareStringObjects((x->level[i].forward)->obj, obj);
#line 157
            if (! (__cil_tmp < 0)) {
#line 157
              break;
            }
          } else {
#line 157
            break;
          }
        }
      } else {
#line 157
        break;
      }
#line 161
      x = x->level[i].forward;
    }
#line 162
    update[i] = x;
#line 156
    i --;
  }
#line 166
  x = x->level[0].forward;
#line 167
  if (x && score == x->score) {
#line 167
    __cil_tmp___0 = equalStringObjects(x->obj, obj);
#line 167
    if (__cil_tmp___0) {
#line 168
      zslDeleteNode(zsl, x, update);
#line 169
      zslFreeNode(x);
#line 170
      return (1);
    } else {
#line 172
      return (0);
    }
  } else {
#line 172
    return (0);
  }
#line 174
  return (0);
}
}
#line 187 "t_zset.c"
unsigned long zslDeleteRangeByScore(zskiplist *zsl , zrangespec range , dict *dict___0 ) 
{ zskiplistNode *update[32] ;
  zskiplistNode *x ;
  unsigned long removed ;
  int i ;
  zskiplistNode *next ;

  {
#line 189
  removed = 0UL;
#line 192
  x = zsl->header;
#line 193
  i = zsl->level - 1;
#line 193
  while (i >= 0) {
#line 194
    while (x->level[i].forward && (range.minex ? (x->level[i].forward)->score <= range.min : (x->level[i].forward)->score < range.min)) {
#line 197
      x = x->level[i].forward;
    }
#line 198
    update[i] = x;
#line 193
    i --;
  }
#line 202
  x = x->level[0].forward;
#line 205
  while (x && (range.maxex ? x->score < range.max : x->score <= range.max)) {
#line 206
    next = x->level[0].forward;
#line 207
    zslDeleteNode(zsl, x, update);
#line 208
    dictDelete(dict___0, (void const   *)x->obj);
#line 209
    zslFreeNode(x);
#line 210
    removed ++;
#line 211
    x = next;
  }
#line 213
  return (removed);
}
}
#line 218 "t_zset.c"
unsigned long zslDeleteRangeByRank(zskiplist *zsl , unsigned int start , unsigned int end ,
                                   dict *dict___0 ) 
{ zskiplistNode *update[32] ;
  zskiplistNode *x ;
  unsigned long traversed ;
  unsigned long removed ;
  int i ;
  zskiplistNode *next ;

  {
#line 220
  traversed = 0UL;
#line 220
  removed = 0UL;
#line 223
  x = zsl->header;
#line 224
  i = zsl->level - 1;
#line 224
  while (i >= 0) {
#line 225
    while (x->level[i].forward && traversed + (unsigned long )x->level[i].span < (unsigned long )start) {
#line 226
      traversed += (unsigned long )x->level[i].span;
#line 227
      x = x->level[i].forward;
    }
#line 229
    update[i] = x;
#line 224
    i --;
  }
#line 232
  traversed ++;
#line 233
  x = x->level[0].forward;
#line 234
  while (x && traversed <= (unsigned long )end) {
#line 235
    next = x->level[0].forward;
#line 236
    zslDeleteNode(zsl, x, update);
#line 237
    dictDelete(dict___0, (void const   *)x->obj);
#line 238
    zslFreeNode(x);
#line 239
    removed ++;
#line 240
    traversed ++;
#line 241
    x = next;
  }
#line 243
  return (removed);
}
}
#line 248 "t_zset.c"
zskiplistNode *zslFirstWithScore(zskiplist *zsl , double score ) 
{ zskiplistNode *x ;
  int i ;

  {
#line 252
  x = zsl->header;
#line 253
  i = zsl->level - 1;
#line 253
  while (i >= 0) {
#line 254
    while (x->level[i].forward && (x->level[i].forward)->score < score) {
#line 255
      x = x->level[i].forward;
    }
#line 253
    i --;
  }
#line 259
  return (x->level[0].forward);
}
}
#line 266 "t_zset.c"
unsigned long zslGetRank(zskiplist *zsl , double score , robj *o ) 
{ zskiplistNode *x ;
  unsigned long rank ;
  int i ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 268
  rank = 0UL;
#line 271
  x = zsl->header;
#line 272
  i = zsl->level - 1;
#line 272
  while (i >= 0) {
#line 273
    while (1) {
#line 273
      if (x->level[i].forward) {
#line 273
        if (! ((x->level[i].forward)->score < score)) {
#line 273
          if ((x->level[i].forward)->score == score) {
#line 273
            __cil_tmp = compareStringObjects((x->level[i].forward)->obj, o);
#line 273
            if (! (__cil_tmp <= 0)) {
#line 273
              break;
            }
          } else {
#line 273
            break;
          }
        }
      } else {
#line 273
        break;
      }
#line 277
      rank += (unsigned long )x->level[i].span;
#line 278
      x = x->level[i].forward;
    }
#line 282
    if (x->obj) {
#line 282
      __cil_tmp___0 = equalStringObjects(x->obj, o);
#line 282
      if (__cil_tmp___0) {
#line 283
        return (rank);
      }
    }
#line 272
    i --;
  }
#line 286
  return (0UL);
}
}
#line 290 "t_zset.c"
zskiplistNode *zslGetElementByRank(zskiplist *zsl , unsigned long rank ) 
{ zskiplistNode *x ;
  unsigned long traversed ;
  int i ;

  {
#line 292
  traversed = 0UL;
#line 295
  x = zsl->header;
#line 296
  i = zsl->level - 1;
#line 296
  while (i >= 0) {
#line 297
    while (x->level[i].forward && traversed + (unsigned long )x->level[i].span <= rank) {
#line 299
      traversed += (unsigned long )x->level[i].span;
#line 300
      x = x->level[i].forward;
    }
#line 302
    if (traversed == rank) {
#line 303
      return (x);
    }
#line 296
    i --;
  }
#line 306
  return ((zskiplistNode *)((void *)0));
}
}
#line 310 "t_zset.c"
static int zslParseRange(robj *min , robj *max , zrangespec *spec ) 
{ char *eptr ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;

  {
#line 312
  __cil_tmp = 0;
#line 312
  spec->maxex = __cil_tmp;
#line 312
  spec->minex = __cil_tmp;
#line 318
  if (min->encoding == 1U) {
#line 319
    spec->min = (double )((long )min->ptr);
  } else
#line 321
  if ((int )*((char *)min->ptr + 0) == 40) {
#line 322
    spec->min = strtod((char const   *)((char *)min->ptr + 1), & eptr);
#line 323
    if ((int )*(eptr + 0) != 0) {
#line 323
      return (-1);
    } else {
#line 323
      if (sizeof(spec->min) == sizeof(float )) {
#line 323
        __cil_tmp___0 = __fpclassifyf((float )spec->min);
#line 323
        __cil_tmp___2 = __cil_tmp___0;
      } else {
#line 323
        __cil_tmp___1 = __fpclassifyd(spec->min);
#line 323
        __cil_tmp___2 = __cil_tmp___1;
      }
#line 323
      if (__cil_tmp___2 == 0) {
#line 323
        return (-1);
      }
    }
#line 324
    spec->minex = 1;
  } else {
#line 326
    spec->min = strtod((char const   *)((char *)min->ptr), & eptr);
#line 327
    if ((int )*(eptr + 0) != 0) {
#line 327
      return (-1);
    } else {
#line 327
      if (sizeof(spec->min) == sizeof(float )) {
#line 327
        __cil_tmp___3 = __fpclassifyf((float )spec->min);
#line 327
        __cil_tmp___5 = __cil_tmp___3;
      } else {
#line 327
        __cil_tmp___4 = __fpclassifyd(spec->min);
#line 327
        __cil_tmp___5 = __cil_tmp___4;
      }
#line 327
      if (__cil_tmp___5 == 0) {
#line 327
        return (-1);
      }
    }
  }
#line 330
  if (max->encoding == 1U) {
#line 331
    spec->max = (double )((long )max->ptr);
  } else
#line 333
  if ((int )*((char *)max->ptr + 0) == 40) {
#line 334
    spec->max = strtod((char const   *)((char *)max->ptr + 1), & eptr);
#line 335
    if ((int )*(eptr + 0) != 0) {
#line 335
      return (-1);
    } else {
#line 335
      if (sizeof(spec->max) == sizeof(float )) {
#line 335
        __cil_tmp___6 = __fpclassifyf((float )spec->max);
#line 335
        __cil_tmp___8 = __cil_tmp___6;
      } else {
#line 335
        __cil_tmp___7 = __fpclassifyd(spec->max);
#line 335
        __cil_tmp___8 = __cil_tmp___7;
      }
#line 335
      if (__cil_tmp___8 == 0) {
#line 335
        return (-1);
      }
    }
#line 336
    spec->maxex = 1;
  } else {
#line 338
    spec->max = strtod((char const   *)((char *)max->ptr), & eptr);
#line 339
    if ((int )*(eptr + 0) != 0) {
#line 339
      return (-1);
    } else {
#line 339
      if (sizeof(spec->max) == sizeof(float )) {
#line 339
        __cil_tmp___9 = __fpclassifyf((float )spec->max);
#line 339
        __cil_tmp___11 = __cil_tmp___9;
      } else {
#line 339
        __cil_tmp___10 = __fpclassifyd(spec->max);
#line 339
        __cil_tmp___11 = __cil_tmp___10;
      }
#line 339
      if (__cil_tmp___11 == 0) {
#line 339
        return (-1);
      }
    }
  }
#line 343
  return (0);
}
}
#line 352 "t_zset.c"
void zaddGenericCommand(redisClient *c , robj *key , robj *ele , double score , int incr ) 
{ robj *zsetobj ;
  zset *zs ;
  zskiplistNode *znode ;
  dictEntry *de ;
  dictEntry *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  dictEntry *de___0 ;
  dictEntry *de___1 ;
  robj *curobj ;
  double *curscore ;
  int deleted ;
  int __cil_tmp___3 ;

  {
#line 357
  zsetobj = lookupKeyWrite(c->db, key);
#line 358
  if ((unsigned int )zsetobj == (unsigned int )((void *)0)) {
#line 359
    zsetobj = createZsetObject();
#line 360
    dbAdd(c->db, key, zsetobj);
  } else
#line 362
  if (zsetobj->type != 3U) {
#line 363
    addReply(c, shared.wrongtypeerr);
#line 364
    return;
  }
#line 367
  zs = (zset *)zsetobj->ptr;
#line 371
  if (incr) {
#line 373
    __cil_tmp = dictFind(zs->dict, (void const   *)ele);
#line 373
    de = __cil_tmp;
#line 374
    if ((unsigned int )de != (unsigned int )((void *)0)) {
#line 375
      score += *((double *)de->val);
    }
#line 377
    if (sizeof(score) == sizeof(float )) {
#line 377
      __cil_tmp___0 = __fpclassifyf((float )score);
#line 377
      __cil_tmp___2 = __cil_tmp___0;
    } else {
#line 377
      __cil_tmp___1 = __fpclassifyd(score);
#line 377
      __cil_tmp___2 = __cil_tmp___1;
    }
#line 377
    if (__cil_tmp___2 == 0) {
#line 378
      addReplyError(c, (char *)"resulting score is not a number (NaN)");
#line 382
      return;
    }
  }
#line 390
  __cil_tmp___3 = dictAdd(zs->dict, (void *)ele, (void *)0);
#line 390
  if (__cil_tmp___3 == 0) {
#line 394
    incrRefCount(ele);
#line 395
    znode = zslInsert(zs->zsl, score, ele);
#line 396
    incrRefCount(ele);
#line 399
    de___0 = dictFind(zs->dict, (void const   *)ele);
#line 400
    if (! ((unsigned int )de___0 != (unsigned int )((void *)0))) {
#line 400
      _redisAssert((char *)"de != NULL", (char *)"t_zset.c", 400);
#line 400
      _exit(1);
    }
#line 401
    de___0->val = (void *)(& znode->score);
#line 402
    touchWatchedKey(c->db, *(c->argv + 1));
#line 403
    (server.dirty) ++;
#line 404
    if (incr) {
#line 405
      addReplyDouble(c, score);
    } else {
#line 407
      addReply(c, shared.cone);
    }
  } else {
#line 415
    de___1 = dictFind(zs->dict, (void const   *)ele);
#line 416
    if (! ((unsigned int )de___1 != (unsigned int )((void *)0))) {
#line 416
      _redisAssert((char *)"de != NULL", (char *)"t_zset.c", 416);
#line 416
      _exit(1);
    }
#line 417
    curobj = (robj *)de___1->key;
#line 418
    curscore = (double *)de___1->val;
#line 422
    if (score != *curscore) {
#line 423
      deleted = zslDelete(zs->zsl, *curscore, curobj);
#line 424
      if (! (deleted != 0)) {
#line 424
        _redisAssert((char *)"deleted != 0", (char *)"t_zset.c", 424);
#line 424
        _exit(1);
      }
#line 425
      znode = zslInsert(zs->zsl, score, curobj);
#line 426
      incrRefCount(curobj);
#line 429
      de___1->val = (void *)(& znode->score);
#line 430
      touchWatchedKey(c->db, *(c->argv + 1));
#line 431
      (server.dirty) ++;
    }
#line 433
    if (incr) {
#line 434
      addReplyDouble(c, score);
    } else {
#line 436
      addReply(c, shared.czero);
    }
  }
#line 438
  return;
}
}
#line 440 "t_zset.c"
void zaddCommand(redisClient *c ) 
{ double scoreval ;
  int __cil_tmp ;

  {
#line 442
  __cil_tmp = getDoubleFromObjectOrReply(c, *(c->argv + 2), & scoreval, (char const   *)((void *)0));
#line 442
  if (__cil_tmp != 0) {
#line 442
    return;
  }
#line 443
  *(c->argv + 3) = tryObjectEncoding(*(c->argv + 3));
#line 444
  zaddGenericCommand(c, *(c->argv + 1), *(c->argv + 3), scoreval, 0);
#line 445
  return;
}
}
#line 447 "t_zset.c"
void zincrbyCommand(redisClient *c ) 
{ double scoreval ;
  int __cil_tmp ;

  {
#line 449
  __cil_tmp = getDoubleFromObjectOrReply(c, *(c->argv + 2), & scoreval, (char const   *)((void *)0));
#line 449
  if (__cil_tmp != 0) {
#line 449
    return;
  }
#line 450
  *(c->argv + 3) = tryObjectEncoding(*(c->argv + 3));
#line 451
  zaddGenericCommand(c, *(c->argv + 1), *(c->argv + 3), scoreval, 1);
#line 452
  return;
}
}
#line 454 "t_zset.c"
void zremCommand(redisClient *c ) 
{ robj *zsetobj ;
  zset *zs ;
  dictEntry *de ;
  double curscore ;
  int deleted ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 461
  zsetobj = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.czero);
#line 461
  if ((unsigned int )zsetobj == (unsigned int )((void *)0)) {
#line 462
    return;
  } else {
#line 461
    __cil_tmp = checkType(c, zsetobj, 3);
#line 461
    if (__cil_tmp) {
#line 462
      return;
    }
  }
#line 464
  zs = (zset *)zsetobj->ptr;
#line 465
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 466
  de = dictFind(zs->dict, (void const   *)*(c->argv + 2));
#line 467
  if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 468
    addReply(c, shared.czero);
#line 469
    return;
  }
#line 472
  curscore = *((double *)de->val);
#line 473
  deleted = zslDelete(zs->zsl, curscore, *(c->argv + 2));
#line 474
  if (! (deleted != 0)) {
#line 474
    _redisAssert((char *)"deleted != 0", (char *)"t_zset.c", 474);
#line 474
    _exit(1);
  }
#line 477
  dictDelete(zs->dict, (void const   *)*(c->argv + 2));
#line 478
  __cil_tmp___0 = htNeedsResize(zs->dict);
#line 478
  if (__cil_tmp___0) {
#line 478
    dictResize(zs->dict);
  }
#line 479
  if ((zs->dict)->ht[0].used + (zs->dict)->ht[1].used == 0UL) {
#line 479
    dbDelete(c->db, *(c->argv + 1));
  }
#line 480
  touchWatchedKey(c->db, *(c->argv + 1));
#line 481
  (server.dirty) ++;
#line 482
  addReply(c, shared.cone);
#line 483
  return;
}
}
#line 485 "t_zset.c"
void zremrangebyscoreCommand(redisClient *c ) 
{ zrangespec range ;
  long deleted ;
  robj *o ;
  zset *zs ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  unsigned long __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 492
  __cil_tmp = zslParseRange(*(c->argv + 2), *(c->argv + 3), & range);
#line 492
  if (__cil_tmp != 0) {
#line 493
    addReplyError(c, (char *)"min or max is not a double");
#line 494
    return;
  }
#line 497
  o = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.czero);
#line 497
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 498
    return;
  } else {
#line 497
    __cil_tmp___0 = checkType(c, o, 3);
#line 497
    if (__cil_tmp___0) {
#line 498
      return;
    }
  }
#line 500
  zs = (zset *)o->ptr;
#line 501
  __cil_tmp___1 = zslDeleteRangeByScore(zs->zsl, range, zs->dict);
#line 501
  deleted = (long )__cil_tmp___1;
#line 502
  __cil_tmp___2 = htNeedsResize(zs->dict);
#line 502
  if (__cil_tmp___2) {
#line 502
    dictResize(zs->dict);
  }
#line 503
  if ((zs->dict)->ht[0].used + (zs->dict)->ht[1].used == 0UL) {
#line 503
    dbDelete(c->db, *(c->argv + 1));
  }
#line 504
  if (deleted) {
#line 504
    touchWatchedKey(c->db, *(c->argv + 1));
  }
#line 505
  server.dirty += (long long )deleted;
#line 506
  addReplyLongLong(c, (long long )deleted);
#line 507
  return;
}
}
#line 509 "t_zset.c"
void zremrangebyrankCommand(redisClient *c ) 
{ long start ;
  long end ;
  int llen ;
  long deleted ;
  robj *zsetobj ;
  zset *zs ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  unsigned long __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 517
  __cil_tmp = getLongFromObjectOrReply(c, *(c->argv + 2), & start, (char const   *)((void *)0));
#line 517
  if (__cil_tmp != 0) {
#line 518
    return;
  } else {
#line 517
    __cil_tmp___0 = getLongFromObjectOrReply(c, *(c->argv + 3), & end, (char const   *)((void *)0));
#line 517
    if (__cil_tmp___0 != 0) {
#line 518
      return;
    }
  }
#line 520
  zsetobj = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.czero);
#line 520
  if ((unsigned int )zsetobj == (unsigned int )((void *)0)) {
#line 521
    return;
  } else {
#line 520
    __cil_tmp___1 = checkType(c, zsetobj, 3);
#line 520
    if (__cil_tmp___1) {
#line 521
      return;
    }
  }
#line 522
  zs = (zset *)zsetobj->ptr;
#line 523
  llen = (int )(zs->zsl)->length;
#line 526
  if (start < 0L) {
#line 526
    start = (long )llen + start;
  }
#line 527
  if (end < 0L) {
#line 527
    end = (long )llen + end;
  }
#line 528
  if (start < 0L) {
#line 528
    start = 0L;
  }
#line 532
  if (start > end || start >= (long )llen) {
#line 533
    addReply(c, shared.czero);
#line 534
    return;
  }
#line 536
  if (end >= (long )llen) {
#line 536
    end = (long )(llen - 1);
  }
#line 540
  __cil_tmp___2 = zslDeleteRangeByRank(zs->zsl, (unsigned int )(start + 1L), (unsigned int )(end + 1L),
                                       zs->dict);
#line 540
  deleted = (long )__cil_tmp___2;
#line 541
  __cil_tmp___3 = htNeedsResize(zs->dict);
#line 541
  if (__cil_tmp___3) {
#line 541
    dictResize(zs->dict);
  }
#line 542
  if ((zs->dict)->ht[0].used + (zs->dict)->ht[1].used == 0UL) {
#line 542
    dbDelete(c->db, *(c->argv + 1));
  }
#line 543
  if (deleted) {
#line 543
    touchWatchedKey(c->db, *(c->argv + 1));
  }
#line 544
  server.dirty += (long long )deleted;
#line 545
  addReplyLongLong(c, (long long )deleted);
#line 546
  return;
}
}
#line 553 "t_zset.c"
int qsortCompareZsetopsrcByCardinality(void const   *s1___0 , void const   *s2___0 ) 
{ zsetopsrc *d1 ;
  zsetopsrc *d2 ;
  unsigned long size1 ;
  unsigned long size2 ;

  {
#line 554
  d1 = (zsetopsrc *)((void *)s1___0);
#line 554
  d2 = (zsetopsrc *)((void *)s2___0);
#line 556
  size1 = d1->dict ? (d1->dict)->ht[0].used + (d1->dict)->ht[1].used : 0UL;
#line 557
  size2 = d2->dict ? (d2->dict)->ht[0].used + (d2->dict)->ht[1].used : 0UL;
#line 558
  return ((int )(size1 - size2));
}
}
#line 566 "t_zset.c"
__inline static void zunionInterAggregate(double *target , double val , int aggregate ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 567
  if (aggregate == 1) {
#line 568
    *target += val;
#line 572
    if (sizeof(*target) == sizeof(float )) {
#line 572
      __cil_tmp = __fpclassifyf((float )*target);
#line 572
      __cil_tmp___1 = __cil_tmp;
    } else {
#line 572
      __cil_tmp___0 = __fpclassifyd(*target);
#line 572
      __cil_tmp___1 = __cil_tmp___0;
    }
#line 572
    if (__cil_tmp___1 == 0) {
#line 572
      *target = 0.0;
    }
  } else
#line 573
  if (aggregate == 2) {
#line 574
    *target = val < *target ? val : *target;
  } else
#line 575
  if (aggregate == 3) {
#line 576
    *target = val > *target ? val : *target;
  } else {
#line 579
    _redisPanic((char *)"\"Unknown ZUNION/INTER aggregate type\"", (char *)"t_zset.c",
                579);
#line 579
    _exit(1);
  }
#line 581
  return;
}
}
#line 583 "t_zset.c"
void zunionInterGenericCommand(redisClient *c , robj *dstkey , int op ) 
{ int i ;
  int j ;
  int setnum ;
  int aggregate ;
  zsetopsrc *src ;
  robj *dstobj ;
  zset *dstzset ;
  zskiplistNode *znode ;
  dictIterator *di ;
  dictEntry *de ;
  int touched ;
  void *__cil_tmp ;
  robj *obj ;
  robj *__cil_tmp___0 ;
  int remaining ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  double score ;
  double value ;
  dictEntry *other ;
  dictEntry *__cil_tmp___7 ;
  robj *o ;
  double score___0 ;
  double value___0 ;
  dictEntry *__cil_tmp___8 ;
  dictEntry *other___0 ;
  dictEntry *__cil_tmp___9 ;
  robj *o___0 ;
  int __cil_tmp___10 ;

  {
#line 585
  aggregate = 1;
#line 592
  touched = 0;
#line 595
  setnum = atoi((char const   *)(*(c->argv + 2))->ptr);
#line 596
  if (setnum < 1) {
#line 597
    addReplyError(c, (char *)"at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE");
#line 599
    return;
  }
#line 603
  if (3 + setnum > c->argc) {
#line 604
    addReply(c, shared.syntaxerr);
#line 605
    return;
  }
#line 609
  __cil_tmp = malloc((unsigned int )(sizeof(zsetopsrc ) * (unsigned long )setnum));
#line 609
  src = (zsetopsrc *)__cil_tmp;
#line 610
  i = 0;
#line 610
  j = 3;
#line 610
  while (i < setnum) {
#line 611
    __cil_tmp___0 = lookupKeyWrite(c->db, *(c->argv + j));
#line 611
    obj = __cil_tmp___0;
#line 612
    if (! obj) {
#line 613
      (src + i)->dict = (dict *)((void *)0);
    } else
#line 615
    if (obj->type == 3U) {
#line 616
      (src + i)->dict = ((zset *)obj->ptr)->dict;
    } else
#line 617
    if (obj->type == 2U) {
#line 618
      (src + i)->dict = (dict *)obj->ptr;
    } else {
#line 620
      free((void *)src);
#line 621
      addReply(c, shared.wrongtypeerr);
#line 622
      return;
    }
#line 627
    (src + i)->weight = 1.0;
#line 610
    i ++;
#line 610
    j ++;
  }
#line 631
  if (j < c->argc) {
#line 632
    remaining = c->argc - j;
#line 634
    while (remaining) {
#line 635
      if (remaining >= setnum + 1) {
#line 635
        __cil_tmp___6 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "weights");
#line 635
        if (__cil_tmp___6) {
#line 635
          goto _L;
        } else {
#line 636
          j ++;
#line 636
          remaining --;
#line 637
          i = 0;
#line 637
          while (i < setnum) {
#line 638
            __cil_tmp___1 = getDoubleFromObjectOrReply(c, *(c->argv + j), & (src + i)->weight,
                                                       "weight value is not a double");
#line 638
            if (__cil_tmp___1 != 0) {
#line 641
              free((void *)src);
#line 642
              return;
            }
#line 637
            i ++;
#line 637
            j ++;
#line 637
            remaining --;
          }
        }
      } else
      _L: 
#line 645
      if (remaining >= 2) {
#line 645
        __cil_tmp___5 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "aggregate");
#line 645
        if (__cil_tmp___5) {
#line 660
          free((void *)src);
#line 661
          addReply(c, shared.syntaxerr);
#line 662
          return;
        } else {
#line 646
          j ++;
#line 646
          remaining --;
#line 647
          __cil_tmp___4 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "sum");
#line 647
          if (__cil_tmp___4) {
#line 649
            __cil_tmp___3 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "min");
#line 649
            if (__cil_tmp___3) {
#line 651
              __cil_tmp___2 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "max");
#line 651
              if (__cil_tmp___2) {
#line 654
                free((void *)src);
#line 655
                addReply(c, shared.syntaxerr);
#line 656
                return;
              } else {
#line 652
                aggregate = 3;
              }
            } else {
#line 650
              aggregate = 2;
            }
          } else {
#line 648
            aggregate = 1;
          }
#line 658
          j ++;
#line 658
          remaining --;
        }
      } else {
#line 660
        free((void *)src);
#line 661
        addReply(c, shared.syntaxerr);
#line 662
        return;
      }
    }
  }
#line 669
  qsort((void *)src, (unsigned int )setnum, (unsigned int )sizeof(zsetopsrc ), & qsortCompareZsetopsrcByCardinality);
#line 671
  dstobj = createZsetObject();
#line 672
  dstzset = (zset *)dstobj->ptr;
#line 674
  if (op == 2) {
#line 676
    if ((src + 0)->dict && ((src + 0)->dict)->ht[0].used + ((src + 0)->dict)->ht[1].used > 0UL) {
#line 679
      di = dictGetIterator((src + 0)->dict);
#line 680
      while (1) {
#line 680
        de = dictNext(di);
#line 680
        if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 680
          break;
        }
#line 683
        score = (src + 0)->weight * ((unsigned int )de->val == (unsigned int )((void *)0) ? 1.0 : *((double *)de->val));
#line 684
        j = 1;
#line 684
        while (j < setnum) {
#line 685
          __cil_tmp___7 = dictFind((src + j)->dict, (void const   *)de->key);
#line 685
          other = __cil_tmp___7;
#line 686
          if (other) {
#line 687
            value = (src + j)->weight * ((unsigned int )other->val == (unsigned int )((void *)0) ? 1.0 : *((double *)other->val));
#line 688
            zunionInterAggregate(& score, value, aggregate);
          } else {
#line 690
            break;
          }
#line 684
          j ++;
        }
#line 695
        if (j == setnum) {
#line 696
          o = (robj *)de->key;
#line 697
          znode = zslInsert(dstzset->zsl, score, o);
#line 698
          incrRefCount(o);
#line 699
          dictAdd(dstzset->dict, (void *)o, (void *)(& znode->score));
#line 700
          incrRefCount(o);
        }
      }
#line 703
      dictReleaseIterator(di);
    }
  } else
#line 705
  if (op == 0) {
#line 706
    i = 0;
#line 706
    while (i < setnum) {
#line 707
      if (! (src + i)->dict) {
#line 707
        goto __Cont;
      }
#line 709
      di = dictGetIterator((src + i)->dict);
#line 710
      while (1) {
#line 710
        de = dictNext(di);
#line 710
        if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 710
          break;
        }
#line 714
        __cil_tmp___8 = dictFind(dstzset->dict, (void const   *)de->key);
#line 714
        if ((unsigned int )__cil_tmp___8 != (unsigned int )((void *)0)) {
#line 715
          continue;
        }
#line 718
        score___0 = (src + i)->weight * ((unsigned int )de->val == (unsigned int )((void *)0) ? 1.0 : *((double *)de->val));
#line 722
        j = i + 1;
#line 722
        while (j < setnum) {
#line 723
          __cil_tmp___9 = dictFind((src + j)->dict, (void const   *)de->key);
#line 723
          other___0 = __cil_tmp___9;
#line 724
          if (other___0) {
#line 725
            value___0 = (src + j)->weight * ((unsigned int )other___0->val == (unsigned int )((void *)0) ? 1.0 : *((double *)other___0->val));
#line 726
            zunionInterAggregate(& score___0, value___0, aggregate);
          }
#line 722
          j ++;
        }
#line 730
        o___0 = (robj *)de->key;
#line 731
        znode = zslInsert(dstzset->zsl, score___0, o___0);
#line 732
        incrRefCount(o___0);
#line 733
        dictAdd(dstzset->dict, (void *)o___0, (void *)(& znode->score));
#line 734
        incrRefCount(o___0);
      }
#line 736
      dictReleaseIterator(di);
      __Cont: 
#line 706
      i ++;
    }
  } else
#line 740
  if (! (op == 2 || op == 0)) {
#line 740
    _redisAssert((char *)"op == REDIS_OP_INTER || op == REDIS_OP_UNION", (char *)"t_zset.c",
                 740);
#line 740
    _exit(1);
  }
#line 743
  __cil_tmp___10 = dbDelete(c->db, dstkey);
#line 743
  if (__cil_tmp___10) {
#line 744
    touchWatchedKey(c->db, dstkey);
#line 745
    touched = 1;
#line 746
    (server.dirty) ++;
  }
#line 748
  if ((dstzset->zsl)->length) {
#line 749
    dbAdd(c->db, dstkey, dstobj);
#line 750
    addReplyLongLong(c, (long long )(dstzset->zsl)->length);
#line 751
    if (! touched) {
#line 751
      touchWatchedKey(c->db, dstkey);
    }
#line 752
    (server.dirty) ++;
  } else {
#line 754
    decrRefCount((void *)dstobj);
#line 755
    addReply(c, shared.czero);
  }
#line 757
  free((void *)src);
#line 758
  return;
}
}
#line 760 "t_zset.c"
void zunionstoreCommand(redisClient *c ) 
{ 

  {
#line 761
  zunionInterGenericCommand(c, *(c->argv + 1), 0);
#line 762
  return;
}
}
#line 764 "t_zset.c"
void zinterstoreCommand(redisClient *c ) 
{ 

  {
#line 765
  zunionInterGenericCommand(c, *(c->argv + 1), 2);
#line 766
  return;
}
}
#line 768 "t_zset.c"
void zrangeGenericCommand(redisClient *c , int reverse ) 
{ robj *o ;
  long start ;
  long end ;
  int withscores ;
  int llen ;
  int rangelen ;
  int j ;
  zset *zsetobj ;
  zskiplist *zsl ;
  zskiplistNode *ln ;
  robj *ele ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  zskiplistNode *__cil_tmp___3 ;
  zskiplistNode *__cil_tmp___4 ;

  {
#line 772
  withscores = 0;
#line 780
  __cil_tmp = getLongFromObjectOrReply(c, *(c->argv + 2), & start, (char const   *)((void *)0));
#line 780
  if (__cil_tmp != 0) {
#line 781
    return;
  } else {
#line 780
    __cil_tmp___0 = getLongFromObjectOrReply(c, *(c->argv + 3), & end, (char const   *)((void *)0));
#line 780
    if (__cil_tmp___0 != 0) {
#line 781
      return;
    }
  }
#line 783
  if (c->argc == 5) {
#line 783
    __cil_tmp___1 = strcasecmp((char const   *)(*(c->argv + 4))->ptr, "withscores");
#line 783
    if (__cil_tmp___1) {
#line 783
      goto _L;
    } else {
#line 784
      withscores = 1;
    }
  } else
  _L: 
#line 785
  if (c->argc >= 5) {
#line 786
    addReply(c, shared.syntaxerr);
#line 787
    return;
  }
#line 790
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.emptymultibulk);
#line 790
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 791
    return;
  } else {
#line 790
    __cil_tmp___2 = checkType(c, o, 3);
#line 790
    if (__cil_tmp___2) {
#line 791
      return;
    }
  }
#line 792
  zsetobj = (zset *)o->ptr;
#line 793
  zsl = zsetobj->zsl;
#line 794
  llen = (int )zsl->length;
#line 797
  if (start < 0L) {
#line 797
    start = (long )llen + start;
  }
#line 798
  if (end < 0L) {
#line 798
    end = (long )llen + end;
  }
#line 799
  if (start < 0L) {
#line 799
    start = 0L;
  }
#line 803
  if (start > end || start >= (long )llen) {
#line 804
    addReply(c, shared.emptymultibulk);
#line 805
    return;
  }
#line 807
  if (end >= (long )llen) {
#line 807
    end = (long )(llen - 1);
  }
#line 808
  rangelen = (int )((end - start) + 1L);
#line 812
  if (reverse) {
#line 813
    if (start == 0L) {
#line 813
      ln = zsl->tail;
    } else {
#line 813
      __cil_tmp___3 = zslGetElementByRank(zsl, (unsigned long )((long )llen - start));
#line 813
      ln = __cil_tmp___3;
    }
  } else
#line 815
  if (start == 0L) {
#line 815
    ln = (zsl->header)->level[0].forward;
  } else {
#line 815
    __cil_tmp___4 = zslGetElementByRank(zsl, (unsigned long )(start + 1L));
#line 815
    ln = __cil_tmp___4;
  }
#line 820
  addReplyMultiBulkLen(c, (long )(withscores ? rangelen * 2 : rangelen));
#line 821
  j = 0;
#line 821
  while (j < rangelen) {
#line 822
    ele = ln->obj;
#line 823
    addReplyBulk(c, ele);
#line 824
    if (withscores) {
#line 825
      addReplyDouble(c, ln->score);
    }
#line 826
    ln = reverse ? ln->backward : ln->level[0].forward;
#line 821
    j ++;
  }
#line 828
  return;
}
}
#line 830 "t_zset.c"
void zrangeCommand(redisClient *c ) 
{ 

  {
#line 831
  zrangeGenericCommand(c, 0);
#line 832
  return;
}
}
#line 834 "t_zset.c"
void zrevrangeCommand(redisClient *c ) 
{ 

  {
#line 835
  zrangeGenericCommand(c, 1);
#line 836
  return;
}
}
#line 840 "t_zset.c"
void genericZrangebyscoreCommand(redisClient *c , int reverse , int justcount ) 
{ zrangespec range ;
  robj *o ;
  robj *emptyreply ;
  zset *zsetobj ;
  zskiplist *zsl ;
  zskiplistNode *ln ;
  int offset ;
  int limit ;
  int withscores ;
  unsigned long rangelen ;
  void *replylen ;
  int __cil_tmp ;
  int remaining ;
  int pos ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 846
  offset = 0;
#line 846
  limit = -1;
#line 847
  withscores = 0;
#line 848
  rangelen = 0UL;
#line 849
  replylen = (void *)0;
#line 852
  __cil_tmp = zslParseRange(*(c->argv + 2), *(c->argv + 3), & range);
#line 852
  if (__cil_tmp != 0) {
#line 853
    addReplyError(c, (char *)"min or max is not a double");
#line 854
    return;
  }
#line 859
  if (c->argc > 4) {
#line 860
    remaining = c->argc - 4;
#line 861
    pos = 4;
#line 863
    while (remaining) {
#line 864
      if (remaining >= 1) {
#line 864
        __cil_tmp___1 = strcasecmp((char const   *)(*(c->argv + pos))->ptr, "withscores");
#line 864
        if (__cil_tmp___1) {
#line 864
          goto _L;
        } else {
#line 865
          pos ++;
#line 865
          remaining --;
#line 866
          withscores = 1;
        }
      } else
      _L: 
#line 867
      if (remaining >= 3) {
#line 867
        __cil_tmp___0 = strcasecmp((char const   *)(*(c->argv + pos))->ptr, "limit");
#line 867
        if (__cil_tmp___0) {
#line 872
          addReply(c, shared.syntaxerr);
#line 873
          return;
        } else {
#line 868
          offset = atoi((char const   *)(*(c->argv + (pos + 1)))->ptr);
#line 869
          limit = atoi((char const   *)(*(c->argv + (pos + 2)))->ptr);
#line 870
          pos += 3;
#line 870
          remaining -= 3;
        }
      } else {
#line 872
        addReply(c, shared.syntaxerr);
#line 873
        return;
      }
    }
  }
#line 879
  emptyreply = justcount ? shared.czero : shared.emptymultibulk;
#line 880
  o = lookupKeyReadOrReply(c, *(c->argv + 1), emptyreply);
#line 880
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 881
    return;
  } else {
#line 880
    __cil_tmp___2 = checkType(c, o, 3);
#line 880
    if (__cil_tmp___2) {
#line 881
      return;
    }
  }
#line 882
  zsetobj = (zset *)o->ptr;
#line 883
  zsl = zsetobj->zsl;
#line 886
  ln = zslFirstWithScore(zsl, range.min);
#line 887
  if (reverse) {
#line 890
    if ((unsigned int )ln == (unsigned int )((void *)0)) {
#line 890
      ln = zsl->tail;
    }
#line 895
    while (ln && ln->score > range.min) {
#line 895
      ln = ln->backward;
    }
#line 898
    if (range.minex) {
#line 900
      while (ln && ln->score == range.min) {
#line 900
        ln = ln->backward;
      }
    } else {
#line 903
      while ((ln && ln->level[0].forward) && (ln->level[0].forward)->score == range.min) {
#line 905
        ln = ln->level[0].forward;
      }
    }
  } else
#line 908
  if (range.minex) {
#line 910
    while (ln && ln->score == range.min) {
#line 910
      ln = ln->level[0].forward;
    }
  }
#line 915
  if ((unsigned int )ln == (unsigned int )((void *)0)) {
#line 916
    addReply(c, emptyreply);
#line 917
    return;
  }
#line 924
  if (! justcount) {
#line 925
    replylen = addDeferredMultiBulkLength(c);
  }
#line 929
  while (1) {
#line 929
    if (ln) {
#line 929
      __cil_tmp___3 = offset;
#line 929
      offset --;
#line 929
      if (! __cil_tmp___3) {
#line 929
        break;
      }
    } else {
#line 929
      break;
    }
#line 930
    if (reverse) {
#line 931
      ln = ln->backward;
    } else {
#line 933
      ln = ln->level[0].forward;
    }
  }
#line 936
  while (1) {
#line 936
    if (ln) {
#line 936
      __cil_tmp___4 = limit;
#line 936
      limit --;
#line 936
      if (! __cil_tmp___4) {
#line 936
        break;
      }
    } else {
#line 936
      break;
    }
#line 938
    if (reverse) {
#line 939
      if (range.maxex) {
#line 941
        if (ln->score <= range.max) {
#line 941
          break;
        }
      } else
#line 944
      if (ln->score < range.max) {
#line 944
        break;
      }
    } else
#line 947
    if (range.maxex) {
#line 949
      if (ln->score >= range.max) {
#line 949
        break;
      }
    } else
#line 952
    if (ln->score > range.max) {
#line 952
      break;
    }
#line 957
    rangelen ++;
#line 958
    if (! justcount) {
#line 959
      addReplyBulk(c, ln->obj);
#line 960
      if (withscores) {
#line 961
        addReplyDouble(c, ln->score);
      }
    }
#line 964
    if (reverse) {
#line 965
      ln = ln->backward;
    } else {
#line 967
      ln = ln->level[0].forward;
    }
  }
#line 970
  if (justcount) {
#line 971
    addReplyLongLong(c, (long long )((long )rangelen));
  } else {
#line 973
    setDeferredMultiBulkLength(c, replylen, (long )(withscores ? rangelen * 2UL : rangelen));
  }
#line 976
  return;
}
}
#line 978 "t_zset.c"
void zrangebyscoreCommand(redisClient *c ) 
{ 

  {
#line 979
  genericZrangebyscoreCommand(c, 0, 0);
#line 980
  return;
}
}
#line 982 "t_zset.c"
void zrevrangebyscoreCommand(redisClient *c ) 
{ 

  {
#line 983
  genericZrangebyscoreCommand(c, 1, 0);
#line 984
  return;
}
}
#line 986 "t_zset.c"
void zcountCommand(redisClient *c ) 
{ 

  {
#line 987
  genericZrangebyscoreCommand(c, 0, 1);
#line 988
  return;
}
}
#line 990 "t_zset.c"
void zcardCommand(redisClient *c ) 
{ robj *o ;
  zset *zs ;
  int __cil_tmp ;

  {
#line 994
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 994
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 995
    return;
  } else {
#line 994
    __cil_tmp = checkType(c, o, 3);
#line 994
    if (__cil_tmp) {
#line 995
      return;
    }
  }
#line 997
  zs = (zset *)o->ptr;
#line 998
  addReplyLongLong(c, (long long )(zs->zsl)->length);
#line 999
  return;
}
}
#line 1001 "t_zset.c"
void zscoreCommand(redisClient *c ) 
{ robj *o ;
  zset *zs ;
  dictEntry *de ;
  int __cil_tmp ;
  double *score ;

  {
#line 1006
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 1006
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 1007
    return;
  } else {
#line 1006
    __cil_tmp = checkType(c, o, 3);
#line 1006
    if (__cil_tmp) {
#line 1007
      return;
    }
  }
#line 1009
  zs = (zset *)o->ptr;
#line 1010
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 1011
  de = dictFind(zs->dict, (void const   *)*(c->argv + 2));
#line 1012
  if (! de) {
#line 1013
    addReply(c, shared.nullbulk);
  } else {
#line 1015
    score = (double *)de->val;
#line 1017
    addReplyDouble(c, *score);
  }
#line 1019
  return;
}
}
#line 1021 "t_zset.c"
void zrankGenericCommand(redisClient *c , int reverse ) 
{ robj *o ;
  zset *zs ;
  zskiplist *zsl ;
  dictEntry *de ;
  unsigned long rank ;
  double *score ;
  int __cil_tmp ;

  {
#line 1029
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 1029
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 1030
    return;
  } else {
#line 1029
    __cil_tmp = checkType(c, o, 3);
#line 1029
    if (__cil_tmp) {
#line 1030
      return;
    }
  }
#line 1032
  zs = (zset *)o->ptr;
#line 1033
  zsl = zs->zsl;
#line 1034
  *(c->argv + 2) = tryObjectEncoding(*(c->argv + 2));
#line 1035
  de = dictFind(zs->dict, (void const   *)*(c->argv + 2));
#line 1036
  if (! de) {
#line 1037
    addReply(c, shared.nullbulk);
#line 1038
    return;
  }
#line 1041
  score = (double *)de->val;
#line 1042
  rank = zslGetRank(zsl, *score, *(c->argv + 2));
#line 1043
  if (rank) {
#line 1044
    if (reverse) {
#line 1045
      addReplyLongLong(c, (long long )(zsl->length - rank));
    } else {
#line 1047
      addReplyLongLong(c, (long long )(rank - 1UL));
    }
  } else {
#line 1050
    addReply(c, shared.nullbulk);
  }
#line 1052
  return;
}
}
#line 1054 "t_zset.c"
void zrankCommand(redisClient *c ) 
{ 

  {
#line 1055
  zrankGenericCommand(c, 0);
#line 1056
  return;
}
}
#line 1058 "t_zset.c"
void zrevrankCommand(redisClient *c ) 
{ 

  {
#line 1059
  zrankGenericCommand(c, 1);
#line 1060
  return;
}
}
#line 1 "t_hash.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-yp66l3ls.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 834 "redis.h"
void hashTypeTryConversion(robj *subject , robj **argv , int start , int end ) ;
#line 835
void hashTypeTryObjectEncoding(robj *subject , robj **o1 , robj **o2 ) ;
#line 836
int hashTypeGet(robj *o , robj *key , robj **objval , unsigned char **v , unsigned int *vlen ) ;
#line 837
robj *hashTypeGetObject(robj *o , robj *key ) ;
#line 838
int hashTypeExists(robj *o , robj *key ) ;
#line 839
int hashTypeSet(robj *o , robj *key , robj *value ) ;
#line 840
int hashTypeDelete(robj *o , robj *key ) ;
#line 841
unsigned long hashTypeLength(robj *o ) ;
#line 842
hashTypeIterator *hashTypeInitIterator(robj *subject ) ;
#line 843
void hashTypeReleaseIterator(hashTypeIterator *hi ) ;
#line 844
int hashTypeNext(hashTypeIterator *hi ) ;
#line 845
int hashTypeCurrent(hashTypeIterator *hi , int what , robj **objval , unsigned char **v ,
                    unsigned int *vlen ) ;
#line 846
robj *hashTypeCurrentObject(hashTypeIterator *hi , int what ) ;
#line 847
robj *hashTypeLookupWriteOrCreate(redisClient *c , robj *key ) ;
#line 12 "t_hash.c"
void hashTypeTryConversion(robj *subject , robj **argv , int start , int end ) 
{ int i ;
  size_t __cil_tmp ;

  {
#line 14
  if (subject->encoding != 3U) {
#line 14
    return;
  }
#line 16
  i = start;
#line 16
  while (i <= end) {
#line 17
    if ((*(argv + i))->encoding == 0U) {
#line 17
      __cil_tmp = sdslen((char *)(*(argv + i))->ptr);
#line 17
      if (__cil_tmp > server.hash_max_zipmap_value) {
#line 20
        convertToRealHash(subject);
#line 21
        return;
      }
    }
#line 16
    i ++;
  }
#line 24
  return;
}
}
#line 27 "t_hash.c"
void hashTypeTryObjectEncoding(robj *subject , robj **o1 , robj **o2 ) 
{ 

  {
#line 28
  if (subject->encoding == 2U) {
#line 29
    if (o1) {
#line 29
      *o1 = tryObjectEncoding(*o1);
    }
#line 30
    if (o2) {
#line 30
      *o2 = tryObjectEncoding(*o2);
    }
  }
#line 32
  return;
}
}
#line 45 "t_hash.c"
int hashTypeGet(robj *o , robj *key , robj **objval , unsigned char **v , unsigned int *vlen ) 
{ int found ;
  size_t __cil_tmp ;
  dictEntry *de ;
  dictEntry *__cil_tmp___0 ;

  {
#line 48
  if (o->encoding == 3U) {
#line 51
    key = getDecodedObject(key);
#line 52
    __cil_tmp = sdslen((char *)key->ptr);
#line 52
    found = zipmapGet((unsigned char *)o->ptr, (unsigned char *)key->ptr, __cil_tmp,
                      v, vlen);
#line 53
    decrRefCount((void *)key);
#line 54
    if (! found) {
#line 54
      return (-1);
    }
  } else {
#line 56
    __cil_tmp___0 = dictFind((dict *)o->ptr, (void const   *)key);
#line 56
    de = __cil_tmp___0;
#line 57
    if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 57
      return (-1);
    }
#line 58
    *objval = (robj *)de->val;
  }
#line 60
  return ((int )o->encoding);
}
}
#line 69 "t_hash.c"
robj *hashTypeGetObject(robj *o , robj *key ) 
{ robj *objval ;
  unsigned char *v ;
  unsigned int vlen ;
  int encoding ;
  int __cil_tmp ;

  {
#line 74
  __cil_tmp = hashTypeGet(o, key, & objval, & v, & vlen);
#line 74
  encoding = __cil_tmp;
#line 75
  switch (encoding) {
  case 2: 
#line 77
  incrRefCount(objval);
#line 78
  return (objval);
  case 3: 
#line 80
  objval = createStringObject((char *)v, vlen);
#line 81
  return (objval);
  default: 
#line 82
  return ((robj *)((void *)0));
  }
}
}
#line 88 "t_hash.c"
int hashTypeExists(robj *o , robj *key ) 
{ size_t __cil_tmp ;
  int __cil_tmp___0 ;
  dictEntry *__cil_tmp___1 ;

  {
#line 89
  if (o->encoding == 3U) {
#line 90
    key = getDecodedObject(key);
#line 91
    __cil_tmp = sdslen((char *)key->ptr);
#line 91
    __cil_tmp___0 = zipmapExists((unsigned char *)o->ptr, (unsigned char *)key->ptr,
                                 __cil_tmp);
#line 91
    if (__cil_tmp___0) {
#line 92
      decrRefCount((void *)key);
#line 93
      return (1);
    }
#line 95
    decrRefCount((void *)key);
  } else {
#line 97
    __cil_tmp___1 = dictFind((dict *)o->ptr, (void const   *)key);
#line 97
    if ((unsigned int )__cil_tmp___1 != (unsigned int )((void *)0)) {
#line 98
      return (1);
    }
  }
#line 101
  return (0);
}
}
#line 106 "t_hash.c"
int hashTypeSet(robj *o , robj *key , robj *value ) 
{ int update ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  unsigned char *__cil_tmp___1 ;
  unsigned int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 107
  update = 0;
#line 108
  if (o->encoding == 3U) {
#line 109
    key = getDecodedObject(key);
#line 110
    value = getDecodedObject(value);
#line 111
    __cil_tmp = sdslen((char *)value->ptr);
#line 111
    __cil_tmp___0 = sdslen((char *)key->ptr);
#line 111
    __cil_tmp___1 = zipmapSet((unsigned char *)o->ptr, (unsigned char *)key->ptr,
                              __cil_tmp___0, (unsigned char *)value->ptr, __cil_tmp,
                              & update);
#line 111
    o->ptr = (void *)__cil_tmp___1;
#line 114
    decrRefCount((void *)key);
#line 115
    decrRefCount((void *)value);
#line 118
    __cil_tmp___2 = zipmapLen((unsigned char *)o->ptr);
#line 118
    if (__cil_tmp___2 > server.hash_max_zipmap_entries) {
#line 119
      convertToRealHash(o);
    }
  } else {
#line 121
    __cil_tmp___3 = dictReplace((dict *)o->ptr, (void *)key, (void *)value);
#line 121
    if (__cil_tmp___3) {
#line 123
      incrRefCount(key);
    } else {
#line 126
      update = 1;
    }
#line 128
    incrRefCount(value);
  }
#line 130
  return (update);
}
}
#line 135 "t_hash.c"
int hashTypeDelete(robj *o , robj *key ) 
{ int deleted ;
  size_t __cil_tmp ;
  unsigned char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 136
  deleted = 0;
#line 137
  if (o->encoding == 3U) {
#line 138
    key = getDecodedObject(key);
#line 139
    __cil_tmp = sdslen((char *)key->ptr);
#line 139
    __cil_tmp___0 = zipmapDel((unsigned char *)o->ptr, (unsigned char *)key->ptr,
                              __cil_tmp, & deleted);
#line 139
    o->ptr = (void *)__cil_tmp___0;
#line 140
    decrRefCount((void *)key);
  } else {
#line 142
    __cil_tmp___1 = dictDelete((dict *)o->ptr, (void const   *)key);
#line 142
    deleted = __cil_tmp___1 == 0;
#line 144
    if (deleted) {
#line 144
      __cil_tmp___2 = htNeedsResize((dict *)o->ptr);
#line 144
      if (__cil_tmp___2) {
#line 144
        dictResize((dict *)o->ptr);
      }
    }
  }
#line 146
  return (deleted);
}
}
#line 150 "t_hash.c"
unsigned long hashTypeLength(robj *o ) 
{ unsigned int __cil_tmp ;
  unsigned long __cil_tmp___0 ;

  {
#line 151
  if (o->encoding == 3U) {
#line 151
    __cil_tmp = zipmapLen((unsigned char *)o->ptr);
#line 151
    __cil_tmp___0 = (unsigned long )__cil_tmp;
  } else {
#line 151
    __cil_tmp___0 = ((dict *)o->ptr)->ht[0].used + ((dict *)o->ptr)->ht[1].used;
  }
#line 151
  return (__cil_tmp___0);
}
}
#line 155 "t_hash.c"
hashTypeIterator *hashTypeInitIterator(robj *subject ) 
{ hashTypeIterator *hi ;
  void *__cil_tmp ;

  {
#line 156
  __cil_tmp = malloc((unsigned int )sizeof(hashTypeIterator ));
#line 156
  hi = (hashTypeIterator *)__cil_tmp;
#line 157
  hi->encoding = (int )subject->encoding;
#line 158
  if (hi->encoding == 3) {
#line 159
    hi->zi = zipmapRewind((unsigned char *)subject->ptr);
  } else
#line 160
  if (hi->encoding == 2) {
#line 161
    hi->di = dictGetIterator((dict *)subject->ptr);
  } else
#line 163
  if (! ((void *)0)) {
#line 163
    _redisAssert((char *)"NULL", (char *)"t_hash.c", 163);
#line 163
    _exit(1);
  }
#line 165
  return (hi);
}
}
#line 168 "t_hash.c"
void hashTypeReleaseIterator(hashTypeIterator *hi ) 
{ 

  {
#line 169
  if (hi->encoding == 2) {
#line 170
    dictReleaseIterator(hi->di);
  }
#line 172
  free((void *)hi);
#line 173
  return;
}
}
#line 177 "t_hash.c"
int hashTypeNext(hashTypeIterator *hi ) 
{ unsigned char *__cil_tmp ;
  dictEntry *__cil_tmp___0 ;

  {
#line 178
  if (hi->encoding == 3) {
#line 179
    __cil_tmp = zipmapNext(hi->zi, & hi->zk, & hi->zklen, & hi->zv, & hi->zvlen);
#line 179
    hi->zi = __cil_tmp;
#line 179
    if ((unsigned int )__cil_tmp == (unsigned int )((void *)0)) {
#line 180
      return (-1);
    }
  } else {
#line 182
    __cil_tmp___0 = dictNext(hi->di);
#line 182
    hi->de = __cil_tmp___0;
#line 182
    if ((unsigned int )__cil_tmp___0 == (unsigned int )((void *)0)) {
#line 182
      return (-1);
    }
  }
#line 184
  return (0);
}
}
#line 198 "t_hash.c"
int hashTypeCurrent(hashTypeIterator *hi , int what , robj **objval , unsigned char **v ,
                    unsigned int *vlen ) 
{ 

  {
#line 199
  if (hi->encoding == 3) {
#line 200
    if (what & 1) {
#line 201
      *v = hi->zk;
#line 202
      *vlen = hi->zklen;
    } else {
#line 204
      *v = hi->zv;
#line 205
      *vlen = hi->zvlen;
    }
  } else
#line 208
  if (what & 1) {
#line 209
    *objval = (robj *)(hi->de)->key;
  } else {
#line 211
    *objval = (robj *)(hi->de)->val;
  }
#line 213
  return (hi->encoding);
}
}
#line 220 "t_hash.c"
robj *hashTypeCurrentObject(hashTypeIterator *hi , int what ) 
{ robj *obj ;
  unsigned char *v ;
  unsigned int vlen ;
  int encoding ;
  int __cil_tmp ;
  robj *__cil_tmp___0 ;

  {
#line 222
  v = (unsigned char *)((void *)0);
#line 223
  vlen = 0U;
#line 224
  __cil_tmp = hashTypeCurrent(hi, what, & obj, & v, & vlen);
#line 224
  encoding = __cil_tmp;
#line 226
  if (encoding == 2) {
#line 227
    incrRefCount(obj);
#line 228
    return (obj);
  } else {
#line 230
    __cil_tmp___0 = createStringObject((char *)v, vlen);
#line 230
    return (__cil_tmp___0);
  }
}
}
#line 234 "t_hash.c"
robj *hashTypeLookupWriteOrCreate(redisClient *c , robj *key ) 
{ robj *o ;
  robj *__cil_tmp ;

  {
#line 235
  __cil_tmp = lookupKeyWrite(c->db, key);
#line 235
  o = __cil_tmp;
#line 236
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 237
    o = createHashObject();
#line 238
    dbAdd(c->db, key, o);
  } else
#line 240
  if (o->type != 4U) {
#line 241
    addReply(c, shared.wrongtypeerr);
#line 242
    return ((robj *)((void *)0));
  }
#line 245
  return (o);
}
}
#line 248 "t_hash.c"
void convertToRealHash(robj *o ) 
{ unsigned char *key ;
  unsigned char *val ;
  unsigned char *p ;
  unsigned char *zm ;
  unsigned int klen ;
  unsigned int vlen ;
  dict *dict___0 ;
  dict *__cil_tmp ;
  robj *keyobj ;
  robj *valobj ;

  {
#line 249
  zm = (unsigned char *)o->ptr;
#line 251
  __cil_tmp = dictCreate(& hashDictType, (void *)0);
#line 251
  dict___0 = __cil_tmp;
#line 253
  if (! (o->type == 4U && o->encoding != 2U)) {
#line 253
    _redisAssert((char *)"o->type == REDIS_HASH && o->encoding != REDIS_ENCODING_HT",
                 (char *)"t_hash.c", 253);
#line 253
    _exit(1);
  }
#line 254
  p = zipmapRewind(zm);
#line 255
  while (1) {
#line 255
    p = zipmapNext(p, & key, & klen, & val, & vlen);
#line 255
    if (! ((unsigned int )p != (unsigned int )((void *)0))) {
#line 255
      break;
    }
#line 258
    keyobj = createStringObject((char *)key, klen);
#line 259
    valobj = createStringObject((char *)val, vlen);
#line 260
    keyobj = tryObjectEncoding(keyobj);
#line 261
    valobj = tryObjectEncoding(valobj);
#line 262
    dictAdd(dict___0, (void *)keyobj, (void *)valobj);
  }
#line 264
  o->encoding = 2U;
#line 265
  o->ptr = (void *)dict___0;
#line 266
  free((void *)zm);
#line 267
  return;
}
}
#line 273 "t_hash.c"
void hsetCommand(redisClient *c ) 
{ int update ;
  robj *o ;

  {
#line 277
  o = hashTypeLookupWriteOrCreate(c, *(c->argv + 1));
#line 277
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 277
    return;
  }
#line 278
  hashTypeTryConversion(o, c->argv, 2, 3);
#line 279
  hashTypeTryObjectEncoding(o, c->argv + 2, c->argv + 3);
#line 280
  update = hashTypeSet(o, *(c->argv + 2), *(c->argv + 3));
#line 281
  addReply(c, update ? shared.czero : shared.cone);
#line 282
  touchWatchedKey(c->db, *(c->argv + 1));
#line 283
  (server.dirty) ++;
#line 284
  return;
}
}
#line 286 "t_hash.c"
void hsetnxCommand(redisClient *c ) 
{ robj *o ;
  int __cil_tmp ;

  {
#line 288
  o = hashTypeLookupWriteOrCreate(c, *(c->argv + 1));
#line 288
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 288
    return;
  }
#line 289
  hashTypeTryConversion(o, c->argv, 2, 3);
#line 291
  __cil_tmp = hashTypeExists(o, *(c->argv + 2));
#line 291
  if (__cil_tmp) {
#line 292
    addReply(c, shared.czero);
  } else {
#line 294
    hashTypeTryObjectEncoding(o, c->argv + 2, c->argv + 3);
#line 295
    hashTypeSet(o, *(c->argv + 2), *(c->argv + 3));
#line 296
    addReply(c, shared.cone);
#line 297
    touchWatchedKey(c->db, *(c->argv + 1));
#line 298
    (server.dirty) ++;
  }
#line 300
  return;
}
}
#line 302 "t_hash.c"
void hmsetCommand(redisClient *c ) 
{ int i ;
  robj *o ;

  {
#line 306
  if (c->argc % 2 == 1) {
#line 307
    addReplyError(c, (char *)"wrong number of arguments for HMSET");
#line 308
    return;
  }
#line 311
  o = hashTypeLookupWriteOrCreate(c, *(c->argv + 1));
#line 311
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 311
    return;
  }
#line 312
  hashTypeTryConversion(o, c->argv, 2, c->argc - 1);
#line 313
  i = 2;
#line 313
  while (i < c->argc) {
#line 314
    hashTypeTryObjectEncoding(o, c->argv + i, c->argv + (i + 1));
#line 315
    hashTypeSet(o, *(c->argv + i), *(c->argv + (i + 1)));
#line 313
    i += 2;
  }
#line 317
  addReply(c, shared.ok);
#line 318
  touchWatchedKey(c->db, *(c->argv + 1));
#line 319
  (server.dirty) ++;
#line 320
  return;
}
}
#line 322 "t_hash.c"
void hincrbyCommand(redisClient *c ) 
{ long long value ;
  long long incr ;
  robj *o ;
  robj *current ;
  robj *new ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 326
  __cil_tmp = getLongLongFromObjectOrReply(c, *(c->argv + 3), & incr, (char const   *)((void *)0));
#line 326
  if (__cil_tmp != 0) {
#line 326
    return;
  }
#line 327
  o = hashTypeLookupWriteOrCreate(c, *(c->argv + 1));
#line 327
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 327
    return;
  }
#line 328
  current = hashTypeGetObject(o, *(c->argv + 2));
#line 328
  if ((unsigned int )current != (unsigned int )((void *)0)) {
#line 329
    __cil_tmp___0 = getLongLongFromObjectOrReply(c, current, & value, "hash value is not an integer");
#line 329
    if (__cil_tmp___0 != 0) {
#line 331
      decrRefCount((void *)current);
#line 332
      return;
    }
#line 334
    decrRefCount((void *)current);
  } else {
#line 336
    value = 0LL;
  }
#line 339
  value += incr;
#line 340
  new = createStringObjectFromLongLong(value);
#line 341
  hashTypeTryObjectEncoding(o, c->argv + 2, (robj **)((void *)0));
#line 342
  hashTypeSet(o, *(c->argv + 2), new);
#line 343
  decrRefCount((void *)new);
#line 344
  addReplyLongLong(c, value);
#line 345
  touchWatchedKey(c->db, *(c->argv + 1));
#line 346
  (server.dirty) ++;
#line 347
  return;
}
}
#line 349 "t_hash.c"
void hgetCommand(redisClient *c ) 
{ robj *o ;
  robj *value ;
  unsigned char *v ;
  unsigned int vlen ;
  int encoding ;
  int __cil_tmp ;

  {
#line 355
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.nullbulk);
#line 355
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 356
    return;
  } else {
#line 355
    __cil_tmp = checkType(c, o, 4);
#line 355
    if (__cil_tmp) {
#line 356
      return;
    }
  }
#line 358
  encoding = hashTypeGet(o, *(c->argv + 2), & value, & v, & vlen);
#line 358
  if (encoding != -1) {
#line 359
    if (encoding == 2) {
#line 360
      addReplyBulk(c, value);
    } else {
#line 362
      addReplyBulkCBuffer(c, (void *)v, vlen);
    }
  } else {
#line 364
    addReply(c, shared.nullbulk);
  }
#line 366
  return;
}
}
#line 368 "t_hash.c"
void hmgetCommand(redisClient *c ) 
{ int i ;
  int encoding ;
  robj *o ;
  robj *value ;
  unsigned char *v ;
  unsigned int vlen ;

  {
#line 374
  o = lookupKeyRead(c->db, *(c->argv + 1));
#line 375
  if ((unsigned int )o != (unsigned int )((void *)0) && o->type != 4U) {
#line 376
    addReply(c, shared.wrongtypeerr);
#line 377
    return;
  }
#line 383
  addReplyMultiBulkLen(c, (long )(c->argc - 2));
#line 384
  i = 2;
#line 384
  while (i < c->argc) {
#line 385
    if ((unsigned int )o != (unsigned int )((void *)0)) {
#line 385
      encoding = hashTypeGet(o, *(c->argv + i), & value, & v, & vlen);
#line 385
      if (encoding != -1) {
#line 387
        if (encoding == 2) {
#line 388
          addReplyBulk(c, value);
        } else {
#line 390
          addReplyBulkCBuffer(c, (void *)v, vlen);
        }
      } else {
#line 392
        addReply(c, shared.nullbulk);
      }
    } else {
#line 392
      addReply(c, shared.nullbulk);
    }
#line 384
    i ++;
  }
#line 395
  return;
}
}
#line 397 "t_hash.c"
void hdelCommand(redisClient *c ) 
{ robj *o ;
  int __cil_tmp ;
  unsigned long __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 399
  o = lookupKeyWriteOrReply(c, *(c->argv + 1), shared.czero);
#line 399
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 400
    return;
  } else {
#line 399
    __cil_tmp = checkType(c, o, 4);
#line 399
    if (__cil_tmp) {
#line 400
      return;
    }
  }
#line 402
  __cil_tmp___1 = hashTypeDelete(o, *(c->argv + 2));
#line 402
  if (__cil_tmp___1) {
#line 403
    __cil_tmp___0 = hashTypeLength(o);
#line 403
    if (__cil_tmp___0 == 0UL) {
#line 403
      dbDelete(c->db, *(c->argv + 1));
    }
#line 404
    addReply(c, shared.cone);
#line 405
    touchWatchedKey(c->db, *(c->argv + 1));
#line 406
    (server.dirty) ++;
  } else {
#line 408
    addReply(c, shared.czero);
  }
#line 410
  return;
}
}
#line 412 "t_hash.c"
void hlenCommand(redisClient *c ) 
{ robj *o ;
  int __cil_tmp ;
  unsigned long __cil_tmp___0 ;

  {
#line 414
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 414
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 415
    return;
  } else {
#line 414
    __cil_tmp = checkType(c, o, 4);
#line 414
    if (__cil_tmp) {
#line 415
      return;
    }
  }
#line 417
  __cil_tmp___0 = hashTypeLength(o);
#line 417
  addReplyLongLong(c, (long long )__cil_tmp___0);
#line 418
  return;
}
}
#line 420 "t_hash.c"
void genericHgetallCommand(redisClient *c , int flags ) 
{ robj *o ;
  unsigned long count ;
  hashTypeIterator *hi ;
  void *replylen ;
  int __cil_tmp ;
  robj *obj ;
  unsigned char *v ;
  unsigned int vlen ;
  int encoding ;
  int __cil_tmp___0 ;

  {
#line 422
  count = 0UL;
#line 424
  replylen = (void *)0;
#line 426
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.emptymultibulk);
#line 426
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 427
    return;
  } else {
#line 426
    __cil_tmp = checkType(c, o, 4);
#line 426
    if (__cil_tmp) {
#line 427
      return;
    }
  }
#line 429
  replylen = addDeferredMultiBulkLength(c);
#line 430
  hi = hashTypeInitIterator(o);
#line 431
  while (1) {
#line 431
    __cil_tmp___0 = hashTypeNext(hi);
#line 431
    if (! (__cil_tmp___0 != -1)) {
#line 431
      break;
    }
#line 433
    v = (unsigned char *)((void *)0);
#line 434
    vlen = 0U;
#line 437
    if (flags & 1) {
#line 438
      encoding = hashTypeCurrent(hi, 1, & obj, & v, & vlen);
#line 439
      if (encoding == 2) {
#line 440
        addReplyBulk(c, obj);
      } else {
#line 442
        addReplyBulkCBuffer(c, (void *)v, vlen);
      }
#line 443
      count ++;
    }
#line 445
    if (flags & 2) {
#line 446
      encoding = hashTypeCurrent(hi, 2, & obj, & v, & vlen);
#line 447
      if (encoding == 2) {
#line 448
        addReplyBulk(c, obj);
      } else {
#line 450
        addReplyBulkCBuffer(c, (void *)v, vlen);
      }
#line 451
      count ++;
    }
  }
#line 454
  hashTypeReleaseIterator(hi);
#line 455
  setDeferredMultiBulkLength(c, replylen, (long )count);
#line 456
  return;
}
}
#line 458 "t_hash.c"
void hkeysCommand(redisClient *c ) 
{ 

  {
#line 459
  genericHgetallCommand(c, 1);
#line 460
  return;
}
}
#line 462 "t_hash.c"
void hvalsCommand(redisClient *c ) 
{ 

  {
#line 463
  genericHgetallCommand(c, 2);
#line 464
  return;
}
}
#line 466 "t_hash.c"
void hgetallCommand(redisClient *c ) 
{ 

  {
#line 467
  genericHgetallCommand(c, 3);
#line 468
  return;
}
}
#line 470 "t_hash.c"
void hexistsCommand(redisClient *c ) 
{ robj *o ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 472
  o = lookupKeyReadOrReply(c, *(c->argv + 1), shared.czero);
#line 472
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 473
    return;
  } else {
#line 472
    __cil_tmp = checkType(c, o, 4);
#line 472
    if (__cil_tmp) {
#line 473
      return;
    }
  }
#line 475
  __cil_tmp___0 = hashTypeExists(o, *(c->argv + 2));
#line 475
  addReply(c, __cil_tmp___0 ? shared.cone : shared.czero);
#line 476
  return;
}
}
#line 1 "config.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wJDIwMWf.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 195 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
char *fgets(char *buf , int n , FILE *fp ) ;
#line 21 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
int chdir(char const   *path ) ;
#line 768 "redis.h"
void stopAppendOnly(void) ;
#line 769
int startAppendOnly(void) ;
#line 7 "config.c"
int yesnotoi(char *s ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 8
  __cil_tmp___0 = strcasecmp((char const   *)s, "yes");
#line 8
  if (__cil_tmp___0) {
#line 9
    __cil_tmp = strcasecmp((char const   *)s, "no");
#line 9
    if (__cil_tmp) {
#line 10
      return (-1);
    } else {
#line 9
      return (0);
    }
  } else {
#line 8
    return (1);
  }
}
}
#line 13 "config.c"
void appendServerSaveParams(time_t seconds , int changes ) 
{ void *__cil_tmp ;

  {
#line 14
  __cil_tmp = realloc((void *)server.saveparams, (unsigned int )(sizeof(struct saveparam ) * (unsigned long )(server.saveparamslen + 1)));
#line 14
  server.saveparams = (struct saveparam *)__cil_tmp;
#line 15
  (server.saveparams + server.saveparamslen)->seconds = seconds;
#line 16
  (server.saveparams + server.saveparamslen)->changes = changes;
#line 17
  (server.saveparamslen) ++;
#line 18
  return;
}
}
#line 20 "config.c"
void resetServerSaveParams(void) 
{ 

  {
#line 21
  free((void *)server.saveparams);
#line 22
  server.saveparams = (struct saveparam *)((void *)0);
#line 23
  server.saveparamslen = 0;
#line 24
  return;
}
}
#line 28 "config.c"
void loadServerConfig(char *filename ) 
{ FILE *fp ;
  char buf[1025] ;
  char *err ;
  int linenum ;
  sds line ;
  sds *argv ;
  int argc ;
  int j ;
  int seconds ;
  int __cil_tmp ;
  int changes ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  FILE *logfp ;
  int __cil_tmp___8 ;
  int *__cil_tmp___9 ;
  char *__cil_tmp___10 ;
  sds __cil_tmp___11 ;
  struct __anonstruct_validSyslogFacilities_16 validSyslogFacilities[10] ;
  int i ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  long long __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  int __cil_tmp___17 ;
  int __cil_tmp___18 ;
  int __cil_tmp___19 ;
  int __cil_tmp___20 ;
  int __cil_tmp___21 ;
  int __cil_tmp___22 ;
  int __cil_tmp___23 ;
  long long __cil_tmp___24 ;
  long long __cil_tmp___25 ;
  long long __cil_tmp___26 ;
  long long __cil_tmp___27 ;
  long long __cil_tmp___28 ;
  long long __cil_tmp___29 ;
  long long __cil_tmp___30 ;
  long long __cil_tmp___31 ;
  long long __cil_tmp___32 ;
  struct redisCommand *cmd ;
  struct redisCommand *__cil_tmp___33 ;
  int retval ;
  sds copy ;
  sds __cil_tmp___34 ;
  size_t __cil_tmp___35 ;
  int __cil_tmp___36 ;
  int __cil_tmp___37 ;
  int __cil_tmp___38 ;
  int __cil_tmp___39 ;
  int __cil_tmp___40 ;
  int __cil_tmp___41 ;
  int __cil_tmp___42 ;
  int __cil_tmp___43 ;
  int __cil_tmp___44 ;
  int __cil_tmp___45 ;
  int __cil_tmp___46 ;
  int __cil_tmp___47 ;
  int __cil_tmp___48 ;
  int __cil_tmp___49 ;
  int __cil_tmp___50 ;
  int __cil_tmp___51 ;
  int __cil_tmp___52 ;
  int __cil_tmp___53 ;
  int __cil_tmp___54 ;
  int __cil_tmp___55 ;
  int __cil_tmp___56 ;
  int __cil_tmp___57 ;
  int __cil_tmp___58 ;
  int __cil_tmp___59 ;
  int __cil_tmp___60 ;
  int __cil_tmp___61 ;
  int __cil_tmp___62 ;
  int __cil_tmp___63 ;
  int __cil_tmp___64 ;
  int __cil_tmp___65 ;
  int __cil_tmp___66 ;
  int __cil_tmp___67 ;
  int __cil_tmp___68 ;
  int __cil_tmp___69 ;
  int __cil_tmp___70 ;
  int __cil_tmp___71 ;
  int __cil_tmp___72 ;
  int __cil_tmp___73 ;
  int __cil_tmp___74 ;
  int __cil_tmp___75 ;
  int __cil_tmp___76 ;
  int __cil_tmp___77 ;
  int __cil_tmp___78 ;
  char *__cil_tmp___79 ;

  {
#line 30
  err = (char *)((void *)0);
#line 31
  linenum = 0;
#line 32
  line = (char *)((void *)0);
#line 34
  if ((int )*(filename + 0) == 45 && (int )*(filename + 1) == 0) {
#line 35
    fp = _impure_ptr->_stdin;
  } else {
#line 37
    fp = fopen((char const   *)filename, "r");
#line 37
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 38
      redisLog(3, "Fatal error, can\'t open config file \'%s\'", filename);
#line 39
      exit(1);
    }
  }
#line 43
  while (1) {
#line 43
    __cil_tmp___79 = fgets(buf, 1025, fp);
#line 43
    if (! ((unsigned int )__cil_tmp___79 != (unsigned int )((void *)0))) {
#line 43
      break;
    }
#line 47
    linenum ++;
#line 48
    line = sdsnew((char const   *)(buf));
#line 49
    line = sdstrim(line, " \t\r\n");
#line 52
    if ((int )*(line + 0) == 35 || (int )*(line + 0) == 0) {
#line 53
      sdsfree(line);
#line 54
      continue;
    }
#line 58
    argv = sdssplitargs(line, & argc);
#line 59
    sdstolower(*(argv + 0));
#line 62
    __cil_tmp___78 = strcasecmp((char const   *)*(argv + 0), "timeout");
#line 62
    if (__cil_tmp___78) {
      _L___39: 
#line 67
      __cil_tmp___77 = strcasecmp((char const   *)*(argv + 0), "port");
#line 67
      if (__cil_tmp___77) {
        _L___38: 
#line 72
        __cil_tmp___76 = strcasecmp((char const   *)*(argv + 0), "bind");
#line 72
        if (__cil_tmp___76) {
          _L___37: 
#line 74
          __cil_tmp___75 = strcasecmp((char const   *)*(argv + 0), "unixsocket");
#line 74
          if (__cil_tmp___75) {
            _L___36: 
#line 76
            __cil_tmp___74 = strcasecmp((char const   *)*(argv + 0), "save");
#line 76
            if (__cil_tmp___74) {
              _L___35: 
#line 83
              __cil_tmp___73 = strcasecmp((char const   *)*(argv + 0), "dir");
#line 83
              if (__cil_tmp___73) {
                _L___34: 
#line 89
                __cil_tmp___72 = strcasecmp((char const   *)*(argv + 0), "loglevel");
#line 89
                if (__cil_tmp___72) {
                  _L___33: 
#line 98
                  __cil_tmp___71 = strcasecmp((char const   *)*(argv + 0), "logfile");
#line 98
                  if (__cil_tmp___71) {
                    _L___32: 
#line 117
                    __cil_tmp___70 = strcasecmp((char const   *)*(argv + 0), "syslog-enabled");
#line 117
                    if (__cil_tmp___70) {
                      _L___31: 
#line 121
                      __cil_tmp___69 = strcasecmp((char const   *)*(argv + 0), "syslog-ident");
#line 121
                      if (__cil_tmp___69) {
                        _L___30: 
#line 124
                        __cil_tmp___68 = strcasecmp((char const   *)*(argv + 0), "syslog-facility");
#line 124
                        if (__cil_tmp___68) {
                          _L___29: 
#line 153
                          __cil_tmp___67 = strcasecmp((char const   *)*(argv + 0),
                                                      "databases");
#line 153
                          if (__cil_tmp___67) {
                            _L___28: 
#line 158
                            __cil_tmp___66 = strcasecmp((char const   *)*(argv + 0),
                                                        "include");
#line 158
                            if (__cil_tmp___66) {
                              _L___27: 
#line 160
                              __cil_tmp___65 = strcasecmp((char const   *)*(argv + 0),
                                                          "maxclients");
#line 160
                              if (__cil_tmp___65) {
                                _L___26: 
#line 162
                                __cil_tmp___64 = strcasecmp((char const   *)*(argv + 0),
                                                            "maxmemory");
#line 162
                                if (__cil_tmp___64) {
                                  _L___25: 
#line 164
                                  __cil_tmp___63 = strcasecmp((char const   *)*(argv + 0),
                                                              "maxmemory-policy");
#line 164
                                  if (__cil_tmp___63) {
                                    _L___24: 
#line 181
                                    __cil_tmp___62 = strcasecmp((char const   *)*(argv + 0),
                                                                "maxmemory-samples");
#line 181
                                    if (__cil_tmp___62) {
                                      _L___23: 
#line 187
                                      __cil_tmp___61 = strcasecmp((char const   *)*(argv + 0),
                                                                  "slaveof");
#line 187
                                      if (__cil_tmp___61) {
                                        _L___22: 
#line 191
                                        __cil_tmp___60 = strcasecmp((char const   *)*(argv + 0),
                                                                    "masterauth");
#line 191
                                        if (__cil_tmp___60) {
                                          _L___21: 
#line 193
                                          __cil_tmp___59 = strcasecmp((char const   *)*(argv + 0),
                                                                      "slave-serve-stale-data");
#line 193
                                          if (__cil_tmp___59) {
                                            _L___20: 
#line 197
                                            __cil_tmp___58 = strcasecmp((char const   *)*(argv + 0),
                                                                        "glueoutputbuf");
#line 197
                                            if (__cil_tmp___58) {
#line 199
                                              __cil_tmp___57 = strcasecmp((char const   *)*(argv + 0),
                                                                          "rdbcompression");
#line 199
                                              if (__cil_tmp___57) {
                                                _L___19: 
#line 203
                                                __cil_tmp___56 = strcasecmp((char const   *)*(argv + 0),
                                                                            "activerehashing");
#line 203
                                                if (__cil_tmp___56) {
                                                  _L___18: 
#line 207
                                                  __cil_tmp___55 = strcasecmp((char const   *)*(argv + 0),
                                                                              "daemonize");
#line 207
                                                  if (__cil_tmp___55) {
                                                    _L___17: 
#line 211
                                                    __cil_tmp___54 = strcasecmp((char const   *)*(argv + 0),
                                                                                "appendonly");
#line 211
                                                    if (__cil_tmp___54) {
                                                      _L___16: 
#line 215
                                                      __cil_tmp___53 = strcasecmp((char const   *)*(argv + 0),
                                                                                  "appendfilename");
#line 215
                                                      if (__cil_tmp___53) {
                                                        _L___15: 
#line 218
                                                        __cil_tmp___52 = strcasecmp((char const   *)*(argv + 0),
                                                                                    "no-appendfsync-on-rewrite");
#line 218
                                                        if (__cil_tmp___52) {
                                                          _L___14: 
#line 223
                                                          __cil_tmp___51 = strcasecmp((char const   *)*(argv + 0),
                                                                                      "appendfsync");
#line 223
                                                          if (__cil_tmp___51) {
                                                            _L___13: 
#line 234
                                                            __cil_tmp___50 = strcasecmp((char const   *)*(argv + 0),
                                                                                        "requirepass");
#line 234
                                                            if (__cil_tmp___50) {
                                                              _L___12: 
#line 236
                                                              __cil_tmp___49 = strcasecmp((char const   *)*(argv + 0),
                                                                                          "pidfile");
#line 236
                                                              if (__cil_tmp___49) {
                                                                _L___11: 
#line 239
                                                                __cil_tmp___48 = strcasecmp((char const   *)*(argv + 0),
                                                                                            "dbfilename");
#line 239
                                                                if (__cil_tmp___48) {
                                                                  _L___10: 
#line 242
                                                                  __cil_tmp___47 = strcasecmp((char const   *)*(argv + 0),
                                                                                              "vm-enabled");
#line 242
                                                                  if (__cil_tmp___47) {
                                                                    _L___9: 
#line 246
                                                                    __cil_tmp___46 = strcasecmp((char const   *)*(argv + 0),
                                                                                                "vm-swap-file");
#line 246
                                                                    if (__cil_tmp___46) {
                                                                      _L___8: 
#line 249
                                                                      __cil_tmp___45 = strcasecmp((char const   *)*(argv + 0),
                                                                                                  "vm-max-memory");
#line 249
                                                                      if (__cil_tmp___45) {
                                                                        _L___7: 
#line 251
                                                                        __cil_tmp___44 = strcasecmp((char const   *)*(argv + 0),
                                                                                                    "vm-page-size");
#line 251
                                                                        if (__cil_tmp___44) {
                                                                          _L___6: 
#line 253
                                                                          __cil_tmp___43 = strcasecmp((char const   *)*(argv + 0),
                                                                                                      "vm-pages");
#line 253
                                                                          if (__cil_tmp___43) {
                                                                            _L___5: 
#line 255
                                                                            __cil_tmp___42 = strcasecmp((char const   *)*(argv + 0),
                                                                                                        "vm-max-threads");
#line 255
                                                                            if (__cil_tmp___42) {
                                                                              _L___4: 
#line 257
                                                                              __cil_tmp___41 = strcasecmp((char const   *)*(argv + 0),
                                                                                                          "hash-max-zipmap-entries");
#line 257
                                                                              if (__cil_tmp___41) {
                                                                                _L___3: 
#line 259
                                                                                __cil_tmp___40 = strcasecmp((char const   *)*(argv + 0),
                                                                                                            "hash-max-zipmap-value");
#line 259
                                                                                if (__cil_tmp___40) {
                                                                                  _L___2: 
#line 261
                                                                                  __cil_tmp___39 = strcasecmp((char const   *)*(argv + 0),
                                                                                                              "list-max-ziplist-entries");
#line 261
                                                                                  if (__cil_tmp___39) {
                                                                                    _L___1: 
#line 263
                                                                                    __cil_tmp___38 = strcasecmp((char const   *)*(argv + 0),
                                                                                                                "list-max-ziplist-value");
#line 263
                                                                                    if (__cil_tmp___38) {
                                                                                      _L___0: 
#line 265
                                                                                      __cil_tmp___37 = strcasecmp((char const   *)*(argv + 0),
                                                                                                                  "set-max-intset-entries");
#line 265
                                                                                      if (__cil_tmp___37) {
                                                                                        _L: 
#line 267
                                                                                        __cil_tmp___36 = strcasecmp((char const   *)*(argv + 0),
                                                                                                                    "rename-command");
#line 267
                                                                                        if (__cil_tmp___36) {
#line 292
                                                                                          err = (char *)"Bad directive or wrong number of arguments";
#line 292
                                                                                          goto loaderr;
                                                                                        } else
#line 267
                                                                                        if (argc == 3) {
#line 268
                                                                                          __cil_tmp___33 = lookupCommand(*(argv + 1));
#line 268
                                                                                          cmd = __cil_tmp___33;
#line 271
                                                                                          if (! cmd) {
#line 272
                                                                                            err = (char *)"No such command in rename-command";
#line 273
                                                                                            goto loaderr;
                                                                                          }
#line 278
                                                                                          retval = dictDelete(server.commands,
                                                                                                              (void const   *)*(argv + 1));
#line 279
                                                                                          if (! (retval == 0)) {
#line 279
                                                                                            _redisAssert((char *)"retval == DICT_OK",
                                                                                                         (char *)"config.c",
                                                                                                         279);
#line 279
                                                                                            _exit(1);
                                                                                          }
#line 282
                                                                                          __cil_tmp___35 = sdslen(*(argv + 2));
#line 282
                                                                                          if (__cil_tmp___35 != 0U) {
#line 283
                                                                                            __cil_tmp___34 = sdsdup(*(argv + 2));
#line 283
                                                                                            copy = __cil_tmp___34;
#line 285
                                                                                            retval = dictAdd(server.commands,
                                                                                                             (void *)copy,
                                                                                                             (void *)cmd);
#line 286
                                                                                            if (retval != 0) {
#line 287
                                                                                              sdsfree(copy);
#line 288
                                                                                              err = (char *)"Target command name already exists";
#line 288
                                                                                              goto loaderr;
                                                                                            }
                                                                                          }
                                                                                        } else {
#line 292
                                                                                          err = (char *)"Bad directive or wrong number of arguments";
#line 292
                                                                                          goto loaderr;
                                                                                        }
                                                                                      } else
#line 265
                                                                                      if (argc == 2) {
#line 266
                                                                                        __cil_tmp___32 = memtoll((char const   *)*(argv + 1),
                                                                                                                 (int *)((void *)0));
#line 266
                                                                                        server.set_max_intset_entries = (unsigned int )__cil_tmp___32;
                                                                                      } else {
#line 265
                                                                                        goto _L;
                                                                                      }
                                                                                    } else
#line 263
                                                                                    if (argc == 2) {
#line 264
                                                                                      __cil_tmp___31 = memtoll((char const   *)*(argv + 1),
                                                                                                               (int *)((void *)0));
#line 264
                                                                                      server.list_max_ziplist_value = (unsigned int )__cil_tmp___31;
                                                                                    } else {
#line 263
                                                                                      goto _L___0;
                                                                                    }
                                                                                  } else
#line 261
                                                                                  if (argc == 2) {
#line 262
                                                                                    __cil_tmp___30 = memtoll((char const   *)*(argv + 1),
                                                                                                             (int *)((void *)0));
#line 262
                                                                                    server.list_max_ziplist_entries = (unsigned int )__cil_tmp___30;
                                                                                  } else {
#line 261
                                                                                    goto _L___1;
                                                                                  }
                                                                                } else
#line 259
                                                                                if (argc == 2) {
#line 260
                                                                                  __cil_tmp___29 = memtoll((char const   *)*(argv + 1),
                                                                                                           (int *)((void *)0));
#line 260
                                                                                  server.hash_max_zipmap_value = (unsigned int )__cil_tmp___29;
                                                                                } else {
#line 259
                                                                                  goto _L___2;
                                                                                }
                                                                              } else
#line 257
                                                                              if (argc == 2) {
#line 258
                                                                                __cil_tmp___28 = memtoll((char const   *)*(argv + 1),
                                                                                                         (int *)((void *)0));
#line 258
                                                                                server.hash_max_zipmap_entries = (unsigned int )__cil_tmp___28;
                                                                              } else {
#line 257
                                                                                goto _L___3;
                                                                              }
                                                                            } else
#line 255
                                                                            if (argc == 2) {
#line 256
                                                                              __cil_tmp___27 = strtoll((char const   *)*(argv + 1),
                                                                                                       (char **)((void *)0),
                                                                                                       10);
#line 256
                                                                              server.vm_max_threads = (int )__cil_tmp___27;
                                                                            } else {
#line 255
                                                                              goto _L___4;
                                                                            }
                                                                          } else
#line 253
                                                                          if (argc == 2) {
#line 254
                                                                            __cil_tmp___26 = memtoll((char const   *)*(argv + 1),
                                                                                                     (int *)((void *)0));
#line 254
                                                                            server.vm_pages = (long )__cil_tmp___26;
                                                                          } else {
#line 253
                                                                            goto _L___5;
                                                                          }
                                                                        } else
#line 251
                                                                        if (argc == 2) {
#line 252
                                                                          __cil_tmp___25 = memtoll((char const   *)*(argv + 1),
                                                                                                   (int *)((void *)0));
#line 252
                                                                          server.vm_page_size = (long )__cil_tmp___25;
                                                                        } else {
#line 251
                                                                          goto _L___6;
                                                                        }
                                                                      } else
#line 249
                                                                      if (argc == 2) {
#line 250
                                                                        __cil_tmp___24 = memtoll((char const   *)*(argv + 1),
                                                                                                 (int *)((void *)0));
#line 250
                                                                        server.vm_max_memory = (unsigned long long )__cil_tmp___24;
                                                                      } else {
#line 249
                                                                        goto _L___7;
                                                                      }
                                                                    } else
#line 246
                                                                    if (argc == 2) {
#line 247
                                                                      free((void *)server.vm_swap_file);
#line 248
                                                                      server.vm_swap_file = strdup((char const   *)*(argv + 1));
                                                                    } else {
#line 246
                                                                      goto _L___8;
                                                                    }
                                                                  } else
#line 242
                                                                  if (argc == 2) {
#line 243
                                                                    server.vm_enabled = yesnotoi(*(argv + 1));
#line 243
                                                                    if (server.vm_enabled == -1) {
#line 244
                                                                      err = (char *)"argument must be \'yes\' or \'no\'";
#line 244
                                                                      goto loaderr;
                                                                    }
                                                                  } else {
#line 242
                                                                    goto _L___9;
                                                                  }
                                                                } else
#line 239
                                                                if (argc == 2) {
#line 240
                                                                  free((void *)server.dbfilename);
#line 241
                                                                  server.dbfilename = strdup((char const   *)*(argv + 1));
                                                                } else {
#line 239
                                                                  goto _L___10;
                                                                }
                                                              } else
#line 236
                                                              if (argc == 2) {
#line 237
                                                                free((void *)server.pidfile);
#line 238
                                                                server.pidfile = strdup((char const   *)*(argv + 1));
                                                              } else {
#line 236
                                                                goto _L___11;
                                                              }
                                                            } else
#line 234
                                                            if (argc == 2) {
#line 235
                                                              server.requirepass = strdup((char const   *)*(argv + 1));
                                                            } else {
#line 234
                                                              goto _L___12;
                                                            }
                                                          } else
#line 223
                                                          if (argc == 2) {
#line 224
                                                            __cil_tmp___23 = strcasecmp((char const   *)*(argv + 1),
                                                                                        "no");
#line 224
                                                            if (__cil_tmp___23) {
#line 226
                                                              __cil_tmp___22 = strcasecmp((char const   *)*(argv + 1),
                                                                                          "always");
#line 226
                                                              if (__cil_tmp___22) {
#line 228
                                                                __cil_tmp___21 = strcasecmp((char const   *)*(argv + 1),
                                                                                            "everysec");
#line 228
                                                                if (__cil_tmp___21) {
#line 231
                                                                  err = (char *)"argument must be \'no\', \'always\' or \'everysec\'";
#line 232
                                                                  goto loaderr;
                                                                } else {
#line 229
                                                                  server.appendfsync = 2;
                                                                }
                                                              } else {
#line 227
                                                                server.appendfsync = 1;
                                                              }
                                                            } else {
#line 225
                                                              server.appendfsync = 0;
                                                            }
                                                          } else {
#line 223
                                                            goto _L___13;
                                                          }
                                                        } else
#line 218
                                                        if (argc == 2) {
#line 220
                                                          server.no_appendfsync_on_rewrite = yesnotoi(*(argv + 1));
#line 220
                                                          if (server.no_appendfsync_on_rewrite == -1) {
#line 221
                                                            err = (char *)"argument must be \'yes\' or \'no\'";
#line 221
                                                            goto loaderr;
                                                          }
                                                        } else {
#line 218
                                                          goto _L___14;
                                                        }
                                                      } else
#line 215
                                                      if (argc == 2) {
#line 216
                                                        free((void *)server.appendfilename);
#line 217
                                                        server.appendfilename = strdup((char const   *)*(argv + 1));
                                                      } else {
#line 215
                                                        goto _L___15;
                                                      }
                                                    } else
#line 211
                                                    if (argc == 2) {
#line 212
                                                      server.appendonly = yesnotoi(*(argv + 1));
#line 212
                                                      if (server.appendonly == -1) {
#line 213
                                                        err = (char *)"argument must be \'yes\' or \'no\'";
#line 213
                                                        goto loaderr;
                                                      }
                                                    } else {
#line 211
                                                      goto _L___16;
                                                    }
                                                  } else
#line 207
                                                  if (argc == 2) {
#line 208
                                                    server.daemonize = yesnotoi(*(argv + 1));
#line 208
                                                    if (server.daemonize == -1) {
#line 209
                                                      err = (char *)"argument must be \'yes\' or \'no\'";
#line 209
                                                      goto loaderr;
                                                    }
                                                  } else {
#line 207
                                                    goto _L___17;
                                                  }
                                                } else
#line 203
                                                if (argc == 2) {
#line 204
                                                  server.activerehashing = yesnotoi(*(argv + 1));
#line 204
                                                  if (server.activerehashing == -1) {
#line 205
                                                    err = (char *)"argument must be \'yes\' or \'no\'";
#line 205
                                                    goto loaderr;
                                                  }
                                                } else {
#line 203
                                                  goto _L___18;
                                                }
                                              } else
#line 199
                                              if (argc == 2) {
#line 200
                                                server.rdbcompression = yesnotoi(*(argv + 1));
#line 200
                                                if (server.rdbcompression == -1) {
#line 201
                                                  err = (char *)"argument must be \'yes\' or \'no\'";
#line 201
                                                  goto loaderr;
                                                }
                                              } else {
#line 199
                                                goto _L___19;
                                              }
                                            } else {
#line 198
                                              redisLog(3, "Deprecated configuration directive: \"%s\"",
                                                       *(argv + 0));
                                            }
                                          } else
#line 193
                                          if (argc == 2) {
#line 194
                                            server.repl_serve_stale_data = yesnotoi(*(argv + 1));
#line 194
                                            if (server.repl_serve_stale_data == -1) {
#line 195
                                              err = (char *)"argument must be \'yes\' or \'no\'";
#line 195
                                              goto loaderr;
                                            }
                                          } else {
#line 193
                                            goto _L___20;
                                          }
                                        } else
#line 191
                                        if (argc == 2) {
#line 192
                                          server.masterauth = strdup((char const   *)*(argv + 1));
                                        } else {
#line 191
                                          goto _L___21;
                                        }
                                      } else
#line 187
                                      if (argc == 3) {
#line 188
                                        server.masterhost = sdsnew((char const   *)*(argv + 1));
#line 189
                                        server.masterport = atoi((char const   *)*(argv + 2));
#line 190
                                        server.replstate = 1;
                                      } else {
#line 187
                                        goto _L___22;
                                      }
                                    } else
#line 181
                                    if (argc == 2) {
#line 182
                                      server.maxmemory_samples = atoi((char const   *)*(argv + 1));
#line 183
                                      if (server.maxmemory_samples <= 0) {
#line 184
                                        err = (char *)"maxmemory-samples must be 1 or greater";
#line 185
                                        goto loaderr;
                                      }
                                    } else {
#line 181
                                      goto _L___23;
                                    }
                                  } else
#line 164
                                  if (argc == 2) {
#line 165
                                    __cil_tmp___20 = strcasecmp((char const   *)*(argv + 1),
                                                                "volatile-lru");
#line 165
                                    if (__cil_tmp___20) {
#line 167
                                      __cil_tmp___19 = strcasecmp((char const   *)*(argv + 1),
                                                                  "volatile-random");
#line 167
                                      if (__cil_tmp___19) {
#line 169
                                        __cil_tmp___18 = strcasecmp((char const   *)*(argv + 1),
                                                                    "volatile-ttl");
#line 169
                                        if (__cil_tmp___18) {
#line 171
                                          __cil_tmp___17 = strcasecmp((char const   *)*(argv + 1),
                                                                      "allkeys-lru");
#line 171
                                          if (__cil_tmp___17) {
#line 173
                                            __cil_tmp___16 = strcasecmp((char const   *)*(argv + 1),
                                                                        "allkeys-random");
#line 173
                                            if (__cil_tmp___16) {
#line 175
                                              __cil_tmp___15 = strcasecmp((char const   *)*(argv + 1),
                                                                          "noeviction");
#line 175
                                              if (__cil_tmp___15) {
#line 178
                                                err = (char *)"Invalid maxmemory policy";
#line 179
                                                goto loaderr;
                                              } else {
#line 176
                                                server.maxmemory_policy = 5;
                                              }
                                            } else {
#line 174
                                              server.maxmemory_policy = 4;
                                            }
                                          } else {
#line 172
                                            server.maxmemory_policy = 3;
                                          }
                                        } else {
#line 170
                                          server.maxmemory_policy = 1;
                                        }
                                      } else {
#line 168
                                        server.maxmemory_policy = 2;
                                      }
                                    } else {
#line 166
                                      server.maxmemory_policy = 0;
                                    }
                                  } else {
#line 164
                                    goto _L___24;
                                  }
                                } else
#line 162
                                if (argc == 2) {
#line 163
                                  __cil_tmp___14 = memtoll((char const   *)*(argv + 1),
                                                           (int *)((void *)0));
#line 163
                                  server.maxmemory = (unsigned long long )__cil_tmp___14;
                                } else {
#line 162
                                  goto _L___25;
                                }
                              } else
#line 160
                              if (argc == 2) {
#line 161
                                __cil_tmp___13 = atoi((char const   *)*(argv + 1));
#line 161
                                server.maxclients = (unsigned int )__cil_tmp___13;
                              } else {
#line 160
                                goto _L___26;
                              }
                            } else
#line 158
                            if (argc == 2) {
#line 159
                              loadServerConfig(*(argv + 1));
                            } else {
#line 158
                              goto _L___27;
                            }
                          } else
#line 153
                          if (argc == 2) {
#line 154
                            server.dbnum = atoi((char const   *)*(argv + 1));
#line 155
                            if (server.dbnum < 1) {
#line 156
                              err = (char *)"Invalid number of databases";
#line 156
                              goto loaderr;
                            }
                          } else {
#line 153
                            goto _L___28;
                          }
                        } else
#line 124
                        if (argc == 2) {
#line 125
                          validSyslogFacilities[0].name = "user";
#line 125
                          validSyslogFacilities[0].value = 1 << 3;
#line 125
                          validSyslogFacilities[1].name = "local0";
#line 125
                          validSyslogFacilities[1].value = 16 << 3;
#line 125
                          validSyslogFacilities[2].name = "local1";
#line 125
                          validSyslogFacilities[2].value = 17 << 3;
#line 125
                          validSyslogFacilities[3].name = "local2";
#line 125
                          validSyslogFacilities[3].value = 18 << 3;
#line 125
                          validSyslogFacilities[4].name = "local3";
#line 125
                          validSyslogFacilities[4].value = 19 << 3;
#line 125
                          validSyslogFacilities[5].name = "local4";
#line 125
                          validSyslogFacilities[5].value = 20 << 3;
#line 125
                          validSyslogFacilities[6].name = "local5";
#line 125
                          validSyslogFacilities[6].value = 21 << 3;
#line 125
                          validSyslogFacilities[7].name = "local6";
#line 125
                          validSyslogFacilities[7].value = 22 << 3;
#line 125
                          validSyslogFacilities[8].name = "local7";
#line 125
                          validSyslogFacilities[8].value = 23 << 3;
#line 125
                          validSyslogFacilities[9].name = (char const   *)((void *)0);
#line 125
                          validSyslogFacilities[9].value = 0;
#line 142
                          i = 0;
#line 142
                          while (validSyslogFacilities[i].name) {
#line 143
                            __cil_tmp___12 = strcasecmp(validSyslogFacilities[i].name,
                                                        (char const   *)*(argv + 1));
#line 143
                            if (! __cil_tmp___12) {
#line 144
                              server.syslog_facility = validSyslogFacilities[i].value;
#line 145
                              break;
                            }
#line 142
                            i ++;
                          }
#line 149
                          if (! validSyslogFacilities[i].name) {
#line 150
                            err = (char *)"Invalid log facility. Must be one of USER or between LOCAL0-LOCAL7";
#line 151
                            goto loaderr;
                          }
                        } else {
#line 124
                          goto _L___29;
                        }
                      } else
#line 121
                      if (argc == 2) {
#line 122
                        if (server.syslog_ident) {
#line 122
                          free((void *)server.syslog_ident);
                        }
#line 123
                        server.syslog_ident = strdup((char const   *)*(argv + 1));
                      } else {
#line 121
                        goto _L___30;
                      }
                    } else
#line 117
                    if (argc == 2) {
#line 118
                      server.syslog_enabled = yesnotoi(*(argv + 1));
#line 118
                      if (server.syslog_enabled == -1) {
#line 119
                        err = (char *)"argument must be \'yes\' or \'no\'";
#line 119
                        goto loaderr;
                      }
                    } else {
#line 117
                      goto _L___31;
                    }
                  } else
#line 98
                  if (argc == 2) {
#line 101
                    server.logfile = strdup((char const   *)*(argv + 1));
#line 102
                    __cil_tmp___8 = strcasecmp((char const   *)server.logfile, "stdout");
#line 102
                    if (! __cil_tmp___8) {
#line 103
                      free((void *)server.logfile);
#line 104
                      server.logfile = (char *)((void *)0);
                    }
#line 106
                    if (server.logfile) {
#line 109
                      logfp = fopen((char const   *)server.logfile, "a");
#line 110
                      if ((unsigned int )logfp == (unsigned int )((void *)0)) {
#line 111
                        __cil_tmp___9 = __errno();
#line 111
                        __cil_tmp___10 = strerror(*__cil_tmp___9);
#line 111
                        __cil_tmp___11 = sdsempty();
#line 111
                        err = sdscatprintf(__cil_tmp___11, "Can\'t open the log file: %s",
                                           __cil_tmp___10);
#line 113
                        goto loaderr;
                      }
#line 115
                      fclose(logfp);
                    }
                  } else {
#line 98
                    goto _L___32;
                  }
                } else
#line 89
                if (argc == 2) {
#line 90
                  __cil_tmp___7 = strcasecmp((char const   *)*(argv + 1), "debug");
#line 90
                  if (__cil_tmp___7) {
#line 91
                    __cil_tmp___6 = strcasecmp((char const   *)*(argv + 1), "verbose");
#line 91
                    if (__cil_tmp___6) {
#line 92
                      __cil_tmp___5 = strcasecmp((char const   *)*(argv + 1), "notice");
#line 92
                      if (__cil_tmp___5) {
#line 93
                        __cil_tmp___4 = strcasecmp((char const   *)*(argv + 1), "warning");
#line 93
                        if (__cil_tmp___4) {
#line 95
                          err = (char *)"Invalid log level. Must be one of debug, notice, warning";
#line 96
                          goto loaderr;
                        } else {
#line 93
                          server.verbosity = 3;
                        }
                      } else {
#line 92
                        server.verbosity = 2;
                      }
                    } else {
#line 91
                      server.verbosity = 1;
                    }
                  } else {
#line 90
                    server.verbosity = 0;
                  }
                } else {
#line 89
                  goto _L___33;
                }
              } else
#line 83
              if (argc == 2) {
#line 84
                __cil_tmp___3 = chdir((char const   *)*(argv + 1));
#line 84
                if (__cil_tmp___3 == -1) {
#line 85
                  __cil_tmp___1 = __errno();
#line 85
                  __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 85
                  redisLog(3, "Can\'t chdir to \'%s\': %s", *(argv + 1), __cil_tmp___2);
#line 87
                  exit(1);
                }
              } else {
#line 83
                goto _L___34;
              }
            } else
#line 76
            if (argc == 3) {
#line 77
              __cil_tmp = atoi((char const   *)*(argv + 1));
#line 77
              seconds = __cil_tmp;
#line 78
              __cil_tmp___0 = atoi((char const   *)*(argv + 2));
#line 78
              changes = __cil_tmp___0;
#line 79
              if (seconds < 1 || changes < 0) {
#line 80
                err = (char *)"Invalid save parameters";
#line 80
                goto loaderr;
              }
#line 82
              appendServerSaveParams((long )seconds, changes);
            } else {
#line 76
              goto _L___35;
            }
          } else
#line 74
          if (argc == 2) {
#line 75
            server.unixsocket = strdup((char const   *)*(argv + 1));
          } else {
#line 74
            goto _L___36;
          }
        } else
#line 72
        if (argc == 2) {
#line 73
          server.bindaddr = strdup((char const   *)*(argv + 1));
        } else {
#line 72
          goto _L___37;
        }
      } else
#line 67
      if (argc == 2) {
#line 68
        server.port = atoi((char const   *)*(argv + 1));
#line 69
        if (server.port < 1 || server.port > 65535) {
#line 70
          err = (char *)"Invalid port";
#line 70
          goto loaderr;
        }
      } else {
#line 67
        goto _L___38;
      }
    } else
#line 62
    if (argc == 2) {
#line 63
      server.maxidletime = atoi((char const   *)*(argv + 1));
#line 64
      if (server.maxidletime < 0) {
#line 65
        err = (char *)"Invalid timeout value";
#line 65
        goto loaderr;
      }
    } else {
#line 62
      goto _L___39;
    }
#line 294
    j = 0;
#line 294
    while (j < argc) {
#line 295
      sdsfree(*(argv + j));
#line 294
      j ++;
    }
#line 296
    free((void *)argv);
#line 297
    sdsfree(line);
  }
#line 299
  if ((unsigned int )fp != (unsigned int )_impure_ptr->_stdin) {
#line 299
    fclose(fp);
  }
#line 300
  return;
  loaderr: 
#line 303
  fprintf(_impure_ptr->_stderr, "\n*** FATAL CONFIG FILE ERROR ***\n");
#line 304
  fprintf(_impure_ptr->_stderr, "Reading the configuration file, at line %d\n", linenum);
#line 305
  fprintf(_impure_ptr->_stderr, ">>> \'%s\'\n", line);
#line 306
  fprintf(_impure_ptr->_stderr, "%s\n", err);
#line 307
  exit(1);
}
}
#line 314 "config.c"
void configSetCommand(redisClient *c ) 
{ robj *o ;
  long long ll ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int yn ;
  int __cil_tmp___11 ;
  int old ;
  int new ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int vlen ;
  int j ;
  sds *v ;
  size_t __cil_tmp___14 ;
  sds *__cil_tmp___15 ;
  char *eptr ;
  long val ;
  long long __cil_tmp___16 ;
  time_t seconds ;
  int changes ;
  long long __cil_tmp___17 ;
  long long __cil_tmp___18 ;
  int yn___0 ;
  int __cil_tmp___19 ;
  int __cil_tmp___20 ;
  int __cil_tmp___21 ;
  int __cil_tmp___22 ;
  int __cil_tmp___23 ;
  int __cil_tmp___24 ;
  int __cil_tmp___25 ;
  int __cil_tmp___26 ;
  int __cil_tmp___27 ;
  int __cil_tmp___28 ;
  int __cil_tmp___29 ;
  int __cil_tmp___30 ;
  int __cil_tmp___31 ;

  {
#line 317
  if (! ((*(c->argv + 2))->encoding == 0U)) {
#line 317
    _redisAssert((char *)"c->argv[2]->encoding == REDIS_ENCODING_RAW", (char *)"config.c",
                 317);
#line 317
    _exit(1);
  }
#line 318
  if (! ((*(c->argv + 3))->encoding == 0U)) {
#line 318
    _redisAssert((char *)"c->argv[3]->encoding == REDIS_ENCODING_RAW", (char *)"config.c",
                 318);
#line 318
    _exit(1);
  }
#line 319
  o = *(c->argv + 3);
#line 321
  __cil_tmp___31 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "dbfilename");
#line 321
  if (__cil_tmp___31) {
#line 324
    __cil_tmp___30 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "requirepass");
#line 324
    if (__cil_tmp___30) {
#line 327
      __cil_tmp___29 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "masterauth");
#line 327
      if (__cil_tmp___29) {
#line 330
        __cil_tmp___28 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "maxmemory");
#line 330
        if (__cil_tmp___28) {
#line 335
          __cil_tmp___27 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "maxmemory-policy");
#line 335
          if (__cil_tmp___27) {
#line 351
            __cil_tmp___26 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "maxmemory-samples");
#line 351
            if (__cil_tmp___26) {
#line 355
              __cil_tmp___25 = strcasecmp((char const   *)(*(c->argv + 2))->ptr, "timeout");
#line 355
              if (__cil_tmp___25) {
#line 359
                __cil_tmp___24 = strcasecmp((char const   *)(*(c->argv + 2))->ptr,
                                            "appendfsync");
#line 359
                if (__cil_tmp___24) {
#line 369
                  __cil_tmp___23 = strcasecmp((char const   *)(*(c->argv + 2))->ptr,
                                              "no-appendfsync-on-rewrite");
#line 369
                  if (__cil_tmp___23) {
#line 374
                    __cil_tmp___22 = strcasecmp((char const   *)(*(c->argv + 2))->ptr,
                                                "appendonly");
#line 374
                    if (__cil_tmp___22) {
#line 390
                      __cil_tmp___21 = strcasecmp((char const   *)(*(c->argv + 2))->ptr,
                                                  "save");
#line 390
                      if (__cil_tmp___21) {
#line 424
                        __cil_tmp___20 = strcasecmp((char const   *)(*(c->argv + 2))->ptr,
                                                    "slave-serve-stale-data");
#line 424
                        if (__cil_tmp___20) {
#line 430
                          addReplyErrorFormat(c, "Unsupported CONFIG parameter: %s",
                                              (char *)(*(c->argv + 2))->ptr);
#line 432
                          return;
                        } else {
#line 425
                          __cil_tmp___19 = yesnotoi((char *)o->ptr);
#line 425
                          yn___0 = __cil_tmp___19;
#line 427
                          if (yn___0 == -1) {
#line 427
                            goto badfmt;
                          }
#line 428
                          server.repl_serve_stale_data = yn___0;
                        }
                      } else {
#line 392
                        __cil_tmp___14 = sdslen((char *)o->ptr);
#line 392
                        __cil_tmp___15 = sdssplitlen((char *)o->ptr, (int )__cil_tmp___14,
                                                     (char *)" ", 1, & vlen);
#line 392
                        v = __cil_tmp___15;
#line 397
                        if (vlen & 1) {
#line 398
                          sdsfreesplitres(v, vlen);
#line 399
                          goto badfmt;
                        }
#line 401
                        j = 0;
#line 401
                        while (j < vlen) {
#line 405
                          __cil_tmp___16 = strtoll((char const   *)*(v + j), & eptr,
                                                   10);
#line 405
                          val = (long )__cil_tmp___16;
#line 406
                          if (((int )*(eptr + 0) != 0 || ((j & 1) == 0 && val < 1L)) || ((j & 1) == 1 && val < 0L)) {
#line 409
                            sdsfreesplitres(v, vlen);
#line 410
                            goto badfmt;
                          }
#line 401
                          j ++;
                        }
#line 414
                        resetServerSaveParams();
#line 415
                        j = 0;
#line 415
                        while (j < vlen) {
#line 419
                          __cil_tmp___17 = strtoll((char const   *)*(v + j), (char **)((void *)0),
                                                   10);
#line 419
                          seconds = (long )__cil_tmp___17;
#line 420
                          __cil_tmp___18 = strtoll((char const   *)*(v + (j + 1)),
                                                   (char **)((void *)0), 10);
#line 420
                          changes = (int )__cil_tmp___18;
#line 421
                          appendServerSaveParams(seconds, changes);
#line 415
                          j += 2;
                        }
#line 423
                        sdsfreesplitres(v, vlen);
                      }
                    } else {
#line 375
                      old = server.appendonly;
#line 376
                      __cil_tmp___12 = yesnotoi((char *)o->ptr);
#line 376
                      new = __cil_tmp___12;
#line 378
                      if (new == -1) {
#line 378
                        goto badfmt;
                      }
#line 379
                      if (old != new) {
#line 380
                        if (new == 0) {
#line 381
                          stopAppendOnly();
                        } else {
#line 383
                          __cil_tmp___13 = startAppendOnly();
#line 383
                          if (__cil_tmp___13 == -1) {
#line 384
                            addReplyError(c, (char *)"Unable to turn on AOF. Check server logs.");
#line 386
                            return;
                          }
                        }
                      }
                    }
                  } else {
#line 370
                    __cil_tmp___11 = yesnotoi((char *)o->ptr);
#line 370
                    yn = __cil_tmp___11;
#line 372
                    if (yn == -1) {
#line 372
                      goto badfmt;
                    }
#line 373
                    server.no_appendfsync_on_rewrite = yn;
                  }
                } else {
#line 360
                  __cil_tmp___10 = strcasecmp((char const   *)o->ptr, "no");
#line 360
                  if (__cil_tmp___10) {
#line 362
                    __cil_tmp___9 = strcasecmp((char const   *)o->ptr, "everysec");
#line 362
                    if (__cil_tmp___9) {
#line 364
                      __cil_tmp___8 = strcasecmp((char const   *)o->ptr, "always");
#line 364
                      if (__cil_tmp___8) {
#line 367
                        goto badfmt;
                      } else {
#line 365
                        server.appendfsync = 1;
                      }
                    } else {
#line 363
                      server.appendfsync = 2;
                    }
                  } else {
#line 361
                    server.appendfsync = 0;
                  }
                }
              } else {
#line 356
                __cil_tmp___7 = getLongLongFromObject(o, & ll);
#line 356
                if ((__cil_tmp___7 == -1 || ll < 0LL) || ll > 2147483647LL) {
#line 357
                  goto badfmt;
                }
#line 358
                server.maxidletime = (int )ll;
              }
            } else {
#line 352
              __cil_tmp___6 = getLongLongFromObject(o, & ll);
#line 352
              if (__cil_tmp___6 == -1 || ll <= 0LL) {
#line 353
                goto badfmt;
              }
#line 354
              server.maxmemory_samples = (int )ll;
            }
          } else {
#line 336
            __cil_tmp___5 = strcasecmp((char const   *)o->ptr, "volatile-lru");
#line 336
            if (__cil_tmp___5) {
#line 338
              __cil_tmp___4 = strcasecmp((char const   *)o->ptr, "volatile-random");
#line 338
              if (__cil_tmp___4) {
#line 340
                __cil_tmp___3 = strcasecmp((char const   *)o->ptr, "volatile-ttl");
#line 340
                if (__cil_tmp___3) {
#line 342
                  __cil_tmp___2 = strcasecmp((char const   *)o->ptr, "allkeys-lru");
#line 342
                  if (__cil_tmp___2) {
#line 344
                    __cil_tmp___1 = strcasecmp((char const   *)o->ptr, "allkeys-random");
#line 344
                    if (__cil_tmp___1) {
#line 346
                      __cil_tmp___0 = strcasecmp((char const   *)o->ptr, "noeviction");
#line 346
                      if (__cil_tmp___0) {
#line 349
                        goto badfmt;
                      } else {
#line 347
                        server.maxmemory_policy = 5;
                      }
                    } else {
#line 345
                      server.maxmemory_policy = 4;
                    }
                  } else {
#line 343
                    server.maxmemory_policy = 3;
                  }
                } else {
#line 341
                  server.maxmemory_policy = 1;
                }
              } else {
#line 339
                server.maxmemory_policy = 2;
              }
            } else {
#line 337
              server.maxmemory_policy = 0;
            }
          }
        } else {
#line 331
          __cil_tmp = getLongLongFromObject(o, & ll);
#line 331
          if (__cil_tmp == -1 || ll < 0LL) {
#line 332
            goto badfmt;
          }
#line 333
          server.maxmemory = (unsigned long long )ll;
#line 334
          if (server.maxmemory) {
#line 334
            freeMemoryIfNeeded();
          }
        }
      } else {
#line 328
        free((void *)server.masterauth);
#line 329
        server.masterauth = strdup((char const   *)o->ptr);
      }
    } else {
#line 325
      free((void *)server.requirepass);
#line 326
      server.requirepass = strdup((char const   *)o->ptr);
    }
  } else {
#line 322
    free((void *)server.dbfilename);
#line 323
    server.dbfilename = strdup((char const   *)o->ptr);
  }
#line 434
  addReply(c, shared.ok);
#line 435
  return;
  badfmt: 
#line 438
  addReplyErrorFormat(c, "Invalid argument \'%s\' for CONFIG SET \'%s\'", (char *)o->ptr,
                      (char *)(*(c->argv + 2))->ptr);
#line 441
  return;
}
}
#line 443 "config.c"
void configGetCommand(redisClient *c ) 
{ robj *o ;
  void *replylen ;
  void *__cil_tmp ;
  char *pattern ;
  char buf[128] ;
  int matches ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  char *s ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  char *policy ;
  int __cil_tmp___9 ;
  sds buf___0 ;
  sds __cil_tmp___10 ;
  int j ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;

  {
#line 444
  o = *(c->argv + 2);
#line 445
  __cil_tmp = addDeferredMultiBulkLength(c);
#line 445
  replylen = __cil_tmp;
#line 446
  pattern = (char *)o->ptr;
#line 448
  matches = 0;
#line 449
  if (! (o->encoding == 0U)) {
#line 449
    _redisAssert((char *)"o->encoding == REDIS_ENCODING_RAW", (char *)"config.c",
                 449);
#line 449
    _exit(1);
  }
#line 451
  __cil_tmp___0 = stringmatch((char const   *)pattern, "dbfilename", 0);
#line 451
  if (__cil_tmp___0) {
#line 452
    addReplyBulkCString(c, (char *)"dbfilename");
#line 453
    addReplyBulkCString(c, server.dbfilename);
#line 454
    matches ++;
  }
#line 456
  __cil_tmp___1 = stringmatch((char const   *)pattern, "requirepass", 0);
#line 456
  if (__cil_tmp___1) {
#line 457
    addReplyBulkCString(c, (char *)"requirepass");
#line 458
    addReplyBulkCString(c, server.requirepass);
#line 459
    matches ++;
  }
#line 461
  __cil_tmp___2 = stringmatch((char const   *)pattern, "masterauth", 0);
#line 461
  if (__cil_tmp___2) {
#line 462
    addReplyBulkCString(c, (char *)"masterauth");
#line 463
    addReplyBulkCString(c, server.masterauth);
#line 464
    matches ++;
  }
#line 466
  __cil_tmp___3 = stringmatch((char const   *)pattern, "maxmemory", 0);
#line 466
  if (__cil_tmp___3) {
#line 467
    ll2string(buf, (unsigned int )sizeof(buf), (long long )server.maxmemory);
#line 468
    addReplyBulkCString(c, (char *)"maxmemory");
#line 469
    addReplyBulkCString(c, buf);
#line 470
    matches ++;
  }
#line 472
  __cil_tmp___4 = stringmatch((char const   *)pattern, "maxmemory-policy", 0);
#line 472
  if (__cil_tmp___4) {
#line 475
    switch (server.maxmemory_policy) {
    case 0: 
#line 476
    s = (char *)"volatile-lru";
#line 476
    break;
    case 1: 
#line 477
    s = (char *)"volatile-ttl";
#line 477
    break;
    case 2: 
#line 478
    s = (char *)"volatile-random";
#line 478
    break;
    case 3: 
#line 479
    s = (char *)"allkeys-lru";
#line 479
    break;
    case 4: 
#line 480
    s = (char *)"allkeys-random";
#line 480
    break;
    case 5: 
#line 481
    s = (char *)"noeviction";
#line 481
    break;
    default: 
#line 482
    s = (char *)"unknown";
#line 482
    break;
    }
#line 484
    addReplyBulkCString(c, (char *)"maxmemory-policy");
#line 485
    addReplyBulkCString(c, s);
#line 486
    matches ++;
  }
#line 488
  __cil_tmp___5 = stringmatch((char const   *)pattern, "maxmemory-samples", 0);
#line 488
  if (__cil_tmp___5) {
#line 489
    ll2string(buf, (unsigned int )sizeof(buf), (long long )server.maxmemory_samples);
#line 490
    addReplyBulkCString(c, (char *)"maxmemory-samples");
#line 491
    addReplyBulkCString(c, buf);
#line 492
    matches ++;
  }
#line 494
  __cil_tmp___6 = stringmatch((char const   *)pattern, "timeout", 0);
#line 494
  if (__cil_tmp___6) {
#line 495
    ll2string(buf, (unsigned int )sizeof(buf), (long long )server.maxidletime);
#line 496
    addReplyBulkCString(c, (char *)"timeout");
#line 497
    addReplyBulkCString(c, buf);
#line 498
    matches ++;
  }
#line 500
  __cil_tmp___7 = stringmatch((char const   *)pattern, "appendonly", 0);
#line 500
  if (__cil_tmp___7) {
#line 501
    addReplyBulkCString(c, (char *)"appendonly");
#line 502
    addReplyBulkCString(c, (char *)(server.appendonly ? "yes" : "no"));
#line 503
    matches ++;
  }
#line 505
  __cil_tmp___8 = stringmatch((char const   *)pattern, "no-appendfsync-on-rewrite",
                              0);
#line 505
  if (__cil_tmp___8) {
#line 506
    addReplyBulkCString(c, (char *)"no-appendfsync-on-rewrite");
#line 507
    addReplyBulkCString(c, (char *)(server.no_appendfsync_on_rewrite ? "yes" : "no"));
#line 508
    matches ++;
  }
#line 510
  __cil_tmp___9 = stringmatch((char const   *)pattern, "appendfsync", 0);
#line 510
  if (__cil_tmp___9) {
#line 513
    switch (server.appendfsync) {
    case 0: 
#line 514
    policy = (char *)"no";
#line 514
    break;
    case 2: 
#line 515
    policy = (char *)"everysec";
#line 515
    break;
    case 1: 
#line 516
    policy = (char *)"always";
#line 516
    break;
    default: 
#line 517
    policy = (char *)"unknown";
#line 517
    break;
    }
#line 519
    addReplyBulkCString(c, (char *)"appendfsync");
#line 520
    addReplyBulkCString(c, policy);
#line 521
    matches ++;
  }
#line 523
  __cil_tmp___11 = stringmatch((char const   *)pattern, "save", 0);
#line 523
  if (__cil_tmp___11) {
#line 524
    __cil_tmp___10 = sdsempty();
#line 524
    buf___0 = __cil_tmp___10;
#line 527
    j = 0;
#line 527
    while (j < server.saveparamslen) {
#line 528
      buf___0 = sdscatprintf(buf___0, "%ld %d", (server.saveparams + j)->seconds,
                             (server.saveparams + j)->changes);
#line 531
      if (j != server.saveparamslen - 1) {
#line 532
        buf___0 = sdscatlen(buf___0, (void *)" ", 1U);
      }
#line 527
      j ++;
    }
#line 534
    addReplyBulkCString(c, (char *)"save");
#line 535
    addReplyBulkCString(c, buf___0);
#line 536
    sdsfree(buf___0);
#line 537
    matches ++;
  }
#line 539
  __cil_tmp___12 = stringmatch((char const   *)pattern, "slave-serve-stale-data",
                               0);
#line 539
  if (__cil_tmp___12) {
#line 540
    addReplyBulkCString(c, (char *)"slave-serve-stale-data");
#line 541
    addReplyBulkCString(c, (char *)(server.repl_serve_stale_data ? "yes" : "no"));
#line 542
    matches ++;
  }
#line 544
  setDeferredMultiBulkLength(c, replylen, (long )(matches * 2));
#line 545
  return;
}
}
#line 547 "config.c"
void configCommand(redisClient *c ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 548
  __cil_tmp___1 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "set");
#line 548
  if (__cil_tmp___1) {
#line 551
    __cil_tmp___0 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "get");
#line 551
    if (__cil_tmp___0) {
#line 554
      __cil_tmp = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "resetstat");
#line 554
      if (__cil_tmp) {
#line 563
        addReplyError(c, (char *)"CONFIG subcommand must be one of GET, SET, RESETSTAT");
      } else {
#line 555
        if (c->argc != 2) {
#line 555
          goto badarity;
        }
#line 556
        server.stat_keyspace_hits = 0LL;
#line 557
        server.stat_keyspace_misses = 0LL;
#line 558
        server.stat_numcommands = 0LL;
#line 559
        server.stat_numconnections = 0LL;
#line 560
        server.stat_expiredkeys = 0LL;
#line 561
        addReply(c, shared.ok);
      }
    } else {
#line 552
      if (c->argc != 3) {
#line 552
        goto badarity;
      }
#line 553
      configGetCommand(c);
    }
  } else {
#line 549
    if (c->argc != 4) {
#line 549
      goto badarity;
    }
#line 550
    configSetCommand(c);
  }
#line 566
  return;
  badarity: 
#line 569
  addReplyErrorFormat(c, "Wrong number of arguments for CONFIG %s", (char *)(*(c->argv + 1))->ptr);
#line 571
  return;
}
}
#line 1 "aof.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-YhyQnJ8V.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 221 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int feof(FILE *fp ) ;
#line 734 "redis.h"
int fwriteBulkString(FILE *fp , char *s , unsigned long len ) ;
#line 735
int fwriteBulkDouble(FILE *fp , double d ) ;
#line 736
int fwriteBulkLongLong(FILE *fp , long long l ) ;
#line 737
int fwriteBulkObject(FILE *fp , robj *obj ) ;
#line 765
void aofRemoveTempFile(pid_t childpid ) ;
#line 13 "aof.c"
void stopAppendOnly(void) 
{ int statloc ;
  int __cil_tmp ;

  {
#line 14
  flushAppendOnlyFile();
#line 15
  fsync(server.appendfd);
#line 16
  close(server.appendfd);
#line 18
  server.appendfd = -1;
#line 19
  server.appendseldb = -1;
#line 20
  server.appendonly = 0;
#line 22
  if (server.bgsavechildpid != -1) {
#line 25
    __cil_tmp = kill(server.bgsavechildpid, 9);
#line 25
    if (__cil_tmp != -1) {
#line 26
      wait3(& statloc, 0, (void *)0);
    }
#line 28
    sdsfree(server.bgrewritebuf);
#line 29
    server.bgrewritebuf = sdsempty();
#line 30
    server.bgsavechildpid = -1;
  }
#line 32
  return;
}
}
#line 36 "aof.c"
int startAppendOnly(void) 
{ int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 37
  server.appendonly = 1;
#line 38
  server.lastfsync = time((time_t *)((void *)0));
#line 39
  server.appendfd = open((char const   *)server.appendfilename, 70, 420);
#line 40
  if (server.appendfd == -1) {
#line 41
    __cil_tmp = __errno();
#line 41
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 41
    redisLog(3, "Used tried to switch on AOF via CONFIG, but I can\'t open the AOF file: %s",
             __cil_tmp___0);
#line 42
    return (-1);
  }
#line 44
  __cil_tmp___3 = rewriteAppendOnlyFileBackground();
#line 44
  if (__cil_tmp___3 == -1) {
#line 45
    server.appendonly = 0;
#line 46
    close(server.appendfd);
#line 47
    __cil_tmp___1 = __errno();
#line 47
    __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 47
    redisLog(3, "Used tried to switch on AOF via CONFIG, I can\'t trigger a background AOF rewrite operation. Check the above logs for more info about the error.",
             __cil_tmp___2);
#line 48
    return (-1);
  }
#line 50
  return (0);
}
}
#line 60 "aof.c"
void flushAppendOnlyFile(void) 
{ time_t now ;
  ssize_t nwritten ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  size_t __cil_tmp___5 ;

  {
#line 64
  __cil_tmp = sdslen(server.aofbuf);
#line 64
  if (__cil_tmp == 0U) {
#line 64
    return;
  }
#line 71
  __cil_tmp___0 = sdslen(server.aofbuf);
#line 71
  nwritten = write(server.appendfd, (void const   *)server.aofbuf, __cil_tmp___0);
#line 72
  __cil_tmp___5 = sdslen(server.aofbuf);
#line 72
  if (nwritten != (int )__cil_tmp___5) {
#line 76
    if (nwritten == -1) {
#line 77
      __cil_tmp___1 = __errno();
#line 77
      __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 77
      redisLog(3, "Exiting on error writing to the append-only file: %s", __cil_tmp___2);
    } else {
#line 79
      __cil_tmp___3 = __errno();
#line 79
      __cil_tmp___4 = strerror(*__cil_tmp___3);
#line 79
      redisLog(3, "Exiting on short write while writing to the append-only file: %s",
               __cil_tmp___4);
    }
#line 81
    exit(1);
  }
#line 83
  sdsfree(server.aofbuf);
#line 84
  server.aofbuf = sdsempty();
#line 88
  if (server.no_appendfsync_on_rewrite && (server.bgrewritechildpid != -1 || server.bgsavechildpid != -1)) {
#line 90
    return;
  }
#line 92
  now = time((time_t *)((void *)0));
#line 93
  if (server.appendfsync == 1 || (server.appendfsync == 2 && now - server.lastfsync > 1L)) {
#line 99
    fsync(server.appendfd);
#line 100
    server.lastfsync = now;
  }
#line 102
  return;
}
}
#line 104 "aof.c"
sds catAppendOnlyGenericCommand(sds buf , int argc , robj **argv ) 
{ int j ;
  robj *o ;
  robj *__cil_tmp ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 106
  buf = sdscatprintf(buf, "*%d\r\n", argc);
#line 107
  j = 0;
#line 107
  while (j < argc) {
#line 108
    __cil_tmp = getDecodedObject(*(argv + j));
#line 108
    o = __cil_tmp;
#line 109
    __cil_tmp___0 = sdslen((char *)o->ptr);
#line 109
    buf = sdscatprintf(buf, "$%lu\r\n", (unsigned long )__cil_tmp___0);
#line 110
    __cil_tmp___1 = sdslen((char *)o->ptr);
#line 110
    buf = sdscatlen(buf, o->ptr, __cil_tmp___1);
#line 111
    buf = sdscatlen(buf, (void *)"\r\n", 2U);
#line 112
    decrRefCount((void *)o);
#line 107
    j ++;
  }
#line 114
  return (buf);
}
}
#line 117 "aof.c"
sds catAppendOnlyExpireAtCommand(sds buf , robj *key , robj *seconds ) 
{ int argc ;
  long when ;
  robj *argv[3] ;
  time_t __cil_tmp ;
  long __cil_tmp___0 ;
  sds __cil_tmp___1 ;
  sds __cil_tmp___2 ;

  {
#line 118
  argc = 3;
#line 123
  seconds = getDecodedObject(seconds);
#line 124
  __cil_tmp = time((time_t *)((void *)0));
#line 124
  __cil_tmp___0 = strtol((char const   *)seconds->ptr, (char **)((void *)0), 10);
#line 124
  when = __cil_tmp + __cil_tmp___0;
#line 125
  decrRefCount((void *)seconds);
#line 127
  argv[0] = createStringObject((char *)"EXPIREAT", 8U);
#line 128
  argv[1] = key;
#line 129
  __cil_tmp___1 = sdsempty();
#line 129
  __cil_tmp___2 = sdscatprintf(__cil_tmp___1, "%ld", when);
#line 129
  argv[2] = createObject(0, (void *)__cil_tmp___2);
#line 131
  buf = catAppendOnlyGenericCommand(buf, argc, argv);
#line 132
  decrRefCount((void *)argv[0]);
#line 133
  decrRefCount((void *)argv[2]);
#line 134
  return (buf);
}
}
#line 137 "aof.c"
void feedAppendOnlyFile(struct redisCommand *cmd , int dictid , robj **argv , int argc ) 
{ sds buf ;
  sds __cil_tmp ;
  robj *tmpargv[3] ;
  char seldb[64] ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 138
  __cil_tmp = sdsempty();
#line 138
  buf = __cil_tmp;
#line 143
  if (dictid != server.appendseldb) {
#line 146
    snprintf(seldb, (unsigned int )sizeof(seldb), "%d", dictid);
#line 147
    __cil_tmp___0 = strlen((char const   *)(seldb));
#line 147
    buf = sdscatprintf(buf, "*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n", (unsigned long )__cil_tmp___0,
                       seldb);
#line 149
    server.appendseldb = dictid;
  }
#line 152
  if ((unsigned int )cmd->proc == (unsigned int )(& expireCommand)) {
#line 154
    buf = catAppendOnlyExpireAtCommand(buf, *(argv + 1), *(argv + 2));
  } else
#line 155
  if ((unsigned int )cmd->proc == (unsigned int )(& setexCommand)) {
#line 157
    tmpargv[0] = createStringObject((char *)"SET", 3U);
#line 158
    tmpargv[1] = *(argv + 1);
#line 159
    tmpargv[2] = *(argv + 3);
#line 160
    buf = catAppendOnlyGenericCommand(buf, 3, tmpargv);
#line 161
    decrRefCount((void *)tmpargv[0]);
#line 162
    buf = catAppendOnlyExpireAtCommand(buf, *(argv + 1), *(argv + 2));
  } else {
#line 164
    buf = catAppendOnlyGenericCommand(buf, argc, argv);
  }
#line 170
  __cil_tmp___1 = sdslen(buf);
#line 170
  server.aofbuf = sdscatlen(server.aofbuf, (void *)buf, __cil_tmp___1);
#line 176
  if (server.bgrewritechildpid != -1) {
#line 177
    __cil_tmp___2 = sdslen(buf);
#line 177
    server.bgrewritebuf = sdscatlen(server.bgrewritebuf, (void *)buf, __cil_tmp___2);
  }
#line 179
  sdsfree(buf);
#line 180
  return;
}
}
#line 184 "aof.c"
struct redisClient *createFakeClient(void) 
{ struct redisClient *c ;
  void *__cil_tmp ;

  {
#line 185
  __cil_tmp = malloc((unsigned int )sizeof(*c));
#line 185
  c = (struct redisClient *)__cil_tmp;
#line 187
  selectDb(c, 0);
#line 188
  c->fd = -1;
#line 189
  c->querybuf = sdsempty();
#line 190
  c->argc = 0;
#line 191
  c->argv = (robj **)((void *)0);
#line 192
  c->bufpos = 0;
#line 193
  c->flags = 0;
#line 196
  c->replstate = 3;
#line 197
  c->reply = listCreate();
#line 198
  c->watched_keys = listCreate();
#line 199
  (c->reply)->free = & decrRefCount;
#line 200
  (c->reply)->dup = & dupClientReplyValue;
#line 201
  initClientMultiState(c);
#line 202
  return (c);
}
}
#line 205 "aof.c"
void freeFakeClient(struct redisClient *c ) 
{ 

  {
#line 206
  sdsfree(c->querybuf);
#line 207
  listRelease(c->reply);
#line 208
  listRelease(c->watched_keys);
#line 209
  freeClientMultiState(c);
#line 210
  free((void *)c);
#line 211
  return;
}
}
#line 216 "aof.c"
int loadAppendOnlyFile(char *filename ) 
{ struct redisClient *fakeClient ;
  FILE *fp ;
  FILE *__cil_tmp ;
  struct stat sb ;
  int appendonly ;
  long loops ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  int argc ;
  int j ;
  unsigned long len ;
  robj **argv ;
  char buf[128] ;
  sds argsds ;
  struct redisCommand *cmd ;
  int force_swapout ;
  off_t __cil_tmp___4 ;
  long __cil_tmp___5 ;
  int __cil_tmp___6 ;
  char *__cil_tmp___7 ;
  void *__cil_tmp___8 ;
  char *__cil_tmp___9 ;
  long __cil_tmp___10 ;
  size_t __cil_tmp___11 ;
  size_t __cil_tmp___12 ;
  size_t __cil_tmp___13 ;
  int __cil_tmp___14 ;
  size_t __cil_tmp___15 ;
  int *__cil_tmp___16 ;
  char *__cil_tmp___17 ;
  int __cil_tmp___18 ;

  {
#line 218
  __cil_tmp = fopen((char const   *)filename, "r");
#line 218
  fp = __cil_tmp;
#line 220
  appendonly = server.appendonly;
#line 221
  loops = 0L;
#line 223
  __cil_tmp___0 = fileno(fp);
#line 223
  __cil_tmp___1 = fstat(__cil_tmp___0, & sb);
#line 223
  if (__cil_tmp___1 != -1 && sb.st_size == 0L) {
#line 224
    return (-1);
  }
#line 226
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 227
    __cil_tmp___2 = __errno();
#line 227
    __cil_tmp___3 = strerror(*__cil_tmp___2);
#line 227
    redisLog(3, "Fatal error: can\'t open the append log file for reading: %s", __cil_tmp___3);
#line 228
    exit(1);
  }
#line 233
  server.appendonly = 0;
#line 235
  fakeClient = createFakeClient();
#line 236
  startLoading(fp);
#line 238
  while (1) {
#line 248
    __cil_tmp___5 = loops;
#line 248
    loops ++;
#line 248
    if (! (__cil_tmp___5 % 1000L)) {
#line 249
      __cil_tmp___4 = ftello(fp);
#line 249
      loadingProgress(__cil_tmp___4);
#line 250
      aeProcessEvents(server.el, 5);
    }
#line 253
    __cil_tmp___7 = fgets(buf, (int )sizeof(buf), fp);
#line 253
    if ((unsigned int )__cil_tmp___7 == (unsigned int )((void *)0)) {
#line 254
      __cil_tmp___6 = feof(fp);
#line 254
      if (__cil_tmp___6) {
#line 255
        break;
      } else {
#line 257
        goto readerr;
      }
    }
#line 259
    if ((int )buf[0] != 42) {
#line 259
      goto fmterr;
    }
#line 260
    argc = atoi((char const   *)(buf + 1));
#line 261
    __cil_tmp___8 = malloc((unsigned int )(sizeof(robj *) * (unsigned long )argc));
#line 261
    argv = (robj **)__cil_tmp___8;
#line 262
    j = 0;
#line 262
    while (j < argc) {
#line 263
      __cil_tmp___9 = fgets(buf, (int )sizeof(buf), fp);
#line 263
      if ((unsigned int )__cil_tmp___9 == (unsigned int )((void *)0)) {
#line 263
        goto readerr;
      }
#line 264
      if ((int )buf[0] != 36) {
#line 264
        goto fmterr;
      }
#line 265
      __cil_tmp___10 = strtol((char const   *)(buf + 1), (char **)((void *)0), 10);
#line 265
      len = (unsigned long )__cil_tmp___10;
#line 266
      argsds = sdsnewlen((void const   *)((void *)0), (unsigned int )len);
#line 267
      if (len) {
#line 267
        __cil_tmp___11 = fread((void *)argsds, (unsigned int )len, 1U, fp);
#line 267
        if (__cil_tmp___11 == 0U) {
#line 267
          goto fmterr;
        }
      }
#line 268
      *(argv + j) = createObject(0, (void *)argsds);
#line 269
      __cil_tmp___12 = fread((void *)(buf), 2U, 1U, fp);
#line 269
      if (__cil_tmp___12 == 0U) {
#line 269
        goto fmterr;
      }
#line 262
      j ++;
    }
#line 273
    cmd = lookupCommand((char *)(*(argv + 0))->ptr);
#line 274
    if (! cmd) {
#line 275
      redisLog(3, "Unknown command \'%s\' reading the append only file", (*(argv + 0))->ptr);
#line 276
      exit(1);
    }
#line 279
    fakeClient->argc = argc;
#line 280
    fakeClient->argv = argv;
#line 281
    (*(cmd->proc))(fakeClient);
#line 284
    if (! (fakeClient->bufpos == 0 && (fakeClient->reply)->len == 0U)) {
#line 284
      _redisAssert((char *)"fakeClient->bufpos == 0 && listLength(fakeClient->reply) == 0",
                   (char *)"aof.c", 284);
#line 284
      _exit(1);
    }
#line 287
    j = 0;
#line 287
    while (j < argc) {
#line 287
      decrRefCount((void *)*(argv + j));
#line 287
      j ++;
    }
#line 288
    free((void *)argv);
#line 291
    force_swapout = 0;
#line 292
    __cil_tmp___13 = zmalloc_used_memory();
#line 292
    if ((unsigned long long )__cil_tmp___13 - server.vm_max_memory > 33554432ULL) {
#line 293
      force_swapout = 1;
    }
#line 295
    if (server.vm_enabled && force_swapout) {
#line 296
      while (1) {
#line 296
        __cil_tmp___15 = zmalloc_used_memory();
#line 296
        if (! ((unsigned long long )__cil_tmp___15 > server.vm_max_memory)) {
#line 296
          break;
        }
#line 297
        __cil_tmp___14 = vmSwapOneObjectBlocking();
#line 297
        if (__cil_tmp___14 == -1) {
#line 297
          break;
        }
      }
    }
  }
#line 304
  if (fakeClient->flags & 8) {
#line 304
    goto readerr;
  }
#line 306
  fclose(fp);
#line 307
  freeFakeClient(fakeClient);
#line 308
  server.appendonly = appendonly;
#line 309
  stopLoading();
#line 310
  return (0);
  readerr: 
#line 313
  __cil_tmp___18 = feof(fp);
#line 313
  if (__cil_tmp___18) {
#line 314
    redisLog(3, "Unexpected end of file reading the append only file");
  } else {
#line 316
    __cil_tmp___16 = __errno();
#line 316
    __cil_tmp___17 = strerror(*__cil_tmp___16);
#line 316
    redisLog(3, "Unrecoverable error reading the append only file: %s", __cil_tmp___17);
  }
#line 318
  exit(1);
  fmterr: 
#line 320
  redisLog(3, "Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix <filename>");
#line 321
  exit(1);
}
}
#line 326 "aof.c"
int rewriteAppendOnlyFile(char *filename ) 
{ dictIterator *di ;
  dictEntry *de ;
  FILE *fp ;
  char tmpfile___0[256] ;
  int j ;
  time_t now ;
  time_t __cil_tmp ;
  pid_t __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  char selectcmd[17] ;
  redisDb *db ;
  dict *d ;
  size_t __cil_tmp___3 ;
  int __cil_tmp___4 ;
  sds keystr ;
  robj key ;
  robj *o ;
  time_t expiretime ;
  int swapped ;
  char cmd[14] ;
  size_t __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  char cmd___0[16] ;
  unsigned char *zl ;
  unsigned char *p ;
  unsigned char *__cil_tmp___8 ;
  unsigned char *vstr ;
  unsigned int vlen ;
  long long vlong ;
  size_t __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  unsigned int __cil_tmp___13 ;
  list *list___0 ;
  listNode *ln ;
  listIter li ;
  robj *eleobj ;
  size_t __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  char cmd___1[15] ;
  int ii ;
  int64_t llval ;
  size_t __cil_tmp___17 ;
  int __cil_tmp___18 ;
  int __cil_tmp___19 ;
  int __cil_tmp___20 ;
  uint8_t __cil_tmp___21 ;
  dictIterator *di___0 ;
  dictIterator *__cil_tmp___22 ;
  dictEntry *de___0 ;
  robj *eleobj___0 ;
  size_t __cil_tmp___23 ;
  int __cil_tmp___24 ;
  int __cil_tmp___25 ;
  zset *zs ;
  dictIterator *di___1 ;
  dictIterator *__cil_tmp___26 ;
  dictEntry *de___1 ;
  char cmd___2[15] ;
  robj *eleobj___1 ;
  double *score ;
  size_t __cil_tmp___27 ;
  int __cil_tmp___28 ;
  int __cil_tmp___29 ;
  int __cil_tmp___30 ;
  char cmd___3[15] ;
  unsigned char *p___0 ;
  unsigned char *__cil_tmp___31 ;
  unsigned char *field ;
  unsigned char *val ;
  unsigned int flen ;
  unsigned int vlen___0 ;
  size_t __cil_tmp___32 ;
  int __cil_tmp___33 ;
  int __cil_tmp___34 ;
  int __cil_tmp___35 ;
  dictIterator *di___2 ;
  dictIterator *__cil_tmp___36 ;
  dictEntry *de___2 ;
  robj *field___0 ;
  robj *val___0 ;
  size_t __cil_tmp___37 ;
  int __cil_tmp___38 ;
  int __cil_tmp___39 ;
  int __cil_tmp___40 ;
  char cmd___4[19] ;
  size_t __cil_tmp___41 ;
  int __cil_tmp___42 ;
  int __cil_tmp___43 ;
  int __cil_tmp___44 ;
  int *__cil_tmp___45 ;
  char *__cil_tmp___46 ;
  int __cil_tmp___47 ;
  int *__cil_tmp___48 ;
  char *__cil_tmp___49 ;

  {
#line 327
  di = (dictIterator *)((void *)0);
#line 332
  __cil_tmp = time((time_t *)((void *)0));
#line 332
  now = __cil_tmp;
#line 336
  __cil_tmp___0 = getpid();
#line 336
  snprintf(tmpfile___0, 256U, "temp-rewriteaof-%d.aof", __cil_tmp___0);
#line 337
  fp = fopen((char const   *)(tmpfile___0), "w");
#line 338
  if (! fp) {
#line 339
    __cil_tmp___1 = __errno();
#line 339
    __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 339
    redisLog(3, "Failed rewriting the append only file: %s", __cil_tmp___2);
#line 340
    return (-1);
  }
#line 342
  j = 0;
#line 342
  while (j < server.dbnum) {
#line 343
    selectcmd[0] = (char )'*';
#line 343
    selectcmd[1] = (char )'2';
#line 343
    selectcmd[2] = (char )'\r';
#line 343
    selectcmd[3] = (char )'\n';
#line 343
    selectcmd[4] = (char )'$';
#line 343
    selectcmd[5] = (char )'6';
#line 343
    selectcmd[6] = (char )'\r';
#line 343
    selectcmd[7] = (char )'\n';
#line 343
    selectcmd[8] = (char )'S';
#line 343
    selectcmd[9] = (char )'E';
#line 343
    selectcmd[10] = (char )'L';
#line 343
    selectcmd[11] = (char )'E';
#line 343
    selectcmd[12] = (char )'C';
#line 343
    selectcmd[13] = (char )'T';
#line 343
    selectcmd[14] = (char )'\r';
#line 343
    selectcmd[15] = (char )'\n';
#line 343
    selectcmd[16] = (char )'\000';
#line 344
    db = server.db + j;
#line 345
    d = db->dict;
#line 346
    if (d->ht[0].used + d->ht[1].used == 0UL) {
#line 346
      goto __Cont;
    }
#line 347
    di = dictGetIterator(d);
#line 348
    if (! di) {
#line 349
      fclose(fp);
#line 350
      return (-1);
    }
#line 354
    __cil_tmp___3 = fwrite((void const   *)(selectcmd), (unsigned int )(sizeof(selectcmd) - 1UL),
                           1U, fp);
#line 354
    if (__cil_tmp___3 == 0U) {
#line 354
      goto werr;
    }
#line 355
    __cil_tmp___4 = fwriteBulkLongLong(fp, (long long )j);
#line 355
    if (__cil_tmp___4 == 0) {
#line 355
      goto werr;
    }
#line 358
    while (1) {
#line 358
      de = dictNext(di);
#line 358
      if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 358
        break;
      }
#line 359
      keystr = (char *)de->key;
#line 364
      keystr = (char *)de->key;
#line 365
      o = (robj *)de->val;
#line 366
      while (1) {
#line 366
        key.refcount = 1;
#line 366
        key.type = 0U;
#line 366
        key.encoding = 0U;
#line 366
        key.ptr = (void *)keystr;
#line 366
        key.storage = 0U;
#line 366
        break;
      }
#line 371
      if ((! server.vm_enabled || o->storage == 0U) || o->storage == 2U) {
#line 373
        swapped = 0;
      } else {
#line 375
        o = vmPreviewObject(o);
#line 376
        swapped = 1;
      }
#line 378
      expiretime = getExpire(db, & key);
#line 381
      if (o->type == 0U) {
#line 383
        cmd[0] = (char )'*';
#line 383
        cmd[1] = (char )'3';
#line 383
        cmd[2] = (char )'\r';
#line 383
        cmd[3] = (char )'\n';
#line 383
        cmd[4] = (char )'$';
#line 383
        cmd[5] = (char )'3';
#line 383
        cmd[6] = (char )'\r';
#line 383
        cmd[7] = (char )'\n';
#line 383
        cmd[8] = (char )'S';
#line 383
        cmd[9] = (char )'E';
#line 383
        cmd[10] = (char )'T';
#line 383
        cmd[11] = (char )'\r';
#line 383
        cmd[12] = (char )'\n';
#line 383
        cmd[13] = (char )'\000';
#line 384
        __cil_tmp___5 = fwrite((void const   *)(cmd), (unsigned int )(sizeof(cmd) - 1UL),
                               1U, fp);
#line 384
        if (__cil_tmp___5 == 0U) {
#line 384
          goto werr;
        }
#line 386
        __cil_tmp___6 = fwriteBulkObject(fp, & key);
#line 386
        if (__cil_tmp___6 == 0) {
#line 386
          goto werr;
        }
#line 387
        __cil_tmp___7 = fwriteBulkObject(fp, o);
#line 387
        if (__cil_tmp___7 == 0) {
#line 387
          goto werr;
        }
      } else
#line 388
      if (o->type == 1U) {
#line 390
        cmd___0[0] = (char )'*';
#line 390
        cmd___0[1] = (char )'3';
#line 390
        cmd___0[2] = (char )'\r';
#line 390
        cmd___0[3] = (char )'\n';
#line 390
        cmd___0[4] = (char )'$';
#line 390
        cmd___0[5] = (char )'5';
#line 390
        cmd___0[6] = (char )'\r';
#line 390
        cmd___0[7] = (char )'\n';
#line 390
        cmd___0[8] = (char )'R';
#line 390
        cmd___0[9] = (char )'P';
#line 390
        cmd___0[10] = (char )'U';
#line 390
        cmd___0[11] = (char )'S';
#line 390
        cmd___0[12] = (char )'H';
#line 390
        cmd___0[13] = (char )'\r';
#line 390
        cmd___0[14] = (char )'\n';
#line 390
        cmd___0[15] = (char )'\000';
#line 391
        if (o->encoding == 5U) {
#line 392
          zl = (unsigned char *)o->ptr;
#line 393
          __cil_tmp___8 = ziplistIndex(zl, 0);
#line 393
          p = __cil_tmp___8;
#line 398
          while (1) {
#line 398
            __cil_tmp___13 = ziplistGet(p, & vstr, & vlen, & vlong);
#line 398
            if (! __cil_tmp___13) {
#line 398
              break;
            }
#line 399
            __cil_tmp___9 = fwrite((void const   *)(cmd___0), (unsigned int )(sizeof(cmd___0) - 1UL),
                                   1U, fp);
#line 399
            if (__cil_tmp___9 == 0U) {
#line 399
              goto werr;
            }
#line 400
            __cil_tmp___10 = fwriteBulkObject(fp, & key);
#line 400
            if (__cil_tmp___10 == 0) {
#line 400
              goto werr;
            }
#line 401
            if (vstr) {
#line 402
              __cil_tmp___11 = fwriteBulkString(fp, (char *)vstr, (unsigned long )vlen);
#line 402
              if (__cil_tmp___11 == 0) {
#line 403
                goto werr;
              }
            } else {
#line 405
              __cil_tmp___12 = fwriteBulkLongLong(fp, vlong);
#line 405
              if (__cil_tmp___12 == 0) {
#line 406
                goto werr;
              }
            }
#line 408
            p = ziplistNext(zl, p);
          }
        } else
#line 410
        if (o->encoding == 4U) {
#line 411
          list___0 = (list *)o->ptr;
#line 415
          listRewind(list___0, & li);
#line 416
          while (1) {
#line 416
            ln = listNext(& li);
#line 416
            if (! ln) {
#line 416
              break;
            }
#line 417
            eleobj = (robj *)ln->value;
#line 419
            __cil_tmp___14 = fwrite((void const   *)(cmd___0), (unsigned int )(sizeof(cmd___0) - 1UL),
                                    1U, fp);
#line 419
            if (__cil_tmp___14 == 0U) {
#line 419
              goto werr;
            }
#line 420
            __cil_tmp___15 = fwriteBulkObject(fp, & key);
#line 420
            if (__cil_tmp___15 == 0) {
#line 420
              goto werr;
            }
#line 421
            __cil_tmp___16 = fwriteBulkObject(fp, eleobj);
#line 421
            if (__cil_tmp___16 == 0) {
#line 421
              goto werr;
            }
          }
        } else {
#line 424
          _redisPanic((char *)"\"Unknown list encoding\"", (char *)"aof.c", 424);
#line 424
          _exit(1);
        }
      } else
#line 426
      if (o->type == 2U) {
#line 427
        cmd___1[0] = (char )'*';
#line 427
        cmd___1[1] = (char )'3';
#line 427
        cmd___1[2] = (char )'\r';
#line 427
        cmd___1[3] = (char )'\n';
#line 427
        cmd___1[4] = (char )'$';
#line 427
        cmd___1[5] = (char )'4';
#line 427
        cmd___1[6] = (char )'\r';
#line 427
        cmd___1[7] = (char )'\n';
#line 427
        cmd___1[8] = (char )'S';
#line 427
        cmd___1[9] = (char )'A';
#line 427
        cmd___1[10] = (char )'D';
#line 427
        cmd___1[11] = (char )'D';
#line 427
        cmd___1[12] = (char )'\r';
#line 427
        cmd___1[13] = (char )'\n';
#line 427
        cmd___1[14] = (char )'\000';
#line 430
        if (o->encoding == 6U) {
#line 431
          ii = 0;
#line 433
          while (1) {
#line 433
            __cil_tmp___20 = ii;
#line 433
            ii ++;
#line 433
            __cil_tmp___21 = intsetGet((intset *)o->ptr, (unsigned long )__cil_tmp___20,
                                       & llval);
#line 433
            if (! __cil_tmp___21) {
#line 433
              break;
            }
#line 434
            __cil_tmp___17 = fwrite((void const   *)(cmd___1), (unsigned int )(sizeof(cmd___1) - 1UL),
                                    1U, fp);
#line 434
            if (__cil_tmp___17 == 0U) {
#line 434
              goto werr;
            }
#line 435
            __cil_tmp___18 = fwriteBulkObject(fp, & key);
#line 435
            if (__cil_tmp___18 == 0) {
#line 435
              goto werr;
            }
#line 436
            __cil_tmp___19 = fwriteBulkLongLong(fp, llval);
#line 436
            if (__cil_tmp___19 == 0) {
#line 436
              goto werr;
            }
          }
        } else
#line 438
        if (o->encoding == 2U) {
#line 439
          __cil_tmp___22 = dictGetIterator((dict *)o->ptr);
#line 439
          di___0 = __cil_tmp___22;
#line 441
          while (1) {
#line 441
            de___0 = dictNext(di___0);
#line 441
            if (! ((unsigned int )de___0 != (unsigned int )((void *)0))) {
#line 441
              break;
            }
#line 442
            eleobj___0 = (robj *)de___0->key;
#line 443
            __cil_tmp___23 = fwrite((void const   *)(cmd___1), (unsigned int )(sizeof(cmd___1) - 1UL),
                                    1U, fp);
#line 443
            if (__cil_tmp___23 == 0U) {
#line 443
              goto werr;
            }
#line 444
            __cil_tmp___24 = fwriteBulkObject(fp, & key);
#line 444
            if (__cil_tmp___24 == 0) {
#line 444
              goto werr;
            }
#line 445
            __cil_tmp___25 = fwriteBulkObject(fp, eleobj___0);
#line 445
            if (__cil_tmp___25 == 0) {
#line 445
              goto werr;
            }
          }
#line 447
          dictReleaseIterator(di___0);
        } else {
#line 449
          _redisPanic((char *)"\"Unknown set encoding\"", (char *)"aof.c", 449);
#line 449
          _exit(1);
        }
      } else
#line 451
      if (o->type == 3U) {
#line 453
        zs = (zset *)o->ptr;
#line 454
        __cil_tmp___26 = dictGetIterator(zs->dict);
#line 454
        di___1 = __cil_tmp___26;
#line 457
        while (1) {
#line 457
          de___1 = dictNext(di___1);
#line 457
          if (! ((unsigned int )de___1 != (unsigned int )((void *)0))) {
#line 457
            break;
          }
#line 458
          cmd___2[0] = (char )'*';
#line 458
          cmd___2[1] = (char )'4';
#line 458
          cmd___2[2] = (char )'\r';
#line 458
          cmd___2[3] = (char )'\n';
#line 458
          cmd___2[4] = (char )'$';
#line 458
          cmd___2[5] = (char )'4';
#line 458
          cmd___2[6] = (char )'\r';
#line 458
          cmd___2[7] = (char )'\n';
#line 458
          cmd___2[8] = (char )'Z';
#line 458
          cmd___2[9] = (char )'A';
#line 458
          cmd___2[10] = (char )'D';
#line 458
          cmd___2[11] = (char )'D';
#line 458
          cmd___2[12] = (char )'\r';
#line 458
          cmd___2[13] = (char )'\n';
#line 458
          cmd___2[14] = (char )'\000';
#line 459
          eleobj___1 = (robj *)de___1->key;
#line 460
          score = (double *)de___1->val;
#line 462
          __cil_tmp___27 = fwrite((void const   *)(cmd___2), (unsigned int )(sizeof(cmd___2) - 1UL),
                                  1U, fp);
#line 462
          if (__cil_tmp___27 == 0U) {
#line 462
            goto werr;
          }
#line 463
          __cil_tmp___28 = fwriteBulkObject(fp, & key);
#line 463
          if (__cil_tmp___28 == 0) {
#line 463
            goto werr;
          }
#line 464
          __cil_tmp___29 = fwriteBulkDouble(fp, *score);
#line 464
          if (__cil_tmp___29 == 0) {
#line 464
            goto werr;
          }
#line 465
          __cil_tmp___30 = fwriteBulkObject(fp, eleobj___1);
#line 465
          if (__cil_tmp___30 == 0) {
#line 465
            goto werr;
          }
        }
#line 467
        dictReleaseIterator(di___1);
      } else
#line 468
      if (o->type == 4U) {
#line 469
        cmd___3[0] = (char )'*';
#line 469
        cmd___3[1] = (char )'4';
#line 469
        cmd___3[2] = (char )'\r';
#line 469
        cmd___3[3] = (char )'\n';
#line 469
        cmd___3[4] = (char )'$';
#line 469
        cmd___3[5] = (char )'4';
#line 469
        cmd___3[6] = (char )'\r';
#line 469
        cmd___3[7] = (char )'\n';
#line 469
        cmd___3[8] = (char )'H';
#line 469
        cmd___3[9] = (char )'S';
#line 469
        cmd___3[10] = (char )'E';
#line 469
        cmd___3[11] = (char )'T';
#line 469
        cmd___3[12] = (char )'\r';
#line 469
        cmd___3[13] = (char )'\n';
#line 469
        cmd___3[14] = (char )'\000';
#line 472
        if (o->encoding == 3U) {
#line 473
          __cil_tmp___31 = zipmapRewind((unsigned char *)o->ptr);
#line 473
          p___0 = __cil_tmp___31;
#line 477
          while (1) {
#line 477
            p___0 = zipmapNext(p___0, & field, & flen, & val, & vlen___0);
#line 477
            if (! ((unsigned int )p___0 != (unsigned int )((void *)0))) {
#line 477
              break;
            }
#line 478
            __cil_tmp___32 = fwrite((void const   *)(cmd___3), (unsigned int )(sizeof(cmd___3) - 1UL),
                                    1U, fp);
#line 478
            if (__cil_tmp___32 == 0U) {
#line 478
              goto werr;
            }
#line 479
            __cil_tmp___33 = fwriteBulkObject(fp, & key);
#line 479
            if (__cil_tmp___33 == 0) {
#line 479
              goto werr;
            }
#line 480
            __cil_tmp___34 = fwriteBulkString(fp, (char *)field, (unsigned long )flen);
#line 480
            if (__cil_tmp___34 == 0) {
#line 481
              goto werr;
            }
#line 482
            __cil_tmp___35 = fwriteBulkString(fp, (char *)val, (unsigned long )vlen___0);
#line 482
            if (__cil_tmp___35 == 0) {
#line 483
              goto werr;
            }
          }
        } else {
#line 486
          __cil_tmp___36 = dictGetIterator((dict *)o->ptr);
#line 486
          di___2 = __cil_tmp___36;
#line 489
          while (1) {
#line 489
            de___2 = dictNext(di___2);
#line 489
            if (! ((unsigned int )de___2 != (unsigned int )((void *)0))) {
#line 489
              break;
            }
#line 490
            field___0 = (robj *)de___2->key;
#line 491
            val___0 = (robj *)de___2->val;
#line 493
            __cil_tmp___37 = fwrite((void const   *)(cmd___3), (unsigned int )(sizeof(cmd___3) - 1UL),
                                    1U, fp);
#line 493
            if (__cil_tmp___37 == 0U) {
#line 493
              goto werr;
            }
#line 494
            __cil_tmp___38 = fwriteBulkObject(fp, & key);
#line 494
            if (__cil_tmp___38 == 0) {
#line 494
              goto werr;
            }
#line 495
            __cil_tmp___39 = fwriteBulkObject(fp, field___0);
#line 495
            if (__cil_tmp___39 == 0) {
#line 495
              goto werr;
            }
#line 496
            __cil_tmp___40 = fwriteBulkObject(fp, val___0);
#line 496
            if (__cil_tmp___40 == 0) {
#line 496
              goto werr;
            }
          }
#line 498
          dictReleaseIterator(di___2);
        }
      } else {
#line 501
        _redisPanic((char *)"\"Unknown object type\"", (char *)"aof.c", 501);
#line 501
        _exit(1);
      }
#line 504
      if (expiretime != -1L) {
#line 505
        cmd___4[0] = (char )'*';
#line 505
        cmd___4[1] = (char )'3';
#line 505
        cmd___4[2] = (char )'\r';
#line 505
        cmd___4[3] = (char )'\n';
#line 505
        cmd___4[4] = (char )'$';
#line 505
        cmd___4[5] = (char )'8';
#line 505
        cmd___4[6] = (char )'\r';
#line 505
        cmd___4[7] = (char )'\n';
#line 505
        cmd___4[8] = (char )'E';
#line 505
        cmd___4[9] = (char )'X';
#line 505
        cmd___4[10] = (char )'P';
#line 505
        cmd___4[11] = (char )'I';
#line 505
        cmd___4[12] = (char )'R';
#line 505
        cmd___4[13] = (char )'E';
#line 505
        cmd___4[14] = (char )'A';
#line 505
        cmd___4[15] = (char )'T';
#line 505
        cmd___4[16] = (char )'\r';
#line 505
        cmd___4[17] = (char )'\n';
#line 505
        cmd___4[18] = (char )'\000';
#line 507
        if (expiretime < now) {
#line 507
          continue;
        }
#line 508
        __cil_tmp___41 = fwrite((void const   *)(cmd___4), (unsigned int )(sizeof(cmd___4) - 1UL),
                                1U, fp);
#line 508
        if (__cil_tmp___41 == 0U) {
#line 508
          goto werr;
        }
#line 509
        __cil_tmp___42 = fwriteBulkObject(fp, & key);
#line 509
        if (__cil_tmp___42 == 0) {
#line 509
          goto werr;
        }
#line 510
        __cil_tmp___43 = fwriteBulkLongLong(fp, (long long )expiretime);
#line 510
        if (__cil_tmp___43 == 0) {
#line 510
          goto werr;
        }
      }
#line 512
      if (swapped) {
#line 512
        decrRefCount((void *)o);
      }
    }
#line 514
    dictReleaseIterator(di);
    __Cont: 
#line 342
    j ++;
  }
#line 518
  fflush(fp);
#line 519
  __cil_tmp___44 = fileno(fp);
#line 519
  fsync(__cil_tmp___44);
#line 520
  fclose(fp);
#line 524
  __cil_tmp___47 = rename((char const   *)(tmpfile___0), (char const   *)filename);
#line 524
  if (__cil_tmp___47 == -1) {
#line 525
    __cil_tmp___45 = __errno();
#line 525
    __cil_tmp___46 = strerror(*__cil_tmp___45);
#line 525
    redisLog(3, "Error moving temp append only file on the final destination: %s",
             __cil_tmp___46);
#line 526
    unlink((char const   *)(tmpfile___0));
#line 527
    return (-1);
  }
#line 529
  redisLog(2, "SYNC append only file rewrite performed");
#line 530
  return (0);
  werr: 
#line 533
  fclose(fp);
#line 534
  unlink((char const   *)(tmpfile___0));
#line 535
  __cil_tmp___48 = __errno();
#line 535
  __cil_tmp___49 = strerror(*__cil_tmp___48);
#line 535
  redisLog(3, "Write error writing append only file on disk: %s", __cil_tmp___49);
#line 536
  if (di) {
#line 536
    dictReleaseIterator(di);
  }
#line 537
  return (-1);
}
}
#line 552 "aof.c"
int rewriteAppendOnlyFileBackground(void) 
{ pid_t childpid ;
  char tmpfile___0[256] ;
  pid_t __cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;

  {
#line 555
  if (server.bgrewritechildpid != -1) {
#line 555
    return (-1);
  }
#line 556
  if (server.vm_enabled) {
#line 556
    waitEmptyIOJobsQueue();
  }
#line 557
  childpid = fork();
#line 557
  if (childpid == 0) {
#line 561
    if (server.vm_enabled) {
#line 561
      vmReopenSwapFile();
    }
#line 562
    if (server.ipfd > 0) {
#line 562
      close(server.ipfd);
    }
#line 563
    if (server.sofd > 0) {
#line 563
      close(server.sofd);
    }
#line 564
    __cil_tmp = getpid();
#line 564
    snprintf(tmpfile___0, 256U, "temp-rewriteaof-bg-%d.aof", __cil_tmp);
#line 565
    __cil_tmp___0 = rewriteAppendOnlyFile(tmpfile___0);
#line 565
    if (__cil_tmp___0 == 0) {
#line 566
      _exit(0);
    } else {
#line 568
      _exit(1);
    }
  } else {
#line 572
    if (childpid == -1) {
#line 573
      __cil_tmp___1 = __errno();
#line 573
      __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 573
      redisLog(3, "Can\'t rewrite append only file in background: fork: %s", __cil_tmp___2);
#line 576
      return (-1);
    }
#line 578
    redisLog(2, "Background append only file rewriting started by pid %d", childpid);
#line 580
    server.bgrewritechildpid = childpid;
#line 581
    updateDictResizePolicy();
#line 586
    server.appendseldb = -1;
#line 587
    return (0);
  }
#line 589
  return (0);
}
}
#line 592 "aof.c"
void bgrewriteaofCommand(redisClient *c ) 
{ int __cil_tmp ;

  {
#line 593
  if (server.bgrewritechildpid != -1) {
#line 594
    addReplyError(c, (char *)"Background append only file rewriting already in progress");
#line 595
    return;
  }
#line 597
  __cil_tmp = rewriteAppendOnlyFileBackground();
#line 597
  if (__cil_tmp == 0) {
#line 598
    addReplyStatus(c, (char *)"Background append only file rewriting started");
  } else {
#line 600
    addReply(c, shared.err);
  }
#line 602
  return;
}
}
#line 604 "aof.c"
void aofRemoveTempFile(pid_t childpid ) 
{ char tmpfile___0[256] ;

  {
#line 607
  snprintf(tmpfile___0, 256U, "temp-rewriteaof-bg-%d.aof", childpid);
#line 608
  unlink((char const   *)(tmpfile___0));
#line 609
  return;
}
}
#line 613 "aof.c"
void backgroundRewriteDoneHandler(int statloc ) 
{ int exitcode ;
  int bysignal ;
  int fd ;
  char tmpfile___0[256] ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  int __cil_tmp___4 ;
  size_t __cil_tmp___5 ;
  size_t __cil_tmp___6 ;
  int *__cil_tmp___7 ;
  char *__cil_tmp___8 ;
  int __cil_tmp___9 ;

  {
#line 614
  exitcode = statloc & 1;
#line 615
  bysignal = statloc & 8;
#line 617
  if (! bysignal && exitcode == 0) {
#line 621
    redisLog(2, "Background append only file rewriting terminated with success");
#line 624
    snprintf(tmpfile___0, 256U, "temp-rewriteaof-bg-%d.aof", server.bgrewritechildpid);
#line 625
    fd = open((char const   *)(tmpfile___0), 66);
#line 626
    if (fd == -1) {
#line 627
      __cil_tmp = __errno();
#line 627
      __cil_tmp___0 = strerror(*__cil_tmp);
#line 627
      redisLog(3, "Not able to open the temp append only file produced by the child: %s",
               __cil_tmp___0);
#line 628
      goto cleanup;
    }
#line 631
    __cil_tmp___3 = sdslen(server.bgrewritebuf);
#line 631
    __cil_tmp___4 = write(fd, (void const   *)server.bgrewritebuf, __cil_tmp___3);
#line 631
    __cil_tmp___5 = sdslen(server.bgrewritebuf);
#line 631
    if (__cil_tmp___4 != (int )__cil_tmp___5) {
#line 633
      __cil_tmp___1 = __errno();
#line 633
      __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 633
      redisLog(3, "Error or short write trying to flush the parent diff of the append log file in the child temp file: %s",
               __cil_tmp___2);
#line 634
      close(fd);
#line 635
      goto cleanup;
    }
#line 637
    __cil_tmp___6 = sdslen(server.bgrewritebuf);
#line 637
    redisLog(2, "Parent diff flushed into the new append log file with success (%lu bytes)",
             __cil_tmp___6);
#line 640
    __cil_tmp___9 = rename((char const   *)(tmpfile___0), (char const   *)server.appendfilename);
#line 640
    if (__cil_tmp___9 == -1) {
#line 641
      __cil_tmp___7 = __errno();
#line 641
      __cil_tmp___8 = strerror(*__cil_tmp___7);
#line 641
      redisLog(3, "Can\'t rename the temp append only file into the stable one: %s",
               __cil_tmp___8);
#line 642
      close(fd);
#line 643
      goto cleanup;
    }
#line 646
    redisLog(2, "Append only file successfully rewritten.");
#line 647
    if (server.appendfd != -1) {
#line 649
      close(server.appendfd);
#line 650
      server.appendfd = fd;
#line 651
      if (server.appendfsync != 0) {
#line 651
        fsync(fd);
      }
#line 652
      server.appendseldb = -1;
#line 653
      redisLog(2, "The new append only file was selected for future appends.");
    } else {
#line 657
      close(fd);
    }
  } else
#line 659
  if (! bysignal && exitcode != 0) {
#line 660
    redisLog(3, "Background append only file rewriting error");
  } else {
#line 662
    redisLog(3, "Background append only file rewriting terminated by signal %d", statloc & 64);
  }
  cleanup: 
#line 667
  sdsfree(server.bgrewritebuf);
#line 668
  server.bgrewritebuf = sdsempty();
#line 669
  aofRemoveTempFile(server.bgrewritechildpid);
#line 670
  server.bgrewritechildpid = -1;
#line 671
  return;
}
}
#line 1 "vm.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8xJ22AqY.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 236 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int fseeko(FILE *fp , long offset , int whence ) ;
#line 132 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern int pipe(int *__fildes ) ;
#line 181
extern int usleep(useconds_t __useconds ) ;
#line 62 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/pthread.h"
extern int pthread_mutex_init(pthread_mutex_t *__mutex , pthread_mutexattr_t const   *__attr ) ;
#line 186
extern int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 192
extern int pthread_attr_getstacksize(pthread_attr_t const   *__attr , size_t *__stacksize ) ;
#line 194
extern int pthread_attr_setstacksize(pthread_attr_t *__attr , size_t __stacksize ) ;
#line 211
extern int pthread_create(pthread_t *__pthread , pthread_attr_t const   *__attr ,
                          void *(*__start_routine)(void * ) , void *__arg ) ;
#line 221
extern int pthread_detach(pthread_t __pthread ) ;
#line 800 "redis.h"
void vmThreadedIOCompletedJob(aeEventLoop *el , int fd , void *privdata , int mask ) ;
#line 804
int vmSwapObjectThreaded(robj *key , robj *val , redisDb *db ) ;
#line 805
void freeIOJob(iojob *j ) ;
#line 806
void queueIOJob(iojob *j ) ;
#line 807
int vmWriteObjectOnSwap(robj *o , off_t page ) ;
#line 808
robj *vmReadObjectFromSwap(off_t page , int type ) ;
#line 811
int vmFreePage(off_t page ) ;
#line 134 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/math.h"
extern double log(double  ) ;
#line 134 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/signal.h"
extern int pthread_sigmask(int how , sigset_t const   *set , sigset_t *oset ) ;
#line 33 "vm.c"
vmpointer *createVmPointer(int vtype ) 
{ vmpointer *vp ;
  void *__cil_tmp ;

  {
#line 34
  __cil_tmp = malloc((unsigned int )sizeof(vmpointer ));
#line 34
  vp = (vmpointer *)__cil_tmp;
#line 36
  vp->type = 8U;
#line 37
  vp->storage = 1U;
#line 38
  vp->vtype = (unsigned int )vtype;
#line 39
  return (vp);
}
}
#line 82
extern int ftruncate() ;
#line 42 "vm.c"
void vmInit(void) 
{ off_t totsize ;
  int pipefds[2] ;
  size_t stacksize ;
  struct flock fl ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int *__cil_tmp___4 ;
  char *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  void *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  char *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;

  {
#line 48
  if (server.vm_max_threads != 0) {
#line 49
    zmalloc_enable_thread_safeness();
  }
#line 51
  redisLog(2, "Using \'%s\' as swap file", server.vm_swap_file);
#line 53
  server.vm_fp = fopen((char const   *)server.vm_swap_file, "r+b");
#line 53
  if ((unsigned int )server.vm_fp == (unsigned int )((void *)0)) {
#line 54
    server.vm_fp = fopen((char const   *)server.vm_swap_file, "w+b");
  }
#line 56
  if ((unsigned int )server.vm_fp == (unsigned int )((void *)0)) {
#line 57
    __cil_tmp = __errno();
#line 57
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 57
    redisLog(3, "Can\'t open the swap file: %s. Exiting.", __cil_tmp___0);
#line 60
    exit(1);
  }
#line 62
  server.vm_fd = fileno(server.vm_fp);
#line 65
  fl.l_type = (short)2;
#line 66
  fl.l_whence = (short)0;
#line 67
  fl.l_len = 0L;
#line 67
  fl.l_start = fl.l_len;
#line 68
  __cil_tmp___3 = fcntl(server.vm_fd, 7, & fl);
#line 68
  if (__cil_tmp___3 == -1) {
#line 69
    __cil_tmp___1 = __errno();
#line 69
    __cil_tmp___2 = strerror(*__cil_tmp___1);
#line 69
    redisLog(3, "Can\'t lock the swap file at \'%s\': %s. Make sure it is not used by another Redis instance.",
             server.vm_swap_file, __cil_tmp___2);
#line 71
    exit(1);
  }
#line 74
  server.vm_next_page = 0L;
#line 75
  server.vm_near_pages = 0L;
#line 76
  server.vm_stats_used_pages = 0ULL;
#line 77
  server.vm_stats_swapped_objects = 0ULL;
#line 78
  server.vm_stats_swapouts = 0ULL;
#line 79
  server.vm_stats_swapins = 0ULL;
#line 80
  totsize = server.vm_pages * server.vm_page_size;
#line 81
  redisLog(2, "Allocating %lld bytes of swap file", totsize);
#line 82
  __cil_tmp___6 = ftruncate(server.vm_fd, totsize);
#line 82
  if (__cil_tmp___6 == -1) {
#line 83
    __cil_tmp___4 = __errno();
#line 83
    __cil_tmp___5 = strerror(*__cil_tmp___4);
#line 83
    redisLog(3, "Can\'t ftruncate swap file: %s. Exiting.", __cil_tmp___5);
#line 85
    exit(1);
  } else {
#line 87
    redisLog(2, "Swap file allocated with success");
  }
#line 89
  __cil_tmp___7 = calloc(1U, (unsigned int )((server.vm_pages + 7L) / 8L));
#line 89
  server.vm_bitmap = (unsigned char *)__cil_tmp___7;
#line 90
  redisLog(1, "Allocated %lld bytes page table for %lld pages", (long long )(server.vm_pages + 7L) / 8LL,
           server.vm_pages);
#line 94
  server.io_newjobs = listCreate();
#line 95
  server.io_processing = listCreate();
#line 96
  server.io_processed = listCreate();
#line 97
  server.io_ready_clients = listCreate();
#line 98
  pthread_mutex_init(& server.io_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 99
  pthread_mutex_init(& server.io_swapfile_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 100
  server.io_active_threads = 0;
#line 101
  __cil_tmp___10 = pipe(pipefds);
#line 101
  if (__cil_tmp___10 == -1) {
#line 102
    __cil_tmp___8 = __errno();
#line 102
    __cil_tmp___9 = strerror(*__cil_tmp___8);
#line 102
    redisLog(3, "Unable to intialized VM: pipe(2): %s. Exiting.", __cil_tmp___9);
#line 104
    exit(1);
  }
#line 106
  server.io_ready_pipe_read = pipefds[0];
#line 107
  server.io_ready_pipe_write = pipefds[1];
#line 108
  __cil_tmp___11 = anetNonBlock((char *)((void *)0), server.io_ready_pipe_read);
#line 108
  if (! (__cil_tmp___11 != -1)) {
#line 108
    _redisAssert((char *)"anetNonBlock(NULL,server.io_ready_pipe_read) != ANET_ERR",
                 (char *)"vm.c", 108);
#line 108
    _exit(1);
  }
#line 110
  pthread_attr_init(& server.io_threads_attr);
#line 111
  pthread_attr_getstacksize((pthread_attr_t const   *)(& server.io_threads_attr),
                            & stacksize);
#line 115
  if (! stacksize) {
#line 115
    stacksize = 1U;
  }
#line 117
  while (stacksize < 4194304U) {
#line 117
    stacksize *= 2U;
  }
#line 118
  pthread_attr_setstacksize(& server.io_threads_attr, stacksize);
#line 120
  __cil_tmp___12 = aeCreateFileEvent(server.el, server.io_ready_pipe_read, 1, & vmThreadedIOCompletedJob,
                                     (void *)0);
#line 120
  if (__cil_tmp___12 == -1) {
#line 122
    oom("creating file event");
  }
#line 123
  return;
}
}
#line 126 "vm.c"
void vmMarkPageUsed(off_t page ) 
{ off_t byte ;
  int bit ;
  int __cil_tmp ;

  {
#line 127
  byte = page / 8L;
#line 128
  bit = (int )(page & 7L);
#line 129
  __cil_tmp = vmFreePage(page);
#line 129
  if (! (__cil_tmp == 1)) {
#line 129
    _redisAssert((char *)"vmFreePage(page) == 1", (char *)"vm.c", 129);
#line 129
    _exit(1);
  }
#line 130
  *(server.vm_bitmap + byte) = (unsigned char )((int )*(server.vm_bitmap + byte) | (1 << bit));
#line 131
  return;
}
}
#line 134 "vm.c"
void vmMarkPagesUsed(off_t page , off_t count ) 
{ off_t j ;

  {
#line 137
  j = 0L;
#line 137
  while (j < count) {
#line 138
    vmMarkPageUsed(page + j);
#line 137
    j ++;
  }
#line 139
  server.vm_stats_used_pages += (unsigned long long )count;
#line 140
  redisLog(0, "Mark USED pages: %lld pages at %lld\n", (long long )count, (long long )page);
#line 142
  return;
}
}
#line 145 "vm.c"
void vmMarkPageFree(off_t page ) 
{ off_t byte ;
  int bit ;
  int __cil_tmp ;

  {
#line 146
  byte = page / 8L;
#line 147
  bit = (int )(page & 7L);
#line 148
  __cil_tmp = vmFreePage(page);
#line 148
  if (! (__cil_tmp == 0)) {
#line 148
    _redisAssert((char *)"vmFreePage(page) == 0", (char *)"vm.c", 148);
#line 148
    _exit(1);
  }
#line 149
  *(server.vm_bitmap + byte) = (unsigned char )((int )*(server.vm_bitmap + byte) & ~ (1 << bit));
#line 150
  return;
}
}
#line 153 "vm.c"
void vmMarkPagesFree(off_t page , off_t count ) 
{ off_t j ;

  {
#line 156
  j = 0L;
#line 156
  while (j < count) {
#line 157
    vmMarkPageFree(page + j);
#line 156
    j ++;
  }
#line 158
  server.vm_stats_used_pages -= (unsigned long long )count;
#line 159
  redisLog(0, "Mark FREE pages: %lld pages at %lld\n", (long long )count, (long long )page);
#line 161
  return;
}
}
#line 164 "vm.c"
int vmFreePage(off_t page ) 
{ off_t byte ;
  int bit ;

  {
#line 165
  byte = page / 8L;
#line 166
  bit = (int )(page & 7L);
#line 167
  return (((int )*(server.vm_bitmap + byte) & (1 << bit)) == 0);
}
}
#line 189 "vm.c"
int vmFindContiguousPages(off_t *first , off_t n ) 
{ off_t base ;
  off_t offset ;
  off_t since_jump ;
  off_t numfree ;
  off_t this ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 190
  offset = 0L;
#line 190
  since_jump = 0L;
#line 190
  numfree = 0L;
#line 192
  if (server.vm_near_pages == 65536L) {
#line 193
    server.vm_near_pages = 0L;
#line 194
    server.vm_next_page = 0L;
  }
#line 196
  (server.vm_near_pages) ++;
#line 197
  base = server.vm_next_page;
#line 199
  while (offset < server.vm_pages) {
#line 200
    this = base + offset;
#line 203
    if (this >= server.vm_pages) {
#line 204
      this -= server.vm_pages;
#line 205
      if (this == 0L) {
#line 208
        numfree = 0L;
      }
    }
#line 211
    __cil_tmp = vmFreePage(this);
#line 211
    if (__cil_tmp) {
#line 213
      numfree ++;
#line 215
      if (numfree == n) {
#line 216
        *first = this - (n - 1L);
#line 217
        server.vm_next_page = this + 1L;
#line 218
        redisLog(0, "FOUND CONTIGUOUS PAGES: %lld pages at %lld\n", (long long )n,
                 (long long )*first);
#line 219
        return (0);
      }
    } else {
#line 223
      numfree = 0L;
    }
#line 228
    since_jump ++;
#line 229
    if (! numfree && since_jump >= 1024L) {
#line 230
      __cil_tmp___0 = random();
#line 230
      offset += (long )(__cil_tmp___0 % 4096);
#line 231
      since_jump = 0L;
    } else {
#line 237
      offset ++;
    }
  }
#line 240
  return (-1);
}
}
#line 244 "vm.c"
int vmWriteObjectOnSwap(robj *o , off_t page ) 
{ int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 245
  if (server.vm_enabled) {
#line 245
    pthread_mutex_lock(& server.io_swapfile_mutex);
  }
#line 246
  __cil_tmp___1 = fseeko(server.vm_fp, page * server.vm_page_size, 0);
#line 246
  if (__cil_tmp___1 == -1) {
#line 247
    if (server.vm_enabled) {
#line 247
      pthread_mutex_unlock(& server.io_swapfile_mutex);
    }
#line 248
    __cil_tmp = __errno();
#line 248
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 248
    redisLog(3, "Critical VM problem in vmWriteObjectOnSwap(): can\'t seek: %s", __cil_tmp___0);
#line 251
    return (-1);
  }
#line 253
  rdbSaveObject(server.vm_fp, o);
#line 254
  fflush(server.vm_fp);
#line 255
  if (server.vm_enabled) {
#line 255
    pthread_mutex_unlock(& server.io_swapfile_mutex);
  }
#line 256
  return (0);
}
}
#line 265 "vm.c"
vmpointer *vmSwapObjectBlocking(robj *val ) 
{ off_t pages ;
  off_t __cil_tmp ;
  off_t page ;
  vmpointer *vp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 266
  __cil_tmp = rdbSavedObjectPages(val);
#line 266
  pages = __cil_tmp;
#line 270
  if (! (val->storage == 0U)) {
#line 270
    _redisAssert((char *)"val->storage == REDIS_VM_MEMORY", (char *)"vm.c", 270);
#line 270
    _exit(1);
  }
#line 271
  if (! (val->refcount == 1)) {
#line 271
    _redisAssert((char *)"val->refcount == 1", (char *)"vm.c", 271);
#line 271
    _exit(1);
  }
#line 272
  __cil_tmp___0 = vmFindContiguousPages(& page, pages);
#line 272
  if (__cil_tmp___0 == -1) {
#line 272
    return ((vmpointer *)((void *)0));
  }
#line 273
  __cil_tmp___1 = vmWriteObjectOnSwap(val, page);
#line 273
  if (__cil_tmp___1 == -1) {
#line 273
    return ((vmpointer *)((void *)0));
  }
#line 275
  vp = createVmPointer((int )val->type);
#line 276
  vp->page = page;
#line 277
  vp->usedpages = pages;
#line 278
  decrRefCount((void *)val);
#line 279
  vmMarkPagesUsed(page, pages);
#line 280
  redisLog(0, "VM: object %p swapped out at %lld (%lld pages)", (void *)val, (unsigned long long )page,
           (unsigned long long )pages);
#line 283
  (server.vm_stats_swapped_objects) ++;
#line 284
  (server.vm_stats_swapouts) ++;
#line 285
  return (vp);
}
}
#line 288 "vm.c"
robj *vmReadObjectFromSwap(off_t page , int type ) 
{ robj *o ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  char *__cil_tmp___3 ;

  {
#line 291
  if (server.vm_enabled) {
#line 291
    pthread_mutex_lock(& server.io_swapfile_mutex);
  }
#line 292
  __cil_tmp___1 = fseeko(server.vm_fp, page * server.vm_page_size, 0);
#line 292
  if (__cil_tmp___1 == -1) {
#line 293
    __cil_tmp = __errno();
#line 293
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 293
    redisLog(3, "Unrecoverable VM problem in vmReadObjectFromSwap(): can\'t seek: %s",
             __cil_tmp___0);
#line 296
    _exit(1);
  }
#line 298
  o = rdbLoadObject(type, server.vm_fp);
#line 299
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 300
    __cil_tmp___2 = __errno();
#line 300
    __cil_tmp___3 = strerror(*__cil_tmp___2);
#line 300
    redisLog(3, "Unrecoverable VM problem in vmReadObjectFromSwap(): can\'t load object from swap file: %s",
             __cil_tmp___3);
#line 301
    _exit(1);
  }
#line 303
  if (server.vm_enabled) {
#line 303
    pthread_mutex_unlock(& server.io_swapfile_mutex);
  }
#line 304
  return (o);
}
}
#line 312 "vm.c"
robj *vmGenericLoadObject(vmpointer *vp , int preview ) 
{ robj *val ;

  {
#line 315
  if (! (vp->type == 8U && (vp->storage == 1U || vp->storage == 3U))) {
#line 315
    _redisAssert((char *)"vp->type == REDIS_VMPOINTER && (vp->storage == REDIS_VM_SWAPPED || vp->storage == REDIS_VM_LOADING)",
                 (char *)"vm.c", 316);
#line 315
    _exit(1);
  }
#line 317
  val = vmReadObjectFromSwap(vp->page, (int )vp->vtype);
#line 318
  if (! preview) {
#line 319
    redisLog(0, "VM: object %p loaded from disk", (void *)vp);
#line 320
    vmMarkPagesFree(vp->page, vp->usedpages);
#line 321
    free((void *)vp);
#line 322
    (server.vm_stats_swapped_objects) --;
  } else {
#line 324
    redisLog(0, "VM: object %p previewed from disk", (void *)vp);
  }
#line 326
  (server.vm_stats_swapins) ++;
#line 327
  return (val);
}
}
#line 334 "vm.c"
robj *vmLoadObject(robj *o ) 
{ robj *__cil_tmp ;

  {
#line 337
  if (o->storage == 3U) {
#line 338
    vmCancelThreadedIOJob(o);
  }
#line 339
  __cil_tmp = vmGenericLoadObject((vmpointer *)o, 0);
#line 339
  return (__cil_tmp);
}
}
#line 346 "vm.c"
robj *vmPreviewObject(robj *o ) 
{ robj *__cil_tmp ;

  {
#line 347
  __cil_tmp = vmGenericLoadObject((vmpointer *)o, 1);
#line 347
  return (__cil_tmp);
}
}
#line 361 "vm.c"
double computeObjectSwappability(robj *o ) 
{ time_t minage ;
  unsigned long __cil_tmp ;
  long asize ;
  long elesize ;
  robj *ele ;
  list *l ;
  listNode *ln ;
  dict *d ;
  struct dictEntry *de ;
  int z ;
  size_t __cil_tmp___0 ;
  unsigned int __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  intset *is ;
  size_t __cil_tmp___3 ;
  unsigned char *p ;
  unsigned char *__cil_tmp___4 ;
  unsigned int len ;
  unsigned int __cil_tmp___5 ;
  unsigned int klen ;
  unsigned int vlen ;
  unsigned char *key ;
  unsigned char *val ;
  size_t __cil_tmp___6 ;
  size_t __cil_tmp___7 ;
  double __cil_tmp___8 ;

  {
#line 364
  __cil_tmp = estimateObjectIdleTime(o);
#line 364
  minage = (long )__cil_tmp;
#line 365
  asize = 0L;
#line 373
  if (minage <= 0L) {
#line 373
    return ((double )0);
  }
#line 374
  switch ((int )o->type) {
  case 0: 
#line 376
  if (o->encoding != 0U) {
#line 377
    asize = (long )sizeof(*o);
  } else {
#line 379
    __cil_tmp___0 = sdslen((char *)o->ptr);
#line 379
    asize = (long )(((unsigned long )__cil_tmp___0 + sizeof(*o)) + sizeof(long ) * 2UL);
  }
#line 381
  break;
  case 1: 
#line 383
  if (o->encoding == 5U) {
#line 384
    __cil_tmp___1 = ziplistSize((unsigned char *)o->ptr);
#line 384
    asize = (long )(sizeof(*o) + (unsigned long )__cil_tmp___1);
  } else {
#line 386
    l = (list *)o->ptr;
#line 387
    ln = l->head;
#line 388
    asize = (long )sizeof(list );
#line 389
    if (ln) {
#line 390
      ele = (robj *)ln->value;
#line 391
      if (ele->encoding == 0U) {
#line 391
        __cil_tmp___2 = sdslen((char *)ele->ptr);
#line 391
        elesize = (long )(sizeof(*o) + (unsigned long )__cil_tmp___2);
      } else {
#line 391
        elesize = (long )sizeof(*o);
      }
#line 393
      asize = (long )((unsigned long )asize + (sizeof(listNode ) + (unsigned long )elesize) * (unsigned long )l->len);
    }
  }
#line 396
  break;
  case 2: 
  case 3: 
#line 399
  z = o->type == 3U;
#line 400
  d = z ? ((zset *)o->ptr)->dict : (dict *)o->ptr;
#line 402
  if (! z && o->encoding == 6U) {
#line 403
    is = (intset *)o->ptr;
#line 404
    asize = (long )(sizeof(*is) + is->encoding * is->length);
  } else {
#line 406
    asize = (long )(sizeof(dict ) + sizeof(struct dictEntry *) * (d->ht[0].size + d->ht[1].size));
#line 407
    if (z) {
#line 407
      asize = (long )((unsigned long )asize + (sizeof(zset ) - sizeof(dict )));
    }
#line 408
    if (d->ht[0].used + d->ht[1].used) {
#line 409
      de = dictGetRandomKey(d);
#line 410
      ele = (robj *)de->key;
#line 411
      if (ele->encoding == 0U) {
#line 411
        __cil_tmp___3 = sdslen((char *)ele->ptr);
#line 411
        elesize = (long )(sizeof(*o) + (unsigned long )__cil_tmp___3);
      } else {
#line 411
        elesize = (long )sizeof(*o);
      }
#line 413
      asize = (long )((unsigned long )asize + (sizeof(struct dictEntry ) + (unsigned long )elesize) * (d->ht[0].used + d->ht[1].used));
#line 414
      if (z) {
#line 414
        asize = (long )((unsigned long )asize + sizeof(zskiplistNode ) * (d->ht[0].used + d->ht[1].used));
      }
    }
  }
#line 417
  break;
  case 4: 
#line 419
  if (o->encoding == 3U) {
#line 420
    __cil_tmp___4 = zipmapRewind((unsigned char *)o->ptr);
#line 420
    p = __cil_tmp___4;
#line 421
    __cil_tmp___5 = zipmapLen((unsigned char *)o->ptr);
#line 421
    len = __cil_tmp___5;
#line 425
    p = zipmapNext(p, & key, & klen, & val, & vlen);
#line 425
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 426
      klen = 0U;
#line 427
      vlen = 0U;
    }
#line 429
    asize = (long )(len * ((klen + vlen) + 3U));
  } else
#line 430
  if (o->encoding == 2U) {
#line 431
    d = (dict *)o->ptr;
#line 432
    asize = (long )(sizeof(dict ) + sizeof(struct dictEntry *) * (d->ht[0].size + d->ht[1].size));
#line 433
    if (d->ht[0].used + d->ht[1].used) {
#line 434
      de = dictGetRandomKey(d);
#line 435
      ele = (robj *)de->key;
#line 436
      if (ele->encoding == 0U) {
#line 436
        __cil_tmp___6 = sdslen((char *)ele->ptr);
#line 436
        elesize = (long )(sizeof(*o) + (unsigned long )__cil_tmp___6);
      } else {
#line 436
        elesize = (long )sizeof(*o);
      }
#line 438
      ele = (robj *)de->val;
#line 439
      if (ele->encoding == 0U) {
#line 439
        __cil_tmp___7 = sdslen((char *)ele->ptr);
#line 439
        elesize = (long )(sizeof(*o) + (unsigned long )__cil_tmp___7);
      } else {
#line 439
        elesize = (long )sizeof(*o);
      }
#line 441
      asize = (long )((unsigned long )asize + (sizeof(struct dictEntry ) + (unsigned long )elesize) * (d->ht[0].used + d->ht[1].used));
    }
  }
#line 444
  break;
  }
#line 446
  __cil_tmp___8 = log((double )(1L + asize));
#line 446
  return ((double )minage * __cil_tmp___8);
}
}
#line 455 "vm.c"
int vmSwapOneObject(int usethreads ) 
{ int j ;
  int i ;
  struct dictEntry *best ;
  double best_swappability ;
  redisDb *best_db ;
  robj *val ;
  sds key ;
  redisDb *db ;
  int maxtries ;
  dictEntry *de ;
  double swappability ;
  robj *keyobj ;
  size_t __cil_tmp ;
  robj *__cil_tmp___0 ;
  vmpointer *vp ;

  {
#line 457
  best = (struct dictEntry *)((void *)0);
#line 458
  best_swappability = (double )0;
#line 459
  best_db = (redisDb *)((void *)0);
#line 463
  j = 0;
#line 463
  while (j < server.dbnum) {
#line 464
    db = server.db + j;
#line 468
    maxtries = 100;
#line 470
    if ((db->dict)->ht[0].used + (db->dict)->ht[1].used == 0UL) {
#line 470
      goto __Cont;
    }
#line 471
    i = 0;
#line 471
    while (i < 5) {
#line 475
      if (maxtries) {
#line 475
        maxtries --;
      }
#line 476
      de = dictGetRandomKey(db->dict);
#line 477
      val = (robj *)de->val;
#line 484
      if (val->storage != 0U || val->refcount != 1) {
#line 485
        if (maxtries) {
#line 485
          i --;
        }
#line 486
        goto __Cont___0;
      }
#line 488
      swappability = computeObjectSwappability(val);
#line 489
      if (! best || swappability > best_swappability) {
#line 490
        best = de;
#line 491
        best_swappability = swappability;
#line 492
        best_db = db;
      }
      __Cont___0: 
#line 471
      i ++;
    }
    __Cont: 
#line 463
    j ++;
  }
#line 496
  if ((unsigned int )best == (unsigned int )((void *)0)) {
#line 496
    return (-1);
  }
#line 497
  key = (char *)best->key;
#line 498
  val = (robj *)best->val;
#line 500
  redisLog(0, "Key with best swappability: %s, %f", key, best_swappability);
#line 504
  if (usethreads) {
#line 505
    __cil_tmp = sdslen(key);
#line 505
    __cil_tmp___0 = createStringObject(key, __cil_tmp);
#line 505
    keyobj = __cil_tmp___0;
#line 506
    vmSwapObjectThreaded(keyobj, val, best_db);
#line 507
    decrRefCount((void *)keyobj);
#line 508
    return (0);
  } else {
#line 512
    vp = vmSwapObjectBlocking(val);
#line 512
    if ((unsigned int )vp != (unsigned int )((void *)0)) {
#line 513
      best->val = (void *)vp;
#line 514
      return (0);
    } else {
#line 516
      return (-1);
    }
  }
}
}
#line 521 "vm.c"
int vmSwapOneObjectBlocking(void) 
{ int __cil_tmp ;

  {
#line 522
  __cil_tmp = vmSwapOneObject(0);
#line 522
  return (__cil_tmp);
}
}
#line 525 "vm.c"
int vmSwapOneObjectThreaded(void) 
{ int __cil_tmp ;

  {
#line 526
  __cil_tmp = vmSwapOneObject(1);
#line 526
  return (__cil_tmp);
}
}
#line 532 "vm.c"
int vmCanSwapOut(void) 
{ 

  {
#line 533
  return (server.bgsavechildpid == -1 && server.bgrewritechildpid == -1);
}
}
#line 538 "vm.c"
void freeIOJob(iojob *j ) 
{ 

  {
#line 539
  if (((j->type == 1 || j->type == 2) || j->type == 0) && (unsigned int )j->val != (unsigned int )((void *)0)) {
#line 545
    if ((j->val)->storage == 2U) {
#line 546
      (j->val)->storage = 0U;
    }
#line 547
    decrRefCount((void *)j->val);
  }
#line 549
  decrRefCount((void *)j->key);
#line 550
  free((void *)j);
#line 551
  return;
}
}
#line 564 "vm.c"
void vmThreadedIOCompletedJob(aeEventLoop *el , int fd , void *privdata , int mask ) 
{ char buf[1] ;
  int retval ;
  int processed ;
  int toprocess ;
  int trytoswap ;
  iojob *j ;
  listNode *ln ;
  struct dictEntry *de ;
  redisDb *db ;
  vmpointer *vp ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  vmpointer *vp___0 ;
  vmpointer *vp___1 ;
  int more ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  int *__cil_tmp___4 ;
  char *__cil_tmp___5 ;
  int *__cil_tmp___6 ;

  {
#line 568
  processed = 0;
#line 568
  toprocess = -1;
#line 568
  trytoswap = 1;
#line 573
  if ((unsigned int )privdata != (unsigned int )((void *)0)) {
#line 573
    trytoswap = 0;
  }
#line 577
  while (1) {
#line 577
    retval = read(fd, (void *)(buf), 1U);
#line 577
    if (! (retval == 1)) {
#line 577
      break;
    }
#line 582
    redisLog(0, "Processing I/O completed job");
#line 585
    lockThreadedIO();
#line 586
    if (! ((server.io_processed)->len != 0U)) {
#line 586
      _redisAssert((char *)"listLength(server.io_processed) != 0", (char *)"vm.c",
                   586);
#line 586
      _exit(1);
    }
#line 587
    if (toprocess == -1) {
#line 588
      toprocess = (int )((server.io_processed)->len / 100U);
#line 589
      if (toprocess <= 0) {
#line 589
        toprocess = 1;
      }
    }
#line 591
    ln = (server.io_processed)->head;
#line 592
    j = (iojob *)ln->value;
#line 593
    listDelNode(server.io_processed, ln);
#line 594
    unlockThreadedIO();
#line 596
    if (j->canceled) {
#line 597
      freeIOJob(j);
#line 598
      continue;
    }
#line 602
    redisLog(0, "COMPLETED Job type: %d, ID %p, key: %s", j->type, (void *)j->id,
             (unsigned char *)(j->key)->ptr);
#line 603
    de = dictFind((j->db)->dict, (void const   *)(j->key)->ptr);
#line 604
    if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 604
      _redisAssert((char *)"de != NULL", (char *)"vm.c", 604);
#line 604
      _exit(1);
    }
#line 605
    if (j->type == 0) {
#line 607
      vp = (vmpointer *)de->val;
#line 610
      vmMarkPagesFree(vp->page, vp->usedpages);
#line 611
      redisLog(0, "VM: object %s loaded from disk (threaded)", (unsigned char *)(j->key)->ptr);
#line 613
      (server.vm_stats_swapped_objects) --;
#line 614
      (server.vm_stats_swapins) ++;
#line 615
      de->val = (void *)j->val;
#line 616
      incrRefCount(j->val);
#line 617
      db = j->db;
#line 619
      handleClientsBlockedOnSwappedKey(db, j->key);
#line 620
      freeIOJob(j);
#line 621
      free((void *)vp);
    } else
#line 622
    if (j->type == 1) {
#line 626
      __cil_tmp = vmCanSwapOut();
#line 626
      if (__cil_tmp) {
#line 626
        __cil_tmp___0 = vmFindContiguousPages(& j->page, j->pages);
#line 626
        if (__cil_tmp___0 == -1) {
#line 631
          (j->val)->storage = 0U;
#line 632
          freeIOJob(j);
        } else {
#line 637
          vmMarkPagesUsed(j->page, j->pages);
#line 638
          j->type = 2;
#line 639
          lockThreadedIO();
#line 640
          queueIOJob(j);
#line 641
          unlockThreadedIO();
        }
      } else {
#line 631
        (j->val)->storage = 0U;
#line 632
        freeIOJob(j);
      }
    } else
#line 643
    if (j->type == 2) {
#line 647
      if ((j->val)->storage != 2U) {
#line 648
        vp___1 = (vmpointer *)j->id;
#line 649
        printf("storage: %d\n", vp___1->storage);
#line 650
        printf("key->name: %s\n", (char *)(j->key)->ptr);
#line 651
        printf("val: %p\n", (void *)j->val);
#line 652
        printf("val->type: %d\n", (j->val)->type);
#line 653
        printf("val->ptr: %s\n", (char *)(j->val)->ptr);
      }
#line 655
      if (! ((j->val)->storage == 2U)) {
#line 655
        _redisAssert((char *)"j->val->storage == REDIS_VM_SWAPPING", (char *)"vm.c",
                     655);
#line 655
        _exit(1);
      }
#line 656
      vp___0 = createVmPointer((int )(j->val)->type);
#line 657
      vp___0->page = j->page;
#line 658
      vp___0->usedpages = j->pages;
#line 659
      de->val = (void *)vp___0;
#line 662
      (j->val)->storage = 0U;
#line 663
      decrRefCount((void *)j->val);
#line 664
      redisLog(0, "VM: object %s swapped out at %lld (%lld pages) (threaded)", (unsigned char *)(j->key)->ptr,
               (unsigned long long )j->page, (unsigned long long )j->pages);
#line 668
      (server.vm_stats_swapped_objects) ++;
#line 669
      (server.vm_stats_swapouts) ++;
#line 670
      freeIOJob(j);
#line 673
      if (trytoswap) {
#line 673
        __cil_tmp___2 = vmCanSwapOut();
#line 673
        if (__cil_tmp___2) {
#line 673
          __cil_tmp___3 = zmalloc_used_memory();
#line 673
          if ((unsigned long long )__cil_tmp___3 > server.vm_max_memory) {
#line 676
            more = 1;
#line 677
            while (more) {
#line 678
              lockThreadedIO();
#line 679
              more = (server.io_newjobs)->len < (unsigned int )server.vm_max_threads;
#line 681
              unlockThreadedIO();
#line 683
              __cil_tmp___1 = vmSwapOneObjectThreaded();
#line 683
              if (__cil_tmp___1 == -1) {
#line 684
                trytoswap = 0;
#line 685
                break;
              }
            }
          }
        }
      }
    }
#line 690
    processed ++;
#line 691
    if (processed == toprocess) {
#line 691
      return;
    }
  }
#line 693
  if (retval < 0) {
#line 693
    __cil_tmp___6 = __errno();
#line 693
    if (*__cil_tmp___6 != 11) {
#line 694
      __cil_tmp___4 = __errno();
#line 694
      __cil_tmp___5 = strerror(*__cil_tmp___4);
#line 694
      redisLog(3, "WARNING: read(2) error in vmThreadedIOCompletedJob() %s", __cil_tmp___5);
    }
  }
#line 698
  return;
}
}
#line 700 "vm.c"
void lockThreadedIO(void) 
{ 

  {
#line 701
  pthread_mutex_lock(& server.io_mutex);
#line 702
  return;
}
}
#line 704 "vm.c"
void unlockThreadedIO(void) 
{ 

  {
#line 705
  pthread_mutex_unlock(& server.io_mutex);
#line 706
  return;
}
}
#line 710 "vm.c"
void vmCancelThreadedIOJob(robj *o ) 
{ list *lists[3] ;
  int i ;
  listNode *ln ;
  listIter li ;
  iojob *job ;

  {
#line 711
  lists[0] = server.io_newjobs;
#line 711
  lists[1] = server.io_processing;
#line 711
  lists[2] = server.io_processed;
#line 718
  if (! (o->storage == 3U || o->storage == 2U)) {
#line 718
    _redisAssert((char *)"o->storage == REDIS_VM_LOADING || o->storage == REDIS_VM_SWAPPING",
                 (char *)"vm.c", 718);
#line 718
    _exit(1);
  }
  again: 
#line 720
  lockThreadedIO();
#line 722
  i = 0;
#line 722
  while (i < 3) {
#line 726
    listRewind(lists[i], & li);
#line 727
    while (1) {
#line 727
      ln = listNext(& li);
#line 727
      if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 727
        break;
      }
#line 728
      job = (iojob *)ln->value;
#line 730
      if (job->canceled) {
#line 730
        continue;
      }
#line 731
      if ((unsigned int )job->id == (unsigned int )o) {
#line 732
        redisLog(0, "*** CANCELED %p (key %s) (type %d) (LIST ID %d)\n", (void *)job,
                 (char *)(job->key)->ptr, job->type, i);
#line 736
        if (i != 1 && job->type == 2) {
#line 737
          vmMarkPagesFree(job->page, job->pages);
        }
#line 740
        switch (i) {
        case 0: 
#line 744
        freeIOJob(job);
#line 745
        listDelNode(lists[i], ln);
#line 746
        break;
        case 1: 
#line 761
        unlockThreadedIO();
#line 765
        usleep(1UL);
#line 766
        goto again;
        case 2: 
#line 771
        job->canceled = 1;
#line 772
        break;
        }
#line 776
        if (o->storage == 3U) {
#line 777
          o->storage = 1U;
        } else
#line 778
        if (o->storage == 2U) {
#line 779
          o->storage = 0U;
        }
#line 780
        unlockThreadedIO();
#line 781
        redisLog(0, "*** DONE");
#line 782
        return;
      }
    }
#line 722
    i ++;
  }
#line 786
  unlockThreadedIO();
#line 787
  printf("Not found: %p\n", (void *)o);
#line 788
  _redisAssert((char *)"1 != 1", (char *)"vm.c", 788);
#line 788
  _exit(1);
}
}
#line 791 "vm.c"
void *IOThreadEntryPoint(void *arg ) 
{ iojob *j ;
  listNode *ln ;
  pthread_t __cil_tmp ;
  pthread_t __cil_tmp___0 ;
  pthread_t __cil_tmp___1 ;
  vmpointer *vp ;
  int __cil_tmp___2 ;
  pthread_t __cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 796
  __cil_tmp = pthread_self();
#line 796
  pthread_detach(__cil_tmp);
#line 797
  while (1) {
#line 799
    lockThreadedIO();
#line 800
    if ((server.io_newjobs)->len == 0U) {
#line 802
      __cil_tmp___0 = pthread_self();
#line 802
      redisLog(0, "Thread %ld exiting, nothing to do", (long )__cil_tmp___0);
#line 804
      (server.io_active_threads) --;
#line 805
      unlockThreadedIO();
#line 806
      return ((void *)0);
    }
#line 808
    ln = (server.io_newjobs)->head;
#line 809
    j = (iojob *)ln->value;
#line 810
    listDelNode(server.io_newjobs, ln);
#line 812
    j->thread = pthread_self();
#line 813
    listAddNodeTail(server.io_processing, (void *)j);
#line 814
    ln = (server.io_processing)->tail;
#line 815
    unlockThreadedIO();
#line 816
    __cil_tmp___1 = pthread_self();
#line 816
    redisLog(0, "Thread %ld got a new job (type %d): %p about key \'%s\'", (long )__cil_tmp___1,
             j->type, (void *)j, (char *)(j->key)->ptr);
#line 820
    if (j->type == 0) {
#line 821
      vp = (vmpointer *)j->id;
#line 822
      j->val = vmReadObjectFromSwap(j->page, (int )vp->vtype);
    } else
#line 823
    if (j->type == 1) {
#line 824
      j->pages = rdbSavedObjectPages(j->val);
    } else
#line 825
    if (j->type == 2) {
#line 826
      __cil_tmp___2 = vmWriteObjectOnSwap(j->val, j->page);
#line 826
      if (__cil_tmp___2 == -1) {
#line 827
        j->canceled = 1;
      }
    }
#line 831
    __cil_tmp___3 = pthread_self();
#line 831
    redisLog(0, "Thread %ld completed the job: %p (key %s)", (long )__cil_tmp___3,
             (void *)j, (char *)(j->key)->ptr);
#line 833
    lockThreadedIO();
#line 834
    listDelNode(server.io_processing, ln);
#line 835
    listAddNodeTail(server.io_processed, (void *)j);
#line 836
    unlockThreadedIO();
#line 839
    __cil_tmp___4 = write(server.io_ready_pipe_write, (void const   *)"x", 1U);
#line 839
    if (! (__cil_tmp___4 == 1)) {
#line 839
      _redisAssert((char *)"write(server.io_ready_pipe_write,\"x\",1) == 1", (char *)"vm.c",
                   839);
#line 839
      _exit(1);
    }
  }
#line 841
  return ((void *)0);
}
}
#line 844 "vm.c"
void spawnIOThread(void) 
{ pthread_t thread ;
  sigset_t mask ;
  sigset_t omask ;
  int err ;
  char *__cil_tmp ;

  {
#line 849
  mask = 0UL;
#line 850
  mask |= (unsigned long )(1 << 20);
#line 851
  mask |= (unsigned long )(1 << 1);
#line 852
  mask |= (unsigned long )(1 << 13);
#line 853
  pthread_sigmask(0, (sigset_t const   *)(& mask), & omask);
#line 854
  while (1) {
#line 854
    err = pthread_create(& thread, (pthread_attr_t const   *)(& server.io_threads_attr),
                         & IOThreadEntryPoint, (void *)0);
#line 854
    if (! (err != 0)) {
#line 854
      break;
    }
#line 855
    __cil_tmp = strerror(err);
#line 855
    redisLog(3, "Unable to spawn an I/O thread: %s", __cil_tmp);
#line 857
    usleep(1000000UL);
  }
#line 859
  pthread_sigmask(0, (sigset_t const   *)(& omask), (sigset_t *)((void *)0));
#line 860
  (server.io_active_threads) ++;
#line 861
  return;
}
}
#line 865 "vm.c"
void waitEmptyIOJobsQueue(void) 
{ int io_processed_len ;

  {
#line 866
  while (1) {
#line 869
    lockThreadedIO();
#line 870
    if (((server.io_newjobs)->len == 0U && (server.io_processing)->len == 0U) && server.io_active_threads == 0) {
#line 874
      unlockThreadedIO();
#line 875
      return;
    }
#line 881
    io_processed_len = (int )(server.io_processed)->len;
#line 882
    unlockThreadedIO();
#line 883
    if (io_processed_len) {
#line 884
      vmThreadedIOCompletedJob((aeEventLoop *)((void *)0), server.io_ready_pipe_read,
                               (void *)3735928559U, 0);
#line 886
      usleep(1000UL);
    } else {
#line 888
      usleep(10000UL);
    }
  }
}
}
#line 893 "vm.c"
void vmReopenSwapFile(void) 
{ 

  {
#line 896
  server.vm_fp = fopen((char const   *)server.vm_swap_file, "r+b");
#line 897
  if ((unsigned int )server.vm_fp == (unsigned int )((void *)0)) {
#line 898
    redisLog(3, "Can\'t re-open the VM swap file: %s. Exiting.", server.vm_swap_file);
#line 900
    _exit(1);
  }
#line 902
  server.vm_fd = fileno(server.vm_fp);
#line 903
  return;
}
}
#line 906 "vm.c"
void queueIOJob(iojob *j ) 
{ 

  {
#line 907
  redisLog(0, "Queued IO Job %p type %d about key \'%s\'\n", (void *)j, j->type, (char *)(j->key)->ptr);
#line 909
  listAddNodeTail(server.io_newjobs, (void *)j);
#line 910
  if (server.io_active_threads < server.vm_max_threads) {
#line 911
    spawnIOThread();
  }
#line 912
  return;
}
}
#line 914 "vm.c"
int vmSwapObjectThreaded(robj *key , robj *val , redisDb *db ) 
{ iojob *j ;
  void *__cil_tmp ;
  robj *__cil_tmp___0 ;

  {
#line 917
  __cil_tmp = malloc((unsigned int )sizeof(*j));
#line 917
  j = (iojob *)__cil_tmp;
#line 918
  j->type = 1;
#line 919
  j->db = db;
#line 920
  j->key = key;
#line 921
  incrRefCount(key);
#line 922
  __cil_tmp___0 = val;
#line 922
  j->val = __cil_tmp___0;
#line 922
  j->id = __cil_tmp___0;
#line 923
  incrRefCount(val);
#line 924
  j->canceled = 0;
#line 925
  j->thread = 4294967295U;
#line 926
  val->storage = 2U;
#line 928
  lockThreadedIO();
#line 929
  queueIOJob(j);
#line 930
  unlockThreadedIO();
#line 931
  return (0);
}
}
#line 941 "vm.c"
int waitForSwappedKey(redisClient *c , robj *key ) 
{ struct dictEntry *de ;
  robj *o ;
  list *l ;
  int retval ;
  iojob *j ;
  vmpointer *vp ;
  void *__cil_tmp ;

  {
#line 948
  de = dictFind((c->db)->dict, (void const   *)key->ptr);
#line 949
  if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 949
    return (0);
  }
#line 950
  o = (robj *)de->val;
#line 951
  if (o->storage == 0U) {
#line 952
    return (0);
  } else
#line 953
  if (o->storage == 2U) {
#line 955
    vmCancelThreadedIOJob(o);
#line 956
    return (0);
  }
#line 963
  listAddNodeTail(c->io_keys, (void *)key);
#line 964
  incrRefCount(key);
#line 967
  de = dictFind((c->db)->io_keys, (void const   *)key);
#line 968
  if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 972
    l = listCreate();
#line 973
    retval = dictAdd((c->db)->io_keys, (void *)key, (void *)l);
#line 974
    incrRefCount(key);
#line 975
    if (! (retval == 0)) {
#line 975
      _redisAssert((char *)"retval == DICT_OK", (char *)"vm.c", 975);
#line 975
      _exit(1);
    }
  } else {
#line 977
    l = (list *)de->val;
  }
#line 979
  listAddNodeTail(l, (void *)c);
#line 982
  if (o->storage == 1U) {
#line 984
    vp = (vmpointer *)o;
#line 986
    o->storage = 3U;
#line 987
    __cil_tmp = malloc((unsigned int )sizeof(*j));
#line 987
    j = (iojob *)__cil_tmp;
#line 988
    j->type = 0;
#line 989
    j->db = c->db;
#line 990
    j->id = (robj *)vp;
#line 991
    j->key = key;
#line 992
    incrRefCount(key);
#line 993
    j->page = vp->page;
#line 994
    j->val = (robj *)((void *)0);
#line 995
    j->canceled = 0;
#line 996
    j->thread = 4294967295U;
#line 997
    lockThreadedIO();
#line 998
    queueIOJob(j);
#line 999
    unlockThreadedIO();
  }
#line 1001
  return (1);
}
}
#line 1006 "vm.c"
void waitForMultipleSwappedKeys(redisClient *c , struct redisCommand *cmd , int argc ,
                                robj **argv ) 
{ int j ;
  int last ;

  {
#line 1008
  if (cmd->vm_firstkey == 0) {
#line 1008
    return;
  }
#line 1009
  last = cmd->vm_lastkey;
#line 1010
  if (last < 0) {
#line 1010
    last = argc + last;
  }
#line 1011
  j = cmd->vm_firstkey;
#line 1011
  while (j <= last) {
#line 1012
    if (! (j < argc)) {
#line 1012
      _redisAssert((char *)"j < argc", (char *)"vm.c", 1012);
#line 1012
      _exit(1);
    }
#line 1013
    waitForSwappedKey(c, *(argv + j));
#line 1011
    j += cmd->vm_keystep;
  }
#line 1015
  return;
}
}
#line 1020 "vm.c"
void zunionInterBlockClientOnSwappedKeys(redisClient *c , struct redisCommand *cmd ,
                                         int argc , robj **argv ) 
{ int i ;
  int num ;

  {
#line 1024
  num = atoi((char const   *)(*(argv + 2))->ptr);
#line 1025
  if (num > argc - 3) {
#line 1025
    return;
  }
#line 1026
  i = 0;
#line 1026
  while (i < num) {
#line 1027
    waitForSwappedKey(c, *(argv + (3 + i)));
#line 1026
    i ++;
  }
#line 1029
  return;
}
}
#line 1035 "vm.c"
void execBlockClientOnSwappedKeys(redisClient *c , struct redisCommand *cmd , int argc ,
                                  robj **argv ) 
{ int i ;
  int margc ;
  struct redisCommand *mcmd ;
  robj **margv ;

  {
#line 1043
  if (! (c->flags & 8)) {
#line 1043
    return;
  }
#line 1044
  i = 0;
#line 1044
  while (i < c->mstate.count) {
#line 1045
    mcmd = (c->mstate.commands + i)->cmd;
#line 1046
    margc = (c->mstate.commands + i)->argc;
#line 1047
    margv = (c->mstate.commands + i)->argv;
#line 1049
    if ((unsigned int )mcmd->vm_preload_proc != (unsigned int )((void *)0)) {
#line 1050
      (*(mcmd->vm_preload_proc))(c, mcmd, margc, margv);
    } else {
#line 1052
      waitForMultipleSwappedKeys(c, mcmd, margc, margv);
    }
#line 1044
    i ++;
  }
#line 1055
  return;
}
}
#line 1067 "vm.c"
int blockClientOnSwappedKeys(redisClient *c , struct redisCommand *cmd ) 
{ 

  {
#line 1068
  if ((unsigned int )cmd->vm_preload_proc != (unsigned int )((void *)0)) {
#line 1069
    (*(cmd->vm_preload_proc))(c, cmd, c->argc, c->argv);
  } else {
#line 1071
    waitForMultipleSwappedKeys(c, cmd, c->argc, c->argv);
  }
#line 1075
  if ((c->io_keys)->len) {
#line 1076
    c->flags |= 32;
#line 1077
    aeDeleteFileEvent(server.el, c->fd, 1);
#line 1078
    (server.vm_blocked_clients) ++;
#line 1079
    return (1);
  } else {
#line 1081
    return (0);
  }
}
}
#line 1089 "vm.c"
int dontWaitForSwappedKey(redisClient *c , robj *key ) 
{ list *l ;
  listNode *ln ;
  listIter li ;
  struct dictEntry *de ;
  int __cil_tmp ;

  {
#line 1098
  incrRefCount(key);
#line 1101
  listRewind(c->io_keys, & li);
#line 1102
  while (1) {
#line 1102
    ln = listNext(& li);
#line 1102
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 1102
      break;
    }
#line 1103
    __cil_tmp = equalStringObjects((robj *)ln->value, key);
#line 1103
    if (__cil_tmp) {
#line 1104
      listDelNode(c->io_keys, ln);
#line 1105
      break;
    }
  }
#line 1108
  if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 1108
    _redisAssert((char *)"ln != NULL", (char *)"vm.c", 1108);
#line 1108
    _exit(1);
  }
#line 1111
  de = dictFind((c->db)->io_keys, (void const   *)key);
#line 1112
  if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 1112
    _redisAssert((char *)"de != NULL", (char *)"vm.c", 1112);
#line 1112
    _exit(1);
  }
#line 1113
  l = (list *)de->val;
#line 1114
  ln = listSearchKey(l, (void *)c);
#line 1115
  if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 1115
    _redisAssert((char *)"ln != NULL", (char *)"vm.c", 1115);
#line 1115
    _exit(1);
  }
#line 1116
  listDelNode(l, ln);
#line 1117
  if (l->len == 0U) {
#line 1118
    dictDelete((c->db)->io_keys, (void const   *)key);
  }
#line 1120
  decrRefCount((void *)key);
#line 1121
  return ((c->io_keys)->len == 0U);
}
}
#line 1126 "vm.c"
void handleClientsBlockedOnSwappedKey(redisDb *db , robj *key ) 
{ struct dictEntry *de ;
  list *l ;
  listNode *ln ;
  int len ;
  redisClient *c ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 1132
  de = dictFind(db->io_keys, (void const   *)key);
#line 1133
  if (! de) {
#line 1133
    return;
  }
#line 1135
  l = (list *)de->val;
#line 1136
  len = (int )l->len;
#line 1139
  while (1) {
#line 1139
    __cil_tmp___0 = len;
#line 1139
    len --;
#line 1139
    if (! __cil_tmp___0) {
#line 1139
      break;
    }
#line 1140
    ln = l->head;
#line 1141
    c = (redisClient *)ln->value;
#line 1143
    __cil_tmp = dontWaitForSwappedKey(c, key);
#line 1143
    if (__cil_tmp) {
#line 1146
      listAddNodeTail(server.io_ready_clients, (void *)c);
    }
  }
#line 1149
  return;
}
}
#line 1 "pubsub.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lLfV1ZDN.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 7 "pubsub.c"
void freePubsubPattern(void *p ) 
{ pubsubPattern *pat ;

  {
#line 8
  pat = (pubsubPattern *)p;
#line 10
  decrRefCount((void *)pat->pattern);
#line 11
  free((void *)pat);
#line 12
  return;
}
}
#line 14 "pubsub.c"
int listMatchPubsubPattern(void *a , void *b ) 
{ pubsubPattern *pa ;
  pubsubPattern *pb ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 15
  pa = (pubsubPattern *)a;
#line 15
  pb = (pubsubPattern *)b;
#line 17
  if ((unsigned int )pa->client == (unsigned int )pb->client) {
#line 17
    __cil_tmp = equalStringObjects(pa->pattern, pb->pattern);
#line 17
    if (__cil_tmp) {
#line 17
      __cil_tmp___0 = 1;
    } else {
#line 17
      __cil_tmp___0 = 0;
    }
  } else {
#line 17
    __cil_tmp___0 = 0;
  }
#line 17
  return (__cil_tmp___0);
}
}
#line 23 "pubsub.c"
int pubsubSubscribeChannel(redisClient *c , robj *channel ) 
{ struct dictEntry *de ;
  list *clients ;
  int retval ;
  int __cil_tmp ;

  {
#line 25
  clients = (list *)((void *)0);
#line 26
  retval = 0;
#line 29
  __cil_tmp = dictAdd(c->pubsub_channels, (void *)channel, (void *)0);
#line 29
  if (__cil_tmp == 0) {
#line 30
    retval = 1;
#line 31
    incrRefCount(channel);
#line 33
    de = dictFind(server.pubsub_channels, (void const   *)channel);
#line 34
    if ((unsigned int )de == (unsigned int )((void *)0)) {
#line 35
      clients = listCreate();
#line 36
      dictAdd(server.pubsub_channels, (void *)channel, (void *)clients);
#line 37
      incrRefCount(channel);
    } else {
#line 39
      clients = (list *)de->val;
    }
#line 41
    listAddNodeTail(clients, (void *)c);
  }
#line 44
  addReply(c, shared.mbulk3);
#line 45
  addReply(c, shared.subscribebulk);
#line 46
  addReplyBulk(c, channel);
#line 47
  addReplyLongLong(c, (long long )(((c->pubsub_channels)->ht[0].used + (c->pubsub_channels)->ht[1].used) + (unsigned long )(c->pubsub_patterns)->len));
#line 48
  return (retval);
}
}
#line 53 "pubsub.c"
int pubsubUnsubscribeChannel(redisClient *c , robj *channel , int notify ) 
{ struct dictEntry *de ;
  list *clients ;
  listNode *ln ;
  int retval ;
  int __cil_tmp ;

  {
#line 57
  retval = 0;
#line 60
  incrRefCount(channel);
#line 62
  __cil_tmp = dictDelete(c->pubsub_channels, (void const   *)channel);
#line 62
  if (__cil_tmp == 0) {
#line 63
    retval = 1;
#line 65
    de = dictFind(server.pubsub_channels, (void const   *)channel);
#line 66
    if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 66
      _redisAssert((char *)"de != NULL", (char *)"pubsub.c", 66);
#line 66
      _exit(1);
    }
#line 67
    clients = (list *)de->val;
#line 68
    ln = listSearchKey(clients, (void *)c);
#line 69
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 69
      _redisAssert((char *)"ln != NULL", (char *)"pubsub.c", 69);
#line 69
      _exit(1);
    }
#line 70
    listDelNode(clients, ln);
#line 71
    if (clients->len == 0U) {
#line 75
      dictDelete(server.pubsub_channels, (void const   *)channel);
    }
  }
#line 79
  if (notify) {
#line 80
    addReply(c, shared.mbulk3);
#line 81
    addReply(c, shared.unsubscribebulk);
#line 82
    addReplyBulk(c, channel);
#line 83
    addReplyLongLong(c, (long long )(((c->pubsub_channels)->ht[0].used + (c->pubsub_channels)->ht[1].used) + (unsigned long )(c->pubsub_patterns)->len));
  }
#line 87
  decrRefCount((void *)channel);
#line 88
  return (retval);
}
}
#line 92 "pubsub.c"
int pubsubSubscribePattern(redisClient *c , robj *pattern ) 
{ int retval ;
  pubsubPattern *pat ;
  void *__cil_tmp ;
  listNode *__cil_tmp___0 ;

  {
#line 93
  retval = 0;
#line 95
  __cil_tmp___0 = listSearchKey(c->pubsub_patterns, (void *)pattern);
#line 95
  if ((unsigned int )__cil_tmp___0 == (unsigned int )((void *)0)) {
#line 96
    retval = 1;
#line 98
    listAddNodeTail(c->pubsub_patterns, (void *)pattern);
#line 99
    incrRefCount(pattern);
#line 100
    __cil_tmp = malloc((unsigned int )sizeof(*pat));
#line 100
    pat = (pubsubPattern *)__cil_tmp;
#line 101
    pat->pattern = getDecodedObject(pattern);
#line 102
    pat->client = c;
#line 103
    listAddNodeTail(server.pubsub_patterns, (void *)pat);
  }
#line 106
  addReply(c, shared.mbulk3);
#line 107
  addReply(c, shared.psubscribebulk);
#line 108
  addReplyBulk(c, pattern);
#line 109
  addReplyLongLong(c, (long long )(((c->pubsub_channels)->ht[0].used + (c->pubsub_channels)->ht[1].used) + (unsigned long )(c->pubsub_patterns)->len));
#line 110
  return (retval);
}
}
#line 115 "pubsub.c"
int pubsubUnsubscribePattern(redisClient *c , robj *pattern , int notify ) 
{ listNode *ln ;
  pubsubPattern pat ;
  int retval ;

  {
#line 118
  retval = 0;
#line 120
  incrRefCount(pattern);
#line 121
  ln = listSearchKey(c->pubsub_patterns, (void *)pattern);
#line 121
  if ((unsigned int )ln != (unsigned int )((void *)0)) {
#line 122
    retval = 1;
#line 123
    listDelNode(c->pubsub_patterns, ln);
#line 124
    pat.client = c;
#line 125
    pat.pattern = pattern;
#line 126
    ln = listSearchKey(server.pubsub_patterns, (void *)(& pat));
#line 127
    listDelNode(server.pubsub_patterns, ln);
  }
#line 130
  if (notify) {
#line 131
    addReply(c, shared.mbulk3);
#line 132
    addReply(c, shared.punsubscribebulk);
#line 133
    addReplyBulk(c, pattern);
#line 134
    addReplyLongLong(c, (long long )(((c->pubsub_channels)->ht[0].used + (c->pubsub_channels)->ht[1].used) + (unsigned long )(c->pubsub_patterns)->len));
  }
#line 137
  decrRefCount((void *)pattern);
#line 138
  return (retval);
}
}
#line 143 "pubsub.c"
int pubsubUnsubscribeAllChannels(redisClient *c , int notify ) 
{ dictIterator *di ;
  dictIterator *__cil_tmp ;
  dictEntry *de ;
  int count ;
  robj *channel ;
  int __cil_tmp___0 ;

  {
#line 144
  __cil_tmp = dictGetIterator(c->pubsub_channels);
#line 144
  di = __cil_tmp;
#line 146
  count = 0;
#line 148
  while (1) {
#line 148
    de = dictNext(di);
#line 148
    if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 148
      break;
    }
#line 149
    channel = (robj *)de->key;
#line 151
    __cil_tmp___0 = pubsubUnsubscribeChannel(c, channel, notify);
#line 151
    count += __cil_tmp___0;
  }
#line 153
  dictReleaseIterator(di);
#line 154
  return (count);
}
}
#line 159 "pubsub.c"
int pubsubUnsubscribeAllPatterns(redisClient *c , int notify ) 
{ listNode *ln ;
  listIter li ;
  int count ;
  robj *pattern ;
  int __cil_tmp ;

  {
#line 162
  count = 0;
#line 164
  listRewind(c->pubsub_patterns, & li);
#line 165
  while (1) {
#line 165
    ln = listNext(& li);
#line 165
    if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 165
      break;
    }
#line 166
    pattern = (robj *)ln->value;
#line 168
    __cil_tmp = pubsubUnsubscribePattern(c, pattern, notify);
#line 168
    count += __cil_tmp;
  }
#line 170
  return (count);
}
}
#line 174 "pubsub.c"
int pubsubPublishMessage(robj *channel , robj *message ) 
{ int receivers ;
  struct dictEntry *de ;
  listNode *ln ;
  listIter li ;
  list *list___0 ;
  listNode *ln___0 ;
  listIter li___0 ;
  redisClient *c ;
  pubsubPattern *pat ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 175
  receivers = 0;
#line 181
  de = dictFind(server.pubsub_channels, (void const   *)channel);
#line 182
  if (de) {
#line 183
    list___0 = (list *)de->val;
#line 187
    listRewind(list___0, & li___0);
#line 188
    while (1) {
#line 188
      ln___0 = listNext(& li___0);
#line 188
      if (! ((unsigned int )ln___0 != (unsigned int )((void *)0))) {
#line 188
        break;
      }
#line 189
      c = (redisClient *)ln___0->value;
#line 191
      addReply(c, shared.mbulk3);
#line 192
      addReply(c, shared.messagebulk);
#line 193
      addReplyBulk(c, channel);
#line 194
      addReplyBulk(c, message);
#line 195
      receivers ++;
    }
  }
#line 199
  if ((server.pubsub_patterns)->len) {
#line 200
    listRewind(server.pubsub_patterns, & li);
#line 201
    channel = getDecodedObject(channel);
#line 202
    while (1) {
#line 202
      ln = listNext(& li);
#line 202
      if (! ((unsigned int )ln != (unsigned int )((void *)0))) {
#line 202
        break;
      }
#line 203
      pat = (pubsubPattern *)ln->value;
#line 205
      __cil_tmp = sdslen((char *)channel->ptr);
#line 205
      __cil_tmp___0 = sdslen((char *)(pat->pattern)->ptr);
#line 205
      __cil_tmp___1 = stringmatchlen((char const   *)((char *)(pat->pattern)->ptr),
                                     (int )__cil_tmp___0, (char const   *)((char *)channel->ptr),
                                     (int )__cil_tmp, 0);
#line 205
      if (__cil_tmp___1) {
#line 209
        addReply(pat->client, shared.mbulk4);
#line 210
        addReply(pat->client, shared.pmessagebulk);
#line 211
        addReplyBulk(pat->client, pat->pattern);
#line 212
        addReplyBulk(pat->client, channel);
#line 213
        addReplyBulk(pat->client, message);
#line 214
        receivers ++;
      }
    }
#line 217
    decrRefCount((void *)channel);
  }
#line 219
  return (receivers);
}
}
#line 226 "pubsub.c"
void subscribeCommand(redisClient *c ) 
{ int j ;

  {
#line 229
  j = 1;
#line 229
  while (j < c->argc) {
#line 230
    pubsubSubscribeChannel(c, *(c->argv + j));
#line 229
    j ++;
  }
#line 231
  return;
}
}
#line 233 "pubsub.c"
void unsubscribeCommand(redisClient *c ) 
{ int j ;

  {
#line 234
  if (c->argc == 1) {
#line 235
    pubsubUnsubscribeAllChannels(c, 1);
#line 236
    return;
  } else {
#line 240
    j = 1;
#line 240
    while (j < c->argc) {
#line 241
      pubsubUnsubscribeChannel(c, *(c->argv + j), 1);
#line 240
      j ++;
    }
  }
#line 243
  return;
}
}
#line 245 "pubsub.c"
void psubscribeCommand(redisClient *c ) 
{ int j ;

  {
#line 248
  j = 1;
#line 248
  while (j < c->argc) {
#line 249
    pubsubSubscribePattern(c, *(c->argv + j));
#line 248
    j ++;
  }
#line 250
  return;
}
}
#line 252 "pubsub.c"
void punsubscribeCommand(redisClient *c ) 
{ int j ;

  {
#line 253
  if (c->argc == 1) {
#line 254
    pubsubUnsubscribeAllPatterns(c, 1);
#line 255
    return;
  } else {
#line 259
    j = 1;
#line 259
    while (j < c->argc) {
#line 260
      pubsubUnsubscribePattern(c, *(c->argv + j), 1);
#line 259
      j ++;
    }
  }
#line 262
  return;
}
}
#line 264 "pubsub.c"
void publishCommand(redisClient *c ) 
{ int receivers ;
  int __cil_tmp ;

  {
#line 265
  __cil_tmp = pubsubPublishMessage(*(c->argv + 1), *(c->argv + 2));
#line 265
  receivers = __cil_tmp;
#line 266
  addReplyLongLong(c, (long long )receivers);
#line 267
  return;
}
}
#line 1 "multi.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IeD0KeQz.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 6 "multi.c"
void initClientMultiState(redisClient *c ) 
{ 

  {
#line 7
  c->mstate.commands = (multiCmd *)((void *)0);
#line 8
  c->mstate.count = 0;
#line 9
  return;
}
}
#line 12 "multi.c"
void freeClientMultiState(redisClient *c ) 
{ int j ;
  int i ;
  multiCmd *mc ;

  {
#line 15
  j = 0;
#line 15
  while (j < c->mstate.count) {
#line 17
    mc = c->mstate.commands + j;
#line 19
    i = 0;
#line 19
    while (i < mc->argc) {
#line 20
      decrRefCount((void *)*(mc->argv + i));
#line 19
      i ++;
    }
#line 21
    free((void *)mc->argv);
#line 15
    j ++;
  }
#line 23
  free((void *)c->mstate.commands);
#line 24
  return;
}
}
#line 27 "multi.c"
void queueMultiCommand(redisClient *c , struct redisCommand *cmd ) 
{ multiCmd *mc ;
  int j ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 31
  __cil_tmp = realloc((void *)c->mstate.commands, (unsigned int )(sizeof(multiCmd ) * (unsigned long )(c->mstate.count + 1)));
#line 31
  c->mstate.commands = (multiCmd *)__cil_tmp;
#line 33
  mc = c->mstate.commands + c->mstate.count;
#line 34
  mc->cmd = cmd;
#line 35
  mc->argc = c->argc;
#line 36
  __cil_tmp___0 = malloc((unsigned int )(sizeof(robj *) * (unsigned long )c->argc));
#line 36
  mc->argv = (robj **)__cil_tmp___0;
#line 37
  memcpy((void *)mc->argv, (void const   *)c->argv, (unsigned int )(sizeof(robj *) * (unsigned long )c->argc));
#line 38
  j = 0;
#line 38
  while (j < c->argc) {
#line 39
    incrRefCount(*(mc->argv + j));
#line 38
    j ++;
  }
#line 40
  (c->mstate.count) ++;
#line 41
  return;
}
}
#line 43 "multi.c"
void multiCommand(redisClient *c ) 
{ 

  {
#line 44
  if (c->flags & 8) {
#line 45
    addReplyError(c, (char *)"MULTI calls can not be nested");
#line 46
    return;
  }
#line 48
  c->flags |= 8;
#line 49
  addReply(c, shared.ok);
#line 50
  return;
}
}
#line 52 "multi.c"
void discardCommand(redisClient *c ) 
{ 

  {
#line 53
  if (! (c->flags & 8)) {
#line 54
    addReplyError(c, (char *)"DISCARD without MULTI");
#line 55
    return;
  }
#line 58
  freeClientMultiState(c);
#line 59
  initClientMultiState(c);
#line 60
  c->flags &= -9;
#line 61
  unwatchAllKeys(c);
#line 62
  addReply(c, shared.ok);
#line 63
  return;
}
}
#line 67 "multi.c"
void execCommandReplicateMulti(redisClient *c ) 
{ robj *multistring ;
  robj *__cil_tmp ;

  {
#line 68
  __cil_tmp = createStringObject((char *)"MULTI", 5U);
#line 68
  multistring = __cil_tmp;
#line 70
  if (server.appendonly) {
#line 71
    feedAppendOnlyFile(server.multiCommand, (c->db)->id, & multistring, 1);
  }
#line 72
  if ((server.slaves)->len) {
#line 73
    replicationFeedSlaves(server.slaves, (c->db)->id, & multistring, 1);
  }
#line 74
  decrRefCount((void *)multistring);
#line 75
  return;
}
}
#line 77 "multi.c"
void execCommand(redisClient *c ) 
{ int j ;
  robj **orig_argv ;
  int orig_argc ;

  {
#line 82
  if (! (c->flags & 8)) {
#line 83
    addReplyError(c, (char *)"EXEC without MULTI");
#line 84
    return;
  }
#line 89
  if (c->flags & 64) {
#line 90
    freeClientMultiState(c);
#line 91
    initClientMultiState(c);
#line 92
    c->flags &= -73;
#line 93
    unwatchAllKeys(c);
#line 94
    addReply(c, shared.nullmultibulk);
#line 95
    return;
  }
#line 102
  execCommandReplicateMulti(c);
#line 105
  unwatchAllKeys(c);
#line 106
  orig_argv = c->argv;
#line 107
  orig_argc = c->argc;
#line 108
  addReplyMultiBulkLen(c, (long )c->mstate.count);
#line 109
  j = 0;
#line 109
  while (j < c->mstate.count) {
#line 110
    c->argc = (c->mstate.commands + j)->argc;
#line 111
    c->argv = (c->mstate.commands + j)->argv;
#line 112
    call(c, (c->mstate.commands + j)->cmd);
#line 109
    j ++;
  }
#line 114
  c->argv = orig_argv;
#line 115
  c->argc = orig_argc;
#line 116
  freeClientMultiState(c);
#line 117
  initClientMultiState(c);
#line 118
  c->flags &= -73;
#line 122
  (server.dirty) ++;
#line 123
  return;
}
}
#line 143 "multi.c"
void watchForKey(redisClient *c , robj *key ) 
{ list *clients ;
  listIter li ;
  listNode *ln ;
  watchedKey *wk ;
  int __cil_tmp ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;

  {
#line 144
  clients = (list *)((void *)0);
#line 150
  listRewind(c->watched_keys, & li);
#line 151
  while (1) {
#line 151
    ln = listNext(& li);
#line 151
    if (! ln) {
#line 151
      break;
    }
#line 152
    wk = (watchedKey *)ln->value;
#line 153
    if ((unsigned int )wk->db == (unsigned int )c->db) {
#line 153
      __cil_tmp = equalStringObjects(key, wk->key);
#line 153
      if (__cil_tmp) {
#line 154
        return;
      }
    }
  }
#line 157
  __cil_tmp___0 = dictFetchValue((c->db)->watched_keys, (void const   *)key);
#line 157
  clients = (list *)__cil_tmp___0;
#line 158
  if (! clients) {
#line 159
    clients = listCreate();
#line 160
    dictAdd((c->db)->watched_keys, (void *)key, (void *)clients);
#line 161
    incrRefCount(key);
  }
#line 163
  listAddNodeTail(clients, (void *)c);
#line 165
  __cil_tmp___1 = malloc((unsigned int )sizeof(*wk));
#line 165
  wk = (watchedKey *)__cil_tmp___1;
#line 166
  wk->key = key;
#line 167
  wk->db = c->db;
#line 168
  incrRefCount(key);
#line 169
  listAddNodeTail(c->watched_keys, (void *)wk);
#line 170
  return;
}
}
#line 174 "multi.c"
void unwatchAllKeys(redisClient *c ) 
{ listIter li ;
  listNode *ln ;
  list *clients ;
  watchedKey *wk ;
  void *__cil_tmp ;
  listNode *__cil_tmp___0 ;

  {
#line 178
  if ((c->watched_keys)->len == 0U) {
#line 178
    return;
  }
#line 179
  listRewind(c->watched_keys, & li);
#line 180
  while (1) {
#line 180
    ln = listNext(& li);
#line 180
    if (! ln) {
#line 180
      break;
    }
#line 186
    wk = (watchedKey *)ln->value;
#line 187
    __cil_tmp = dictFetchValue((wk->db)->watched_keys, (void const   *)wk->key);
#line 187
    clients = (list *)__cil_tmp;
#line 188
    if (! ((unsigned int )clients != (unsigned int )((void *)0))) {
#line 188
      _redisAssert((char *)"clients != NULL", (char *)"multi.c", 188);
#line 188
      _exit(1);
    }
#line 189
    __cil_tmp___0 = listSearchKey(clients, (void *)c);
#line 189
    listDelNode(clients, __cil_tmp___0);
#line 191
    if (clients->len == 0U) {
#line 192
      dictDelete((wk->db)->watched_keys, (void const   *)wk->key);
    }
#line 194
    listDelNode(c->watched_keys, ln);
#line 195
    decrRefCount((void *)wk->key);
#line 196
    free((void *)wk);
  }
#line 198
  return;
}
}
#line 202 "multi.c"
void touchWatchedKey(redisDb *db , robj *key ) 
{ list *clients ;
  listIter li ;
  listNode *ln ;
  void *__cil_tmp ;
  redisClient *c ;

  {
#line 207
  if ((db->watched_keys)->ht[0].used + (db->watched_keys)->ht[1].used == 0UL) {
#line 207
    return;
  }
#line 208
  __cil_tmp = dictFetchValue(db->watched_keys, (void const   *)key);
#line 208
  clients = (list *)__cil_tmp;
#line 209
  if (! clients) {
#line 209
    return;
  }
#line 213
  listRewind(clients, & li);
#line 214
  while (1) {
#line 214
    ln = listNext(& li);
#line 214
    if (! ln) {
#line 214
      break;
    }
#line 215
    c = (redisClient *)ln->value;
#line 217
    c->flags |= 64;
  }
#line 219
  return;
}
}
#line 225 "multi.c"
void touchWatchedKeysOnFlush(int dbid ) 
{ listIter li1 ;
  listIter li2 ;
  listNode *ln ;
  redisClient *c ;
  watchedKey *wk ;
  dictEntry *__cil_tmp ;

  {
#line 230
  listRewind(server.clients, & li1);
#line 231
  while (1) {
#line 231
    ln = listNext(& li1);
#line 231
    if (! ln) {
#line 231
      break;
    }
#line 232
    c = (redisClient *)ln->value;
#line 233
    listRewind(c->watched_keys, & li2);
#line 234
    while (1) {
#line 234
      ln = listNext(& li2);
#line 234
      if (! ln) {
#line 234
        break;
      }
#line 235
      wk = (watchedKey *)ln->value;
#line 240
      if (dbid == -1 || (wk->db)->id == dbid) {
#line 241
        __cil_tmp = dictFind((wk->db)->dict, (void const   *)(wk->key)->ptr);
#line 241
        if ((unsigned int )__cil_tmp != (unsigned int )((void *)0)) {
#line 242
          c->flags |= 64;
        }
      }
    }
  }
#line 246
  return;
}
}
#line 248 "multi.c"
void watchCommand(redisClient *c ) 
{ int j ;

  {
#line 251
  if (c->flags & 8) {
#line 252
    addReplyError(c, (char *)"WATCH inside MULTI is not allowed");
#line 253
    return;
  }
#line 255
  j = 1;
#line 255
  while (j < c->argc) {
#line 256
    watchForKey(c, *(c->argv + j));
#line 255
    j ++;
  }
#line 257
  addReply(c, shared.ok);
#line 258
  return;
}
}
#line 260 "multi.c"
void unwatchCommand(redisClient *c ) 
{ 

  {
#line 261
  unwatchAllKeys(c);
#line 262
  c->flags &= -65;
#line 263
  addReply(c, shared.ok);
#line 264
  return;
}
}
#line 1 "debug.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-KdP2SMwa.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 14 "debug.c"
void xorDigest(unsigned char *digest , void *ptr , size_t len ) 
{ SHA1_CTX ctx ;
  unsigned char hash[20] ;
  unsigned char *s ;
  int j ;

  {
#line 16
  s = (unsigned char *)ptr;
#line 19
  SHA1Init(& ctx);
#line 20
  SHA1Update(& ctx, (unsigned char const   *)s, (unsigned long )len);
#line 21
  SHA1Final(hash, & ctx);
#line 23
  j = 0;
#line 23
  while (j < 20) {
#line 24
    *(digest + j) = (unsigned char )((int )*(digest + j) ^ (int )hash[j]);
#line 23
    j ++;
  }
#line 25
  return;
}
}
#line 27 "debug.c"
void xorObjectDigest(unsigned char *digest , robj *o ) 
{ size_t __cil_tmp ;

  {
#line 28
  o = getDecodedObject(o);
#line 29
  __cil_tmp = sdslen((char *)o->ptr);
#line 29
  xorDigest(digest, o->ptr, __cil_tmp);
#line 30
  decrRefCount((void *)o);
#line 31
  return;
}
}
#line 47 "debug.c"
void mixDigest(unsigned char *digest , void *ptr , size_t len ) 
{ SHA1_CTX ctx ;
  char *s ;

  {
#line 49
  s = (char *)ptr;
#line 51
  xorDigest(digest, (void *)s, len);
#line 52
  SHA1Init(& ctx);
#line 53
  SHA1Update(& ctx, (unsigned char const   *)digest, 20UL);
#line 54
  SHA1Final(digest, & ctx);
#line 55
  return;
}
}
#line 57 "debug.c"
void mixObjectDigest(unsigned char *digest , robj *o ) 
{ size_t __cil_tmp ;

  {
#line 58
  o = getDecodedObject(o);
#line 59
  __cil_tmp = sdslen((char *)o->ptr);
#line 59
  mixDigest(digest, o->ptr, __cil_tmp);
#line 60
  decrRefCount((void *)o);
#line 61
  return;
}
}
#line 69 "debug.c"
void computeDatasetDigest(unsigned char *final ) 
{ unsigned char digest[20] ;
  char buf[128] ;
  dictIterator *di ;
  dictEntry *de ;
  int j ;
  uint32_t aux ;
  redisDb *db ;
  sds key ;
  robj *keyobj ;
  robj *o ;
  time_t expiretime ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  listTypeIterator *li ;
  listTypeIterator *__cil_tmp___1 ;
  listTypeEntry entry ;
  robj *eleobj ;
  robj *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  setTypeIterator *si ;
  setTypeIterator *__cil_tmp___4 ;
  robj *ele ;
  zset *zs ;
  dictIterator *di___0 ;
  dictIterator *__cil_tmp___5 ;
  dictEntry *de___0 ;
  robj *eleobj___0 ;
  double *score ;
  unsigned char eledigest[20] ;
  size_t __cil_tmp___6 ;
  hashTypeIterator *hi ;
  robj *obj ;
  unsigned char eledigest___0[20] ;
  int __cil_tmp___7 ;

  {
#line 72
  di = (dictIterator *)((void *)0);
#line 77
  memset((void *)final, 0, 20U);
#line 79
  j = 0;
#line 79
  while (j < server.dbnum) {
#line 80
    db = server.db + j;
#line 82
    if ((db->dict)->ht[0].used + (db->dict)->ht[1].used == 0UL) {
#line 82
      goto __Cont;
    }
#line 83
    di = dictGetIterator(db->dict);
#line 87
    aux = (unsigned long )((((((unsigned int )j & 4278190080U) >> 24) | (unsigned int )((j & 16711680) >> 8)) | (unsigned int )((j & 65280) << 8)) | (unsigned int )((j & 255) << 24));
#line 88
    mixDigest(final, (void *)(& aux), (unsigned int )sizeof(aux));
#line 91
    while (1) {
#line 91
      de = dictNext(di);
#line 91
      if (! ((unsigned int )de != (unsigned int )((void *)0))) {
#line 91
        break;
      }
#line 96
      memset((void *)(digest), 0, 20U);
#line 97
      key = (char *)de->key;
#line 98
      __cil_tmp = sdslen(key);
#line 98
      keyobj = createStringObject(key, __cil_tmp);
#line 100
      __cil_tmp___0 = sdslen(key);
#line 100
      mixDigest(digest, (void *)key, __cil_tmp___0);
#line 103
      o = lookupKeyRead(db, keyobj);
#line 105
      aux = (unsigned long )(((((o->type & 4278190080U) >> 24) | ((o->type & 16711680U) >> 8)) | ((o->type & 65280U) << 8)) | ((o->type & 255U) << 24));
#line 106
      mixDigest(digest, (void *)(& aux), (unsigned int )sizeof(aux));
#line 107
      expiretime = getExpire(db, keyobj);
#line 110
      if (o->type == 0U) {
#line 111
        mixObjectDigest(digest, o);
      } else
#line 112
      if (o->type == 1U) {
#line 113
        __cil_tmp___1 = listTypeInitIterator(o, 0, (unsigned char)1);
#line 113
        li = __cil_tmp___1;
#line 115
        while (1) {
#line 115
          __cil_tmp___3 = listTypeNext(li, & entry);
#line 115
          if (! __cil_tmp___3) {
#line 115
            break;
          }
#line 116
          __cil_tmp___2 = listTypeGet(& entry);
#line 116
          eleobj = __cil_tmp___2;
#line 117
          mixObjectDigest(digest, eleobj);
#line 118
          decrRefCount((void *)eleobj);
        }
#line 120
        listTypeReleaseIterator(li);
      } else
#line 121
      if (o->type == 2U) {
#line 122
        __cil_tmp___4 = setTypeInitIterator(o);
#line 122
        si = __cil_tmp___4;
#line 124
        while (1) {
#line 124
          ele = setTypeNextObject(si);
#line 124
          if (! ((unsigned int )ele != (unsigned int )((void *)0))) {
#line 124
            break;
          }
#line 125
          xorObjectDigest(digest, ele);
#line 126
          decrRefCount((void *)ele);
        }
#line 128
        setTypeReleaseIterator(si);
      } else
#line 129
      if (o->type == 3U) {
#line 130
        zs = (zset *)o->ptr;
#line 131
        __cil_tmp___5 = dictGetIterator(zs->dict);
#line 131
        di___0 = __cil_tmp___5;
#line 134
        while (1) {
#line 134
          de___0 = dictNext(di___0);
#line 134
          if (! ((unsigned int )de___0 != (unsigned int )((void *)0))) {
#line 134
            break;
          }
#line 135
          eleobj___0 = (robj *)de___0->key;
#line 136
          score = (double *)de___0->val;
#line 139
          snprintf(buf, (unsigned int )sizeof(buf), "%.17g", *score);
#line 140
          memset((void *)(eledigest), 0, 20U);
#line 141
          mixObjectDigest(eledigest, eleobj___0);
#line 142
          __cil_tmp___6 = strlen((char const   *)(buf));
#line 142
          mixDigest(eledigest, (void *)(buf), __cil_tmp___6);
#line 143
          xorDigest(digest, (void *)(eledigest), 20U);
        }
#line 145
        dictReleaseIterator(di___0);
      } else
#line 146
      if (o->type == 4U) {
#line 150
        hi = hashTypeInitIterator(o);
#line 151
        while (1) {
#line 151
          __cil_tmp___7 = hashTypeNext(hi);
#line 151
          if (! (__cil_tmp___7 != -1)) {
#line 151
            break;
          }
#line 154
          memset((void *)(eledigest___0), 0, 20U);
#line 155
          obj = hashTypeCurrentObject(hi, 1);
#line 156
          mixObjectDigest(eledigest___0, obj);
#line 157
          decrRefCount((void *)obj);
#line 158
          obj = hashTypeCurrentObject(hi, 2);
#line 159
          mixObjectDigest(eledigest___0, obj);
#line 160
          decrRefCount((void *)obj);
#line 161
          xorDigest(digest, (void *)(eledigest___0), 20U);
        }
#line 163
        hashTypeReleaseIterator(hi);
      } else {
#line 165
        _redisPanic((char *)"\"Unknown object type\"", (char *)"debug.c", 165);
#line 165
        _exit(1);
      }
#line 168
      if (expiretime != -1L) {
#line 168
        xorDigest(digest, (void *)"!!expire!!", 10U);
      }
#line 170
      xorDigest(final, (void *)(digest), 20U);
#line 171
      decrRefCount((void *)keyobj);
    }
#line 173
    dictReleaseIterator(di);
    __Cont: 
#line 79
    j ++;
  }
#line 175
  return;
}
}
#line 177 "debug.c"
void debugCommand(redisClient *c ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  dictEntry *de ;
  dictEntry *__cil_tmp___2 ;
  robj *val ;
  char *strenc ;
  unsigned long __cil_tmp___3 ;
  off_t __cil_tmp___4 ;
  vmpointer *vp ;
  dictEntry *de___0 ;
  dictEntry *__cil_tmp___5 ;
  robj *val___0 ;
  vmpointer *vp___0 ;
  long keys ;
  long j ;
  robj *key ;
  robj *val___1 ;
  char buf[128] ;
  int __cil_tmp___6 ;
  size_t __cil_tmp___7 ;
  robj *__cil_tmp___8 ;
  size_t __cil_tmp___9 ;
  unsigned char digest[20] ;
  sds d ;
  sds __cil_tmp___10 ;
  int j___0 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  int __cil_tmp___17 ;
  int __cil_tmp___18 ;

  {
#line 178
  __cil_tmp___18 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "segfault");
#line 178
  if (__cil_tmp___18) {
#line 180
    __cil_tmp___17 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "reload");
#line 180
    if (__cil_tmp___17) {
#line 192
      __cil_tmp___16 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "loadaof");
#line 192
      if (__cil_tmp___16) {
#line 200
        __cil_tmp___15 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "object");
#line 200
        if (__cil_tmp___15) {
          _L___2: 
#line 229
          __cil_tmp___14 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "swapin");
#line 229
          if (__cil_tmp___14) {
            _L___1: 
#line 232
            __cil_tmp___13 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "swapout");
#line 232
            if (__cil_tmp___13) {
              _L___0: 
#line 257
              __cil_tmp___12 = strcasecmp((char const   *)(*(c->argv + 1))->ptr, "populate");
#line 257
              if (__cil_tmp___12) {
                _L: 
#line 277
                __cil_tmp___11 = strcasecmp((char const   *)(*(c->argv + 1))->ptr,
                                            "digest");
#line 277
                if (__cil_tmp___11) {
#line 288
                  addReplyError(c, (char *)"Syntax error, try DEBUG [SEGFAULT|OBJECT <key>|SWAPIN <key>|SWAPOUT <key>|RELOAD]");
                } else
#line 277
                if (c->argc == 2) {
#line 279
                  __cil_tmp___10 = sdsempty();
#line 279
                  d = __cil_tmp___10;
#line 282
                  computeDatasetDigest(digest);
#line 283
                  j___0 = 0;
#line 283
                  while (j___0 < 20) {
#line 284
                    d = sdscatprintf(d, "%02x", (int )digest[j___0]);
#line 283
                    j___0 ++;
                  }
#line 285
                  addReplyStatus(c, d);
#line 286
                  sdsfree(d);
                } else {
#line 288
                  addReplyError(c, (char *)"Syntax error, try DEBUG [SEGFAULT|OBJECT <key>|SWAPIN <key>|SWAPOUT <key>|RELOAD]");
                }
              } else
#line 257
              if (c->argc == 3) {
#line 262
                __cil_tmp___6 = getLongFromObjectOrReply(c, *(c->argv + 2), & keys,
                                                         (char const   *)((void *)0));
#line 262
                if (__cil_tmp___6 != 0) {
#line 263
                  return;
                }
#line 264
                j = 0L;
#line 264
                while (j < keys) {
#line 265
                  snprintf(buf, (unsigned int )sizeof(buf), "key:%lu", j);
#line 266
                  __cil_tmp___7 = strlen((char const   *)(buf));
#line 266
                  key = createStringObject(buf, __cil_tmp___7);
#line 267
                  __cil_tmp___8 = lookupKeyRead(c->db, key);
#line 267
                  if ((unsigned int )__cil_tmp___8 != (unsigned int )((void *)0)) {
#line 268
                    decrRefCount((void *)key);
#line 269
                    goto __Cont;
                  }
#line 271
                  snprintf(buf, (unsigned int )sizeof(buf), "value:%lu", j);
#line 272
                  __cil_tmp___9 = strlen((char const   *)(buf));
#line 272
                  val___1 = createStringObject(buf, __cil_tmp___9);
#line 273
                  dbAdd(c->db, key, val___1);
#line 274
                  decrRefCount((void *)key);
                  __Cont: 
#line 264
                  j ++;
                }
#line 276
                addReply(c, shared.ok);
              } else {
#line 257
                goto _L;
              }
            } else
#line 232
            if (c->argc == 3) {
#line 233
              __cil_tmp___5 = dictFind((c->db)->dict, (void const   *)(*(c->argv + 2))->ptr);
#line 233
              de___0 = __cil_tmp___5;
#line 237
              if (! server.vm_enabled) {
#line 238
                addReplyError(c, (char *)"Virtual Memory is disabled");
#line 239
                return;
              }
#line 241
              if (! de___0) {
#line 242
                addReply(c, shared.nokeyerr);
#line 243
                return;
              }
#line 245
              val___0 = (robj *)de___0->val;
#line 247
              if (val___0->storage != 0U) {
#line 248
                addReplyError(c, (char *)"This key is not in memory");
              } else
#line 249
              if (val___0->refcount != 1) {
#line 250
                addReplyError(c, (char *)"Object is shared");
              } else {
#line 251
                vp___0 = vmSwapObjectBlocking(val___0);
#line 251
                if ((unsigned int )vp___0 != (unsigned int )((void *)0)) {
#line 252
                  de___0->val = (void *)vp___0;
#line 253
                  addReply(c, shared.ok);
                } else {
#line 255
                  addReply(c, shared.err);
                }
              }
            } else {
#line 232
              goto _L___0;
            }
          } else
#line 229
          if (c->argc == 3) {
#line 230
            lookupKeyRead(c->db, *(c->argv + 2));
#line 231
            addReply(c, shared.ok);
          } else {
#line 229
            goto _L___1;
          }
        } else
#line 200
        if (c->argc == 3) {
#line 201
          __cil_tmp___2 = dictFind((c->db)->dict, (void const   *)(*(c->argv + 2))->ptr);
#line 201
          de = __cil_tmp___2;
#line 204
          if (! de) {
#line 205
            addReply(c, shared.nokeyerr);
#line 206
            return;
          }
#line 208
          val = (robj *)de->val;
#line 209
          if (! server.vm_enabled || (val->storage == 0U || val->storage == 2U)) {
#line 213
            strenc = strEncoding((int )val->encoding);
#line 214
            __cil_tmp___3 = estimateObjectIdleTime(val);
#line 214
            __cil_tmp___4 = rdbSavedObjectLen(val);
#line 214
            addReplyStatusFormat(c, "Value at:%p refcount:%d encoding:%s serializedlength:%lld lru:%d lru_seconds_idle:%lu",
                                 (void *)val, val->refcount, strenc, (long long )__cil_tmp___4,
                                 val->lru, __cil_tmp___3);
          } else {
#line 222
            vp = (vmpointer *)val;
#line 223
            addReplyStatusFormat(c, "Value swapped at: page %llu using %llu pages",
                                 (unsigned long long )vp->page, (unsigned long long )vp->usedpages);
          }
        } else {
#line 200
          goto _L___2;
        }
      } else {
#line 193
        emptyDb();
#line 194
        __cil_tmp___1 = loadAppendOnlyFile(server.appendfilename);
#line 194
        if (__cil_tmp___1 != 0) {
#line 195
          addReply(c, shared.err);
#line 196
          return;
        }
#line 198
        redisLog(3, "Append Only File loaded by DEBUG LOADAOF");
#line 199
        addReply(c, shared.ok);
      }
    } else {
#line 181
      __cil_tmp = rdbSave(server.dbfilename);
#line 181
      if (__cil_tmp != 0) {
#line 182
        addReply(c, shared.err);
#line 183
        return;
      }
#line 185
      emptyDb();
#line 186
      __cil_tmp___0 = rdbLoad(server.dbfilename);
#line 186
      if (__cil_tmp___0 != 0) {
#line 187
        addReply(c, shared.err);
#line 188
        return;
      }
#line 190
      redisLog(3, "DB reloaded by DEBUG RELOAD");
#line 191
      addReply(c, shared.ok);
    }
  } else {
#line 179
    *((char *)-1) = (char )'x';
  }
#line 291
  return;
}
}
#line 293 "debug.c"
void _redisAssert(char *estr , char *file , int line ) 
{ 

  {
#line 294
  redisLog(3, "=== ASSERTION FAILED ===");
#line 295
  redisLog(3, "==> %s:%d \'%s\' is not true", file, line, estr);
#line 300
  return;
}
}
#line 302 "debug.c"
void _redisPanic(char *msg , char *file , int line ) 
{ 

  {
#line 303
  redisLog(3, "!!! Software Failure. Press left mouse button to continue");
#line 304
  redisLog(3, "Guru Meditation: %s #%s:%d", msg, file, line);
#line 309
  return;
}
}
#line 1 "sort.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-sOIRTSPW.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 30 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
int strcoll(char const   *a , char const   *b ) ;
#line 4 "sort.c"
redisSortOperation *createSortOperation(int type , robj *pattern ) 
{ redisSortOperation *so ;
  void *__cil_tmp ;

  {
#line 5
  __cil_tmp = malloc((unsigned int )sizeof(*so));
#line 5
  so = (redisSortOperation *)__cil_tmp;
#line 6
  so->type = type;
#line 7
  so->pattern = pattern;
#line 8
  return (so);
}
}
#line 15 "sort.c"
robj *lookupKeyByPattern(redisDb *db , robj *pattern , robj *subst ) 
{ char *p ;
  char *f ;
  sds spat ;
  sds ssub ;
  robj keyobj ;
  robj fieldobj ;
  robj *o ;
  int prefixlen ;
  int sublen ;
  int postfixlen ;
  int fieldlen ;
  struct __anonstruct_keyname_16 keyname ;
  struct __anonstruct_keyname_16 fieldname ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  size_t __cil_tmp___3 ;

  {
#line 29
  spat = (char *)pattern->ptr;
#line 30
  if ((int )*(spat + 0) == 35 && (int )*(spat + 1) == 0) {
#line 31
    incrRefCount(subst);
#line 32
    return (subst);
  }
#line 38
  subst = getDecodedObject(subst);
#line 40
  ssub = (char *)subst->ptr;
#line 41
  __cil_tmp = sdslen(spat);
#line 41
  __cil_tmp___0 = sdslen(ssub);
#line 41
  if ((__cil_tmp + __cil_tmp___0) - 1U > 1024U) {
#line 41
    return ((robj *)((void *)0));
  }
#line 42
  p = strchr((char const   *)spat, '*');
#line 43
  if (! p) {
#line 44
    decrRefCount((void *)subst);
#line 45
    return ((robj *)((void *)0));
  }
#line 49
  f = strstr((char const   *)(p + 1), "->");
#line 49
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 50
    __cil_tmp___1 = sdslen(spat);
#line 50
    fieldlen = (int )(__cil_tmp___1 - (unsigned int )(f - spat));
#line 52
    memcpy((void *)(fieldname.buf), (void const   *)(f + 2), (unsigned int )(fieldlen - 1));
#line 53
    fieldname.len = fieldlen - 2;
  } else {
#line 55
    fieldlen = 0;
  }
#line 58
  prefixlen = p - spat;
#line 59
  __cil_tmp___2 = sdslen(ssub);
#line 59
  sublen = (int )__cil_tmp___2;
#line 60
  __cil_tmp___3 = sdslen(spat);
#line 60
  postfixlen = (int )((__cil_tmp___3 - (unsigned int )(prefixlen + 1)) - (unsigned int )fieldlen);
#line 61
  memcpy((void *)(keyname.buf), (void const   *)spat, (unsigned int )prefixlen);
#line 62
  memcpy((void *)(keyname.buf + prefixlen), (void const   *)ssub, (unsigned int )sublen);
#line 63
  memcpy((void *)((keyname.buf + prefixlen) + sublen), (void const   *)(p + 1), (unsigned int )postfixlen);
#line 64
  keyname.buf[(prefixlen + sublen) + postfixlen] = (char )'\000';
#line 65
  keyname.len = (prefixlen + sublen) + postfixlen;
#line 66
  decrRefCount((void *)subst);
#line 69
  while (1) {
#line 69
    keyobj.refcount = 1;
#line 69
    keyobj.type = 0U;
#line 69
    keyobj.encoding = 0U;
#line 69
    keyobj.ptr = (void *)((char *)(& keyname) + sizeof(struct sdshdr ));
#line 69
    keyobj.storage = 0U;
#line 69
    break;
  }
#line 70
  o = lookupKeyRead(db, & keyobj);
#line 71
  if ((unsigned int )o == (unsigned int )((void *)0)) {
#line 71
    return ((robj *)((void *)0));
  }
#line 73
  if (fieldlen > 0) {
#line 74
    if (o->type != 4U || fieldname.len < 1) {
#line 74
      return ((robj *)((void *)0));
    }
#line 78
    while (1) {
#line 78
      fieldobj.refcount = 1;
#line 78
      fieldobj.type = 0U;
#line 78
      fieldobj.encoding = 0U;
#line 78
      fieldobj.ptr = (void *)((char *)(& fieldname) + sizeof(struct sdshdr ));
#line 78
      fieldobj.storage = 0U;
#line 78
      break;
    }
#line 79
    o = hashTypeGetObject(o, & fieldobj);
  } else {
#line 81
    if (o->type != 0U) {
#line 81
      return ((robj *)((void *)0));
    }
#line 85
    incrRefCount(o);
  }
#line 88
  return (o);
}
}
#line 94 "sort.c"
int sortCompare(void const   *s1___0 , void const   *s2___0 ) 
{ redisSortObject const   *so1 ;
  redisSortObject const   *so2 ;
  int cmp ;

  {
#line 95
  so1 = (redisSortObject const   *)s1___0;
#line 95
  so2 = (redisSortObject const   *)s2___0;
#line 98
  if (! server.sort_alpha) {
#line 100
    if (so1->u.score > so2->u.score) {
#line 101
      cmp = 1;
    } else
#line 102
    if (so1->u.score < so2->u.score) {
#line 103
      cmp = -1;
    } else {
#line 105
      cmp = 0;
    }
  } else
#line 109
  if (server.sort_bypattern) {
#line 110
    if (! so1->u.cmpobj || ! so2->u.cmpobj) {
#line 112
      if ((unsigned int )so1->u.cmpobj == (unsigned int )so2->u.cmpobj) {
#line 113
        cmp = 0;
      } else
#line 114
      if ((unsigned int )so1->u.cmpobj == (unsigned int )((void *)0)) {
#line 115
        cmp = -1;
      } else {
#line 117
        cmp = 1;
      }
    } else {
#line 120
      cmp = strcoll((char const   *)(so1->u.cmpobj)->ptr, (char const   *)(so2->u.cmpobj)->ptr);
    }
  } else {
#line 124
    cmp = compareStringObjects((robj *)so1->obj, (robj *)so2->obj);
  }
#line 127
  return (server.sort_desc ? - cmp : cmp);
}
}
#line 132 "sort.c"
void sortCommand(redisClient *c ) 
{ list *operations ;
  unsigned int outputlen ;
  int desc ;
  int alpha ;
  int limit_start ;
  int limit_count ;
  int start ;
  int end ;
  int j ;
  int dontsort ;
  int vectorlen ;
  int getop ;
  robj *sortval ;
  robj *sortby ;
  robj *storekey ;
  redisSortObject *vector ;
  int leftargs ;
  char *__cil_tmp ;
  redisSortOperation *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  unsigned long __cil_tmp___8 ;
  unsigned long __cil_tmp___9 ;
  void *__cil_tmp___10 ;
  listTypeIterator *li ;
  listTypeIterator *__cil_tmp___11 ;
  listTypeEntry entry ;
  int __cil_tmp___12 ;
  setTypeIterator *si ;
  setTypeIterator *__cil_tmp___13 ;
  robj *ele ;
  dict *set ;
  dictIterator *di ;
  dictEntry *setele ;
  robj *byval ;
  listNode *ln ;
  listIter li___0 ;
  redisSortOperation *sop ;
  robj *val ;
  robj *__cil_tmp___14 ;
  robj *sobj ;
  robj *__cil_tmp___15 ;
  listNode *ln___0 ;
  listIter li___1 ;
  redisSortOperation *sop___0 ;
  robj *val___0 ;
  robj *__cil_tmp___16 ;

  {
#line 134
  outputlen = 0U;
#line 135
  desc = 0;
#line 135
  alpha = 0;
#line 136
  limit_start = 0;
#line 136
  limit_count = -1;
#line 137
  dontsort = 0;
#line 138
  getop = 0;
#line 139
  sortby = (robj *)((void *)0);
#line 139
  storekey = (robj *)((void *)0);
#line 143
  sortval = lookupKeyRead(c->db, *(c->argv + 1));
#line 144
  if ((unsigned int )sortval == (unsigned int )((void *)0)) {
#line 145
    addReply(c, shared.emptymultibulk);
#line 146
    return;
  }
#line 148
  if ((sortval->type != 2U && sortval->type != 1U) && sortval->type != 3U) {
#line 151
    addReply(c, shared.wrongtypeerr);
#line 152
    return;
  }
#line 157
  operations = listCreate();
#line 158
  operations->free = & free;
#line 159
  j = 2;
#line 164
  incrRefCount(sortval);
#line 167
  while (j < c->argc) {
#line 168
    leftargs = (c->argc - j) - 1;
#line 169
    __cil_tmp___7 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "asc");
#line 169
    if (__cil_tmp___7) {
#line 171
      __cil_tmp___6 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "desc");
#line 171
      if (__cil_tmp___6) {
#line 173
        __cil_tmp___5 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "alpha");
#line 173
        if (__cil_tmp___5) {
#line 175
          __cil_tmp___4 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "limit");
#line 175
          if (__cil_tmp___4) {
            _L___1: 
#line 179
            __cil_tmp___3 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "store");
#line 179
            if (__cil_tmp___3) {
              _L___0: 
#line 182
              __cil_tmp___2 = strcasecmp((char const   *)(*(c->argv + j))->ptr, "by");
#line 182
              if (__cil_tmp___2) {
                _L: 
#line 188
                __cil_tmp___1 = strcasecmp((char const   *)(*(c->argv + j))->ptr,
                                           "get");
#line 188
                if (__cil_tmp___1) {
#line 194
                  decrRefCount((void *)sortval);
#line 195
                  listRelease(operations);
#line 196
                  addReply(c, shared.syntaxerr);
#line 197
                  return;
                } else
#line 188
                if (leftargs >= 1) {
#line 189
                  __cil_tmp___0 = createSortOperation(0, *(c->argv + (j + 1)));
#line 189
                  listAddNodeTail(operations, (void *)__cil_tmp___0);
#line 191
                  getop ++;
#line 192
                  j ++;
                } else {
#line 194
                  decrRefCount((void *)sortval);
#line 195
                  listRelease(operations);
#line 196
                  addReply(c, shared.syntaxerr);
#line 197
                  return;
                }
              } else
#line 182
              if (leftargs >= 1) {
#line 183
                sortby = *(c->argv + (j + 1));
#line 186
                __cil_tmp = strchr((char const   *)(*(c->argv + (j + 1)))->ptr, '*');
#line 186
                if ((unsigned int )__cil_tmp == (unsigned int )((void *)0)) {
#line 186
                  dontsort = 1;
                }
#line 187
                j ++;
              } else {
#line 182
                goto _L;
              }
            } else
#line 179
            if (leftargs >= 1) {
#line 180
              storekey = *(c->argv + (j + 1));
#line 181
              j ++;
            } else {
#line 179
              goto _L___0;
            }
          } else
#line 175
          if (leftargs >= 2) {
#line 176
            limit_start = atoi((char const   *)(*(c->argv + (j + 1)))->ptr);
#line 177
            limit_count = atoi((char const   *)(*(c->argv + (j + 2)))->ptr);
#line 178
            j += 2;
          } else {
#line 175
            goto _L___1;
          }
        } else {
#line 174
          alpha = 1;
        }
      } else {
#line 172
        desc = 1;
      }
    } else {
#line 170
      desc = 0;
    }
#line 199
    j ++;
  }
#line 203
  switch ((int )sortval->type) {
  case 1: 
#line 204
  __cil_tmp___8 = listTypeLength(sortval);
#line 204
  vectorlen = (int )__cil_tmp___8;
#line 204
  break;
  case 2: 
#line 205
  __cil_tmp___9 = setTypeSize(sortval);
#line 205
  vectorlen = (int )__cil_tmp___9;
#line 205
  break;
  case 3: 
#line 206
  vectorlen = (int )((((zset *)sortval->ptr)->dict)->ht[0].used + (((zset *)sortval->ptr)->dict)->ht[1].used);
#line 206
  break;
  default: 
#line 207
  vectorlen = 0;
#line 207
  _redisPanic((char *)"\"Bad SORT type\"", (char *)"sort.c", 207);
#line 207
  _exit(1);
  }
#line 209
  __cil_tmp___10 = malloc((unsigned int )(sizeof(redisSortObject ) * (unsigned long )vectorlen));
#line 209
  vector = (redisSortObject *)__cil_tmp___10;
#line 210
  j = 0;
#line 212
  if (sortval->type == 1U) {
#line 213
    __cil_tmp___11 = listTypeInitIterator(sortval, 0, (unsigned char)1);
#line 213
    li = __cil_tmp___11;
#line 215
    while (1) {
#line 215
      __cil_tmp___12 = listTypeNext(li, & entry);
#line 215
      if (! __cil_tmp___12) {
#line 215
        break;
      }
#line 216
      (vector + j)->obj = listTypeGet(& entry);
#line 217
      (vector + j)->u.score = (double )0;
#line 218
      (vector + j)->u.cmpobj = (robj *)((void *)0);
#line 219
      j ++;
    }
#line 221
    listTypeReleaseIterator(li);
  } else
#line 222
  if (sortval->type == 2U) {
#line 223
    __cil_tmp___13 = setTypeInitIterator(sortval);
#line 223
    si = __cil_tmp___13;
#line 225
    while (1) {
#line 225
      ele = setTypeNextObject(si);
#line 225
      if (! ((unsigned int )ele != (unsigned int )((void *)0))) {
#line 225
        break;
      }
#line 226
      (vector + j)->obj = ele;
#line 227
      (vector + j)->u.score = (double )0;
#line 228
      (vector + j)->u.cmpobj = (robj *)((void *)0);
#line 229
      j ++;
    }
#line 231
    setTypeReleaseIterator(si);
  } else
#line 232
  if (sortval->type == 3U) {
#line 233
    set = ((zset *)sortval->ptr)->dict;
#line 236
    di = dictGetIterator(set);
#line 237
    while (1) {
#line 237
      setele = dictNext(di);
#line 237
      if (! ((unsigned int )setele != (unsigned int )((void *)0))) {
#line 237
        break;
      }
#line 238
      (vector + j)->obj = (robj *)setele->key;
#line 239
      (vector + j)->u.score = (double )0;
#line 240
      (vector + j)->u.cmpobj = (robj *)((void *)0);
#line 241
      j ++;
    }
#line 243
    dictReleaseIterator(di);
  } else {
#line 245
    _redisPanic((char *)"\"Unknown type\"", (char *)"sort.c", 245);
#line 245
    _exit(1);
  }
#line 247
  if (! (j == vectorlen)) {
#line 247
    _redisAssert((char *)"j == vectorlen", (char *)"sort.c", 247);
#line 247
    _exit(1);
  }
#line 250
  if (dontsort == 0) {
#line 251
    j = 0;
#line 251
    while (j < vectorlen) {
#line 253
      if (sortby) {
#line 255
        byval = lookupKeyByPattern(c->db, sortby, (vector + j)->obj);
#line 256
        if (! byval) {
#line 256
          goto __Cont;
        }
      } else {
#line 259
        byval = (vector + j)->obj;
      }
#line 262
      if (alpha) {
#line 263
        if (sortby) {
#line 263
          (vector + j)->u.cmpobj = getDecodedObject(byval);
        }
      } else
#line 265
      if (byval->encoding == 0U) {
#line 266
        (vector + j)->u.score = strtod((char const   *)byval->ptr, (char **)((void *)0));
      } else
#line 267
      if (byval->encoding == 1U) {
#line 271
        (vector + j)->u.score = (double )((long )byval->ptr);
      } else {
#line 273
        _redisAssert((char *)"1 != 1", (char *)"sort.c", 273);
#line 273
        _exit(1);
      }
#line 279
      if (sortby) {
#line 280
        decrRefCount((void *)byval);
      }
      __Cont: 
#line 251
      j ++;
    }
  }
#line 287
  start = limit_start < 0 ? 0 : limit_start;
#line 288
  end = limit_count < 0 ? vectorlen - 1 : (start + limit_count) - 1;
#line 289
  if (start >= vectorlen) {
#line 290
    start = vectorlen - 1;
#line 291
    end = vectorlen - 2;
  }
#line 293
  if (end >= vectorlen) {
#line 293
    end = vectorlen - 1;
  }
#line 295
  if (dontsort == 0) {
#line 296
    server.sort_desc = desc;
#line 297
    server.sort_alpha = alpha;
#line 298
    server.sort_bypattern = sortby ? 1 : 0;
#line 299
    if (sortby && (start != 0 || end != vectorlen - 1)) {
#line 300
      pqsort((void *)vector, (unsigned int )vectorlen, (unsigned int )sizeof(redisSortObject ),
             & sortCompare, (unsigned int )start, (unsigned int )end);
    } else {
#line 302
      qsort((void *)vector, (unsigned int )vectorlen, (unsigned int )sizeof(redisSortObject ),
            & sortCompare);
    }
  }
#line 307
  outputlen = (unsigned int )(getop ? getop * ((end - start) + 1) : (end - start) + 1);
#line 308
  if ((unsigned int )storekey == (unsigned int )((void *)0)) {
#line 310
    addReplyMultiBulkLen(c, (long )outputlen);
#line 311
    j = start;
#line 311
    while (j <= end) {
#line 315
      if (! getop) {
#line 315
        addReplyBulk(c, (vector + j)->obj);
      }
#line 316
      listRewind(operations, & li___0);
#line 317
      while (1) {
#line 317
        ln = listNext(& li___0);
#line 317
        if (! ln) {
#line 317
          break;
        }
#line 318
        sop = (redisSortOperation *)ln->value;
#line 319
        __cil_tmp___14 = lookupKeyByPattern(c->db, sop->pattern, (vector + j)->obj);
#line 319
        val = __cil_tmp___14;
#line 322
        if (sop->type == 0) {
#line 323
          if (! val) {
#line 324
            addReply(c, shared.nullbulk);
          } else {
#line 326
            addReplyBulk(c, val);
#line 327
            decrRefCount((void *)val);
          }
        } else
#line 330
        if (! (sop->type == 0)) {
#line 330
          _redisAssert((char *)"sop->type == REDIS_SORT_GET", (char *)"sort.c", 330);
#line 330
          _exit(1);
        }
      }
#line 311
      j ++;
    }
  } else {
#line 335
    __cil_tmp___15 = createZiplistObject();
#line 335
    sobj = __cil_tmp___15;
#line 338
    j = start;
#line 338
    while (j <= end) {
#line 342
      if (! getop) {
#line 343
        listTypePush(sobj, (vector + j)->obj, 1);
      } else {
#line 345
        listRewind(operations, & li___1);
#line 346
        while (1) {
#line 346
          ln___0 = listNext(& li___1);
#line 346
          if (! ln___0) {
#line 346
            break;
          }
#line 347
          sop___0 = (redisSortOperation *)ln___0->value;
#line 348
          __cil_tmp___16 = lookupKeyByPattern(c->db, sop___0->pattern, (vector + j)->obj);
#line 348
          val___0 = __cil_tmp___16;
#line 351
          if (sop___0->type == 0) {
#line 352
            if (! val___0) {
#line 352
              val___0 = createStringObject((char *)"", 0U);
            }
#line 357
            listTypePush(sobj, val___0, 1);
#line 358
            decrRefCount((void *)val___0);
          } else
#line 361
          if (! (sop___0->type == 0)) {
#line 361
            _redisAssert((char *)"sop->type == REDIS_SORT_GET", (char *)"sort.c",
                         361);
#line 361
            _exit(1);
          }
        }
      }
#line 338
      j ++;
    }
#line 366
    dbReplace(c->db, storekey, sobj);
#line 370
    server.dirty += (long long )(1U + outputlen);
#line 371
    touchWatchedKey(c->db, storekey);
#line 372
    addReplyLongLong(c, (long long )outputlen);
  }
#line 376
  if (sortval->type == 1U || sortval->type == 2U) {
#line 377
    j = 0;
#line 377
    while (j < vectorlen) {
#line 378
      decrRefCount((void *)(vector + j)->obj);
#line 377
      j ++;
    }
  }
#line 379
  decrRefCount((void *)sortval);
#line 380
  listRelease(operations);
#line 381
  j = 0;
#line 381
  while (j < vectorlen) {
#line 382
    if (alpha && (vector + j)->u.cmpobj) {
#line 383
      decrRefCount((void *)(vector + j)->u.cmpobj);
    }
#line 381
    j ++;
  }
#line 385
  free((void *)vector);
#line 386
  return;
}
}
#line 1 "intset.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-aChC6EpS.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 120 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
int rand(void) ;
#line 14 "intset.c"
static uint8_t _intsetValueEncoding(int64_t v ) 
{ 

  {
#line 15
  if (v < (-0x7FFFFFFF-1) || v > 2147483647LL) {
#line 16
    return ((unsigned char )sizeof(int64_t ));
  } else
#line 17
  if (v < -32768LL || v > 32767LL) {
#line 18
    return ((unsigned char )sizeof(int32_t ));
  }
#line 19
  return ((unsigned char )sizeof(int16_t ));
}
}
#line 23 "intset.c"
static int64_t _intsetGetEncoded(intset *is , int pos , uint8_t enc ) 
{ 

  {
#line 24
  if ((unsigned long )enc == sizeof(int64_t )) {
#line 25
    return (*((int64_t *)(is->contents) + pos));
  } else
#line 26
  if ((unsigned long )enc == sizeof(int32_t )) {
#line 27
    return ((long long )*((int32_t *)(is->contents) + pos));
  }
#line 28
  return ((long long )*((int16_t *)(is->contents) + pos));
}
}
#line 32 "intset.c"
static int64_t _intsetGet(intset *is , int pos ) 
{ int64_t __cil_tmp ;

  {
#line 33
  __cil_tmp = _intsetGetEncoded(is, pos, (unsigned char )is->encoding);
#line 33
  return (__cil_tmp);
}
}
#line 37 "intset.c"
static void _intsetSet(intset *is , int pos , int64_t value ) 
{ 

  {
#line 38
  if (is->encoding == sizeof(int64_t )) {
#line 39
    *((int64_t *)(is->contents) + pos) = value;
  } else
#line 40
  if (is->encoding == sizeof(int32_t )) {
#line 41
    *((int32_t *)(is->contents) + pos) = (long )value;
  } else {
#line 43
    *((int16_t *)(is->contents) + pos) = (short )value;
  }
#line 44
  return;
}
}
#line 47 "intset.c"
intset *intsetNew(void) 
{ intset *is ;
  void *__cil_tmp ;

  {
#line 48
  __cil_tmp = malloc((unsigned int )sizeof(intset ));
#line 48
  is = (intset *)__cil_tmp;
#line 49
  is->encoding = sizeof(int16_t );
#line 50
  is->length = 0UL;
#line 51
  return (is);
}
}
#line 55 "intset.c"
static intset *intsetResize(intset *is , uint32_t len ) 
{ uint32_t size ;
  void *__cil_tmp ;

  {
#line 56
  size = len * is->encoding;
#line 57
  __cil_tmp = realloc((void *)is, (unsigned int )(sizeof(intset ) + size));
#line 57
  is = (intset *)__cil_tmp;
#line 58
  return (is);
}
}
#line 65 "intset.c"
static uint8_t intsetSearch(intset *is , int64_t value , uint32_t *pos ) 
{ int min ;
  int max ;
  int mid ;
  int64_t cur ;
  int64_t __cil_tmp ;
  int64_t __cil_tmp___0 ;

  {
#line 66
  min = 0;
#line 66
  max = (int )(is->length - 1UL);
#line 66
  mid = -1;
#line 67
  cur = -1LL;
#line 70
  if (is->length == 0UL) {
#line 71
    if (pos) {
#line 71
      *pos = 0UL;
    }
#line 72
    return ((unsigned char)0);
  } else {
#line 76
    __cil_tmp___0 = _intsetGet(is, (int )(is->length - 1UL));
#line 76
    if (value > __cil_tmp___0) {
#line 77
      if (pos) {
#line 77
        *pos = is->length;
      }
#line 78
      return ((unsigned char)0);
    } else {
#line 79
      __cil_tmp = _intsetGet(is, 0);
#line 79
      if (value < __cil_tmp) {
#line 80
        if (pos) {
#line 80
          *pos = 0UL;
        }
#line 81
        return ((unsigned char)0);
      }
    }
  }
#line 85
  while (max >= min) {
#line 86
    mid = (min + max) / 2;
#line 87
    cur = _intsetGet(is, mid);
#line 88
    if (value > cur) {
#line 89
      min = mid + 1;
    } else
#line 90
    if (value < cur) {
#line 91
      max = mid - 1;
    } else {
#line 93
      break;
    }
  }
#line 97
  if (value == cur) {
#line 98
    if (pos) {
#line 98
      *pos = (unsigned long )mid;
    }
#line 99
    return ((unsigned char)1);
  } else {
#line 101
    if (pos) {
#line 101
      *pos = (unsigned long )min;
    }
#line 102
    return ((unsigned char)0);
  }
}
}
#line 107 "intset.c"
static intset *intsetUpgradeAndAdd(intset *is , int64_t value ) 
{ uint8_t curenc ;
  uint8_t newenc ;
  uint8_t __cil_tmp ;
  int length ;
  int prepend ;
  int64_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 108
  curenc = (unsigned char )is->encoding;
#line 109
  __cil_tmp = _intsetValueEncoding(value);
#line 109
  newenc = __cil_tmp;
#line 110
  length = (int )is->length;
#line 111
  prepend = value < 0LL ? 1 : 0;
#line 114
  is->encoding = (unsigned long )newenc;
#line 115
  is = intsetResize(is, is->length + 1UL);
#line 120
  while (1) {
#line 120
    __cil_tmp___1 = length;
#line 120
    length --;
#line 120
    if (! __cil_tmp___1) {
#line 120
      break;
    }
#line 121
    __cil_tmp___0 = _intsetGetEncoded(is, length, curenc);
#line 121
    _intsetSet(is, length + prepend, __cil_tmp___0);
  }
#line 124
  if (prepend) {
#line 125
    _intsetSet(is, 0, value);
  } else {
#line 127
    _intsetSet(is, (int )is->length, value);
  }
#line 128
  (is->length) ++;
#line 129
  return (is);
}
}
#line 132 "intset.c"
static void intsetMoveTail(intset *is , uint32_t from , uint32_t to ) 
{ void *src ;
  void *dst ;
  uint32_t bytes ;

  {
#line 134
  bytes = is->length - from;
#line 135
  if (is->encoding == sizeof(int64_t )) {
#line 136
    src = (void *)((int64_t *)(is->contents) + from);
#line 137
    dst = (void *)((int64_t *)(is->contents) + to);
#line 138
    bytes *= sizeof(int64_t );
  } else
#line 139
  if (is->encoding == sizeof(int32_t )) {
#line 140
    src = (void *)((int32_t *)(is->contents) + from);
#line 141
    dst = (void *)((int32_t *)(is->contents) + to);
#line 142
    bytes *= sizeof(int32_t );
  } else {
#line 144
    src = (void *)((int16_t *)(is->contents) + from);
#line 145
    dst = (void *)((int16_t *)(is->contents) + to);
#line 146
    bytes *= sizeof(int16_t );
  }
#line 148
  memmove(dst, (void const   *)src, (unsigned int )bytes);
#line 149
  return;
}
}
#line 152 "intset.c"
intset *intsetAdd(intset *is , int64_t value , uint8_t *success ) 
{ uint8_t valenc ;
  uint8_t __cil_tmp ;
  uint32_t pos ;
  intset *__cil_tmp___0 ;
  uint8_t __cil_tmp___1 ;

  {
#line 153
  __cil_tmp = _intsetValueEncoding(value);
#line 153
  valenc = __cil_tmp;
#line 155
  if (success) {
#line 155
    *success = (unsigned char)1;
  }
#line 160
  if ((unsigned long )valenc > is->encoding) {
#line 162
    __cil_tmp___0 = intsetUpgradeAndAdd(is, value);
#line 162
    return (__cil_tmp___0);
  } else {
#line 167
    __cil_tmp___1 = intsetSearch(is, value, & pos);
#line 167
    if (__cil_tmp___1) {
#line 168
      if (success) {
#line 168
        *success = (unsigned char)0;
      }
#line 169
      return (is);
    }
#line 172
    is = intsetResize(is, is->length + 1UL);
#line 173
    if (pos < is->length) {
#line 173
      intsetMoveTail(is, pos, pos + 1UL);
    }
  }
#line 176
  _intsetSet(is, (int )pos, value);
#line 177
  (is->length) ++;
#line 178
  return (is);
}
}
#line 182 "intset.c"
intset *intsetRemove(intset *is , int64_t value , int *success ) 
{ uint8_t valenc ;
  uint8_t __cil_tmp ;
  uint32_t pos ;
  uint8_t __cil_tmp___0 ;

  {
#line 183
  __cil_tmp = _intsetValueEncoding(value);
#line 183
  valenc = __cil_tmp;
#line 185
  if (success) {
#line 185
    *success = 0;
  }
#line 187
  if ((unsigned long )valenc <= is->encoding) {
#line 187
    __cil_tmp___0 = intsetSearch(is, value, & pos);
#line 187
    if (__cil_tmp___0) {
#line 189
      if (success) {
#line 189
        *success = 1;
      }
#line 192
      if (pos < is->length - 1UL) {
#line 192
        intsetMoveTail(is, pos + 1UL, pos);
      }
#line 193
      is = intsetResize(is, is->length - 1UL);
#line 194
      (is->length) --;
    }
  }
#line 196
  return (is);
}
}
#line 200 "intset.c"
uint8_t intsetFind(intset *is , int64_t value ) 
{ uint8_t valenc ;
  uint8_t __cil_tmp ;
  uint8_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 201
  __cil_tmp = _intsetValueEncoding(value);
#line 201
  valenc = __cil_tmp;
#line 202
  if ((unsigned long )valenc <= is->encoding) {
#line 202
    __cil_tmp___0 = intsetSearch(is, value, (uint32_t *)((void *)0));
#line 202
    if (__cil_tmp___0) {
#line 202
      __cil_tmp___1 = 1;
    } else {
#line 202
      __cil_tmp___1 = 0;
    }
  } else {
#line 202
    __cil_tmp___1 = 0;
  }
#line 202
  return ((unsigned char )__cil_tmp___1);
}
}
#line 206 "intset.c"
int64_t intsetRandom(intset *is ) 
{ int __cil_tmp ;
  int64_t __cil_tmp___0 ;

  {
#line 207
  __cil_tmp = rand();
#line 207
  __cil_tmp___0 = _intsetGet(is, (int )((unsigned long )__cil_tmp % is->length));
#line 207
  return (__cil_tmp___0);
}
}
#line 212 "intset.c"
uint8_t intsetGet(intset *is , uint32_t pos , int64_t *value ) 
{ 

  {
#line 213
  if (pos < is->length) {
#line 214
    *value = _intsetGet(is, (int )pos);
#line 215
    return ((unsigned char)1);
  }
#line 217
  return ((unsigned char)0);
}
}
#line 221 "intset.c"
uint32_t intsetLen(intset *is ) 
{ 

  {
#line 222
  return (is->length);
}
}
#line 1 "syncio.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-bGnn2uah.i","-std=c99,-pedantic,-O2,-Wall,-W,-g,-ggdb")
#line 732 "redis.h"
int syncRead(int fd , char *ptr , ssize_t size , int timeout ) ;
#line 41 "syncio.c"
int syncWrite(int fd , char *ptr , ssize_t size , int timeout ) 
{ ssize_t nwritten ;
  ssize_t ret ;
  time_t start ;
  time_t __cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  time_t __cil_tmp___2 ;

  {
#line 42
  ret = size;
#line 43
  __cil_tmp = time((time_t *)((void *)0));
#line 43
  start = __cil_tmp;
#line 45
  timeout ++;
#line 46
  while (size) {
#line 47
    __cil_tmp___0 = aeWait(fd, 2, 1000LL);
#line 47
    if (__cil_tmp___0 & 2) {
#line 48
      nwritten = write(fd, (void const   *)ptr, (unsigned int )size);
#line 49
      if (nwritten == -1) {
#line 49
        return (-1);
      }
#line 50
      ptr += nwritten;
#line 51
      size -= nwritten;
    }
#line 53
    __cil_tmp___2 = time((time_t *)((void *)0));
#line 53
    if (__cil_tmp___2 - start > (long )timeout) {
#line 54
      __cil_tmp___1 = __errno();
#line 54
      *__cil_tmp___1 = 116;
#line 55
      return (-1);
    }
  }
#line 58
  return (ret);
}
}
#line 61 "syncio.c"
int syncRead(int fd , char *ptr , ssize_t size , int timeout ) 
{ ssize_t nread ;
  ssize_t totread ;
  time_t start ;
  time_t __cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  time_t __cil_tmp___2 ;

  {
#line 62
  totread = 0;
#line 63
  __cil_tmp = time((time_t *)((void *)0));
#line 63
  start = __cil_tmp;
#line 65
  timeout ++;
#line 66
  while (size) {
#line 67
    __cil_tmp___0 = aeWait(fd, 1, 1000LL);
#line 67
    if (__cil_tmp___0 & 1) {
#line 68
      nread = read(fd, (void *)ptr, (unsigned int )size);
#line 69
      if (nread <= 0) {
#line 69
        return (-1);
      }
#line 70
      ptr += nread;
#line 71
      size -= nread;
#line 72
      totread += nread;
    }
#line 74
    __cil_tmp___2 = time((time_t *)((void *)0));
#line 74
    if (__cil_tmp___2 - start > (long )timeout) {
#line 75
      __cil_tmp___1 = __errno();
#line 75
      *__cil_tmp___1 = 116;
#line 76
      return (-1);
    }
  }
#line 79
  return (totread);
}
}
#line 82 "syncio.c"
int syncReadLine(int fd , char *ptr , ssize_t size , int timeout ) 
{ ssize_t nread ;
  char c ;
  int __cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 83
  nread = 0;
#line 85
  size --;
#line 86
  while (size) {
#line 89
    __cil_tmp = syncRead(fd, & c, 1, timeout);
#line 89
    if (__cil_tmp == -1) {
#line 89
      return (-1);
    }
#line 90
    if ((int )c == 10) {
#line 91
      *ptr = (char )'\000';
#line 92
      if (nread && (int )*(ptr - 1) == 13) {
#line 92
        *(ptr - 1) = (char )'\000';
      }
#line 93
      return (nread);
    } else {
#line 95
      __cil_tmp___0 = ptr;
#line 95
      ptr ++;
#line 95
      *__cil_tmp___0 = c;
#line 96
      *ptr = (char )'\000';
#line 97
      nread ++;
    }
  }
#line 100
  return (nread);
}
}
#line 107 "syncio.c"
int fwriteBulkString(FILE *fp , char *s , unsigned long len ) 
{ char cbuf[128] ;
  int clen ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  size_t __cil_tmp___4 ;

  {
#line 110
  cbuf[0] = (char )'$';
#line 111
  __cil_tmp = ll2string(cbuf + 1, (unsigned int )(sizeof(cbuf) - 1UL), (long long )len);
#line 111
  clen = 1 + __cil_tmp;
#line 112
  __cil_tmp___0 = clen;
#line 112
  clen ++;
#line 112
  cbuf[__cil_tmp___0] = (char )'\r';
#line 113
  __cil_tmp___1 = clen;
#line 113
  clen ++;
#line 113
  cbuf[__cil_tmp___1] = (char )'\n';
#line 114
  __cil_tmp___2 = fwrite((void const   *)(cbuf), (unsigned int )clen, 1U, fp);
#line 114
  if (__cil_tmp___2 == 0U) {
#line 114
    return (0);
  }
#line 115
  if (len > 0UL) {
#line 115
    __cil_tmp___3 = fwrite((void const   *)s, (unsigned int )len, 1U, fp);
#line 115
    if (__cil_tmp___3 == 0U) {
#line 115
      return (0);
    }
  }
#line 116
  __cil_tmp___4 = fwrite((void const   *)"\r\n", 2U, 1U, fp);
#line 116
  if (__cil_tmp___4 == 0U) {
#line 116
    return (0);
  }
#line 117
  return (1);
}
}
#line 121 "syncio.c"
int fwriteBulkDouble(FILE *fp , double d ) 
{ char buf[128] ;
  char dbuf[128] ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  size_t __cil_tmp___3 ;

  {
#line 124
  snprintf(dbuf, (unsigned int )sizeof(dbuf), "%.17g\r\n", d);
#line 125
  __cil_tmp = strlen((char const   *)(dbuf));
#line 125
  snprintf(buf, (unsigned int )sizeof(buf), "$%lu\r\n", (unsigned long )__cil_tmp - 2UL);
#line 126
  __cil_tmp___0 = strlen((char const   *)(buf));
#line 126
  __cil_tmp___1 = fwrite((void const   *)(buf), __cil_tmp___0, 1U, fp);
#line 126
  if (__cil_tmp___1 == 0U) {
#line 126
    return (0);
  }
#line 127
  __cil_tmp___2 = strlen((char const   *)(dbuf));
#line 127
  __cil_tmp___3 = fwrite((void const   *)(dbuf), __cil_tmp___2, 1U, fp);
#line 127
  if (__cil_tmp___3 == 0U) {
#line 127
    return (0);
  }
#line 128
  return (1);
}
}
#line 132 "syncio.c"
int fwriteBulkLongLong(FILE *fp , long long l ) 
{ char bbuf[128] ;
  char lbuf[128] ;
  unsigned int blen ;
  unsigned int llen ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 135
  __cil_tmp = ll2string(lbuf, 32U, l);
#line 135
  llen = (unsigned int )__cil_tmp;
#line 136
  __cil_tmp___0 = snprintf(bbuf, (unsigned int )sizeof(bbuf), "$%u\r\n%s\r\n", llen,
                           lbuf);
#line 136
  blen = (unsigned int )__cil_tmp___0;
#line 137
  __cil_tmp___1 = fwrite((void const   *)(bbuf), blen, 1U, fp);
#line 137
  if (__cil_tmp___1 == 0U) {
#line 137
    return (0);
  }
#line 138
  return (1);
}
}
#line 142 "syncio.c"
int fwriteBulkObject(FILE *fp , robj *obj ) 
{ int __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 145
  if (obj->encoding == 1U) {
#line 146
    __cil_tmp = fwriteBulkLongLong(fp, (long long )((long )obj->ptr));
#line 146
    return (__cil_tmp);
  } else
#line 147
  if (obj->encoding == 0U) {
#line 148
    __cil_tmp___0 = sdslen((char *)obj->ptr);
#line 148
    __cil_tmp___1 = fwriteBulkString(fp, (char *)obj->ptr, (unsigned long )__cil_tmp___0);
#line 148
    return (__cil_tmp___1);
  } else {
#line 150
    _redisPanic((char *)"\"Unknown string encoding\"", (char *)"syncio.c", 150);
#line 150
    _exit(1);
  }
}
}
#line 1 "cil-xYTnIBBE.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Jp5Bj7cR.i","")
#line 120 "deps/hiredis/hiredis.h"
void freeReplyObject(void *reply ) ;
#line 135
redisContext *redisConnect(char const   *ip , int port ) ;
#line 163
void *redisCommand(redisContext *c , char const   *format  , ...) ;
#line 7 "example-client.c"
void client_main(void) 
{ unsigned int j ;
  redisContext *c ;
  redisReply *reply ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;
  char buf[64] ;
  void *__cil_tmp___6 ;
  void *__cil_tmp___7 ;

  {
#line 12
  c = redisConnect("127.0.0.1", 6379);
#line 13
  if (c->err) {
#line 14
    printf("Connection error: %s\n", c->errstr);
#line 15
    exit(1);
  }
#line 19
  __cil_tmp = redisCommand(c, "PING");
#line 19
  reply = (redisReply *)__cil_tmp;
#line 20
  printf("PING: %s\n", reply->str);
#line 21
  freeReplyObject((void *)reply);
#line 24
  __cil_tmp___0 = redisCommand(c, "SET %s %s", "foo", "hello world");
#line 24
  reply = (redisReply *)__cil_tmp___0;
#line 25
  printf("SET: %s\n", reply->str);
#line 26
  freeReplyObject((void *)reply);
#line 29
  __cil_tmp___1 = redisCommand(c, "SET %b %b", "bar", 3, "hello", 5);
#line 29
  reply = (redisReply *)__cil_tmp___1;
#line 30
  printf("SET (binary API): %s\n", reply->str);
#line 31
  freeReplyObject((void *)reply);
#line 34
  __cil_tmp___2 = redisCommand(c, "GET foo");
#line 34
  reply = (redisReply *)__cil_tmp___2;
#line 35
  printf("GET foo: %s\n", reply->str);
#line 36
  freeReplyObject((void *)reply);
#line 38
  __cil_tmp___3 = redisCommand(c, "INCR counter");
#line 38
  reply = (redisReply *)__cil_tmp___3;
#line 39
  printf("INCR counter: %lld\n", reply->integer);
#line 40
  freeReplyObject((void *)reply);
#line 42
  __cil_tmp___4 = redisCommand(c, "INCR counter");
#line 42
  reply = (redisReply *)__cil_tmp___4;
#line 43
  printf("INCR counter: %lld\n", reply->integer);
#line 44
  freeReplyObject((void *)reply);
#line 47
  __cil_tmp___5 = redisCommand(c, "DEL mylist");
#line 47
  reply = (redisReply *)__cil_tmp___5;
#line 48
  freeReplyObject((void *)reply);
#line 49
  j = 0U;
#line 49
  while (j < 10U) {
#line 52
    snprintf(buf, 64U, "%d", j);
#line 53
    __cil_tmp___6 = redisCommand(c, "LPUSH mylist element-%s", buf);
#line 53
    reply = (redisReply *)__cil_tmp___6;
#line 54
    freeReplyObject((void *)reply);
#line 49
    j ++;
  }
#line 58
  __cil_tmp___7 = redisCommand(c, "LRANGE mylist 0 -1");
#line 58
  reply = (redisReply *)__cil_tmp___7;
#line 59
  if (reply->type == 2) {
#line 60
    j = 0U;
#line 60
    while (j < reply->elements) {
#line 61
      printf("%u) %s\n", j, (*(reply->element + j))->str);
#line 60
      j ++;
    }
  }
#line 64
  freeReplyObject((void *)reply);
#line 65
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 1 "lib_a-_Exit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-r02Sqb2g.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-__adjust.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-a8YuOw6W.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-__atexit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lXn8umdY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 819 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _reent * const  _global_impure_ptr ;
#line 1 "lib_a-__call_atexit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-bqvyVxkA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 12 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/atexit.h"
void __call_exitprocs(int code , void *d ) ;
#line 63 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/__call_atexit.c"
void __call_exitprocs(int code , void *d ) 
{ register struct _atexit *p ;
  struct _atexit **lastp ;
  register struct _on_exit_args *args ;
  register int n ;
  int i ;
  void (*fn)(void) ;
  int ind ;

  {
  restart: 
#line 81
  p = _global_impure_ptr->_atexit;
#line 82
  lastp = & _global_impure_ptr->_atexit;
#line 83
  while (p) {
#line 86
    args = p->_on_exit_args_ptr;
#line 90
    n = p->_ind - 1;
#line 90
    while (n >= 0) {
#line 94
      i = 1 << n;
#line 97
      if (d && (! args || (unsigned int )args->_dso_handle[n] != (unsigned int )d)) {
#line 98
        goto __Cont;
      }
#line 102
      fn = p->_fns[n];
#line 103
      if (n == p->_ind - 1) {
#line 104
        (p->_ind) --;
      } else {
#line 106
        p->_fns[n] = (void (*)(void))((void *)0);
      }
#line 109
      if (! fn) {
#line 110
        goto __Cont;
      }
#line 112
      ind = p->_ind;
#line 115
      if (! args || (args->_fntypes & (unsigned long )i) == 0UL) {
#line 116
        (*fn)();
      } else
#line 117
      if ((args->_is_cxa & (unsigned long )i) == 0UL) {
#line 118
        (*((void (*)(int  , void * ))fn))(code, args->_fnargs[n]);
      } else {
#line 120
        (*((void (*)(void * ))fn))(args->_fnargs[n]);
      }
#line 125
      if (ind != p->_ind || (unsigned int )*lastp != (unsigned int )p) {
#line 126
        goto restart;
      }
      __Cont: 
#line 90
      n --;
    }
#line 134
    if (! (& free)) {
#line 135
      break;
    }
#line 139
    if (p->_ind == 0 && p->_next) {
#line 142
      *lastp = p->_next;
#line 144
      if (args) {
#line 145
        free((void *)args);
      }
#line 147
      free((void *)p);
#line 148
      p = *lastp;
    } else {
#line 152
      lastp = & p->_next;
#line 153
      p = p->_next;
    }
  }
#line 161
  return;
}
}
#line 1 "lib_a-__dprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1OUIbinG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-__exp10.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-DjceMeGm.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-__ten_mu.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-GMU0o5Ch.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-_isatty.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-tEdh5h8D.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 8 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/posix/_isatty.c"
int _isatty(int fd ) 
{ struct stat buf ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 13
  __cil_tmp___0 = fstat(fd, & buf);
#line 13
  if (__cil_tmp___0 < 0) {
#line 14
    __cil_tmp = __errno();
#line 14
    *__cil_tmp = 9;
#line 15
    return (0);
  }
#line 17
  if ((buf.st_mode & 8323072U) == 131072U) {
#line 18
    return (1);
  }
#line 19
  __cil_tmp___1 = __errno();
#line 19
  *__cil_tmp___1 = 25;
#line 20
  return (0);
}
}
#line 1 "lib_a-a64l.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-uTDsdNHM.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-abort.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-9ui7mly5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-abs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ENjkjhKK.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_add.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-n8FB9MbV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_add_sep.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-d8Knjmj2.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_append.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vThckx4d.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_count.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1WFPKYnM.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_create.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-s3S7Tlv0.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_create_sep.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jxcA6NYv.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_delete.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-KW22VeA6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_extract.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-KfOLzCya.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_insert.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-4zy4VqQa.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_next.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hKsQIQuC.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_replace.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-XWUR4v1u.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-argz_stringify.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Y99tsvng.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-asctime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-kCdhB9lZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-asctime_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hu6zCdKg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-asiprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-S1kyVVaP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-asniprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hUreQZ49.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-asnprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dm8QijsZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 45 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
int _svfprintf_r(struct _reent *data , FILE *fp , char const   *fmt0 , va_list ap ) ;
#line 1 "lib_a-asprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5f1TQqvp.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-assert.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-n6pk24Oi.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-atexit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-l8GG3lBv.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-atof.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-MsHwivOP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-atoff.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-HeneeSuH.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-atoi.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-AL5bjIWH.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 136 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
long _strtol_r(struct _reent *rptr , char const   *nptr , char **endptr , int base ) ;
#line 66 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/atoi.c"
int atoi(char const   *s ) 
{ long __cil_tmp ;

  {
#line 70
  __cil_tmp = strtol(s, (char **)((void *)0), 10);
#line 70
  return ((int )__cil_tmp);
}
}
#line 1 "lib_a-atol.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NtkjiRtn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-atoll.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-S5S2KL5C.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 190 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
long long _strtoll_r(struct _reent *rptr , char const   *nptr , char **endptr , int base ) ;
#line 1 "lib_a-bcmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-FZ7YKrSJ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-bcopy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1sDVkrYY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-bsearch.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-6WQi5OEK.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-btowc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wB7eqbqw.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 8 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/local.h"
char *__locale_charset(void) ;
#line 33
int (*__mbtowc)(struct _reent * , wchar_t * , char const   * , size_t  , char const   * ,
                mbstate_t * ) ;
#line 1 "lib_a-buf_findstr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-tNVcg3nY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-bzero.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-yHrdkZP9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-calloc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-iFSFjZ6j.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-callocr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-VQQoCqGN.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-cfreer.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-bkNANxmJ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-clearerr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vcJsb4Sp.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 156 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/reent.h"
void __sinit(struct _reent *s ) ;
#line 405
struct __sFILE_fake  const  __sf_fake_stdin  __attribute__((__weak__)) ;
#line 406
struct __sFILE_fake  const  __sf_fake_stdout  __attribute__((__weak__)) ;
#line 407
struct __sFILE_fake  const  __sf_fake_stderr  __attribute__((__weak__)) ;
#line 1 "lib_a-clock.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hop3wcP3.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-closedir.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-OhRZGT7K.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-closer.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-zFch4YIt.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-collate.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-yTLtCewV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 36 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
int strncmp(char const   *s1___0 , char const   *s2___0 , size_t n ) ;
#line 1 "lib_a-collcmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Wv3sYJO8.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-creat.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-0fi5VffM.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ctime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-MLPW9aM7.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ctime_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IPdQ5i6n.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ctype_.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-gtTZPklr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 93 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/ctype/ctype_.c"
static char const   _ctype_b[384]  = 
#line 93 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/ctype/ctype_.c"
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )32,      (char const   )32,      (char const   )32,      (char const   )32, 
        (char const   )32,      (char const   )32,      (char const   )32,      (char const   )32, 
        (char const   )32,      (char const   )40,      (char const   )40,      (char const   )40, 
        (char const   )40,      (char const   )40,      (char const   )32,      (char const   )32, 
        (char const   )32,      (char const   )32,      (char const   )32,      (char const   )32, 
        (char const   )32,      (char const   )32,      (char const   )32,      (char const   )32, 
        (char const   )32,      (char const   )32,      (char const   )32,      (char const   )32, 
        (char const   )32,      (char const   )32,      (char const   )32,      (char const   )32, 
        (char const   )136,      (char const   )16,      (char const   )16,      (char const   )16, 
        (char const   )16,      (char const   )16,      (char const   )16,      (char const   )16, 
        (char const   )16,      (char const   )16,      (char const   )16,      (char const   )16, 
        (char const   )16,      (char const   )16,      (char const   )16,      (char const   )16, 
        (char const   )4,      (char const   )4,      (char const   )4,      (char const   )4, 
        (char const   )4,      (char const   )4,      (char const   )4,      (char const   )4, 
        (char const   )4,      (char const   )4,      (char const   )16,      (char const   )16, 
        (char const   )16,      (char const   )16,      (char const   )16,      (char const   )16, 
        (char const   )16,      (char const   )65,      (char const   )65,      (char const   )65, 
        (char const   )65,      (char const   )65,      (char const   )65,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )16, 
        (char const   )16,      (char const   )16,      (char const   )16,      (char const   )16, 
        (char const   )16,      (char const   )66,      (char const   )66,      (char const   )66, 
        (char const   )66,      (char const   )66,      (char const   )66,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )16, 
        (char const   )16,      (char const   )16,      (char const   )16,      (char const   )32, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0};
#line 109 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/ctype/ctype_.c"
char const   *__ctype_ptr__  =    (char const   *)((char *)(_ctype_b) + 127);
#line 1 "lib_a-cxa_atexit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-aSciJKs7.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-cxa_finalize.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-PT24fIwS.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-difftime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CEumxxxT.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-diprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-I1OnGiyG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-div.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-JmCDkTAM.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-dprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-DXw8Qa6z.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-drand48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-FG2HlQe5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-dtoa.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-81sf5bg6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 206 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
char *_dtoa_r(struct _reent *ptr , double _d , int mode , int ndigits , int *decpt ,
              int *sign , char **rve ) ;
#line 385 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
_Bigint *_Balloc(struct _reent *ptr , int k ) ;
#line 386
void _Bfree(struct _reent *ptr , _Bigint *v ) ;
#line 387
_Bigint *__multadd(struct _reent *ptr , _Bigint *b , int m , int a ) ;
#line 389
_Bigint *__i2b(struct _reent *ptr , int i ) ;
#line 390
_Bigint *__multiply(struct _reent *ptr , _Bigint *a , _Bigint *b ) ;
#line 391
_Bigint *__pow5mult(struct _reent *ptr , _Bigint *b , int k ) ;
#line 392
int __hi0bits(__ULong x ) ;
#line 394
_Bigint *__d2b(struct _reent *ptr , double _d , int *e , int *bits ) ;
#line 395
_Bigint *__lshift(struct _reent *ptr , _Bigint *b , int k ) ;
#line 396
_Bigint *__mdiff(struct _reent *ptr , _Bigint *a , _Bigint *b ) ;
#line 397
int __mcmp(_Bigint *a , _Bigint *b ) ;
#line 410
double const   __mprec_bigtens[5] ;
#line 411
double const   __mprec_tens[25] ;
#line 35 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/dtoa.c"
static int quorem(_Bigint *b , _Bigint *S ) 
{ int n ;
  long borrow ;
  long y ;
  __ULong carry ;
  __ULong q ;
  __ULong ys ;
  __ULong *bx ;
  __ULong *bxe ;
  __ULong *sx ;
  __ULong *sxe ;
  long z ;
  __ULong si ;
  __ULong zs ;
  __ULong *__cil_tmp ;
  __ULong *__cil_tmp___0 ;
  __ULong *__cil_tmp___1 ;
  __ULong *__cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 49
  n = S->_wds;
#line 54
  if (b->_wds < n) {
#line 55
    return (0);
  }
#line 56
  sx = S->_x;
#line 57
  n --;
#line 57
  sxe = sx + n;
#line 58
  bx = b->_x;
#line 59
  bxe = bx + n;
#line 60
  q = *bxe / (*sxe + 1UL);
#line 65
  if (q) {
#line 67
    borrow = 0L;
#line 68
    carry = 0UL;
#line 69
    while (1) {
#line 72
      __cil_tmp = sx;
#line 72
      sx ++;
#line 72
      si = *__cil_tmp;
#line 73
      ys = (si & 65535UL) * q + carry;
#line 74
      zs = (si >> 16) * q + (ys >> 16);
#line 75
      carry = zs >> 16;
#line 76
      y = (long )(((*bx & 65535UL) - (ys & 65535UL)) + (unsigned long )borrow);
#line 77
      borrow = y >> 16;
#line 79
      z = (long )(((*bx >> 16) - (zs & 65535UL)) + (unsigned long )borrow);
#line 80
      borrow = z >> 16;
#line 82
      __cil_tmp___0 = bx;
#line 82
      bx ++;
#line 82
      *__cil_tmp___0 = (unsigned long )((z << 16) | (y & 65535L));
#line 69
      if (! ((unsigned int )sx <= (unsigned int )sxe)) {
#line 69
        break;
      }
    }
#line 93
    if (! *bxe) {
#line 95
      bx = b->_x;
#line 96
      while (1) {
#line 96
        bxe --;
#line 96
        if (! ((unsigned int )bxe > (unsigned int )bx && ! *bxe)) {
#line 96
          break;
        }
#line 97
        n --;
      }
#line 98
      b->_wds = n;
    }
  }
#line 101
  __cil_tmp___3 = __mcmp(b, S);
#line 101
  if (__cil_tmp___3 >= 0) {
#line 103
    q ++;
#line 104
    borrow = 0L;
#line 105
    carry = 0UL;
#line 106
    bx = b->_x;
#line 107
    sx = S->_x;
#line 108
    while (1) {
#line 111
      __cil_tmp___1 = sx;
#line 111
      sx ++;
#line 111
      si = *__cil_tmp___1;
#line 112
      ys = (si & 65535UL) + carry;
#line 113
      zs = (si >> 16) + (ys >> 16);
#line 114
      carry = zs >> 16;
#line 115
      y = (long )(((*bx & 65535UL) - (ys & 65535UL)) + (unsigned long )borrow);
#line 116
      borrow = y >> 16;
#line 118
      z = (long )(((*bx >> 16) - (zs & 65535UL)) + (unsigned long )borrow);
#line 119
      borrow = z >> 16;
#line 121
      __cil_tmp___2 = bx;
#line 121
      bx ++;
#line 121
      *__cil_tmp___2 = (unsigned long )((z << 16) | (y & 65535L));
#line 108
      if (! ((unsigned int )sx <= (unsigned int )sxe)) {
#line 108
        break;
      }
    }
#line 132
    bx = b->_x;
#line 133
    bxe = bx + n;
#line 134
    if (! *bxe) {
#line 136
      while (1) {
#line 136
        bxe --;
#line 136
        if (! ((unsigned int )bxe > (unsigned int )bx && ! *bxe)) {
#line 136
          break;
        }
#line 137
        n --;
      }
#line 138
      b->_wds = n;
    }
  }
#line 141
  return ((int )q);
}
}
#line 179 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/dtoa.c"
char *_dtoa_r(struct _reent *ptr , double _d , int mode , int ndigits , int *decpt ,
              int *sign , char **rve ) 
{ int bbits ;
  int b2 ;
  int b5 ;
  int be ;
  int dig ;
  int i ;
  int ieps ;
  int ilim ;
  int ilim0 ;
  int ilim1 ;
  int j ;
  int j1___0 ;
  int k ;
  int k0 ;
  int k_check ;
  int leftright ;
  int m2 ;
  int m5 ;
  int s2___0 ;
  int s5 ;
  int spec_case ;
  int try_quick ;
  union double_union d ;
  union double_union d2 ;
  union double_union eps ;
  long L ;
  int denorm ;
  __ULong x ;
  _Bigint *b ;
  _Bigint *b1 ;
  _Bigint *delta ;
  _Bigint *mlo ;
  _Bigint *mhi ;
  _Bigint *S ;
  double ds ;
  char *s ;
  char *s0 ;
  struct _reent *_r ;
  void *__cil_tmp ;
  struct _reent *_r___0 ;
  struct _Bigint *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  char *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  char *__cil_tmp___12 ;
  int __cil_tmp___13 ;
  char *__cil_tmp___14 ;
  char *__cil_tmp___15 ;
  char *__cil_tmp___16 ;
  char *__cil_tmp___17 ;
  char *__cil_tmp___18 ;
  int __cil_tmp___19 ;
  char *__cil_tmp___20 ;
  char *__cil_tmp___21 ;

  {
#line 232
  mlo = (_Bigint *)((void *)0);
#line 236
  d.d = _d;
#line 238
  while (1) {
#line 238
    _r = ptr;
#line 238
    if ((unsigned int )_r->_mp == (unsigned int )((void *)0)) {
#line 238
      __cil_tmp = malloc((unsigned int )sizeof(*(ptr->_mp)));
#line 238
      _r->_mp = (struct _mprec *)__cil_tmp;
#line 238
      while (1) {
#line 238
        _r___0 = ptr;
#line 238
        (_r___0->_mp)->_result_k = 0;
#line 238
        __cil_tmp___0 = (struct _Bigint *)0;
#line 238
        (_r___0->_mp)->_p5s = __cil_tmp___0;
#line 238
        (_r___0->_mp)->_result = __cil_tmp___0;
#line 238
        (_r___0->_mp)->_freelist = (struct _Bigint **)0;
#line 238
        break;
      }
    }
#line 238
    break;
  }
#line 239
  if ((ptr->_mp)->_result) {
#line 241
    ((ptr->_mp)->_result)->_k = (ptr->_mp)->_result_k;
#line 242
    ((ptr->_mp)->_result)->_maxwds = 1 << (ptr->_mp)->_result_k;
#line 243
    _Bfree(ptr, (ptr->_mp)->_result);
#line 244
    (ptr->_mp)->_result = (struct _Bigint *)0;
  }
#line 247
  if (d.i[1] & 2147483648U) {
#line 250
    *sign = 1;
#line 251
    d.i[1] &= 2147483647U;
  } else {
#line 254
    *sign = 0;
  }
#line 258
  if ((d.i[1] & 2146435072U) == 2146435072U) {
#line 264
    *decpt = 9999;
#line 265
    s = (char *)(! d.i[0] && ! (d.i[1] & 1048575U) ? "Infinity" : "NaN");
#line 270
    if (rve) {
#line 271
      *rve = *(s + 3) ? s + 8 : s + 3;
    }
#line 276
    return (s);
  }
#line 282
  if (! d.d) {
#line 284
    *decpt = 1;
#line 285
    s = (char *)"0";
#line 286
    if (rve) {
#line 287
      *rve = s + 1;
    }
#line 288
    return (s);
  }
#line 291
  b = __d2b(ptr, d.d, & be, & bbits);
#line 295
  i = (int )((d.i[1] >> 20) & (2146435072U >> 20));
#line 295
  if (i != 0) {
#line 298
    d2.d = d.d;
#line 299
    d2.i[1] &= 1048575U;
#line 300
    d2.i[1] |= 1072693248U;
#line 328
    i -= 1023;
#line 334
    denorm = 0;
  } else {
#line 340
    i = (bbits + be) + 1074;
#line 344
    x = (unsigned long )(i > 32 ? (d.i[1] << (64 - i)) | (d.i[0] >> (i - 32)) : d.i[0] << (32 - i));
#line 347
    d2.d = (double )x;
#line 348
    d2.i[1] -= 32505856U;
#line 349
    i -= 1075;
#line 350
    denorm = 1;
  }
#line 356
  ds = ((d2.d - 1.5) * 0.289529654602168 + 0.1760912590558) + (double )i * 0.301029995663981;
#line 358
  k = (int )ds;
#line 359
  if (ds < 0. && ds != (double )k) {
#line 360
    k --;
  }
#line 361
  k_check = 1;
#line 362
  if (k >= 0 && k <= 22) {
#line 364
    if (d.d < (double )__mprec_tens[k]) {
#line 365
      k --;
    }
#line 366
    k_check = 0;
  }
#line 368
  j = (bbits - i) - 1;
#line 369
  if (j >= 0) {
#line 371
    b2 = 0;
#line 372
    s2___0 = j;
  } else {
#line 376
    b2 = - j;
#line 377
    s2___0 = 0;
  }
#line 379
  if (k >= 0) {
#line 381
    b5 = 0;
#line 382
    s5 = k;
#line 383
    s2___0 += k;
  } else {
#line 387
    b2 -= k;
#line 388
    b5 = - k;
#line 389
    s5 = 0;
  }
#line 391
  if (mode < 0 || mode > 9) {
#line 392
    mode = 0;
  }
#line 393
  try_quick = 1;
#line 394
  if (mode > 5) {
#line 396
    mode -= 4;
#line 397
    try_quick = 0;
  }
#line 399
  leftright = 1;
#line 400
  ilim1 = -1;
#line 400
  ilim = ilim1;
#line 401
  switch (mode) {
  case 0: 
  case 1: 
#line 405
  i = 18;
#line 406
  ndigits = 0;
#line 407
  break;
  case 2: 
#line 409
  leftright = 0;
  case 4: 
#line 412
  if (ndigits <= 0) {
#line 413
    ndigits = 1;
  }
#line 414
  i = ndigits;
#line 414
  ilim1 = i;
#line 414
  ilim = ilim1;
#line 415
  break;
  case 3: 
#line 417
  leftright = 0;
  case 5: 
#line 420
  i = (ndigits + k) + 1;
#line 421
  ilim = i;
#line 422
  ilim1 = i - 1;
#line 423
  if (i <= 0) {
#line 424
    i = 1;
  }
  }
#line 426
  j = (int )sizeof(__ULong );
#line 427
  (ptr->_mp)->_result_k = 0;
#line 427
  while ((sizeof(_Bigint ) - sizeof(__ULong )) + (unsigned long )j <= (unsigned long )i) {
#line 429
    ((ptr->_mp)->_result_k) ++;
#line 427
    j <<= 1;
  }
#line 430
  (ptr->_mp)->_result = _Balloc(ptr, (ptr->_mp)->_result_k);
#line 431
  s0 = (char *)(ptr->_mp)->_result;
#line 431
  s = s0;
#line 433
  if ((ilim >= 0 && ilim <= 14) && try_quick) {
#line 437
    i = 0;
#line 438
    d2.d = d.d;
#line 439
    k0 = k;
#line 440
    ilim0 = ilim;
#line 441
    ieps = 2;
#line 442
    if (k > 0) {
#line 444
      ds = (double )__mprec_tens[k & 15];
#line 445
      j = k >> 4;
#line 446
      if (j & 16) {
#line 449
        j &= 15;
#line 450
        d.d /= (double )__mprec_bigtens[4];
#line 451
        ieps ++;
      }
#line 453
      while (j) {
#line 454
        if (j & 1) {
#line 456
          ieps ++;
#line 457
          ds *= (double )__mprec_bigtens[i];
        }
#line 453
        j >>= 1;
#line 453
        i ++;
      }
#line 459
      d.d /= ds;
    } else {
#line 461
      j1___0 = - k;
#line 461
      if (j1___0 != 0) {
#line 463
        d.d *= (double )__mprec_tens[j1___0 & 15];
#line 464
        j = j1___0 >> 4;
#line 464
        while (j) {
#line 465
          if (j & 1) {
#line 467
            ieps ++;
#line 468
            d.d *= (double )__mprec_bigtens[i];
          }
#line 464
          j >>= 1;
#line 464
          i ++;
        }
      }
    }
#line 471
    if ((k_check && d.d < 1.) && ilim > 0) {
#line 473
      if (ilim1 <= 0) {
#line 474
        goto fast_failed;
      }
#line 475
      ilim = ilim1;
#line 476
      k --;
#line 477
      d.d *= 10.;
#line 478
      ieps ++;
    }
#line 480
    eps.d = (double )ieps * d.d + 7.;
#line 481
    eps.i[1] -= 54525952U;
#line 482
    if (ilim == 0) {
#line 484
      mhi = (_Bigint *)0;
#line 484
      S = mhi;
#line 485
      d.d -= 5.;
#line 486
      if (d.d > eps.d) {
#line 487
        goto one_digit;
      }
#line 488
      if (d.d < - eps.d) {
#line 489
        goto no_digits;
      }
#line 490
      goto fast_failed;
    }
#line 493
    if (leftright) {
#line 498
      eps.d = 0.5 / (double )__mprec_tens[ilim - 1] - eps.d;
#line 499
      i = 0;
#line 499
      while (1) {
#line 501
        L = (long )d.d;
#line 502
        d.d -= (double )L;
#line 503
        __cil_tmp___1 = s;
#line 503
        s ++;
#line 503
        *__cil_tmp___1 = (char )(48 + (int )L);
#line 504
        if (d.d < eps.d) {
#line 505
          goto ret1;
        }
#line 506
        if (1. - d.d < eps.d) {
#line 507
          goto bump_up;
        }
#line 508
        i ++;
#line 508
        if (i >= ilim) {
#line 509
          break;
        }
#line 510
        eps.d *= 10.;
#line 511
        d.d *= 10.;
      }
    } else {
#line 518
      eps.d *= (double )__mprec_tens[ilim - 1];
#line 519
      i = 1;
#line 519
      while (1) {
#line 521
        L = (long )d.d;
#line 522
        d.d -= (double )L;
#line 523
        __cil_tmp___2 = s;
#line 523
        s ++;
#line 523
        *__cil_tmp___2 = (char )(48 + (int )L);
#line 524
        if (i == ilim) {
#line 526
          if (d.d > 0.5 + eps.d) {
#line 527
            goto bump_up;
          } else
#line 528
          if (d.d < 0.5 - eps.d) {
#line 530
            while (1) {
#line 530
              s --;
#line 530
              if (! ((int )*s == 48)) {
#line 530
                break;
              }
            }
#line 531
            s ++;
#line 532
            goto ret1;
          }
#line 534
          break;
        }
#line 519
        i ++;
#line 519
        d.d *= 10.;
      }
    }
    fast_failed: 
#line 541
    s = s0;
#line 542
    d.d = d2.d;
#line 543
    k = k0;
#line 544
    ilim = ilim0;
  }
#line 549
  if (be >= 0 && k <= 14) {
#line 552
    ds = (double )__mprec_tens[k];
#line 553
    if (ndigits < 0 && ilim <= 0) {
#line 555
      mhi = (_Bigint *)0;
#line 555
      S = mhi;
#line 556
      if (ilim < 0 || d.d <= (double )5 * ds) {
#line 557
        goto no_digits;
      }
#line 558
      goto one_digit;
    }
#line 560
    i = 1;
#line 560
    while (1) {
#line 562
      L = (long )(d.d / ds);
#line 563
      d.d -= (double )L * ds;
#line 572
      __cil_tmp___3 = s;
#line 572
      s ++;
#line 572
      *__cil_tmp___3 = (char )(48 + (int )L);
#line 573
      if (i == ilim) {
#line 575
        d.d += d.d;
#line 576
        if (d.d > ds || (d.d == ds && L & 1L)) {
          bump_up: 
#line 579
          while (1) {
#line 579
            s --;
#line 579
            if (! ((int )*s == 57)) {
#line 579
              break;
            }
#line 580
            if ((unsigned int )s == (unsigned int )s0) {
#line 582
              k ++;
#line 583
              *s = (char )'0';
#line 584
              break;
            }
          }
#line 586
          __cil_tmp___4 = s;
#line 586
          s ++;
#line 586
          *__cil_tmp___4 = (char )((int )*__cil_tmp___4 + 1);
        }
#line 588
        break;
      }
#line 590
      d.d *= 10.;
#line 590
      if (! d.d) {
#line 591
        break;
      }
#line 560
      i ++;
    }
#line 593
    goto ret1;
  }
#line 596
  m2 = b2;
#line 597
  m5 = b5;
#line 598
  mlo = (_Bigint *)0;
#line 598
  mhi = mlo;
#line 599
  if (leftright) {
#line 601
    if (mode < 2) {
#line 603
      i = denorm ? be + 1075 : 54 - bbits;
    } else {
#line 615
      j = ilim - 1;
#line 616
      if (m5 >= j) {
#line 617
        m5 -= j;
      } else {
#line 620
        j -= m5;
#line 620
        s5 += j;
#line 621
        b5 += j;
#line 622
        m5 = 0;
      }
#line 624
      i = ilim;
#line 624
      if (i < 0) {
#line 626
        m2 -= i;
#line 627
        i = 0;
      }
    }
#line 630
    b2 += i;
#line 631
    s2___0 += i;
#line 632
    mhi = __i2b(ptr, 1);
  }
#line 634
  if (m2 > 0 && s2___0 > 0) {
#line 636
    i = m2 < s2___0 ? m2 : s2___0;
#line 637
    b2 -= i;
#line 638
    m2 -= i;
#line 639
    s2___0 -= i;
  }
#line 641
  if (b5 > 0) {
#line 643
    if (leftright) {
#line 645
      if (m5 > 0) {
#line 647
        mhi = __pow5mult(ptr, mhi, m5);
#line 648
        b1 = __multiply(ptr, mhi, b);
#line 649
        _Bfree(ptr, b);
#line 650
        b = b1;
      }
#line 652
      j = b5 - m5;
#line 652
      if (j != 0) {
#line 653
        b = __pow5mult(ptr, b, j);
      }
    } else {
#line 656
      b = __pow5mult(ptr, b, b5);
    }
  }
#line 658
  S = __i2b(ptr, 1);
#line 659
  if (s5 > 0) {
#line 660
    S = __pow5mult(ptr, S, s5);
  }
#line 664
  spec_case = 0;
#line 665
  if (mode < 2) {
#line 667
    if ((! d.i[0] && ! (d.i[1] & 1048575U)) && d.i[1] & 2146435072U) {
#line 674
      b2 ++;
#line 675
      s2___0 ++;
#line 676
      spec_case = 1;
    }
  }
#line 689
  if (s5) {
#line 689
    __cil_tmp___5 = __hi0bits(S->_x[S->_wds - 1]);
#line 689
    __cil_tmp___6 = 32 - __cil_tmp___5;
  } else {
#line 689
    __cil_tmp___6 = 1;
  }
#line 689
  i = (__cil_tmp___6 + s2___0) & 31;
#line 689
  if (i != 0) {
#line 690
    i = 32 - i;
  }
#line 695
  if (i > 4) {
#line 697
    i -= 4;
#line 698
    b2 += i;
#line 699
    m2 += i;
#line 700
    s2___0 += i;
  } else
#line 702
  if (i < 4) {
#line 704
    i += 28;
#line 705
    b2 += i;
#line 706
    m2 += i;
#line 707
    s2___0 += i;
  }
#line 709
  if (b2 > 0) {
#line 710
    b = __lshift(ptr, b, b2);
  }
#line 711
  if (s2___0 > 0) {
#line 712
    S = __lshift(ptr, S, s2___0);
  }
#line 713
  if (k_check) {
#line 715
    __cil_tmp___7 = __mcmp(b, S);
#line 715
    if (__cil_tmp___7 < 0) {
#line 717
      k --;
#line 718
      b = __multadd(ptr, b, 10, 0);
#line 719
      if (leftright) {
#line 720
        mhi = __multadd(ptr, mhi, 10, 0);
      }
#line 721
      ilim = ilim1;
    }
  }
#line 724
  if (ilim <= 0 && mode > 2) {
#line 726
    if (ilim < 0) {
#line 726
      goto no_digits;
    } else {
#line 726
      S = __multadd(ptr, S, 5, 0);
#line 726
      __cil_tmp___8 = __mcmp(b, S);
#line 726
      if (__cil_tmp___8 <= 0) {
        no_digits: 
#line 730
        k = -1 - ndigits;
#line 731
        goto ret;
      }
    }
    one_digit: 
#line 734
    __cil_tmp___9 = s;
#line 734
    s ++;
#line 734
    *__cil_tmp___9 = (char )'1';
#line 735
    k ++;
#line 736
    goto ret;
  }
#line 738
  if (leftright) {
#line 740
    if (m2 > 0) {
#line 741
      mhi = __lshift(ptr, mhi, m2);
    }
#line 747
    mlo = mhi;
#line 748
    if (spec_case) {
#line 750
      mhi = _Balloc(ptr, mhi->_k);
#line 751
      memcpy((void *)((char *)(& mhi->_sign)), (void const   *)((char *)(& mlo->_sign)),
             (unsigned int )((unsigned long )mlo->_wds * sizeof(long ) + 2UL * sizeof(int )));
#line 752
      mhi = __lshift(ptr, mhi, 1);
    }
#line 755
    i = 1;
#line 755
    while (1) {
#line 757
      __cil_tmp___10 = quorem(b, S);
#line 757
      dig = __cil_tmp___10 + 48;
#line 761
      j = __mcmp(b, mlo);
#line 762
      delta = __mdiff(ptr, S, mhi);
#line 763
      if (delta->_sign) {
#line 763
        j1___0 = 1;
      } else {
#line 763
        __cil_tmp___11 = __mcmp(b, delta);
#line 763
        j1___0 = __cil_tmp___11;
      }
#line 764
      _Bfree(ptr, delta);
#line 766
      if ((j1___0 == 0 && ! mode) && ! (d.i[0] & 1U)) {
#line 768
        if (dig == 57) {
#line 769
          goto round_9_up;
        }
#line 770
        if (j > 0) {
#line 771
          dig ++;
        }
#line 772
        __cil_tmp___12 = s;
#line 772
        s ++;
#line 772
        *__cil_tmp___12 = (char )dig;
#line 773
        goto ret;
      }
#line 776
      if (j < 0 || ((j == 0 && ! mode) && ! (d.i[0] & 1U))) {
#line 782
        if (j1___0 > 0) {
#line 784
          b = __lshift(ptr, b, 1);
#line 785
          j1___0 = __mcmp(b, S);
#line 786
          if (j1___0 > 0 || (j1___0 == 0 && dig & 1)) {
#line 786
            __cil_tmp___13 = dig;
#line 786
            dig ++;
#line 786
            if (__cil_tmp___13 == 57) {
#line 788
              goto round_9_up;
            }
          }
        }
#line 790
        __cil_tmp___14 = s;
#line 790
        s ++;
#line 790
        *__cil_tmp___14 = (char )dig;
#line 791
        goto ret;
      }
#line 793
      if (j1___0 > 0) {
#line 795
        if (dig == 57) {
          round_9_up: 
#line 798
          __cil_tmp___15 = s;
#line 798
          s ++;
#line 798
          *__cil_tmp___15 = (char )'9';
#line 799
          goto roundoff;
        }
#line 801
        __cil_tmp___16 = s;
#line 801
        s ++;
#line 801
        *__cil_tmp___16 = (char )(dig + 1);
#line 802
        goto ret;
      }
#line 804
      __cil_tmp___17 = s;
#line 804
      s ++;
#line 804
      *__cil_tmp___17 = (char )dig;
#line 805
      if (i == ilim) {
#line 806
        break;
      }
#line 807
      b = __multadd(ptr, b, 10, 0);
#line 808
      if ((unsigned int )mlo == (unsigned int )mhi) {
#line 809
        mhi = __multadd(ptr, mhi, 10, 0);
#line 809
        mlo = mhi;
      } else {
#line 812
        mlo = __multadd(ptr, mlo, 10, 0);
#line 813
        mhi = __multadd(ptr, mhi, 10, 0);
      }
#line 755
      i ++;
    }
  } else {
#line 818
    i = 1;
#line 818
    while (1) {
#line 820
      __cil_tmp___18 = s;
#line 820
      s ++;
#line 820
      __cil_tmp___19 = quorem(b, S);
#line 820
      dig = __cil_tmp___19 + 48;
#line 820
      *__cil_tmp___18 = (char )dig;
#line 821
      if (i >= ilim) {
#line 822
        break;
      }
#line 823
      b = __multadd(ptr, b, 10, 0);
#line 818
      i ++;
    }
  }
#line 828
  b = __lshift(ptr, b, 1);
#line 829
  j = __mcmp(b, S);
#line 830
  if (j > 0 || (j == 0 && dig & 1)) {
    roundoff: 
#line 833
    while (1) {
#line 833
      s --;
#line 833
      if (! ((int )*s == 57)) {
#line 833
        break;
      }
#line 834
      if ((unsigned int )s == (unsigned int )s0) {
#line 836
        k ++;
#line 837
        __cil_tmp___20 = s;
#line 837
        s ++;
#line 837
        *__cil_tmp___20 = (char )'1';
#line 838
        goto ret;
      }
    }
#line 840
    __cil_tmp___21 = s;
#line 840
    s ++;
#line 840
    *__cil_tmp___21 = (char )((int )*__cil_tmp___21 + 1);
  } else {
#line 844
    while (1) {
#line 844
      s --;
#line 844
      if (! ((int )*s == 48)) {
#line 844
        break;
      }
    }
#line 845
    s ++;
  }
  ret: 
#line 848
  _Bfree(ptr, S);
#line 849
  if (mhi) {
#line 851
    if (mlo && (unsigned int )mlo != (unsigned int )mhi) {
#line 852
      _Bfree(ptr, mlo);
    }
#line 853
    _Bfree(ptr, mhi);
  }
  ret1: 
#line 856
  _Bfree(ptr, b);
#line 857
  *s = (char)0;
#line 858
  *decpt = k + 1;
#line 859
  if (rve) {
#line 860
    *rve = s;
  }
#line 861
  return (s0);
}
}
#line 1 "lib_a-dtoastub.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Bs5EwM51.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-dummy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Jm5YXLhY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ecvtbuf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-guylGKAC.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 211 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
void *_realloc_r(struct _reent *r , void *p , size_t s ) ;
#line 1 "lib_a-efgcvt.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Op9iQSx9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-environ.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-EsqXr2W6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-envlock.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-UpEvB5tb.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-envz_add.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-TkmwovOH.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-envz_entry.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hwFAQJNn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-envz_get.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-3HFKnKkt.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-envz_merge.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Lq6PnW7y.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-envz_remove.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IB9hxm76.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-envz_strip.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SLeXAvJA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-eprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SJ9agVRs.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-erand48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Mm9YbrOJ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-errno.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1BO60cxO.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 10 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/errno/errno.c"
int *__errno(void) 
{ 

  {
#line 13
  return (& _impure_ptr->_errno);
}
}
#line 1 "lib_a-execl.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-UoNfhdyV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-execle.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dliNFJa3.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-execlp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-29Wc6zUk.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-execr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8mEkWsg2.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-execv.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cgdokJJd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-execve.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cm5Jkhvo.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-execvp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ew2Dq95B.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-exit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-QMDhABt9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 57 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/exit.c"
 __attribute__((__noreturn__)) void exit(int code ) ;
#line 57 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/exit.c"
void exit(int code ) 
{ 

  {
#line 61
  __call_exitprocs(code, (void *)0);
#line 63
  if (_global_impure_ptr->__cleanup) {
#line 64
    (*(_global_impure_ptr->__cleanup))((struct _reent *)_global_impure_ptr);
  }
#line 65
  _exit(code);
}
}
#line 1 "lib_a-fclose.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-TkZRhwUb.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 369 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int _fclose_r(struct _reent *rptr , FILE *fp ) ;
#line 372
int _fflush_r(struct _reent *ptr , FILE *fp ) ;
#line 210 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
void _free_r(struct _reent *r , void *p ) ;
#line 175 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
void __sfp_lock_acquire(void) ;
#line 176
void __sfp_lock_release(void) ;
#line 67 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fclose.c"
int _fclose_r(struct _reent *rptr , FILE *fp ) 
{ int r ;
  int __cil_tmp ;

  {
#line 74
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 75
    return (0);
  }
#line 77
  __sfp_lock_acquire();
#line 79
  while (1) {
#line 79
    if (rptr && ! rptr->__sdidinit) {
#line 79
      __sinit(rptr);
    }
#line 79
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 79
      fp = rptr->_stdin;
    } else
#line 79
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 79
      fp = rptr->_stdout;
    } else
#line 79
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 79
      fp = rptr->_stderr;
    }
#line 79
    break;
  }
#line 81
  if ((int )fp->_flags & 512) {

  }
#line 83
  if ((int )fp->_flags == 0) {
#line 85
    if ((int )fp->_flags & 512) {

    }
#line 86
    __sfp_lock_release();
#line 87
    return (0);
  }
#line 92
  r = _fflush_r(rptr, fp);
#line 93
  if ((unsigned int )fp->_close != (unsigned int )((void *)0)) {
#line 93
    __cil_tmp = (*(fp->_close))(rptr, fp->_cookie);
#line 93
    if (__cil_tmp < 0) {
#line 94
      r = -1;
    }
  }
#line 95
  if ((int )fp->_flags & 128) {
#line 96
    _free_r(rptr, (void *)((char *)fp->_bf._base));
  }
#line 97
  if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 98
    if ((unsigned int )fp->_ub._base != (unsigned int )(fp->_ubuf)) {
#line 98
      _free_r(rptr, (void *)((char *)fp->_ub._base));
    }
#line 98
    fp->_ub._base = (unsigned char *)((void *)0);
  }
#line 99
  if ((unsigned int )fp->_lb._base != (unsigned int )((void *)0)) {
#line 100
    _free_r(rptr, (void *)((char *)fp->_lb._base));
#line 100
    fp->_lb._base = (unsigned char *)((void *)0);
  }
#line 101
  fp->_flags = (short)0;
#line 102
  if ((int )fp->_flags & 512) {

  }
#line 107
  __sfp_lock_release();
#line 109
  return (r);
}
}
#line 114 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fclose.c"
int fclose(FILE *fp ) 
{ int __cil_tmp ;

  {
#line 118
  __cil_tmp = _fclose_r(_impure_ptr, fp);
#line 118
  return (__cil_tmp);
}
}
#line 1 "lib_a-fcloseall.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-2jo3Ypcj.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 71 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
int _fwalk_reent(struct _reent *ptr , int (*reent_function)(struct _reent * , FILE * ) ) ;
#line 1 "lib_a-fcntlr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NfShngtG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fdopen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1fvrE0f1.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 55 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
FILE *__sfp(struct _reent *d ) ;
#line 56
int __sflags(struct _reent *ptr , char *mode , int *optr ) ;
#line 58
int __sread(struct _reent *ptr , void *cookie , char *buf , int n ) ;
#line 62
int __swrite(struct _reent *ptr , void *cookie , char const   *buf , int n ) ;
#line 64
_fpos_t __sseek(struct _reent *ptr , void *cookie , _fpos_t offset , int whence ) ;
#line 65
int __sclose(struct _reent *ptr , void *cookie ) ;
#line 1 "lib_a-feof.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-yLP2yQQ4.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 55 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/feof.c"
int feof(FILE *fp ) 
{ int result ;

  {
#line 60
  while (1) {
#line 60
    if (_impure_ptr && ! _impure_ptr->__sdidinit) {
#line 60
      __sinit(_impure_ptr);
    }
#line 60
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 60
      fp = _impure_ptr->_stdin;
    } else
#line 60
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 60
      fp = _impure_ptr->_stdout;
    } else
#line 60
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 60
      fp = _impure_ptr->_stderr;
    }
#line 60
    break;
  }
#line 61
  if ((int )fp->_flags & 512) {

  }
#line 62
  result = ((int )fp->_flags & 32) != 0;
#line 63
  if ((int )fp->_flags & 512) {

  }
#line 64
  return (result);
}
}
#line 1 "lib_a-ferror.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Bi0MgsPg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fflush.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-w174HXx5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 70 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fflush.c"
int _fflush_r(struct _reent *ptr , FILE *fp ) 
{ register unsigned char *p ;
  register int n ;
  register int t ;
  int tmp_errno ;
  _fpos_t curoff ;
  int result ;

  {
#line 90
  if ((unsigned int )fp->_bf._base == (unsigned int )((void *)0)) {
#line 91
    return (0);
  }
#line 94
  while (1) {
#line 94
    if (ptr && ! ptr->__sdidinit) {
#line 94
      __sinit(ptr);
    }
#line 94
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 94
      fp = ptr->_stdin;
    } else
#line 94
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 94
      fp = ptr->_stdout;
    } else
#line 94
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 94
      fp = ptr->_stderr;
    }
#line 94
    break;
  }
#line 96
  if (! fp->_flags) {
#line 97
    return (0);
  }
#line 99
  if ((int )fp->_flags & 512) {

  }
#line 101
  t = (int )fp->_flags;
#line 102
  if ((t & 8) == 0) {
#line 107
    fp->_flags = (short )((int )fp->_flags | 2048);
#line 116
    if ((fp->_r > 0 || fp->_ur > 0) && (unsigned int )fp->_seek != (unsigned int )((void *)0)) {
#line 128
      tmp_errno = ptr->_errno;
#line 129
      ptr->_errno = 0;
#line 131
      if ((int )fp->_flags & 4096) {
#line 132
        curoff = (long )fp->_offset;
      } else {
#line 142
        curoff = (*(fp->_seek))(ptr, fp->_cookie, 0L, 1);
#line 143
        if (curoff == -1L && ptr->_errno != 0) {
#line 145
          result = -1;
#line 146
          if (ptr->_errno == 29 || ptr->_errno == 22) {
#line 148
            result = 0;
#line 149
            ptr->_errno = tmp_errno;
          } else {
#line 152
            fp->_flags = (short )((int )fp->_flags | 64);
          }
#line 153
          if ((int )fp->_flags & 512) {

          }
#line 154
          return (result);
        }
      }
#line 157
      if ((int )fp->_flags & 4) {
#line 161
        curoff -= (long )fp->_r;
#line 162
        if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 163
          curoff -= (long )fp->_ur;
        }
      }
#line 171
      curoff = (*(fp->_seek))(ptr, fp->_cookie, curoff, 0);
#line 172
      if (((curoff != -1L || ptr->_errno == 0) || ptr->_errno == 29) || ptr->_errno == 22) {
#line 177
        fp->_flags = (short )((int )fp->_flags & -2049);
#line 178
        fp->_r = 0;
#line 179
        fp->_p = fp->_bf._base;
#line 180
        if ((int )fp->_flags & 4096 && (curoff != -1L || ptr->_errno == 0)) {
#line 181
          fp->_offset = (int )curoff;
        }
#line 182
        ptr->_errno = tmp_errno;
#line 183
        if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 184
          if ((unsigned int )fp->_ub._base != (unsigned int )(fp->_ubuf)) {
#line 184
            _free_r(ptr, (void *)((char *)fp->_ub._base));
          }
#line 184
          fp->_ub._base = (unsigned char *)((void *)0);
        }
      } else {
#line 188
        fp->_flags = (short )((int )fp->_flags | 64);
#line 189
        if ((int )fp->_flags & 512) {

        }
#line 190
        return (-1);
      }
    }
#line 193
    if ((int )fp->_flags & 512) {

    }
#line 194
    return (0);
  }
#line 196
  p = fp->_bf._base;
#line 196
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 199
    if ((int )fp->_flags & 512) {

    }
#line 200
    return (0);
  }
#line 202
  n = fp->_p - p;
#line 209
  fp->_p = p;
#line 210
  fp->_w = t & 3 ? 0 : fp->_bf._size;
#line 212
  while (n > 0) {
#line 214
    t = (*(fp->_write))(ptr, fp->_cookie, (char const   *)((char *)p), n);
#line 215
    if (t <= 0) {
#line 217
      fp->_flags = (short )((int )fp->_flags | 64);
#line 218
      if ((int )fp->_flags & 512) {

      }
#line 219
      return (-1);
    }
#line 221
    p += t;
#line 222
    n -= t;
  }
#line 224
  if ((int )fp->_flags & 512) {

  }
#line 225
  return (0);
}
}
#line 230 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fflush.c"
int fflush(FILE *fp ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 234
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 235
    __cil_tmp = _fwalk_reent((struct _reent *)_global_impure_ptr, & _fflush_r);
#line 235
    return (__cil_tmp);
  }
#line 237
  __cil_tmp___0 = _fflush_r(_impure_ptr, fp);
#line 237
  return (__cil_tmp___0);
}
}
#line 1 "lib_a-ffs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-AhEZv5wo.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fgetc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hmuZUmld.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fgetpos.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vGOfn3oV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 399 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
long _ftell_r(struct _reent *ptr , FILE *fp ) ;
#line 1 "lib_a-fgets.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-kugbQ4yI.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 374 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
char *_fgets_r(struct _reent *ptr , char *buf , int n , FILE *fp ) ;
#line 22 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
void *memchr(void const   *src_void , int c , size_t length ) ;
#line 57 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
int __srefill_r(struct _reent *ptr , FILE *fp ) ;
#line 83 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fgets.c"
char *_fgets_r(struct _reent *ptr , char *buf , int n , FILE *fp ) 
{ size_t len ;
  char *s ;
  unsigned char *p ;
  unsigned char *t ;
  int __cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 94
  if (n < 2) {
#line 95
    return ((char *)0);
  }
#line 97
  s = buf;
#line 99
  while (1) {
#line 99
    if (ptr && ! ptr->__sdidinit) {
#line 99
      __sinit(ptr);
    }
#line 99
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 99
      fp = ptr->_stdin;
    } else
#line 99
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 99
      fp = ptr->_stdout;
    } else
#line 99
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 99
      fp = ptr->_stderr;
    }
#line 99
    break;
  }
#line 101
  __sfp_lock_acquire();
#line 102
  if ((int )fp->_flags & 512) {

  }
#line 127
  n --;
#line 128
  while (1) {
#line 133
    len = (unsigned int )fp->_r;
#line 133
    if (len <= 0U) {
#line 135
      __cil_tmp = __srefill_r(ptr, fp);
#line 135
      if (__cil_tmp) {
#line 138
        if ((unsigned int )s == (unsigned int )buf) {
#line 140
          if ((int )fp->_flags & 512) {

          }
#line 141
          __sfp_lock_release();
#line 142
          return ((char *)0);
        }
#line 144
        break;
      }
#line 146
      len = (unsigned int )fp->_r;
    }
#line 148
    p = fp->_p;
#line 156
    if (len > (unsigned int )n) {
#line 157
      len = (unsigned int )n;
    }
#line 158
    __cil_tmp___0 = memchr((void const   *)((void *)p), '\n', len);
#line 158
    t = (unsigned char *)__cil_tmp___0;
#line 159
    if ((unsigned int )t != (unsigned int )((unsigned char *)0)) {
#line 161
      t ++;
#line 161
      len = (unsigned int )(t - p);
#line 162
      fp->_r = (int )((unsigned int )fp->_r - len);
#line 163
      fp->_p = t;
#line 164
      memcpy((void *)s, (void const   *)((void *)p), len);
#line 165
      *(s + len) = (char)0;
#line 166
      if ((int )fp->_flags & 512) {

      }
#line 167
      __sfp_lock_release();
#line 168
      return (buf);
    }
#line 170
    fp->_r = (int )((unsigned int )fp->_r - len);
#line 171
    fp->_p += len;
#line 172
    memcpy((void *)s, (void const   *)((void *)p), len);
#line 173
    s += len;
#line 128
    n = (int )((unsigned int )n - len);
#line 128
    if (! (n != 0)) {
#line 128
      break;
    }
  }
#line 176
  *s = (char)0;
#line 177
  if ((int )fp->_flags & 512) {

  }
#line 178
  __sfp_lock_release();
#line 179
  return (buf);
}
}
#line 184 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fgets.c"
char *fgets(char *buf , int n , FILE *fp ) 
{ char *__cil_tmp ;

  {
#line 190
  __cil_tmp = _fgets_r(_impure_ptr, buf, n, fp);
#line 190
  return (__cil_tmp);
}
}
#line 1 "lib_a-fgetwc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-TQkcC3ld.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 58 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
int __locale_mb_cur_max(void) ;
#line 54 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/wchar.h"
size_t _mbrtowc_r(struct _reent *ptr , wchar_t *pwc , char const   *s , size_t n ,
                  mbstate_t *ps ) ;
#line 1 "lib_a-fgetws.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-EpsPHlKq.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fileno.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cSZpeKJW.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 52 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fileno.c"
int fileno(FILE *f ) 
{ int result ;

  {
#line 57
  while (1) {
#line 57
    if (_impure_ptr && ! _impure_ptr->__sdidinit) {
#line 57
      __sinit(_impure_ptr);
    }
#line 57
    if ((unsigned int )f == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 57
      f = _impure_ptr->_stdin;
    } else
#line 57
    if ((unsigned int )f == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 57
      f = _impure_ptr->_stdout;
    } else
#line 57
    if ((unsigned int )f == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 57
      f = _impure_ptr->_stderr;
    }
#line 57
    break;
  }
#line 58
  if ((int )f->_flags & 512) {

  }
#line 59
  result = (int )f->_file;
#line 60
  if ((int )f->_flags & 512) {

  }
#line 61
  return (result);
}
}
#line 1 "lib_a-findfp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-iY0EH27p.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 208 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
void *_malloc_r(struct _reent *r , size_t s ) ;
#line 68 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
void _cleanup_r(struct _reent *ptr ) ;
#line 70
int _fwalk(struct _reent *ptr , int (*function)(FILE * ) ) ;
#line 72
struct _glue *__sfmoreglue(struct _reent *d , int n ) ;
#line 177
void __sinit_lock_acquire(void) ;
#line 178
void __sinit_lock_release(void) ;
#line 30 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
struct __sFILE_fake  const  __sf_fake_stdin  __attribute__((__weak__))  = 
#line 30 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
     {(unsigned char *)0, 0, 0, (short)0, (short)0, {(unsigned char *)0, 0}, 0, (struct _reent *)0};
#line 32 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
struct __sFILE_fake  const  __sf_fake_stdout  __attribute__((__weak__))  = 
#line 32
     {(unsigned char *)0, 0, 0, (short)0, (short)0, {(unsigned char *)0, 0}, 0, (struct _reent *)0};
#line 34 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
struct __sFILE_fake  const  __sf_fake_stderr  __attribute__((__weak__))  = 
#line 34
     {(unsigned char *)0, 0, 0, (short)0, (short)0, {(unsigned char *)0, 0}, 0, (struct _reent *)0};
#line 38 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
static void std(FILE *ptr , int flags , int file , struct _reent *data ) 
{ 

  {
#line 45
  ptr->_p = (unsigned char *)0;
#line 46
  ptr->_r = 0;
#line 47
  ptr->_w = 0;
#line 48
  ptr->_flags = (short )flags;
#line 49
  ptr->_flags2 = 0;
#line 50
  ptr->_file = (short )file;
#line 51
  ptr->_bf._base = (unsigned char *)0;
#line 52
  ptr->_bf._size = 0;
#line 53
  ptr->_lbfsize = 0;
#line 54
  memset((void *)(& ptr->_mbstate), 0, (unsigned int )sizeof(_mbstate_t ));
#line 55
  ptr->_cookie = (void *)ptr;
#line 56
  ptr->_read = & __sread;
#line 58
  ptr->_write = & __swrite;
#line 64
  ptr->_seek = & __sseek;
#line 65
  ptr->_close = & __sclose;
#line 78
  return;
}
}
#line 80 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
struct _glue *__sfmoreglue(struct _reent *d , int n ) 
{ struct _glue *g ;
  FILE *p ;
  void *__cil_tmp ;

  {
#line 88
  __cil_tmp = _malloc_r(d, (unsigned int )(sizeof(*g) + (unsigned long )n * sizeof(FILE )));
#line 88
  g = (struct _glue *)__cil_tmp;
#line 89
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 90
    return ((struct _glue *)((void *)0));
  }
#line 91
  p = (FILE *)(g + 1);
#line 92
  g->_next = (struct _glue *)((void *)0);
#line 93
  g->_niobs = n;
#line 94
  g->_iobs = p;
#line 95
  memset((void *)p, 0, (unsigned int )((unsigned long )n * sizeof(FILE )));
#line 96
  return (g);
}
}
#line 103 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
FILE *__sfp(struct _reent *d ) 
{ FILE *fp ;
  int n ;
  struct _glue *g ;
  struct _glue *__cil_tmp ;

  {
#line 111
  __sfp_lock_acquire();
#line 113
  if (! _global_impure_ptr->__sdidinit) {
#line 114
    __sinit((struct _reent *)_global_impure_ptr);
  }
#line 115
  g = & _global_impure_ptr->__sglue;
#line 115
  while (1) {
#line 117
    fp = g->_iobs;
#line 117
    n = g->_niobs;
#line 117
    while (1) {
#line 117
      n --;
#line 117
      if (! (n >= 0)) {
#line 117
        break;
      }
#line 118
      if ((int )fp->_flags == 0) {
#line 119
        goto found;
      }
#line 117
      fp ++;
    }
#line 120
    if ((unsigned int )g->_next == (unsigned int )((void *)0)) {
#line 120
      __cil_tmp = __sfmoreglue(d, 4);
#line 120
      g->_next = __cil_tmp;
#line 120
      if ((unsigned int )__cil_tmp == (unsigned int )((void *)0)) {
#line 122
        break;
      }
    }
#line 115
    g = g->_next;
  }
#line 124
  __sfp_lock_release();
#line 125
  d->_errno = 12;
#line 126
  return ((FILE *)((void *)0));
  found: 
#line 129
  fp->_file = (short)-1;
#line 130
  fp->_flags = (short)1;
#line 131
  fp->_flags2 = 0;
#line 135
  __sfp_lock_release();
#line 137
  fp->_p = (unsigned char *)((void *)0);
#line 138
  fp->_w = 0;
#line 139
  fp->_r = 0;
#line 140
  fp->_bf._base = (unsigned char *)((void *)0);
#line 141
  fp->_bf._size = 0;
#line 142
  fp->_lbfsize = 0;
#line 143
  memset((void *)(& fp->_mbstate), 0, (unsigned int )sizeof(_mbstate_t ));
#line 145
  fp->_ub._base = (unsigned char *)((void *)0);
#line 146
  fp->_ub._size = 0;
#line 147
  fp->_lb._base = (unsigned char *)((void *)0);
#line 148
  fp->_lb._size = 0;
#line 150
  return (fp);
}
}
#line 161 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
void _cleanup_r(struct _reent *ptr ) 
{ 

  {
#line 165
  _fwalk(ptr, & fclose);
#line 167
  return;
}
}
#line 181 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
void __sinit(struct _reent *s ) 
{ 

  {
#line 185
  __sinit_lock_acquire();
#line 187
  if (s->__sdidinit) {
#line 189
    __sinit_lock_release();
#line 190
    return;
  }
#line 194
  s->__cleanup = & _cleanup_r;
#line 195
  s->__sdidinit = 1;
#line 197
  s->__sglue._next = (struct _glue *)((void *)0);
#line 202
  s->__sglue._niobs = 0;
#line 203
  s->__sglue._iobs = (__FILE *)((void *)0);
#line 204
  s->_stdin = __sfp(s);
#line 205
  s->_stdout = __sfp(s);
#line 206
  s->_stderr = __sfp(s);
#line 209
  std(s->_stdin, 4, 0, s);
#line 218
  std(s->_stdout, 8, 1, s);
#line 225
  std(s->_stderr, 18, 2, s);
#line 227
  __sinit_lock_release();
#line 228
  return;
}
}
#line 235 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
void __sfp_lock_acquire(void) 
{ 

  {
#line 239
  return;
}
}
#line 241 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
void __sfp_lock_release(void) 
{ 

  {
#line 245
  return;
}
}
#line 247 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
void __sinit_lock_acquire(void) 
{ 

  {
#line 251
  return;
}
}
#line 253 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/findfp.c"
void __sinit_lock_release(void) 
{ 

  {
#line 257
  return;
}
}
#line 1 "lib_a-fini.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-p690IDyV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fiprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-H7pW4Ypu.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fiscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-xnWoxtTu.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fix_grouping.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-n810s22O.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-flags.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CKROd7C3.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 32 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/flags.c"
int __sflags(struct _reent *ptr , char *mode , int *optr ) 
{ register int ret ;
  register int m ;
  register int o ;

  {
#line 40
  switch ((int )*(mode + 0)) {
  case 114: 
#line 43
  ret = 4;
#line 44
  m = 1;
#line 45
  o = 0;
#line 46
  break;
  case 119: 
#line 49
  ret = 8;
#line 50
  m = 2;
#line 51
  o = 36;
#line 52
  break;
  case 97: 
#line 55
  ret = 264;
#line 56
  m = 2;
#line 57
  o = 68;
#line 58
  break;
  default: 
#line 60
  ptr->_errno = 22;
#line 61
  return (0);
  }
#line 63
  if (*(mode + 1) && ((int )*(mode + 1) == 43 || (int )*(mode + 2) == 43)) {
#line 65
    ret = (ret & -13) | 16;
#line 66
    m = 3;
  }
#line 68
  if (*(mode + 1) && ((int )*(mode + 1) == 98 || (int )*(mode + 2) == 98)) {

  }
#line 84
  *optr = m | o;
#line 85
  return (ret);
}
}
#line 1 "lib_a-fmemopen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-gYrKSsAD.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fnmatch.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-DfsiociR.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fopen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SPtPzYCI.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 387 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
FILE *_fopen_r(struct _reent *ptr , char const   *file , char const   *mode ) ;
#line 397
int _fseek_r(struct _reent *ptr , FILE *fp , long offset , int whence ) ;
#line 126 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fopen.c"
FILE *_fopen_r(struct _reent *ptr , char const   *file , char const   *mode ) 
{ register FILE *fp ;
  register int f ;
  int flags ;
  int oflags ;

  {
#line 136
  flags = __sflags(ptr, (char *)mode, & oflags);
#line 136
  if (flags == 0) {
#line 137
    return ((FILE *)((void *)0));
  }
#line 138
  fp = __sfp(ptr);
#line 138
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 139
    return ((FILE *)((void *)0));
  }
#line 141
  f = open(file, oflags, 438);
#line 141
  if (f < 0) {
#line 143
    __sfp_lock_acquire();
#line 144
    fp->_flags = (short)0;
#line 148
    __sfp_lock_release();
#line 149
    return ((FILE *)((void *)0));
  }
#line 152
  if ((int )fp->_flags & 512) {

  }
#line 154
  fp->_file = (short )f;
#line 155
  fp->_flags = (short )flags;
#line 156
  fp->_cookie = (void *)fp;
#line 157
  fp->_read = & __sread;
#line 158
  fp->_write = & __swrite;
#line 159
  fp->_seek = & __sseek;
#line 160
  fp->_close = & __sclose;
#line 162
  if ((int )fp->_flags & 256) {
#line 163
    _fseek_r(ptr, fp, 0L, 2);
  }
#line 170
  if ((int )fp->_flags & 512) {

  }
#line 171
  return (fp);
}
}
#line 176 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fopen.c"
FILE *fopen(char const   *file , char const   *mode ) 
{ FILE *__cil_tmp ;

  {
#line 181
  __cil_tmp = _fopen_r(_impure_ptr, file, mode);
#line 181
  return (__cil_tmp);
}
}
#line 1 "lib_a-fopencookie.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-4ypmfEjh.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ZzK4KUmW.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 458 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int _vfprintf_r(struct _reent *data , FILE *fp , char const   *fmt0 , va_list ap ) ;
#line 41 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fprintf.c"
int fprintf(FILE *fp , char const   *fmt  , ...) 
{ int ret ;
  va_list ap ;

  {
#line 49
  __builtin_va_start(ap, fmt);
#line 50
  ret = _vfprintf_r(_impure_ptr, fp, fmt, ap);
#line 51
  __builtin_va_end(ap);
#line 52
  return (ret);
}
}
#line 1 "lib_a-fpurge.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-09j0MChj.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fputc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-PXSIRrHn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fputs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ddRBqEaO.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 35 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fvwrite.h"
int __sfvwrite_r(struct _reent *ptr , FILE *fp , struct __suio *uio ) ;
#line 1 "lib_a-fputwc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-fPRHQ3mV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 516 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int __swbuf_r(struct _reent *ptr , int c , FILE *fp ) ;
#line 64 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/wchar.h"
size_t _wcrtomb_r(struct _reent *ptr , char *s , wchar_t wc , mbstate_t *ps ) ;
#line 132
wint_t _fputwc_r(struct _reent *ptr , wchar_t wc , __FILE *fp ) ;
#line 120 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fputwc.c"
static wint_t __fputwc(struct _reent *ptr , wchar_t wc , FILE *fp ) 
{ char buf[1] ;
  size_t i ;
  size_t len ;
  int __cil_tmp ;
  unsigned char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  unsigned char *__cil_tmp___5 ;
  int __cil_tmp___6 ;

  {
#line 129
  __cil_tmp = __locale_mb_cur_max();
#line 129
  if ((__cil_tmp == 1 && (int )wc > 0) && (int )wc <= 255) {
#line 136
    buf[0] = (char )((unsigned char )wc);
#line 137
    len = 1U;
  } else {
#line 141
    len = _wcrtomb_r(ptr, buf, wc, & fp->_mbstate);
#line 141
    if (len == 4294967295U) {
#line 143
      fp->_flags = (short )((int )fp->_flags | 64);
#line 144
      return (-1);
    }
  }
#line 148
  i = 0U;
#line 148
  while (i < len) {
#line 149
    (fp->_w) --;
#line 149
    if (fp->_w < 0) {
#line 149
      if (fp->_w >= fp->_lbfsize) {
#line 149
        *(fp->_p) = (unsigned char )buf[i];
#line 149
        if ((int )*(fp->_p) != 10) {
#line 149
          __cil_tmp___0 = fp->_p;
#line 149
          (fp->_p) ++;
#line 149
          __cil_tmp___2 = (int )*__cil_tmp___0;
        } else {
#line 149
          __cil_tmp___1 = __swbuf_r(ptr, '\n', fp);
#line 149
          __cil_tmp___2 = __cil_tmp___1;
        }
#line 149
        __cil_tmp___4 = __cil_tmp___2;
      } else {
#line 149
        __cil_tmp___3 = __swbuf_r(ptr, (int )((unsigned char )buf[i]), fp);
#line 149
        __cil_tmp___4 = __cil_tmp___3;
      }
#line 149
      __cil_tmp___6 = __cil_tmp___4;
    } else {
#line 149
      *(fp->_p) = (unsigned char )buf[i];
#line 149
      __cil_tmp___5 = fp->_p;
#line 149
      (fp->_p) ++;
#line 149
      __cil_tmp___6 = (int )*__cil_tmp___5;
    }
#line 149
    if (__cil_tmp___6 == -1) {
#line 150
      return (-1);
    }
#line 148
    i ++;
  }
#line 152
  return ((int )wc);
}
}
#line 155 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fputwc.c"
wint_t _fputwc_r(struct _reent *ptr , wchar_t wc , __FILE *fp ) 
{ wint_t r ;

  {
#line 163
  if ((int )fp->_flags & 512) {

  }
#line 164
  while (1) {
#line 164
    if (! ((int )fp->_flags & 8192)) {
#line 164
      fp->_flags = (short )((int )fp->_flags | 8192);
#line 164
      fp->_flags2 |= 8192;
    }
#line 164
    break;
  }
#line 165
  r = __fputwc(ptr, wc, fp);
#line 166
  if ((int )fp->_flags & 512) {

  }
#line 167
  return (r);
}
}
#line 1 "lib_a-fputws.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SVGNcDKX.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 36 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fvwrite.h"
int __swsetup_r(struct _reent *ptr , FILE *fp ) ;
#line 1 "lib_a-fread.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Ih93yQdP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 394 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
size_t _fread_r(struct _reent *ptr , void *buf , size_t size , size_t count , FILE *fp ) ;
#line 131 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fread.c"
size_t _fread_r(struct _reent *ptr , void *buf , size_t size , size_t count , FILE *fp ) 
{ register size_t resid ;
  register char *p ;
  register int r ;
  size_t total ;
  int __cil_tmp ;

  {
#line 144
  resid = count * size;
#line 144
  if (resid == 0U) {
#line 145
    return (0U);
  }
#line 147
  while (1) {
#line 147
    if (ptr && ! ptr->__sdidinit) {
#line 147
      __sinit(ptr);
    }
#line 147
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 147
      fp = ptr->_stdin;
    } else
#line 147
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 147
      fp = ptr->_stdout;
    } else
#line 147
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 147
      fp = ptr->_stderr;
    }
#line 147
    break;
  }
#line 149
  __sfp_lock_acquire();
#line 150
  if ((int )fp->_flags & 512) {

  }
#line 151
  while (1) {
#line 151
    if (! ((int )fp->_flags & 8192)) {
#line 151
      fp->_flags = (short )((int )fp->_flags | 8192);
#line 151
      fp->_flags2 &= -8193;
    }
#line 151
    break;
  }
#line 152
  if (fp->_r < 0) {
#line 153
    fp->_r = 0;
  }
#line 154
  total = resid;
#line 155
  p = (char *)buf;
#line 213
  while (1) {
#line 213
    r = fp->_r;
#line 213
    if (! (resid > (unsigned int )r)) {
#line 213
      break;
    }
#line 215
    memcpy((void *)p, (void const   *)((void *)fp->_p), (unsigned int )r);
#line 216
    fp->_p += r;
#line 218
    p += r;
#line 219
    resid -= (unsigned int )r;
#line 220
    __cil_tmp = __srefill_r(ptr, fp);
#line 220
    if (__cil_tmp) {
#line 231
      if ((int )fp->_flags & 512) {

      }
#line 232
      __sfp_lock_release();
#line 233
      return ((total - resid) / size);
    }
  }
#line 236
  memcpy((void *)p, (void const   *)((void *)fp->_p), resid);
#line 237
  fp->_r = (int )((unsigned int )fp->_r - resid);
#line 238
  fp->_p += resid;
#line 250
  if ((int )fp->_flags & 512) {

  }
#line 251
  __sfp_lock_release();
#line 252
  return (count);
}
}
#line 256 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fread.c"
size_t fread(void *buf , size_t size , size_t count , FILE *fp ) 
{ size_t __cil_tmp ;

  {
#line 263
  __cil_tmp = _fread_r(_impure_ptr, buf, size, count, fp);
#line 263
  return (__cil_tmp);
}
}
#line 1 "lib_a-freer.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-sZodSMFD.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-freopen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-YRbDFbPX.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-R74iNYl6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fseek.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-B6zCR0Dj.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 69 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
void __smakebuf_r(struct _reent *ptr , FILE *fp ) ;
#line 119 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fseek.c"
int _fseek_r(struct _reent *ptr , FILE *fp , long offset , int whence ) 
{ _fpos_t (*seekfn)(struct _reent * , void * , _fpos_t  , int  ) ;
  _fpos_t target ;
  _fpos_t curoff ;
  size_t n ;
  struct stat st ;
  int havepos ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  register int o ;
  _fpos_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  _fpos_t __cil_tmp___4 ;

  {
#line 128
  curoff = 0L;
#line 139
  while (1) {
#line 139
    if (ptr && ! ptr->__sdidinit) {
#line 139
      __sinit(ptr);
    }
#line 139
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 139
      fp = ptr->_stdin;
    } else
#line 139
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 139
      fp = ptr->_stdout;
    } else
#line 139
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 139
      fp = ptr->_stderr;
    }
#line 139
    break;
  }
#line 141
  __sfp_lock_acquire();
#line 142
  if ((int )fp->_flags & 512) {

  }
#line 147
  if ((int )fp->_flags & 256 && (int )fp->_flags & 8) {
#line 150
    _fflush_r(ptr, fp);
  }
#line 155
  seekfn = fp->_seek;
#line 155
  if ((unsigned int )seekfn == (unsigned int )((void *)0)) {
#line 157
    ptr->_errno = 29;
#line 158
    if ((int )fp->_flags & 512) {

    }
#line 159
    __sfp_lock_release();
#line 160
    return (-1);
  }
#line 168
  switch (whence) {
  case 1: 
#line 176
  _fflush_r(ptr, fp);
#line 177
  if ((int )fp->_flags & 4096) {
#line 178
    curoff = (long )fp->_offset;
  } else {
#line 181
    curoff = (*seekfn)(ptr, fp->_cookie, 0L, 1);
#line 182
    if (curoff == -1L) {
#line 184
      if ((int )fp->_flags & 512) {

      }
#line 185
      __sfp_lock_release();
#line 186
      return (-1);
    }
  }
#line 189
  if ((int )fp->_flags & 4) {
#line 191
    curoff -= (long )fp->_r;
#line 192
    if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 193
      curoff -= (long )fp->_ur;
    }
  } else
#line 195
  if ((int )fp->_flags & 8 && (unsigned int )fp->_p != (unsigned int )((void *)0)) {
#line 196
    curoff += (long )(fp->_p - fp->_bf._base);
  }
#line 198
  offset += curoff;
#line 199
  whence = 0;
#line 200
  havepos = 1;
#line 201
  break;
  case 0: 
  case 2: 
#line 205
  havepos = 0;
#line 206
  break;
  default: 
#line 209
  ptr->_errno = 22;
#line 210
  if ((int )fp->_flags & 512) {

  }
#line 211
  __sfp_lock_release();
#line 212
  return (-1);
  }
#line 224
  if ((unsigned int )fp->_bf._base == (unsigned int )((void *)0)) {
#line 225
    __smakebuf_r(ptr, fp);
  }
#line 226
  if ((int )fp->_flags & 2074) {
#line 227
    goto dumb;
  }
#line 228
  if (((int )fp->_flags & 1024) == 0) {
#line 230
    if ((unsigned int )seekfn != (unsigned int )(& __sseek) || (int )fp->_file < 0) {
#line 239
      fp->_flags = (short )((int )fp->_flags | 2048);
#line 240
      goto dumb;
    } else {
#line 230
      __cil_tmp = fstat((int )fp->_file, & st);
#line 230
      if (__cil_tmp) {
#line 239
        fp->_flags = (short )((int )fp->_flags | 2048);
#line 240
        goto dumb;
      } else
#line 230
      if ((st.st_mode & 8323072U) != 524288U) {
#line 239
        fp->_flags = (short )((int )fp->_flags | 2048);
#line 240
        goto dumb;
      }
    }
#line 245
    fp->_blksize = 1024;
#line 247
    fp->_flags = (short )((int )fp->_flags | 1024);
  }
#line 255
  if (whence == 0) {
#line 256
    target = offset;
  } else {
#line 262
    __cil_tmp___0 = fstat((int )fp->_file, & st);
#line 262
    if (__cil_tmp___0) {
#line 264
      goto dumb;
    }
#line 265
    target = st.st_size + offset;
  }
#line 267
  if (target != target) {
#line 269
    ptr->_errno = 139;
#line 270
    if ((int )fp->_flags & 512) {

    }
#line 271
    __sfp_lock_release();
#line 272
    return (-1);
  }
#line 275
  if (! havepos) {
#line 277
    if ((int )fp->_flags & 4096) {
#line 278
      curoff = (long )fp->_offset;
    } else {
#line 281
      curoff = (*seekfn)(ptr, fp->_cookie, 0L, 1);
#line 282
      if (curoff == -1L) {
#line 283
        goto dumb;
      }
    }
#line 285
    curoff -= (long )fp->_r;
#line 286
    if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 287
      curoff -= (long )fp->_ur;
    }
  }
#line 297
  if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 299
    curoff += (long )fp->_r;
#line 300
    n = (unsigned int )(fp->_up - fp->_bf._base);
#line 301
    curoff = (long )((unsigned long )curoff - (unsigned long )n);
#line 302
    n += (unsigned int )fp->_ur;
  } else {
#line 306
    n = (unsigned int )(fp->_p - fp->_bf._base);
#line 307
    curoff = (long )((unsigned long )curoff - (unsigned long )n);
#line 308
    n += (unsigned int )fp->_r;
  }
#line 317
  if (target >= curoff && (unsigned long )target < (unsigned long )curoff + (unsigned long )n) {
#line 319
    o = (int )(target - curoff);
#line 321
    fp->_p = fp->_bf._base + o;
#line 322
    fp->_r = (int )(n - (unsigned int )o);
#line 323
    if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 324
      if ((unsigned int )fp->_ub._base != (unsigned int )(fp->_ubuf)) {
#line 324
        _free_r(ptr, (void *)((char *)fp->_ub._base));
      }
#line 324
      fp->_ub._base = (unsigned char *)((void *)0);
    }
#line 325
    fp->_flags = (short )((int )fp->_flags & -33);
#line 326
    memset((void *)(& fp->_mbstate), 0, (unsigned int )sizeof(_mbstate_t ));
#line 327
    if ((int )fp->_flags & 512) {

    }
#line 328
    __sfp_lock_release();
#line 329
    return (0);
  }
#line 341
  curoff = target & (long )(~ (fp->_blksize - 1));
#line 342
  __cil_tmp___1 = (*seekfn)(ptr, fp->_cookie, curoff, 0);
#line 342
  if (__cil_tmp___1 == -1L) {
#line 343
    goto dumb;
  }
#line 344
  fp->_r = 0;
#line 345
  fp->_p = fp->_bf._base;
#line 346
  if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 347
    if ((unsigned int )fp->_ub._base != (unsigned int )(fp->_ubuf)) {
#line 347
      _free_r(ptr, (void *)((char *)fp->_ub._base));
    }
#line 347
    fp->_ub._base = (unsigned char *)((void *)0);
  }
#line 348
  fp->_flags = (short )((int )fp->_flags & -33);
#line 349
  n = (unsigned int )(target - curoff);
#line 350
  if (n) {
#line 352
    __cil_tmp___2 = __srefill_r(ptr, fp);
#line 352
    if (__cil_tmp___2 || (unsigned int )fp->_r < n) {
#line 353
      goto dumb;
    }
#line 354
    fp->_p += n;
#line 355
    fp->_r = (int )((unsigned int )fp->_r - n);
  }
#line 357
  memset((void *)(& fp->_mbstate), 0, (unsigned int )sizeof(_mbstate_t ));
#line 358
  if ((int )fp->_flags & 512) {

  }
#line 359
  __sfp_lock_release();
#line 360
  return (0);
  dumb: 
#line 368
  __cil_tmp___3 = _fflush_r(ptr, fp);
#line 368
  if (__cil_tmp___3) {
#line 368
    goto _L;
  } else {
#line 368
    __cil_tmp___4 = (*seekfn)(ptr, fp->_cookie, offset, whence);
#line 368
    if (__cil_tmp___4 == -1L) {
      _L: 
#line 371
      if ((int )fp->_flags & 512) {

      }
#line 372
      __sfp_lock_release();
#line 373
      return (-1);
    }
  }
#line 376
  if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 377
    if ((unsigned int )fp->_ub._base != (unsigned int )(fp->_ubuf)) {
#line 377
      _free_r(ptr, (void *)((char *)fp->_ub._base));
    }
#line 377
    fp->_ub._base = (unsigned char *)((void *)0);
  }
#line 378
  fp->_p = fp->_bf._base;
#line 379
  fp->_r = 0;
#line 381
  fp->_flags = (short )((int )fp->_flags & -33);
#line 388
  fp->_flags = (short )((int )fp->_flags & -2049);
#line 389
  memset((void *)(& fp->_mbstate), 0, (unsigned int )sizeof(_mbstate_t ));
#line 390
  if ((int )fp->_flags & 512) {

  }
#line 391
  __sfp_lock_release();
#line 392
  return (0);
}
}
#line 1 "lib_a-fseeko.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-xcLPkwRP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 34 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fseeko.c"
int fseeko(FILE *fp , long offset , int whence ) 
{ int __cil_tmp ;

  {
#line 41
  __cil_tmp = _fseek_r(_impure_ptr, fp, offset, whence);
#line 41
  return (__cil_tmp);
}
}
#line 1 "lib_a-fsetpos.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-m0ZHFC8c.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fstatr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ZtdWBmda.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ftell.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wcuFIXbG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 101 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/ftell.c"
long _ftell_r(struct _reent *ptr , FILE *fp ) 
{ _fpos_t pos ;

  {
#line 110
  while (1) {
#line 110
    if (ptr && ! ptr->__sdidinit) {
#line 110
      __sinit(ptr);
    }
#line 110
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 110
      fp = ptr->_stdin;
    } else
#line 110
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 110
      fp = ptr->_stdout;
    } else
#line 110
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 110
      fp = ptr->_stderr;
    }
#line 110
    break;
  }
#line 112
  if ((int )fp->_flags & 512) {

  }
#line 114
  if ((unsigned int )fp->_seek == (unsigned int )((void *)0)) {
#line 116
    ptr->_errno = 29;
#line 117
    if ((int )fp->_flags & 512) {

    }
#line 118
    return (-1L);
  }
#line 125
  if ((int )fp->_flags & 8) {
#line 126
    _fflush_r(ptr, fp);
  }
#line 127
  if ((int )fp->_flags & 4096) {
#line 128
    pos = (long )fp->_offset;
  } else {
#line 131
    pos = (*(fp->_seek))(ptr, fp->_cookie, 0L, 1);
#line 132
    if (pos == -1L) {
#line 134
      if ((int )fp->_flags & 512) {

      }
#line 135
      return (pos);
    }
  }
#line 138
  if ((int )fp->_flags & 4) {
#line 145
    pos -= (long )fp->_r;
#line 146
    if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 147
      pos -= (long )fp->_ur;
    }
  } else
#line 149
  if ((int )fp->_flags & 8 && (unsigned int )fp->_p != (unsigned int )((void *)0)) {
#line 156
    pos += (long )(fp->_p - fp->_bf._base);
  }
#line 159
  if ((int )fp->_flags & 512) {

  }
#line 160
  if (pos != pos) {
#line 162
    pos = -1L;
#line 163
    ptr->_errno = 139;
  }
#line 165
  return (pos);
}
}
#line 170 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/ftell.c"
long ftell(FILE *fp ) 
{ long __cil_tmp ;

  {
#line 174
  __cil_tmp = _ftell_r(_impure_ptr, fp);
#line 174
  return (__cil_tmp);
}
}
#line 1 "lib_a-ftello.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-l87ZJ3pC.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 33 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/ftello.c"
long ftello(FILE *fp ) 
{ long __cil_tmp ;

  {
#line 37
  __cil_tmp = _ftell_r(_impure_ptr, fp);
#line 37
  return (__cil_tmp);
}
}
#line 1 "lib_a-funopen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CL8Fh1pY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fvwrite.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Lz0JScNu.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 46 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fvwrite.c"
int __sfvwrite_r(struct _reent *ptr , FILE *fp , struct __suio *uio ) 
{ register size_t len ;
  register char const   *p ;
  register struct __siov *iov ;
  register int w ;
  register int s ;
  char *nl ;
  int nlknown ;
  int nldist ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  unsigned char *str ;
  int curpos ;
  int newsize ;
  void *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  void *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;

  {
#line 53
  p = (char const   *)((void *)0);
#line 59
  len = (unsigned int )uio->uio_resid;
#line 59
  if (len == 0U) {
#line 60
    return (0);
  }
#line 63
  if (((int )fp->_flags & 8) == 0 || (unsigned int )fp->_bf._base == (unsigned int )((void *)0)) {
#line 63
    __cil_tmp = __swsetup_r(ptr, fp);
#line 63
    if (__cil_tmp) {
#line 65
      fp->_flags = (short )((int )fp->_flags | 64);
#line 66
      ptr->_errno = 9;
#line 67
      return (-1);
    }
  }
#line 70
  iov = uio->uio_iov;
#line 71
  len = 0U;
#line 93
  if ((int )fp->_flags & 2) {
#line 98
    while (1) {
#line 100
      while (len == 0U) {
#line 100
        p = (char const   *)iov->iov_base;
#line 100
        len = iov->iov_len;
#line 100
        iov ++;
      }
#line 101
      w = (*(fp->_write))(ptr, fp->_cookie, p, (int )(len < 1024U ? len : 1024U));
#line 102
      if (w <= 0) {
#line 103
        goto err;
      }
#line 104
      p += w;
#line 105
      len -= (unsigned int )w;
#line 98
      __cil_tmp___0 = uio->uio_resid - w;
#line 98
      uio->uio_resid = __cil_tmp___0;
#line 98
      if (! (__cil_tmp___0 != 0)) {
#line 98
        break;
      }
    }
  } else
#line 109
  if (((int )fp->_flags & 1) == 0) {
#line 124
    while (1) {
#line 126
      while (len == 0U) {
#line 126
        p = (char const   *)iov->iov_base;
#line 126
        len = iov->iov_len;
#line 126
        iov ++;
      }
#line 127
      w = fp->_w;
#line 128
      if ((int )fp->_flags & 512) {
#line 130
        if (len >= (unsigned int )w && (int )fp->_flags & 1152) {
#line 133
          curpos = fp->_p - fp->_bf._base;
#line 141
          newsize = (fp->_bf._size * 3) / 2;
#line 142
          if ((unsigned int )newsize < ((unsigned int )curpos + len) + 1U) {
#line 143
            newsize = (int )(((unsigned int )curpos + len) + 1U);
          }
#line 144
          if ((int )fp->_flags & 1024) {
#line 147
            __cil_tmp___1 = _malloc_r(ptr, (unsigned int )newsize);
#line 147
            str = (unsigned char *)__cil_tmp___1;
#line 148
            if (! str) {
#line 150
              ptr->_errno = 12;
#line 151
              goto err;
            }
#line 153
            memcpy((void *)str, (void const   *)fp->_bf._base, (unsigned int )curpos);
#line 154
            fp->_flags = (short )(((int )fp->_flags & -1025) | 128);
          } else {
#line 158
            __cil_tmp___2 = _realloc_r(ptr, (void *)fp->_bf._base, (unsigned int )newsize);
#line 158
            str = (unsigned char *)__cil_tmp___2;
#line 160
            if (! str) {
#line 163
              _free_r(ptr, (void *)fp->_bf._base);
#line 165
              ptr->_errno = 12;
#line 166
              goto err;
            }
          }
#line 169
          fp->_bf._base = str;
#line 170
          fp->_p = str + curpos;
#line 171
          fp->_bf._size = newsize;
#line 172
          w = (int )len;
#line 173
          fp->_w = newsize - curpos;
        }
#line 175
        if (len < (unsigned int )w) {
#line 176
          w = (int )len;
        }
#line 177
        memmove((void *)fp->_p, (void const   *)((void *)p), (unsigned int )w);
#line 178
        fp->_w -= w;
#line 179
        fp->_p += w;
#line 180
        w = (int )len;
      } else
#line 182
      if ((unsigned int )fp->_p > (unsigned int )fp->_bf._base && len > (unsigned int )w) {
#line 185
        memmove((void *)fp->_p, (void const   *)((void *)p), (unsigned int )w);
#line 187
        fp->_p += w;
#line 188
        __cil_tmp___3 = _fflush_r(ptr, fp);
#line 188
        if (__cil_tmp___3) {
#line 189
          goto err;
        }
      } else {
#line 191
        w = fp->_bf._size;
#line 191
        if (len >= (unsigned int )w) {
#line 194
          w = (*(fp->_write))(ptr, fp->_cookie, p, w);
#line 195
          if (w <= 0) {
#line 196
            goto err;
          }
        } else {
#line 201
          w = (int )len;
#line 202
          memmove((void *)fp->_p, (void const   *)((void *)p), (unsigned int )w);
#line 203
          fp->_w -= w;
#line 204
          fp->_p += w;
        }
      }
#line 206
      p += w;
#line 207
      len -= (unsigned int )w;
#line 124
      __cil_tmp___4 = uio->uio_resid - w;
#line 124
      uio->uio_resid = __cil_tmp___4;
#line 124
      if (! (__cil_tmp___4 != 0)) {
#line 124
        break;
      }
    }
  } else {
#line 220
    nlknown = 0;
#line 221
    nldist = 0;
#line 222
    while (1) {
#line 224
      while (len == 0U) {
#line 224
        nlknown = 0;
#line 224
        p = (char const   *)iov->iov_base;
#line 224
        len = iov->iov_len;
#line 224
        iov ++;
      }
#line 225
      if (! nlknown) {
#line 227
        __cil_tmp___5 = memchr((void const   *)((void *)p), '\n', len);
#line 227
        nl = (char *)__cil_tmp___5;
#line 228
        nldist = (int )(nl ? (unsigned int )((nl + 1) - (char *)p) : len + 1U);
#line 229
        nlknown = 1;
      }
#line 231
      s = (int )(len < (unsigned int )nldist ? len : (unsigned int )nldist);
#line 232
      w = fp->_w + fp->_bf._size;
#line 233
      if ((unsigned int )fp->_p > (unsigned int )fp->_bf._base && s > w) {
#line 235
        memmove((void *)fp->_p, (void const   *)((void *)p), (unsigned int )w);
#line 237
        fp->_p += w;
#line 238
        __cil_tmp___6 = _fflush_r(ptr, fp);
#line 238
        if (__cil_tmp___6) {
#line 239
          goto err;
        }
      } else {
#line 241
        w = fp->_bf._size;
#line 241
        if (s >= w) {
#line 243
          w = (*(fp->_write))(ptr, fp->_cookie, p, w);
#line 244
          if (w <= 0) {
#line 245
            goto err;
          }
        } else {
#line 249
          w = s;
#line 250
          memmove((void *)fp->_p, (void const   *)((void *)p), (unsigned int )w);
#line 251
          fp->_w -= w;
#line 252
          fp->_p += w;
        }
      }
#line 254
      nldist -= w;
#line 254
      if (nldist == 0) {
#line 257
        __cil_tmp___7 = _fflush_r(ptr, fp);
#line 257
        if (__cil_tmp___7) {
#line 258
          goto err;
        }
#line 259
        nlknown = 0;
      }
#line 261
      p += w;
#line 262
      len -= (unsigned int )w;
#line 222
      __cil_tmp___8 = uio->uio_resid - w;
#line 222
      uio->uio_resid = __cil_tmp___8;
#line 222
      if (! (__cil_tmp___8 != 0)) {
#line 222
        break;
      }
    }
  }
#line 266
  return (0);
  err: 
#line 269
  fp->_flags = (short )((int )fp->_flags | 64);
#line 270
  return (-1);
}
}
#line 1 "lib_a-fwalk.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-YL8pJAO3.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 30 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fwalk.c"
static int __fwalk(struct _reent *ptr , int (*function)(FILE * ) ) 
{ register FILE *fp ;
  register int n ;
  register int ret ;
  register struct _glue *g ;
  int __cil_tmp ;

  {
#line 36
  ret = 0;
#line 39
  g = & ptr->__sglue;
#line 39
  while ((unsigned int )g != (unsigned int )((void *)0)) {
#line 40
    fp = g->_iobs;
#line 40
    n = g->_niobs;
#line 40
    while (1) {
#line 40
      n --;
#line 40
      if (! (n >= 0)) {
#line 40
        break;
      }
#line 41
      if ((int )fp->_flags != 0) {
#line 43
        if ((int )fp->_flags != 0 && (int )fp->_file != -1) {
#line 44
          __cil_tmp = (*function)(fp);
#line 44
          ret |= __cil_tmp;
        }
      }
#line 40
      fp ++;
    }
#line 39
    g = g->_next;
  }
#line 47
  return (ret);
}
}
#line 52 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fwalk.c"
static int __fwalk_reent(struct _reent *ptr , int (*reent_function)(struct _reent * ,
                                                                    FILE * ) ) 
{ register FILE *fp ;
  register int n ;
  register int ret ;
  register struct _glue *g ;
  int __cil_tmp ;

  {
#line 58
  ret = 0;
#line 61
  g = & ptr->__sglue;
#line 61
  while ((unsigned int )g != (unsigned int )((void *)0)) {
#line 62
    fp = g->_iobs;
#line 62
    n = g->_niobs;
#line 62
    while (1) {
#line 62
      n --;
#line 62
      if (! (n >= 0)) {
#line 62
        break;
      }
#line 63
      if ((int )fp->_flags != 0) {
#line 65
        if ((int )fp->_flags != 0 && (int )fp->_file != -1) {
#line 66
          __cil_tmp = (*reent_function)(ptr, fp);
#line 66
          ret |= __cil_tmp;
        }
      }
#line 62
      fp ++;
    }
#line 61
    g = g->_next;
  }
#line 69
  return (ret);
}
}
#line 72 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fwalk.c"
int _fwalk(struct _reent *ptr , int (*function)(FILE * ) ) 
{ register int ret ;
  int __cil_tmp ;

  {
#line 77
  ret = 0;
#line 79
  __sfp_lock_acquire();
#line 83
  __cil_tmp = __fwalk(ptr, function);
#line 83
  ret |= __cil_tmp;
#line 85
  __sfp_lock_release();
#line 87
  return (ret);
}
}
#line 92 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fwalk.c"
int _fwalk_reent(struct _reent *ptr , int (*reent_function)(struct _reent * , FILE * ) ) 
{ register int ret ;
  int __cil_tmp ;

  {
#line 97
  ret = 0;
#line 99
  __sfp_lock_acquire();
#line 103
  __cil_tmp = __fwalk_reent(ptr, reent_function);
#line 103
  ret |= __cil_tmp;
#line 105
  __sfp_lock_release();
#line 107
  return (ret);
}
}
#line 1 "lib_a-fwide.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jBTIUS4L.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fwprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-3M1I9gfq.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-fwrite.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Vau2b0ZI.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 402 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
size_t _fwrite_r(struct _reent *ptr , void const   *buf , size_t size , size_t count ,
                 FILE *fp ) ;
#line 97 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fwrite.c"
size_t _fwrite_r(struct _reent *ptr , void const   *buf , size_t size , size_t count ,
                 FILE *fp ) 
{ size_t n ;
  struct __suio uio ;
  struct __siov iov ;
  int __cil_tmp ;

  {
#line 109
  iov.iov_base = buf;
#line 110
  n = count * size;
#line 110
  iov.iov_len = n;
#line 110
  uio.uio_resid = (int )iov.iov_len;
#line 111
  uio.uio_iov = & iov;
#line 112
  uio.uio_iovcnt = 1;
#line 120
  while (1) {
#line 120
    if (ptr && ! ptr->__sdidinit) {
#line 120
      __sinit(ptr);
    }
#line 120
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 120
      fp = ptr->_stdin;
    } else
#line 120
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 120
      fp = ptr->_stdout;
    } else
#line 120
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 120
      fp = ptr->_stderr;
    }
#line 120
    break;
  }
#line 122
  if ((int )fp->_flags & 512) {

  }
#line 123
  while (1) {
#line 123
    if (! ((int )fp->_flags & 8192)) {
#line 123
      fp->_flags = (short )((int )fp->_flags | 8192);
#line 123
      fp->_flags2 &= -8193;
    }
#line 123
    break;
  }
#line 124
  __cil_tmp = __sfvwrite_r(ptr, fp, & uio);
#line 124
  if (__cil_tmp == 0) {
#line 126
    if ((int )fp->_flags & 512) {

    }
#line 127
    return (count);
  }
#line 129
  if ((int )fp->_flags & 512) {

  }
#line 130
  return ((n - (unsigned int )uio.uio_resid) / size);
}
}
#line 134 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/fwrite.c"
size_t fwrite(void const   *buf , size_t size , size_t count , FILE *fp ) 
{ size_t __cil_tmp ;

  {
#line 141
  __cil_tmp = _fwrite_r(_impure_ptr, buf, size, count, fp);
#line 141
  return (__cil_tmp);
}
}
#line 1 "lib_a-fwscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-FvpxpPmk.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-gdtoa-gethex.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-u3kH6hqJ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 398 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
int __gethex(struct _reent *ptr , char const   **sp , struct FPI *fpi___0 , Long *exp___0 ,
             _Bigint **bp , int sign ) ;
#line 400
__ULong __any_on(_Bigint *b , int k ) ;
#line 402
void __hexdig_init(void) ;
#line 412 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
unsigned char __hexdig[256]  ;
#line 61 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/locale.h"
struct lconv *_localeconv_r(struct _reent *data ) ;
#line 42 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa-gethex.c"
static void htinit(unsigned char *h , unsigned char *s , int inc ) 
{ int i ;
  int j ;

  {
#line 49
  i = 0;
#line 49
  while (1) {
#line 49
    j = (int )*(s + i);
#line 49
    if (! (j != 0)) {
#line 49
      break;
    }
#line 50
    *(h + j) = (unsigned char )(i + inc);
#line 49
    i ++;
  }
#line 51
  return;
}
}
#line 53 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa-gethex.c"
void __hexdig_init(void) 
{ 

  {
#line 57
  htinit(__hexdig, (unsigned char *)"0123456789", 16);
#line 58
  htinit(__hexdig, (unsigned char *)"abcdef", 26);
#line 59
  htinit(__hexdig, (unsigned char *)"ABCDEF", 26);
#line 60
  return;
}
}
#line 62 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa-gethex.c"
static void rshift(_Bigint *b , int k ) 
{ __ULong *x ;
  __ULong *x1 ;
  __ULong *xe ;
  __ULong y ;
  int n ;
  __ULong *__cil_tmp ;
  __ULong *__cil_tmp___0 ;
  __ULong *__cil_tmp___1 ;
  __ULong __cil_tmp___2 ;
  __ULong *__cil_tmp___3 ;
  __ULong *__cil_tmp___4 ;
  int __cil_tmp___5 ;

  {
#line 70
  x1 = b->_x;
#line 70
  x = x1;
#line 71
  n = k >> 5;
#line 72
  if (n < b->_wds) {
#line 73
    xe = x + b->_wds;
#line 74
    x += n;
#line 75
    k &= 31;
#line 75
    if (k) {
#line 76
      n = 32 - k;
#line 77
      __cil_tmp = x;
#line 77
      x ++;
#line 77
      y = *__cil_tmp >> k;
#line 78
      while ((unsigned int )x < (unsigned int )xe) {
#line 79
        __cil_tmp___0 = x1;
#line 79
        x1 ++;
#line 79
        *__cil_tmp___0 = (y | (*x << n)) & 4294967295UL;
#line 80
        __cil_tmp___1 = x;
#line 80
        x ++;
#line 80
        y = *__cil_tmp___1 >> k;
      }
#line 82
      __cil_tmp___2 = y;
#line 82
      *x1 = __cil_tmp___2;
#line 82
      if (__cil_tmp___2 != 0UL) {
#line 83
        x1 ++;
      }
    } else {
#line 86
      while ((unsigned int )x < (unsigned int )xe) {
#line 87
        __cil_tmp___3 = x1;
#line 87
        x1 ++;
#line 87
        __cil_tmp___4 = x;
#line 87
        x ++;
#line 87
        *__cil_tmp___3 = *__cil_tmp___4;
      }
    }
  }
#line 89
  __cil_tmp___5 = x1 - b->_x;
#line 89
  b->_wds = __cil_tmp___5;
#line 89
  if (__cil_tmp___5 == 0) {
#line 90
    b->_x[0] = 0UL;
  }
#line 91
  return;
}
}
#line 93 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa-gethex.c"
static _Bigint *increment(struct _reent *ptr , _Bigint *b ) 
{ __ULong *x ;
  __ULong *xe ;
  _Bigint *b1 ;
  __ULong *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 104
  x = b->_x;
#line 105
  xe = x + b->_wds;
#line 107
  while (1) {
#line 108
    if (*x < 4294967295UL) {
#line 109
      (*x) ++;
#line 110
      return (b);
    }
#line 112
    __cil_tmp = x;
#line 112
    x ++;
#line 112
    *__cil_tmp = 0UL;
#line 107
    if (! ((unsigned int )x < (unsigned int )xe)) {
#line 107
      break;
    }
  }
#line 125
  if (b->_wds >= b->_maxwds) {
#line 126
    b1 = _Balloc(ptr, b->_k + 1);
#line 127
    memcpy((void *)((char *)(& b1->_sign)), (void const   *)((char *)(& b->_sign)),
           (unsigned int )((unsigned long )b->_wds * sizeof(long ) + 2UL * sizeof(int )));
#line 128
    _Bfree(ptr, b);
#line 129
    b = b1;
  }
#line 131
  __cil_tmp___0 = b->_wds;
#line 131
  (b->_wds) ++;
#line 131
  b->_x[__cil_tmp___0] = 1UL;
#line 133
  return (b);
}
}
#line 137 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa-gethex.c"
int __gethex(struct _reent *ptr , char const   **sp , struct FPI *fpi___0 , Long *exp___0 ,
             _Bigint **bp , int sign ) 
{ _Bigint *b ;
  unsigned char const   *decpt ;
  unsigned char const   *s0 ;
  unsigned char const   *s ;
  unsigned char const   *s1___0 ;
  int esign ;
  int havedig ;
  int irv ;
  int k ;
  int n ;
  int nbits ;
  int up ;
  int zret ;
  __ULong L ;
  __ULong lostbits ;
  __ULong *x ;
  Long e ;
  Long e1 ;
  unsigned char *decimalpoint ;
  struct lconv *__cil_tmp ;
  size_t decp_len ;
  size_t __cil_tmp___0 ;
  unsigned char decp_end ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  __ULong *__cil_tmp___4 ;
  __ULong *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  __ULong __cil_tmp___7 ;
  __ULong __cil_tmp___8 ;
  __ULong __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;

  {
#line 151
  __cil_tmp = _localeconv_r(ptr);
#line 151
  decimalpoint = (unsigned char *)__cil_tmp->decimal_point;
#line 153
  __cil_tmp___0 = strlen((char const   *)decimalpoint);
#line 153
  decp_len = __cil_tmp___0;
#line 154
  decp_end = *(decimalpoint + (decp_len - 1U));
#line 156
  if (! __hexdig[48]) {
#line 157
    __hexdig_init();
  }
#line 158
  havedig = 0;
#line 159
  s0 = *((unsigned char const   **)sp) + 2;
#line 160
  while ((int const   )*(s0 + havedig) == 48) {
#line 161
    havedig ++;
  }
#line 162
  s0 += havedig;
#line 163
  s = s0;
#line 164
  decpt = (unsigned char const   *)0;
#line 165
  zret = 0;
#line 166
  e = 0;
#line 167
  if (! __hexdig[*s]) {
#line 168
    zret = 1;
#line 169
    __cil_tmp___1 = strncmp((char const   *)s, (char const   *)decimalpoint, decp_len);
#line 169
    if (__cil_tmp___1 != 0) {
#line 171
      goto pcheck;
    }
#line 172
    s += decp_len;
#line 172
    decpt = s;
#line 173
    if (! __hexdig[*s]) {
#line 174
      goto pcheck;
    }
#line 175
    while ((int const   )*s == 48) {
#line 176
      s ++;
    }
#line 177
    if (__hexdig[*s]) {
#line 178
      zret = 0;
    }
#line 179
    havedig = 1;
#line 180
    s0 = s;
  }
#line 182
  while (__hexdig[*s]) {
#line 183
    s ++;
  }
#line 184
  __cil_tmp___2 = strncmp((char const   *)s, (char const   *)decimalpoint, decp_len);
#line 184
  if (__cil_tmp___2 == 0 && ! decpt) {
#line 187
    s += decp_len;
#line 187
    decpt = s;
#line 188
    while (__hexdig[*s]) {
#line 189
      s ++;
    }
  }
#line 191
  if (decpt) {
#line 192
    e = - ((s - decpt) << 2);
  }
  pcheck: 
#line 194
  s1___0 = s;
#line 195
  switch ((int )*s) {
  case 112: 
  case 80: 
#line 198
  esign = 0;
#line 199
  s ++;
#line 199
  switch ((int )*s) {
  case 45: 
#line 201
  esign = 1;
  case 43: 
#line 204
  s ++;
  }
#line 206
  n = (int )__hexdig[*s];
#line 206
  if (n == 0 || n > 25) {
#line 207
    s = s1___0;
#line 208
    break;
  }
#line 210
  e1 = n - 16;
#line 211
  while (1) {
#line 211
    s ++;
#line 211
    n = (int )__hexdig[*s];
#line 211
    if (! (n != 0 && n <= 25)) {
#line 211
      break;
    }
#line 212
    e1 = (10 * e1 + n) - 16;
  }
#line 213
  if (esign) {
#line 214
    e1 = - e1;
  }
#line 215
  e += e1;
  }
#line 217
  *sp = (char const   *)((char *)s);
#line 218
  if (zret) {
#line 219
    return (havedig ? 0 : 6);
  }
#line 220
  n = (s1___0 - s0) - 1;
#line 221
  k = 0;
#line 221
  while (n > 7) {
#line 222
    k ++;
#line 221
    n >>= 1;
  }
#line 223
  b = _Balloc(ptr, k);
#line 224
  x = b->_x;
#line 225
  n = 0;
#line 226
  L = 0UL;
#line 227
  while ((unsigned int )s1___0 > (unsigned int )s0) {
#line 228
    s1___0 --;
#line 228
    if ((int const   )*s1___0 == (int const   )decp_end && (unsigned int )((s1___0 - decp_len) + 1) >= (unsigned int )s0) {
#line 228
      __cil_tmp___3 = strncmp(((char const   *)s1___0 - decp_len) + 1, (char const   *)decimalpoint,
                              decp_len);
#line 228
      if (__cil_tmp___3 == 0) {
#line 231
        s1___0 -= decp_len - 1U;
#line 232
        continue;
      }
    }
#line 234
    if (n == 32) {
#line 235
      __cil_tmp___4 = x;
#line 235
      x ++;
#line 235
      *__cil_tmp___4 = L;
#line 236
      L = 0UL;
#line 237
      n = 0;
    }
#line 239
    L |= (unsigned long )(((int )__hexdig[*s1___0] & 15) << n);
#line 240
    n += 4;
  }
#line 242
  __cil_tmp___5 = x;
#line 242
  x ++;
#line 242
  *__cil_tmp___5 = L;
#line 243
  n = x - b->_x;
#line 243
  b->_wds = n;
#line 244
  __cil_tmp___6 = __hi0bits(L);
#line 244
  n = 32 * n - __cil_tmp___6;
#line 245
  nbits = fpi___0->nbits;
#line 246
  lostbits = 0UL;
#line 247
  x = b->_x;
#line 248
  if (n > nbits) {
#line 249
    n -= nbits;
#line 250
    __cil_tmp___8 = __any_on(b, n);
#line 250
    if (__cil_tmp___8) {
#line 251
      lostbits = 1UL;
#line 252
      k = n - 1;
#line 253
      if (*(x + (k >> 5)) & (unsigned long )(1 << (k & 31))) {
#line 254
        lostbits = 2UL;
#line 255
        if (k > 1) {
#line 255
          __cil_tmp___7 = __any_on(b, k - 1);
#line 255
          if (__cil_tmp___7) {
#line 256
            lostbits = 3UL;
          }
        }
      }
    }
#line 259
    rshift(b, n);
#line 260
    e += n;
  } else
#line 262
  if (n < nbits) {
#line 263
    n = nbits - n;
#line 264
    b = __lshift(ptr, b, n);
#line 265
    e -= n;
#line 266
    x = b->_x;
  }
#line 268
  if (e > fpi___0->emax) {
    ovfl: 
#line 270
    _Bfree(ptr, b);
#line 271
    *bp = (_Bigint *)0;
#line 272
    return (163);
  }
#line 274
  irv = 1;
#line 275
  if (e < fpi___0->emin) {
#line 276
    irv = 2;
#line 277
    n = fpi___0->emin - e;
#line 278
    if (n >= nbits) {
#line 279
      switch (fpi___0->rounding) {
      case 1: 
#line 281
      if (n == nbits) {
#line 281
        if (n < 2) {
#line 282
          goto one_bit;
        } else {
#line 281
          __cil_tmp___9 = __any_on(b, n - 1);
#line 281
          if (__cil_tmp___9) {
#line 282
            goto one_bit;
          }
        }
      }
#line 283
      break;
      case 2: 
#line 285
      if (! sign) {
#line 286
        goto one_bit;
      }
#line 287
      break;
      case 3: 
#line 289
      if (sign) {
        one_bit: 
#line 291
        *exp___0 = fpi___0->emin;
#line 292
        __cil_tmp___10 = 1;
#line 292
        b->_wds = __cil_tmp___10;
#line 292
        *(x + 0) = (unsigned long )__cil_tmp___10;
#line 293
        *bp = b;
#line 294
        return (98);
      }
      }
#line 298
      _Bfree(ptr, b);
#line 299
      *bp = (_Bigint *)0;
#line 300
      return (80);
    }
#line 302
    k = n - 1;
#line 303
    if (lostbits) {
#line 304
      lostbits = 1UL;
    } else
#line 305
    if (k > 0) {
#line 306
      lostbits = __any_on(b, k);
    }
#line 307
    if (*(x + (k >> 5)) & (unsigned long )(1 << (k & 31))) {
#line 308
      lostbits |= 2UL;
    }
#line 309
    nbits -= n;
#line 310
    rshift(b, n);
#line 311
    e = fpi___0->emin;
  }
#line 313
  if (lostbits) {
#line 314
    up = 0;
#line 315
    switch (fpi___0->rounding) {
    case 0: 
#line 317
    break;
    case 1: 
#line 319
    if (lostbits & 2UL && (lostbits & 1UL) | (*(x + 0) & 1UL)) {
#line 321
      up = 1;
    }
#line 322
    break;
    case 2: 
#line 324
    up = 1 - sign;
#line 325
    break;
    case 3: 
#line 327
    up = sign;
    }
#line 329
    if (up) {
#line 330
      k = b->_wds;
#line 331
      b = increment(ptr, b);
#line 332
      x = b->_x;
#line 333
      if (irv == 2) {
#line 334
        if (nbits == fpi___0->nbits - 1 && *(x + (nbits >> 5)) & (unsigned long )(1 << (nbits & 31))) {
#line 336
          irv = 1;
        }
      } else
#line 338
      if (b->_wds > k) {
#line 338
        goto _L;
      } else {
#line 338
        n = nbits & 31;
#line 338
        if (n != 0) {
#line 338
          __cil_tmp___11 = __hi0bits(*(x + (k - 1)));
#line 338
          if (__cil_tmp___11 < 32 - n) {
            _L: 
#line 341
            rshift(b, 1);
#line 342
            e ++;
#line 342
            if (e > fpi___0->emax) {
#line 343
              goto ovfl;
            }
          }
        }
      }
#line 345
      irv |= 32;
    } else {
#line 348
      irv |= 16;
    }
  }
#line 350
  *bp = b;
#line 351
  *exp___0 = e;
#line 352
  return (irv);
}
}
#line 1 "lib_a-gdtoa-hexnan.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-xHJ0WRzx.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 404 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
int __hexnan(char const   **sp , struct FPI *fpi___0 , __ULong *x0 ) ;
#line 47 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa-hexnan.c"
static void L_shift(__ULong *x , __ULong *x1 , int i ) 
{ int j ;

  {
#line 55
  i = 8 - i;
#line 56
  i <<= 2;
#line 57
  j = 32 - i;
#line 58
  while (1) {
#line 59
    *x |= *(x + 1) << j;
#line 60
    *(x + 1) >>= i;
#line 58
    x ++;
#line 58
    if (! ((unsigned int )x < (unsigned int )x1)) {
#line 58
      break;
    }
  }
#line 62
  return;
}
}
#line 64 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/gdtoa-hexnan.c"
int __hexnan(char const   **sp , struct FPI *fpi___0 , __ULong *x0 ) 
{ __ULong c ;
  __ULong h ;
  __ULong *x ;
  __ULong *x1 ;
  __ULong *xe ;
  char const   *s ;
  int havedig ;
  int hd0 ;
  int i ;
  int nbits ;
  __ULong *__cil_tmp ;
  __ULong *__cil_tmp___0 ;
  __ULong *__cil_tmp___1 ;

  {
#line 74
  if (! __hexdig[48]) {
#line 75
    __hexdig_init();
  }
#line 76
  nbits = fpi___0->nbits;
#line 77
  x = x0 + (nbits >> 5);
#line 78
  if (nbits & 31) {
#line 79
    x ++;
  }
#line 80
  x --;
#line 80
  *x = 0UL;
#line 81
  xe = x;
#line 81
  x1 = xe;
#line 82
  i = 0;
#line 82
  hd0 = i;
#line 82
  havedig = hd0;
#line 83
  s = *sp;
#line 84
  while (1) {
#line 84
    s ++;
#line 84
    c = (unsigned long )*((unsigned char const   *)s);
#line 84
    if (! c) {
#line 84
      break;
    }
#line 85
    h = (unsigned long )__hexdig[c];
#line 85
    if (! h) {
#line 86
      if (c <= 32UL) {
#line 87
        if (hd0 < havedig) {
#line 88
          if ((unsigned int )x < (unsigned int )x1 && i < 8) {
#line 89
            L_shift(x, x1, i);
          }
#line 90
          if ((unsigned int )x <= (unsigned int )x0) {
#line 91
            i = 8;
#line 92
            continue;
          }
#line 94
          hd0 = havedig;
#line 95
          x --;
#line 95
          *x = 0UL;
#line 96
          x1 = x;
#line 97
          i = 0;
        }
#line 99
        continue;
      }
#line 101
      if (c == 41UL) {
#line 102
        *sp = s + 1;
#line 103
        break;
      }
#line 105
      return (4);
    }
#line 107
    havedig ++;
#line 108
    i ++;
#line 108
    if (i > 8) {
#line 109
      if ((unsigned int )x <= (unsigned int )x0) {
#line 110
        continue;
      }
#line 111
      i = 1;
#line 112
      x --;
#line 112
      *x = 0UL;
    }
#line 114
    *x = (*x << 4) | (h & 15UL);
  }
#line 116
  if (! havedig) {
#line 117
    return (4);
  }
#line 118
  if ((unsigned int )x < (unsigned int )x1 && i < 8) {
#line 119
    L_shift(x, x1, i);
  }
#line 120
  if ((unsigned int )x > (unsigned int )x0) {
#line 121
    x1 = x0;
#line 122
    while (1) {
#line 122
      __cil_tmp = x1;
#line 122
      x1 ++;
#line 122
      __cil_tmp___0 = x;
#line 122
      x ++;
#line 122
      *__cil_tmp = *__cil_tmp___0;
#line 122
      if (! ((unsigned int )x <= (unsigned int )xe)) {
#line 122
        break;
      }
    }
#line 124
    while (1) {
#line 124
      __cil_tmp___1 = x1;
#line 124
      x1 ++;
#line 124
      *__cil_tmp___1 = 0UL;
#line 124
      if (! ((unsigned int )x1 <= (unsigned int )xe)) {
#line 124
        break;
      }
    }
  } else {
#line 129
    i = nbits & 31;
#line 129
    if (i != 0) {
#line 130
      *xe &= 4294967295UL >> (32 - i);
    }
  }
#line 132
  x1 = xe;
#line 132
  while (! (*x1 != 0UL)) {
#line 135
    if ((unsigned int )x1 == (unsigned int )x0) {
#line 136
      *x1 = 1UL;
#line 137
      break;
    }
#line 132
    x1 --;
  }
#line 140
  return (5);
}
}
#line 1 "lib_a-getc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Q7x4b640.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getc_u.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-3FqeF86T.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getchar.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-h5bUA68L.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getchar_u.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ALBjGgtg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getdelim.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jZPmN9Z5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getenv.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-qq4Bxw89.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getenv_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SyqVNLcy.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getline.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-MzhtBXTm.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getopt.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-slfGQ3S1.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getreent.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-qkI2Rfif.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-gets.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-m0p0FOBU.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getsubopt.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-gjPMsqbL.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-gettimeofdayr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-zmVxZAq7.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-gettzinfo.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-4V66hFIY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getw.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1LE9BiiF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getwc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-b6RvYBCi.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-getwchar.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IcoyWJVk.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-glob.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-W7w47plp.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-gmtime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-2SYjoE8H.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-gmtime_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SgRcBxaP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-hash.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-VKOKKSyb.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-hash_bigkey.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ZXLow0G6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-hash_buf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-b8xmx8s6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-hash_func.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-JPQ6zPev.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-hash_log2.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-gAHsVROn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-hash_page.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-N6GtXHyG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-hcreate.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-110V3A8Z.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-hcreate_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-X2EvujyG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-impure.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-60aV1Yxw.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 23 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/reent/impure.c"
static struct _reent impure_data  = 
#line 23 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/reent/impure.c"
     {0, (__FILE *)(& __sf_fake_stdin), (__FILE *)(& __sf_fake_stdout), (__FILE *)(& __sf_fake_stderr),
    0, (char *)0, 0, 0, "C", (struct _mprec *)0, (void (*)(struct _reent * ))0, 0,
    0, (char *)0, (struct _rand48 *)0, (struct __tm *)0, (char *)0, (void (**)(int  ))0,
    (struct _atexit *)0, {(struct _atexit *)0, 0, {(void (*)(void))0}, (struct _on_exit_args *)0},
    {(struct _glue *)0, 0, (__FILE *)0}, (__FILE *)0, (struct _misc_reent *)0, (char *)0};
#line 27 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/reent/impure.c"
struct _reent *_impure_ptr  =    & impure_data;
#line 28 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/reent/impure.c"
struct _reent * const  _global_impure_ptr  =    (struct _reent * const  )(& impure_data);
#line 1 "lib_a-index.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hcgaswh7.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-init.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-OOlhyGl5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-uzXcdSGq.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isalnum.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-0KGVd5CA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isalpha.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-QcvMNwQQ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isascii.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-s6acwAgi.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isatty.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-uJAnwRGF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 108 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
int isatty(int fd ) ;
#line 6 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/posix/isatty.c"
int isatty(int fd ) 
{ int __cil_tmp ;

  {
#line 9
  __cil_tmp = _isatty(fd);
#line 9
  return (__cil_tmp);
}
}
#line 1 "lib_a-isattyr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CWwEbMES.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isblank.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-LJVPyyLn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-flacImBv.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iscntrl.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-zq1t7Xnj.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isdigit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1MB5JlPg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-islower.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dUsYD47I.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isprint.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-htLtnywT.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ispunct.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-43lSrnLT.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isspace.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-PXQ9QFFU.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isupper.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vwqOR1EU.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswalnum.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-c7Q4SdEU.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswalpha.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-TILhfoFr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswblank.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-862yeeWX.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswcntrl.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5NEvfb8K.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswctype.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-aqt5OCFR.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 36 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/wctype.h"
int iswspace(wint_t c ) ;
#line 1 "lib_a-iswdigit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-a9km8KfZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswgraph.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-nja3F6lA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswlower.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-2Ni9d3OB.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswprint.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dKVdLdw1.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswpunct.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-fxbl2Q24.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswspace.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-UUNTlF7F.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 65 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/ctype/iswspace.c"
int iswspace(wint_t c ) 
{ 

  {
#line 80
  return ((int )(c < 256 ? (int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 8 : (int const   )0));
}
}
#line 1 "lib_a-iswupper.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ixxGH7PU.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-iswxdigit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IIONS71N.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-isxdigit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-AA5D8exS.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-jp2uc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-edj21S4S.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-jrand48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-RR5IuAUg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-l64a.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8AnCU4gN.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-labs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1ImQvEln.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lcltime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lLK2yAgn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lcltime_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-AXhuplpB.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lcong48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-2A4aJ8OZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lctype.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-51TzAAEX.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ldiv.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5t9jawgg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ldpart.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Kf5HXwsk.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ldtoa.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-iAlZcITT.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-linkr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5scPGsNq.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-llabs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-sm2UbY8u.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lldiv.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-kfSEI7du.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lmessages.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Fk5EB2X9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lmonetary.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-A44QKDgV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lnumeric.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-MNaNzbpP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-locale.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-QTUQinqK.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 190 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/locale/locale.c"
int __mb_cur_max  =    1;
#line 196 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/locale/locale.c"
static struct lconv lconv  = 
#line 196
     {(char *)".", (char *)"", (char *)"", (char *)"", (char *)"", (char *)"", (char *)"",
    (char *)"", (char *)"", (char *)"", (char)127, (char)127, (char)127, (char)127,
    (char)127, (char)127, (char)127, (char)127, (char)127, (char)127, (char)127, (char)127,
    (char)127, (char)127};
#line 262 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/locale/locale.c"
static char lc_ctype_charset[32]  = {      (char )'A',      (char )'S',      (char )'C',      (char )'I', 
        (char )'I',      (char )'\000'};
#line 930 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/locale/locale.c"
char *__locale_charset(void) 
{ 

  {
#line 936
  return (lc_ctype_charset);
}
}
#line 940 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/locale/locale.c"
int __locale_mb_cur_max(void) 
{ 

  {
#line 946
  return (__mb_cur_max);
}
}
#line 967 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/locale/locale.c"
struct lconv *_localeconv_r(struct _reent *data ) 
{ 

  {
#line 1016
  return (& lconv);
}
}
#line 1 "lib_a-longjmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-HbYsbB7E.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lrand48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vRn8oTfP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-lseekr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jlyxcWcd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-makebuf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-LM23vyAn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 37 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/makebuf.c"
void __smakebuf_r(struct _reent *ptr , FILE *fp ) 
{ register size_t size ;
  register size_t couldbetty ;
  register void *p ;
  struct stat st ;
  unsigned char *__cil_tmp ;
  int __cil_tmp___0 ;
  unsigned char *__cil_tmp___1 ;
  unsigned char *__cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 50
  if ((int )fp->_flags & 2) {
#line 52
    __cil_tmp = fp->_nbuf;
#line 52
    fp->_p = __cil_tmp;
#line 52
    fp->_bf._base = __cil_tmp;
#line 53
    fp->_bf._size = 1;
#line 54
    return;
  }
#line 59
  if ((int )fp->_file < 0) {
#line 59
    goto _L;
  } else {
#line 59
    __cil_tmp___0 = fstat((int )fp->_file, & st);
#line 59
    if (__cil_tmp___0 < 0) {
      _L: 
#line 62
      couldbetty = 0U;
#line 64
      if ((int )fp->_flags & 128) {
#line 65
        size = 64U;
      } else {
#line 67
        size = 1024U;
      }
#line 69
      fp->_flags = (short )((int )fp->_flags | 2048);
    } else {
#line 73
      couldbetty = (unsigned int )((st.st_mode & 8323072U) == 131072U);
#line 77
      size = 1024U;
#line 83
      if ((st.st_mode & 8323072U) == 524288U && (unsigned int )fp->_seek == (unsigned int )(& __sseek)) {
#line 85
        fp->_flags = (short )((int )fp->_flags | 1024);
#line 89
        fp->_blksize = 1024;
      } else {
#line 93
        fp->_flags = (short )((int )fp->_flags | 2048);
      }
    }
  }
#line 95
  p = _malloc_r(ptr, size);
#line 95
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 97
    if (! ((int )fp->_flags & 512)) {
#line 99
      fp->_flags = (short )((int )fp->_flags | 2);
#line 100
      __cil_tmp___1 = fp->_nbuf;
#line 100
      fp->_p = __cil_tmp___1;
#line 100
      fp->_bf._base = __cil_tmp___1;
#line 101
      fp->_bf._size = 1;
    }
  } else {
#line 106
    ptr->__cleanup = & _cleanup_r;
#line 107
    fp->_flags = (short )((int )fp->_flags | 128);
#line 108
    __cil_tmp___2 = (unsigned char *)p;
#line 108
    fp->_p = __cil_tmp___2;
#line 108
    fp->_bf._base = __cil_tmp___2;
#line 109
    fp->_bf._size = (int )size;
#line 110
    if (couldbetty) {
#line 110
      __cil_tmp___3 = isatty((int )fp->_file);
#line 110
      if (__cil_tmp___3) {
#line 111
        fp->_flags = (short )((int )fp->_flags | 1);
      }
    }
  }
#line 113
  return;
}
}
#line 1 "lib_a-malign.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5e6r78Q4.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-malignr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-6A0A6RAr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mallinfor.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-tJq0XyO9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-malloc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jHoPY6pq.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mallocr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Ncdvp1bk.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-malloptr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Pv7ffW8j.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mallstatsr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-HgJOk9oS.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mblen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NMZVCGiA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mblen_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1JaUwmls.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mbrlen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cSQNpYpS.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mbrtowc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ZH0bjwcL.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 10 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mbrtowc.c"
size_t _mbrtowc_r(struct _reent *ptr , wchar_t *pwc , char const   *s , size_t n ,
                  mbstate_t *ps ) 
{ int retval ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 18
  retval = 0;
#line 28
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 29
    __cil_tmp = __locale_charset();
#line 29
    retval = (*__mbtowc)(ptr, (wchar_t *)((void *)0), "", 1U, (char const   *)__cil_tmp,
                         ps);
  } else {
#line 31
    __cil_tmp___0 = __locale_charset();
#line 31
    retval = (*__mbtowc)(ptr, pwc, s, n, (char const   *)__cil_tmp___0, ps);
  }
#line 33
  if (retval == -1) {
#line 35
    ps->__count = 0;
#line 36
    ptr->_errno = 138;
#line 37
    return (4294967295U);
  } else {
#line 40
    return ((unsigned int )retval);
  }
}
}
#line 1 "lib_a-mbsinit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-L6LYAATi.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mbsnrtowcs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jVmaj07t.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mbsrtowcs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-JSoetWyR.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mbstowcs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1sHCRNM5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mbstowcs_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-oddn8EaL.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mbtowc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-r7HI1vQE.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mbtowc_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-XrqdfXgV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 35 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/local.h"
int __ascii_mbtowc(struct _reent *r , wchar_t *pwc , char const   *s , size_t n ,
                   char const   *charset , mbstate_t *state ) ;
#line 10 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mbtowc_r.c"
int (*__mbtowc)(struct _reent * , wchar_t * , char const   * , size_t  , char const   * ,
                mbstate_t * )  =    & __ascii_mbtowc;
#line 30 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mbtowc_r.c"
int __ascii_mbtowc(struct _reent *r , wchar_t *pwc , char const   *s , size_t n ,
                   char const   *charset , mbstate_t *state ) 
{ wchar_t dummy ;
  unsigned char *t ;

  {
#line 40
  t = (unsigned char *)s;
#line 42
  if ((unsigned int )pwc == (unsigned int )((void *)0)) {
#line 43
    pwc = & dummy;
  }
#line 45
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 46
    return (0);
  }
#line 48
  if (n == 0U) {
#line 49
    return (-2);
  }
#line 59
  *pwc = (short )*t;
#line 61
  if ((int )*t == 0) {
#line 62
    return (0);
  }
#line 64
  return (1);
}
}
#line 1 "lib_a-memccpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-BpZ2NEOB.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-memchr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5ovzCQbU.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 71 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/memchr.c"
void *memchr(void const   *src_void , int c , size_t length ) 
{ unsigned char const   *src ;
  unsigned char d ;
  size_t __cil_tmp ;

  {
#line 77
  src = (unsigned char const   *)src_void;
#line 78
  d = (unsigned char )c;
#line 126
  while (1) {
#line 126
    __cil_tmp = length;
#line 126
    length --;
#line 126
    if (! __cil_tmp) {
#line 126
      break;
    }
#line 128
    if ((int const   )*src == (int const   )d) {
#line 129
      return ((void *)src);
    }
#line 130
    src ++;
  }
#line 133
  return ((void *)0);
}
}
#line 1 "lib_a-memcmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-OWdCSiRt.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 52 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/memcmp.c"
int memcmp(void const   *m1 , void const   *m2 , size_t n ) 
{ unsigned char *s1___0 ;
  unsigned char *s2___0 ;
  size_t __cil_tmp ;

  {
#line 59
  s1___0 = (unsigned char *)m1;
#line 60
  s2___0 = (unsigned char *)m2;
#line 62
  while (1) {
#line 62
    __cil_tmp = n;
#line 62
    n --;
#line 62
    if (! __cil_tmp) {
#line 62
      break;
    }
#line 64
    if ((int )*s1___0 != (int )*s2___0) {
#line 66
      return ((int )*s1___0 - (int )*s2___0);
    }
#line 68
    s1___0 ++;
#line 69
    s2___0 ++;
  }
#line 71
  return (0);
}
}
#line 1 "lib_a-memcpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-h15Afh8P.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 52 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/memcpy.c"
void *memcpy(void *dst0 , void const   *src0 , size_t len0 ) 
{ char *dst ;
  char *src ;
  void *save ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 59
  dst = (char *)dst0;
#line 60
  src = (char *)src0;
#line 62
  save = dst0;
#line 64
  while (1) {
#line 64
    __cil_tmp___1 = len0;
#line 64
    len0 --;
#line 64
    if (! __cil_tmp___1) {
#line 64
      break;
    }
#line 66
    __cil_tmp = dst;
#line 66
    dst ++;
#line 66
    __cil_tmp___0 = src;
#line 66
    src ++;
#line 66
    *__cil_tmp = *__cil_tmp___0;
  }
#line 69
  return (save);
}
}
#line 1 "lib_a-memmem.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-YtnpC3bd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-memmove.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-BMuxrhac.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 57 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/memmove.c"
void *memmove(void *dst_void , void const   *src_void , size_t length ) 
{ char *dst ;
  char const   *src ;
  size_t __cil_tmp ;
  char *__cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 64
  dst = (char *)dst_void;
#line 65
  src = (char const   *)src_void;
#line 67
  if ((unsigned int )src < (unsigned int )dst && (unsigned int )dst < (unsigned int )(src + length)) {
#line 70
    src += length;
#line 71
    dst += length;
#line 72
    while (1) {
#line 72
      __cil_tmp = length;
#line 72
      length --;
#line 72
      if (! __cil_tmp) {
#line 72
        break;
      }
#line 74
      dst --;
#line 74
      src --;
#line 74
      *dst = (char )*src;
    }
  } else {
#line 79
    while (1) {
#line 79
      __cil_tmp___2 = length;
#line 79
      length --;
#line 79
      if (! __cil_tmp___2) {
#line 79
        break;
      }
#line 81
      __cil_tmp___0 = dst;
#line 81
      dst ++;
#line 81
      __cil_tmp___1 = src;
#line 81
      src ++;
#line 81
      *__cil_tmp___0 = (char )*__cil_tmp___1;
    }
  }
#line 85
  return (dst_void);
}
}
#line 1 "lib_a-mempcpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ClEZVCuQ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-memset.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-6NtHBujr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 42 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/memset.c"
void *memset(void *m , int c , size_t n ) 
{ char *s ;
  char *__cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 48
  s = (char *)m;
#line 98
  while (1) {
#line 98
    __cil_tmp___0 = n;
#line 98
    n --;
#line 98
    if (! __cil_tmp___0) {
#line 98
      break;
    }
#line 99
    __cil_tmp = s;
#line 99
    s ++;
#line 99
    *__cil_tmp = (char )c;
  }
#line 101
  return (m);
}
}
#line 1 "lib_a-mkdirr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lCWrm4Xq.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mktemp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-tAjlcAej.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mktime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-AA9cdZ3l.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mktm_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-I0cHNwE4.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mlock.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-QmUFVg3b.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mprec.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lWADV6jF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 209 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern void *_calloc_r(struct _reent * , size_t  , size_t  ) ;
#line 383 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.h"
double __ulp(double _x ) ;
#line 384
double __b2d(_Bigint *a , int *e ) ;
#line 388
_Bigint *__s2b(struct _reent *ptr , char const   *s , int nd0 , int nd , __ULong y9 ) ;
#line 393
int __lo0bits(__ULong *y ) ;
#line 399
double __ratio(_Bigint *a , _Bigint *b ) ;
#line 401
void __copybits(__ULong *c , int n , _Bigint *b ) ;
#line 96 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *_Balloc(struct _reent *ptr , int k ) 
{ int x ;
  _Bigint *rv ;
  struct _reent *_r ;
  void *__cil_tmp ;
  struct _reent *_r___0 ;
  struct _Bigint *__cil_tmp___0 ;
  void *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 102
  while (1) {
#line 102
    _r = ptr;
#line 102
    if ((unsigned int )_r->_mp == (unsigned int )((void *)0)) {
#line 102
      __cil_tmp = malloc((unsigned int )sizeof(*(ptr->_mp)));
#line 102
      _r->_mp = (struct _mprec *)__cil_tmp;
#line 102
      while (1) {
#line 102
        _r___0 = ptr;
#line 102
        (_r___0->_mp)->_result_k = 0;
#line 102
        __cil_tmp___0 = (struct _Bigint *)0;
#line 102
        (_r___0->_mp)->_p5s = __cil_tmp___0;
#line 102
        (_r___0->_mp)->_result = __cil_tmp___0;
#line 102
        (_r___0->_mp)->_freelist = (struct _Bigint **)0;
#line 102
        break;
      }
    }
#line 102
    break;
  }
#line 103
  if ((unsigned int )(ptr->_mp)->_freelist == (unsigned int )((void *)0)) {
#line 106
    __cil_tmp___1 = _calloc_r(ptr, (unsigned int )sizeof(struct _Bigint *), (unsigned int )((sizeof(size_t ) << 3) + 1UL));
#line 106
    (ptr->_mp)->_freelist = (struct _Bigint **)__cil_tmp___1;
#line 109
    if ((unsigned int )(ptr->_mp)->_freelist == (unsigned int )((void *)0)) {
#line 111
      return ((_Bigint *)((void *)0));
    }
  }
#line 115
  rv = *((ptr->_mp)->_freelist + k);
#line 115
  if ((unsigned int )rv != (unsigned int )((_Bigint *)0)) {
#line 117
    *((ptr->_mp)->_freelist + k) = rv->_next;
  } else {
#line 121
    x = 1 << k;
#line 123
    __cil_tmp___2 = _calloc_r(ptr, 1U, (unsigned int )(sizeof(_Bigint ) + (unsigned long )(x - 1) * sizeof(rv->_x)));
#line 123
    rv = (_Bigint *)__cil_tmp___2;
#line 127
    if ((unsigned int )rv == (unsigned int )((void *)0)) {
#line 127
      return ((_Bigint *)((void *)0));
    }
#line 128
    rv->_k = k;
#line 129
    rv->_maxwds = x;
  }
#line 131
  __cil_tmp___3 = 0;
#line 131
  rv->_wds = __cil_tmp___3;
#line 131
  rv->_sign = __cil_tmp___3;
#line 132
  return (rv);
}
}
#line 135 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
void _Bfree(struct _reent *ptr , _Bigint *v ) 
{ struct _reent *_r ;
  void *__cil_tmp ;
  struct _reent *_r___0 ;
  struct _Bigint *__cil_tmp___0 ;

  {
#line 138
  while (1) {
#line 138
    _r = ptr;
#line 138
    if ((unsigned int )_r->_mp == (unsigned int )((void *)0)) {
#line 138
      __cil_tmp = malloc((unsigned int )sizeof(*(ptr->_mp)));
#line 138
      _r->_mp = (struct _mprec *)__cil_tmp;
#line 138
      while (1) {
#line 138
        _r___0 = ptr;
#line 138
        (_r___0->_mp)->_result_k = 0;
#line 138
        __cil_tmp___0 = (struct _Bigint *)0;
#line 138
        (_r___0->_mp)->_p5s = __cil_tmp___0;
#line 138
        (_r___0->_mp)->_result = __cil_tmp___0;
#line 138
        (_r___0->_mp)->_freelist = (struct _Bigint **)0;
#line 138
        break;
      }
    }
#line 138
    break;
  }
#line 139
  if (v) {
#line 141
    v->_next = *((ptr->_mp)->_freelist + v->_k);
#line 142
    *((ptr->_mp)->_freelist + v->_k) = v;
  }
#line 144
  return;
}
}
#line 146 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *__multadd(struct _reent *ptr , _Bigint *b , int m , int a ) 
{ int i ;
  int wds ;
  __ULong *x ;
  __ULong y ;
  __ULong xi ;
  __ULong z ;
  _Bigint *b1 ;
  __ULong *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 160
  wds = b->_wds;
#line 161
  x = b->_x;
#line 162
  i = 0;
#line 163
  while (1) {
#line 166
    xi = *x;
#line 167
    y = (xi & 65535UL) * (unsigned long )m + (unsigned long )a;
#line 168
    z = (xi >> 16) * (unsigned long )m + (y >> 16);
#line 169
    a = (int )(z >> 16);
#line 170
    __cil_tmp = x;
#line 170
    x ++;
#line 170
    *__cil_tmp = (z << 16) + (y & 65535UL);
#line 163
    i ++;
#line 163
    if (! (i < wds)) {
#line 163
      break;
    }
  }
#line 178
  if (a) {
#line 180
    if (wds >= b->_maxwds) {
#line 182
      b1 = _Balloc(ptr, b->_k + 1);
#line 183
      memcpy((void *)((char *)(& b1->_sign)), (void const   *)((char *)(& b->_sign)),
             (unsigned int )((unsigned long )b->_wds * sizeof(long ) + 2UL * sizeof(int )));
#line 184
      _Bfree(ptr, b);
#line 185
      b = b1;
    }
#line 187
    __cil_tmp___0 = wds;
#line 187
    wds ++;
#line 187
    b->_x[__cil_tmp___0] = (unsigned long )a;
#line 188
    b->_wds = wds;
  }
#line 190
  return (b);
}
}
#line 193 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *__s2b(struct _reent *ptr , char const   *s , int nd0 , int nd , __ULong y9 ) 
{ _Bigint *b ;
  int i ;
  int k ;
  long x ;
  long y ;
  char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;

  {
#line 205
  x = (long )((nd + 8) / 9);
#line 206
  k = 0;
#line 206
  y = 1L;
#line 206
  while (x > y) {
#line 206
    y <<= 1;
#line 206
    k ++;
  }
#line 208
  b = _Balloc(ptr, k);
#line 209
  b->_x[0] = y9;
#line 210
  b->_wds = 1;
#line 217
  i = 9;
#line 218
  if (9 < nd0) {
#line 220
    s += 9;
#line 221
    while (1) {
#line 222
      __cil_tmp = s;
#line 222
      s ++;
#line 222
      b = __multadd(ptr, b, 10, (int )((int const   )*__cil_tmp - 48));
#line 221
      i ++;
#line 221
      if (! (i < nd0)) {
#line 221
        break;
      }
    }
#line 224
    s ++;
  } else {
#line 227
    s += 10;
  }
#line 228
  while (i < nd) {
#line 229
    __cil_tmp___0 = s;
#line 229
    s ++;
#line 229
    b = __multadd(ptr, b, 10, (int )((int const   )*__cil_tmp___0 - 48));
#line 228
    i ++;
  }
#line 230
  return (b);
}
}
#line 233 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
int __hi0bits(__ULong x ) 
{ register int k ;

  {
#line 237
  k = 0;
#line 239
  if (! (x & 4294901760UL)) {
#line 241
    k = 16;
#line 242
    x <<= 16;
  }
#line 244
  if (! (x & 4278190080UL)) {
#line 246
    k += 8;
#line 247
    x <<= 8;
  }
#line 249
  if (! (x & 4026531840UL)) {
#line 251
    k += 4;
#line 252
    x <<= 4;
  }
#line 254
  if (! (x & 3221225472UL)) {
#line 256
    k += 2;
#line 257
    x <<= 2;
  }
#line 259
  if (! (x & 2147483648UL)) {
#line 261
    k ++;
#line 262
    if (! (x & 1073741824UL)) {
#line 263
      return (32);
    }
  }
#line 265
  return (k);
}
}
#line 268 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
int __lo0bits(__ULong *y ) 
{ register int k ;
  register __ULong x ;

  {
#line 272
  x = *y;
#line 274
  if (x & 7UL) {
#line 276
    if (x & 1UL) {
#line 277
      return (0);
    }
#line 278
    if (x & 2UL) {
#line 280
      *y = x >> 1;
#line 281
      return (1);
    }
#line 283
    *y = x >> 2;
#line 284
    return (2);
  }
#line 286
  k = 0;
#line 287
  if (! (x & 65535UL)) {
#line 289
    k = 16;
#line 290
    x >>= 16;
  }
#line 292
  if (! (x & 255UL)) {
#line 294
    k += 8;
#line 295
    x >>= 8;
  }
#line 297
  if (! (x & 15UL)) {
#line 299
    k += 4;
#line 300
    x >>= 4;
  }
#line 302
  if (! (x & 3UL)) {
#line 304
    k += 2;
#line 305
    x >>= 2;
  }
#line 307
  if (! (x & 1UL)) {
#line 309
    k ++;
#line 310
    x >>= 1;
#line 311
    if (! x & 1) {
#line 312
      return (32);
    }
  }
#line 314
  *y = x;
#line 315
  return (k);
}
}
#line 318 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *__i2b(struct _reent *ptr , int i ) 
{ _Bigint *b ;

  {
#line 323
  b = _Balloc(ptr, 1);
#line 324
  b->_x[0] = (unsigned long )i;
#line 325
  b->_wds = 1;
#line 326
  return (b);
}
}
#line 329 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *__multiply(struct _reent *ptr , _Bigint *a , _Bigint *b ) 
{ _Bigint *c ;
  int k ;
  int wa ;
  int wb ;
  int wc ;
  __ULong carry ;
  __ULong y ;
  __ULong z ;
  __ULong *x ;
  __ULong *xa ;
  __ULong *xae ;
  __ULong *xb ;
  __ULong *xbe ;
  __ULong *xc ;
  __ULong *xc0 ;
  __ULong z2 ;
  __ULong *__cil_tmp ;
  __ULong *__cil_tmp___0 ;
  __ULong *__cil_tmp___1 ;
  __ULong *__cil_tmp___2 ;

  {
#line 340
  if (a->_wds < b->_wds) {
#line 342
    c = a;
#line 343
    a = b;
#line 344
    b = c;
  }
#line 346
  k = a->_k;
#line 347
  wa = a->_wds;
#line 348
  wb = b->_wds;
#line 349
  wc = wa + wb;
#line 350
  if (wc > a->_maxwds) {
#line 351
    k ++;
  }
#line 352
  c = _Balloc(ptr, k);
#line 353
  x = c->_x;
#line 353
  xa = x + wc;
#line 353
  while ((unsigned int )x < (unsigned int )xa) {
#line 354
    *x = 0UL;
#line 353
    x ++;
  }
#line 355
  xa = a->_x;
#line 356
  xae = xa + wa;
#line 357
  xb = b->_x;
#line 358
  xbe = xb + wb;
#line 359
  xc0 = c->_x;
#line 361
  while ((unsigned int )xb < (unsigned int )xbe) {
#line 363
    y = *xb & 65535UL;
#line 363
    if (y != 0UL) {
#line 365
      x = xa;
#line 366
      xc = xc0;
#line 367
      carry = 0UL;
#line 368
      while (1) {
#line 370
        z = ((*x & 65535UL) * y + (*xc & 65535UL)) + carry;
#line 371
        carry = z >> 16;
#line 372
        __cil_tmp = x;
#line 372
        x ++;
#line 372
        z2 = ((*__cil_tmp >> 16) * y + (*xc >> 16)) + carry;
#line 373
        carry = z2 >> 16;
#line 374
        __cil_tmp___0 = xc;
#line 374
        xc ++;
#line 374
        *__cil_tmp___0 = (z2 << 16) | (z & 65535UL);
#line 368
        if (! ((unsigned int )x < (unsigned int )xae)) {
#line 368
          break;
        }
      }
#line 377
      *xc = carry;
    }
#line 379
    y = *xb >> 16;
#line 379
    if (y != 0UL) {
#line 381
      x = xa;
#line 382
      xc = xc0;
#line 383
      carry = 0UL;
#line 384
      z2 = *xc;
#line 385
      while (1) {
#line 387
        z = ((*x & 65535UL) * y + (*xc >> 16)) + carry;
#line 388
        carry = z >> 16;
#line 389
        __cil_tmp___1 = xc;
#line 389
        xc ++;
#line 389
        *__cil_tmp___1 = (z << 16) | (z2 & 65535UL);
#line 390
        __cil_tmp___2 = x;
#line 390
        x ++;
#line 390
        z2 = ((*__cil_tmp___2 >> 16) * y + (*xc & 65535UL)) + carry;
#line 391
        carry = z2 >> 16;
#line 385
        if (! ((unsigned int )x < (unsigned int )xae)) {
#line 385
          break;
        }
      }
#line 394
      *xc = z2;
    }
#line 361
    xb ++;
#line 361
    xc0 ++;
  }
#line 416
  xc0 = c->_x;
#line 416
  xc = xc0 + wc;
#line 416
  while (1) {
#line 416
    if (wc > 0) {
#line 416
      xc --;
#line 416
      if (*xc) {
#line 416
        break;
      }
    } else {
#line 416
      break;
    }
#line 416
    wc --;
  }
#line 417
  c->_wds = wc;
#line 418
  return (c);
}
}
#line 427 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
static int const   p05[3]  = {      (int const   )5,      (int const   )25,      (int const   )125};
#line 421 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *__pow5mult(struct _reent *ptr , _Bigint *b , int k ) 
{ _Bigint *b1 ;
  _Bigint *p5 ;
  _Bigint *p51 ;
  int i ;
  struct _reent *_r ;
  void *__cil_tmp ;
  struct _reent *_r___0 ;
  struct _Bigint *__cil_tmp___0 ;
  struct _Bigint *__cil_tmp___1 ;
  struct _Bigint *__cil_tmp___2 ;

  {
#line 429
  i = k & 3;
#line 429
  if (i != 0) {
#line 430
    b = __multadd(ptr, b, (int )p05[i - 1], 0);
  }
#line 432
  k >>= 2;
#line 432
  if (! k) {
#line 433
    return (b);
  }
#line 434
  while (1) {
#line 434
    _r = ptr;
#line 434
    if ((unsigned int )_r->_mp == (unsigned int )((void *)0)) {
#line 434
      __cil_tmp = malloc((unsigned int )sizeof(*(ptr->_mp)));
#line 434
      _r->_mp = (struct _mprec *)__cil_tmp;
#line 434
      while (1) {
#line 434
        _r___0 = ptr;
#line 434
        (_r___0->_mp)->_result_k = 0;
#line 434
        __cil_tmp___0 = (struct _Bigint *)0;
#line 434
        (_r___0->_mp)->_p5s = __cil_tmp___0;
#line 434
        (_r___0->_mp)->_result = __cil_tmp___0;
#line 434
        (_r___0->_mp)->_freelist = (struct _Bigint **)0;
#line 434
        break;
      }
    }
#line 434
    break;
  }
#line 435
  p5 = (ptr->_mp)->_p5s;
#line 435
  if (! p5) {
#line 438
    __cil_tmp___1 = __i2b(ptr, 625);
#line 438
    (ptr->_mp)->_p5s = __cil_tmp___1;
#line 438
    p5 = __cil_tmp___1;
#line 439
    p5->_next = (struct _Bigint *)0;
  }
#line 441
  while (1) {
#line 443
    if (k & 1) {
#line 445
      b1 = __multiply(ptr, b, p5);
#line 446
      _Bfree(ptr, b);
#line 447
      b = b1;
    }
#line 449
    k >>= 1;
#line 449
    if (! k) {
#line 450
      break;
    }
#line 451
    p51 = p5->_next;
#line 451
    if (! p51) {
#line 453
      __cil_tmp___2 = __multiply(ptr, p5, p5);
#line 453
      p5->_next = __cil_tmp___2;
#line 453
      p51 = __cil_tmp___2;
#line 454
      p51->_next = (struct _Bigint *)0;
    }
#line 456
    p5 = p51;
  }
#line 458
  return (b);
}
}
#line 461 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *__lshift(struct _reent *ptr , _Bigint *b , int k ) 
{ int i ;
  int k1 ;
  int n ;
  int n1 ;
  _Bigint *b1 ;
  __ULong *x ;
  __ULong *x1 ;
  __ULong *xe ;
  __ULong z ;
  __ULong *__cil_tmp ;
  __ULong *__cil_tmp___0 ;
  __ULong *__cil_tmp___1 ;
  __ULong __cil_tmp___2 ;
  __ULong *__cil_tmp___3 ;
  __ULong *__cil_tmp___4 ;

  {
#line 469
  n = k >> 5;
#line 473
  k1 = b->_k;
#line 474
  n1 = (n + b->_wds) + 1;
#line 475
  i = b->_maxwds;
#line 475
  while (n1 > i) {
#line 476
    k1 ++;
#line 475
    i <<= 1;
  }
#line 477
  b1 = _Balloc(ptr, k1);
#line 478
  x1 = b1->_x;
#line 479
  i = 0;
#line 479
  while (i < n) {
#line 480
    __cil_tmp = x1;
#line 480
    x1 ++;
#line 480
    *__cil_tmp = 0UL;
#line 479
    i ++;
  }
#line 481
  x = b->_x;
#line 482
  xe = x + b->_wds;
#line 484
  k &= 31;
#line 484
  if (k) {
#line 486
    k1 = 32 - k;
#line 487
    z = 0UL;
#line 488
    while (1) {
#line 490
      __cil_tmp___0 = x1;
#line 490
      x1 ++;
#line 490
      *__cil_tmp___0 = (*x << k) | z;
#line 491
      __cil_tmp___1 = x;
#line 491
      x ++;
#line 491
      z = *__cil_tmp___1 >> k1;
#line 488
      if (! ((unsigned int )x < (unsigned int )xe)) {
#line 488
        break;
      }
    }
#line 494
    __cil_tmp___2 = z;
#line 494
    *x1 = __cil_tmp___2;
#line 494
    if (__cil_tmp___2 != 0UL) {
#line 495
      n1 ++;
    }
  } else {
#line 513
    while (1) {
#line 514
      __cil_tmp___3 = x1;
#line 514
      x1 ++;
#line 514
      __cil_tmp___4 = x;
#line 514
      x ++;
#line 514
      *__cil_tmp___3 = *__cil_tmp___4;
#line 513
      if (! ((unsigned int )x < (unsigned int )xe)) {
#line 513
        break;
      }
    }
  }
#line 516
  b1->_wds = n1 - 1;
#line 517
  _Bfree(ptr, b);
#line 518
  return (b1);
}
}
#line 521 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
int __mcmp(_Bigint *a , _Bigint *b ) 
{ __ULong *xa ;
  __ULong *xa0 ;
  __ULong *xb ;
  __ULong *xb0 ;
  int i ;
  int j ;

  {
#line 527
  i = a->_wds;
#line 528
  j = b->_wds;
#line 535
  i -= j;
#line 535
  if (i) {
#line 536
    return (i);
  }
#line 537
  xa0 = a->_x;
#line 538
  xa = xa0 + j;
#line 539
  xb0 = b->_x;
#line 540
  xb = xb0 + j;
#line 541
  while (1) {
#line 543
    xa --;
#line 543
    xb --;
#line 543
    if (*xa != *xb) {
#line 544
      return (*xa < *xb ? -1 : 1);
    }
#line 545
    if ((unsigned int )xa <= (unsigned int )xa0) {
#line 546
      break;
    }
  }
#line 548
  return (0);
}
}
#line 551 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *__mdiff(struct _reent *ptr , _Bigint *a , _Bigint *b ) 
{ _Bigint *c ;
  int i ;
  int wa ;
  int wb ;
  long borrow ;
  long y ;
  __ULong *xa ;
  __ULong *xae ;
  __ULong *xb ;
  __ULong *xbe ;
  __ULong *xc ;
  long z ;
  __ULong *__cil_tmp ;
  __ULong *__cil_tmp___0 ;
  __ULong *__cil_tmp___1 ;
  __ULong *__cil_tmp___2 ;
  __ULong *__cil_tmp___3 ;

  {
#line 563
  i = __mcmp(a, b);
#line 564
  if (! i) {
#line 566
    c = _Balloc(ptr, 0);
#line 567
    c->_wds = 1;
#line 568
    c->_x[0] = 0UL;
#line 569
    return (c);
  }
#line 571
  if (i < 0) {
#line 573
    c = a;
#line 574
    a = b;
#line 575
    b = c;
#line 576
    i = 1;
  } else {
#line 579
    i = 0;
  }
#line 580
  c = _Balloc(ptr, a->_k);
#line 581
  c->_sign = i;
#line 582
  wa = a->_wds;
#line 583
  xa = a->_x;
#line 584
  xae = xa + wa;
#line 585
  wb = b->_wds;
#line 586
  xb = b->_x;
#line 587
  xbe = xb + wb;
#line 588
  xc = c->_x;
#line 589
  borrow = 0L;
#line 591
  while (1) {
#line 593
    y = (long )(((*xa & 65535UL) - (*xb & 65535UL)) + (unsigned long )borrow);
#line 594
    borrow = y >> 16;
#line 596
    __cil_tmp = xa;
#line 596
    xa ++;
#line 596
    __cil_tmp___0 = xb;
#line 596
    xb ++;
#line 596
    z = (long )(((*__cil_tmp >> 16) - (*__cil_tmp___0 >> 16)) + (unsigned long )borrow);
#line 597
    borrow = z >> 16;
#line 599
    __cil_tmp___1 = xc;
#line 599
    xc ++;
#line 599
    *__cil_tmp___1 = (unsigned long )((z << 16) | (y & 65535L));
#line 591
    if (! ((unsigned int )xb < (unsigned int )xbe)) {
#line 591
      break;
    }
  }
#line 602
  while ((unsigned int )xa < (unsigned int )xae) {
#line 604
    y = (long )((*xa & 65535UL) + (unsigned long )borrow);
#line 605
    borrow = y >> 16;
#line 607
    __cil_tmp___2 = xa;
#line 607
    xa ++;
#line 607
    z = (long )((*__cil_tmp___2 >> 16) + (unsigned long )borrow);
#line 608
    borrow = z >> 16;
#line 610
    __cil_tmp___3 = xc;
#line 610
    xc ++;
#line 610
    *__cil_tmp___3 = (unsigned long )((z << 16) | (y & 65535L));
  }
#line 629
  while (1) {
#line 629
    xc --;
#line 629
    if (*xc) {
#line 629
      break;
    }
#line 630
    wa --;
  }
#line 631
  c->_wds = wa;
#line 632
  return (c);
}
}
#line 635 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
double __ulp(double _x ) 
{ union double_union x ;
  union double_union a ;
  register long L ;

  {
#line 641
  x.d = _x;
#line 643
  L = (long )((x.i[1] & 2146435072U) - 54525952U);
#line 645
  if (L > 0L) {
#line 651
    a.i[1] = (unsigned int )L;
#line 653
    a.i[0] = 0U;
  } else {
#line 660
    L = - L >> 20;
#line 661
    if (L < 20L) {
#line 663
      a.i[1] = (unsigned int )(524288 >> L);
#line 665
      a.i[0] = 0U;
    } else {
#line 670
      a.i[1] = 0U;
#line 671
      L -= 20L;
#line 673
      a.i[0] = (unsigned int )(L >= 31L ? 1 : 1 << (31L - L));
    }
  }
#line 678
  return (a.d);
}
}
#line 681 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
double __b2d(_Bigint *a , int *e ) 
{ __ULong *xa ;
  __ULong *xa0 ;
  __ULong w ;
  __ULong y ;
  __ULong z ;
  int k ;
  union double_union d ;

  {
#line 695
  xa0 = a->_x;
#line 696
  xa = xa0 + a->_wds;
#line 697
  xa --;
#line 697
  y = *xa;
#line 702
  k = __hi0bits(y);
#line 703
  *e = 32 - k;
#line 705
  if (k < 11) {
#line 707
    d.i[1] = (unsigned int )(1072693248UL | (y >> (11 - k)));
#line 708
    if ((unsigned int )xa > (unsigned int )xa0) {
#line 708
      xa --;
#line 708
      w = *xa;
    } else {
#line 708
      w = 0UL;
    }
#line 710
    d.i[0] = (unsigned int )((y << (21 + k)) | (w >> (11 - k)));
#line 712
    goto ret_d;
  }
#line 714
  if ((unsigned int )xa > (unsigned int )xa0) {
#line 714
    xa --;
#line 714
    z = *xa;
  } else {
#line 714
    z = 0UL;
  }
#line 715
  k -= 11;
#line 715
  if (k) {
#line 717
    d.i[1] = (unsigned int )((1072693248UL | (y << k)) | (z >> (32 - k)));
#line 718
    if ((unsigned int )xa > (unsigned int )xa0) {
#line 718
      xa --;
#line 718
      y = *xa;
    } else {
#line 718
      y = 0UL;
    }
#line 720
    d.i[0] = (unsigned int )((z << k) | (y >> (32 - k)));
  } else {
#line 725
    d.i[1] = (unsigned int )(1072693248UL | y);
#line 727
    d.i[0] = (unsigned int )z;
  }
  ret_d: 
#line 755
  return (d.d);
}
}
#line 758 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
_Bigint *__d2b(struct _reent *ptr , double _d , int *e , int *bits ) 
{ union double_union d ;
  _Bigint *b ;
  int de ;
  int i ;
  int k ;
  __ULong *x ;
  __ULong y ;
  __ULong z ;
  int __cil_tmp ;
  __ULong __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 774
  d.d = _d;
#line 781
  d.d = _d;
#line 785
  b = _Balloc(ptr, 1);
#line 789
  x = b->_x;
#line 791
  z = (unsigned long )(d.i[1] & 1048575U);
#line 792
  d.i[1] &= 2147483647U;
#line 799
  de = (int )(d.i[1] >> 20);
#line 799
  if (de != 0) {
#line 800
    z |= 1048576UL;
  }
#line 804
  if (d.i[0]) {
#line 806
    y = (unsigned long )d.i[0];
#line 807
    k = __lo0bits(& y);
#line 808
    if (k) {
#line 810
      *(x + 0) = y | (z << (32 - k));
#line 811
      z >>= k;
    } else {
#line 814
      *(x + 0) = y;
    }
#line 815
    __cil_tmp___0 = z;
#line 815
    *(x + 1) = __cil_tmp___0;
#line 815
    __cil_tmp = __cil_tmp___0 ? 2 : 1;
#line 815
    b->_wds = __cil_tmp;
#line 815
    i = __cil_tmp;
  } else {
#line 824
    k = __lo0bits(& z);
#line 825
    *(x + 0) = z;
#line 826
    __cil_tmp___1 = 1;
#line 826
    b->_wds = __cil_tmp___1;
#line 826
    i = __cil_tmp___1;
#line 828
    k += 32;
  }
#line 886
  if (de) {
#line 893
    *e = ((de - 1023) - 52) + k;
#line 894
    *bits = 53 - k;
  } else {
#line 900
    *e = (((de - 1023) - 52) + 1) + k;
#line 902
    __cil_tmp___2 = __hi0bits(*(x + (i - 1)));
#line 902
    *bits = 32 * i - __cil_tmp___2;
  }
#line 908
  return (b);
}
}
#line 913 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
double __ratio(_Bigint *a , _Bigint *b ) 
{ union double_union da ;
  union double_union db ;
  int k ;
  int ka ;
  int kb ;

  {
#line 920
  da.d = __b2d(a, & ka);
#line 921
  db.d = __b2d(b, & kb);
#line 923
  k = (ka - kb) + 32 * (a->_wds - b->_wds);
#line 942
  if (k > 0) {
#line 943
    da.i[1] += (unsigned int )k * 1048576U;
  } else {
#line 946
    k = - k;
#line 947
    db.i[1] += (unsigned int )k * 1048576U;
  }
#line 950
  return (da.d / db.d);
}
}
#line 954 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
double const   __mprec_tens[25]  = 
#line 954
  {      (double const   )1e0,      (double const   )1e1,      (double const   )1e2,      (double const   )1e3, 
        (double const   )1e4,      (double const   )1e5,      (double const   )1e6,      (double const   )1e7, 
        (double const   )1e8,      (double const   )1e9,      (double const   )1e10,      (double const   )1e11, 
        (double const   )1e12,      (double const   )1e13,      (double const   )1e14,      (double const   )1e15, 
        (double const   )1e16,      (double const   )1e17,      (double const   )1e18,      (double const   )1e19, 
        (double const   )1e20,      (double const   )1e21,      (double const   )1e22,      (double const   )1e23, 
        (double const   )1e24};
#line 964 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
double const   __mprec_bigtens[5]  = {      (double const   )1e16,      (double const   )1e32,      (double const   )1e64,      (double const   )1e128, 
        (double const   )1e256};
#line 993 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
void __copybits(__ULong *c , int n , _Bigint *b ) 
{ __ULong *ce ;
  __ULong *x ;
  __ULong *xe ;
  __ULong *__cil_tmp ;
  __ULong *__cil_tmp___0 ;
  __ULong *__cil_tmp___1 ;

  {
#line 1004
  ce = (c + ((n - 1) >> 5)) + 1;
#line 1005
  x = b->_x;
#line 1007
  xe = x + b->_wds;
#line 1008
  while ((unsigned int )x < (unsigned int )xe) {
#line 1009
    __cil_tmp = c;
#line 1009
    c ++;
#line 1009
    __cil_tmp___0 = x;
#line 1009
    x ++;
#line 1009
    *__cil_tmp = *__cil_tmp___0;
  }
#line 1018
  while ((unsigned int )c < (unsigned int )ce) {
#line 1019
    __cil_tmp___1 = c;
#line 1019
    c ++;
#line 1019
    *__cil_tmp___1 = 0UL;
  }
#line 1020
  return;
}
}
#line 1022 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/mprec.c"
__ULong __any_on(_Bigint *b , int k ) 
{ int n ;
  int nwds ;
  __ULong *x ;
  __ULong *x0 ;
  __ULong x1 ;
  __ULong x2 ;

  {
#line 1030
  x = b->_x;
#line 1031
  nwds = b->_wds;
#line 1032
  n = k >> 5;
#line 1033
  if (n > nwds) {
#line 1034
    n = nwds;
  } else
#line 1035
  if (n < nwds) {
#line 1035
    k &= 31;
#line 1035
    if (k) {
#line 1036
      x2 = *(x + n);
#line 1036
      x1 = x2;
#line 1037
      x1 >>= k;
#line 1038
      x1 <<= k;
#line 1039
      if (x1 != x2) {
#line 1040
        return (1UL);
      }
    }
  }
#line 1042
  x0 = x;
#line 1043
  x += n;
#line 1044
  while ((unsigned int )x > (unsigned int )x0) {
#line 1045
    x --;
#line 1045
    if (*x) {
#line 1046
      return (1UL);
    }
  }
#line 1047
  return (0UL);
}
}
#line 1 "lib_a-mrand48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-UzQ5n5Xy.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-msize.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1a87JM47.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-msizer.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-kPtKClF4.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mstats.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-PPbHLWyd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-mtrim.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-HzvyooqP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-nl_langinfo.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-qgUma7xd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-nrand48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-H9nd7Dbp.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-on_exit.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ibTJCAxA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-open_memstream.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-pMazrq5B.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-opendir.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5jCXxhVX.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-openr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-nYnmhIhQ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-perror.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8iHNEXAu.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-popen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-STMjkMFP.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-printf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-UZeSAsKt.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 42 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/printf.c"
int ( /* format attribute */  printf)(char const   *fmt  , ...) 
{ int ret ;
  va_list ap ;
  struct _reent *ptr ;

  {
#line 48
  ptr = _impure_ptr;
#line 50
  while (1) {
#line 50
    if (ptr && ! ptr->__sdidinit) {
#line 50
      __sinit(ptr);
    }
#line 50
    break;
  }
#line 51
  __builtin_va_start(ap, fmt);
#line 52
  ret = _vfprintf_r(ptr, ptr->_stdout, fmt, ap);
#line 53
  __builtin_va_end(ap);
#line 54
  return (ret);
}
}
#line 1 "lib_a-putc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-eUx7ukbe.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-putc_u.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8A1f2G89.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-putchar.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-oZHBvZMY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-putchar_u.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-PRcOIHZA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-putenv.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ADpgCwhA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-putenv_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NrUIkill.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 66 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
char *_strdup_r(struct _reent *reent_ptr , char const   *str ) ;
#line 1 "lib_a-puts.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jkT94Awq.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-putw.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-qLZZVoyE.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-putwc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jSCek7yS.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-putwchar.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NcrWs7Z6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-pvallocr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-oppGNsFi.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-qsort.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hq4TZ1hI.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 84 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/search/qsort.c"
__inline static char *med3___0(char *a , char *b , char *c , int (*cmp)() ) ;
#line 85
__inline static void swapfunc___0(char *a , char *b , int n , int swaptype ) ;
#line 105 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/search/qsort.c"
__inline static void swapfunc___0(char *a , char *b , int n , int swaptype ) 
{ long i ;
  register long *pi ;
  register long *pj ;
  register long t ;
  long *__cil_tmp ;
  long *__cil_tmp___0 ;
  long i___0 ;
  register char *pi___0 ;
  register char *pj___0 ;
  register char t___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;

  {
#line 112
  if (swaptype <= 1) {
#line 113
    i = (long )((unsigned long )n / sizeof(long ));
#line 113
    pi = (long *)a;
#line 113
    pj = (long *)b;
#line 113
    while (1) {
#line 113
      t = *pi;
#line 113
      __cil_tmp = pi;
#line 113
      pi ++;
#line 113
      *__cil_tmp = *pj;
#line 113
      __cil_tmp___0 = pj;
#line 113
      pj ++;
#line 113
      *__cil_tmp___0 = t;
#line 113
      i --;
#line 113
      if (! (i > 0L)) {
#line 113
        break;
      }
    }
  } else {
#line 115
    i___0 = (long )((unsigned long )n / sizeof(char ));
#line 115
    pi___0 = a;
#line 115
    pj___0 = b;
#line 115
    while (1) {
#line 115
      t___0 = *pi___0;
#line 115
      __cil_tmp___1 = pi___0;
#line 115
      pi___0 ++;
#line 115
      *__cil_tmp___1 = *pj___0;
#line 115
      __cil_tmp___2 = pj___0;
#line 115
      pj___0 ++;
#line 115
      *__cil_tmp___2 = t___0;
#line 115
      i___0 --;
#line 115
      if (! (i___0 > 0L)) {
#line 115
        break;
      }
    }
  }
#line 116
  return;
}
}
#line 128 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/search/qsort.c"
__inline static char *med3___0(char *a , char *b , char *c , int (*cmp)() ) 
{ int __cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___5 ;
  char *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  char *__cil_tmp___8 ;
  int __cil_tmp___9 ;

  {
#line 135
  __cil_tmp___9 = (*cmp)(a, b);
#line 135
  if (__cil_tmp___9 < 0) {
#line 135
    __cil_tmp___3 = (*cmp)(b, c);
#line 135
    if (__cil_tmp___3 < 0) {
#line 135
      __cil_tmp___2 = b;
    } else {
#line 135
      __cil_tmp___1 = (*cmp)(a, c);
#line 135
      __cil_tmp___2 = __cil_tmp___1 < 0 ? c : a;
    }
#line 135
    __cil_tmp___8 = __cil_tmp___2;
  } else {
#line 135
    __cil_tmp___7 = (*cmp)(b, c);
#line 135
    if (__cil_tmp___7 > 0) {
#line 135
      __cil_tmp___6 = b;
    } else {
#line 135
      __cil_tmp___5 = (*cmp)(a, c);
#line 135
      __cil_tmp___6 = __cil_tmp___5 < 0 ? a : c;
    }
#line 135
    __cil_tmp___8 = __cil_tmp___6;
  }
#line 135
  return (__cil_tmp___8);
}
}
#line 140 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/search/qsort.c"
void qsort(void *a , size_t n , size_t es , int (*cmp)(void const   * , void const   * ) ) 
{ char *pa ;
  char *pb ;
  char *pc ;
  char *pd ;
  char *pl ;
  char *pm ;
  char *pn ;
  int d ;
  int r ;
  int swaptype ;
  int swap_cnt ;
  long t ;
  int __cil_tmp ;
  long t___0 ;
  long t___1 ;
  long t___2 ;
  long t___3 ;
  long t___4 ;
  int __cil_tmp___0 ;

  {
  loop: 
#line 150
  swaptype = 2;
#line 151
  swap_cnt = 0;
#line 152
  if (n < 7U) {
#line 153
    pm = (char *)a + es;
#line 153
    while ((unsigned int )pm < (unsigned int )((char *)a + n * es)) {
#line 154
      pl = pm;
#line 154
      while (1) {
#line 154
        if ((unsigned int )pl > (unsigned int )((char *)a)) {
#line 154
          __cil_tmp = (*cmp)((void const   *)(pl - es), (void const   *)pl);
#line 154
          if (! (__cil_tmp > 0)) {
#line 154
            break;
          }
        } else {
#line 154
          break;
        }
#line 156
        if (swaptype == 0) {
#line 156
          t = *((long *)pl);
#line 156
          *((long *)pl) = *((long *)(pl - es));
#line 156
          *((long *)(pl - es)) = t;
        } else {
#line 156
          swapfunc___0(pl, pl - es, (int )es, swaptype);
        }
#line 154
        pl -= es;
      }
#line 153
      pm += es;
    }
#line 157
    return;
  }
#line 159
  pm = (char *)a + (n / 2U) * es;
#line 160
  if (n > 7U) {
#line 161
    pl = (char *)a;
#line 162
    pn = (char *)a + (n - 1U) * es;
#line 163
    if (n > 40U) {
#line 164
      d = (int )((n / 8U) * es);
#line 165
      pl = med3___0(pl, pl + d, pl + 2 * d, (int (*)())cmp);
#line 166
      pm = med3___0(pm - d, pm, pm + d, (int (*)())cmp);
#line 167
      pn = med3___0(pn - 2 * d, pn - d, pn, (int (*)())cmp);
    }
#line 169
    pm = med3___0(pl, pm, pn, (int (*)())cmp);
  }
#line 171
  if (swaptype == 0) {
#line 171
    t___0 = *((long *)a);
#line 171
    *((long *)a) = *((long *)pm);
#line 171
    *((long *)pm) = t___0;
  } else {
#line 171
    swapfunc___0((char *)a, pm, (int )es, swaptype);
  }
#line 172
  pb = (char *)a + es;
#line 172
  pa = pb;
#line 174
  pd = (char *)a + (n - 1U) * es;
#line 174
  pc = pd;
#line 175
  while (1) {
#line 176
    while (1) {
#line 176
      if ((unsigned int )pb <= (unsigned int )pc) {
#line 176
        r = (*cmp)((void const   *)pb, (void const   *)a);
#line 176
        if (! (r <= 0)) {
#line 176
          break;
        }
      } else {
#line 176
        break;
      }
#line 177
      if (r == 0) {
#line 178
        swap_cnt = 1;
#line 179
        if (swaptype == 0) {
#line 179
          t___1 = *((long *)pa);
#line 179
          *((long *)pa) = *((long *)pb);
#line 179
          *((long *)pb) = t___1;
        } else {
#line 179
          swapfunc___0(pa, pb, (int )es, swaptype);
        }
#line 180
        pa += es;
      }
#line 182
      pb += es;
    }
#line 184
    while (1) {
#line 184
      if ((unsigned int )pb <= (unsigned int )pc) {
#line 184
        r = (*cmp)((void const   *)pc, (void const   *)a);
#line 184
        if (! (r >= 0)) {
#line 184
          break;
        }
      } else {
#line 184
        break;
      }
#line 185
      if (r == 0) {
#line 186
        swap_cnt = 1;
#line 187
        if (swaptype == 0) {
#line 187
          t___2 = *((long *)pc);
#line 187
          *((long *)pc) = *((long *)pd);
#line 187
          *((long *)pd) = t___2;
        } else {
#line 187
          swapfunc___0(pc, pd, (int )es, swaptype);
        }
#line 188
        pd -= es;
      }
#line 190
      pc -= es;
    }
#line 192
    if ((unsigned int )pb > (unsigned int )pc) {
#line 193
      break;
    }
#line 194
    if (swaptype == 0) {
#line 194
      t___3 = *((long *)pb);
#line 194
      *((long *)pb) = *((long *)pc);
#line 194
      *((long *)pc) = t___3;
    } else {
#line 194
      swapfunc___0(pb, pc, (int )es, swaptype);
    }
#line 195
    swap_cnt = 1;
#line 196
    pb += es;
#line 197
    pc -= es;
  }
#line 199
  if (swap_cnt == 0) {
#line 200
    pm = (char *)a + es;
#line 200
    while ((unsigned int )pm < (unsigned int )((char *)a + n * es)) {
#line 201
      pl = pm;
#line 201
      while (1) {
#line 201
        if ((unsigned int )pl > (unsigned int )((char *)a)) {
#line 201
          __cil_tmp___0 = (*cmp)((void const   *)(pl - es), (void const   *)pl);
#line 201
          if (! (__cil_tmp___0 > 0)) {
#line 201
            break;
          }
        } else {
#line 201
          break;
        }
#line 203
        if (swaptype == 0) {
#line 203
          t___4 = *((long *)pl);
#line 203
          *((long *)pl) = *((long *)(pl - es));
#line 203
          *((long *)(pl - es)) = t___4;
        } else {
#line 203
          swapfunc___0(pl, pl - es, (int )es, swaptype);
        }
#line 201
        pl -= es;
      }
#line 200
      pm += es;
    }
#line 204
    return;
  }
#line 207
  pn = (char *)a + n * es;
#line 208
  r = pa - (char *)a < pb - pa ? pa - (char *)a : pb - pa;
#line 209
  if (r > 0) {
#line 209
    swapfunc___0((char *)a, pb - r, r, swaptype);
  }
#line 210
  r = (int )((unsigned int )(pd - pc) < (unsigned int )(pn - pd) - es ? (unsigned int )(pd - pc) : (unsigned int )(pn - pd) - es);
#line 211
  if (r > 0) {
#line 211
    swapfunc___0(pb, pn - r, r, swaptype);
  }
#line 212
  r = pb - pa;
#line 212
  if ((unsigned int )r > es) {
#line 213
    qsort(a, (unsigned int )r / es, es, cmp);
  }
#line 214
  r = pd - pc;
#line 214
  if ((unsigned int )r > es) {
#line 216
    a = (void *)(pn - r);
#line 217
    n = (unsigned int )r / es;
#line 218
    goto loop;
  }
#line 221
  return;
}
}
#line 1 "lib_a-raise.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-GL0MnBhT.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-rand.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cZy91Aoh.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 79 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/rand.c"
int rand(void) 
{ struct _reent *_r ;
  void *__cil_tmp ;
  struct _reent *_r___0 ;

  {
#line 85
  while (1) {
#line 85
    _r = _impure_ptr;
#line 85
    if ((unsigned int )_r->_r48 == (unsigned int )((void *)0)) {
#line 85
      __cil_tmp = malloc((unsigned int )sizeof(*(_impure_ptr->_r48)));
#line 85
      _r->_r48 = (struct _rand48 *)__cil_tmp;
#line 85
      while (1) {
#line 85
        _r___0 = _impure_ptr;
#line 85
        (_r___0->_r48)->_seed[0] = (unsigned short)13070;
#line 85
        (_r___0->_r48)->_seed[1] = (unsigned short)43981;
#line 85
        (_r___0->_r48)->_seed[2] = (unsigned short)4660;
#line 85
        (_r___0->_r48)->_mult[0] = (unsigned short)58989;
#line 85
        (_r___0->_r48)->_mult[1] = (unsigned short)57068;
#line 85
        (_r___0->_r48)->_mult[2] = (unsigned short)5;
#line 85
        (_r___0->_r48)->_add = (unsigned short)11;
#line 85
        (_r___0->_r48)->_rand_next = 1ULL;
#line 85
        break;
      }
    }
#line 85
    break;
  }
#line 86
  (_impure_ptr->_r48)->_rand_next = (_impure_ptr->_r48)->_rand_next * 6364136223846793005ULL + 1ULL;
#line 88
  return ((int )(((_impure_ptr->_r48)->_rand_next >> 32) & 2147483647ULL));
}
}
#line 1 "lib_a-rand48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-4kYv3TDy.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-rand_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NAMZNwNU.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-readdir.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-3TsvaO2O.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-readdir_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-puSSPtK7.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-readr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-05w1zCQ8.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-realloc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-0ifGgB5d.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-reallocf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-RX0kFAVu.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-reallocr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-TalSW0Qz.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-reent.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ENpxA140.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-refill.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-0ghiOM1d.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 25 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/refill.c"
static int lflush(FILE *fp ) 
{ int __cil_tmp ;

  {
#line 29
  if (((int )fp->_flags & 9) == 9) {
#line 30
    __cil_tmp = fflush(fp);
#line 30
    return (__cil_tmp);
  }
#line 31
  return (0);
}
}
#line 39 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/refill.c"
int __srefill_r(struct _reent *ptr , FILE *fp ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 46
  while (1) {
#line 46
    if (ptr && ! ptr->__sdidinit) {
#line 46
      __sinit(ptr);
    }
#line 46
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 46
      fp = ptr->_stdin;
    } else
#line 46
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 46
      fp = ptr->_stdout;
    } else
#line 46
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 46
      fp = ptr->_stderr;
    }
#line 46
    break;
  }
#line 48
  while (1) {
#line 48
    if (! ((int )fp->_flags & 8192)) {
#line 48
      fp->_flags = (short )((int )fp->_flags | 8192);
#line 48
      fp->_flags2 &= -8193;
    }
#line 48
    break;
  }
#line 50
  fp->_r = 0;
#line 54
  if ((int )fp->_flags & 32) {
#line 55
    return (-1);
  }
#line 59
  if (((int )fp->_flags & 4) == 0) {
#line 61
    if (((int )fp->_flags & 16) == 0) {
#line 63
      ptr->_errno = 9;
#line 64
      fp->_flags = (short )((int )fp->_flags | 64);
#line 65
      return (-1);
    }
#line 68
    if ((int )fp->_flags & 8) {
#line 70
      __cil_tmp = _fflush_r(ptr, fp);
#line 70
      if (__cil_tmp) {
#line 71
        return (-1);
      }
#line 72
      fp->_flags = (short )((int )fp->_flags & -9);
#line 73
      fp->_w = 0;
#line 74
      fp->_lbfsize = 0;
    }
#line 76
    fp->_flags = (short )((int )fp->_flags | 4);
  } else
#line 86
  if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 88
    if ((unsigned int )fp->_ub._base != (unsigned int )(fp->_ubuf)) {
#line 88
      _free_r(ptr, (void *)((char *)fp->_ub._base));
    }
#line 88
    fp->_ub._base = (unsigned char *)((void *)0);
#line 89
    __cil_tmp___0 = fp->_ur;
#line 89
    fp->_r = __cil_tmp___0;
#line 89
    if (__cil_tmp___0 != 0) {
#line 91
      fp->_p = fp->_up;
#line 92
      return (0);
    }
  }
#line 97
  if ((unsigned int )fp->_bf._base == (unsigned int )((void *)0)) {
#line 98
    __smakebuf_r(ptr, fp);
  }
#line 106
  if ((int )fp->_flags & 3) {
#line 107
    _fwalk((struct _reent *)_global_impure_ptr, & lflush);
  }
#line 108
  fp->_p = fp->_bf._base;
#line 109
  fp->_r = (*(fp->_read))(ptr, fp->_cookie, (char *)fp->_p, fp->_bf._size);
#line 111
  if (fp->_r <= 0) {
#line 118
    if (fp->_r == 0) {
#line 119
      fp->_flags = (short )((int )fp->_flags | 32);
    } else {
#line 122
      fp->_r = 0;
#line 123
      fp->_flags = (short )((int )fp->_flags | 64);
    }
#line 125
    return (-1);
  }
#line 127
  return (0);
}
}
#line 1 "lib_a-regcomp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-3VKQjtjj.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-regerror.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-a0bEEpI0.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-regexec.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-s3OBQp6I.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-regfree.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-t8UXb3Hs.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-remove.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-UF4XDVuH.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-rename.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-APZZA8nw.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 422 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int _rename_r(struct _reent *ignored , char const   *old_path , char const   *new_path ) ;
#line 62 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/rename.c"
int rename(char const   *old , char const   *new ) 
{ int __cil_tmp ;

  {
#line 67
  __cil_tmp = _rename_r(_impure_ptr, old, new);
#line 67
  return (__cil_tmp);
}
}
#line 1 "lib_a-renamer.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-oOThWNs4.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-rewind.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-OAfjdtM2.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-rewinddir.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-R4f3ze2a.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-rget.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dPtu6fyL.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-rindex.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wc0hVzzr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 39 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/string.h"
char *strrchr(char const   *s , int i ) ;
#line 1 "lib_a-sb_charsets.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ktIv0Ufe.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-sbrkr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Ed4McEY0.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-scandir.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jxpX7Xk9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-scanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SUxFsHLf.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-sccl.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-QSMWhiHe.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 36 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
u_char *__sccl(char *tab , u_char *fmt ) ;
#line 33 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/sccl.c"
u_char *__sccl(char *tab , u_char *fmt ) 
{ register int c ;
  register int n ;
  register int v ;
  u_char *__cil_tmp ;
  u_char *__cil_tmp___0 ;
  u_char *__cil_tmp___1 ;

  {
#line 41
  __cil_tmp = fmt;
#line 41
  fmt ++;
#line 41
  c = (int )*__cil_tmp;
#line 42
  if (c == 94) {
#line 44
    v = 1;
#line 45
    __cil_tmp___0 = fmt;
#line 45
    fmt ++;
#line 45
    c = (int )*__cil_tmp___0;
  } else {
#line 48
    v = 0;
  }
#line 50
  n = 0;
#line 50
  while (n < 256) {
#line 51
    *(tab + n) = (char )v;
#line 50
    n ++;
  }
#line 52
  if (c == 0) {
#line 53
    return (fmt - 1);
  }
#line 63
  v = 1 - v;
#line 64
  while (1) {
#line 66
    *(tab + c) = (char )v;
    doswitch: 
#line 68
    __cil_tmp___1 = fmt;
#line 68
    fmt ++;
#line 68
    n = (int )*__cil_tmp___1;
#line 69
    switch (n) {
    case 0: 
#line 73
    return (fmt - 1);
    case 45: 
#line 88
    n = (int )*fmt;
#line 89
    if (n == 93 || n < c) {
#line 91
      c = '-';
#line 92
      break;
    }
#line 94
    fmt ++;
#line 95
    while (1) {
#line 97
      c ++;
#line 97
      *(tab + c) = (char )v;
#line 95
      if (! (c < n)) {
#line 95
        break;
      }
    }
#line 106
    goto doswitch;
#line 115
    break;
    case 93: 
#line 119
    return (fmt);
    default: 
#line 122
    c = n;
#line 123
    break;
    }
  }
}
}
#line 1 "lib_a-seed48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7DmkOEbC.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-seekdir.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-mTcSEjLm.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-setbuf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NPHnUAik.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-setbuffer.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-A7Xb9vkF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-setenv.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-PlFuU5cL.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-setenv_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-OvmwOiVC.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-setlinebuf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hgtNC2ak.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-setvbuf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ifxEypAd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-signal.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-6nJHMWAx.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 20 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/signal.h"
_sig_func_ptr _signal_r(struct _reent *ptr , int sig , void (*func)(int  ) ) ;
#line 102 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/signal/signal.c"
int _init_signal_r(struct _reent *ptr ) 
{ int i ;
  void *__cil_tmp ;

  {
#line 108
  if ((unsigned int )ptr->_sig_func == (unsigned int )((void *)0)) {
#line 110
    __cil_tmp = _malloc_r(ptr, (unsigned int )(sizeof(void (*)(int  )) * 32UL));
#line 110
    ptr->_sig_func = (_sig_func_ptr *)__cil_tmp;
#line 111
    if ((unsigned int )ptr->_sig_func == (unsigned int )((void *)0)) {
#line 112
      return (-1);
    }
#line 114
    i = 0;
#line 114
    while (i < 32) {
#line 115
      *(ptr->_sig_func + i) = (void (*)(int  ))0;
#line 114
      i ++;
    }
  }
#line 118
  return (0);
}
}
#line 121 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/signal/signal.c"
_sig_func_ptr _signal_r(struct _reent *ptr , int sig , void (*func)(int  ) ) 
{ void (*old_func)(int  ) ;
  int __cil_tmp ;

  {
#line 129
  if (sig < 0 || sig >= 32) {
#line 131
    ptr->_errno = 22;
#line 132
    return ((void (*)(int  ))-1);
  }
#line 135
  if ((unsigned int )ptr->_sig_func == (unsigned int )((void *)0)) {
#line 135
    __cil_tmp = _init_signal_r(ptr);
#line 135
    if (__cil_tmp != 0) {
#line 136
      return ((void (*)(int  ))-1);
    }
  }
#line 138
  old_func = *(ptr->_sig_func + sig);
#line 139
  *(ptr->_sig_func + sig) = func;
#line 141
  return (old_func);
}
}
#line 218 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/signal/signal.c"
_sig_func_ptr signal(int sig , void (*func)(int  ) ) 
{ void (*__cil_tmp)(int  ) ;

  {
#line 223
  __cil_tmp = _signal_r(_impure_ptr, sig, func);
#line 223
  return (__cil_tmp);
}
}
#line 1 "lib_a-signalr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-N1uamiYJ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-signgam.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8RfPx2eR.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-siprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-74827sJu.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-siscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-yCFqnra5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 60 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
int __seofread(struct _reent *_ptr , void *cookie , char *buf , int len ) ;
#line 1 "lib_a-sleep.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-02u0piJY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-sniprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-tosev0nX.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-snprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-LgUQFsVM.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 77 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/snprintf.c"
int ( /* format attribute */  snprintf)(char *str , size_t size , char const   *fmt 
                                        , ...) 
{ int ret ;
  va_list ap ;
  FILE f ;
  struct _reent *ptr ;

  {
#line 94
  ptr = _impure_ptr;
#line 96
  if (size > 2147483647U) {
#line 98
    ptr->_errno = 139;
#line 99
    return (-1);
  }
#line 101
  f._flags = (short)520;
#line 102
  f._p = (unsigned char *)str;
#line 102
  f._bf._base = f._p;
#line 103
  f._w = (int )(size > 0U ? size - 1U : 0U);
#line 103
  f._bf._size = f._w;
#line 104
  f._file = (short)-1;
#line 106
  __builtin_va_start(ap, fmt);
#line 110
  ret = _svfprintf_r(ptr, & f, fmt, ap);
#line 111
  __builtin_va_end(ap);
#line 112
  if (ret < -1) {
#line 113
    ptr->_errno = 139;
  }
#line 114
  if (size > 0U) {
#line 115
    *(f._p) = (unsigned char)0;
  }
#line 116
  return (ret);
}
}
#line 1 "lib_a-sprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-iHTg1MGV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 609 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/sprintf.c"
int sprintf(char *str , char const   *fmt  , ...) 
{ int ret ;
  va_list ap ;
  FILE f ;

  {
#line 625
  f._flags = (short)520;
#line 626
  f._p = (unsigned char *)str;
#line 626
  f._bf._base = f._p;
#line 627
  f._w = 2147483647;
#line 627
  f._bf._size = f._w;
#line 628
  f._file = (short)-1;
#line 630
  __builtin_va_start(ap, fmt);
#line 634
  ret = _svfprintf_r(_impure_ptr, & f, fmt, ap);
#line 635
  __builtin_va_end(ap);
#line 636
  *(f._p) = (unsigned char )'\000';
#line 637
  return (ret);
}
}
#line 1 "lib_a-srand48.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-pNvnmUPm.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-sscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jSoe54zu.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 38 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
int __ssvfscanf_r(struct _reent *rptr , FILE *fp , char const   *fmt0 , va_list ap ) ;
#line 400 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/sscanf.c"
int sscanf(char const   *str , char const   *fmt  , ...) 
{ int ret ;
  va_list ap ;
  FILE f ;
  size_t __cil_tmp ;

  {
#line 416
  f._flags = (short)516;
#line 417
  f._p = (unsigned char *)str;
#line 417
  f._bf._base = f._p;
#line 418
  __cil_tmp = strlen(str);
#line 418
  f._r = (int )__cil_tmp;
#line 418
  f._bf._size = f._r;
#line 419
  f._read = & __seofread;
#line 420
  f._ub._base = (unsigned char *)((void *)0);
#line 421
  f._lb._base = (unsigned char *)((void *)0);
#line 422
  f._file = (short)-1;
#line 424
  __builtin_va_start(ap, fmt);
#line 428
  ret = __ssvfscanf_r(_impure_ptr, & f, fmt, ap);
#line 429
  __builtin_va_end(ap);
#line 430
  return (ret);
}
}
#line 1 "lib_a-statr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-G7L0H083.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-stdio.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-tn55xsr6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 32 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/stdio.c"
int __sread(struct _reent *ptr , void *cookie , char *buf , int n ) 
{ register FILE *fp ;
  register int ret ;

  {
#line 39
  fp = (FILE *)cookie;
#line 48
  ret = read((int )fp->_file, (void *)buf, (unsigned int )n);
#line 57
  if (ret >= 0) {
#line 58
    fp->_offset += ret;
  } else {
#line 60
    fp->_flags = (short )((int )fp->_flags & -4097);
  }
#line 61
  return (ret);
}
}
#line 65 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/stdio.c"
int __seofread(struct _reent *_ptr , void *cookie , char *buf , int len ) 
{ 

  {
#line 72
  return (0);
}
}
#line 75 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/stdio.c"
int __swrite(struct _reent *ptr , void *cookie , char const   *buf , int n ) 
{ register FILE *fp ;
  int w ;

  {
#line 82
  fp = (FILE *)cookie;
#line 88
  if ((int )fp->_flags & 256) {
#line 89
    lseek((int )fp->_file, 0L, 2);
  }
#line 90
  fp->_flags = (short )((int )fp->_flags & -4097);
#line 97
  w = write((int )fp->_file, (void const   *)buf, (unsigned int )n);
#line 104
  return (w);
}
}
#line 107 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/stdio.c"
_fpos_t __sseek(struct _reent *ptr , void *cookie , _fpos_t offset , int whence ) 
{ register FILE *fp ;
  register _off_t ret ;

  {
#line 114
  fp = (FILE *)cookie;
#line 117
  ret = lseek((int )fp->_file, offset, whence);
#line 118
  if (ret == -1L) {
#line 119
    fp->_flags = (short )((int )fp->_flags & -4097);
  } else {
#line 122
    fp->_flags = (short )((int )fp->_flags | 4096);
#line 123
    fp->_offset = (int )ret;
  }
#line 125
  return (ret);
}
}
#line 128 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/stdio.c"
int __sclose(struct _reent *ptr , void *cookie ) 
{ FILE *fp ;
  int __cil_tmp ;

  {
#line 133
  fp = (FILE *)cookie;
#line 135
  __cil_tmp = close((int )fp->_file);
#line 135
  return (__cil_tmp);
}
}
#line 1 "lib_a-stpcpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-BI1PRvCH.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-stpncpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-JamdTgu1.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strcasecmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1VPeQe5J.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 44 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strcasecmp.c"
int strcasecmp(char const   *s1___0 , char const   *s2___0 ) 
{ unsigned char const   *ucs1 ;
  unsigned char const   *ucs2 ;
  int d ;
  int c1 ;
  unsigned char __x ;
  unsigned char const   *__cil_tmp___0 ;
  int c2 ;
  unsigned char __x___0 ;
  unsigned char const   *__cil_tmp___2 ;

  {
#line 49
  ucs1 = (unsigned char const   *)s1___0;
#line 50
  ucs2 = (unsigned char const   *)s2___0;
#line 51
  d = 0;
#line 52
  while (1) {
#line 54
    __cil_tmp___0 = ucs1;
#line 54
    ucs1 ++;
#line 54
    __x = (unsigned char )*__cil_tmp___0;
#line 54
    c1 = ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 1 ? ((int )__x - 65) + 97 : (int )__x;
#line 55
    __cil_tmp___2 = ucs2;
#line 55
    ucs2 ++;
#line 55
    __x___0 = (unsigned char )*__cil_tmp___2;
#line 55
    c2 = ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___0))) + (int )__x___0) & 3) == 1 ? ((int )__x___0 - 65) + 97 : (int )__x___0;
#line 56
    d = c1 - c2;
#line 56
    if (d != 0 || c2 == 0) {
#line 57
      break;
    }
  }
#line 59
  return (d);
}
}
#line 1 "lib_a-strcasestr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ttkHDDKB.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strcat.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SREkJWdD.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strchr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-uuqMbTAm.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 60 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strchr.c"
char *strchr(char const   *s1___0 , int i ) 
{ unsigned char const   *s ;
  unsigned char c ;

  {
#line 65
  s = (unsigned char const   *)s1___0;
#line 66
  c = (unsigned char )i;
#line 118
  while (*s && (int const   )*s != (int const   )c) {
#line 119
    s ++;
  }
#line 120
  if ((int const   )*s == (int const   )c) {
#line 121
    return ((char *)s);
  }
#line 122
  return ((char *)((void *)0));
}
}
#line 1 "lib_a-strcmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Xahg7y72.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 60 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strcmp.c"
int strcmp(char const   *s1___0 , char const   *s2___0 ) 
{ 

  {
#line 66
  while ((int const   )*s1___0 != 0 && (int const   )*s1___0 == (int const   )*s2___0) {
#line 68
    s1___0 ++;
#line 69
    s2___0 ++;
  }
#line 72
  return ((int )*((unsigned char *)s1___0) - (int )*((unsigned char *)s2___0));
}
}
#line 1 "lib_a-strcoll.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-DO616ZGY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 41 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strcoll.c"
int strcoll(char const   *a , char const   *b ) 
{ int __cil_tmp ;

  {
#line 47
  __cil_tmp = strcmp(a, b);
#line 47
  return (__cil_tmp);
}
}
#line 1 "lib_a-strcpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-MXieyjAI.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 60 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strcpy.c"
char *strcpy(char *dst0 , char const   *src0 ) 
{ char *s ;
  char *__cil_tmp ;
  char __cil_tmp___0 ;
  char const   *__cil_tmp___1 ;

  {
#line 66
  s = dst0;
#line 68
  while (1) {
#line 68
    __cil_tmp = dst0;
#line 68
    dst0 ++;
#line 68
    __cil_tmp___1 = src0;
#line 68
    src0 ++;
#line 68
    __cil_tmp___0 = (char )*__cil_tmp___1;
#line 68
    *__cil_tmp = __cil_tmp___0;
#line 68
    if (! __cil_tmp___0) {
#line 68
      break;
    }
  }
#line 71
  return (s);
}
}
#line 1 "lib_a-strcspn.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Zs1cXyWx.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strdup.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-DF5JvzUF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 7 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strdup.c"
char *strdup(char const   *str ) 
{ char *__cil_tmp ;

  {
#line 10
  __cil_tmp = _strdup_r(_impure_ptr, str);
#line 10
  return (__cil_tmp);
}
}
#line 1 "lib_a-strdup_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lhtNPQjv.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 5 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strdup_r.c"
char *_strdup_r(struct _reent *reent_ptr , char const   *str ) 
{ size_t len ;
  size_t __cil_tmp ;
  char *copy ;
  void *__cil_tmp___0 ;

  {
#line 10
  __cil_tmp = strlen(str);
#line 10
  len = __cil_tmp + 1U;
#line 11
  __cil_tmp___0 = _malloc_r(reent_ptr, len);
#line 11
  copy = (char *)__cil_tmp___0;
#line 12
  if (copy) {
#line 14
    memcpy((void *)copy, (void const   *)str, len);
  }
#line 16
  return (copy);
}
}
#line 1 "lib_a-strerror.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-pBH4oko3.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 330 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strerror.c"
char *_user_strerror(int errnum ) ;
#line 325 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strerror.c"
char *strerror(int errnum ) 
{ char *error ;

  {
#line 332
  switch (errnum) {
  case 1: 
#line 337
  error = (char *)"Not owner";
#line 338
  break;
  case 2: 
#line 342
  error = (char *)"No such file or directory";
#line 343
  break;
  case 3: 
#line 347
  error = (char *)"No such process";
#line 348
  break;
  case 4: 
#line 352
  error = (char *)"Interrupted system call";
#line 353
  break;
  case 5: 
#line 357
  error = (char *)"I/O error";
#line 358
  break;
  case 6: 
#line 363
  error = (char *)"No such device or address";
#line 364
  break;
  case 7: 
#line 368
  error = (char *)"Arg list too long";
#line 369
  break;
  case 8: 
#line 373
  error = (char *)"Exec format error";
#line 374
  break;
  case 120: 
#line 378
  error = (char *)"Socket already connected";
#line 379
  break;
  case 9: 
#line 383
  error = (char *)"Bad file number";
#line 384
  break;
  case 10: 
#line 388
  error = (char *)"No children";
#line 389
  break;
  case 121: 
#line 393
  error = (char *)"Destination address required";
#line 394
  break;
  case 11: 
#line 398
  error = (char *)"No more processes";
#line 399
  break;
  case 12: 
#line 403
  error = (char *)"Not enough space";
#line 404
  break;
  case 13: 
#line 408
  error = (char *)"Permission denied";
#line 409
  break;
  case 14: 
#line 413
  error = (char *)"Bad address";
#line 414
  break;
  case 16: 
#line 423
  error = (char *)"Device or resource busy";
#line 424
  break;
  case 17: 
#line 428
  error = (char *)"File exists";
#line 429
  break;
  case 18: 
#line 433
  error = (char *)"Cross-device link";
#line 434
  break;
  case 19: 
#line 438
  error = (char *)"No such device";
#line 439
  break;
  case 20: 
#line 443
  error = (char *)"Not a directory";
#line 444
  break;
  case 117: 
#line 448
  error = (char *)"Host is down";
#line 449
  break;
  case 119: 
#line 453
  error = (char *)"Connection already in progress";
#line 454
  break;
  case 21: 
#line 458
  error = (char *)"Is a directory";
#line 459
  break;
  case 22: 
#line 463
  error = (char *)"Invalid argument";
#line 464
  break;
  case 115: 
#line 468
  error = (char *)"Network interface is not configured";
#line 469
  break;
  case 23: 
#line 473
  error = (char *)"Too many open files in system";
#line 474
  break;
  case 24: 
#line 478
  error = (char *)"Too many open files";
#line 479
  break;
  case 25: 
#line 483
  error = (char *)"Not a character device";
#line 484
  break;
  case 26: 
#line 488
  error = (char *)"Text file busy";
#line 489
  break;
  case 27: 
#line 493
  error = (char *)"File too large";
#line 494
  break;
  case 118: 
#line 498
  error = (char *)"Host is unreachable";
#line 499
  break;
  case 28: 
#line 503
  error = (char *)"No space left on device";
#line 504
  break;
  case 134: 
#line 508
  error = (char *)"Not supported";
#line 509
  break;
  case 29: 
#line 513
  error = (char *)"Illegal seek";
#line 514
  break;
  case 30: 
#line 518
  error = (char *)"Read-only file system";
#line 519
  break;
  case 31: 
#line 523
  error = (char *)"Too many links";
#line 524
  break;
  case 32: 
#line 528
  error = (char *)"Broken pipe";
#line 529
  break;
  case 33: 
#line 533
  error = (char *)"Math argument";
#line 534
  break;
  case 34: 
#line 538
  error = (char *)"Result too large";
#line 539
  break;
  case 35: 
#line 543
  error = (char *)"No message of desired type";
#line 544
  break;
  case 36: 
#line 548
  error = (char *)"Identifier removed";
#line 549
  break;
  case 45: 
#line 553
  error = (char *)"Deadlock";
#line 554
  break;
  case 114: 
#line 558
  error = (char *)"Network is unreachable";
#line 559
  break;
  case 46: 
#line 563
  error = (char *)"No lock";
#line 564
  break;
  case 60: 
#line 568
  error = (char *)"Not a stream";
#line 569
  break;
  case 62: 
#line 573
  error = (char *)"Stream ioctl timeout";
#line 574
  break;
  case 63: 
#line 578
  error = (char *)"No stream resources";
#line 579
  break;
  case 67: 
#line 598
  error = (char *)"Virtual circuit is gone";
#line 599
  break;
  case 71: 
#line 618
  error = (char *)"Protocol error";
#line 619
  break;
  case 123: 
#line 623
  error = (char *)"Unknown protocol";
#line 624
  break;
  case 74: 
#line 628
  error = (char *)"Multihop attempted";
#line 629
  break;
  case 77: 
#line 633
  error = (char *)"Bad message";
#line 634
  break;
  case 88: 
#line 663
  error = (char *)"Function not implemented";
#line 664
  break;
  case 90: 
#line 673
  error = (char *)"Directory not empty";
#line 674
  break;
  case 91: 
#line 678
  error = (char *)"File or path name too long";
#line 679
  break;
  case 92: 
#line 683
  error = (char *)"Too many symbolic links";
#line 684
  break;
  case 105: 
#line 688
  error = (char *)"No buffer space available";
#line 689
  break;
  case 106: 
#line 693
  error = (char *)"Address family not supported by protocol family";
#line 694
  break;
  case 107: 
#line 698
  error = (char *)"Protocol wrong type for socket";
#line 699
  break;
  case 108: 
#line 703
  error = (char *)"Socket operation on non-socket";
#line 704
  break;
  case 109: 
#line 708
  error = (char *)"Protocol not available";
#line 709
  break;
  case 111: 
#line 718
  error = (char *)"Connection refused";
#line 719
  break;
  case 112: 
#line 723
  error = (char *)"Address already in use";
#line 724
  break;
  case 113: 
#line 728
  error = (char *)"Software caused connection abort";
#line 729
  break;
  case 128: 
#line 738
  error = (char *)"Socket is not connected";
#line 739
  break;
  case 127: 
#line 748
  error = (char *)"Socket is already connected";
#line 749
  break;
  case 140: 
#line 753
  error = (char *)"Operation canceled";
#line 754
  break;
  case 141: 
#line 758
  error = (char *)"State not recoverable";
#line 759
  break;
  case 142: 
#line 763
  error = (char *)"Previous owner died";
#line 764
  break;
  case 95: 
#line 773
  error = (char *)"Operation not supported on socket";
#line 774
  break;
  case 122: 
#line 778
  error = (char *)"Message too long";
#line 779
  break;
  case 116: 
#line 783
  error = (char *)"Connection timed out";
#line 784
  break;
  default: 
#line 787
  error = _user_strerror(errnum);
#line 787
  if ((unsigned int )error == (unsigned int )((char *)0)) {
#line 788
    error = (char *)"";
  }
#line 789
  break;
  }
#line 792
  return (error);
}
}
#line 1 "lib_a-strerror_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Wao5T36I.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strftime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-YU5gQl73.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strlcat.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-mKaZVXPL.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strlcpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5hpHlUHM.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strlen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-JHHiCsiy.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 56 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strlen.c"
size_t strlen(char const   *str ) 
{ char const   *start ;
  int len ;

  {
#line 60
  start = str;
#line 85
  len = 0;
#line 86
  while (*str) {
#line 87
    str ++;
#line 88
    len ++;
  }
#line 90
  return ((unsigned int )len);
}
}
#line 1 "lib_a-strlwr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hx0EwATF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strncasecmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-kHwmcIrh.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strncat.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NMwjjGA3.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strncmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-BGcoMw53.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 61 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strncmp.c"
int strncmp(char const   *s1___0 , char const   *s2___0 , size_t n ) 
{ size_t __cil_tmp ;

  {
#line 68
  if (n == 0U) {
#line 69
    return (0);
  }
#line 71
  while (1) {
#line 71
    __cil_tmp = n;
#line 71
    n --;
#line 71
    if (! (__cil_tmp != 0U && (int const   )*s1___0 == (int const   )*s2___0)) {
#line 71
      break;
    }
#line 73
    if (n == 0U || (int const   )*s1___0 == 0) {
#line 74
      break;
    }
#line 75
    s1___0 ++;
#line 76
    s2___0 ++;
  }
#line 79
  return ((int )*((unsigned char *)s1___0) - (int )*((unsigned char *)s2___0));
}
}
#line 1 "lib_a-strncpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ZQ5OGOWB.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 67 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strncpy.c"
char *strncpy(char *dst0 , char const   *src0 , size_t count ) 
{ char *dscan ;
  char const   *sscan ;
  char *__cil_tmp ;
  char __cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  size_t __cil_tmp___3 ;

  {
#line 77
  dscan = dst0;
#line 78
  sscan = src0;
#line 79
  while (count > 0U) {
#line 81
    count --;
#line 82
    __cil_tmp = dscan;
#line 82
    dscan ++;
#line 82
    __cil_tmp___1 = sscan;
#line 82
    sscan ++;
#line 82
    __cil_tmp___0 = (char )*__cil_tmp___1;
#line 82
    *__cil_tmp = __cil_tmp___0;
#line 82
    if ((int )__cil_tmp___0 == 0) {
#line 83
      break;
    }
  }
#line 85
  while (1) {
#line 85
    __cil_tmp___3 = count;
#line 85
    count --;
#line 85
    if (! (__cil_tmp___3 > 0U)) {
#line 85
      break;
    }
#line 86
    __cil_tmp___2 = dscan;
#line 86
    dscan ++;
#line 86
    *__cil_tmp___2 = (char )'\000';
  }
#line 88
  return (dst0);
}
}
#line 1 "lib_a-strndup.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-WBqp1dEG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strndup_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7Ey2EUPq.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strnlen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-4bAsN2zO.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strpbrk.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-gQfBLiPj.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strptime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-KPtU9yfi.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strrchr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vADYMRPF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 38 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strrchr.c"
char *strrchr(char const   *s , int i ) 
{ char const   *last ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 43
  last = (char const   *)((void *)0);
#line 45
  if (i) {
#line 47
    while (1) {
#line 47
      __cil_tmp = strchr(s, i);
#line 47
      s = (char const   *)__cil_tmp;
#line 47
      if (! s) {
#line 47
        break;
      }
#line 49
      last = s;
#line 50
      s ++;
    }
  } else {
#line 55
    __cil_tmp___0 = strchr(s, i);
#line 55
    last = (char const   *)__cil_tmp___0;
  }
#line 58
  return ((char *)last);
}
}
#line 1 "lib_a-strsep.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-9H22S83H.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strsignal.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-MCw5vvMB.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strspn.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7eqe1ctF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strstr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-YQxjYnLi.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 47 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/strstr.c"
char *strstr(char const   *searchee , char const   *lookfor ) 
{ size_t i ;

  {
#line 55
  if ((int const   )*searchee == 0) {
#line 57
    if (*lookfor) {
#line 58
      return ((char *)((void *)0));
    }
#line 59
    return ((char *)searchee);
  }
#line 62
  while (*searchee) {
#line 65
    i = 0U;
#line 67
    while (1) {
#line 69
      if ((int const   )*(lookfor + i) == 0) {
#line 71
        return ((char *)searchee);
      }
#line 74
      if ((int const   )*(lookfor + i) != (int const   )*(searchee + i)) {
#line 76
        break;
      }
#line 78
      i ++;
    }
#line 80
    searchee ++;
  }
#line 83
  return ((char *)((void *)0));
}
}
#line 1 "lib_a-strtod.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wyiB7GrG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 127 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
double _strtod_r(struct _reent *ptr , char const   *s00 , char **se ) ;
#line 335 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/math.h"
extern float nanf(char const   * ) ;
#line 133 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtod.c"
static double const   tinytens[5]  = {      (double const   )1e-16,      (double const   )1e-32,      (double const   )1e-64,      (double const   )1e-128, 
        (double const   )9007199254740992.e-256};
#line 149 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtod.c"
static void ULtod(__ULong *L , __ULong *bits , Long exp___0 , int k ) 
{ __ULong __cil_tmp ;

  {
#line 156
  switch (k & 7) {
  case 6: 
  case 0: 
#line 159
  __cil_tmp = 0UL;
#line 159
  *(L + 1) = __cil_tmp;
#line 159
  *(L + 0) = __cil_tmp;
#line 160
  break;
  case 2: 
#line 163
  *(L + 0) = *(bits + 0);
#line 164
  *(L + 1) = *(bits + 1);
#line 165
  break;
  case 1: 
  case 5: 
#line 169
  *(L + 0) = *(bits + 0);
#line 170
  *(L + 1) = (*(bits + 1) & 4293918719UL) | (unsigned long )(((exp___0 + 1023) + 52) << 20);
#line 171
  break;
  case 3: 
#line 174
  *(L + 1) = 2146435072UL;
#line 175
  *(L + 0) = 0UL;
#line 176
  break;
  case 4: 
#line 179
  *(L + 1) = 2147483647UL;
#line 180
  *(L + 0) = 4294967295UL;
  }
#line 182
  if (k & 8) {
#line 183
    *(L + 1) |= 2147483648UL;
  }
#line 184
  return;
}
}
#line 188 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtod.c"
static int match___0(char const   **sp , char *t ) 
{ int c ;
  int d ;
  char const   *s ;
  char *__cil_tmp ;

  {
#line 194
  s = *sp;
#line 196
  while (1) {
#line 196
    __cil_tmp = t;
#line 196
    t ++;
#line 196
    d = (int )*__cil_tmp;
#line 196
    if (! (d != 0)) {
#line 196
      break;
    }
#line 197
    s ++;
#line 197
    c = (int )*s;
#line 197
    if (c >= 65 && c <= 90) {
#line 198
      c += 32;
    }
#line 199
    if (c != d) {
#line 200
      return (0);
    }
  }
#line 202
  *sp = s + 1;
#line 203
  return (1);
}
}
#line 259 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtod.c"
static FPI fpi  =    {53, -1074, 971, 1, 0};
#line 393 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtod.c"
static FPI fpinan  =    {52, -1074, 971, 1, 0};
#line 208 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtod.c"
double _strtod_r(struct _reent *ptr , char const   *s00 , char **se ) 
{ int scale ;
  int bb2 ;
  int bb5 ;
  int bbe ;
  int bd2 ;
  int bd5 ;
  int bbbits ;
  int bs2 ;
  int c ;
  int decpt ;
  int dsign ;
  int e ;
  int e1 ;
  int esign ;
  int i ;
  int j ;
  int k ;
  int nd ;
  int nd0 ;
  int nf ;
  int nz ;
  int nz0 ;
  int sign ;
  char const   *s ;
  char const   *s0 ;
  char const   *s1___0 ;
  double aadj ;
  double adj ;
  U aadj1 ;
  U rv ;
  U rv0 ;
  Long L ;
  __ULong y ;
  __ULong z ;
  _Bigint *bb ;
  _Bigint *bb1 ;
  _Bigint *bd ;
  _Bigint *bd0 ;
  _Bigint *bs ;
  _Bigint *delta ;
  Long exp___0 ;
  __ULong bits[2] ;
  struct lconv *__cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  struct lconv *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  struct lconv *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  __ULong bits___0[2] ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  unsigned int __cil_tmp___12 ;
  double __cil_tmp___13 ;
  double __cil_tmp___14 ;
  double __cil_tmp___15 ;
  double __cil_tmp___16 ;

  {
#line 232
  bd = (_Bigint *)((void *)0);
#line 232
  bs = bd;
#line 232
  delta = bs;
#line 233
  decpt = 0;
#line 233
  nz = decpt;
#line 233
  nz0 = nz;
#line 233
  sign = nz0;
#line 234
  rv.d = 0.;
#line 235
  s = s00;
#line 235
  while (1) {
#line 235
    switch ((int )*s) {
    case 45: 
#line 237
    sign = 1;
    case 43: 
#line 240
    s ++;
#line 240
    if (*s) {
#line 241
      goto break2;
    }
    case 0: 
#line 244
    goto ret0;
    case 9: 
    case 10: 
    case 11: 
    case 12: 
    case 13: 
    case 32: 
#line 251
    goto __Cont;
    default: 
#line 253
    goto break2;
    }
    __Cont: 
#line 235
    s ++;
  }
  break2: 
#line 256
  if ((int const   )*s == 48) {
#line 262
    switch ((int )*(s + 1)) {
    case 120: 
    case 88: 
#line 267
    s00 = s + 1;
#line 279
    i = __gethex(ptr, & s, & fpi, & exp___0, & bb, sign);
#line 279
    switch (i & 7) {
    case 6: 
#line 281
    s = s00;
    case 0: 
#line 283
    break;
    default: 
#line 285
    if (bb) {
#line 286
      __copybits(bits, fpi.nbits, bb);
#line 287
      _Bfree(ptr, bb);
    }
#line 289
    ULtod(rv.i, bits, exp___0, i);
    }
#line 291
    goto ret;
    }
#line 295
    nz0 = 1;
#line 296
    while (1) {
#line 296
      s ++;
#line 296
      if (! ((int const   )*s == 48)) {
#line 296
        break;
      }
    }
#line 297
    if (! *s) {
#line 298
      goto ret;
    }
  }
#line 300
  s0 = s;
#line 301
  z = 0UL;
#line 301
  y = z;
#line 302
  nf = 0;
#line 302
  nd = nf;
#line 302
  while (1) {
#line 302
    c = (int )*s;
#line 302
    if (! (c >= 48 && c <= 57)) {
#line 302
      break;
    }
#line 303
    if (nd < 16) {
#line 304
      if (nd < 9) {
#line 305
        y = (10UL * y + (unsigned long )c) - 48UL;
      } else {
#line 307
        z = (10UL * z + (unsigned long )c) - 48UL;
      }
    }
#line 302
    nd ++;
#line 302
    s ++;
  }
#line 310
  nd0 = nd;
#line 311
  __cil_tmp___3 = _localeconv_r(ptr);
#line 311
  __cil_tmp___4 = strlen((char const   *)__cil_tmp___3->decimal_point);
#line 311
  __cil_tmp___5 = _localeconv_r(ptr);
#line 311
  __cil_tmp___6 = strncmp(s, (char const   *)__cil_tmp___5->decimal_point, __cil_tmp___4);
#line 311
  if (__cil_tmp___6 == 0) {
#line 314
    decpt = 1;
#line 315
    __cil_tmp = _localeconv_r(ptr);
#line 315
    __cil_tmp___0 = strlen((char const   *)__cil_tmp->decimal_point);
#line 315
    s += __cil_tmp___0;
#line 315
    c = (int )*s;
#line 316
    if (! nd) {
#line 317
      while (c == 48) {
#line 318
        nz ++;
#line 317
        s ++;
#line 317
        c = (int )*s;
      }
#line 319
      if (c > 48 && c <= 57) {
#line 320
        s0 = s;
#line 321
        nf += nz;
#line 322
        nz = 0;
#line 323
        goto have_dig;
      }
#line 325
      goto dig_done;
    }
#line 327
    while (c >= 48 && c <= 57) {
      have_dig: 
#line 329
      nz ++;
#line 330
      c -= 48;
#line 330
      if (c) {
#line 331
        nf += nz;
#line 332
        i = 1;
#line 332
        while (i < nz) {
#line 333
          __cil_tmp___1 = nd;
#line 333
          nd ++;
#line 333
          if (__cil_tmp___1 <= 16) {
#line 334
            if (nd < 10) {
#line 335
              y *= 10UL;
            } else {
#line 337
              z *= 10UL;
            }
          }
#line 332
          i ++;
        }
#line 340
        __cil_tmp___2 = nd;
#line 340
        nd ++;
#line 340
        if (__cil_tmp___2 <= 16) {
#line 341
          if (nd < 10) {
#line 342
            y = 10UL * y + (unsigned long )c;
          } else {
#line 344
            z = 10UL * z + (unsigned long )c;
          }
        }
#line 346
        nz = 0;
      }
#line 327
      s ++;
#line 327
      c = (int )*s;
    }
  }
  dig_done: 
#line 351
  e = 0;
#line 352
  if (c == 101 || c == 69) {
#line 353
    if ((! nd && ! nz) && ! nz0) {
#line 354
      goto ret0;
    }
#line 356
    s00 = s;
#line 357
    esign = 0;
#line 358
    s ++;
#line 358
    c = (int )*s;
#line 358
    switch (c) {
    case 45: 
#line 360
    esign = 1;
    case 43: 
#line 362
    s ++;
#line 362
    c = (int )*s;
    }
#line 364
    if (c >= 48 && c <= 57) {
#line 365
      while (c == 48) {
#line 366
        s ++;
#line 366
        c = (int )*s;
      }
#line 367
      if (c > 48 && c <= 57) {
#line 368
        L = c - 48;
#line 369
        s1___0 = s;
#line 370
        while (1) {
#line 370
          s ++;
#line 370
          c = (int )*s;
#line 370
          if (! (c >= 48 && c <= 57)) {
#line 370
            break;
          }
#line 371
          L = (10 * L + c) - 48;
        }
#line 372
        if (s - s1___0 > 8 || L > 19999) {
#line 376
          e = 19999;
        } else {
#line 378
          e = L;
        }
#line 379
        if (esign) {
#line 380
          e = - e;
        }
      } else {
#line 383
        e = 0;
      }
    } else {
#line 386
      s = s00;
    }
  }
#line 388
  if (! nd) {
#line 389
    if (! nz && ! nz0) {
#line 395
      if (! decpt) {
#line 396
        switch (c) {
        case 105: 
        case 73: 
#line 399
        __cil_tmp___8 = match___0(& s, (char *)"nf");
#line 399
        if (__cil_tmp___8) {
#line 400
          s --;
#line 401
          __cil_tmp___7 = match___0(& s, (char *)"inity");
#line 401
          if (! __cil_tmp___7) {
#line 402
            s ++;
          }
#line 403
          rv.i[1] = 2146435072UL;
#line 405
          rv.i[0] = 0UL;
#line 407
          goto ret;
        }
#line 409
        break;
        case 110: 
        case 78: 
#line 412
        __cil_tmp___10 = match___0(& s, (char *)"an");
#line 412
        if (__cil_tmp___10) {
#line 414
          if ((int const   )*s == 40) {
#line 414
            __cil_tmp___9 = __hexnan(& s, & fpinan, bits___0);
#line 414
            if (__cil_tmp___9 == 5) {
#line 417
              rv.i[1] = 2146435072UL | bits___0[1];
#line 419
              rv.i[0] = bits___0[0];
            } else {
#line 424
              rv.i[1] = 4294443008UL;
#line 426
              rv.i[0] = 0UL;
            }
          } else {
#line 424
            rv.i[1] = 4294443008UL;
#line 426
            rv.i[0] = 0UL;
          }
#line 431
          goto ret;
        }
        }
      }
      ret0: 
#line 436
      s = s00;
#line 437
      sign = 0;
    }
#line 439
    goto ret;
  }
#line 441
  e -= nf;
#line 441
  e1 = e;
#line 448
  if (! nd0) {
#line 449
    nd0 = nd;
  }
#line 450
  k = nd < 16 ? nd : 16;
#line 451
  rv.d = (double )y;
#line 452
  if (k > 9) {
#line 457
    rv.d = (double )(__mprec_tens[k - 9] * (double const   )rv.d + (double const   )z);
  }
#line 459
  bd0 = (_Bigint *)0;
#line 460
  if (nd <= 15) {
#line 467
    if (! e) {
#line 468
      goto ret;
    }
#line 469
    if (e > 0) {
#line 470
      if (e <= 22) {
#line 481
        rv.d *= (double )__mprec_tens[e];
#line 482
        goto ret;
      }
#line 485
      i = 15 - nd;
#line 486
      if (e <= 22 + i) {
#line 497
        e -= i;
#line 498
        rv.d *= (double )__mprec_tens[i];
#line 511
        rv.d *= (double )__mprec_tens[e];
#line 513
        goto ret;
      }
    } else
#line 517
    if (e >= -22) {
#line 525
      rv.d /= (double )__mprec_tens[- e];
#line 526
      goto ret;
    }
  }
#line 530
  e1 += nd - k;
#line 539
  scale = 0;
#line 554
  if (e1 > 0) {
#line 555
    i = e1 & 15;
#line 555
    if (i != 0) {
#line 556
      rv.d *= (double )__mprec_tens[i];
    }
#line 557
    e1 &= -16;
#line 557
    if (e1) {
#line 558
      if (e1 > 308) {
        ovfl: 
#line 561
        ptr->_errno = 34;
#line 581
        rv.i[1] = 2146435072UL;
#line 583
        rv.i[0] = 0UL;
#line 597
        if (bd0) {
#line 598
          goto retfree;
        }
#line 599
        goto ret;
      }
#line 601
      e1 >>= 4;
#line 602
      j = 0;
#line 602
      while (e1 > 1) {
#line 603
        if (e1 & 1) {
#line 604
          rv.d *= (double )__mprec_bigtens[j];
        }
#line 602
        j ++;
#line 602
        e1 >>= 1;
      }
#line 606
      rv.i[1] -= 55574528UL;
#line 607
      rv.d *= (double )__mprec_bigtens[j];
#line 608
      z = rv.i[1] & 2146435072UL;
#line 608
      if (z > 2090860544UL) {
#line 610
        goto ovfl;
      }
#line 611
      if (z > 2089811968UL) {
#line 614
        rv.i[1] = 2146435071UL;
#line 616
        rv.i[0] = 4294967295UL;
      } else {
#line 620
        rv.i[1] += 55574528UL;
      }
    }
  } else
#line 623
  if (e1 < 0) {
#line 624
    e1 = - e1;
#line 625
    i = e1 & 15;
#line 625
    if (i != 0) {
#line 626
      rv.d /= (double )__mprec_tens[i];
    }
#line 627
    e1 >>= 4;
#line 627
    if (e1) {
#line 628
      if (e1 >= 1 << 5) {
#line 629
        goto undfl;
      }
#line 631
      if (e1 & 16) {
#line 632
        scale = 106;
      }
#line 633
      j = 0;
#line 633
      while (e1 > 0) {
#line 634
        if (e1 & 1) {
#line 635
          rv.d *= (double )tinytens[j];
        }
#line 633
        j ++;
#line 633
        e1 >>= 1;
      }
#line 636
      if (scale) {
#line 636
        j = (int )(107UL - ((rv.i[1] & 2146435072UL) >> 20));
#line 636
        if (j > 0) {
#line 639
          if (j >= 32) {
#line 641
            rv.i[0] = 0UL;
#line 643
            if (j >= 53) {
#line 644
              rv.i[1] = 57671680UL;
            } else {
#line 646
              rv.i[1] &= (unsigned long )(4294967295U << (j - 32));
            }
          } else {
#line 650
            rv.i[0] &= (unsigned long )(4294967295U << j);
          }
        }
      }
#line 664
      if (! rv.d) {
        undfl: 
#line 666
        rv.d = 0.;
#line 668
        ptr->_errno = 34;
#line 670
        if (bd0) {
#line 671
          goto retfree;
        }
#line 672
        goto ret;
      }
    }
  }
#line 693
  bd0 = __s2b(ptr, s0, nd0, nd, y);
#line 695
  while (1) {
#line 696
    bd = _Balloc(ptr, bd0->_k);
#line 697
    memcpy((void *)((char *)(& bd->_sign)), (void const   *)((char *)(& bd0->_sign)),
           (unsigned int )((unsigned long )bd0->_wds * sizeof(long ) + 2UL * sizeof(int )));
#line 698
    bb = __d2b(ptr, rv.d, & bbe, & bbbits);
#line 699
    bs = __i2b(ptr, 1);
#line 701
    if (e >= 0) {
#line 702
      bb5 = 0;
#line 702
      bb2 = bb5;
#line 703
      bd5 = e;
#line 703
      bd2 = bd5;
    } else {
#line 706
      bb5 = - e;
#line 706
      bb2 = bb5;
#line 707
      bd5 = 0;
#line 707
      bd2 = bd5;
    }
#line 709
    if (bbe >= 0) {
#line 710
      bb2 += bbe;
    } else {
#line 712
      bd2 -= bbe;
    }
#line 713
    bs2 = bb2;
#line 719
    j = bbe - scale;
#line 720
    i = (j + bbbits) - 1;
#line 721
    if (i < -1022) {
#line 722
      j += 1075;
    } else {
#line 724
      j = 54 - bbbits;
    }
#line 741
    bb2 += j;
#line 742
    bd2 += j;
#line 744
    bd2 += scale;
#line 746
    i = bb2 < bd2 ? bb2 : bd2;
#line 747
    if (i > bs2) {
#line 748
      i = bs2;
    }
#line 749
    if (i > 0) {
#line 750
      bb2 -= i;
#line 751
      bd2 -= i;
#line 752
      bs2 -= i;
    }
#line 754
    if (bb5 > 0) {
#line 755
      bs = __pow5mult(ptr, bs, bb5);
#line 756
      bb1 = __multiply(ptr, bs, bb);
#line 757
      _Bfree(ptr, bb);
#line 758
      bb = bb1;
    }
#line 760
    if (bb2 > 0) {
#line 761
      bb = __lshift(ptr, bb, bb2);
    }
#line 762
    if (bd5 > 0) {
#line 763
      bd = __pow5mult(ptr, bd, bd5);
    }
#line 764
    if (bd2 > 0) {
#line 765
      bd = __lshift(ptr, bd, bd2);
    }
#line 766
    if (bs2 > 0) {
#line 767
      bs = __lshift(ptr, bs, bs2);
    }
#line 768
    delta = __mdiff(ptr, bb, bd);
#line 769
    dsign = delta->_sign;
#line 770
    delta->_sign = 0;
#line 771
    i = __mcmp(delta, bs);
#line 863
    if (i < 0) {
#line 867
      if (((dsign || rv.i[0]) || rv.i[1] & 1048575UL) || (rv.i[1] & 2146435072UL) <= 112197632UL) {
#line 880
        break;
      }
#line 882
      if (! delta->_x[0] && delta->_wds <= 1) {
#line 887
        break;
      }
#line 889
      delta = __lshift(ptr, delta, 1);
#line 890
      __cil_tmp___11 = __mcmp(delta, bs);
#line 890
      if (__cil_tmp___11 > 0) {
#line 891
        goto drop_down;
      }
#line 892
      break;
    }
#line 894
    if (i == 0) {
#line 896
      if (dsign) {
#line 897
        if ((rv.i[1] & 1048575UL) == 1048575UL) {
#line 897
          if (scale) {
#line 897
            y = rv.i[1] & 2146435072UL;
#line 897
            if (y <= 111149056UL) {
#line 897
              __cil_tmp___12 = 4294967295U & (4294967295U << (107UL - (y >> 20)));
            } else {
#line 897
              __cil_tmp___12 = 4294967295U;
            }
          } else {
#line 897
            __cil_tmp___12 = 4294967295U;
          }
#line 897
          if (rv.i[0] == (unsigned long )__cil_tmp___12) {
#line 905
            rv.i[1] = (rv.i[1] & 2146435072UL) + 1048576UL;
#line 912
            rv.i[0] = 0UL;
#line 915
            dsign = 0;
#line 917
            break;
          }
        }
      } else
#line 920
      if (! (rv.i[1] & 1048575UL) && ! rv.i[0]) {
        drop_down: 
#line 938
        if (scale) {
#line 939
          L = (int )(rv.i[1] & 2146435072UL);
#line 940
          if ((unsigned int )L <= 112197632U) {
#line 941
            if ((unsigned int )L > 57671680U) {
#line 944
              break;
            }
#line 946
            goto undfl;
          }
        }
#line 950
        L = (int )((rv.i[1] & 2146435072UL) - 1048576UL);
#line 952
        rv.i[1] = (unsigned long )((unsigned int )L | 1048575U);
#line 954
        rv.i[0] = 4294967295UL;
#line 959
        break;
      }
#line 963
      if (! (rv.i[0] & 1UL)) {
#line 964
        break;
      }
#line 966
      if (dsign) {
#line 967
        __cil_tmp___13 = __ulp(rv.d);
#line 967
        rv.d += __cil_tmp___13;
      } else {
#line 970
        __cil_tmp___14 = __ulp(rv.d);
#line 970
        rv.d -= __cil_tmp___14;
#line 972
        if (! rv.d) {
#line 973
          goto undfl;
        }
      }
#line 977
      dsign = 1 - dsign;
#line 980
      break;
    }
#line 982
    aadj = __ratio(delta, bs);
#line 982
    if (aadj <= 2.) {
#line 983
      if (dsign) {
#line 984
        aadj1.d = 1.;
#line 984
        aadj = aadj1.d;
      } else
#line 985
      if (rv.i[0] || rv.i[1] & 1048575UL) {
#line 987
        if (rv.i[0] == 1UL && ! rv.i[1]) {
#line 988
          goto undfl;
        }
#line 990
        aadj = 1.;
#line 991
        aadj1.d = - 1.;
      } else {
#line 997
        if (aadj < 2. / (double )2) {
#line 998
          aadj = 1. / (double )2;
        } else {
#line 1000
          aadj *= 0.5;
        }
#line 1001
        aadj1.d = - aadj;
      }
    } else {
#line 1005
      aadj *= 0.5;
#line 1006
      aadj1.d = dsign ? aadj : - aadj;
    }
#line 1021
    y = rv.i[1] & 2146435072UL;
#line 1025
    if (y == 2145386496UL) {
#line 1026
      rv0.d = rv.d;
#line 1027
      rv.i[1] -= 55574528UL;
#line 1028
      __cil_tmp___15 = __ulp(rv.d);
#line 1028
      adj = aadj1.d * __cil_tmp___15;
#line 1029
      rv.d += adj;
#line 1030
      if ((rv.i[1] & 2146435072UL) >= 2090860544UL) {
#line 1032
        if (rv0.i[1] == 2146435071UL && rv0.i[0] == 4294967295UL) {
#line 1033
          goto ovfl;
        }
#line 1034
        rv.i[1] = 2146435071UL;
#line 1036
        rv.i[0] = 4294967295UL;
#line 1038
        goto cont;
      } else {
#line 1041
        rv.i[1] += 55574528UL;
      }
    } else {
#line 1045
      if (scale && y <= 111149056UL) {
#line 1046
        if (aadj <= (double )2147483647) {
#line 1047
          z = (unsigned long )aadj;
#line 1047
          if (z <= 0UL) {
#line 1048
            z = 1UL;
          }
#line 1049
          aadj = (double )z;
#line 1050
          aadj1.d = dsign ? aadj : - aadj;
        }
#line 1052
        aadj1.i[1] += 112197632UL - y;
      }
#line 1054
      __cil_tmp___16 = __ulp(rv.d);
#line 1054
      adj = aadj1.d * __cil_tmp___16;
#line 1055
      rv.d += adj;
    }
#line 1105
    z = rv.i[1] & 2146435072UL;
#line 1108
    if (! scale) {
#line 1110
      if (y == z) {
#line 1112
        L = (int )aadj;
#line 1113
        aadj -= (double )L;
#line 1115
        if ((dsign || rv.i[0]) || rv.i[1] & 1048575UL) {
#line 1116
          if (aadj < .4999999 || aadj > .5000001) {
#line 1117
            break;
          }
        } else
#line 1119
        if (aadj < .4999999 / (double )2) {
#line 1120
          break;
        }
      }
    }
    cont: 
#line 1124
    _Bfree(ptr, bb);
#line 1125
    _Bfree(ptr, bd);
#line 1126
    _Bfree(ptr, bs);
#line 1127
    _Bfree(ptr, delta);
  }
#line 1143
  if (scale) {
#line 1144
    rv0.i[1] = 961544192UL;
#line 1146
    rv0.i[0] = 0UL;
#line 1148
    rv.d *= rv0.d;
#line 1151
    if (rv.i[1] == 0UL && rv.i[0] == 0UL) {
#line 1152
      ptr->_errno = 34;
    }
  }
  retfree: 
#line 1164
  _Bfree(ptr, bb);
#line 1165
  _Bfree(ptr, bd);
#line 1166
  _Bfree(ptr, bs);
#line 1167
  _Bfree(ptr, bd0);
#line 1168
  _Bfree(ptr, delta);
  ret: 
#line 1170
  if (se) {
#line 1171
    *se = (char *)s;
  }
#line 1172
  return (sign ? - rv.d : rv.d);
}
}
#line 1177 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtod.c"
double strtod(char const   *s00 , char **se ) 
{ double __cil_tmp ;

  {
#line 1181
  __cil_tmp = _strtod_r(_impure_ptr, s00, se);
#line 1181
  return (__cil_tmp);
}
}
#line 1 "lib_a-strtok.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dF079idE.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strtok_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SaPkUzZd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strtol.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ekgWBXNk.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 133 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtol.c"
long _strtol_r(struct _reent *rptr , char const   *nptr , char **endptr , int base ) 
{ register unsigned char const   *s ;
  register unsigned long acc ;
  register int c ;
  register unsigned long cutoff ;
  register int neg ;
  register int any ;
  register int cutlim ;
  unsigned char const   *__cil_tmp ;
  unsigned char const   *__cil_tmp___0 ;
  unsigned char const   *__cil_tmp___1 ;
  unsigned char const   *__cil_tmp___2 ;

  {
#line 140
  s = (unsigned char const   *)nptr;
#line 144
  neg = 0;
#line 151
  while (1) {
#line 152
    __cil_tmp = s;
#line 152
    s ++;
#line 152
    c = (int )*__cil_tmp;
#line 151
    if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 8)) {
#line 151
      break;
    }
  }
#line 154
  if (c == 45) {
#line 155
    neg = 1;
#line 156
    __cil_tmp___0 = s;
#line 156
    s ++;
#line 156
    c = (int )*__cil_tmp___0;
  } else
#line 157
  if (c == 43) {
#line 158
    __cil_tmp___1 = s;
#line 158
    s ++;
#line 158
    c = (int )*__cil_tmp___1;
  }
#line 159
  if (((base == 0 || base == 16) && c == 48) && ((int const   )*s == 120 || (int const   )*s == 88)) {
#line 161
    c = (int )*(s + 1);
#line 162
    s += 2;
#line 163
    base = 16;
  }
#line 165
  if (base == 0) {
#line 166
    base = c == 48 ? 8 : 10;
  }
#line 185
  cutoff = neg ? 2147483648UL : 2147483647UL;
#line 186
  cutlim = (int )(cutoff % (unsigned long )base);
#line 187
  cutoff /= (unsigned long )base;
#line 188
  acc = 0UL;
#line 188
  any = 0;
#line 188
  while (1) {
#line 189
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 4) {
#line 190
      c -= 48;
    } else
#line 191
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) {
#line 192
      c -= ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) == 1 ? 55 : 87;
    } else {
#line 194
      break;
    }
#line 195
    if (c >= base) {
#line 196
      break;
    }
#line 197
    if ((any < 0 || acc > cutoff) || (acc == cutoff && c > cutlim)) {
#line 198
      any = -1;
    } else {
#line 200
      any = 1;
#line 201
      acc *= (unsigned long )base;
#line 202
      acc += (unsigned long )c;
    }
#line 188
    __cil_tmp___2 = s;
#line 188
    s ++;
#line 188
    c = (int )*__cil_tmp___2;
  }
#line 205
  if (any < 0) {
#line 206
    acc = (unsigned long )(neg ? (-0x7FFFFFFF-1) : 2147483647L);
#line 207
    rptr->_errno = 34;
  } else
#line 208
  if (neg) {
#line 209
    acc = - acc;
  }
#line 210
  if ((unsigned int )endptr != (unsigned int )((char **)0)) {
#line 211
    *endptr = (char *)(any ? (char const   *)((char *)s - 1) : nptr);
  }
#line 212
  return ((long )acc);
}
}
#line 217 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtol.c"
long strtol(char const   *s , char **ptr , int base ) 
{ long __cil_tmp ;

  {
#line 223
  __cil_tmp = _strtol_r(_impure_ptr, s, ptr, base);
#line 223
  return (__cil_tmp);
}
}
#line 1 "lib_a-strtoll.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-78yiOiFg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 129 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtoll.c"
long long strtoll(char const   *s , char **ptr , int base ) 
{ long long __cil_tmp ;

  {
#line 135
  __cil_tmp = _strtoll_r(_impure_ptr, s, ptr, base);
#line 135
  return (__cil_tmp);
}
}
#line 1 "lib_a-strtoll_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7lzWyg6s.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 58 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtoll_r.c"
long long _strtoll_r(struct _reent *rptr , char const   *nptr , char **endptr , int base ) 
{ register unsigned char const   *s ;
  register unsigned long long acc ;
  register int c ;
  register unsigned long long cutoff ;
  register int neg ;
  register int any ;
  register int cutlim ;
  unsigned char const   *__cil_tmp ;
  unsigned char const   *__cil_tmp___0 ;
  unsigned char const   *__cil_tmp___1 ;
  unsigned char const   *__cil_tmp___2 ;

  {
#line 65
  s = (unsigned char const   *)nptr;
#line 69
  neg = 0;
#line 76
  while (1) {
#line 77
    __cil_tmp = s;
#line 77
    s ++;
#line 77
    c = (int )*__cil_tmp;
#line 76
    if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 8)) {
#line 76
      break;
    }
  }
#line 79
  if (c == 45) {
#line 80
    neg = 1;
#line 81
    __cil_tmp___0 = s;
#line 81
    s ++;
#line 81
    c = (int )*__cil_tmp___0;
  } else
#line 82
  if (c == 43) {
#line 83
    __cil_tmp___1 = s;
#line 83
    s ++;
#line 83
    c = (int )*__cil_tmp___1;
  }
#line 84
  if (((base == 0 || base == 16) && c == 48) && ((int const   )*s == 120 || (int const   )*s == 88)) {
#line 86
    c = (int )*(s + 1);
#line 87
    s += 2;
#line 88
    base = 16;
  }
#line 90
  if (base == 0) {
#line 91
    base = c == 48 ? 8 : 10;
  }
#line 110
  cutoff = neg ? 0x8000000000000000ULL : 9223372036854775807ULL;
#line 111
  cutlim = (int )(cutoff % (unsigned long long )base);
#line 112
  cutoff /= (unsigned long long )base;
#line 113
  acc = 0ULL;
#line 113
  any = 0;
#line 113
  while (1) {
#line 114
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 4) {
#line 115
      c -= 48;
    } else
#line 116
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) {
#line 117
      c -= ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) == 1 ? 55 : 87;
    } else {
#line 119
      break;
    }
#line 120
    if (c >= base) {
#line 121
      break;
    }
#line 122
    if ((any < 0 || acc > cutoff) || (acc == cutoff && c > cutlim)) {
#line 123
      any = -1;
    } else {
#line 125
      any = 1;
#line 126
      acc *= (unsigned long long )base;
#line 127
      acc += (unsigned long long )c;
    }
#line 113
    __cil_tmp___2 = s;
#line 113
    s ++;
#line 113
    c = (int )*__cil_tmp___2;
  }
#line 130
  if (any < 0) {
#line 131
    acc = (unsigned long long )(neg ? (-0x7FFFFFFFFFFFFFFF-1) : 9223372036854775807LL);
#line 132
    rptr->_errno = 34;
  } else
#line 133
  if (neg) {
#line 134
    acc = - acc;
  }
#line 135
  if ((unsigned int )endptr != (unsigned int )((char **)0)) {
#line 136
    *endptr = (char *)(any ? (char const   *)((char *)s - 1) : nptr);
  }
#line 137
  return ((long long )acc);
}
}
#line 1 "lib_a-strtoul.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-6lzmBrCY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 138 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
unsigned long _strtoul_r(struct _reent *rptr , char const   *nptr , char **endptr ,
                         int base ) ;
#line 134 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtoul.c"
unsigned long _strtoul_r(struct _reent *rptr , char const   *nptr , char **endptr ,
                         int base ) 
{ register unsigned char const   *s ;
  register unsigned long acc ;
  register int c ;
  register unsigned long cutoff ;
  register int neg ;
  register int any ;
  register int cutlim ;
  unsigned char const   *__cil_tmp ;
  unsigned char const   *__cil_tmp___0 ;
  unsigned char const   *__cil_tmp___1 ;
  unsigned char const   *__cil_tmp___2 ;

  {
#line 141
  s = (unsigned char const   *)nptr;
#line 145
  neg = 0;
#line 150
  while (1) {
#line 151
    __cil_tmp = s;
#line 151
    s ++;
#line 151
    c = (int )*__cil_tmp;
#line 150
    if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 8)) {
#line 150
      break;
    }
  }
#line 153
  if (c == 45) {
#line 154
    neg = 1;
#line 155
    __cil_tmp___0 = s;
#line 155
    s ++;
#line 155
    c = (int )*__cil_tmp___0;
  } else
#line 156
  if (c == 43) {
#line 157
    __cil_tmp___1 = s;
#line 157
    s ++;
#line 157
    c = (int )*__cil_tmp___1;
  }
#line 158
  if (((base == 0 || base == 16) && c == 48) && ((int const   )*s == 120 || (int const   )*s == 88)) {
#line 160
    c = (int )*(s + 1);
#line 161
    s += 2;
#line 162
    base = 16;
  }
#line 164
  if (base == 0) {
#line 165
    base = c == 48 ? 8 : 10;
  }
#line 166
  cutoff = 4294967295UL / (unsigned long )base;
#line 167
  cutlim = (int )(4294967295UL % (unsigned long )base);
#line 168
  acc = 0UL;
#line 168
  any = 0;
#line 168
  while (1) {
#line 169
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 4) {
#line 170
      c -= 48;
    } else
#line 171
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) {
#line 172
      c -= ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) == 1 ? 55 : 87;
    } else {
#line 174
      break;
    }
#line 175
    if (c >= base) {
#line 176
      break;
    }
#line 177
    if ((any < 0 || acc > cutoff) || (acc == cutoff && c > cutlim)) {
#line 178
      any = -1;
    } else {
#line 180
      any = 1;
#line 181
      acc *= (unsigned long )base;
#line 182
      acc += (unsigned long )c;
    }
#line 168
    __cil_tmp___2 = s;
#line 168
    s ++;
#line 168
    c = (int )*__cil_tmp___2;
  }
#line 185
  if (any < 0) {
#line 186
    acc = 4294967295UL;
#line 187
    rptr->_errno = 34;
  } else
#line 188
  if (neg) {
#line 189
    acc = - acc;
  }
#line 190
  if ((unsigned int )endptr != (unsigned int )((char **)0)) {
#line 191
    *endptr = (char *)(any ? (char const   *)((char *)s - 1) : nptr);
  }
#line 192
  return (acc);
}
}
#line 1 "lib_a-strtoull.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dq7j94Av.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 192 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdlib.h"
unsigned long long _strtoull_r(struct _reent *rptr , char const   *nptr , char **endptr ,
                               int base ) ;
#line 1 "lib_a-strtoull_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-PblYhKJ6.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 59 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/strtoull_r.c"
unsigned long long _strtoull_r(struct _reent *rptr , char const   *nptr , char **endptr ,
                               int base ) 
{ register unsigned char const   *s ;
  register unsigned long long acc ;
  register int c ;
  register unsigned long long cutoff ;
  register int neg ;
  register int any ;
  register int cutlim ;
  unsigned char const   *__cil_tmp ;
  unsigned char const   *__cil_tmp___0 ;
  unsigned char const   *__cil_tmp___1 ;
  unsigned char const   *__cil_tmp___2 ;

  {
#line 66
  s = (unsigned char const   *)nptr;
#line 70
  neg = 0;
#line 75
  while (1) {
#line 76
    __cil_tmp = s;
#line 76
    s ++;
#line 76
    c = (int )*__cil_tmp;
#line 75
    if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 8)) {
#line 75
      break;
    }
  }
#line 78
  if (c == 45) {
#line 79
    neg = 1;
#line 80
    __cil_tmp___0 = s;
#line 80
    s ++;
#line 80
    c = (int )*__cil_tmp___0;
  } else
#line 81
  if (c == 43) {
#line 82
    __cil_tmp___1 = s;
#line 82
    s ++;
#line 82
    c = (int )*__cil_tmp___1;
  }
#line 83
  if (((base == 0 || base == 16) && c == 48) && ((int const   )*s == 120 || (int const   )*s == 88)) {
#line 85
    c = (int )*(s + 1);
#line 86
    s += 2;
#line 87
    base = 16;
  }
#line 89
  if (base == 0) {
#line 90
    base = c == 48 ? 8 : 10;
  }
#line 91
  cutoff = 0xffffffffffffffffULL / (unsigned long long )base;
#line 92
  cutlim = (int )(0xffffffffffffffffULL % (unsigned long long )base);
#line 93
  acc = 0ULL;
#line 93
  any = 0;
#line 93
  while (1) {
#line 94
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 4) {
#line 95
      c -= 48;
    } else
#line 96
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) {
#line 97
      c -= ((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) == 1 ? 55 : 87;
    } else {
#line 99
      break;
    }
#line 100
    if (c >= base) {
#line 101
      break;
    }
#line 102
    if ((any < 0 || acc > cutoff) || (acc == cutoff && c > cutlim)) {
#line 103
      any = -1;
    } else {
#line 105
      any = 1;
#line 106
      acc *= (unsigned long long )base;
#line 107
      acc += (unsigned long long )c;
    }
#line 93
    __cil_tmp___2 = s;
#line 93
    s ++;
#line 93
    c = (int )*__cil_tmp___2;
  }
#line 110
  if (any < 0) {
#line 111
    acc = 0xffffffffffffffffULL;
#line 112
    rptr->_errno = 34;
  } else
#line 113
  if (neg) {
#line 114
    acc = - acc;
  }
#line 115
  if ((unsigned int )endptr != (unsigned int )((char **)0)) {
#line 116
    *endptr = (char *)(any ? (char const   *)((char *)s - 1) : nptr);
  }
#line 117
  return (acc);
}
}
#line 1 "lib_a-strupr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-BG8u36ea.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-strxfrm.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7U5gQPrV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-svfiprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cxO7XiY2.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 225 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
__CH_CLASS const   __chclass[256] ;
#line 226
__STATE const   __state_table[12][9] ;
#line 227
__ACTION const   __action_table[12][9] ;
#line 191 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
int __ssprint_r(struct _reent *ptr , FILE *fp , struct __suio *uio ) 
{ register size_t len ;
  register int w ;
  register struct __siov *iov ;
  register char const   *p ;
  unsigned char *str ;
  int curpos ;
  int newsize ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 200
  p = (char const   *)((void *)0);
#line 202
  iov = uio->uio_iov;
#line 203
  len = 0U;
#line 205
  if (uio->uio_resid == 0) {
#line 206
    uio->uio_iovcnt = 0;
#line 207
    return (0);
  }
#line 210
  while (1) {
#line 211
    while (len == 0U) {
#line 212
      p = (char const   *)iov->iov_base;
#line 213
      len = iov->iov_len;
#line 214
      iov ++;
    }
#line 216
    w = fp->_w;
#line 217
    if (len >= (unsigned int )w && (int )fp->_flags & 1152) {
#line 220
      curpos = fp->_p - fp->_bf._base;
#line 228
      newsize = (fp->_bf._size * 3) / 2;
#line 229
      if ((unsigned int )newsize < ((unsigned int )curpos + len) + 1U) {
#line 230
        newsize = (int )(((unsigned int )curpos + len) + 1U);
      }
#line 231
      if ((int )fp->_flags & 1024) {
#line 234
        __cil_tmp = _malloc_r(ptr, (unsigned int )newsize);
#line 234
        str = (unsigned char *)__cil_tmp;
#line 235
        if (! str) {
#line 237
          ptr->_errno = 12;
#line 238
          goto err;
        }
#line 240
        memcpy((void *)str, (void const   *)fp->_bf._base, (unsigned int )curpos);
#line 241
        fp->_flags = (short )(((int )fp->_flags & -1025) | 128);
      } else {
#line 245
        __cil_tmp___0 = _realloc_r(ptr, (void *)fp->_bf._base, (unsigned int )newsize);
#line 245
        str = (unsigned char *)__cil_tmp___0;
#line 247
        if (! str) {
#line 249
          _free_r(ptr, (void *)fp->_bf._base);
#line 252
          ptr->_errno = 12;
#line 253
          goto err;
        }
      }
#line 256
      fp->_bf._base = str;
#line 257
      fp->_p = str + curpos;
#line 258
      fp->_bf._size = newsize;
#line 259
      w = (int )len;
#line 260
      fp->_w = newsize - curpos;
    }
#line 262
    if (len < (unsigned int )w) {
#line 263
      w = (int )len;
    }
#line 264
    memmove((void *)fp->_p, (void const   *)((void *)p), (unsigned int )w);
#line 265
    fp->_w -= w;
#line 266
    fp->_p += w;
#line 267
    w = (int )len;
#line 268
    p += w;
#line 269
    len -= (unsigned int )w;
#line 210
    __cil_tmp___1 = uio->uio_resid - w;
#line 210
    uio->uio_resid = __cil_tmp___1;
#line 210
    if (! (__cil_tmp___1 != 0)) {
#line 210
      break;
    }
  }
#line 272
  uio->uio_resid = 0;
#line 273
  uio->uio_iovcnt = 0;
#line 274
  return (0);
  err: 
#line 277
  fp->_flags = (short )((int )fp->_flags | 64);
#line 278
  uio->uio_resid = 0;
#line 279
  uio->uio_iovcnt = 0;
#line 280
  return (-1);
}
}
#line 1808 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
__CH_CLASS const   __chclass[256]  = 
#line 1808
  {      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )7,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )7, 
        (enum __anonenum___CH_CLASS_11  const  )2,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )7, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )6,      (enum __anonenum___CH_CLASS_11  const  )7, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )7,      (enum __anonenum___CH_CLASS_11  const  )5,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )0,      (enum __anonenum___CH_CLASS_11  const  )1,      (enum __anonenum___CH_CLASS_11  const  )1,      (enum __anonenum___CH_CLASS_11  const  )1, 
        (enum __anonenum___CH_CLASS_11  const  )1,      (enum __anonenum___CH_CLASS_11  const  )1,      (enum __anonenum___CH_CLASS_11  const  )1,      (enum __anonenum___CH_CLASS_11  const  )1, 
        (enum __anonenum___CH_CLASS_11  const  )1,      (enum __anonenum___CH_CLASS_11  const  )1,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4, 
        (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )4, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )3,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4, 
        (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )4, 
        (enum __anonenum___CH_CLASS_11  const  )3,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )3,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )3,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )4, 
        (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )3,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )4, 
        (enum __anonenum___CH_CLASS_11  const  )3,      (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )4,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )3,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8, 
        (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8,      (enum __anonenum___CH_CLASS_11  const  )8};
#line 1843 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
__STATE const   __state_table[12][9]  = 
#line 1843
  { {        (enum __anonenum___STATE_12  const  )1,        (enum __anonenum___STATE_12  const  )2,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )4, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )5,        (enum __anonenum___STATE_12  const  )6,        (enum __anonenum___STATE_12  const  )1, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )1,        (enum __anonenum___STATE_12  const  )2,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )4, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )5,        (enum __anonenum___STATE_12  const  )6,        (enum __anonenum___STATE_12  const  )1, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )3,        (enum __anonenum___STATE_12  const  )4, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )5,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )4, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )5,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )5,        (enum __anonenum___STATE_12  const  )8,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )4, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )7,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )9,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )4, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )5,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )10,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )4, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )4, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )3,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )8,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11,        (enum __anonenum___STATE_12  const  )11, 
            (enum __anonenum___STATE_12  const  )11}, 
   {        (__STATE const   )0,        (__STATE const   )0,        (__STATE const   )0,        (__STATE const   )0, 
            (__STATE const   )0,        (__STATE const   )0,        (__STATE const   )0,        (__STATE const   )0, 
            (__STATE const   )0}};
#line 1858 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
__ACTION const   __action_table[12][9]  = 
#line 1858
  { {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )1,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )3, 
            (enum __anonenum___ACTION_13  const  )4,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )1,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )3, 
            (enum __anonenum___ACTION_13  const  )4,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )7,        (enum __anonenum___ACTION_13  const  )3, 
            (enum __anonenum___ACTION_13  const  )4,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )3, 
            (enum __anonenum___ACTION_13  const  )4,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )4,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )2,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )3, 
            (enum __anonenum___ACTION_13  const  )4,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )1,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )5, 
            (enum __anonenum___ACTION_13  const  )6,        (enum __anonenum___ACTION_13  const  )5,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )1,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )5, 
            (enum __anonenum___ACTION_13  const  )6,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )3, 
            (enum __anonenum___ACTION_13  const  )4,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )8,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )8,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0,        (enum __anonenum___ACTION_13  const  )0, 
            (enum __anonenum___ACTION_13  const  )0}, 
   {        (__ACTION const   )0,        (__ACTION const   )0,        (__ACTION const   )0,        (__ACTION const   )0, 
            (__ACTION const   )0,        (__ACTION const   )0,        (__ACTION const   )0,        (__ACTION const   )0, 
            (__ACTION const   )0}};
#line 1 "lib_a-svfiscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dCPLRx3b.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 73 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/local.h"
int __submore(struct _reent *rptr , FILE *fp ) ;
#line 301 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfscanf.c"
int _sungetc_r(struct _reent *data , int c , FILE *fp ) 
{ int __cil_tmp ;

  {
#line 307
  if (c == -1) {
#line 308
    return (-1);
  }
#line 311
  fp->_flags = (short )((int )fp->_flags & -33);
#line 312
  c = (int )((unsigned char )c);
#line 319
  if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 321
    if (fp->_r >= fp->_ub._size) {
#line 321
      __cil_tmp = __submore(data, fp);
#line 321
      if (__cil_tmp) {
#line 323
        return (-1);
      }
    }
#line 325
    (fp->_p) --;
#line 325
    *(fp->_p) = (unsigned char )c;
#line 326
    (fp->_r) ++;
#line 327
    return (c);
  }
#line 336
  if (((unsigned int )fp->_bf._base != (unsigned int )((void *)0) && (unsigned int )fp->_p > (unsigned int )fp->_bf._base) && (int )*(fp->_p + -1) == c) {
#line 338
    (fp->_p) --;
#line 339
    (fp->_r) ++;
#line 340
    return (c);
  }
#line 348
  fp->_ur = fp->_r;
#line 349
  fp->_up = fp->_p;
#line 350
  fp->_ub._base = fp->_ubuf;
#line 351
  fp->_ub._size = (int )sizeof(fp->_ubuf);
#line 352
  fp->_ubuf[sizeof(fp->_ubuf) - 1UL] = (unsigned char )c;
#line 353
  fp->_p = & fp->_ubuf[sizeof(fp->_ubuf) - 1UL];
#line 354
  fp->_r = 1;
#line 355
  return (c);
}
}
#line 359 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfscanf.c"
int __ssrefill_r(struct _reent *ptr , FILE *fp ) 
{ int __cil_tmp ;

  {
#line 368
  if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 370
    if ((unsigned int )fp->_ub._base != (unsigned int )(fp->_ubuf)) {
#line 370
      _free_r(ptr, (void *)((char *)fp->_ub._base));
    }
#line 370
    fp->_ub._base = (unsigned char *)((void *)0);
#line 371
    __cil_tmp = fp->_ur;
#line 371
    fp->_r = __cil_tmp;
#line 371
    if (__cil_tmp != 0) {
#line 373
      fp->_p = fp->_up;
#line 374
      return (0);
    }
  }
#line 379
  fp->_p = fp->_bf._base;
#line 380
  fp->_r = 0;
#line 381
  fp->_flags = (short )((int )fp->_flags | 32);
#line 382
  return (-1);
}
}
#line 385 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfscanf.c"
size_t _sfread_r(struct _reent *ptr , void *buf , size_t size , size_t count , FILE *fp ) 
{ register size_t resid ;
  register char *p ;
  register int r ;
  size_t total ;
  int __cil_tmp ;

  {
#line 398
  resid = count * size;
#line 398
  if (resid == 0U) {
#line 399
    return (0U);
  }
#line 401
  total = resid;
#line 402
  p = (char *)buf;
#line 404
  while (1) {
#line 404
    r = fp->_r;
#line 404
    if (! (resid > (unsigned int )r)) {
#line 404
      break;
    }
#line 406
    memcpy((void *)p, (void const   *)((void *)fp->_p), (unsigned int )r);
#line 407
    fp->_p += r;
#line 408
    fp->_r = 0;
#line 409
    p += r;
#line 410
    resid -= (unsigned int )r;
#line 411
    __cil_tmp = __ssrefill_r(ptr, fp);
#line 411
    if (__cil_tmp) {
#line 414
      return ((total - resid) / size);
    }
  }
#line 417
  memcpy((void *)p, (void const   *)((void *)fp->_p), resid);
#line 418
  fp->_r = (int )((unsigned int )fp->_r - resid);
#line 419
  fp->_p += resid;
#line 420
  return (count);
}
}
#line 1 "lib_a-svfiwprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-E7evXjQo.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 1 "lib_a-svfiwscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-GAv0nhSo.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-svfprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-N51TrDGo.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 116 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/math.h"
extern double frexp(double  , int * ) ;
#line 413 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static char *cvt(struct _reent *data , double value , int ndigits , int flags , char *sign ,
                 int *decpt , int ch , int *length , char *buf ) ;
#line 416
static int exponent(char *p0 , int exp___0 , int fmtch ) ;
#line 485
static union arg_val *get_arg___3(struct _reent *data , int n , char *fmt , va_list *ap ,
                                  int *numargs_p , union arg_val *args , int *arg_type ,
                                  char **last_fmt ) ;
#line 615 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static char const   blanks___1[16]  = 
#line 615
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' '};
#line 617 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static char const   zeroes___1[16]  = 
#line 617
  {      (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0'};
#line 540 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
int _svfprintf_r(struct _reent *data , FILE *fp , char const   *fmt0 , va_list ap ) 
{ register char *fmt ;
  register int ch ;
  register int n ;
  register int m ;
  register char *cp ;
  register struct __siov *iovp ;
  register int flags ;
  char *fmt_anchor ;
  int N ;
  int arg_index ;
  int numargs ;
  char *saved_fmt ;
  union arg_val args[32] ;
  int arg_type[32] ;
  int is_pos_arg ;
  int old_is_pos_arg ;
  int ret ;
  int width ;
  int prec ;
  char sign ;
  char *thousands_sep ;
  size_t thsnd_len ;
  char const   *grouping ;
  char *decimal_point ;
  struct lconv *__cil_tmp ;
  size_t decp_len ;
  size_t __cil_tmp___0 ;
  char softsign ;
  union __anonunion__double__21 _double_ ;
  int expt ;
  int expsize ;
  char expstr[7] ;
  int lead ;
  int ndig ;
  int nseps ;
  int nrepeats ;
  unsigned long long _uquad ;
  enum __anonenum_base_22 base ;
  int dprec ;
  int realsz ;
  int size ;
  char *xdigs ;
  struct __suio uio ;
  struct __siov iov[8] ;
  char buf[100] ;
  char ox[2] ;
  char *malloc_buf ;
  unsigned char *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  char *__cil_tmp___4 ;
  struct lconv *__cil_tmp___5 ;
  struct lconv *__cil_tmp___6 ;
  char *old_fmt ;
  char *__cil_tmp___7 ;
  char *__cil_tmp___8 ;
  union arg_val *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  int __cil_tmp___17 ;
  char *old_fmt___0 ;
  char *__cil_tmp___18 ;
  char *__cil_tmp___19 ;
  union arg_val *__cil_tmp___20 ;
  int __cil_tmp___21 ;
  int __cil_tmp___23 ;
  int __cil_tmp___24 ;
  int __cil_tmp___25 ;
  int __cil_tmp___26 ;
  int __cil_tmp___27 ;
  int __cil_tmp___28 ;
  char *__cil_tmp___29 ;
  char *__cil_tmp___30 ;
  char *__cil_tmp___31 ;
  union arg_val *__cil_tmp___32 ;
  int __cil_tmp___33 ;
  int __cil_tmp___35 ;
  int __cil_tmp___36 ;
  int __cil_tmp___37 ;
  int __cil_tmp___38 ;
  int __cil_tmp___39 ;
  int __cil_tmp___40 ;
  union arg_val *__cil_tmp___41 ;
  long long __cil_tmp___42 ;
  int __cil_tmp___44 ;
  long long __cil_tmp___45 ;
  long long __cil_tmp___46 ;
  long long __cil_tmp___47 ;
  long long __cil_tmp___48 ;
  int __cil_tmp___49 ;
  long long __cil_tmp___50 ;
  union arg_val *__cil_tmp___51 ;
  long __cil_tmp___52 ;
  int __cil_tmp___54 ;
  long __cil_tmp___55 ;
  long __cil_tmp___56 ;
  long __cil_tmp___57 ;
  long __cil_tmp___58 ;
  int __cil_tmp___59 ;
  long __cil_tmp___60 ;
  union arg_val *__cil_tmp___61 ;
  int __cil_tmp___62 ;
  int __cil_tmp___64 ;
  int __cil_tmp___65 ;
  int __cil_tmp___66 ;
  int __cil_tmp___67 ;
  int __cil_tmp___68 ;
  int __cil_tmp___69 ;
  int __cil_tmp___70 ;
  union arg_val *__cil_tmp___71 ;
  int __cil_tmp___72 ;
  int __cil_tmp___74 ;
  int __cil_tmp___75 ;
  int __cil_tmp___76 ;
  int __cil_tmp___77 ;
  int __cil_tmp___78 ;
  int __cil_tmp___79 ;
  int __cil_tmp___80 ;
  union arg_val *__cil_tmp___81 ;
  int __cil_tmp___82 ;
  int __cil_tmp___84 ;
  int __cil_tmp___85 ;
  int __cil_tmp___86 ;
  int __cil_tmp___87 ;
  int __cil_tmp___88 ;
  int __cil_tmp___89 ;
  int __cil_tmp___90 ;
  long __cil_tmp___91 ;
  long __cil_tmp___92 ;
  long __cil_tmp___93 ;
  union arg_val *__cil_tmp___94 ;
  long double __cil_tmp___95 ;
  int __cil_tmp___97 ;
  long double __cil_tmp___98 ;
  long double __cil_tmp___99 ;
  long double __cil_tmp___100 ;
  long double __cil_tmp___101 ;
  int __cil_tmp___102 ;
  long double __cil_tmp___103 ;
  union arg_val *__cil_tmp___104 ;
  double __cil_tmp___105 ;
  int __cil_tmp___107 ;
  double __cil_tmp___108 ;
  double __cil_tmp___109 ;
  double __cil_tmp___110 ;
  double __cil_tmp___111 ;
  int __cil_tmp___112 ;
  int __cil_tmp___113 ;
  int __cil_tmp___114 ;
  int __cil_tmp___115 ;
  int __cil_tmp___116 ;
  int __cil_tmp___117 ;
  int __cil_tmp___118 ;
  void *__cil_tmp___119 ;
  union arg_val *__cil_tmp___120 ;
  quad_ptr_t __cil_tmp___121 ;
  int __cil_tmp___123 ;
  quad_ptr_t __cil_tmp___124 ;
  quad_ptr_t __cil_tmp___125 ;
  quad_ptr_t __cil_tmp___126 ;
  quad_ptr_t __cil_tmp___127 ;
  int __cil_tmp___128 ;
  quad_ptr_t __cil_tmp___129 ;
  union arg_val *__cil_tmp___130 ;
  long_ptr_t __cil_tmp___131 ;
  int __cil_tmp___133 ;
  long_ptr_t __cil_tmp___134 ;
  long_ptr_t __cil_tmp___135 ;
  long_ptr_t __cil_tmp___136 ;
  long_ptr_t __cil_tmp___137 ;
  int __cil_tmp___138 ;
  long_ptr_t __cil_tmp___139 ;
  union arg_val *__cil_tmp___140 ;
  short_ptr_t __cil_tmp___141 ;
  int __cil_tmp___143 ;
  short_ptr_t __cil_tmp___144 ;
  short_ptr_t __cil_tmp___145 ;
  short_ptr_t __cil_tmp___146 ;
  short_ptr_t __cil_tmp___147 ;
  int __cil_tmp___148 ;
  short_ptr_t __cil_tmp___149 ;
  union arg_val *__cil_tmp___150 ;
  char_ptr_t __cil_tmp___151 ;
  int __cil_tmp___153 ;
  char_ptr_t __cil_tmp___154 ;
  char_ptr_t __cil_tmp___155 ;
  char_ptr_t __cil_tmp___156 ;
  char_ptr_t __cil_tmp___157 ;
  int __cil_tmp___158 ;
  char_ptr_t __cil_tmp___159 ;
  union arg_val *__cil_tmp___160 ;
  int_ptr_t __cil_tmp___161 ;
  int __cil_tmp___163 ;
  int_ptr_t __cil_tmp___164 ;
  int_ptr_t __cil_tmp___165 ;
  int_ptr_t __cil_tmp___166 ;
  int_ptr_t __cil_tmp___167 ;
  int __cil_tmp___168 ;
  int_ptr_t __cil_tmp___169 ;
  union arg_val *__cil_tmp___170 ;
  unsigned long long __cil_tmp___171 ;
  int __cil_tmp___173 ;
  unsigned long long __cil_tmp___174 ;
  unsigned long long __cil_tmp___175 ;
  unsigned long long __cil_tmp___176 ;
  unsigned long long __cil_tmp___177 ;
  int __cil_tmp___178 ;
  unsigned long long __cil_tmp___179 ;
  union arg_val *__cil_tmp___180 ;
  u_long __cil_tmp___181 ;
  int __cil_tmp___183 ;
  u_long __cil_tmp___184 ;
  u_long __cil_tmp___185 ;
  u_long __cil_tmp___186 ;
  u_long __cil_tmp___187 ;
  int __cil_tmp___188 ;
  u_long __cil_tmp___189 ;
  union arg_val *__cil_tmp___190 ;
  int __cil_tmp___191 ;
  int __cil_tmp___193 ;
  int __cil_tmp___194 ;
  int __cil_tmp___195 ;
  int __cil_tmp___196 ;
  int __cil_tmp___197 ;
  int __cil_tmp___198 ;
  int __cil_tmp___199 ;
  union arg_val *__cil_tmp___200 ;
  int __cil_tmp___201 ;
  int __cil_tmp___203 ;
  int __cil_tmp___204 ;
  int __cil_tmp___205 ;
  int __cil_tmp___206 ;
  int __cil_tmp___207 ;
  int __cil_tmp___208 ;
  int __cil_tmp___209 ;
  union arg_val *__cil_tmp___210 ;
  u_int __cil_tmp___211 ;
  int __cil_tmp___213 ;
  u_int __cil_tmp___214 ;
  u_int __cil_tmp___215 ;
  u_int __cil_tmp___216 ;
  u_int __cil_tmp___217 ;
  int __cil_tmp___218 ;
  u_int __cil_tmp___219 ;
  unsigned long __cil_tmp___220 ;
  unsigned long __cil_tmp___221 ;
  u_long __cil_tmp___222 ;
  union arg_val *__cil_tmp___223 ;
  void_ptr_t __cil_tmp___224 ;
  int __cil_tmp___226 ;
  void_ptr_t __cil_tmp___227 ;
  void_ptr_t __cil_tmp___228 ;
  void_ptr_t __cil_tmp___229 ;
  void_ptr_t __cil_tmp___230 ;
  int __cil_tmp___231 ;
  void_ptr_t __cil_tmp___232 ;
  union arg_val *__cil_tmp___233 ;
  char_ptr_t __cil_tmp___234 ;
  int __cil_tmp___236 ;
  char_ptr_t __cil_tmp___237 ;
  char_ptr_t __cil_tmp___238 ;
  char_ptr_t __cil_tmp___239 ;
  char_ptr_t __cil_tmp___240 ;
  int __cil_tmp___241 ;
  char *p ;
  void *__cil_tmp___242 ;
  size_t __cil_tmp___243 ;
  union arg_val *__cil_tmp___244 ;
  unsigned long long __cil_tmp___245 ;
  int __cil_tmp___247 ;
  unsigned long long __cil_tmp___248 ;
  unsigned long long __cil_tmp___249 ;
  unsigned long long __cil_tmp___250 ;
  unsigned long long __cil_tmp___251 ;
  int __cil_tmp___252 ;
  unsigned long long __cil_tmp___253 ;
  union arg_val *__cil_tmp___254 ;
  u_long __cil_tmp___255 ;
  int __cil_tmp___257 ;
  u_long __cil_tmp___258 ;
  u_long __cil_tmp___259 ;
  u_long __cil_tmp___260 ;
  u_long __cil_tmp___261 ;
  int __cil_tmp___262 ;
  u_long __cil_tmp___263 ;
  union arg_val *__cil_tmp___264 ;
  int __cil_tmp___265 ;
  int __cil_tmp___267 ;
  int __cil_tmp___268 ;
  int __cil_tmp___269 ;
  int __cil_tmp___270 ;
  int __cil_tmp___271 ;
  int __cil_tmp___272 ;
  int __cil_tmp___273 ;
  union arg_val *__cil_tmp___274 ;
  int __cil_tmp___275 ;
  int __cil_tmp___277 ;
  int __cil_tmp___278 ;
  int __cil_tmp___279 ;
  int __cil_tmp___280 ;
  int __cil_tmp___281 ;
  int __cil_tmp___282 ;
  int __cil_tmp___283 ;
  union arg_val *__cil_tmp___284 ;
  u_int __cil_tmp___285 ;
  int __cil_tmp___287 ;
  u_int __cil_tmp___288 ;
  u_int __cil_tmp___289 ;
  u_int __cil_tmp___290 ;
  u_int __cil_tmp___291 ;
  int __cil_tmp___292 ;
  u_int __cil_tmp___293 ;
  unsigned long __cil_tmp___294 ;
  unsigned long __cil_tmp___295 ;
  u_long __cil_tmp___296 ;
  union arg_val *__cil_tmp___297 ;
  unsigned long long __cil_tmp___298 ;
  int __cil_tmp___300 ;
  unsigned long long __cil_tmp___301 ;
  unsigned long long __cil_tmp___302 ;
  unsigned long long __cil_tmp___303 ;
  unsigned long long __cil_tmp___304 ;
  int __cil_tmp___305 ;
  unsigned long long __cil_tmp___306 ;
  union arg_val *__cil_tmp___307 ;
  u_long __cil_tmp___308 ;
  int __cil_tmp___310 ;
  u_long __cil_tmp___311 ;
  u_long __cil_tmp___312 ;
  u_long __cil_tmp___313 ;
  u_long __cil_tmp___314 ;
  int __cil_tmp___315 ;
  u_long __cil_tmp___316 ;
  union arg_val *__cil_tmp___317 ;
  int __cil_tmp___318 ;
  int __cil_tmp___320 ;
  int __cil_tmp___321 ;
  int __cil_tmp___322 ;
  int __cil_tmp___323 ;
  int __cil_tmp___324 ;
  int __cil_tmp___325 ;
  int __cil_tmp___326 ;
  union arg_val *__cil_tmp___327 ;
  int __cil_tmp___328 ;
  int __cil_tmp___330 ;
  int __cil_tmp___331 ;
  int __cil_tmp___332 ;
  int __cil_tmp___333 ;
  int __cil_tmp___334 ;
  int __cil_tmp___335 ;
  int __cil_tmp___336 ;
  union arg_val *__cil_tmp___337 ;
  u_int __cil_tmp___338 ;
  int __cil_tmp___340 ;
  u_int __cil_tmp___341 ;
  u_int __cil_tmp___342 ;
  u_int __cil_tmp___343 ;
  u_int __cil_tmp___344 ;
  int __cil_tmp___345 ;
  u_int __cil_tmp___346 ;
  unsigned long __cil_tmp___347 ;
  unsigned long __cil_tmp___348 ;
  u_long __cil_tmp___349 ;
  size_t __cil_tmp___350 ;
  int __cil_tmp___351 ;
  int __cil_tmp___352 ;
  int __cil_tmp___353 ;
  int __cil_tmp___354 ;
  int __cil_tmp___355 ;
  int __cil_tmp___356 ;
  int __cil_tmp___357 ;
  int __cil_tmp___358 ;
  int __cil_tmp___359 ;
  int __cil_tmp___360 ;
  int __cil_tmp___361 ;
  int __cil_tmp___362 ;
  int __cil_tmp___363 ;
  int __cil_tmp___364 ;
  int __cil_tmp___365 ;
  int __cil_tmp___366 ;
  int __cil_tmp___367 ;
  int __cil_tmp___368 ;
  char *convbuf ;
  int n___0 ;
  int __cil_tmp___369 ;
  int __cil_tmp___370 ;
  int __cil_tmp___371 ;
  int __cil_tmp___372 ;
  int n___1 ;
  int __cil_tmp___373 ;
  int __cil_tmp___374 ;
  int __cil_tmp___375 ;
  int __cil_tmp___376 ;
  int n___2 ;
  int __cil_tmp___377 ;
  int __cil_tmp___378 ;
  int __cil_tmp___379 ;
  int __cil_tmp___380 ;
  int __cil_tmp___381 ;
  int __cil_tmp___382 ;
  int __cil_tmp___383 ;
  int __cil_tmp___384 ;
  int __cil_tmp___385 ;
  int __cil_tmp___386 ;
  int __cil_tmp___387 ;
  int __cil_tmp___388 ;
  int __cil_tmp___389 ;
  int __cil_tmp___390 ;

  {
#line 575
  __cil_tmp = _localeconv_r(data);
#line 575
  decimal_point = __cil_tmp->decimal_point;
#line 576
  __cil_tmp___0 = strlen((char const   *)decimal_point);
#line 576
  decp_len = __cil_tmp___0;
#line 578
  _double_.i = 0;
#line 581
  expsize = 0;
#line 586
  ndig = 0;
#line 597
  xdigs = (char *)((void *)0);
#line 607
  malloc_buf = (char *)((void *)0);
#line 729
  if ((int )fp->_flags & 128 && ! fp->_bf._base) {
#line 731
    __cil_tmp___2 = _malloc_r(data, 64U);
#line 731
    __cil_tmp___1 = (unsigned char *)__cil_tmp___2;
#line 731
    fp->_p = __cil_tmp___1;
#line 731
    fp->_bf._base = __cil_tmp___1;
#line 732
    if (! fp->_p) {
#line 734
      data->_errno = 12;
#line 735
      return (-1);
    }
#line 737
    fp->_bf._size = 64;
  }
#line 741
  fmt = (char *)fmt0;
#line 742
  iovp = iov;
#line 742
  uio.uio_iov = iovp;
#line 743
  uio.uio_resid = 0;
#line 744
  uio.uio_iovcnt = 0;
#line 745
  ret = 0;
#line 747
  arg_index = 0;
#line 748
  saved_fmt = (char *)((void *)0);
#line 749
  arg_type[0] = -1;
#line 750
  numargs = 0;
#line 751
  is_pos_arg = 0;
#line 757
  while (1) {
#line 758
    cp = fmt;
#line 772
    while ((int )*fmt != 0 && (int )*fmt != 37) {
#line 773
      fmt ++;
    }
#line 775
    m = fmt - cp;
#line 775
    if (m != 0) {
#line 776
      iovp->iov_base = (void const   *)cp;
#line 776
      iovp->iov_len = (unsigned int )m;
#line 776
      uio.uio_resid += m;
#line 776
      iovp ++;
#line 776
      (uio.uio_iovcnt) ++;
#line 776
      if (uio.uio_iovcnt >= 8) {
#line 776
        __cil_tmp___3 = __ssprint_r(data, fp, & uio);
#line 776
        if (__cil_tmp___3) {
#line 776
          goto error;
        }
#line 776
        iovp = iov;
      }
#line 777
      ret += m;
    }
#line 783
    if ((int )*fmt == 0) {
#line 784
      goto done;
    }
#line 786
    fmt_anchor = fmt;
#line 787
    fmt ++;
#line 789
    flags = 0;
#line 790
    dprec = 0;
#line 791
    width = 0;
#line 792
    prec = -1;
#line 793
    sign = (char )'\000';
#line 795
    lead = 0;
#line 798
    nrepeats = 0;
#line 798
    nseps = nrepeats;
#line 801
    N = arg_index;
#line 802
    is_pos_arg = 0;
    rflag: 
#line 805
    __cil_tmp___4 = fmt;
#line 805
    fmt ++;
#line 805
    ch = (int )*__cil_tmp___4;
    reswitch: 
#line 806
    switch (ch) {
    case 39: 
#line 809
    __cil_tmp___5 = _localeconv_r(data);
#line 809
    thousands_sep = __cil_tmp___5->thousands_sep;
#line 810
    thsnd_len = strlen((char const   *)thousands_sep);
#line 811
    __cil_tmp___6 = _localeconv_r(data);
#line 811
    grouping = (char const   *)__cil_tmp___6->grouping;
#line 812
    if ((thsnd_len > 0U && grouping) && *grouping) {
#line 813
      flags |= 1024;
    }
#line 814
    goto rflag;
    case 32: 
#line 822
    if (! sign) {
#line 823
      sign = (char )' ';
    }
#line 824
    goto rflag;
    case 35: 
#line 826
    flags |= 1;
#line 827
    goto rflag;
    case 42: 
#line 831
    n = N;
#line 832
    old_is_pos_arg = is_pos_arg;
#line 833
    is_pos_arg = 0;
#line 834
    if ((unsigned int )((int )*fmt - 48) <= 9U) {
#line 835
      old_fmt = fmt;
#line 837
      n = 0;
#line 838
      __cil_tmp___7 = fmt;
#line 838
      fmt ++;
#line 838
      ch = (int )*__cil_tmp___7;
#line 839
      while (1) {
#line 840
        n = 10 * n + (ch - 48);
#line 841
        __cil_tmp___8 = fmt;
#line 841
        fmt ++;
#line 841
        ch = (int )*__cil_tmp___8;
#line 839
        if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 839
          break;
        }
      }
#line 844
      if (ch == 36) {
#line 845
        if (n <= 32) {
#line 846
          n --;
#line 847
          is_pos_arg = 1;
        } else {
#line 850
          goto error;
        }
      } else {
#line 853
        fmt = old_fmt;
#line 854
        goto rflag;
      }
    }
#line 865
    if (is_pos_arg) {
#line 865
      if (n < numargs) {
#line 865
        __cil_tmp___10 = args[n].val_int;
      } else {
#line 865
        __cil_tmp___9 = get_arg___3(data, n, fmt_anchor, & ap, & numargs, args, arg_type,
                                    & saved_fmt);
#line 865
        __cil_tmp___10 = __cil_tmp___9->val_int;
      }
#line 865
      width = __cil_tmp___10;
    } else {
#line 865
      __cil_tmp___17 = arg_index;
#line 865
      arg_index ++;
#line 865
      if (__cil_tmp___17 < numargs) {
#line 865
        __cil_tmp___16 = args[n].val_int;
      } else {
#line 865
        if (numargs < 32) {
#line 865
          __cil_tmp___12 = numargs;
#line 865
          numargs ++;
#line 865
          __cil_tmp___13 = __builtin_va_arg(ap, int );
#line 865
          args[__cil_tmp___12].val_int = __cil_tmp___13;
#line 865
          __cil_tmp___15 = __cil_tmp___13;
        } else {
#line 865
          __cil_tmp___14 = __builtin_va_arg(ap, int );
#line 865
          __cil_tmp___15 = __cil_tmp___14;
        }
#line 865
        __cil_tmp___16 = __cil_tmp___15;
      }
#line 865
      width = __cil_tmp___16;
    }
#line 867
    is_pos_arg = old_is_pos_arg;
#line 869
    if (width >= 0) {
#line 870
      goto rflag;
    }
#line 871
    width = - width;
    case 45: 
#line 874
    flags |= 4;
#line 875
    goto rflag;
    case 43: 
#line 877
    sign = (char )'+';
#line 878
    goto rflag;
    case 46: 
#line 880
    __cil_tmp___29 = fmt;
#line 880
    fmt ++;
#line 880
    ch = (int )*__cil_tmp___29;
#line 880
    if (ch == 42) {
#line 883
      n = N;
#line 884
      old_is_pos_arg = is_pos_arg;
#line 885
      is_pos_arg = 0;
#line 886
      if ((unsigned int )((int )*fmt - 48) <= 9U) {
#line 887
        old_fmt___0 = fmt;
#line 889
        n = 0;
#line 890
        __cil_tmp___18 = fmt;
#line 890
        fmt ++;
#line 890
        ch = (int )*__cil_tmp___18;
#line 891
        while (1) {
#line 892
          n = 10 * n + (ch - 48);
#line 893
          __cil_tmp___19 = fmt;
#line 893
          fmt ++;
#line 893
          ch = (int )*__cil_tmp___19;
#line 891
          if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 891
            break;
          }
        }
#line 896
        if (ch == 36) {
#line 897
          if (n <= 32) {
#line 898
            n --;
#line 899
            is_pos_arg = 1;
          } else {
#line 902
            goto error;
          }
        } else {
#line 905
          fmt = old_fmt___0;
#line 906
          goto rflag;
        }
      }
#line 910
      if (is_pos_arg) {
#line 910
        if (n < numargs) {
#line 910
          __cil_tmp___21 = args[n].val_int;
        } else {
#line 910
          __cil_tmp___20 = get_arg___3(data, n, fmt_anchor, & ap, & numargs, args,
                                       arg_type, & saved_fmt);
#line 910
          __cil_tmp___21 = __cil_tmp___20->val_int;
        }
#line 910
        prec = __cil_tmp___21;
      } else {
#line 910
        __cil_tmp___28 = arg_index;
#line 910
        arg_index ++;
#line 910
        if (__cil_tmp___28 < numargs) {
#line 910
          __cil_tmp___27 = args[n].val_int;
        } else {
#line 910
          if (numargs < 32) {
#line 910
            __cil_tmp___23 = numargs;
#line 910
            numargs ++;
#line 910
            __cil_tmp___24 = __builtin_va_arg(ap, int );
#line 910
            args[__cil_tmp___23].val_int = __cil_tmp___24;
#line 910
            __cil_tmp___26 = __cil_tmp___24;
          } else {
#line 910
            __cil_tmp___25 = __builtin_va_arg(ap, int );
#line 910
            __cil_tmp___26 = __cil_tmp___25;
          }
#line 910
          __cil_tmp___27 = __cil_tmp___26;
        }
#line 910
        prec = __cil_tmp___27;
      }
#line 912
      is_pos_arg = old_is_pos_arg;
#line 914
      if (prec < 0) {
#line 915
        prec = -1;
      }
#line 916
      goto rflag;
    }
#line 918
    n = 0;
#line 919
    while ((unsigned int )(ch - 48) <= 9U) {
#line 920
      n = 10 * n + (ch - 48);
#line 921
      __cil_tmp___30 = fmt;
#line 921
      fmt ++;
#line 921
      ch = (int )*__cil_tmp___30;
    }
#line 923
    prec = n < 0 ? -1 : n;
#line 924
    goto reswitch;
    case 48: 
#line 931
    flags |= 128;
#line 932
    goto rflag;
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
#line 935
    n = 0;
#line 936
    while (1) {
#line 937
      n = 10 * n + (ch - 48);
#line 938
      __cil_tmp___31 = fmt;
#line 938
      fmt ++;
#line 938
      ch = (int )*__cil_tmp___31;
#line 936
      if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 936
        break;
      }
    }
#line 941
    if (ch == 36) {
#line 942
      if (n <= 32) {
#line 943
        N = n - 1;
#line 944
        is_pos_arg = 1;
#line 945
        goto rflag;
      } else {
#line 948
        goto error;
      }
    }
#line 951
    width = n;
#line 952
    goto reswitch;
    case 76: 
#line 955
    flags |= 8;
#line 956
    goto rflag;
    case 104: 
#line 960
    if ((int )*fmt == 104) {
#line 961
      fmt ++;
#line 962
      flags |= 512;
    } else {
#line 965
      flags |= 64;
    }
#line 966
    goto rflag;
    case 108: 
#line 969
    if ((int )*fmt == 108) {
#line 970
      fmt ++;
#line 971
      flags |= 32;
    } else {
#line 974
      flags |= 16;
    }
#line 975
    goto rflag;
    case 113: 
#line 977
    flags |= 32;
#line 978
    goto rflag;
    case 106: 
#line 981
    if (sizeof(intmax_t ) == sizeof(long )) {
#line 982
      flags |= 16;
    } else {
#line 984
      flags |= 32;
    }
#line 985
    goto rflag;
    case 122: 
#line 987
    if (sizeof(size_t ) < sizeof(int )) {
#line 989
      flags |= 64;
    } else
#line 990
    if (! (sizeof(size_t ) == sizeof(int ))) {
#line 992
      if (sizeof(size_t ) <= sizeof(long )) {
#line 993
        flags |= 16;
      } else {
#line 999
        flags |= 32;
      }
    }
#line 1000
    goto rflag;
    case 116: 
#line 1002
    if (sizeof(ptrdiff_t ) < sizeof(int )) {
#line 1005
      flags |= 64;
    } else
#line 1006
    if (! (sizeof(ptrdiff_t ) == sizeof(int ))) {
#line 1008
      if (sizeof(ptrdiff_t ) <= sizeof(long )) {
#line 1009
        flags |= 16;
      } else {
#line 1015
        flags |= 32;
      }
    }
#line 1016
    goto rflag;
    case 67: 
    case 99: 
#line 1020
    cp = buf;
#line 1036
    if (is_pos_arg) {
#line 1036
      if (N < numargs) {
#line 1036
        __cil_tmp___33 = args[N].val_int;
      } else {
#line 1036
        __cil_tmp___32 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args, arg_type,
                                     & saved_fmt);
#line 1036
        __cil_tmp___33 = __cil_tmp___32->val_int;
      }
#line 1036
      *cp = (char )__cil_tmp___33;
    } else {
#line 1036
      __cil_tmp___40 = arg_index;
#line 1036
      arg_index ++;
#line 1036
      if (__cil_tmp___40 < numargs) {
#line 1036
        __cil_tmp___39 = args[N].val_int;
      } else {
#line 1036
        if (numargs < 32) {
#line 1036
          __cil_tmp___35 = numargs;
#line 1036
          numargs ++;
#line 1036
          __cil_tmp___36 = __builtin_va_arg(ap, int );
#line 1036
          args[__cil_tmp___35].val_int = __cil_tmp___36;
#line 1036
          __cil_tmp___38 = __cil_tmp___36;
        } else {
#line 1036
          __cil_tmp___37 = __builtin_va_arg(ap, int );
#line 1036
          __cil_tmp___38 = __cil_tmp___37;
        }
#line 1036
        __cil_tmp___39 = __cil_tmp___38;
      }
#line 1036
      *cp = (char )__cil_tmp___39;
    }
#line 1037
    size = 1;
#line 1039
    sign = (char )'\000';
#line 1040
    break;
    case 68: 
#line 1042
    flags |= 16;
    case 100: 
    case 105: 
#line 1046
    if (flags & 32) {
#line 1046
      if (is_pos_arg) {
#line 1046
        if (N < numargs) {
#line 1046
          __cil_tmp___42 = args[N].val_quad_t;
        } else {
#line 1046
          __cil_tmp___41 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                       arg_type, & saved_fmt);
#line 1046
          __cil_tmp___42 = __cil_tmp___41->val_quad_t;
        }
#line 1046
        __cil_tmp___50 = __cil_tmp___42;
      } else {
#line 1046
        __cil_tmp___49 = arg_index;
#line 1046
        arg_index ++;
#line 1046
        if (__cil_tmp___49 < numargs) {
#line 1046
          __cil_tmp___48 = args[N].val_quad_t;
        } else {
#line 1046
          if (numargs < 32) {
#line 1046
            __cil_tmp___44 = numargs;
#line 1046
            numargs ++;
#line 1046
            __cil_tmp___45 = __builtin_va_arg(ap, long long );
#line 1046
            args[__cil_tmp___44].val_quad_t = __cil_tmp___45;
#line 1046
            __cil_tmp___47 = __cil_tmp___45;
          } else {
#line 1046
            __cil_tmp___46 = __builtin_va_arg(ap, long long );
#line 1046
            __cil_tmp___47 = __cil_tmp___46;
          }
#line 1046
          __cil_tmp___48 = __cil_tmp___47;
        }
#line 1046
        __cil_tmp___50 = __cil_tmp___48;
      }
#line 1046
      _uquad = (unsigned long long )__cil_tmp___50;
    } else {
#line 1046
      if (flags & 16) {
#line 1046
        if (is_pos_arg) {
#line 1046
          if (N < numargs) {
#line 1046
            __cil_tmp___52 = args[N].val_long;
          } else {
#line 1046
            __cil_tmp___51 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1046
            __cil_tmp___52 = __cil_tmp___51->val_long;
          }
#line 1046
          __cil_tmp___60 = __cil_tmp___52;
        } else {
#line 1046
          __cil_tmp___59 = arg_index;
#line 1046
          arg_index ++;
#line 1046
          if (__cil_tmp___59 < numargs) {
#line 1046
            __cil_tmp___58 = args[N].val_long;
          } else {
#line 1046
            if (numargs < 32) {
#line 1046
              __cil_tmp___54 = numargs;
#line 1046
              numargs ++;
#line 1046
              __cil_tmp___55 = __builtin_va_arg(ap, long );
#line 1046
              args[__cil_tmp___54].val_long = __cil_tmp___55;
#line 1046
              __cil_tmp___57 = __cil_tmp___55;
            } else {
#line 1046
              __cil_tmp___56 = __builtin_va_arg(ap, long );
#line 1046
              __cil_tmp___57 = __cil_tmp___56;
            }
#line 1046
            __cil_tmp___58 = __cil_tmp___57;
          }
#line 1046
          __cil_tmp___60 = __cil_tmp___58;
        }
#line 1046
        __cil_tmp___93 = __cil_tmp___60;
      } else {
#line 1046
        if (flags & 64) {
#line 1046
          if (is_pos_arg) {
#line 1046
            if (N < numargs) {
#line 1046
              __cil_tmp___62 = args[N].val_int;
            } else {
#line 1046
              __cil_tmp___61 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                           arg_type, & saved_fmt);
#line 1046
              __cil_tmp___62 = __cil_tmp___61->val_int;
            }
#line 1046
            __cil_tmp___70 = __cil_tmp___62;
          } else {
#line 1046
            __cil_tmp___69 = arg_index;
#line 1046
            arg_index ++;
#line 1046
            if (__cil_tmp___69 < numargs) {
#line 1046
              __cil_tmp___68 = args[N].val_int;
            } else {
#line 1046
              if (numargs < 32) {
#line 1046
                __cil_tmp___64 = numargs;
#line 1046
                numargs ++;
#line 1046
                __cil_tmp___65 = __builtin_va_arg(ap, int );
#line 1046
                args[__cil_tmp___64].val_int = __cil_tmp___65;
#line 1046
                __cil_tmp___67 = __cil_tmp___65;
              } else {
#line 1046
                __cil_tmp___66 = __builtin_va_arg(ap, int );
#line 1046
                __cil_tmp___67 = __cil_tmp___66;
              }
#line 1046
              __cil_tmp___68 = __cil_tmp___67;
            }
#line 1046
            __cil_tmp___70 = __cil_tmp___68;
          }
#line 1046
          __cil_tmp___92 = (long )((short )__cil_tmp___70);
        } else {
#line 1046
          if (flags & 512) {
#line 1046
            if (is_pos_arg) {
#line 1046
              if (N < numargs) {
#line 1046
                __cil_tmp___72 = args[N].val_int;
              } else {
#line 1046
                __cil_tmp___71 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                             args, arg_type, & saved_fmt);
#line 1046
                __cil_tmp___72 = __cil_tmp___71->val_int;
              }
#line 1046
              __cil_tmp___80 = __cil_tmp___72;
            } else {
#line 1046
              __cil_tmp___79 = arg_index;
#line 1046
              arg_index ++;
#line 1046
              if (__cil_tmp___79 < numargs) {
#line 1046
                __cil_tmp___78 = args[N].val_int;
              } else {
#line 1046
                if (numargs < 32) {
#line 1046
                  __cil_tmp___74 = numargs;
#line 1046
                  numargs ++;
#line 1046
                  __cil_tmp___75 = __builtin_va_arg(ap, int );
#line 1046
                  args[__cil_tmp___74].val_int = __cil_tmp___75;
#line 1046
                  __cil_tmp___77 = __cil_tmp___75;
                } else {
#line 1046
                  __cil_tmp___76 = __builtin_va_arg(ap, int );
#line 1046
                  __cil_tmp___77 = __cil_tmp___76;
                }
#line 1046
                __cil_tmp___78 = __cil_tmp___77;
              }
#line 1046
              __cil_tmp___80 = __cil_tmp___78;
            }
#line 1046
            __cil_tmp___91 = (long )((signed char )__cil_tmp___80);
          } else {
#line 1046
            if (is_pos_arg) {
#line 1046
              if (N < numargs) {
#line 1046
                __cil_tmp___82 = args[N].val_int;
              } else {
#line 1046
                __cil_tmp___81 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                             args, arg_type, & saved_fmt);
#line 1046
                __cil_tmp___82 = __cil_tmp___81->val_int;
              }
#line 1046
              __cil_tmp___90 = __cil_tmp___82;
            } else {
#line 1046
              __cil_tmp___89 = arg_index;
#line 1046
              arg_index ++;
#line 1046
              if (__cil_tmp___89 < numargs) {
#line 1046
                __cil_tmp___88 = args[N].val_int;
              } else {
#line 1046
                if (numargs < 32) {
#line 1046
                  __cil_tmp___84 = numargs;
#line 1046
                  numargs ++;
#line 1046
                  __cil_tmp___85 = __builtin_va_arg(ap, int );
#line 1046
                  args[__cil_tmp___84].val_int = __cil_tmp___85;
#line 1046
                  __cil_tmp___87 = __cil_tmp___85;
                } else {
#line 1046
                  __cil_tmp___86 = __builtin_va_arg(ap, int );
#line 1046
                  __cil_tmp___87 = __cil_tmp___86;
                }
#line 1046
                __cil_tmp___88 = __cil_tmp___87;
              }
#line 1046
              __cil_tmp___90 = __cil_tmp___88;
            }
#line 1046
            __cil_tmp___91 = (long )__cil_tmp___90;
          }
#line 1046
          __cil_tmp___92 = __cil_tmp___91;
        }
#line 1046
        __cil_tmp___93 = __cil_tmp___92;
      }
#line 1046
      _uquad = (unsigned long long )__cil_tmp___93;
    }
#line 1048
    if ((long long )_uquad < 0LL) {
#line 1054
      _uquad = - _uquad;
#line 1055
      sign = (char )'-';
    }
#line 1057
    base = (enum __anonenum_base_22 )1;
#line 1058
    goto number;
    case 97: 
    case 65: 
    case 70: 
    case 101: 
    case 69: 
    case 102: 
    case 103: 
    case 71: 
#line 1071
    if (flags & 8) {
#line 1072
      if (is_pos_arg) {
#line 1072
        if (N < numargs) {
#line 1072
          __cil_tmp___95 = args[N].val__LONG_DOUBLE;
        } else {
#line 1072
          __cil_tmp___94 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                       arg_type, & saved_fmt);
#line 1072
          __cil_tmp___95 = __cil_tmp___94->val__LONG_DOUBLE;
        }
#line 1072
        __cil_tmp___103 = __cil_tmp___95;
      } else {
#line 1072
        __cil_tmp___102 = arg_index;
#line 1072
        arg_index ++;
#line 1072
        if (__cil_tmp___102 < numargs) {
#line 1072
          __cil_tmp___101 = args[N].val__LONG_DOUBLE;
        } else {
#line 1072
          if (numargs < 32) {
#line 1072
            __cil_tmp___97 = numargs;
#line 1072
            numargs ++;
#line 1072
            __cil_tmp___98 = __builtin_va_arg(ap, long double );
#line 1072
            args[__cil_tmp___97].val__LONG_DOUBLE = __cil_tmp___98;
#line 1072
            __cil_tmp___100 = __cil_tmp___98;
          } else {
#line 1072
            __cil_tmp___99 = __builtin_va_arg(ap, long double );
#line 1072
            __cil_tmp___100 = __cil_tmp___99;
          }
#line 1072
          __cil_tmp___101 = __cil_tmp___100;
        }
#line 1072
        __cil_tmp___103 = __cil_tmp___101;
      }
#line 1072
      _double_.fp = (double )__cil_tmp___103;
    } else
#line 1074
    if (is_pos_arg) {
#line 1074
      if (N < numargs) {
#line 1074
        __cil_tmp___105 = args[N].val_double;
      } else {
#line 1074
        __cil_tmp___104 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                      arg_type, & saved_fmt);
#line 1074
        __cil_tmp___105 = __cil_tmp___104->val_double;
      }
#line 1074
      _double_.fp = __cil_tmp___105;
    } else {
#line 1074
      __cil_tmp___112 = arg_index;
#line 1074
      arg_index ++;
#line 1074
      if (__cil_tmp___112 < numargs) {
#line 1074
        __cil_tmp___111 = args[N].val_double;
      } else {
#line 1074
        if (numargs < 32) {
#line 1074
          __cil_tmp___107 = numargs;
#line 1074
          numargs ++;
#line 1074
          __cil_tmp___108 = __builtin_va_arg(ap, double );
#line 1074
          args[__cil_tmp___107].val_double = __cil_tmp___108;
#line 1074
          __cil_tmp___110 = __cil_tmp___108;
        } else {
#line 1074
          __cil_tmp___109 = __builtin_va_arg(ap, double );
#line 1074
          __cil_tmp___110 = __cil_tmp___109;
        }
#line 1074
        __cil_tmp___111 = __cil_tmp___110;
      }
#line 1074
      _double_.fp = __cil_tmp___111;
    }
#line 1083
    if (sizeof(_double_.fp) == sizeof(float )) {
#line 1083
      __cil_tmp___113 = __fpclassifyf((float )_double_.fp);
#line 1083
      __cil_tmp___115 = __cil_tmp___113;
    } else {
#line 1083
      __cil_tmp___114 = __fpclassifyd(_double_.fp);
#line 1083
      __cil_tmp___115 = __cil_tmp___114;
    }
#line 1083
    if (__cil_tmp___115 == 1) {
#line 1084
      if (_double_.fp < (double )0) {
#line 1085
        sign = (char )'-';
      }
#line 1086
      if (ch <= 71) {
#line 1087
        cp = (char *)"INF";
      } else {
#line 1089
        cp = (char *)"inf";
      }
#line 1090
      size = 3;
#line 1091
      flags &= -129;
#line 1092
      break;
    }
#line 1094
    if (sizeof(_double_.fp) == sizeof(float )) {
#line 1094
      __cil_tmp___116 = __fpclassifyf((float )_double_.fp);
#line 1094
      __cil_tmp___118 = __cil_tmp___116;
    } else {
#line 1094
      __cil_tmp___117 = __fpclassifyd(_double_.fp);
#line 1094
      __cil_tmp___118 = __cil_tmp___117;
    }
#line 1094
    if (__cil_tmp___118 == 0) {
#line 1095
      if (ch <= 71) {
#line 1096
        cp = (char *)"NAN";
      } else {
#line 1098
        cp = (char *)"nan";
      }
#line 1099
      size = 3;
#line 1100
      flags &= -129;
#line 1101
      break;
    }
#line 1137
    if (ch == 97 || ch == 65) {
#line 1138
      ox[0] = (char )'0';
#line 1139
      ox[1] = (char )(ch == 97 ? 'x' : 'X');
#line 1140
      flags |= 2;
#line 1141
      if (prec >= 100) {
#line 1143
        __cil_tmp___119 = _malloc_r(data, (unsigned int )(prec + 1));
#line 1143
        malloc_buf = (char *)__cil_tmp___119;
#line 1143
        if ((unsigned int )malloc_buf == (unsigned int )((void *)0)) {
#line 1147
          fp->_flags = (short )((int )fp->_flags | 64);
#line 1148
          goto error;
        }
#line 1150
        cp = malloc_buf;
      } else {
#line 1153
        cp = buf;
      }
    } else
#line 1156
    if (prec == -1) {
#line 1157
      prec = 6;
    } else
#line 1158
    if ((ch == 103 || ch == 71) && prec == 0) {
#line 1159
      prec = 1;
    }
#line 1162
    flags |= 256;
#line 1164
    cp = cvt(data, _double_.fp, prec, flags, & softsign, & expt, ch, & ndig, cp);
#line 1167
    if (ch == 103 || ch == 71) {
#line 1168
      if (expt <= -4 || expt > prec) {
#line 1169
        ch -= 2;
      } else {
#line 1171
        ch = 'g';
      }
    } else
#line 1174
    if (ch == 70) {
#line 1175
      ch = 'f';
    }
#line 1177
    if (ch <= 101) {
#line 1178
      expt --;
#line 1179
      expsize = exponent(expstr, expt, ch);
#line 1180
      size = expsize + ndig;
#line 1181
      if (ndig > 1 || flags & 1) {
#line 1182
        size ++;
      }
#line 1184
      flags &= -1025;
    } else {
#line 1187
      if (ch == 102) {
#line 1188
        if (expt > 0) {
#line 1189
          size = expt;
#line 1190
          if (prec || flags & 1) {
#line 1191
            size += prec + 1;
          }
        } else {
#line 1193
          size = prec || flags & 1 ? prec + 2 : 1;
        }
      } else
#line 1196
      if (expt >= ndig) {
#line 1197
        size = expt;
#line 1198
        if (flags & 1) {
#line 1199
          size ++;
        }
      } else {
#line 1201
        size = ndig + (expt > 0 ? 1 : 2 - expt);
      }
#line 1204
      if (flags & 1024 && expt > 0) {
#line 1206
        nrepeats = 0;
#line 1206
        nseps = nrepeats;
#line 1207
        lead = expt;
#line 1208
        while ((int const   )*grouping != 127) {
#line 1209
          if (lead <= (int )*grouping) {
#line 1210
            break;
          }
#line 1211
          lead -= (int )*grouping;
#line 1212
          if (*(grouping + 1)) {
#line 1213
            nseps ++;
#line 1214
            grouping ++;
          } else {
#line 1216
            nrepeats ++;
          }
        }
#line 1218
        size = (int )((unsigned int )size + (unsigned int )(nseps + nrepeats) * thsnd_len);
      } else {
#line 1221
        lead = expt;
      }
    }
#line 1224
    if (softsign) {
#line 1225
      sign = (char )'-';
    }
#line 1226
    break;
    case 110: 
#line 1230
    if (flags & 32) {
#line 1231
      if (is_pos_arg) {
#line 1231
        if (N < numargs) {
#line 1231
          __cil_tmp___121 = args[N].val_quad_ptr_t;
        } else {
#line 1231
          __cil_tmp___120 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1231
          __cil_tmp___121 = __cil_tmp___120->val_quad_ptr_t;
        }
#line 1231
        __cil_tmp___129 = __cil_tmp___121;
      } else {
#line 1231
        __cil_tmp___128 = arg_index;
#line 1231
        arg_index ++;
#line 1231
        if (__cil_tmp___128 < numargs) {
#line 1231
          __cil_tmp___127 = args[N].val_quad_ptr_t;
        } else {
#line 1231
          if (numargs < 32) {
#line 1231
            __cil_tmp___123 = numargs;
#line 1231
            numargs ++;
#line 1231
            __cil_tmp___124 = __builtin_va_arg(ap, quad_ptr_t );
#line 1231
            args[__cil_tmp___123].val_quad_ptr_t = __cil_tmp___124;
#line 1231
            __cil_tmp___126 = __cil_tmp___124;
          } else {
#line 1231
            __cil_tmp___125 = __builtin_va_arg(ap, quad_ptr_t );
#line 1231
            __cil_tmp___126 = __cil_tmp___125;
          }
#line 1231
          __cil_tmp___127 = __cil_tmp___126;
        }
#line 1231
        __cil_tmp___129 = __cil_tmp___127;
      }
#line 1231
      *__cil_tmp___129 = (long long )ret;
    } else
#line 1234
    if (flags & 16) {
#line 1235
      if (is_pos_arg) {
#line 1235
        if (N < numargs) {
#line 1235
          __cil_tmp___131 = args[N].val_long_ptr_t;
        } else {
#line 1235
          __cil_tmp___130 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1235
          __cil_tmp___131 = __cil_tmp___130->val_long_ptr_t;
        }
#line 1235
        __cil_tmp___139 = __cil_tmp___131;
      } else {
#line 1235
        __cil_tmp___138 = arg_index;
#line 1235
        arg_index ++;
#line 1235
        if (__cil_tmp___138 < numargs) {
#line 1235
          __cil_tmp___137 = args[N].val_long_ptr_t;
        } else {
#line 1235
          if (numargs < 32) {
#line 1235
            __cil_tmp___133 = numargs;
#line 1235
            numargs ++;
#line 1235
            __cil_tmp___134 = __builtin_va_arg(ap, long_ptr_t );
#line 1235
            args[__cil_tmp___133].val_long_ptr_t = __cil_tmp___134;
#line 1235
            __cil_tmp___136 = __cil_tmp___134;
          } else {
#line 1235
            __cil_tmp___135 = __builtin_va_arg(ap, long_ptr_t );
#line 1235
            __cil_tmp___136 = __cil_tmp___135;
          }
#line 1235
          __cil_tmp___137 = __cil_tmp___136;
        }
#line 1235
        __cil_tmp___139 = __cil_tmp___137;
      }
#line 1235
      *__cil_tmp___139 = (long )ret;
    } else
#line 1236
    if (flags & 64) {
#line 1237
      if (is_pos_arg) {
#line 1237
        if (N < numargs) {
#line 1237
          __cil_tmp___141 = args[N].val_short_ptr_t;
        } else {
#line 1237
          __cil_tmp___140 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1237
          __cil_tmp___141 = __cil_tmp___140->val_short_ptr_t;
        }
#line 1237
        __cil_tmp___149 = __cil_tmp___141;
      } else {
#line 1237
        __cil_tmp___148 = arg_index;
#line 1237
        arg_index ++;
#line 1237
        if (__cil_tmp___148 < numargs) {
#line 1237
          __cil_tmp___147 = args[N].val_short_ptr_t;
        } else {
#line 1237
          if (numargs < 32) {
#line 1237
            __cil_tmp___143 = numargs;
#line 1237
            numargs ++;
#line 1237
            __cil_tmp___144 = __builtin_va_arg(ap, short_ptr_t );
#line 1237
            args[__cil_tmp___143].val_short_ptr_t = __cil_tmp___144;
#line 1237
            __cil_tmp___146 = __cil_tmp___144;
          } else {
#line 1237
            __cil_tmp___145 = __builtin_va_arg(ap, short_ptr_t );
#line 1237
            __cil_tmp___146 = __cil_tmp___145;
          }
#line 1237
          __cil_tmp___147 = __cil_tmp___146;
        }
#line 1237
        __cil_tmp___149 = __cil_tmp___147;
      }
#line 1237
      *__cil_tmp___149 = (short )ret;
    } else
#line 1239
    if (flags & 512) {
#line 1240
      if (is_pos_arg) {
#line 1240
        if (N < numargs) {
#line 1240
          __cil_tmp___151 = args[N].val_char_ptr_t;
        } else {
#line 1240
          __cil_tmp___150 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1240
          __cil_tmp___151 = __cil_tmp___150->val_char_ptr_t;
        }
#line 1240
        __cil_tmp___159 = __cil_tmp___151;
      } else {
#line 1240
        __cil_tmp___158 = arg_index;
#line 1240
        arg_index ++;
#line 1240
        if (__cil_tmp___158 < numargs) {
#line 1240
          __cil_tmp___157 = args[N].val_char_ptr_t;
        } else {
#line 1240
          if (numargs < 32) {
#line 1240
            __cil_tmp___153 = numargs;
#line 1240
            numargs ++;
#line 1240
            __cil_tmp___154 = __builtin_va_arg(ap, char_ptr_t );
#line 1240
            args[__cil_tmp___153].val_char_ptr_t = __cil_tmp___154;
#line 1240
            __cil_tmp___156 = __cil_tmp___154;
          } else {
#line 1240
            __cil_tmp___155 = __builtin_va_arg(ap, char_ptr_t );
#line 1240
            __cil_tmp___156 = __cil_tmp___155;
          }
#line 1240
          __cil_tmp___157 = __cil_tmp___156;
        }
#line 1240
        __cil_tmp___159 = __cil_tmp___157;
      }
#line 1240
      *__cil_tmp___159 = (char )ret;
    } else {
#line 1243
      if (is_pos_arg) {
#line 1243
        if (N < numargs) {
#line 1243
          __cil_tmp___161 = args[N].val_int_ptr_t;
        } else {
#line 1243
          __cil_tmp___160 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1243
          __cil_tmp___161 = __cil_tmp___160->val_int_ptr_t;
        }
#line 1243
        __cil_tmp___169 = __cil_tmp___161;
      } else {
#line 1243
        __cil_tmp___168 = arg_index;
#line 1243
        arg_index ++;
#line 1243
        if (__cil_tmp___168 < numargs) {
#line 1243
          __cil_tmp___167 = args[N].val_int_ptr_t;
        } else {
#line 1243
          if (numargs < 32) {
#line 1243
            __cil_tmp___163 = numargs;
#line 1243
            numargs ++;
#line 1243
            __cil_tmp___164 = __builtin_va_arg(ap, int_ptr_t );
#line 1243
            args[__cil_tmp___163].val_int_ptr_t = __cil_tmp___164;
#line 1243
            __cil_tmp___166 = __cil_tmp___164;
          } else {
#line 1243
            __cil_tmp___165 = __builtin_va_arg(ap, int_ptr_t );
#line 1243
            __cil_tmp___166 = __cil_tmp___165;
          }
#line 1243
          __cil_tmp___167 = __cil_tmp___166;
        }
#line 1243
        __cil_tmp___169 = __cil_tmp___167;
      }
#line 1243
      *__cil_tmp___169 = ret;
    }
#line 1244
    goto __Cont;
    case 79: 
#line 1246
    flags |= 16;
    case 111: 
#line 1249
    if (flags & 32) {
#line 1249
      if (is_pos_arg) {
#line 1249
        if (N < numargs) {
#line 1249
          __cil_tmp___171 = args[N].val_u_quad_t;
        } else {
#line 1249
          __cil_tmp___170 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1249
          __cil_tmp___171 = __cil_tmp___170->val_u_quad_t;
        }
#line 1249
        __cil_tmp___179 = __cil_tmp___171;
      } else {
#line 1249
        __cil_tmp___178 = arg_index;
#line 1249
        arg_index ++;
#line 1249
        if (__cil_tmp___178 < numargs) {
#line 1249
          __cil_tmp___177 = args[N].val_u_quad_t;
        } else {
#line 1249
          if (numargs < 32) {
#line 1249
            __cil_tmp___173 = numargs;
#line 1249
            numargs ++;
#line 1249
            __cil_tmp___174 = __builtin_va_arg(ap, unsigned long long );
#line 1249
            args[__cil_tmp___173].val_u_quad_t = __cil_tmp___174;
#line 1249
            __cil_tmp___176 = __cil_tmp___174;
          } else {
#line 1249
            __cil_tmp___175 = __builtin_va_arg(ap, unsigned long long );
#line 1249
            __cil_tmp___176 = __cil_tmp___175;
          }
#line 1249
          __cil_tmp___177 = __cil_tmp___176;
        }
#line 1249
        __cil_tmp___179 = __cil_tmp___177;
      }
#line 1249
      _uquad = __cil_tmp___179;
    } else {
#line 1249
      if (flags & 16) {
#line 1249
        if (is_pos_arg) {
#line 1249
          if (N < numargs) {
#line 1249
            __cil_tmp___181 = args[N].val_u_long;
          } else {
#line 1249
            __cil_tmp___180 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                          arg_type, & saved_fmt);
#line 1249
            __cil_tmp___181 = __cil_tmp___180->val_u_long;
          }
#line 1249
          __cil_tmp___189 = __cil_tmp___181;
        } else {
#line 1249
          __cil_tmp___188 = arg_index;
#line 1249
          arg_index ++;
#line 1249
          if (__cil_tmp___188 < numargs) {
#line 1249
            __cil_tmp___187 = args[N].val_u_long;
          } else {
#line 1249
            if (numargs < 32) {
#line 1249
              __cil_tmp___183 = numargs;
#line 1249
              numargs ++;
#line 1249
              __cil_tmp___184 = __builtin_va_arg(ap, u_long );
#line 1249
              args[__cil_tmp___183].val_u_long = __cil_tmp___184;
#line 1249
              __cil_tmp___186 = __cil_tmp___184;
            } else {
#line 1249
              __cil_tmp___185 = __builtin_va_arg(ap, u_long );
#line 1249
              __cil_tmp___186 = __cil_tmp___185;
            }
#line 1249
            __cil_tmp___187 = __cil_tmp___186;
          }
#line 1249
          __cil_tmp___189 = __cil_tmp___187;
        }
#line 1249
        __cil_tmp___222 = __cil_tmp___189;
      } else {
#line 1249
        if (flags & 64) {
#line 1249
          if (is_pos_arg) {
#line 1249
            if (N < numargs) {
#line 1249
              __cil_tmp___191 = args[N].val_int;
            } else {
#line 1249
              __cil_tmp___190 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                            args, arg_type, & saved_fmt);
#line 1249
              __cil_tmp___191 = __cil_tmp___190->val_int;
            }
#line 1249
            __cil_tmp___199 = __cil_tmp___191;
          } else {
#line 1249
            __cil_tmp___198 = arg_index;
#line 1249
            arg_index ++;
#line 1249
            if (__cil_tmp___198 < numargs) {
#line 1249
              __cil_tmp___197 = args[N].val_int;
            } else {
#line 1249
              if (numargs < 32) {
#line 1249
                __cil_tmp___193 = numargs;
#line 1249
                numargs ++;
#line 1249
                __cil_tmp___194 = __builtin_va_arg(ap, int );
#line 1249
                args[__cil_tmp___193].val_int = __cil_tmp___194;
#line 1249
                __cil_tmp___196 = __cil_tmp___194;
              } else {
#line 1249
                __cil_tmp___195 = __builtin_va_arg(ap, int );
#line 1249
                __cil_tmp___196 = __cil_tmp___195;
              }
#line 1249
              __cil_tmp___197 = __cil_tmp___196;
            }
#line 1249
            __cil_tmp___199 = __cil_tmp___197;
          }
#line 1249
          __cil_tmp___221 = (unsigned long )((unsigned short )__cil_tmp___199);
        } else {
#line 1249
          if (flags & 512) {
#line 1249
            if (is_pos_arg) {
#line 1249
              if (N < numargs) {
#line 1249
                __cil_tmp___201 = args[N].val_int;
              } else {
#line 1249
                __cil_tmp___200 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                              args, arg_type, & saved_fmt);
#line 1249
                __cil_tmp___201 = __cil_tmp___200->val_int;
              }
#line 1249
              __cil_tmp___209 = __cil_tmp___201;
            } else {
#line 1249
              __cil_tmp___208 = arg_index;
#line 1249
              arg_index ++;
#line 1249
              if (__cil_tmp___208 < numargs) {
#line 1249
                __cil_tmp___207 = args[N].val_int;
              } else {
#line 1249
                if (numargs < 32) {
#line 1249
                  __cil_tmp___203 = numargs;
#line 1249
                  numargs ++;
#line 1249
                  __cil_tmp___204 = __builtin_va_arg(ap, int );
#line 1249
                  args[__cil_tmp___203].val_int = __cil_tmp___204;
#line 1249
                  __cil_tmp___206 = __cil_tmp___204;
                } else {
#line 1249
                  __cil_tmp___205 = __builtin_va_arg(ap, int );
#line 1249
                  __cil_tmp___206 = __cil_tmp___205;
                }
#line 1249
                __cil_tmp___207 = __cil_tmp___206;
              }
#line 1249
              __cil_tmp___209 = __cil_tmp___207;
            }
#line 1249
            __cil_tmp___220 = (unsigned long )((unsigned char )__cil_tmp___209);
          } else {
#line 1249
            if (is_pos_arg) {
#line 1249
              if (N < numargs) {
#line 1249
                __cil_tmp___211 = args[N].val_u_int;
              } else {
#line 1249
                __cil_tmp___210 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                              args, arg_type, & saved_fmt);
#line 1249
                __cil_tmp___211 = __cil_tmp___210->val_u_int;
              }
#line 1249
              __cil_tmp___219 = __cil_tmp___211;
            } else {
#line 1249
              __cil_tmp___218 = arg_index;
#line 1249
              arg_index ++;
#line 1249
              if (__cil_tmp___218 < numargs) {
#line 1249
                __cil_tmp___217 = args[N].val_u_int;
              } else {
#line 1249
                if (numargs < 32) {
#line 1249
                  __cil_tmp___213 = numargs;
#line 1249
                  numargs ++;
#line 1249
                  __cil_tmp___214 = __builtin_va_arg(ap, u_int );
#line 1249
                  args[__cil_tmp___213].val_u_int = __cil_tmp___214;
#line 1249
                  __cil_tmp___216 = __cil_tmp___214;
                } else {
#line 1249
                  __cil_tmp___215 = __builtin_va_arg(ap, u_int );
#line 1249
                  __cil_tmp___216 = __cil_tmp___215;
                }
#line 1249
                __cil_tmp___217 = __cil_tmp___216;
              }
#line 1249
              __cil_tmp___219 = __cil_tmp___217;
            }
#line 1249
            __cil_tmp___220 = (unsigned long )__cil_tmp___219;
          }
#line 1249
          __cil_tmp___221 = __cil_tmp___220;
        }
#line 1249
        __cil_tmp___222 = __cil_tmp___221;
      }
#line 1249
      _uquad = (unsigned long long )__cil_tmp___222;
    }
#line 1250
    base = (enum __anonenum_base_22 )0;
#line 1252
    flags &= -1025;
#line 1254
    goto nosign;
    case 112: 
#line 1264
    if (is_pos_arg) {
#line 1264
      if (N < numargs) {
#line 1264
        __cil_tmp___224 = args[N].val_void_ptr_t;
      } else {
#line 1264
        __cil_tmp___223 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                      arg_type, & saved_fmt);
#line 1264
        __cil_tmp___224 = __cil_tmp___223->val_void_ptr_t;
      }
#line 1264
      __cil_tmp___232 = __cil_tmp___224;
    } else {
#line 1264
      __cil_tmp___231 = arg_index;
#line 1264
      arg_index ++;
#line 1264
      if (__cil_tmp___231 < numargs) {
#line 1264
        __cil_tmp___230 = args[N].val_void_ptr_t;
      } else {
#line 1264
        if (numargs < 32) {
#line 1264
          __cil_tmp___226 = numargs;
#line 1264
          numargs ++;
#line 1264
          __cil_tmp___227 = __builtin_va_arg(ap, void_ptr_t );
#line 1264
          args[__cil_tmp___226].val_void_ptr_t = __cil_tmp___227;
#line 1264
          __cil_tmp___229 = __cil_tmp___227;
        } else {
#line 1264
          __cil_tmp___228 = __builtin_va_arg(ap, void_ptr_t );
#line 1264
          __cil_tmp___229 = __cil_tmp___228;
        }
#line 1264
        __cil_tmp___230 = __cil_tmp___229;
      }
#line 1264
      __cil_tmp___232 = __cil_tmp___230;
    }
#line 1264
    _uquad = (unsigned long long )((unsigned long )__cil_tmp___232);
#line 1265
    base = (enum __anonenum_base_22 )2;
#line 1266
    xdigs = (char *)"0123456789abcdef";
#line 1267
    flags |= 2;
#line 1268
    ox[0] = (char )'0';
#line 1269
    ch = 'x';
#line 1269
    ox[1] = (char )ch;
#line 1270
    goto nosign;
    case 115: 
    case 83: 
#line 1275
    sign = (char )'\000';
#line 1276
    if (is_pos_arg) {
#line 1276
      if (N < numargs) {
#line 1276
        __cil_tmp___234 = args[N].val_char_ptr_t;
      } else {
#line 1276
        __cil_tmp___233 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                      arg_type, & saved_fmt);
#line 1276
        __cil_tmp___234 = __cil_tmp___233->val_char_ptr_t;
      }
#line 1276
      cp = __cil_tmp___234;
    } else {
#line 1276
      __cil_tmp___241 = arg_index;
#line 1276
      arg_index ++;
#line 1276
      if (__cil_tmp___241 < numargs) {
#line 1276
        __cil_tmp___240 = args[N].val_char_ptr_t;
      } else {
#line 1276
        if (numargs < 32) {
#line 1276
          __cil_tmp___236 = numargs;
#line 1276
          numargs ++;
#line 1276
          __cil_tmp___237 = __builtin_va_arg(ap, char_ptr_t );
#line 1276
          args[__cil_tmp___236].val_char_ptr_t = __cil_tmp___237;
#line 1276
          __cil_tmp___239 = __cil_tmp___237;
        } else {
#line 1276
          __cil_tmp___238 = __builtin_va_arg(ap, char_ptr_t );
#line 1276
          __cil_tmp___239 = __cil_tmp___238;
        }
#line 1276
        __cil_tmp___240 = __cil_tmp___239;
      }
#line 1276
      cp = __cil_tmp___240;
    }
#line 1282
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1283
      cp = (char *)"(null)";
#line 1284
      size = (unsigned int )prec > 6U ? 6 : prec;
    } else
#line 1351
    if (prec >= 0) {
#line 1357
      __cil_tmp___242 = memchr((void const   *)cp, 0, (unsigned int )prec);
#line 1357
      p = (char *)__cil_tmp___242;
#line 1359
      if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 1360
        size = p - cp;
#line 1361
        if (size > prec) {
#line 1362
          size = prec;
        }
      } else {
#line 1364
        size = prec;
      }
    } else {
#line 1366
      __cil_tmp___243 = strlen((char const   *)cp);
#line 1366
      size = (int )__cil_tmp___243;
    }
#line 1368
    break;
    case 85: 
#line 1370
    flags |= 16;
    case 117: 
#line 1373
    if (flags & 32) {
#line 1373
      if (is_pos_arg) {
#line 1373
        if (N < numargs) {
#line 1373
          __cil_tmp___245 = args[N].val_u_quad_t;
        } else {
#line 1373
          __cil_tmp___244 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1373
          __cil_tmp___245 = __cil_tmp___244->val_u_quad_t;
        }
#line 1373
        __cil_tmp___253 = __cil_tmp___245;
      } else {
#line 1373
        __cil_tmp___252 = arg_index;
#line 1373
        arg_index ++;
#line 1373
        if (__cil_tmp___252 < numargs) {
#line 1373
          __cil_tmp___251 = args[N].val_u_quad_t;
        } else {
#line 1373
          if (numargs < 32) {
#line 1373
            __cil_tmp___247 = numargs;
#line 1373
            numargs ++;
#line 1373
            __cil_tmp___248 = __builtin_va_arg(ap, unsigned long long );
#line 1373
            args[__cil_tmp___247].val_u_quad_t = __cil_tmp___248;
#line 1373
            __cil_tmp___250 = __cil_tmp___248;
          } else {
#line 1373
            __cil_tmp___249 = __builtin_va_arg(ap, unsigned long long );
#line 1373
            __cil_tmp___250 = __cil_tmp___249;
          }
#line 1373
          __cil_tmp___251 = __cil_tmp___250;
        }
#line 1373
        __cil_tmp___253 = __cil_tmp___251;
      }
#line 1373
      _uquad = __cil_tmp___253;
    } else {
#line 1373
      if (flags & 16) {
#line 1373
        if (is_pos_arg) {
#line 1373
          if (N < numargs) {
#line 1373
            __cil_tmp___255 = args[N].val_u_long;
          } else {
#line 1373
            __cil_tmp___254 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                          arg_type, & saved_fmt);
#line 1373
            __cil_tmp___255 = __cil_tmp___254->val_u_long;
          }
#line 1373
          __cil_tmp___263 = __cil_tmp___255;
        } else {
#line 1373
          __cil_tmp___262 = arg_index;
#line 1373
          arg_index ++;
#line 1373
          if (__cil_tmp___262 < numargs) {
#line 1373
            __cil_tmp___261 = args[N].val_u_long;
          } else {
#line 1373
            if (numargs < 32) {
#line 1373
              __cil_tmp___257 = numargs;
#line 1373
              numargs ++;
#line 1373
              __cil_tmp___258 = __builtin_va_arg(ap, u_long );
#line 1373
              args[__cil_tmp___257].val_u_long = __cil_tmp___258;
#line 1373
              __cil_tmp___260 = __cil_tmp___258;
            } else {
#line 1373
              __cil_tmp___259 = __builtin_va_arg(ap, u_long );
#line 1373
              __cil_tmp___260 = __cil_tmp___259;
            }
#line 1373
            __cil_tmp___261 = __cil_tmp___260;
          }
#line 1373
          __cil_tmp___263 = __cil_tmp___261;
        }
#line 1373
        __cil_tmp___296 = __cil_tmp___263;
      } else {
#line 1373
        if (flags & 64) {
#line 1373
          if (is_pos_arg) {
#line 1373
            if (N < numargs) {
#line 1373
              __cil_tmp___265 = args[N].val_int;
            } else {
#line 1373
              __cil_tmp___264 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                            args, arg_type, & saved_fmt);
#line 1373
              __cil_tmp___265 = __cil_tmp___264->val_int;
            }
#line 1373
            __cil_tmp___273 = __cil_tmp___265;
          } else {
#line 1373
            __cil_tmp___272 = arg_index;
#line 1373
            arg_index ++;
#line 1373
            if (__cil_tmp___272 < numargs) {
#line 1373
              __cil_tmp___271 = args[N].val_int;
            } else {
#line 1373
              if (numargs < 32) {
#line 1373
                __cil_tmp___267 = numargs;
#line 1373
                numargs ++;
#line 1373
                __cil_tmp___268 = __builtin_va_arg(ap, int );
#line 1373
                args[__cil_tmp___267].val_int = __cil_tmp___268;
#line 1373
                __cil_tmp___270 = __cil_tmp___268;
              } else {
#line 1373
                __cil_tmp___269 = __builtin_va_arg(ap, int );
#line 1373
                __cil_tmp___270 = __cil_tmp___269;
              }
#line 1373
              __cil_tmp___271 = __cil_tmp___270;
            }
#line 1373
            __cil_tmp___273 = __cil_tmp___271;
          }
#line 1373
          __cil_tmp___295 = (unsigned long )((unsigned short )__cil_tmp___273);
        } else {
#line 1373
          if (flags & 512) {
#line 1373
            if (is_pos_arg) {
#line 1373
              if (N < numargs) {
#line 1373
                __cil_tmp___275 = args[N].val_int;
              } else {
#line 1373
                __cil_tmp___274 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                              args, arg_type, & saved_fmt);
#line 1373
                __cil_tmp___275 = __cil_tmp___274->val_int;
              }
#line 1373
              __cil_tmp___283 = __cil_tmp___275;
            } else {
#line 1373
              __cil_tmp___282 = arg_index;
#line 1373
              arg_index ++;
#line 1373
              if (__cil_tmp___282 < numargs) {
#line 1373
                __cil_tmp___281 = args[N].val_int;
              } else {
#line 1373
                if (numargs < 32) {
#line 1373
                  __cil_tmp___277 = numargs;
#line 1373
                  numargs ++;
#line 1373
                  __cil_tmp___278 = __builtin_va_arg(ap, int );
#line 1373
                  args[__cil_tmp___277].val_int = __cil_tmp___278;
#line 1373
                  __cil_tmp___280 = __cil_tmp___278;
                } else {
#line 1373
                  __cil_tmp___279 = __builtin_va_arg(ap, int );
#line 1373
                  __cil_tmp___280 = __cil_tmp___279;
                }
#line 1373
                __cil_tmp___281 = __cil_tmp___280;
              }
#line 1373
              __cil_tmp___283 = __cil_tmp___281;
            }
#line 1373
            __cil_tmp___294 = (unsigned long )((unsigned char )__cil_tmp___283);
          } else {
#line 1373
            if (is_pos_arg) {
#line 1373
              if (N < numargs) {
#line 1373
                __cil_tmp___285 = args[N].val_u_int;
              } else {
#line 1373
                __cil_tmp___284 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                              args, arg_type, & saved_fmt);
#line 1373
                __cil_tmp___285 = __cil_tmp___284->val_u_int;
              }
#line 1373
              __cil_tmp___293 = __cil_tmp___285;
            } else {
#line 1373
              __cil_tmp___292 = arg_index;
#line 1373
              arg_index ++;
#line 1373
              if (__cil_tmp___292 < numargs) {
#line 1373
                __cil_tmp___291 = args[N].val_u_int;
              } else {
#line 1373
                if (numargs < 32) {
#line 1373
                  __cil_tmp___287 = numargs;
#line 1373
                  numargs ++;
#line 1373
                  __cil_tmp___288 = __builtin_va_arg(ap, u_int );
#line 1373
                  args[__cil_tmp___287].val_u_int = __cil_tmp___288;
#line 1373
                  __cil_tmp___290 = __cil_tmp___288;
                } else {
#line 1373
                  __cil_tmp___289 = __builtin_va_arg(ap, u_int );
#line 1373
                  __cil_tmp___290 = __cil_tmp___289;
                }
#line 1373
                __cil_tmp___291 = __cil_tmp___290;
              }
#line 1373
              __cil_tmp___293 = __cil_tmp___291;
            }
#line 1373
            __cil_tmp___294 = (unsigned long )__cil_tmp___293;
          }
#line 1373
          __cil_tmp___295 = __cil_tmp___294;
        }
#line 1373
        __cil_tmp___296 = __cil_tmp___295;
      }
#line 1373
      _uquad = (unsigned long long )__cil_tmp___296;
    }
#line 1374
    base = (enum __anonenum_base_22 )1;
#line 1375
    goto nosign;
    case 88: 
#line 1377
    xdigs = (char *)"0123456789ABCDEF";
#line 1378
    goto hex;
    case 120: 
#line 1380
    xdigs = (char *)"0123456789abcdef";
    hex: 
#line 1381
    if (flags & 32) {
#line 1381
      if (is_pos_arg) {
#line 1381
        if (N < numargs) {
#line 1381
          __cil_tmp___298 = args[N].val_u_quad_t;
        } else {
#line 1381
          __cil_tmp___297 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1381
          __cil_tmp___298 = __cil_tmp___297->val_u_quad_t;
        }
#line 1381
        __cil_tmp___306 = __cil_tmp___298;
      } else {
#line 1381
        __cil_tmp___305 = arg_index;
#line 1381
        arg_index ++;
#line 1381
        if (__cil_tmp___305 < numargs) {
#line 1381
          __cil_tmp___304 = args[N].val_u_quad_t;
        } else {
#line 1381
          if (numargs < 32) {
#line 1381
            __cil_tmp___300 = numargs;
#line 1381
            numargs ++;
#line 1381
            __cil_tmp___301 = __builtin_va_arg(ap, unsigned long long );
#line 1381
            args[__cil_tmp___300].val_u_quad_t = __cil_tmp___301;
#line 1381
            __cil_tmp___303 = __cil_tmp___301;
          } else {
#line 1381
            __cil_tmp___302 = __builtin_va_arg(ap, unsigned long long );
#line 1381
            __cil_tmp___303 = __cil_tmp___302;
          }
#line 1381
          __cil_tmp___304 = __cil_tmp___303;
        }
#line 1381
        __cil_tmp___306 = __cil_tmp___304;
      }
#line 1381
      _uquad = __cil_tmp___306;
    } else {
#line 1381
      if (flags & 16) {
#line 1381
        if (is_pos_arg) {
#line 1381
          if (N < numargs) {
#line 1381
            __cil_tmp___308 = args[N].val_u_long;
          } else {
#line 1381
            __cil_tmp___307 = get_arg___3(data, N, fmt_anchor, & ap, & numargs, args,
                                          arg_type, & saved_fmt);
#line 1381
            __cil_tmp___308 = __cil_tmp___307->val_u_long;
          }
#line 1381
          __cil_tmp___316 = __cil_tmp___308;
        } else {
#line 1381
          __cil_tmp___315 = arg_index;
#line 1381
          arg_index ++;
#line 1381
          if (__cil_tmp___315 < numargs) {
#line 1381
            __cil_tmp___314 = args[N].val_u_long;
          } else {
#line 1381
            if (numargs < 32) {
#line 1381
              __cil_tmp___310 = numargs;
#line 1381
              numargs ++;
#line 1381
              __cil_tmp___311 = __builtin_va_arg(ap, u_long );
#line 1381
              args[__cil_tmp___310].val_u_long = __cil_tmp___311;
#line 1381
              __cil_tmp___313 = __cil_tmp___311;
            } else {
#line 1381
              __cil_tmp___312 = __builtin_va_arg(ap, u_long );
#line 1381
              __cil_tmp___313 = __cil_tmp___312;
            }
#line 1381
            __cil_tmp___314 = __cil_tmp___313;
          }
#line 1381
          __cil_tmp___316 = __cil_tmp___314;
        }
#line 1381
        __cil_tmp___349 = __cil_tmp___316;
      } else {
#line 1381
        if (flags & 64) {
#line 1381
          if (is_pos_arg) {
#line 1381
            if (N < numargs) {
#line 1381
              __cil_tmp___318 = args[N].val_int;
            } else {
#line 1381
              __cil_tmp___317 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                            args, arg_type, & saved_fmt);
#line 1381
              __cil_tmp___318 = __cil_tmp___317->val_int;
            }
#line 1381
            __cil_tmp___326 = __cil_tmp___318;
          } else {
#line 1381
            __cil_tmp___325 = arg_index;
#line 1381
            arg_index ++;
#line 1381
            if (__cil_tmp___325 < numargs) {
#line 1381
              __cil_tmp___324 = args[N].val_int;
            } else {
#line 1381
              if (numargs < 32) {
#line 1381
                __cil_tmp___320 = numargs;
#line 1381
                numargs ++;
#line 1381
                __cil_tmp___321 = __builtin_va_arg(ap, int );
#line 1381
                args[__cil_tmp___320].val_int = __cil_tmp___321;
#line 1381
                __cil_tmp___323 = __cil_tmp___321;
              } else {
#line 1381
                __cil_tmp___322 = __builtin_va_arg(ap, int );
#line 1381
                __cil_tmp___323 = __cil_tmp___322;
              }
#line 1381
              __cil_tmp___324 = __cil_tmp___323;
            }
#line 1381
            __cil_tmp___326 = __cil_tmp___324;
          }
#line 1381
          __cil_tmp___348 = (unsigned long )((unsigned short )__cil_tmp___326);
        } else {
#line 1381
          if (flags & 512) {
#line 1381
            if (is_pos_arg) {
#line 1381
              if (N < numargs) {
#line 1381
                __cil_tmp___328 = args[N].val_int;
              } else {
#line 1381
                __cil_tmp___327 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                              args, arg_type, & saved_fmt);
#line 1381
                __cil_tmp___328 = __cil_tmp___327->val_int;
              }
#line 1381
              __cil_tmp___336 = __cil_tmp___328;
            } else {
#line 1381
              __cil_tmp___335 = arg_index;
#line 1381
              arg_index ++;
#line 1381
              if (__cil_tmp___335 < numargs) {
#line 1381
                __cil_tmp___334 = args[N].val_int;
              } else {
#line 1381
                if (numargs < 32) {
#line 1381
                  __cil_tmp___330 = numargs;
#line 1381
                  numargs ++;
#line 1381
                  __cil_tmp___331 = __builtin_va_arg(ap, int );
#line 1381
                  args[__cil_tmp___330].val_int = __cil_tmp___331;
#line 1381
                  __cil_tmp___333 = __cil_tmp___331;
                } else {
#line 1381
                  __cil_tmp___332 = __builtin_va_arg(ap, int );
#line 1381
                  __cil_tmp___333 = __cil_tmp___332;
                }
#line 1381
                __cil_tmp___334 = __cil_tmp___333;
              }
#line 1381
              __cil_tmp___336 = __cil_tmp___334;
            }
#line 1381
            __cil_tmp___347 = (unsigned long )((unsigned char )__cil_tmp___336);
          } else {
#line 1381
            if (is_pos_arg) {
#line 1381
              if (N < numargs) {
#line 1381
                __cil_tmp___338 = args[N].val_u_int;
              } else {
#line 1381
                __cil_tmp___337 = get_arg___3(data, N, fmt_anchor, & ap, & numargs,
                                              args, arg_type, & saved_fmt);
#line 1381
                __cil_tmp___338 = __cil_tmp___337->val_u_int;
              }
#line 1381
              __cil_tmp___346 = __cil_tmp___338;
            } else {
#line 1381
              __cil_tmp___345 = arg_index;
#line 1381
              arg_index ++;
#line 1381
              if (__cil_tmp___345 < numargs) {
#line 1381
                __cil_tmp___344 = args[N].val_u_int;
              } else {
#line 1381
                if (numargs < 32) {
#line 1381
                  __cil_tmp___340 = numargs;
#line 1381
                  numargs ++;
#line 1381
                  __cil_tmp___341 = __builtin_va_arg(ap, u_int );
#line 1381
                  args[__cil_tmp___340].val_u_int = __cil_tmp___341;
#line 1381
                  __cil_tmp___343 = __cil_tmp___341;
                } else {
#line 1381
                  __cil_tmp___342 = __builtin_va_arg(ap, u_int );
#line 1381
                  __cil_tmp___343 = __cil_tmp___342;
                }
#line 1381
                __cil_tmp___344 = __cil_tmp___343;
              }
#line 1381
              __cil_tmp___346 = __cil_tmp___344;
            }
#line 1381
            __cil_tmp___347 = (unsigned long )__cil_tmp___346;
          }
#line 1381
          __cil_tmp___348 = __cil_tmp___347;
        }
#line 1381
        __cil_tmp___349 = __cil_tmp___348;
      }
#line 1381
      _uquad = (unsigned long long )__cil_tmp___349;
    }
#line 1382
    base = (enum __anonenum_base_22 )2;
#line 1384
    if (flags & 1 && _uquad != 0ULL) {
#line 1385
      ox[0] = (char )'0';
#line 1386
      ox[1] = (char )ch;
#line 1387
      flags |= 2;
    }
#line 1391
    flags &= -1025;
    nosign: 
#line 1394
    sign = (char )'\000';
    number: 
#line 1400
    dprec = prec;
#line 1400
    if (dprec >= 0) {
#line 1401
      flags &= -129;
    }
#line 1408
    cp = buf + 100;
#line 1409
    if (_uquad != 0ULL || prec != 0) {
#line 1415
      switch ((int )base) {
      case 0: 
#line 1417
      while (1) {
#line 1418
        cp --;
#line 1418
        *cp = (char )((_uquad & 7ULL) + 48ULL);
#line 1419
        _uquad >>= 3;
#line 1417
        if (! _uquad) {
#line 1417
          break;
        }
      }
#line 1422
      if (flags & 1 && (int )*cp != 48) {
#line 1423
        cp --;
#line 1423
        *cp = (char )'0';
      }
#line 1424
      break;
      case 1: 
#line 1428
      if (_uquad < 10ULL) {
#line 1429
        cp --;
#line 1429
        *cp = (char )(_uquad + 48ULL);
#line 1430
        break;
      }
#line 1433
      ndig = 0;
#line 1435
      while (1) {
#line 1436
        cp --;
#line 1436
        *cp = (char )(_uquad % 10ULL + 48ULL);
#line 1438
        ndig ++;
#line 1441
        if (((flags & 1024 && ndig == (int )*grouping) && (int const   )*grouping != 127) && _uquad > 9ULL) {
#line 1445
          cp -= thsnd_len;
#line 1446
          strncpy(cp, (char const   *)thousands_sep, thsnd_len);
#line 1448
          ndig = 0;
#line 1453
          if ((int const   )*(grouping + 1) != 0) {
#line 1454
            grouping ++;
          }
        }
#line 1457
        _uquad /= 10ULL;
#line 1435
        if (! (_uquad != 0ULL)) {
#line 1435
          break;
        }
      }
#line 1459
      break;
      case 2: 
#line 1462
      while (1) {
#line 1463
        cp --;
#line 1463
        *cp = *(xdigs + (_uquad & 15ULL));
#line 1464
        _uquad >>= 4;
#line 1462
        if (! _uquad) {
#line 1462
          break;
        }
      }
#line 1466
      break;
      default: 
#line 1469
      cp = (char *)"bug in vfprintf: bad base";
#line 1470
      __cil_tmp___350 = strlen((char const   *)cp);
#line 1470
      size = (int )__cil_tmp___350;
#line 1471
      goto skipsize;
      }
    } else
#line 1483
    if ((unsigned int )base == 0U && flags & 1) {
#line 1484
      cp --;
#line 1484
      *cp = (char )'0';
    }
#line 1486
    size = (buf + 100) - cp;
    skipsize: 
#line 1488
    break;
    default: 
#line 1490
    if (ch == 0) {
#line 1491
      goto done;
    }
#line 1493
    cp = buf;
#line 1494
    *cp = (char )ch;
#line 1495
    size = 1;
#line 1496
    sign = (char )'\000';
#line 1497
    break;
    }
#line 1515
    realsz = dprec > size ? dprec : size;
#line 1516
    if (sign) {
#line 1517
      realsz ++;
    }
#line 1518
    if (flags & 2) {
#line 1519
      realsz += 2;
    }
#line 1522
    if ((flags & 132) == 0) {
#line 1523
      n = width - realsz;
#line 1523
      if (n > 0) {
#line 1523
        while (n > 16) {
#line 1523
          iovp->iov_base = (void const   *)(blanks___1);
#line 1523
          iovp->iov_len = 16U;
#line 1523
          uio.uio_resid += 16;
#line 1523
          iovp ++;
#line 1523
          (uio.uio_iovcnt) ++;
#line 1523
          if (uio.uio_iovcnt >= 8) {
#line 1523
            __cil_tmp___351 = __ssprint_r(data, fp, & uio);
#line 1523
            if (__cil_tmp___351) {
#line 1523
              goto error;
            }
#line 1523
            iovp = iov;
          }
#line 1523
          n -= 16;
        }
#line 1523
        iovp->iov_base = (void const   *)(blanks___1);
#line 1523
        iovp->iov_len = (unsigned int )n;
#line 1523
        uio.uio_resid += n;
#line 1523
        iovp ++;
#line 1523
        (uio.uio_iovcnt) ++;
#line 1523
        if (uio.uio_iovcnt >= 8) {
#line 1523
          __cil_tmp___352 = __ssprint_r(data, fp, & uio);
#line 1523
          if (__cil_tmp___352) {
#line 1523
            goto error;
          }
#line 1523
          iovp = iov;
        }
      }
    }
#line 1526
    if (sign) {
#line 1527
      iovp->iov_base = (void const   *)(& sign);
#line 1527
      iovp->iov_len = 1U;
#line 1527
      (uio.uio_resid) ++;
#line 1527
      iovp ++;
#line 1527
      (uio.uio_iovcnt) ++;
#line 1527
      if (uio.uio_iovcnt >= 8) {
#line 1527
        __cil_tmp___353 = __ssprint_r(data, fp, & uio);
#line 1527
        if (__cil_tmp___353) {
#line 1527
          goto error;
        }
#line 1527
        iovp = iov;
      }
    }
#line 1528
    if (flags & 2) {
#line 1529
      iovp->iov_base = (void const   *)(ox);
#line 1529
      iovp->iov_len = 2U;
#line 1529
      uio.uio_resid += 2;
#line 1529
      iovp ++;
#line 1529
      (uio.uio_iovcnt) ++;
#line 1529
      if (uio.uio_iovcnt >= 8) {
#line 1529
        __cil_tmp___354 = __ssprint_r(data, fp, & uio);
#line 1529
        if (__cil_tmp___354) {
#line 1529
          goto error;
        }
#line 1529
        iovp = iov;
      }
    }
#line 1532
    if ((flags & 132) == 128) {
#line 1533
      n = width - realsz;
#line 1533
      if (n > 0) {
#line 1533
        while (n > 16) {
#line 1533
          iovp->iov_base = (void const   *)(zeroes___1);
#line 1533
          iovp->iov_len = 16U;
#line 1533
          uio.uio_resid += 16;
#line 1533
          iovp ++;
#line 1533
          (uio.uio_iovcnt) ++;
#line 1533
          if (uio.uio_iovcnt >= 8) {
#line 1533
            __cil_tmp___355 = __ssprint_r(data, fp, & uio);
#line 1533
            if (__cil_tmp___355) {
#line 1533
              goto error;
            }
#line 1533
            iovp = iov;
          }
#line 1533
          n -= 16;
        }
#line 1533
        iovp->iov_base = (void const   *)(zeroes___1);
#line 1533
        iovp->iov_len = (unsigned int )n;
#line 1533
        uio.uio_resid += n;
#line 1533
        iovp ++;
#line 1533
        (uio.uio_iovcnt) ++;
#line 1533
        if (uio.uio_iovcnt >= 8) {
#line 1533
          __cil_tmp___356 = __ssprint_r(data, fp, & uio);
#line 1533
          if (__cil_tmp___356) {
#line 1533
            goto error;
          }
#line 1533
          iovp = iov;
        }
      }
    }
#line 1536
    n = dprec - size;
#line 1536
    if (n > 0) {
#line 1536
      while (n > 16) {
#line 1536
        iovp->iov_base = (void const   *)(zeroes___1);
#line 1536
        iovp->iov_len = 16U;
#line 1536
        uio.uio_resid += 16;
#line 1536
        iovp ++;
#line 1536
        (uio.uio_iovcnt) ++;
#line 1536
        if (uio.uio_iovcnt >= 8) {
#line 1536
          __cil_tmp___357 = __ssprint_r(data, fp, & uio);
#line 1536
          if (__cil_tmp___357) {
#line 1536
            goto error;
          }
#line 1536
          iovp = iov;
        }
#line 1536
        n -= 16;
      }
#line 1536
      iovp->iov_base = (void const   *)(zeroes___1);
#line 1536
      iovp->iov_len = (unsigned int )n;
#line 1536
      uio.uio_resid += n;
#line 1536
      iovp ++;
#line 1536
      (uio.uio_iovcnt) ++;
#line 1536
      if (uio.uio_iovcnt >= 8) {
#line 1536
        __cil_tmp___358 = __ssprint_r(data, fp, & uio);
#line 1536
        if (__cil_tmp___358) {
#line 1536
          goto error;
        }
#line 1536
        iovp = iov;
      }
    }
#line 1540
    if ((flags & 256) == 0) {
#line 1541
      iovp->iov_base = (void const   *)cp;
#line 1541
      iovp->iov_len = (unsigned int )size;
#line 1541
      uio.uio_resid += size;
#line 1541
      iovp ++;
#line 1541
      (uio.uio_iovcnt) ++;
#line 1541
      if (uio.uio_iovcnt >= 8) {
#line 1541
        __cil_tmp___359 = __ssprint_r(data, fp, & uio);
#line 1541
        if (__cil_tmp___359) {
#line 1541
          goto error;
        }
#line 1541
        iovp = iov;
      }
    } else
#line 1543
    if (ch >= 102) {
#line 1544
      if (_double_.fp == (double )0) {
#line 1546
        iovp->iov_base = (void const   *)"0";
#line 1546
        iovp->iov_len = 1U;
#line 1546
        (uio.uio_resid) ++;
#line 1546
        iovp ++;
#line 1546
        (uio.uio_iovcnt) ++;
#line 1546
        if (uio.uio_iovcnt >= 8) {
#line 1546
          __cil_tmp___360 = __ssprint_r(data, fp, & uio);
#line 1546
          if (__cil_tmp___360) {
#line 1546
            goto error;
          }
#line 1546
          iovp = iov;
        }
#line 1547
        if (expt < ndig || flags & 1) {
#line 1548
          iovp->iov_base = (void const   *)decimal_point;
#line 1548
          iovp->iov_len = decp_len;
#line 1548
          uio.uio_resid = (int )((unsigned int )uio.uio_resid + decp_len);
#line 1548
          iovp ++;
#line 1548
          (uio.uio_iovcnt) ++;
#line 1548
          if (uio.uio_iovcnt >= 8) {
#line 1548
            __cil_tmp___361 = __ssprint_r(data, fp, & uio);
#line 1548
            if (__cil_tmp___361) {
#line 1548
              goto error;
            }
#line 1548
            iovp = iov;
          }
#line 1549
          n = ndig - 1;
#line 1549
          if (n > 0) {
#line 1549
            while (n > 16) {
#line 1549
              iovp->iov_base = (void const   *)(zeroes___1);
#line 1549
              iovp->iov_len = 16U;
#line 1549
              uio.uio_resid += 16;
#line 1549
              iovp ++;
#line 1549
              (uio.uio_iovcnt) ++;
#line 1549
              if (uio.uio_iovcnt >= 8) {
#line 1549
                __cil_tmp___362 = __ssprint_r(data, fp, & uio);
#line 1549
                if (__cil_tmp___362) {
#line 1549
                  goto error;
                }
#line 1549
                iovp = iov;
              }
#line 1549
              n -= 16;
            }
#line 1549
            iovp->iov_base = (void const   *)(zeroes___1);
#line 1549
            iovp->iov_len = (unsigned int )n;
#line 1549
            uio.uio_resid += n;
#line 1549
            iovp ++;
#line 1549
            (uio.uio_iovcnt) ++;
#line 1549
            if (uio.uio_iovcnt >= 8) {
#line 1549
              __cil_tmp___363 = __ssprint_r(data, fp, & uio);
#line 1549
              if (__cil_tmp___363) {
#line 1549
                goto error;
              }
#line 1549
              iovp = iov;
            }
          }
        }
      } else
#line 1551
      if (expt <= 0) {
#line 1552
        iovp->iov_base = (void const   *)"0";
#line 1552
        iovp->iov_len = 1U;
#line 1552
        (uio.uio_resid) ++;
#line 1552
        iovp ++;
#line 1552
        (uio.uio_iovcnt) ++;
#line 1552
        if (uio.uio_iovcnt >= 8) {
#line 1552
          __cil_tmp___364 = __ssprint_r(data, fp, & uio);
#line 1552
          if (__cil_tmp___364) {
#line 1552
            goto error;
          }
#line 1552
          iovp = iov;
        }
#line 1553
        if ((expt || ndig) || flags & 1) {
#line 1554
          iovp->iov_base = (void const   *)decimal_point;
#line 1554
          iovp->iov_len = decp_len;
#line 1554
          uio.uio_resid = (int )((unsigned int )uio.uio_resid + decp_len);
#line 1554
          iovp ++;
#line 1554
          (uio.uio_iovcnt) ++;
#line 1554
          if (uio.uio_iovcnt >= 8) {
#line 1554
            __cil_tmp___365 = __ssprint_r(data, fp, & uio);
#line 1554
            if (__cil_tmp___365) {
#line 1554
              goto error;
            }
#line 1554
            iovp = iov;
          }
#line 1555
          n = - expt;
#line 1555
          if (n > 0) {
#line 1555
            while (n > 16) {
#line 1555
              iovp->iov_base = (void const   *)(zeroes___1);
#line 1555
              iovp->iov_len = 16U;
#line 1555
              uio.uio_resid += 16;
#line 1555
              iovp ++;
#line 1555
              (uio.uio_iovcnt) ++;
#line 1555
              if (uio.uio_iovcnt >= 8) {
#line 1555
                __cil_tmp___366 = __ssprint_r(data, fp, & uio);
#line 1555
                if (__cil_tmp___366) {
#line 1555
                  goto error;
                }
#line 1555
                iovp = iov;
              }
#line 1555
              n -= 16;
            }
#line 1555
            iovp->iov_base = (void const   *)(zeroes___1);
#line 1555
            iovp->iov_len = (unsigned int )n;
#line 1555
            uio.uio_resid += n;
#line 1555
            iovp ++;
#line 1555
            (uio.uio_iovcnt) ++;
#line 1555
            if (uio.uio_iovcnt >= 8) {
#line 1555
              __cil_tmp___367 = __ssprint_r(data, fp, & uio);
#line 1555
              if (__cil_tmp___367) {
#line 1555
                goto error;
              }
#line 1555
              iovp = iov;
            }
          }
#line 1556
          iovp->iov_base = (void const   *)cp;
#line 1556
          iovp->iov_len = (unsigned int )ndig;
#line 1556
          uio.uio_resid += ndig;
#line 1556
          iovp ++;
#line 1556
          (uio.uio_iovcnt) ++;
#line 1556
          if (uio.uio_iovcnt >= 8) {
#line 1556
            __cil_tmp___368 = __ssprint_r(data, fp, & uio);
#line 1556
            if (__cil_tmp___368) {
#line 1556
              goto error;
            }
#line 1556
            iovp = iov;
          }
        }
      } else {
#line 1559
        convbuf = cp;
#line 1560
        n___0 = (convbuf + ndig) - cp;
#line 1560
        if (n___0 > lead) {
#line 1560
          n___0 = lead;
        }
#line 1560
        if (n___0 > 0) {
#line 1560
          iovp->iov_base = (void const   *)cp;
#line 1560
          iovp->iov_len = (unsigned int )n___0;
#line 1560
          uio.uio_resid += n___0;
#line 1560
          iovp ++;
#line 1560
          (uio.uio_iovcnt) ++;
#line 1560
          if (uio.uio_iovcnt >= 8) {
#line 1560
            __cil_tmp___369 = __ssprint_r(data, fp, & uio);
#line 1560
            if (__cil_tmp___369) {
#line 1560
              goto error;
            }
#line 1560
            iovp = iov;
          }
        }
#line 1560
        n___0 = lead - (n___0 > 0 ? n___0 : 0);
#line 1560
        if (n___0 > 0) {
#line 1560
          while (n___0 > 16) {
#line 1560
            iovp->iov_base = (void const   *)(zeroes___1);
#line 1560
            iovp->iov_len = 16U;
#line 1560
            uio.uio_resid += 16;
#line 1560
            iovp ++;
#line 1560
            (uio.uio_iovcnt) ++;
#line 1560
            if (uio.uio_iovcnt >= 8) {
#line 1560
              __cil_tmp___370 = __ssprint_r(data, fp, & uio);
#line 1560
              if (__cil_tmp___370) {
#line 1560
                goto error;
              }
#line 1560
              iovp = iov;
            }
#line 1560
            n___0 -= 16;
          }
#line 1560
          iovp->iov_base = (void const   *)(zeroes___1);
#line 1560
          iovp->iov_len = (unsigned int )n___0;
#line 1560
          uio.uio_resid += n___0;
#line 1560
          iovp ++;
#line 1560
          (uio.uio_iovcnt) ++;
#line 1560
          if (uio.uio_iovcnt >= 8) {
#line 1560
            __cil_tmp___371 = __ssprint_r(data, fp, & uio);
#line 1560
            if (__cil_tmp___371) {
#line 1560
              goto error;
            }
#line 1560
            iovp = iov;
          }
        }
#line 1562
        cp += lead;
#line 1564
        if (flags & 1024) {
#line 1565
          while (nseps > 0 || nrepeats > 0) {
#line 1566
            if (nrepeats > 0) {
#line 1567
              nrepeats --;
            } else {
#line 1569
              grouping --;
#line 1570
              nseps --;
            }
#line 1572
            iovp->iov_base = (void const   *)thousands_sep;
#line 1572
            iovp->iov_len = thsnd_len;
#line 1572
            uio.uio_resid = (int )((unsigned int )uio.uio_resid + thsnd_len);
#line 1572
            iovp ++;
#line 1572
            (uio.uio_iovcnt) ++;
#line 1572
            if (uio.uio_iovcnt >= 8) {
#line 1572
              __cil_tmp___372 = __ssprint_r(data, fp, & uio);
#line 1572
              if (__cil_tmp___372) {
#line 1572
                goto error;
              }
#line 1572
              iovp = iov;
            }
#line 1573
            n___1 = (convbuf + ndig) - cp;
#line 1573
            if (n___1 > (int )*grouping) {
#line 1573
              n___1 = (int )*grouping;
            }
#line 1573
            if (n___1 > 0) {
#line 1573
              iovp->iov_base = (void const   *)cp;
#line 1573
              iovp->iov_len = (unsigned int )n___1;
#line 1573
              uio.uio_resid += n___1;
#line 1573
              iovp ++;
#line 1573
              (uio.uio_iovcnt) ++;
#line 1573
              if (uio.uio_iovcnt >= 8) {
#line 1573
                __cil_tmp___373 = __ssprint_r(data, fp, & uio);
#line 1573
                if (__cil_tmp___373) {
#line 1573
                  goto error;
                }
#line 1573
                iovp = iov;
              }
            }
#line 1573
            n___1 = (int )((int const   )*grouping - (int const   )(n___1 > 0 ? n___1 : 0));
#line 1573
            if (n___1 > 0) {
#line 1573
              while (n___1 > 16) {
#line 1573
                iovp->iov_base = (void const   *)(zeroes___1);
#line 1573
                iovp->iov_len = 16U;
#line 1573
                uio.uio_resid += 16;
#line 1573
                iovp ++;
#line 1573
                (uio.uio_iovcnt) ++;
#line 1573
                if (uio.uio_iovcnt >= 8) {
#line 1573
                  __cil_tmp___374 = __ssprint_r(data, fp, & uio);
#line 1573
                  if (__cil_tmp___374) {
#line 1573
                    goto error;
                  }
#line 1573
                  iovp = iov;
                }
#line 1573
                n___1 -= 16;
              }
#line 1573
              iovp->iov_base = (void const   *)(zeroes___1);
#line 1573
              iovp->iov_len = (unsigned int )n___1;
#line 1573
              uio.uio_resid += n___1;
#line 1573
              iovp ++;
#line 1573
              (uio.uio_iovcnt) ++;
#line 1573
              if (uio.uio_iovcnt >= 8) {
#line 1573
                __cil_tmp___375 = __ssprint_r(data, fp, & uio);
#line 1573
                if (__cil_tmp___375) {
#line 1573
                  goto error;
                }
#line 1573
                iovp = iov;
              }
            }
#line 1575
            cp += (int const   )*grouping;
          }
#line 1577
          if ((unsigned int )cp > (unsigned int )(convbuf + ndig)) {
#line 1578
            cp = convbuf + ndig;
          }
        }
#line 1581
        if (expt < ndig || flags & 1) {
#line 1582
          iovp->iov_base = (void const   *)decimal_point;
#line 1582
          iovp->iov_len = decp_len;
#line 1582
          uio.uio_resid = (int )((unsigned int )uio.uio_resid + decp_len);
#line 1582
          iovp ++;
#line 1582
          (uio.uio_iovcnt) ++;
#line 1582
          if (uio.uio_iovcnt >= 8) {
#line 1582
            __cil_tmp___376 = __ssprint_r(data, fp, & uio);
#line 1582
            if (__cil_tmp___376) {
#line 1582
              goto error;
            }
#line 1582
            iovp = iov;
          }
        }
#line 1583
        n___2 = (convbuf + ndig) - cp;
#line 1583
        if (n___2 > ndig - expt) {
#line 1583
          n___2 = ndig - expt;
        }
#line 1583
        if (n___2 > 0) {
#line 1583
          iovp->iov_base = (void const   *)cp;
#line 1583
          iovp->iov_len = (unsigned int )n___2;
#line 1583
          uio.uio_resid += n___2;
#line 1583
          iovp ++;
#line 1583
          (uio.uio_iovcnt) ++;
#line 1583
          if (uio.uio_iovcnt >= 8) {
#line 1583
            __cil_tmp___377 = __ssprint_r(data, fp, & uio);
#line 1583
            if (__cil_tmp___377) {
#line 1583
              goto error;
            }
#line 1583
            iovp = iov;
          }
        }
#line 1583
        n___2 = (ndig - expt) - (n___2 > 0 ? n___2 : 0);
#line 1583
        if (n___2 > 0) {
#line 1583
          while (n___2 > 16) {
#line 1583
            iovp->iov_base = (void const   *)(zeroes___1);
#line 1583
            iovp->iov_len = 16U;
#line 1583
            uio.uio_resid += 16;
#line 1583
            iovp ++;
#line 1583
            (uio.uio_iovcnt) ++;
#line 1583
            if (uio.uio_iovcnt >= 8) {
#line 1583
              __cil_tmp___378 = __ssprint_r(data, fp, & uio);
#line 1583
              if (__cil_tmp___378) {
#line 1583
                goto error;
              }
#line 1583
              iovp = iov;
            }
#line 1583
            n___2 -= 16;
          }
#line 1583
          iovp->iov_base = (void const   *)(zeroes___1);
#line 1583
          iovp->iov_len = (unsigned int )n___2;
#line 1583
          uio.uio_resid += n___2;
#line 1583
          iovp ++;
#line 1583
          (uio.uio_iovcnt) ++;
#line 1583
          if (uio.uio_iovcnt >= 8) {
#line 1583
            __cil_tmp___379 = __ssprint_r(data, fp, & uio);
#line 1583
            if (__cil_tmp___379) {
#line 1583
              goto error;
            }
#line 1583
            iovp = iov;
          }
        }
      }
    } else {
#line 1587
      if (ndig > 1 || flags & 1) {
#line 1588
        iovp->iov_base = (void const   *)cp;
#line 1588
        iovp->iov_len = 1U;
#line 1588
        (uio.uio_resid) ++;
#line 1588
        iovp ++;
#line 1588
        (uio.uio_iovcnt) ++;
#line 1588
        if (uio.uio_iovcnt >= 8) {
#line 1588
          __cil_tmp___380 = __ssprint_r(data, fp, & uio);
#line 1588
          if (__cil_tmp___380) {
#line 1588
            goto error;
          }
#line 1588
          iovp = iov;
        }
#line 1589
        cp ++;
#line 1590
        iovp->iov_base = (void const   *)decimal_point;
#line 1590
        iovp->iov_len = decp_len;
#line 1590
        uio.uio_resid = (int )((unsigned int )uio.uio_resid + decp_len);
#line 1590
        iovp ++;
#line 1590
        (uio.uio_iovcnt) ++;
#line 1590
        if (uio.uio_iovcnt >= 8) {
#line 1590
          __cil_tmp___381 = __ssprint_r(data, fp, & uio);
#line 1590
          if (__cil_tmp___381) {
#line 1590
            goto error;
          }
#line 1590
          iovp = iov;
        }
#line 1591
        if (_double_.fp) {
#line 1592
          iovp->iov_base = (void const   *)cp;
#line 1592
          iovp->iov_len = (unsigned int )(ndig - 1);
#line 1592
          uio.uio_resid += ndig - 1;
#line 1592
          iovp ++;
#line 1592
          (uio.uio_iovcnt) ++;
#line 1592
          if (uio.uio_iovcnt >= 8) {
#line 1592
            __cil_tmp___382 = __ssprint_r(data, fp, & uio);
#line 1592
            if (__cil_tmp___382) {
#line 1592
              goto error;
            }
#line 1592
            iovp = iov;
          }
        } else {
#line 1595
          n = ndig - 1;
#line 1595
          if (n > 0) {
#line 1595
            while (n > 16) {
#line 1595
              iovp->iov_base = (void const   *)(zeroes___1);
#line 1595
              iovp->iov_len = 16U;
#line 1595
              uio.uio_resid += 16;
#line 1595
              iovp ++;
#line 1595
              (uio.uio_iovcnt) ++;
#line 1595
              if (uio.uio_iovcnt >= 8) {
#line 1595
                __cil_tmp___383 = __ssprint_r(data, fp, & uio);
#line 1595
                if (__cil_tmp___383) {
#line 1595
                  goto error;
                }
#line 1595
                iovp = iov;
              }
#line 1595
              n -= 16;
            }
#line 1595
            iovp->iov_base = (void const   *)(zeroes___1);
#line 1595
            iovp->iov_len = (unsigned int )n;
#line 1595
            uio.uio_resid += n;
#line 1595
            iovp ++;
#line 1595
            (uio.uio_iovcnt) ++;
#line 1595
            if (uio.uio_iovcnt >= 8) {
#line 1595
              __cil_tmp___384 = __ssprint_r(data, fp, & uio);
#line 1595
              if (__cil_tmp___384) {
#line 1595
                goto error;
              }
#line 1595
              iovp = iov;
            }
          }
        }
      } else {
#line 1597
        iovp->iov_base = (void const   *)cp;
#line 1597
        iovp->iov_len = 1U;
#line 1597
        (uio.uio_resid) ++;
#line 1597
        iovp ++;
#line 1597
        (uio.uio_iovcnt) ++;
#line 1597
        if (uio.uio_iovcnt >= 8) {
#line 1597
          __cil_tmp___385 = __ssprint_r(data, fp, & uio);
#line 1597
          if (__cil_tmp___385) {
#line 1597
            goto error;
          }
#line 1597
          iovp = iov;
        }
      }
#line 1598
      iovp->iov_base = (void const   *)(expstr);
#line 1598
      iovp->iov_len = (unsigned int )expsize;
#line 1598
      uio.uio_resid += expsize;
#line 1598
      iovp ++;
#line 1598
      (uio.uio_iovcnt) ++;
#line 1598
      if (uio.uio_iovcnt >= 8) {
#line 1598
        __cil_tmp___386 = __ssprint_r(data, fp, & uio);
#line 1598
        if (__cil_tmp___386) {
#line 1598
          goto error;
        }
#line 1598
        iovp = iov;
      }
    }
#line 1605
    if (flags & 4) {
#line 1606
      n = width - realsz;
#line 1606
      if (n > 0) {
#line 1606
        while (n > 16) {
#line 1606
          iovp->iov_base = (void const   *)(blanks___1);
#line 1606
          iovp->iov_len = 16U;
#line 1606
          uio.uio_resid += 16;
#line 1606
          iovp ++;
#line 1606
          (uio.uio_iovcnt) ++;
#line 1606
          if (uio.uio_iovcnt >= 8) {
#line 1606
            __cil_tmp___387 = __ssprint_r(data, fp, & uio);
#line 1606
            if (__cil_tmp___387) {
#line 1606
              goto error;
            }
#line 1606
            iovp = iov;
          }
#line 1606
          n -= 16;
        }
#line 1606
        iovp->iov_base = (void const   *)(blanks___1);
#line 1606
        iovp->iov_len = (unsigned int )n;
#line 1606
        uio.uio_resid += n;
#line 1606
        iovp ++;
#line 1606
        (uio.uio_iovcnt) ++;
#line 1606
        if (uio.uio_iovcnt >= 8) {
#line 1606
          __cil_tmp___388 = __ssprint_r(data, fp, & uio);
#line 1606
          if (__cil_tmp___388) {
#line 1606
            goto error;
          }
#line 1606
          iovp = iov;
        }
      }
    }
#line 1609
    ret += width > realsz ? width : realsz;
#line 1611
    if (uio.uio_resid) {
#line 1611
      __cil_tmp___389 = __ssprint_r(data, fp, & uio);
#line 1611
      if (__cil_tmp___389) {
#line 1611
        goto error;
      }
    }
#line 1611
    uio.uio_iovcnt = 0;
#line 1611
    iovp = iov;
#line 1613
    if ((unsigned int )malloc_buf != (unsigned int )((void *)0)) {
#line 1614
      _free_r(data, (void *)malloc_buf);
#line 1615
      malloc_buf = (char *)((void *)0);
    }
    __Cont: ;
  }
  done: 
#line 1619
  if (uio.uio_resid) {
#line 1619
    __cil_tmp___390 = __ssprint_r(data, fp, & uio);
#line 1619
    if (__cil_tmp___390) {
#line 1619
      goto error;
    }
  }
#line 1619
  uio.uio_iovcnt = 0;
#line 1619
  iovp = iov;
  error: 
#line 1621
  if ((unsigned int )malloc_buf != (unsigned int )((void *)0)) {
#line 1622
    _free_r(data, (void *)malloc_buf);
  }
#line 1626
  return (((int )fp->_flags & 64) != 0 ? -1 : ret);
}
}
#line 1639 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static char *cvt(struct _reent *data , double value , int ndigits , int flags , char *sign ,
                 int *decpt , int ch , int *length , char *buf ) 
{ int mode ;
  int dsgn ;
  char *digits ;
  char *bp ;
  char *rve ;
  union double_union tmp ;
  double __cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  char *__cil_tmp___4 ;

  {
#line 1648
  tmp.d = value;
#line 1649
  if (tmp.i[1] & 2147483648U) {
#line 1650
    value = - value;
#line 1651
    *sign = (char )'-';
  } else {
#line 1653
    *sign = (char )'\000';
  }
#line 1670
  if (ch == 97 || ch == 65) {
#line 1675
    __cil_tmp = frexp(value, decpt);
#line 1675
    value = __cil_tmp / (double )8;
#line 1676
    if (! value) {
#line 1677
      *decpt = 1;
    }
#line 1678
    digits = (char *)(ch == 97 ? "0123456789abcdef" : "0123456789ABCDEF");
#line 1679
    bp = buf;
#line 1680
    while (1) {
#line 1681
      value *= (double )16;
#line 1682
      mode = (int )value;
#line 1683
      value -= (double )mode;
#line 1684
      __cil_tmp___0 = bp;
#line 1684
      bp ++;
#line 1684
      *__cil_tmp___0 = *(digits + mode);
#line 1680
      __cil_tmp___1 = ndigits;
#line 1680
      ndigits --;
#line 1680
      if (! (__cil_tmp___1 && value)) {
#line 1680
        break;
      }
    }
#line 1686
    if (value > 0.5 || (value == 0.5 && mode & 1)) {
#line 1688
      rve = bp;
#line 1689
      while (1) {
#line 1689
        rve --;
#line 1689
        if (! ((int )*rve == (int )*(digits + 15))) {
#line 1689
          break;
        }
#line 1690
        *rve = (char )'0';
      }
#line 1692
      *rve = (char )((int )*rve == 57 ? (int )*(digits + 10) : (int )*rve + 1);
    } else {
#line 1694
      while (1) {
#line 1694
        __cil_tmp___3 = ndigits;
#line 1694
        ndigits --;
#line 1694
        if (! (__cil_tmp___3 >= 0)) {
#line 1694
          break;
        }
#line 1695
        __cil_tmp___2 = bp;
#line 1695
        bp ++;
#line 1695
        *__cil_tmp___2 = (char )'0';
      }
    }
#line 1698
    *length = bp - buf;
#line 1699
    return (buf);
  }
#line 1702
  if (ch == 102 || ch == 70) {
#line 1703
    mode = 3;
  } else {
#line 1709
    if (ch == 101 || ch == 69) {
#line 1710
      ndigits ++;
    }
#line 1712
    mode = 2;
  }
#line 1715
  digits = _dtoa_r(data, value, mode, ndigits, decpt, & dsgn, & rve);
#line 1717
  if ((ch != 103 && ch != 71) || flags & 1) {
#line 1718
    bp = digits + ndigits;
#line 1719
    if (ch == 102 || ch == 70) {
#line 1720
      if ((int )*digits == 48 && value) {
#line 1721
        *decpt = - ndigits + 1;
      }
#line 1722
      bp += *decpt;
    }
#line 1724
    if (value == (double )0) {
#line 1725
      rve = bp;
    }
#line 1726
    while ((unsigned int )rve < (unsigned int )bp) {
#line 1727
      __cil_tmp___4 = rve;
#line 1727
      rve ++;
#line 1727
      *__cil_tmp___4 = (char )'0';
    }
  }
#line 1729
  *length = rve - digits;
#line 1730
  return (digits);
}
}
#line 1733 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static int exponent(char *p0 , int exp___0 , int fmtch ) 
{ register char *p ;
  register char *t ;
  char expbuf[7] ;
  int isa ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  char *__cil_tmp___5 ;

  {
#line 1739
  isa = fmtch == 97 || fmtch == 65;
#line 1744
  p = p0;
#line 1745
  __cil_tmp = p;
#line 1745
  p ++;
#line 1745
  *__cil_tmp = (char )(isa ? 15 + fmtch : fmtch);
#line 1746
  if (exp___0 < 0) {
#line 1747
    exp___0 = - exp___0;
#line 1748
    __cil_tmp___0 = p;
#line 1748
    p ++;
#line 1748
    *__cil_tmp___0 = (char )'-';
  } else {
#line 1751
    __cil_tmp___1 = p;
#line 1751
    p ++;
#line 1751
    *__cil_tmp___1 = (char )'+';
  }
#line 1752
  t = expbuf + 7;
#line 1753
  if (exp___0 > 9) {
#line 1754
    while (1) {
#line 1755
      t --;
#line 1755
      *t = (char )(exp___0 % 10 + 48);
#line 1754
      exp___0 /= 10;
#line 1754
      if (! (exp___0 > 9)) {
#line 1754
        break;
      }
    }
#line 1757
    t --;
#line 1757
    *t = (char )(exp___0 + 48);
#line 1758
    while ((unsigned int )t < (unsigned int )(expbuf + 7)) {
#line 1758
      __cil_tmp___2 = p;
#line 1758
      p ++;
#line 1758
      __cil_tmp___3 = t;
#line 1758
      t ++;
#line 1758
      *__cil_tmp___2 = *__cil_tmp___3;
    }
  } else {
#line 1761
    if (! isa) {
#line 1762
      __cil_tmp___4 = p;
#line 1762
      p ++;
#line 1762
      *__cil_tmp___4 = (char )'0';
    }
#line 1763
    __cil_tmp___5 = p;
#line 1763
    p ++;
#line 1763
    *__cil_tmp___5 = (char )(exp___0 + 48);
  }
#line 1765
  return (p - p0);
}
}
#line 1876 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static union arg_val *get_arg___3(struct _reent *data , int n , char *fmt , va_list *ap ,
                                  int *numargs_p , union arg_val *args , int *arg_type ,
                                  char **last_fmt ) 
{ int ch ;
  int number ;
  int flags ;
  int spec_type ;
  int numargs ;
  __CH_CLASS chtype ;
  __STATE state ;
  __STATE next_state ;
  __ACTION action ;
  int pos ;
  int last_arg ;
  int max_pos_arg ;
  char *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;

  {
#line 1890
  numargs = *numargs_p;
#line 1895
  max_pos_arg = n;
#line 1905
  if ((unsigned int )*last_fmt != (unsigned int )((void *)0)) {
#line 1906
    fmt = *last_fmt;
  }
#line 1914
  while (*fmt && n >= numargs) {
#line 1928
    while ((int )*fmt != 0 && (int )*fmt != 37) {
#line 1929
      fmt ++;
    }
#line 1931
    if ((int )*fmt == 0) {
#line 1932
      break;
    }
#line 1934
    state = (enum __anonenum___STATE_12 )0;
#line 1935
    flags = 0;
#line 1936
    pos = -1;
#line 1937
    number = 0;
#line 1938
    spec_type = 0;
#line 1943
    while ((unsigned int )state != 11U) {
#line 1945
      __cil_tmp = fmt;
#line 1945
      fmt ++;
#line 1945
      ch = (int )*__cil_tmp;
#line 1946
      chtype = (enum __anonenum___CH_CLASS_11 )__chclass[ch];
#line 1947
      next_state = (enum __anonenum___STATE_12 )__state_table[state][chtype];
#line 1948
      action = (enum __anonenum___ACTION_13 )__action_table[state][chtype];
#line 1949
      state = next_state;
#line 1951
      switch ((int )action) {
      case 3: 
#line 1954
      switch (ch) {
      case 104: 
#line 1958
      break;
      case 76: 
#line 1960
      flags |= 8;
#line 1961
      break;
      case 113: 
#line 1963
      flags |= 32;
#line 1964
      break;
      case 106: 
#line 1967
      if (sizeof(intmax_t ) == sizeof(long )) {
#line 1968
        flags |= 16;
      } else {
#line 1970
        flags |= 32;
      }
#line 1971
      break;
      case 122: 
#line 1973
      if (! (sizeof(size_t ) <= sizeof(int ))) {
#line 1975
        if (sizeof(size_t ) <= sizeof(long )) {
#line 1976
          flags |= 16;
        } else {
#line 1982
          flags |= 32;
        }
      }
#line 1983
      break;
      case 116: 
#line 1985
      if (! (sizeof(ptrdiff_t ) <= sizeof(int ))) {
#line 1987
        if (sizeof(ptrdiff_t ) <= sizeof(long )) {
#line 1988
          flags |= 16;
        } else {
#line 1994
          flags |= 32;
        }
      }
#line 1995
      break;
      default: 
#line 2000
      if ((int )*fmt == 108) {
#line 2002
        flags |= 32;
#line 2003
        fmt ++;
      } else {
#line 2007
        flags |= 16;
      }
#line 2008
      break;
      }
#line 2010
      break;
      case 4: 
#line 2013
      numargs &= 31;
#line 2015
      switch (ch) {
      case 100: 
      case 105: 
      case 111: 
      case 120: 
      case 88: 
      case 117: 
#line 2023
      if (flags & 16) {
#line 2024
        spec_type = 1;
      } else
#line 2026
      if (flags & 32) {
#line 2027
        spec_type = 2;
      } else {
#line 2030
        spec_type = 0;
      }
#line 2031
      break;
      case 68: 
      case 85: 
      case 79: 
#line 2035
      spec_type = 1;
#line 2036
      break;
      case 97: 
      case 65: 
      case 70: 
      case 102: 
      case 103: 
      case 71: 
      case 69: 
      case 101: 
#line 2052
      spec_type = 4;
#line 2053
      break;
      case 115: 
      case 83: 
      case 112: 
      case 110: 
#line 2060
      spec_type = 3;
#line 2061
      break;
      case 99: 
#line 2064
      if (flags & 16) {
#line 2065
        spec_type = 6;
      } else {
#line 2068
        spec_type = 0;
      }
#line 2069
      break;
      case 67: 
#line 2072
      spec_type = 6;
#line 2073
      break;
      }
#line 2079
      if (pos != -1) {
#line 2080
        *(arg_type + pos) = spec_type;
      } else {
#line 2083
        switch (spec_type) {
        case 1: 
#line 2086
        __cil_tmp___0 = numargs;
#line 2086
        numargs ++;
#line 2086
        (args + __cil_tmp___0)->val_long = __builtin_va_arg(*ap, long );
#line 2087
        break;
        case 2: 
#line 2089
        __cil_tmp___1 = numargs;
#line 2089
        numargs ++;
#line 2089
        (args + __cil_tmp___1)->val_quad_t = __builtin_va_arg(*ap, long long );
#line 2090
        break;
        case 6: 
#line 2092
        __cil_tmp___2 = numargs;
#line 2092
        numargs ++;
#line 2092
        (args + __cil_tmp___2)->val_wint_t = __builtin_va_arg(*ap, wint_t );
#line 2093
        break;
        case 0: 
#line 2095
        __cil_tmp___3 = numargs;
#line 2095
        numargs ++;
#line 2095
        (args + __cil_tmp___3)->val_int = __builtin_va_arg(*ap, int );
#line 2096
        break;
        case 3: 
#line 2098
        __cil_tmp___4 = numargs;
#line 2098
        numargs ++;
#line 2098
        (args + __cil_tmp___4)->val_char_ptr_t = __builtin_va_arg(*ap, char *);
#line 2099
        break;
        case 4: 
#line 2101
        __cil_tmp___5 = numargs;
#line 2101
        numargs ++;
#line 2101
        (args + __cil_tmp___5)->val_double = __builtin_va_arg(*ap, double );
#line 2102
        break;
        case 5: 
#line 2104
        __cil_tmp___6 = numargs;
#line 2104
        numargs ++;
#line 2104
        (args + __cil_tmp___6)->val__LONG_DOUBLE = __builtin_va_arg(*ap, long double );
#line 2105
        break;
        }
      }
#line 2109
      break;
      case 7: 
#line 2111
      if (*(arg_type + 0) == -1) {
#line 2112
        memset((void *)arg_type, 0, (unsigned int )(sizeof(int ) * 32UL));
      }
#line 2113
      pos = number - 1;
#line 2114
      max_pos_arg = max_pos_arg > pos ? max_pos_arg : pos;
#line 2115
      break;
      case 8: 
#line 2117
      if (*(arg_type + 0) == -1) {
#line 2118
        memset((void *)arg_type, 0, (unsigned int )(sizeof(int ) * 32UL));
      }
#line 2119
      number --;
#line 2120
      *(arg_type + number) = 0;
#line 2121
      max_pos_arg = max_pos_arg > number ? max_pos_arg : number;
#line 2122
      break;
      case 6: 
#line 2124
      fmt --;
      case 5: 
#line 2127
      __cil_tmp___7 = numargs;
#line 2127
      numargs ++;
#line 2127
      (args + __cil_tmp___7)->val_int = __builtin_va_arg(*ap, int );
#line 2128
      break;
      case 1: 
#line 2130
      number = ch - 48;
#line 2131
      while (1) {
#line 2131
        ch = (int )*fmt;
#line 2131
        if (! (ch != 0 && (unsigned int )(ch - 48) <= 9U)) {
#line 2131
          break;
        }
#line 2133
        number = number * 10 + (ch - 48);
#line 2134
        fmt ++;
      }
#line 2136
      break;
      case 2: 
#line 2138
      while (1) {
#line 2138
        ch = (int )*fmt;
#line 2138
        if (! (ch != 0 && (unsigned int )(ch - 48) <= 9U)) {
#line 2138
          break;
        }
#line 2139
        fmt ++;
      }
#line 2140
      break;
      default: 
#line 2143
      break;
      }
    }
  }
#line 2150
  if ((int )*fmt == 0) {
#line 2151
    last_arg = max_pos_arg;
  } else {
#line 2153
    last_arg = n;
  }
#line 2155
  while (numargs <= last_arg) {
#line 2157
    switch (*(arg_type + numargs)) {
    case 1: 
#line 2160
    __cil_tmp___8 = numargs;
#line 2160
    numargs ++;
#line 2160
    (args + __cil_tmp___8)->val_long = __builtin_va_arg(*ap, long );
#line 2161
    break;
    case 2: 
#line 2163
    __cil_tmp___9 = numargs;
#line 2163
    numargs ++;
#line 2163
    (args + __cil_tmp___9)->val_quad_t = __builtin_va_arg(*ap, long long );
#line 2164
    break;
    case 3: 
#line 2166
    __cil_tmp___10 = numargs;
#line 2166
    numargs ++;
#line 2166
    (args + __cil_tmp___10)->val_char_ptr_t = __builtin_va_arg(*ap, char *);
#line 2167
    break;
    case 4: 
#line 2169
    __cil_tmp___11 = numargs;
#line 2169
    numargs ++;
#line 2169
    (args + __cil_tmp___11)->val_double = __builtin_va_arg(*ap, double );
#line 2170
    break;
    case 5: 
#line 2172
    __cil_tmp___12 = numargs;
#line 2172
    numargs ++;
#line 2172
    (args + __cil_tmp___12)->val__LONG_DOUBLE = __builtin_va_arg(*ap, long double );
#line 2173
    break;
    case 6: 
#line 2175
    __cil_tmp___13 = numargs;
#line 2175
    numargs ++;
#line 2175
    (args + __cil_tmp___13)->val_wint_t = __builtin_va_arg(*ap, wint_t );
#line 2176
    break;
    default: 
#line 2179
    __cil_tmp___14 = numargs;
#line 2179
    numargs ++;
#line 2179
    (args + __cil_tmp___14)->val_int = __builtin_va_arg(*ap, int );
#line 2180
    break;
    }
  }
#line 2186
  *numargs_p = numargs;
#line 2187
  *last_fmt = fmt;
#line 2188
  return (args + n);
}
}
#line 1 "lib_a-svfscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-c2qwAVEy.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 203 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfscanf.c"
static void *get_arg___4(int n , va_list *ap , int *numargs_p , void **args ) ;
#line 478 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfscanf.c"
static short const   basefix___1[17]  = 
#line 478
  {      (short const   )10,      (short const   )1,      (short const   )2,      (short const   )3, 
        (short const   )4,      (short const   )5,      (short const   )6,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )10,      (short const   )11, 
        (short const   )12,      (short const   )13,      (short const   )14,      (short const   )15, 
        (short const   )16};
#line 428 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfscanf.c"
int __ssvfscanf_r(struct _reent *rptr , FILE *fp , char const   *fmt0 , va_list ap ) 
{ register char *fmt ;
  register int c ;
  register size_t width ;
  register char *p ;
  register int n ;
  register int flags ;
  register char *p0 ;
  int nassigned ;
  int nread ;
  int N ;
  int arg_index ;
  int numargs ;
  void *args[32] ;
  int is_pos_arg ;
  int base ;
  int nbytes ;
  wchar_t wc ;
  wchar_t *wcp ;
  size_t mbslen ;
  unsigned long (*ccfn)(struct _reent * , char const   * , char ** , int  ) ;
  char ccltab[256] ;
  char buf[350] ;
  unsigned char *lptr ;
  char *cp ;
  short *sp ;
  int *ip ;
  float *flp ;
  long double *ldp ;
  double *dp ;
  long *lp ;
  long long *llp ;
  int __cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  u_char *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  void *__cil_tmp___4 ;
  int __cil_tmp___6 ;
  void *__cil_tmp___7 ;
  void *__cil_tmp___8 ;
  void *__cil_tmp___9 ;
  void *__cil_tmp___10 ;
  int __cil_tmp___11 ;
  void *__cil_tmp___12 ;
  void *__cil_tmp___13 ;
  void *__cil_tmp___14 ;
  int __cil_tmp___16 ;
  void *__cil_tmp___17 ;
  void *__cil_tmp___18 ;
  void *__cil_tmp___19 ;
  void *__cil_tmp___20 ;
  int __cil_tmp___21 ;
  void *__cil_tmp___22 ;
  void *__cil_tmp___23 ;
  void *__cil_tmp___24 ;
  int __cil_tmp___26 ;
  void *__cil_tmp___27 ;
  void *__cil_tmp___28 ;
  void *__cil_tmp___29 ;
  void *__cil_tmp___30 ;
  int __cil_tmp___31 ;
  void *__cil_tmp___32 ;
  void *__cil_tmp___33 ;
  void *__cil_tmp___34 ;
  int __cil_tmp___36 ;
  void *__cil_tmp___37 ;
  void *__cil_tmp___38 ;
  void *__cil_tmp___39 ;
  void *__cil_tmp___40 ;
  int __cil_tmp___41 ;
  void *__cil_tmp___42 ;
  void *__cil_tmp___43 ;
  void *__cil_tmp___44 ;
  int __cil_tmp___46 ;
  void *__cil_tmp___47 ;
  void *__cil_tmp___48 ;
  void *__cil_tmp___49 ;
  void *__cil_tmp___50 ;
  int __cil_tmp___51 ;
  void *__cil_tmp___52 ;
  int __cil_tmp___53 ;
  int __cil_tmp___54 ;
  mbstate_t state___0 ;
  void *__cil_tmp___55 ;
  void *__cil_tmp___56 ;
  int __cil_tmp___58 ;
  void *__cil_tmp___59 ;
  void *__cil_tmp___60 ;
  void *__cil_tmp___61 ;
  void *__cil_tmp___62 ;
  int __cil_tmp___63 ;
  void *__cil_tmp___64 ;
  int __cil_tmp___65 ;
  int __cil_tmp___66 ;
  int __cil_tmp___67 ;
  size_t sum ;
  int __cil_tmp___68 ;
  size_t r ;
  void *__cil_tmp___69 ;
  void *__cil_tmp___70 ;
  int __cil_tmp___72 ;
  void *__cil_tmp___73 ;
  void *__cil_tmp___74 ;
  void *__cil_tmp___75 ;
  void *__cil_tmp___76 ;
  int __cil_tmp___77 ;
  void *__cil_tmp___78 ;
  size_t __cil_tmp___79 ;
  int __cil_tmp___80 ;
  void *__cil_tmp___81 ;
  void *__cil_tmp___82 ;
  int __cil_tmp___84 ;
  void *__cil_tmp___85 ;
  void *__cil_tmp___86 ;
  void *__cil_tmp___87 ;
  void *__cil_tmp___88 ;
  int __cil_tmp___89 ;
  void *__cil_tmp___90 ;
  char *__cil_tmp___91 ;
  unsigned char *__cil_tmp___92 ;
  int __cil_tmp___93 ;
  mbstate_t state___1 ;
  void *__cil_tmp___94 ;
  void *__cil_tmp___95 ;
  int __cil_tmp___97 ;
  void *__cil_tmp___98 ;
  void *__cil_tmp___99 ;
  void *__cil_tmp___100 ;
  void *__cil_tmp___101 ;
  int __cil_tmp___102 ;
  void *__cil_tmp___103 ;
  int __cil_tmp___104 ;
  int __cil_tmp___105 ;
  int __cil_tmp___106 ;
  int __cil_tmp___107 ;
  int __cil_tmp___108 ;
  void *__cil_tmp___109 ;
  void *__cil_tmp___110 ;
  int __cil_tmp___112 ;
  void *__cil_tmp___113 ;
  void *__cil_tmp___114 ;
  void *__cil_tmp___115 ;
  void *__cil_tmp___116 ;
  int __cil_tmp___117 ;
  void *__cil_tmp___118 ;
  char *__cil_tmp___119 ;
  unsigned char *__cil_tmp___120 ;
  int __cil_tmp___121 ;
  unsigned int width_left ;
  int skips ;
  char *__cil_tmp___122 ;
  int __cil_tmp___123 ;
  unsigned long res ;
  void **vp ;
  void *__cil_tmp___124 ;
  void *__cil_tmp___125 ;
  int __cil_tmp___127 ;
  void *__cil_tmp___128 ;
  void *__cil_tmp___129 ;
  void *__cil_tmp___130 ;
  void *__cil_tmp___131 ;
  int __cil_tmp___132 ;
  void *__cil_tmp___133 ;
  u_long_long resll ;
  void *__cil_tmp___134 ;
  void *__cil_tmp___135 ;
  int __cil_tmp___137 ;
  void *__cil_tmp___138 ;
  void *__cil_tmp___139 ;
  void *__cil_tmp___140 ;
  void *__cil_tmp___141 ;
  int __cil_tmp___142 ;
  void *__cil_tmp___143 ;
  void *__cil_tmp___144 ;
  void *__cil_tmp___145 ;
  int __cil_tmp___147 ;
  void *__cil_tmp___148 ;
  void *__cil_tmp___149 ;
  void *__cil_tmp___150 ;
  void *__cil_tmp___151 ;
  int __cil_tmp___152 ;
  void *__cil_tmp___153 ;
  void *__cil_tmp___154 ;
  void *__cil_tmp___155 ;
  int __cil_tmp___157 ;
  void *__cil_tmp___158 ;
  void *__cil_tmp___159 ;
  void *__cil_tmp___160 ;
  void *__cil_tmp___161 ;
  int __cil_tmp___162 ;
  void *__cil_tmp___163 ;
  u_long_long resll___0 ;
  long long __cil_tmp___164 ;
  void *__cil_tmp___165 ;
  void *__cil_tmp___166 ;
  int __cil_tmp___168 ;
  void *__cil_tmp___169 ;
  void *__cil_tmp___170 ;
  void *__cil_tmp___171 ;
  void *__cil_tmp___172 ;
  int __cil_tmp___173 ;
  void *__cil_tmp___174 ;
  void *__cil_tmp___175 ;
  void *__cil_tmp___176 ;
  int __cil_tmp___178 ;
  void *__cil_tmp___179 ;
  void *__cil_tmp___180 ;
  void *__cil_tmp___181 ;
  void *__cil_tmp___182 ;
  int __cil_tmp___183 ;
  void *__cil_tmp___184 ;
  long leading_zeroes ;
  long zeroes___7 ;
  long exp_adjust ;
  char *exp_start ;
  unsigned int width_left___0 ;
  char nancount ;
  char infcount ;
  char *__cil_tmp___185 ;
  int __cil_tmp___186 ;
  char __cil_tmp___187 ;
  double res___0 ;
  long new_exp ;
  long __cil_tmp___188 ;
  void *__cil_tmp___189 ;
  void *__cil_tmp___190 ;
  int __cil_tmp___192 ;
  void *__cil_tmp___193 ;
  void *__cil_tmp___194 ;
  void *__cil_tmp___195 ;
  void *__cil_tmp___196 ;
  int __cil_tmp___197 ;
  void *__cil_tmp___198 ;
  void *__cil_tmp___199 ;
  void *__cil_tmp___200 ;
  int __cil_tmp___202 ;
  void *__cil_tmp___203 ;
  void *__cil_tmp___204 ;
  void *__cil_tmp___205 ;
  void *__cil_tmp___206 ;
  int __cil_tmp___207 ;
  void *__cil_tmp___208 ;
  void *__cil_tmp___209 ;
  void *__cil_tmp___210 ;
  int __cil_tmp___212 ;
  void *__cil_tmp___213 ;
  void *__cil_tmp___214 ;
  void *__cil_tmp___215 ;
  void *__cil_tmp___216 ;
  int __cil_tmp___217 ;
  void *__cil_tmp___218 ;
  int __cil_tmp___219 ;
  int __cil_tmp___220 ;
  int __cil_tmp___221 ;

  {
#line 435
  fmt = (char *)fmt0;
#line 446
  arg_index = 0;
#line 447
  numargs = 0;
#line 451
  base = 0;
#line 452
  nbytes = 1;
#line 459
  ccfn = (unsigned long (*)(struct _reent * , char const   * , char ** , int  ))0;
#line 497
  __sfp_lock_acquire();
#line 500
  while (1) {
#line 500
    if (! ((int )fp->_flags & 8192)) {
#line 500
      fp->_flags = (short )((int )fp->_flags | 8192);
#line 500
      fp->_flags2 &= -8193;
    }
#line 500
    break;
  }
#line 502
  nassigned = 0;
#line 503
  nread = 0;
#line 508
  while (1) {
#line 511
    wc = (short )*fmt;
#line 521
    fmt += nbytes;
#line 523
    if ((int )wc == 0) {
#line 524
      goto match_failure;
    }
#line 525
    if (nbytes == 1 && (int const   )*((__ctype_ptr__ + sizeof(*("" + (int )wc))) + (int )wc) & 8) {
#line 527
      while (1) {
#line 529
        if (fp->_r <= 0) {
#line 529
          __cil_tmp = __ssrefill_r(rptr, fp);
#line 529
          if (__cil_tmp) {
#line 530
            break;
          } else {
#line 529
            goto _L;
          }
        } else
        _L: 
#line 529
        if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )*(fp->_p)))) + (int )*(fp->_p)) & 8)) {
#line 530
          break;
        }
#line 531
        nread ++;
#line 531
        (fp->_r) --;
#line 531
        (fp->_p) ++;
      }
#line 533
      goto __Cont;
    }
#line 535
    if ((int )wc != 37) {
#line 536
      goto literal;
    }
#line 537
    width = 0U;
#line 538
    flags = 0;
#line 540
    N = arg_index;
#line 541
    is_pos_arg = 0;
    again: 
#line 550
    __cil_tmp___0 = fmt;
#line 550
    fmt ++;
#line 550
    c = (int )*__cil_tmp___0;
#line 552
    switch (c) {
    literal: 
    case 37: 
#line 556
    lptr = (unsigned char *)(fmt - nbytes);
#line 557
    n = 0;
#line 557
    while (n < nbytes) {
#line 559
      if (fp->_r <= 0) {
#line 559
        __cil_tmp___1 = __ssrefill_r(rptr, fp);
#line 559
        if (__cil_tmp___1) {
#line 560
          goto input_failure;
        }
      }
#line 561
      if ((int )*(fp->_p) != (int )*lptr) {
#line 562
        goto match_failure;
      }
#line 563
      (fp->_r) --;
#line 563
      (fp->_p) ++;
#line 564
      nread ++;
#line 565
      lptr ++;
#line 557
      n ++;
    }
#line 567
    goto __Cont;
    case 42: 
#line 570
    flags |= 16;
#line 571
    goto again;
    case 108: 
#line 574
    if ((int )*fmt == 108) {
#line 576
      fmt ++;
#line 577
      flags |= 2;
    } else {
#line 581
      flags |= 1;
    }
#line 582
    goto again;
    case 76: 
#line 584
    flags |= 2;
#line 585
    goto again;
    case 104: 
#line 588
    if ((int )*fmt == 104) {
#line 590
      fmt ++;
#line 591
      flags |= 8;
    } else {
#line 595
      flags |= 4;
    }
#line 596
    goto again;
    case 106: 
#line 599
    if (sizeof(intmax_t ) == sizeof(long )) {
#line 600
      flags |= 1;
    } else {
#line 602
      flags |= 2;
    }
#line 603
    goto again;
    case 116: 
#line 605
    if (sizeof(ptrdiff_t ) < sizeof(int )) {
#line 608
      flags |= 4;
    } else
#line 609
    if (! (sizeof(ptrdiff_t ) == sizeof(int ))) {
#line 611
      if (sizeof(ptrdiff_t ) <= sizeof(long )) {
#line 612
        flags |= 1;
      } else {
#line 618
        flags |= 2;
      }
    }
#line 619
    goto again;
    case 122: 
#line 621
    if (sizeof(size_t ) < sizeof(int )) {
#line 623
      flags |= 4;
    } else
#line 624
    if (! (sizeof(size_t ) == sizeof(int ))) {
#line 626
      if (sizeof(size_t ) <= sizeof(long )) {
#line 627
        flags |= 1;
      } else {
#line 633
        flags |= 2;
      }
    }
#line 634
    goto again;
    case 48: 
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
#line 647
    width = (width * 10U + (unsigned int )c) - 48U;
#line 648
    goto again;
    case 36: 
#line 652
    if (width <= 32U) {
#line 654
      N = (int )(width - 1U);
#line 655
      is_pos_arg = 1;
#line 656
      width = 0U;
#line 657
      goto again;
    }
#line 659
    rptr->_errno = 22;
#line 660
    goto input_failure;
    case 68: 
#line 672
    flags |= 1;
    case 100: 
#line 675
    c = 3;
#line 676
    ccfn = (unsigned long (*)(struct _reent * , char const   * , char ** , int  ))(& _strtol_r);
#line 677
    base = 10;
#line 678
    break;
    case 105: 
#line 681
    c = 3;
#line 682
    ccfn = (unsigned long (*)(struct _reent * , char const   * , char ** , int  ))(& _strtol_r);
#line 683
    base = 0;
#line 684
    break;
    case 79: 
#line 687
    flags |= 1;
    case 111: 
#line 690
    c = 3;
#line 691
    ccfn = & _strtoul_r;
#line 692
    base = 8;
#line 693
    break;
    case 117: 
#line 696
    c = 3;
#line 697
    ccfn = & _strtoul_r;
#line 698
    base = 10;
#line 699
    break;
    case 88: 
    case 120: 
#line 703
    flags |= 512;
#line 704
    c = 3;
#line 705
    ccfn = & _strtoul_r;
#line 706
    base = 16;
#line 707
    break;
    case 97: 
    case 65: 
    case 70: 
    case 69: 
    case 71: 
    case 101: 
    case 102: 
    case 103: 
#line 720
    c = 4;
#line 721
    break;
    case 83: 
#line 726
    flags |= 1;
    case 115: 
#line 731
    c = 2;
#line 732
    break;
    case 91: 
#line 735
    __cil_tmp___2 = __sccl(ccltab, (unsigned char *)fmt);
#line 735
    fmt = (char *)__cil_tmp___2;
#line 736
    flags |= 64;
#line 737
    c = 1;
#line 738
    break;
    case 67: 
#line 742
    flags |= 1;
    case 99: 
#line 747
    flags |= 64;
#line 748
    c = 0;
#line 749
    break;
    case 112: 
#line 752
    flags |= 544;
#line 753
    c = 3;
#line 754
    ccfn = & _strtoul_r;
#line 755
    base = 16;
#line 756
    break;
    case 110: 
#line 759
    if (flags & 16) {
#line 760
      goto __Cont;
    }
#line 762
    if (flags & 8) {
#line 764
      if (is_pos_arg) {
#line 764
        if (N < numargs) {
#line 764
          __cil_tmp___4 = args[N];
        } else {
#line 764
          __cil_tmp___3 = get_arg___4(N, & ap, & numargs, args);
#line 764
          __cil_tmp___4 = __cil_tmp___3;
        }
#line 764
        __cil_tmp___12 = __cil_tmp___4;
      } else {
#line 764
        __cil_tmp___11 = arg_index;
#line 764
        arg_index ++;
#line 764
        if (__cil_tmp___11 < numargs) {
#line 764
          __cil_tmp___10 = args[N];
        } else {
#line 764
          if (numargs < 32) {
#line 764
            __cil_tmp___6 = numargs;
#line 764
            numargs ++;
#line 764
            __cil_tmp___7 = __builtin_va_arg(ap, void *);
#line 764
            args[__cil_tmp___6] = __cil_tmp___7;
#line 764
            __cil_tmp___9 = __cil_tmp___7;
          } else {
#line 764
            __cil_tmp___8 = __builtin_va_arg(ap, void *);
#line 764
            __cil_tmp___9 = __cil_tmp___8;
          }
#line 764
          __cil_tmp___10 = __cil_tmp___9;
        }
#line 764
        __cil_tmp___12 = __cil_tmp___10;
      }
#line 764
      cp = (char *)__cil_tmp___12;
#line 765
      *cp = (char )nread;
    } else
#line 769
    if (flags & 4) {
#line 771
      if (is_pos_arg) {
#line 771
        if (N < numargs) {
#line 771
          __cil_tmp___14 = args[N];
        } else {
#line 771
          __cil_tmp___13 = get_arg___4(N, & ap, & numargs, args);
#line 771
          __cil_tmp___14 = __cil_tmp___13;
        }
#line 771
        __cil_tmp___22 = __cil_tmp___14;
      } else {
#line 771
        __cil_tmp___21 = arg_index;
#line 771
        arg_index ++;
#line 771
        if (__cil_tmp___21 < numargs) {
#line 771
          __cil_tmp___20 = args[N];
        } else {
#line 771
          if (numargs < 32) {
#line 771
            __cil_tmp___16 = numargs;
#line 771
            numargs ++;
#line 771
            __cil_tmp___17 = __builtin_va_arg(ap, void *);
#line 771
            args[__cil_tmp___16] = __cil_tmp___17;
#line 771
            __cil_tmp___19 = __cil_tmp___17;
          } else {
#line 771
            __cil_tmp___18 = __builtin_va_arg(ap, void *);
#line 771
            __cil_tmp___19 = __cil_tmp___18;
          }
#line 771
          __cil_tmp___20 = __cil_tmp___19;
        }
#line 771
        __cil_tmp___22 = __cil_tmp___20;
      }
#line 771
      sp = (short *)__cil_tmp___22;
#line 772
      *sp = (short )nread;
    } else
#line 774
    if (flags & 1) {
#line 776
      if (is_pos_arg) {
#line 776
        if (N < numargs) {
#line 776
          __cil_tmp___24 = args[N];
        } else {
#line 776
          __cil_tmp___23 = get_arg___4(N, & ap, & numargs, args);
#line 776
          __cil_tmp___24 = __cil_tmp___23;
        }
#line 776
        __cil_tmp___32 = __cil_tmp___24;
      } else {
#line 776
        __cil_tmp___31 = arg_index;
#line 776
        arg_index ++;
#line 776
        if (__cil_tmp___31 < numargs) {
#line 776
          __cil_tmp___30 = args[N];
        } else {
#line 776
          if (numargs < 32) {
#line 776
            __cil_tmp___26 = numargs;
#line 776
            numargs ++;
#line 776
            __cil_tmp___27 = __builtin_va_arg(ap, void *);
#line 776
            args[__cil_tmp___26] = __cil_tmp___27;
#line 776
            __cil_tmp___29 = __cil_tmp___27;
          } else {
#line 776
            __cil_tmp___28 = __builtin_va_arg(ap, void *);
#line 776
            __cil_tmp___29 = __cil_tmp___28;
          }
#line 776
          __cil_tmp___30 = __cil_tmp___29;
        }
#line 776
        __cil_tmp___32 = __cil_tmp___30;
      }
#line 776
      lp = (long *)__cil_tmp___32;
#line 777
      *lp = (long )nread;
    } else
#line 780
    if (flags & 2) {
#line 782
      if (is_pos_arg) {
#line 782
        if (N < numargs) {
#line 782
          __cil_tmp___34 = args[N];
        } else {
#line 782
          __cil_tmp___33 = get_arg___4(N, & ap, & numargs, args);
#line 782
          __cil_tmp___34 = __cil_tmp___33;
        }
#line 782
        __cil_tmp___42 = __cil_tmp___34;
      } else {
#line 782
        __cil_tmp___41 = arg_index;
#line 782
        arg_index ++;
#line 782
        if (__cil_tmp___41 < numargs) {
#line 782
          __cil_tmp___40 = args[N];
        } else {
#line 782
          if (numargs < 32) {
#line 782
            __cil_tmp___36 = numargs;
#line 782
            numargs ++;
#line 782
            __cil_tmp___37 = __builtin_va_arg(ap, void *);
#line 782
            args[__cil_tmp___36] = __cil_tmp___37;
#line 782
            __cil_tmp___39 = __cil_tmp___37;
          } else {
#line 782
            __cil_tmp___38 = __builtin_va_arg(ap, void *);
#line 782
            __cil_tmp___39 = __cil_tmp___38;
          }
#line 782
          __cil_tmp___40 = __cil_tmp___39;
        }
#line 782
        __cil_tmp___42 = __cil_tmp___40;
      }
#line 782
      llp = (long long *)__cil_tmp___42;
#line 783
      *llp = (long long )nread;
    } else {
#line 788
      if (is_pos_arg) {
#line 788
        if (N < numargs) {
#line 788
          __cil_tmp___44 = args[N];
        } else {
#line 788
          __cil_tmp___43 = get_arg___4(N, & ap, & numargs, args);
#line 788
          __cil_tmp___44 = __cil_tmp___43;
        }
#line 788
        __cil_tmp___52 = __cil_tmp___44;
      } else {
#line 788
        __cil_tmp___51 = arg_index;
#line 788
        arg_index ++;
#line 788
        if (__cil_tmp___51 < numargs) {
#line 788
          __cil_tmp___50 = args[N];
        } else {
#line 788
          if (numargs < 32) {
#line 788
            __cil_tmp___46 = numargs;
#line 788
            numargs ++;
#line 788
            __cil_tmp___47 = __builtin_va_arg(ap, void *);
#line 788
            args[__cil_tmp___46] = __cil_tmp___47;
#line 788
            __cil_tmp___49 = __cil_tmp___47;
          } else {
#line 788
            __cil_tmp___48 = __builtin_va_arg(ap, void *);
#line 788
            __cil_tmp___49 = __cil_tmp___48;
          }
#line 788
          __cil_tmp___50 = __cil_tmp___49;
        }
#line 788
        __cil_tmp___52 = __cil_tmp___50;
      }
#line 788
      ip = (int *)__cil_tmp___52;
#line 789
      *ip = nread;
    }
#line 791
    goto __Cont;
    case 0: 
#line 798
    __sfp_lock_release();
#line 799
    return (-1);
    default: 
#line 802
    if (((int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 3) == 1) {
#line 803
      flags |= 1;
    }
#line 804
    c = 3;
#line 805
    ccfn = (unsigned long (*)(struct _reent * , char const   * , char ** , int  ))(& _strtol_r);
#line 806
    base = 10;
#line 807
    break;
    }
#line 813
    if (fp->_r <= 0) {
#line 813
      __cil_tmp___53 = __ssrefill_r(rptr, fp);
#line 813
      if (__cil_tmp___53) {
#line 814
        goto input_failure;
      }
    }
#line 820
    if ((flags & 64) == 0) {
#line 822
      while ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )*(fp->_p)))) + (int )*(fp->_p)) & 8) {
#line 824
        nread ++;
#line 825
        (fp->_r) --;
#line 825
        if (fp->_r > 0) {
#line 826
          (fp->_p) ++;
        } else {
#line 828
          __cil_tmp___54 = __ssrefill_r(rptr, fp);
#line 828
          if (__cil_tmp___54) {
#line 829
            goto input_failure;
          }
        }
      }
    }
#line 841
    switch (c) {
    case 0: 
#line 846
    if (width == 0U) {
#line 847
      width = 1U;
    }
#line 849
    if (flags & 1) {
#line 852
      memset((void *)(& state___0), 0, (unsigned int )sizeof(mbstate_t ));
#line 853
      if ((flags & 16) == 0) {
#line 854
        if (is_pos_arg) {
#line 854
          if (N < numargs) {
#line 854
            __cil_tmp___56 = args[N];
          } else {
#line 854
            __cil_tmp___55 = get_arg___4(N, & ap, & numargs, args);
#line 854
            __cil_tmp___56 = __cil_tmp___55;
          }
#line 854
          __cil_tmp___64 = __cil_tmp___56;
        } else {
#line 854
          __cil_tmp___63 = arg_index;
#line 854
          arg_index ++;
#line 854
          if (__cil_tmp___63 < numargs) {
#line 854
            __cil_tmp___62 = args[N];
          } else {
#line 854
            if (numargs < 32) {
#line 854
              __cil_tmp___58 = numargs;
#line 854
              numargs ++;
#line 854
              __cil_tmp___59 = __builtin_va_arg(ap, void *);
#line 854
              args[__cil_tmp___58] = __cil_tmp___59;
#line 854
              __cil_tmp___61 = __cil_tmp___59;
            } else {
#line 854
              __cil_tmp___60 = __builtin_va_arg(ap, void *);
#line 854
              __cil_tmp___61 = __cil_tmp___60;
            }
#line 854
            __cil_tmp___62 = __cil_tmp___61;
          }
#line 854
          __cil_tmp___64 = __cil_tmp___62;
        }
#line 854
        wcp = (wchar_t *)__cil_tmp___64;
      } else {
#line 856
        wcp = (wchar_t *)((void *)0);
      }
#line 857
      n = 0;
#line 858
      while (width != 0U) {
#line 860
        __cil_tmp___65 = __locale_mb_cur_max();
#line 860
        if (n == __cil_tmp___65) {
#line 861
          goto input_failure;
        }
#line 862
        __cil_tmp___66 = n;
#line 862
        n ++;
#line 862
        buf[__cil_tmp___66] = (char )*(fp->_p);
#line 863
        (fp->_r) --;
#line 864
        (fp->_p) ++;
#line 865
        mbslen = _mbrtowc_r(rptr, wcp, (char const   *)(buf), (unsigned int )n, & state___0);
#line 865
        if (mbslen == 4294967295U) {
#line 867
          goto input_failure;
        }
#line 868
        if (mbslen == 0U && ! (flags & 16)) {
#line 869
          *wcp = (short)0;
        }
#line 870
        if (mbslen != 4294967294U) {
#line 872
          nread += n;
#line 873
          width --;
#line 874
          if (! (flags & 16)) {
#line 875
            wcp ++;
          }
#line 876
          n = 0;
        }
#line 878
        if (fp->_r <= 0) {
#line 878
          __cil_tmp___67 = __ssrefill_r(rptr, fp);
#line 878
          if (__cil_tmp___67) {
#line 880
            if (n != 0) {
#line 881
              goto input_failure;
            }
#line 882
            break;
          }
        }
      }
#line 885
      if (! (flags & 16)) {
#line 886
        nassigned ++;
      }
    } else
#line 890
    if (flags & 16) {
#line 892
      sum = 0U;
#line 893
      while (1) {
#line 895
        n = fp->_r;
#line 895
        if (n < (int )width) {
#line 897
          sum += (unsigned int )n;
#line 898
          width -= (unsigned int )n;
#line 899
          fp->_p += n;
#line 900
          __cil_tmp___68 = __ssrefill_r(rptr, fp);
#line 900
          if (__cil_tmp___68) {
#line 902
            if (sum == 0U) {
#line 903
              goto input_failure;
            }
#line 904
            break;
          }
        } else {
#line 909
          sum += width;
#line 910
          fp->_r = (int )((unsigned int )fp->_r - width);
#line 911
          fp->_p += width;
#line 912
          break;
        }
      }
#line 915
      nread = (int )((unsigned int )nread + sum);
    } else {
#line 919
      if (is_pos_arg) {
#line 919
        if (N < numargs) {
#line 919
          __cil_tmp___70 = args[N];
        } else {
#line 919
          __cil_tmp___69 = get_arg___4(N, & ap, & numargs, args);
#line 919
          __cil_tmp___70 = __cil_tmp___69;
        }
#line 919
        __cil_tmp___78 = __cil_tmp___70;
      } else {
#line 919
        __cil_tmp___77 = arg_index;
#line 919
        arg_index ++;
#line 919
        if (__cil_tmp___77 < numargs) {
#line 919
          __cil_tmp___76 = args[N];
        } else {
#line 919
          if (numargs < 32) {
#line 919
            __cil_tmp___72 = numargs;
#line 919
            numargs ++;
#line 919
            __cil_tmp___73 = __builtin_va_arg(ap, void *);
#line 919
            args[__cil_tmp___72] = __cil_tmp___73;
#line 919
            __cil_tmp___75 = __cil_tmp___73;
          } else {
#line 919
            __cil_tmp___74 = __builtin_va_arg(ap, void *);
#line 919
            __cil_tmp___75 = __cil_tmp___74;
          }
#line 919
          __cil_tmp___76 = __cil_tmp___75;
        }
#line 919
        __cil_tmp___78 = __cil_tmp___76;
      }
#line 919
      __cil_tmp___79 = _sfread_r(rptr, (void *)((char *)__cil_tmp___78), 1U, width,
                                 fp);
#line 919
      r = __cil_tmp___79;
#line 921
      if (r == 0U) {
#line 922
        goto input_failure;
      }
#line 923
      nread = (int )((unsigned int )nread + r);
#line 924
      nassigned ++;
    }
#line 926
    break;
    case 1: 
#line 930
    if (width == 0U) {
#line 931
      width = (unsigned int )(~ 0);
    }
#line 933
    if (flags & 16) {
#line 935
      n = 0;
#line 936
      while (ccltab[*(fp->_p)]) {
#line 938
        n ++;
#line 938
        (fp->_r) --;
#line 938
        (fp->_p) ++;
#line 939
        width --;
#line 939
        if (width == 0U) {
#line 940
          break;
        }
#line 941
        if (fp->_r <= 0) {
#line 941
          __cil_tmp___80 = __ssrefill_r(rptr, fp);
#line 941
          if (__cil_tmp___80) {
#line 943
            if (n == 0) {
#line 944
              goto input_failure;
            }
#line 945
            break;
          }
        }
      }
#line 948
      if (n == 0) {
#line 949
        goto match_failure;
      }
    } else {
#line 953
      if (is_pos_arg) {
#line 953
        if (N < numargs) {
#line 953
          __cil_tmp___82 = args[N];
        } else {
#line 953
          __cil_tmp___81 = get_arg___4(N, & ap, & numargs, args);
#line 953
          __cil_tmp___82 = __cil_tmp___81;
        }
#line 953
        __cil_tmp___90 = __cil_tmp___82;
      } else {
#line 953
        __cil_tmp___89 = arg_index;
#line 953
        arg_index ++;
#line 953
        if (__cil_tmp___89 < numargs) {
#line 953
          __cil_tmp___88 = args[N];
        } else {
#line 953
          if (numargs < 32) {
#line 953
            __cil_tmp___84 = numargs;
#line 953
            numargs ++;
#line 953
            __cil_tmp___85 = __builtin_va_arg(ap, void *);
#line 953
            args[__cil_tmp___84] = __cil_tmp___85;
#line 953
            __cil_tmp___87 = __cil_tmp___85;
          } else {
#line 953
            __cil_tmp___86 = __builtin_va_arg(ap, void *);
#line 953
            __cil_tmp___87 = __cil_tmp___86;
          }
#line 953
          __cil_tmp___88 = __cil_tmp___87;
        }
#line 953
        __cil_tmp___90 = __cil_tmp___88;
      }
#line 953
      p = (char *)__cil_tmp___90;
#line 953
      p0 = p;
#line 954
      while (ccltab[*(fp->_p)]) {
#line 956
        (fp->_r) --;
#line 957
        __cil_tmp___91 = p;
#line 957
        p ++;
#line 957
        __cil_tmp___92 = fp->_p;
#line 957
        (fp->_p) ++;
#line 957
        *__cil_tmp___91 = (char )*__cil_tmp___92;
#line 958
        width --;
#line 958
        if (width == 0U) {
#line 959
          break;
        }
#line 960
        if (fp->_r <= 0) {
#line 960
          __cil_tmp___93 = __ssrefill_r(rptr, fp);
#line 960
          if (__cil_tmp___93) {
#line 962
            if ((unsigned int )p == (unsigned int )p0) {
#line 963
              goto input_failure;
            }
#line 964
            break;
          }
        }
      }
#line 967
      n = p - p0;
#line 968
      if (n == 0) {
#line 969
        goto match_failure;
      }
#line 970
      *p = (char)0;
#line 971
      nassigned ++;
    }
#line 973
    nread += n;
#line 974
    break;
    case 2: 
#line 978
    if (width == 0U) {
#line 979
      width = (unsigned int )(~ 0);
    }
#line 981
    if (flags & 1) {
#line 985
      memset((void *)(& state___1), 0, (unsigned int )sizeof(mbstate_t ));
#line 986
      if ((flags & 16) == 0) {
#line 987
        if (is_pos_arg) {
#line 987
          if (N < numargs) {
#line 987
            __cil_tmp___95 = args[N];
          } else {
#line 987
            __cil_tmp___94 = get_arg___4(N, & ap, & numargs, args);
#line 987
            __cil_tmp___95 = __cil_tmp___94;
          }
#line 987
          __cil_tmp___103 = __cil_tmp___95;
        } else {
#line 987
          __cil_tmp___102 = arg_index;
#line 987
          arg_index ++;
#line 987
          if (__cil_tmp___102 < numargs) {
#line 987
            __cil_tmp___101 = args[N];
          } else {
#line 987
            if (numargs < 32) {
#line 987
              __cil_tmp___97 = numargs;
#line 987
              numargs ++;
#line 987
              __cil_tmp___98 = __builtin_va_arg(ap, void *);
#line 987
              args[__cil_tmp___97] = __cil_tmp___98;
#line 987
              __cil_tmp___100 = __cil_tmp___98;
            } else {
#line 987
              __cil_tmp___99 = __builtin_va_arg(ap, void *);
#line 987
              __cil_tmp___100 = __cil_tmp___99;
            }
#line 987
            __cil_tmp___101 = __cil_tmp___100;
          }
#line 987
          __cil_tmp___103 = __cil_tmp___101;
        }
#line 987
        wcp = (wchar_t *)__cil_tmp___103;
      } else {
#line 989
        wcp = & wc;
      }
#line 990
      n = 0;
#line 991
      while (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )*(fp->_p)))) + (int )*(fp->_p)) & 8) && width != 0U) {
#line 993
        __cil_tmp___104 = __locale_mb_cur_max();
#line 993
        if (n == __cil_tmp___104) {
#line 994
          goto input_failure;
        }
#line 995
        __cil_tmp___105 = n;
#line 995
        n ++;
#line 995
        buf[__cil_tmp___105] = (char )*(fp->_p);
#line 996
        (fp->_r) --;
#line 997
        (fp->_p) ++;
#line 998
        mbslen = _mbrtowc_r(rptr, wcp, (char const   *)(buf), (unsigned int )n, & state___1);
#line 998
        if (mbslen == 4294967295U) {
#line 1000
          goto input_failure;
        }
#line 1001
        if (mbslen == 0U) {
#line 1002
          *wcp = (short)0;
        }
#line 1003
        if (mbslen != 4294967294U) {
#line 1005
          __cil_tmp___106 = iswspace((int )*wcp);
#line 1005
          if (__cil_tmp___106) {
#line 1007
            while (n != 0) {
#line 1008
              n --;
#line 1008
              _sungetc_r(rptr, (int )((unsigned char )buf[n]), fp);
            }
#line 1009
            break;
          }
#line 1011
          nread += n;
#line 1012
          width --;
#line 1013
          if ((flags & 16) == 0) {
#line 1014
            wcp ++;
          }
#line 1015
          n = 0;
        }
#line 1017
        if (fp->_r <= 0) {
#line 1017
          __cil_tmp___107 = __ssrefill_r(rptr, fp);
#line 1017
          if (__cil_tmp___107) {
#line 1019
            if (n != 0) {
#line 1020
              goto input_failure;
            }
#line 1021
            break;
          }
        }
      }
#line 1024
      if (! (flags & 16)) {
#line 1026
        *wcp = (short)0;
#line 1027
        nassigned ++;
      }
    } else
#line 1032
    if (flags & 16) {
#line 1034
      n = 0;
#line 1035
      while (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )*(fp->_p)))) + (int )*(fp->_p)) & 8)) {
#line 1037
        n ++;
#line 1037
        (fp->_r) --;
#line 1037
        (fp->_p) ++;
#line 1038
        width --;
#line 1038
        if (width == 0U) {
#line 1039
          break;
        }
#line 1040
        if (fp->_r <= 0) {
#line 1040
          __cil_tmp___108 = __ssrefill_r(rptr, fp);
#line 1040
          if (__cil_tmp___108) {
#line 1041
            break;
          }
        }
      }
#line 1043
      nread += n;
    } else {
#line 1047
      if (is_pos_arg) {
#line 1047
        if (N < numargs) {
#line 1047
          __cil_tmp___110 = args[N];
        } else {
#line 1047
          __cil_tmp___109 = get_arg___4(N, & ap, & numargs, args);
#line 1047
          __cil_tmp___110 = __cil_tmp___109;
        }
#line 1047
        __cil_tmp___118 = __cil_tmp___110;
      } else {
#line 1047
        __cil_tmp___117 = arg_index;
#line 1047
        arg_index ++;
#line 1047
        if (__cil_tmp___117 < numargs) {
#line 1047
          __cil_tmp___116 = args[N];
        } else {
#line 1047
          if (numargs < 32) {
#line 1047
            __cil_tmp___112 = numargs;
#line 1047
            numargs ++;
#line 1047
            __cil_tmp___113 = __builtin_va_arg(ap, void *);
#line 1047
            args[__cil_tmp___112] = __cil_tmp___113;
#line 1047
            __cil_tmp___115 = __cil_tmp___113;
          } else {
#line 1047
            __cil_tmp___114 = __builtin_va_arg(ap, void *);
#line 1047
            __cil_tmp___115 = __cil_tmp___114;
          }
#line 1047
          __cil_tmp___116 = __cil_tmp___115;
        }
#line 1047
        __cil_tmp___118 = __cil_tmp___116;
      }
#line 1047
      p = (char *)__cil_tmp___118;
#line 1047
      p0 = p;
#line 1048
      while (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )*(fp->_p)))) + (int )*(fp->_p)) & 8)) {
#line 1050
        (fp->_r) --;
#line 1051
        __cil_tmp___119 = p;
#line 1051
        p ++;
#line 1051
        __cil_tmp___120 = fp->_p;
#line 1051
        (fp->_p) ++;
#line 1051
        *__cil_tmp___119 = (char )*__cil_tmp___120;
#line 1052
        width --;
#line 1052
        if (width == 0U) {
#line 1053
          break;
        }
#line 1054
        if (fp->_r <= 0) {
#line 1054
          __cil_tmp___121 = __ssrefill_r(rptr, fp);
#line 1054
          if (__cil_tmp___121) {
#line 1055
            break;
          }
        }
      }
#line 1057
      *p = (char)0;
#line 1058
      nread += p - p0;
#line 1059
      nassigned ++;
    }
#line 1061
    goto __Cont;
    case 3: 
#line 1066
    width_left = 0U;
#line 1067
    skips = 0;
#line 1072
    if ((unsigned long )(width - 1U) > sizeof(buf) - 2UL) {
#line 1075
      width_left = (unsigned int )((unsigned long )width - (sizeof(buf) - 1UL));
#line 1076
      width = (unsigned int )(sizeof(buf) - 1UL);
    }
#line 1078
    flags |= 3456;
#line 1079
    p = buf;
#line 1079
    while (width) {
#line 1081
      c = (int )*(fp->_p);
#line 1086
      switch (c) {
      case 48: 
#line 1098
      if (! (flags & 2048)) {
#line 1099
        goto ok;
      }
#line 1100
      if (base == 0) {
#line 1102
        base = 8;
#line 1103
        flags |= 512;
      }
#line 1105
      if (flags & 1024) {
#line 1107
        flags &= -1409;
#line 1108
        goto ok;
      }
#line 1110
      flags &= -897;
#line 1111
      if (width_left) {
#line 1113
        width_left --;
#line 1114
        width ++;
      }
#line 1116
      skips ++;
#line 1117
      goto skip;
      case 49: 
      case 50: 
      case 51: 
      case 52: 
      case 53: 
      case 54: 
      case 55: 
#line 1127
      base = (int )basefix___1[base];
#line 1128
      flags &= -2945;
#line 1129
      goto ok;
      case 56: 
      case 57: 
#line 1134
      base = (int )basefix___1[base];
#line 1135
      if (base <= 8) {
#line 1136
        break;
      }
#line 1137
      flags &= -2945;
#line 1138
      goto ok;
      case 65: 
      case 66: 
      case 67: 
      case 68: 
      case 69: 
      case 70: 
      case 97: 
      case 98: 
      case 99: 
      case 100: 
      case 101: 
      case 102: 
#line 1154
      if (base <= 10) {
#line 1155
        break;
      }
#line 1156
      flags &= -2945;
#line 1157
      goto ok;
      case 43: 
      case 45: 
#line 1162
      if (flags & 128) {
#line 1164
        flags &= -129;
#line 1165
        goto ok;
      }
#line 1167
      break;
      case 120: 
      case 88: 
#line 1172
      if ((flags & 1536) == 512) {
#line 1174
        base = 16;
#line 1175
        flags &= -513;
#line 1179
        flags |= 1280;
#line 1180
        goto ok;
      }
#line 1182
      break;
      }
#line 1189
      break;
      ok: 
#line 1194
      __cil_tmp___122 = p;
#line 1194
      p ++;
#line 1194
      *__cil_tmp___122 = (char )c;
      skip: 
#line 1196
      (fp->_r) --;
#line 1196
      if (fp->_r > 0) {
#line 1197
        (fp->_p) ++;
      } else {
#line 1199
        __cil_tmp___123 = __ssrefill_r(rptr, fp);
#line 1199
        if (__cil_tmp___123) {
#line 1200
          break;
        }
      }
#line 1079
      width --;
    }
#line 1210
    if (flags & 256) {
#line 1212
      if ((unsigned int )p > (unsigned int )(buf)) {
#line 1213
        p --;
#line 1213
        _sungetc_r(rptr, (int )*p, fp);
      }
#line 1214
      if ((unsigned int )p == (unsigned int )(buf)) {
#line 1215
        goto match_failure;
      }
    }
#line 1217
    if ((flags & 16) == 0) {
#line 1221
      *p = (char)0;
#line 1222
      res = (*ccfn)(rptr, (char const   *)(buf), (char **)((void *)0), base);
#line 1223
      if (flags & 32) {
#line 1225
        if (is_pos_arg) {
#line 1225
          if (N < numargs) {
#line 1225
            __cil_tmp___125 = args[N];
          } else {
#line 1225
            __cil_tmp___124 = get_arg___4(N, & ap, & numargs, args);
#line 1225
            __cil_tmp___125 = __cil_tmp___124;
          }
#line 1225
          __cil_tmp___133 = __cil_tmp___125;
        } else {
#line 1225
          __cil_tmp___132 = arg_index;
#line 1225
          arg_index ++;
#line 1225
          if (__cil_tmp___132 < numargs) {
#line 1225
            __cil_tmp___131 = args[N];
          } else {
#line 1225
            if (numargs < 32) {
#line 1225
              __cil_tmp___127 = numargs;
#line 1225
              numargs ++;
#line 1225
              __cil_tmp___128 = __builtin_va_arg(ap, void *);
#line 1225
              args[__cil_tmp___127] = __cil_tmp___128;
#line 1225
              __cil_tmp___130 = __cil_tmp___128;
            } else {
#line 1225
              __cil_tmp___129 = __builtin_va_arg(ap, void *);
#line 1225
              __cil_tmp___130 = __cil_tmp___129;
            }
#line 1225
            __cil_tmp___131 = __cil_tmp___130;
          }
#line 1225
          __cil_tmp___133 = __cil_tmp___131;
        }
#line 1225
        vp = (void **)__cil_tmp___133;
#line 1227
        if (sizeof(uintptr_t ) > sizeof(unsigned long )) {
#line 1230
          resll = _strtoull_r(rptr, (char const   *)(buf), (char **)((void *)0), base);
#line 1231
          *vp = (void *)((unsigned long )resll);
        } else {
#line 1235
          *vp = (void *)res;
        }
      } else
#line 1238
      if (flags & 8) {
#line 1240
        if (is_pos_arg) {
#line 1240
          if (N < numargs) {
#line 1240
            __cil_tmp___135 = args[N];
          } else {
#line 1240
            __cil_tmp___134 = get_arg___4(N, & ap, & numargs, args);
#line 1240
            __cil_tmp___135 = __cil_tmp___134;
          }
#line 1240
          __cil_tmp___143 = __cil_tmp___135;
        } else {
#line 1240
          __cil_tmp___142 = arg_index;
#line 1240
          arg_index ++;
#line 1240
          if (__cil_tmp___142 < numargs) {
#line 1240
            __cil_tmp___141 = args[N];
          } else {
#line 1240
            if (numargs < 32) {
#line 1240
              __cil_tmp___137 = numargs;
#line 1240
              numargs ++;
#line 1240
              __cil_tmp___138 = __builtin_va_arg(ap, void *);
#line 1240
              args[__cil_tmp___137] = __cil_tmp___138;
#line 1240
              __cil_tmp___140 = __cil_tmp___138;
            } else {
#line 1240
              __cil_tmp___139 = __builtin_va_arg(ap, void *);
#line 1240
              __cil_tmp___140 = __cil_tmp___139;
            }
#line 1240
            __cil_tmp___141 = __cil_tmp___140;
          }
#line 1240
          __cil_tmp___143 = __cil_tmp___141;
        }
#line 1240
        cp = (char *)__cil_tmp___143;
#line 1241
        *cp = (char )res;
      } else
#line 1244
      if (flags & 4) {
#line 1246
        if (is_pos_arg) {
#line 1246
          if (N < numargs) {
#line 1246
            __cil_tmp___145 = args[N];
          } else {
#line 1246
            __cil_tmp___144 = get_arg___4(N, & ap, & numargs, args);
#line 1246
            __cil_tmp___145 = __cil_tmp___144;
          }
#line 1246
          __cil_tmp___153 = __cil_tmp___145;
        } else {
#line 1246
          __cil_tmp___152 = arg_index;
#line 1246
          arg_index ++;
#line 1246
          if (__cil_tmp___152 < numargs) {
#line 1246
            __cil_tmp___151 = args[N];
          } else {
#line 1246
            if (numargs < 32) {
#line 1246
              __cil_tmp___147 = numargs;
#line 1246
              numargs ++;
#line 1246
              __cil_tmp___148 = __builtin_va_arg(ap, void *);
#line 1246
              args[__cil_tmp___147] = __cil_tmp___148;
#line 1246
              __cil_tmp___150 = __cil_tmp___148;
            } else {
#line 1246
              __cil_tmp___149 = __builtin_va_arg(ap, void *);
#line 1246
              __cil_tmp___150 = __cil_tmp___149;
            }
#line 1246
            __cil_tmp___151 = __cil_tmp___150;
          }
#line 1246
          __cil_tmp___153 = __cil_tmp___151;
        }
#line 1246
        sp = (short *)__cil_tmp___153;
#line 1247
        *sp = (short )res;
      } else
#line 1249
      if (flags & 1) {
#line 1251
        if (is_pos_arg) {
#line 1251
          if (N < numargs) {
#line 1251
            __cil_tmp___155 = args[N];
          } else {
#line 1251
            __cil_tmp___154 = get_arg___4(N, & ap, & numargs, args);
#line 1251
            __cil_tmp___155 = __cil_tmp___154;
          }
#line 1251
          __cil_tmp___163 = __cil_tmp___155;
        } else {
#line 1251
          __cil_tmp___162 = arg_index;
#line 1251
          arg_index ++;
#line 1251
          if (__cil_tmp___162 < numargs) {
#line 1251
            __cil_tmp___161 = args[N];
          } else {
#line 1251
            if (numargs < 32) {
#line 1251
              __cil_tmp___157 = numargs;
#line 1251
              numargs ++;
#line 1251
              __cil_tmp___158 = __builtin_va_arg(ap, void *);
#line 1251
              args[__cil_tmp___157] = __cil_tmp___158;
#line 1251
              __cil_tmp___160 = __cil_tmp___158;
            } else {
#line 1251
              __cil_tmp___159 = __builtin_va_arg(ap, void *);
#line 1251
              __cil_tmp___160 = __cil_tmp___159;
            }
#line 1251
            __cil_tmp___161 = __cil_tmp___160;
          }
#line 1251
          __cil_tmp___163 = __cil_tmp___161;
        }
#line 1251
        lp = (long *)__cil_tmp___163;
#line 1252
        *lp = (long )res;
      } else
#line 1255
      if (flags & 2) {
#line 1258
        if ((unsigned int )ccfn == (unsigned int )(& _strtoul_r)) {
#line 1259
          resll___0 = _strtoull_r(rptr, (char const   *)(buf), (char **)((void *)0),
                                  base);
        } else {
#line 1261
          __cil_tmp___164 = _strtoll_r(rptr, (char const   *)(buf), (char **)((void *)0),
                                       base);
#line 1261
          resll___0 = (unsigned long long )__cil_tmp___164;
        }
#line 1262
        if (is_pos_arg) {
#line 1262
          if (N < numargs) {
#line 1262
            __cil_tmp___166 = args[N];
          } else {
#line 1262
            __cil_tmp___165 = get_arg___4(N, & ap, & numargs, args);
#line 1262
            __cil_tmp___166 = __cil_tmp___165;
          }
#line 1262
          __cil_tmp___174 = __cil_tmp___166;
        } else {
#line 1262
          __cil_tmp___173 = arg_index;
#line 1262
          arg_index ++;
#line 1262
          if (__cil_tmp___173 < numargs) {
#line 1262
            __cil_tmp___172 = args[N];
          } else {
#line 1262
            if (numargs < 32) {
#line 1262
              __cil_tmp___168 = numargs;
#line 1262
              numargs ++;
#line 1262
              __cil_tmp___169 = __builtin_va_arg(ap, void *);
#line 1262
              args[__cil_tmp___168] = __cil_tmp___169;
#line 1262
              __cil_tmp___171 = __cil_tmp___169;
            } else {
#line 1262
              __cil_tmp___170 = __builtin_va_arg(ap, void *);
#line 1262
              __cil_tmp___171 = __cil_tmp___170;
            }
#line 1262
            __cil_tmp___172 = __cil_tmp___171;
          }
#line 1262
          __cil_tmp___174 = __cil_tmp___172;
        }
#line 1262
        llp = (long long *)__cil_tmp___174;
#line 1263
        *llp = (long long )resll___0;
      } else {
#line 1268
        if (is_pos_arg) {
#line 1268
          if (N < numargs) {
#line 1268
            __cil_tmp___176 = args[N];
          } else {
#line 1268
            __cil_tmp___175 = get_arg___4(N, & ap, & numargs, args);
#line 1268
            __cil_tmp___176 = __cil_tmp___175;
          }
#line 1268
          __cil_tmp___184 = __cil_tmp___176;
        } else {
#line 1268
          __cil_tmp___183 = arg_index;
#line 1268
          arg_index ++;
#line 1268
          if (__cil_tmp___183 < numargs) {
#line 1268
            __cil_tmp___182 = args[N];
          } else {
#line 1268
            if (numargs < 32) {
#line 1268
              __cil_tmp___178 = numargs;
#line 1268
              numargs ++;
#line 1268
              __cil_tmp___179 = __builtin_va_arg(ap, void *);
#line 1268
              args[__cil_tmp___178] = __cil_tmp___179;
#line 1268
              __cil_tmp___181 = __cil_tmp___179;
            } else {
#line 1268
              __cil_tmp___180 = __builtin_va_arg(ap, void *);
#line 1268
              __cil_tmp___181 = __cil_tmp___180;
            }
#line 1268
            __cil_tmp___182 = __cil_tmp___181;
          }
#line 1268
          __cil_tmp___184 = __cil_tmp___182;
        }
#line 1268
        ip = (int *)__cil_tmp___184;
#line 1269
        *ip = (int )res;
      }
#line 1271
      nassigned ++;
    }
#line 1273
    nread += (p - buf) + skips;
#line 1274
    break;
    case 4: 
#line 1284
    leading_zeroes = 0L;
#line 1286
    exp_start = (char *)((void *)0);
#line 1287
    width_left___0 = 0U;
#line 1288
    nancount = (char)0;
#line 1289
    infcount = (char)0;
#line 1294
    if ((unsigned long )(width - 1U) > sizeof(buf) - 2UL) {
#line 1297
      width_left___0 = (unsigned int )((unsigned long )width - (sizeof(buf) - 1UL));
#line 1298
      width = (unsigned int )(sizeof(buf) - 1UL);
    }
#line 1300
    flags |= 1920;
#line 1301
    zeroes___7 = 0L;
#line 1302
    exp_adjust = 0L;
#line 1303
    p = buf;
#line 1303
    while (width) {
#line 1305
      c = (int )*(fp->_p);
#line 1310
      switch (c) {
      case 48: 
#line 1313
      if (flags & 256) {
#line 1315
        flags &= -129;
#line 1316
        zeroes___7 ++;
#line 1317
        if (width_left___0) {
#line 1319
          width_left___0 --;
#line 1320
          width ++;
        }
#line 1322
        goto fskip;
      }
      case 49: 
      case 50: 
      case 51: 
      case 52: 
      case 53: 
      case 54: 
      case 55: 
      case 56: 
      case 57: 
#line 1334
      if ((int )nancount + (int )infcount == 0) {
#line 1336
        flags &= -385;
#line 1337
        goto fok;
      }
#line 1339
      break;
      case 43: 
      case 45: 
#line 1343
      if (flags & 128) {
#line 1345
        flags &= -129;
#line 1346
        goto fok;
      }
#line 1348
      break;
      case 110: 
      case 78: 
#line 1351
      if (((int )nancount == 0 && zeroes___7 == 0L) && (flags & 1792) == 1792) {
#line 1355
        flags &= -1921;
#line 1356
        nancount = (char)1;
#line 1357
        goto fok;
      }
#line 1359
      if ((int )nancount == 2) {
#line 1361
        nancount = (char)3;
#line 1362
        goto fok;
      }
#line 1364
      if ((int )infcount == 1 || (int )infcount == 4) {
#line 1366
        infcount = (char )((int )infcount + 1);
#line 1367
        goto fok;
      }
#line 1369
      break;
      case 97: 
      case 65: 
#line 1372
      if ((int )nancount == 1) {
#line 1374
        nancount = (char)2;
#line 1375
        goto fok;
      }
#line 1377
      break;
      case 105: 
      case 73: 
#line 1380
      if (((int )infcount == 0 && zeroes___7 == 0L) && (flags & 1792) == 1792) {
#line 1384
        flags &= -1921;
#line 1385
        infcount = (char)1;
#line 1386
        goto fok;
      }
#line 1388
      if ((int )infcount == 3 || (int )infcount == 5) {
#line 1390
        infcount = (char )((int )infcount + 1);
#line 1391
        goto fok;
      }
#line 1393
      break;
      case 102: 
      case 70: 
#line 1396
      if ((int )infcount == 2) {
#line 1398
        infcount = (char)3;
#line 1399
        goto fok;
      }
#line 1401
      break;
      case 116: 
      case 84: 
#line 1404
      if ((int )infcount == 6) {
#line 1406
        infcount = (char)7;
#line 1407
        goto fok;
      }
#line 1409
      break;
      case 121: 
      case 89: 
#line 1412
      if ((int )infcount == 7) {
#line 1414
        infcount = (char)8;
#line 1415
        goto fok;
      }
#line 1417
      break;
      case 46: 
#line 1419
      if (flags & 512) {
#line 1421
        flags &= -641;
#line 1422
        leading_zeroes = zeroes___7;
#line 1423
        goto fok;
      }
#line 1425
      break;
      case 101: 
      case 69: 
#line 1429
      if ((flags & 1280) == 1024 || (flags & 1024 && zeroes___7)) {
#line 1432
        if (! (flags & 512)) {
#line 1434
          exp_adjust = zeroes___7 - leading_zeroes;
#line 1435
          exp_start = p;
        }
#line 1437
        flags = ((flags & -1537) | 128) | 256;
#line 1440
        zeroes___7 = 0L;
#line 1441
        goto fok;
      }
#line 1443
      break;
      }
#line 1445
      break;
      fok: 
#line 1447
      __cil_tmp___185 = p;
#line 1447
      p ++;
#line 1447
      *__cil_tmp___185 = (char )c;
      fskip: 
#line 1449
      width --;
#line 1450
      nread ++;
#line 1451
      (fp->_r) --;
#line 1451
      if (fp->_r > 0) {
#line 1452
        (fp->_p) ++;
      } else {
#line 1454
        __cil_tmp___186 = __ssrefill_r(rptr, fp);
#line 1454
        if (__cil_tmp___186) {
#line 1455
          break;
        }
      }
    }
#line 1457
    if (zeroes___7) {
#line 1458
      flags &= -257;
    }
#line 1467
    if ((unsigned int )nancount - 1U < 2U) {
#line 1472
      while ((unsigned int )p > (unsigned int )(buf)) {
#line 1474
        p --;
#line 1474
        _sungetc_r(rptr, (int )*p, fp);
#line 1475
        nread --;
      }
#line 1477
      goto match_failure;
    }
#line 1482
    if ((unsigned int )infcount - 1U < 7U) {
#line 1484
      if ((int )infcount >= 3) {
#line 1485
        while (1) {
#line 1485
          __cil_tmp___187 = infcount;
#line 1485
          infcount = (char )((int )infcount - 1);
#line 1485
          if (! ((int )__cil_tmp___187 > 3)) {
#line 1485
            break;
          }
#line 1487
          p --;
#line 1487
          _sungetc_r(rptr, (int )*p, fp);
#line 1488
          nread --;
        }
      } else {
#line 1492
        while ((unsigned int )p > (unsigned int )(buf)) {
#line 1494
          p --;
#line 1494
          _sungetc_r(rptr, (int )*p, fp);
#line 1495
          nread --;
        }
#line 1497
        goto match_failure;
      }
    }
#line 1505
    if (flags & 256) {
#line 1507
      if (flags & 1024) {
#line 1510
        while ((unsigned int )p > (unsigned int )(buf)) {
#line 1512
          p --;
#line 1512
          _sungetc_r(rptr, (int )*p, fp);
#line 1513
          nread --;
        }
#line 1515
        goto match_failure;
      }
#line 1518
      p --;
#line 1518
      c = (int )*p;
#line 1519
      nread --;
#line 1520
      if (c != 101 && c != 69) {
#line 1522
        _sungetc_r(rptr, c, fp);
#line 1523
        p --;
#line 1523
        c = (int )*p;
#line 1524
        nread --;
      }
#line 1526
      _sungetc_r(rptr, c, fp);
    }
#line 1528
    if ((flags & 16) == 0) {
#line 1530
      res___0 = (double )0;
#line 1537
      new_exp = 0L;
#line 1539
      *p = (char)0;
#line 1540
      if ((flags & 1536) == 1024) {
#line 1542
        exp_adjust = zeroes___7 - leading_zeroes;
#line 1543
        new_exp = - exp_adjust;
#line 1544
        exp_start = p;
      } else
#line 1546
      if (exp_adjust) {
#line 1547
        __cil_tmp___188 = _strtol_r(rptr, (char const   *)(exp_start + 1), (char **)((void *)0),
                                    10);
#line 1547
        new_exp = __cil_tmp___188 - exp_adjust;
      }
#line 1548
      if (exp_adjust) {
#line 1553
        if ((unsigned int )exp_start >= (unsigned int )((buf + sizeof(buf)) - (((8UL * sizeof(long ) - 1UL) * 4UL) / 13UL + 2UL))) {
#line 1554
          exp_start = ((buf + sizeof(buf)) - (((8UL * sizeof(long ) - 1UL) * 4UL) / 13UL + 2UL)) - 1;
        }
#line 1555
        sprintf(exp_start, "e%ld", new_exp);
      }
#line 1566
      res___0 = _strtod_r(rptr, (char const   *)(buf), (char **)((void *)0));
#line 1568
      if (flags & 1) {
#line 1570
        if (is_pos_arg) {
#line 1570
          if (N < numargs) {
#line 1570
            __cil_tmp___190 = args[N];
          } else {
#line 1570
            __cil_tmp___189 = get_arg___4(N, & ap, & numargs, args);
#line 1570
            __cil_tmp___190 = __cil_tmp___189;
          }
#line 1570
          __cil_tmp___198 = __cil_tmp___190;
        } else {
#line 1570
          __cil_tmp___197 = arg_index;
#line 1570
          arg_index ++;
#line 1570
          if (__cil_tmp___197 < numargs) {
#line 1570
            __cil_tmp___196 = args[N];
          } else {
#line 1570
            if (numargs < 32) {
#line 1570
              __cil_tmp___192 = numargs;
#line 1570
              numargs ++;
#line 1570
              __cil_tmp___193 = __builtin_va_arg(ap, void *);
#line 1570
              args[__cil_tmp___192] = __cil_tmp___193;
#line 1570
              __cil_tmp___195 = __cil_tmp___193;
            } else {
#line 1570
              __cil_tmp___194 = __builtin_va_arg(ap, void *);
#line 1570
              __cil_tmp___195 = __cil_tmp___194;
            }
#line 1570
            __cil_tmp___196 = __cil_tmp___195;
          }
#line 1570
          __cil_tmp___198 = __cil_tmp___196;
        }
#line 1570
        dp = (double *)__cil_tmp___198;
#line 1571
        *dp = res___0;
      } else
#line 1573
      if (flags & 2) {
#line 1575
        if (is_pos_arg) {
#line 1575
          if (N < numargs) {
#line 1575
            __cil_tmp___200 = args[N];
          } else {
#line 1575
            __cil_tmp___199 = get_arg___4(N, & ap, & numargs, args);
#line 1575
            __cil_tmp___200 = __cil_tmp___199;
          }
#line 1575
          __cil_tmp___208 = __cil_tmp___200;
        } else {
#line 1575
          __cil_tmp___207 = arg_index;
#line 1575
          arg_index ++;
#line 1575
          if (__cil_tmp___207 < numargs) {
#line 1575
            __cil_tmp___206 = args[N];
          } else {
#line 1575
            if (numargs < 32) {
#line 1575
              __cil_tmp___202 = numargs;
#line 1575
              numargs ++;
#line 1575
              __cil_tmp___203 = __builtin_va_arg(ap, void *);
#line 1575
              args[__cil_tmp___202] = __cil_tmp___203;
#line 1575
              __cil_tmp___205 = __cil_tmp___203;
            } else {
#line 1575
              __cil_tmp___204 = __builtin_va_arg(ap, void *);
#line 1575
              __cil_tmp___205 = __cil_tmp___204;
            }
#line 1575
            __cil_tmp___206 = __cil_tmp___205;
          }
#line 1575
          __cil_tmp___208 = __cil_tmp___206;
        }
#line 1575
        ldp = (long double *)__cil_tmp___208;
#line 1576
        *ldp = (long double )res___0;
      } else {
#line 1580
        if (is_pos_arg) {
#line 1580
          if (N < numargs) {
#line 1580
            __cil_tmp___210 = args[N];
          } else {
#line 1580
            __cil_tmp___209 = get_arg___4(N, & ap, & numargs, args);
#line 1580
            __cil_tmp___210 = __cil_tmp___209;
          }
#line 1580
          __cil_tmp___218 = __cil_tmp___210;
        } else {
#line 1580
          __cil_tmp___217 = arg_index;
#line 1580
          arg_index ++;
#line 1580
          if (__cil_tmp___217 < numargs) {
#line 1580
            __cil_tmp___216 = args[N];
          } else {
#line 1580
            if (numargs < 32) {
#line 1580
              __cil_tmp___212 = numargs;
#line 1580
              numargs ++;
#line 1580
              __cil_tmp___213 = __builtin_va_arg(ap, void *);
#line 1580
              args[__cil_tmp___212] = __cil_tmp___213;
#line 1580
              __cil_tmp___215 = __cil_tmp___213;
            } else {
#line 1580
              __cil_tmp___214 = __builtin_va_arg(ap, void *);
#line 1580
              __cil_tmp___215 = __cil_tmp___214;
            }
#line 1580
            __cil_tmp___216 = __cil_tmp___215;
          }
#line 1580
          __cil_tmp___218 = __cil_tmp___216;
        }
#line 1580
        flp = (float *)__cil_tmp___218;
#line 1581
        if (sizeof(res___0) == sizeof(float )) {
#line 1581
          __cil_tmp___219 = __fpclassifyf((float )res___0);
#line 1581
          __cil_tmp___221 = __cil_tmp___219;
        } else {
#line 1581
          __cil_tmp___220 = __fpclassifyd(res___0);
#line 1581
          __cil_tmp___221 = __cil_tmp___220;
        }
#line 1581
        if (__cil_tmp___221 == 0) {
#line 1582
          *flp = nanf((char const   *)((void *)0));
        } else {
#line 1584
          *flp = (float )res___0;
        }
      }
#line 1586
      nassigned ++;
    }
#line 1588
    break;
    }
    __Cont: ;
  }
  input_failure: 
#line 1599
  __sfp_lock_release();
#line 1600
  return (nassigned && ! ((int )fp->_flags & 64) ? nassigned : -1);
  match_failure: 
#line 1605
  __sfp_lock_release();
#line 1606
  return (nassigned);
}
}
#line 1613 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfscanf.c"
static void *get_arg___4(int n , va_list *ap , int *numargs_p , void **args ) 
{ int numargs ;
  int __cil_tmp ;

  {
#line 1616
  numargs = *numargs_p;
#line 1617
  while (n >= numargs) {
#line 1618
    __cil_tmp = numargs;
#line 1618
    numargs ++;
#line 1618
    *(args + __cil_tmp) = __builtin_va_arg(*ap, void *);
  }
#line 1619
  *numargs_p = numargs;
#line 1620
  return (*(args + n));
}
}
#line 1 "lib_a-svfwprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-aS989mZ4.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 1 "lib_a-svfwscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lAn2QfIv.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-swab.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-kJlom1Qg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-swprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CSQRF3tr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-swscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-WaTLHEY9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-system.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-otueFCQA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tdelete.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NTm811xd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tdestroy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8U55T9oZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-telldir.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-TeG1i9VQ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tfind.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-TkOlsE5m.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-time.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-fkqAUi8p.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 40 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/time/time.c"
time_t time(time_t *t ) 
{ struct timeval now ;
  int __cil_tmp ;

  {
#line 46
  __cil_tmp = gettimeofday(& now, (void *)0);
#line 46
  if (__cil_tmp >= 0) {
#line 48
    if (t) {
#line 49
      *t = now.tv_sec;
    }
#line 50
    return (now.tv_sec);
  }
#line 52
  return (-1L);
}
}
#line 1 "lib_a-timelocal.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-e7loxBB0.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-timesr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-3QDYuQZX.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tmpfile.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-e1Al3Xup.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tmpnam.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hzN3kauf.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-toascii.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wlTFFtfE.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tolower.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7wijK5J5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-toupper.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-XxOG0t8O.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-towctrans.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8Li1Bv3P.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-towlower.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-RPJgeVYt.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-towupper.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-03cNZr9S.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tsearch.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-zgfzxFvI.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-twalk.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-KwqCFj2j.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tzlock.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-KEtEHjoJ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tzset.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-aNdgB6hl.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tzset_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IjraTZpN.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-tzvars.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ECcf8vBU.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-u_strerr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7hQ9RXLW.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 3 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/string/u_strerr.c"
char *_user_strerror(int errnum ) 
{ 

  {
#line 7
  return ((char *)0);
}
}
#line 1 "lib_a-unctrl.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jCBBqv5p.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-ungetc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7Md3jdDE.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 79 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/ungetc.c"
int __submore(struct _reent *rptr , FILE *fp ) 
{ register int i ;
  register unsigned char *p ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 87
  if ((unsigned int )fp->_ub._base == (unsigned int )(fp->_ubuf)) {
#line 92
    __cil_tmp = _malloc_r(rptr, 1024U);
#line 92
    p = (unsigned char *)__cil_tmp;
#line 92
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 93
      return (-1);
    }
#line 94
    fp->_ub._base = p;
#line 95
    fp->_ub._size = 1024;
#line 96
    p += 1024UL - sizeof(fp->_ubuf);
#line 97
    i = (int )sizeof(fp->_ubuf);
#line 97
    while (1) {
#line 97
      i --;
#line 97
      if (! (i >= 0)) {
#line 97
        break;
      }
#line 98
      *(p + i) = fp->_ubuf[i];
    }
#line 99
    fp->_p = p;
#line 100
    return (0);
  }
#line 102
  i = fp->_ub._size;
#line 103
  __cil_tmp___0 = _realloc_r(rptr, (void *)fp->_ub._base, (unsigned int )(i << 1));
#line 103
  p = (unsigned char *)__cil_tmp___0;
#line 104
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 105
    return (-1);
  }
#line 106
  memcpy((void *)(p + i), (void const   *)((void *)p), (unsigned int )i);
#line 107
  fp->_p = p + i;
#line 108
  fp->_ub._base = p;
#line 109
  fp->_ub._size = i << 1;
#line 110
  return (0);
}
}
#line 1 "lib_a-ungetwc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-fdcC0oyK.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-unlinkr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dRUpwqyH.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-usleep.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wU12VFrL.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-valloc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-BHGBAJa9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vallocr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-8LHvkJGE.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vasiprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-mIgDRWHt.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vasniprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NsRReO2n.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vasnprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-R54ICRhA.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vasprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Gc4quSQQ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vdiprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dL5F369U.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vdprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-WbLi4esZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vfiprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-f5b46GNt.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 292 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
int __sprint_r(struct _reent *ptr , FILE *fp , struct __suio *uio ) 
{ register int err ;
  struct __siov *iov ;
  wchar_t *p ;
  int i ;
  int len ;
  wint_t __cil_tmp ;

  {
#line 298
  err = 0;
#line 300
  if (uio->uio_resid == 0) {
#line 301
    uio->uio_iovcnt = 0;
#line 302
    return (0);
  }
#line 304
  if (fp->_flags2 & 8192) {
#line 309
    iov = uio->uio_iov;
#line 310
    while (uio->uio_resid != 0) {
#line 312
      p = (wchar_t *)iov->iov_base;
#line 313
      len = (int )((unsigned long )iov->iov_len / sizeof(wchar_t ));
#line 314
      i = 0;
#line 314
      while (i < len) {
#line 315
        __cil_tmp = _fputwc_r(ptr, *(p + i), fp);
#line 315
        if (__cil_tmp == -1) {
#line 316
          err = -1;
#line 317
          goto out;
        }
#line 314
        i ++;
      }
#line 310
      uio->uio_resid = (int )((unsigned long )uio->uio_resid - (unsigned long )len * sizeof(wchar_t ));
#line 310
      iov ++;
    }
  } else {
#line 322
    err = __sfvwrite_r(ptr, fp, uio);
  }
  out: 
#line 324
  uio->uio_resid = 0;
#line 325
  uio->uio_iovcnt = 0;
#line 326
  return (err);
}
}
#line 1 "lib_a-vfiscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-XWYoKwo5.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vfiwprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CLOrYUPw.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 1 "lib_a-vfiwscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vofiXbyG.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vfprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-sao6z0Mn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 337 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static int __sbprintf___0(struct _reent *rptr , FILE *fp , char const   *fmt , va_list ap ) 
{ int ret ;
  FILE fake ;
  unsigned char buf[1024] ;
  int __cil_tmp ;

  {
#line 349
  fake._flags = (short )((int )fp->_flags & -3);
#line 350
  fake._flags2 = fp->_flags2;
#line 351
  fake._file = fp->_file;
#line 352
  fake._cookie = fp->_cookie;
#line 353
  fake._write = fp->_write;
#line 356
  fake._p = buf;
#line 356
  fake._bf._base = fake._p;
#line 357
  fake._w = (int )sizeof(buf);
#line 357
  fake._bf._size = fake._w;
#line 358
  fake._lbfsize = 0;
#line 364
  ret = _vfprintf_r(rptr, & fake, fmt, ap);
#line 365
  if (ret >= 0) {
#line 365
    __cil_tmp = _fflush_r(rptr, & fake);
#line 365
    if (__cil_tmp) {
#line 366
      ret = -1;
    }
  }
#line 367
  if ((int )fake._flags & 64) {
#line 368
    fp->_flags = (short )((int )fp->_flags | 64);
  }
#line 373
  return (ret);
}
}
#line 413
static char *cvt___0(struct _reent *data , double value , int ndigits , int flags ,
                     char *sign , int *decpt , int ch , int *length , char *buf ) ;
#line 416
static int exponent___0(char *p0 , int exp___0 , int fmtch ) ;
#line 485
static union arg_val *get_arg___11(struct _reent *data , int n , char *fmt , va_list *ap ,
                                   int *numargs_p , union arg_val *args , int *arg_type ,
                                   char **last_fmt ) ;
#line 615 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static char const   blanks___5[16]  = 
#line 615
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' '};
#line 617 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static char const   zeroes___5[16]  = 
#line 617
  {      (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'0'};
#line 540 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
int _vfprintf_r(struct _reent *data , FILE *fp , char const   *fmt0 , va_list ap ) 
{ register char *fmt ;
  register int ch ;
  register int n ;
  register int m ;
  register char *cp ;
  register struct __siov *iovp ;
  register int flags ;
  char *fmt_anchor ;
  int N ;
  int arg_index ;
  int numargs ;
  char *saved_fmt ;
  union arg_val args[32] ;
  int arg_type[32] ;
  int is_pos_arg ;
  int old_is_pos_arg ;
  int ret ;
  int width ;
  int prec ;
  char sign ;
  char *thousands_sep ;
  size_t thsnd_len ;
  char const   *grouping ;
  char *decimal_point ;
  struct lconv *__cil_tmp ;
  size_t decp_len ;
  size_t __cil_tmp___0 ;
  char softsign ;
  union __anonunion__double__21___1 _double_ ;
  int expt ;
  int expsize ;
  char expstr[7] ;
  int lead ;
  int ndig ;
  int nseps ;
  int nrepeats ;
  unsigned long long _uquad ;
  enum __anonenum_base_22___1 base ;
  int dprec ;
  int realsz ;
  int size ;
  char *xdigs ;
  struct __suio uio ;
  struct __siov iov[8] ;
  char buf[100] ;
  char ox[2] ;
  char *malloc_buf ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  char *__cil_tmp___4 ;
  struct lconv *__cil_tmp___5 ;
  struct lconv *__cil_tmp___6 ;
  char *old_fmt ;
  char *__cil_tmp___7 ;
  char *__cil_tmp___8 ;
  union arg_val *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  int __cil_tmp___17 ;
  char *old_fmt___0 ;
  char *__cil_tmp___18 ;
  char *__cil_tmp___19 ;
  union arg_val *__cil_tmp___20 ;
  int __cil_tmp___21 ;
  int __cil_tmp___23 ;
  int __cil_tmp___24 ;
  int __cil_tmp___25 ;
  int __cil_tmp___26 ;
  int __cil_tmp___27 ;
  int __cil_tmp___28 ;
  char *__cil_tmp___29 ;
  char *__cil_tmp___30 ;
  char *__cil_tmp___31 ;
  union arg_val *__cil_tmp___32 ;
  int __cil_tmp___33 ;
  int __cil_tmp___35 ;
  int __cil_tmp___36 ;
  int __cil_tmp___37 ;
  int __cil_tmp___38 ;
  int __cil_tmp___39 ;
  int __cil_tmp___40 ;
  union arg_val *__cil_tmp___41 ;
  long long __cil_tmp___42 ;
  int __cil_tmp___44 ;
  long long __cil_tmp___45 ;
  long long __cil_tmp___46 ;
  long long __cil_tmp___47 ;
  long long __cil_tmp___48 ;
  int __cil_tmp___49 ;
  long long __cil_tmp___50 ;
  union arg_val *__cil_tmp___51 ;
  long __cil_tmp___52 ;
  int __cil_tmp___54 ;
  long __cil_tmp___55 ;
  long __cil_tmp___56 ;
  long __cil_tmp___57 ;
  long __cil_tmp___58 ;
  int __cil_tmp___59 ;
  long __cil_tmp___60 ;
  union arg_val *__cil_tmp___61 ;
  int __cil_tmp___62 ;
  int __cil_tmp___64 ;
  int __cil_tmp___65 ;
  int __cil_tmp___66 ;
  int __cil_tmp___67 ;
  int __cil_tmp___68 ;
  int __cil_tmp___69 ;
  int __cil_tmp___70 ;
  union arg_val *__cil_tmp___71 ;
  int __cil_tmp___72 ;
  int __cil_tmp___74 ;
  int __cil_tmp___75 ;
  int __cil_tmp___76 ;
  int __cil_tmp___77 ;
  int __cil_tmp___78 ;
  int __cil_tmp___79 ;
  int __cil_tmp___80 ;
  union arg_val *__cil_tmp___81 ;
  int __cil_tmp___82 ;
  int __cil_tmp___84 ;
  int __cil_tmp___85 ;
  int __cil_tmp___86 ;
  int __cil_tmp___87 ;
  int __cil_tmp___88 ;
  int __cil_tmp___89 ;
  int __cil_tmp___90 ;
  long __cil_tmp___91 ;
  long __cil_tmp___92 ;
  long __cil_tmp___93 ;
  union arg_val *__cil_tmp___94 ;
  long double __cil_tmp___95 ;
  int __cil_tmp___97 ;
  long double __cil_tmp___98 ;
  long double __cil_tmp___99 ;
  long double __cil_tmp___100 ;
  long double __cil_tmp___101 ;
  int __cil_tmp___102 ;
  long double __cil_tmp___103 ;
  union arg_val *__cil_tmp___104 ;
  double __cil_tmp___105 ;
  int __cil_tmp___107 ;
  double __cil_tmp___108 ;
  double __cil_tmp___109 ;
  double __cil_tmp___110 ;
  double __cil_tmp___111 ;
  int __cil_tmp___112 ;
  int __cil_tmp___113 ;
  int __cil_tmp___114 ;
  int __cil_tmp___115 ;
  int __cil_tmp___116 ;
  int __cil_tmp___117 ;
  int __cil_tmp___118 ;
  void *__cil_tmp___119 ;
  union arg_val *__cil_tmp___120 ;
  quad_ptr_t __cil_tmp___121 ;
  int __cil_tmp___123 ;
  quad_ptr_t __cil_tmp___124 ;
  quad_ptr_t __cil_tmp___125 ;
  quad_ptr_t __cil_tmp___126 ;
  quad_ptr_t __cil_tmp___127 ;
  int __cil_tmp___128 ;
  quad_ptr_t __cil_tmp___129 ;
  union arg_val *__cil_tmp___130 ;
  long_ptr_t __cil_tmp___131 ;
  int __cil_tmp___133 ;
  long_ptr_t __cil_tmp___134 ;
  long_ptr_t __cil_tmp___135 ;
  long_ptr_t __cil_tmp___136 ;
  long_ptr_t __cil_tmp___137 ;
  int __cil_tmp___138 ;
  long_ptr_t __cil_tmp___139 ;
  union arg_val *__cil_tmp___140 ;
  short_ptr_t __cil_tmp___141 ;
  int __cil_tmp___143 ;
  short_ptr_t __cil_tmp___144 ;
  short_ptr_t __cil_tmp___145 ;
  short_ptr_t __cil_tmp___146 ;
  short_ptr_t __cil_tmp___147 ;
  int __cil_tmp___148 ;
  short_ptr_t __cil_tmp___149 ;
  union arg_val *__cil_tmp___150 ;
  char_ptr_t __cil_tmp___151 ;
  int __cil_tmp___153 ;
  char_ptr_t __cil_tmp___154 ;
  char_ptr_t __cil_tmp___155 ;
  char_ptr_t __cil_tmp___156 ;
  char_ptr_t __cil_tmp___157 ;
  int __cil_tmp___158 ;
  char_ptr_t __cil_tmp___159 ;
  union arg_val *__cil_tmp___160 ;
  int_ptr_t __cil_tmp___161 ;
  int __cil_tmp___163 ;
  int_ptr_t __cil_tmp___164 ;
  int_ptr_t __cil_tmp___165 ;
  int_ptr_t __cil_tmp___166 ;
  int_ptr_t __cil_tmp___167 ;
  int __cil_tmp___168 ;
  int_ptr_t __cil_tmp___169 ;
  union arg_val *__cil_tmp___170 ;
  unsigned long long __cil_tmp___171 ;
  int __cil_tmp___173 ;
  unsigned long long __cil_tmp___174 ;
  unsigned long long __cil_tmp___175 ;
  unsigned long long __cil_tmp___176 ;
  unsigned long long __cil_tmp___177 ;
  int __cil_tmp___178 ;
  unsigned long long __cil_tmp___179 ;
  union arg_val *__cil_tmp___180 ;
  u_long __cil_tmp___181 ;
  int __cil_tmp___183 ;
  u_long __cil_tmp___184 ;
  u_long __cil_tmp___185 ;
  u_long __cil_tmp___186 ;
  u_long __cil_tmp___187 ;
  int __cil_tmp___188 ;
  u_long __cil_tmp___189 ;
  union arg_val *__cil_tmp___190 ;
  int __cil_tmp___191 ;
  int __cil_tmp___193 ;
  int __cil_tmp___194 ;
  int __cil_tmp___195 ;
  int __cil_tmp___196 ;
  int __cil_tmp___197 ;
  int __cil_tmp___198 ;
  int __cil_tmp___199 ;
  union arg_val *__cil_tmp___200 ;
  int __cil_tmp___201 ;
  int __cil_tmp___203 ;
  int __cil_tmp___204 ;
  int __cil_tmp___205 ;
  int __cil_tmp___206 ;
  int __cil_tmp___207 ;
  int __cil_tmp___208 ;
  int __cil_tmp___209 ;
  union arg_val *__cil_tmp___210 ;
  u_int __cil_tmp___211 ;
  int __cil_tmp___213 ;
  u_int __cil_tmp___214 ;
  u_int __cil_tmp___215 ;
  u_int __cil_tmp___216 ;
  u_int __cil_tmp___217 ;
  int __cil_tmp___218 ;
  u_int __cil_tmp___219 ;
  unsigned long __cil_tmp___220 ;
  unsigned long __cil_tmp___221 ;
  u_long __cil_tmp___222 ;
  union arg_val *__cil_tmp___223 ;
  void_ptr_t __cil_tmp___224 ;
  int __cil_tmp___226 ;
  void_ptr_t __cil_tmp___227 ;
  void_ptr_t __cil_tmp___228 ;
  void_ptr_t __cil_tmp___229 ;
  void_ptr_t __cil_tmp___230 ;
  int __cil_tmp___231 ;
  void_ptr_t __cil_tmp___232 ;
  union arg_val *__cil_tmp___233 ;
  char_ptr_t __cil_tmp___234 ;
  int __cil_tmp___236 ;
  char_ptr_t __cil_tmp___237 ;
  char_ptr_t __cil_tmp___238 ;
  char_ptr_t __cil_tmp___239 ;
  char_ptr_t __cil_tmp___240 ;
  int __cil_tmp___241 ;
  char *p ;
  void *__cil_tmp___242 ;
  size_t __cil_tmp___243 ;
  union arg_val *__cil_tmp___244 ;
  unsigned long long __cil_tmp___245 ;
  int __cil_tmp___247 ;
  unsigned long long __cil_tmp___248 ;
  unsigned long long __cil_tmp___249 ;
  unsigned long long __cil_tmp___250 ;
  unsigned long long __cil_tmp___251 ;
  int __cil_tmp___252 ;
  unsigned long long __cil_tmp___253 ;
  union arg_val *__cil_tmp___254 ;
  u_long __cil_tmp___255 ;
  int __cil_tmp___257 ;
  u_long __cil_tmp___258 ;
  u_long __cil_tmp___259 ;
  u_long __cil_tmp___260 ;
  u_long __cil_tmp___261 ;
  int __cil_tmp___262 ;
  u_long __cil_tmp___263 ;
  union arg_val *__cil_tmp___264 ;
  int __cil_tmp___265 ;
  int __cil_tmp___267 ;
  int __cil_tmp___268 ;
  int __cil_tmp___269 ;
  int __cil_tmp___270 ;
  int __cil_tmp___271 ;
  int __cil_tmp___272 ;
  int __cil_tmp___273 ;
  union arg_val *__cil_tmp___274 ;
  int __cil_tmp___275 ;
  int __cil_tmp___277 ;
  int __cil_tmp___278 ;
  int __cil_tmp___279 ;
  int __cil_tmp___280 ;
  int __cil_tmp___281 ;
  int __cil_tmp___282 ;
  int __cil_tmp___283 ;
  union arg_val *__cil_tmp___284 ;
  u_int __cil_tmp___285 ;
  int __cil_tmp___287 ;
  u_int __cil_tmp___288 ;
  u_int __cil_tmp___289 ;
  u_int __cil_tmp___290 ;
  u_int __cil_tmp___291 ;
  int __cil_tmp___292 ;
  u_int __cil_tmp___293 ;
  unsigned long __cil_tmp___294 ;
  unsigned long __cil_tmp___295 ;
  u_long __cil_tmp___296 ;
  union arg_val *__cil_tmp___297 ;
  unsigned long long __cil_tmp___298 ;
  int __cil_tmp___300 ;
  unsigned long long __cil_tmp___301 ;
  unsigned long long __cil_tmp___302 ;
  unsigned long long __cil_tmp___303 ;
  unsigned long long __cil_tmp___304 ;
  int __cil_tmp___305 ;
  unsigned long long __cil_tmp___306 ;
  union arg_val *__cil_tmp___307 ;
  u_long __cil_tmp___308 ;
  int __cil_tmp___310 ;
  u_long __cil_tmp___311 ;
  u_long __cil_tmp___312 ;
  u_long __cil_tmp___313 ;
  u_long __cil_tmp___314 ;
  int __cil_tmp___315 ;
  u_long __cil_tmp___316 ;
  union arg_val *__cil_tmp___317 ;
  int __cil_tmp___318 ;
  int __cil_tmp___320 ;
  int __cil_tmp___321 ;
  int __cil_tmp___322 ;
  int __cil_tmp___323 ;
  int __cil_tmp___324 ;
  int __cil_tmp___325 ;
  int __cil_tmp___326 ;
  union arg_val *__cil_tmp___327 ;
  int __cil_tmp___328 ;
  int __cil_tmp___330 ;
  int __cil_tmp___331 ;
  int __cil_tmp___332 ;
  int __cil_tmp___333 ;
  int __cil_tmp___334 ;
  int __cil_tmp___335 ;
  int __cil_tmp___336 ;
  union arg_val *__cil_tmp___337 ;
  u_int __cil_tmp___338 ;
  int __cil_tmp___340 ;
  u_int __cil_tmp___341 ;
  u_int __cil_tmp___342 ;
  u_int __cil_tmp___343 ;
  u_int __cil_tmp___344 ;
  int __cil_tmp___345 ;
  u_int __cil_tmp___346 ;
  unsigned long __cil_tmp___347 ;
  unsigned long __cil_tmp___348 ;
  u_long __cil_tmp___349 ;
  size_t __cil_tmp___350 ;
  int __cil_tmp___351 ;
  int __cil_tmp___352 ;
  int __cil_tmp___353 ;
  int __cil_tmp___354 ;
  int __cil_tmp___355 ;
  int __cil_tmp___356 ;
  int __cil_tmp___357 ;
  int __cil_tmp___358 ;
  int __cil_tmp___359 ;
  int __cil_tmp___360 ;
  int __cil_tmp___361 ;
  int __cil_tmp___362 ;
  int __cil_tmp___363 ;
  int __cil_tmp___364 ;
  int __cil_tmp___365 ;
  int __cil_tmp___366 ;
  int __cil_tmp___367 ;
  int __cil_tmp___368 ;
  char *convbuf ;
  int n___0 ;
  int __cil_tmp___369 ;
  int __cil_tmp___370 ;
  int __cil_tmp___371 ;
  int __cil_tmp___372 ;
  int n___1 ;
  int __cil_tmp___373 ;
  int __cil_tmp___374 ;
  int __cil_tmp___375 ;
  int __cil_tmp___376 ;
  int n___2 ;
  int __cil_tmp___377 ;
  int __cil_tmp___378 ;
  int __cil_tmp___379 ;
  int __cil_tmp___380 ;
  int __cil_tmp___381 ;
  int __cil_tmp___382 ;
  int __cil_tmp___383 ;
  int __cil_tmp___384 ;
  int __cil_tmp___385 ;
  int __cil_tmp___386 ;
  int __cil_tmp___387 ;
  int __cil_tmp___388 ;
  int __cil_tmp___389 ;
  int __cil_tmp___390 ;

  {
#line 575
  __cil_tmp = _localeconv_r(data);
#line 575
  decimal_point = __cil_tmp->decimal_point;
#line 576
  __cil_tmp___0 = strlen((char const   *)decimal_point);
#line 576
  decp_len = __cil_tmp___0;
#line 578
  _double_.i = 0;
#line 581
  expsize = 0;
#line 586
  ndig = 0;
#line 597
  xdigs = (char *)((void *)0);
#line 607
  malloc_buf = (char *)((void *)0);
#line 710
  while (1) {
#line 710
    if (data && ! data->__sdidinit) {
#line 710
      __sinit(data);
    }
#line 710
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 710
      fp = data->_stdin;
    } else
#line 710
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 710
      fp = data->_stdout;
    } else
#line 710
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 710
      fp = data->_stderr;
    }
#line 710
    break;
  }
#line 711
  if ((int )fp->_flags & 512) {

  }
#line 713
  while (1) {
#line 713
    if (! ((int )fp->_flags & 8192)) {
#line 713
      fp->_flags = (short )((int )fp->_flags | 8192);
#line 713
      fp->_flags2 &= -8193;
    }
#line 713
    break;
  }
#line 716
  if (((int )fp->_flags & 8) == 0 || (unsigned int )fp->_bf._base == (unsigned int )((void *)0)) {
#line 716
    __cil_tmp___1 = __swsetup_r(data, fp);
#line 716
    if (__cil_tmp___1) {
#line 717
      if ((int )fp->_flags & 512) {

      }
#line 718
      return (-1);
    }
  }
#line 722
  if (((int )fp->_flags & 26) == 10 && (int )fp->_file >= 0) {
#line 724
    if ((int )fp->_flags & 512) {

    }
#line 725
    __cil_tmp___2 = __sbprintf___0(data, fp, fmt0, ap);
#line 725
    return (__cil_tmp___2);
  }
#line 741
  fmt = (char *)fmt0;
#line 742
  iovp = iov;
#line 742
  uio.uio_iov = iovp;
#line 743
  uio.uio_resid = 0;
#line 744
  uio.uio_iovcnt = 0;
#line 745
  ret = 0;
#line 747
  arg_index = 0;
#line 748
  saved_fmt = (char *)((void *)0);
#line 749
  arg_type[0] = -1;
#line 750
  numargs = 0;
#line 751
  is_pos_arg = 0;
#line 757
  while (1) {
#line 758
    cp = fmt;
#line 772
    while ((int )*fmt != 0 && (int )*fmt != 37) {
#line 773
      fmt ++;
    }
#line 775
    m = fmt - cp;
#line 775
    if (m != 0) {
#line 776
      iovp->iov_base = (void const   *)cp;
#line 776
      iovp->iov_len = (unsigned int )m;
#line 776
      uio.uio_resid += m;
#line 776
      iovp ++;
#line 776
      (uio.uio_iovcnt) ++;
#line 776
      if (uio.uio_iovcnt >= 8) {
#line 776
        __cil_tmp___3 = __sprint_r(data, fp, & uio);
#line 776
        if (__cil_tmp___3) {
#line 776
          goto error;
        }
#line 776
        iovp = iov;
      }
#line 777
      ret += m;
    }
#line 783
    if ((int )*fmt == 0) {
#line 784
      goto done;
    }
#line 786
    fmt_anchor = fmt;
#line 787
    fmt ++;
#line 789
    flags = 0;
#line 790
    dprec = 0;
#line 791
    width = 0;
#line 792
    prec = -1;
#line 793
    sign = (char )'\000';
#line 795
    lead = 0;
#line 798
    nrepeats = 0;
#line 798
    nseps = nrepeats;
#line 801
    N = arg_index;
#line 802
    is_pos_arg = 0;
    rflag: 
#line 805
    __cil_tmp___4 = fmt;
#line 805
    fmt ++;
#line 805
    ch = (int )*__cil_tmp___4;
    reswitch: 
#line 806
    switch (ch) {
    case 39: 
#line 809
    __cil_tmp___5 = _localeconv_r(data);
#line 809
    thousands_sep = __cil_tmp___5->thousands_sep;
#line 810
    thsnd_len = strlen((char const   *)thousands_sep);
#line 811
    __cil_tmp___6 = _localeconv_r(data);
#line 811
    grouping = (char const   *)__cil_tmp___6->grouping;
#line 812
    if ((thsnd_len > 0U && grouping) && *grouping) {
#line 813
      flags |= 1024;
    }
#line 814
    goto rflag;
    case 32: 
#line 822
    if (! sign) {
#line 823
      sign = (char )' ';
    }
#line 824
    goto rflag;
    case 35: 
#line 826
    flags |= 1;
#line 827
    goto rflag;
    case 42: 
#line 831
    n = N;
#line 832
    old_is_pos_arg = is_pos_arg;
#line 833
    is_pos_arg = 0;
#line 834
    if ((unsigned int )((int )*fmt - 48) <= 9U) {
#line 835
      old_fmt = fmt;
#line 837
      n = 0;
#line 838
      __cil_tmp___7 = fmt;
#line 838
      fmt ++;
#line 838
      ch = (int )*__cil_tmp___7;
#line 839
      while (1) {
#line 840
        n = 10 * n + (ch - 48);
#line 841
        __cil_tmp___8 = fmt;
#line 841
        fmt ++;
#line 841
        ch = (int )*__cil_tmp___8;
#line 839
        if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 839
          break;
        }
      }
#line 844
      if (ch == 36) {
#line 845
        if (n <= 32) {
#line 846
          n --;
#line 847
          is_pos_arg = 1;
        } else {
#line 850
          goto error;
        }
      } else {
#line 853
        fmt = old_fmt;
#line 854
        goto rflag;
      }
    }
#line 865
    if (is_pos_arg) {
#line 865
      if (n < numargs) {
#line 865
        __cil_tmp___10 = args[n].val_int;
      } else {
#line 865
        __cil_tmp___9 = get_arg___11(data, n, fmt_anchor, & ap, & numargs, args, arg_type,
                                     & saved_fmt);
#line 865
        __cil_tmp___10 = __cil_tmp___9->val_int;
      }
#line 865
      width = __cil_tmp___10;
    } else {
#line 865
      __cil_tmp___17 = arg_index;
#line 865
      arg_index ++;
#line 865
      if (__cil_tmp___17 < numargs) {
#line 865
        __cil_tmp___16 = args[n].val_int;
      } else {
#line 865
        if (numargs < 32) {
#line 865
          __cil_tmp___12 = numargs;
#line 865
          numargs ++;
#line 865
          __cil_tmp___13 = __builtin_va_arg(ap, int );
#line 865
          args[__cil_tmp___12].val_int = __cil_tmp___13;
#line 865
          __cil_tmp___15 = __cil_tmp___13;
        } else {
#line 865
          __cil_tmp___14 = __builtin_va_arg(ap, int );
#line 865
          __cil_tmp___15 = __cil_tmp___14;
        }
#line 865
        __cil_tmp___16 = __cil_tmp___15;
      }
#line 865
      width = __cil_tmp___16;
    }
#line 867
    is_pos_arg = old_is_pos_arg;
#line 869
    if (width >= 0) {
#line 870
      goto rflag;
    }
#line 871
    width = - width;
    case 45: 
#line 874
    flags |= 4;
#line 875
    goto rflag;
    case 43: 
#line 877
    sign = (char )'+';
#line 878
    goto rflag;
    case 46: 
#line 880
    __cil_tmp___29 = fmt;
#line 880
    fmt ++;
#line 880
    ch = (int )*__cil_tmp___29;
#line 880
    if (ch == 42) {
#line 883
      n = N;
#line 884
      old_is_pos_arg = is_pos_arg;
#line 885
      is_pos_arg = 0;
#line 886
      if ((unsigned int )((int )*fmt - 48) <= 9U) {
#line 887
        old_fmt___0 = fmt;
#line 889
        n = 0;
#line 890
        __cil_tmp___18 = fmt;
#line 890
        fmt ++;
#line 890
        ch = (int )*__cil_tmp___18;
#line 891
        while (1) {
#line 892
          n = 10 * n + (ch - 48);
#line 893
          __cil_tmp___19 = fmt;
#line 893
          fmt ++;
#line 893
          ch = (int )*__cil_tmp___19;
#line 891
          if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 891
            break;
          }
        }
#line 896
        if (ch == 36) {
#line 897
          if (n <= 32) {
#line 898
            n --;
#line 899
            is_pos_arg = 1;
          } else {
#line 902
            goto error;
          }
        } else {
#line 905
          fmt = old_fmt___0;
#line 906
          goto rflag;
        }
      }
#line 910
      if (is_pos_arg) {
#line 910
        if (n < numargs) {
#line 910
          __cil_tmp___21 = args[n].val_int;
        } else {
#line 910
          __cil_tmp___20 = get_arg___11(data, n, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 910
          __cil_tmp___21 = __cil_tmp___20->val_int;
        }
#line 910
        prec = __cil_tmp___21;
      } else {
#line 910
        __cil_tmp___28 = arg_index;
#line 910
        arg_index ++;
#line 910
        if (__cil_tmp___28 < numargs) {
#line 910
          __cil_tmp___27 = args[n].val_int;
        } else {
#line 910
          if (numargs < 32) {
#line 910
            __cil_tmp___23 = numargs;
#line 910
            numargs ++;
#line 910
            __cil_tmp___24 = __builtin_va_arg(ap, int );
#line 910
            args[__cil_tmp___23].val_int = __cil_tmp___24;
#line 910
            __cil_tmp___26 = __cil_tmp___24;
          } else {
#line 910
            __cil_tmp___25 = __builtin_va_arg(ap, int );
#line 910
            __cil_tmp___26 = __cil_tmp___25;
          }
#line 910
          __cil_tmp___27 = __cil_tmp___26;
        }
#line 910
        prec = __cil_tmp___27;
      }
#line 912
      is_pos_arg = old_is_pos_arg;
#line 914
      if (prec < 0) {
#line 915
        prec = -1;
      }
#line 916
      goto rflag;
    }
#line 918
    n = 0;
#line 919
    while ((unsigned int )(ch - 48) <= 9U) {
#line 920
      n = 10 * n + (ch - 48);
#line 921
      __cil_tmp___30 = fmt;
#line 921
      fmt ++;
#line 921
      ch = (int )*__cil_tmp___30;
    }
#line 923
    prec = n < 0 ? -1 : n;
#line 924
    goto reswitch;
    case 48: 
#line 931
    flags |= 128;
#line 932
    goto rflag;
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
#line 935
    n = 0;
#line 936
    while (1) {
#line 937
      n = 10 * n + (ch - 48);
#line 938
      __cil_tmp___31 = fmt;
#line 938
      fmt ++;
#line 938
      ch = (int )*__cil_tmp___31;
#line 936
      if (! ((unsigned int )(ch - 48) <= 9U)) {
#line 936
        break;
      }
    }
#line 941
    if (ch == 36) {
#line 942
      if (n <= 32) {
#line 943
        N = n - 1;
#line 944
        is_pos_arg = 1;
#line 945
        goto rflag;
      } else {
#line 948
        goto error;
      }
    }
#line 951
    width = n;
#line 952
    goto reswitch;
    case 76: 
#line 955
    flags |= 8;
#line 956
    goto rflag;
    case 104: 
#line 960
    if ((int )*fmt == 104) {
#line 961
      fmt ++;
#line 962
      flags |= 512;
    } else {
#line 965
      flags |= 64;
    }
#line 966
    goto rflag;
    case 108: 
#line 969
    if ((int )*fmt == 108) {
#line 970
      fmt ++;
#line 971
      flags |= 32;
    } else {
#line 974
      flags |= 16;
    }
#line 975
    goto rflag;
    case 113: 
#line 977
    flags |= 32;
#line 978
    goto rflag;
    case 106: 
#line 981
    if (sizeof(intmax_t ) == sizeof(long )) {
#line 982
      flags |= 16;
    } else {
#line 984
      flags |= 32;
    }
#line 985
    goto rflag;
    case 122: 
#line 987
    if (sizeof(size_t ) < sizeof(int )) {
#line 989
      flags |= 64;
    } else
#line 990
    if (! (sizeof(size_t ) == sizeof(int ))) {
#line 992
      if (sizeof(size_t ) <= sizeof(long )) {
#line 993
        flags |= 16;
      } else {
#line 999
        flags |= 32;
      }
    }
#line 1000
    goto rflag;
    case 116: 
#line 1002
    if (sizeof(ptrdiff_t ) < sizeof(int )) {
#line 1005
      flags |= 64;
    } else
#line 1006
    if (! (sizeof(ptrdiff_t ) == sizeof(int ))) {
#line 1008
      if (sizeof(ptrdiff_t ) <= sizeof(long )) {
#line 1009
        flags |= 16;
      } else {
#line 1015
        flags |= 32;
      }
    }
#line 1016
    goto rflag;
    case 67: 
    case 99: 
#line 1020
    cp = buf;
#line 1036
    if (is_pos_arg) {
#line 1036
      if (N < numargs) {
#line 1036
        __cil_tmp___33 = args[N].val_int;
      } else {
#line 1036
        __cil_tmp___32 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                      arg_type, & saved_fmt);
#line 1036
        __cil_tmp___33 = __cil_tmp___32->val_int;
      }
#line 1036
      *cp = (char )__cil_tmp___33;
    } else {
#line 1036
      __cil_tmp___40 = arg_index;
#line 1036
      arg_index ++;
#line 1036
      if (__cil_tmp___40 < numargs) {
#line 1036
        __cil_tmp___39 = args[N].val_int;
      } else {
#line 1036
        if (numargs < 32) {
#line 1036
          __cil_tmp___35 = numargs;
#line 1036
          numargs ++;
#line 1036
          __cil_tmp___36 = __builtin_va_arg(ap, int );
#line 1036
          args[__cil_tmp___35].val_int = __cil_tmp___36;
#line 1036
          __cil_tmp___38 = __cil_tmp___36;
        } else {
#line 1036
          __cil_tmp___37 = __builtin_va_arg(ap, int );
#line 1036
          __cil_tmp___38 = __cil_tmp___37;
        }
#line 1036
        __cil_tmp___39 = __cil_tmp___38;
      }
#line 1036
      *cp = (char )__cil_tmp___39;
    }
#line 1037
    size = 1;
#line 1039
    sign = (char )'\000';
#line 1040
    break;
    case 68: 
#line 1042
    flags |= 16;
    case 100: 
    case 105: 
#line 1046
    if (flags & 32) {
#line 1046
      if (is_pos_arg) {
#line 1046
        if (N < numargs) {
#line 1046
          __cil_tmp___42 = args[N].val_quad_t;
        } else {
#line 1046
          __cil_tmp___41 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1046
          __cil_tmp___42 = __cil_tmp___41->val_quad_t;
        }
#line 1046
        __cil_tmp___50 = __cil_tmp___42;
      } else {
#line 1046
        __cil_tmp___49 = arg_index;
#line 1046
        arg_index ++;
#line 1046
        if (__cil_tmp___49 < numargs) {
#line 1046
          __cil_tmp___48 = args[N].val_quad_t;
        } else {
#line 1046
          if (numargs < 32) {
#line 1046
            __cil_tmp___44 = numargs;
#line 1046
            numargs ++;
#line 1046
            __cil_tmp___45 = __builtin_va_arg(ap, long long );
#line 1046
            args[__cil_tmp___44].val_quad_t = __cil_tmp___45;
#line 1046
            __cil_tmp___47 = __cil_tmp___45;
          } else {
#line 1046
            __cil_tmp___46 = __builtin_va_arg(ap, long long );
#line 1046
            __cil_tmp___47 = __cil_tmp___46;
          }
#line 1046
          __cil_tmp___48 = __cil_tmp___47;
        }
#line 1046
        __cil_tmp___50 = __cil_tmp___48;
      }
#line 1046
      _uquad = (unsigned long long )__cil_tmp___50;
    } else {
#line 1046
      if (flags & 16) {
#line 1046
        if (is_pos_arg) {
#line 1046
          if (N < numargs) {
#line 1046
            __cil_tmp___52 = args[N].val_long;
          } else {
#line 1046
            __cil_tmp___51 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                          arg_type, & saved_fmt);
#line 1046
            __cil_tmp___52 = __cil_tmp___51->val_long;
          }
#line 1046
          __cil_tmp___60 = __cil_tmp___52;
        } else {
#line 1046
          __cil_tmp___59 = arg_index;
#line 1046
          arg_index ++;
#line 1046
          if (__cil_tmp___59 < numargs) {
#line 1046
            __cil_tmp___58 = args[N].val_long;
          } else {
#line 1046
            if (numargs < 32) {
#line 1046
              __cil_tmp___54 = numargs;
#line 1046
              numargs ++;
#line 1046
              __cil_tmp___55 = __builtin_va_arg(ap, long );
#line 1046
              args[__cil_tmp___54].val_long = __cil_tmp___55;
#line 1046
              __cil_tmp___57 = __cil_tmp___55;
            } else {
#line 1046
              __cil_tmp___56 = __builtin_va_arg(ap, long );
#line 1046
              __cil_tmp___57 = __cil_tmp___56;
            }
#line 1046
            __cil_tmp___58 = __cil_tmp___57;
          }
#line 1046
          __cil_tmp___60 = __cil_tmp___58;
        }
#line 1046
        __cil_tmp___93 = __cil_tmp___60;
      } else {
#line 1046
        if (flags & 64) {
#line 1046
          if (is_pos_arg) {
#line 1046
            if (N < numargs) {
#line 1046
              __cil_tmp___62 = args[N].val_int;
            } else {
#line 1046
              __cil_tmp___61 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                            args, arg_type, & saved_fmt);
#line 1046
              __cil_tmp___62 = __cil_tmp___61->val_int;
            }
#line 1046
            __cil_tmp___70 = __cil_tmp___62;
          } else {
#line 1046
            __cil_tmp___69 = arg_index;
#line 1046
            arg_index ++;
#line 1046
            if (__cil_tmp___69 < numargs) {
#line 1046
              __cil_tmp___68 = args[N].val_int;
            } else {
#line 1046
              if (numargs < 32) {
#line 1046
                __cil_tmp___64 = numargs;
#line 1046
                numargs ++;
#line 1046
                __cil_tmp___65 = __builtin_va_arg(ap, int );
#line 1046
                args[__cil_tmp___64].val_int = __cil_tmp___65;
#line 1046
                __cil_tmp___67 = __cil_tmp___65;
              } else {
#line 1046
                __cil_tmp___66 = __builtin_va_arg(ap, int );
#line 1046
                __cil_tmp___67 = __cil_tmp___66;
              }
#line 1046
              __cil_tmp___68 = __cil_tmp___67;
            }
#line 1046
            __cil_tmp___70 = __cil_tmp___68;
          }
#line 1046
          __cil_tmp___92 = (long )((short )__cil_tmp___70);
        } else {
#line 1046
          if (flags & 512) {
#line 1046
            if (is_pos_arg) {
#line 1046
              if (N < numargs) {
#line 1046
                __cil_tmp___72 = args[N].val_int;
              } else {
#line 1046
                __cil_tmp___71 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                              args, arg_type, & saved_fmt);
#line 1046
                __cil_tmp___72 = __cil_tmp___71->val_int;
              }
#line 1046
              __cil_tmp___80 = __cil_tmp___72;
            } else {
#line 1046
              __cil_tmp___79 = arg_index;
#line 1046
              arg_index ++;
#line 1046
              if (__cil_tmp___79 < numargs) {
#line 1046
                __cil_tmp___78 = args[N].val_int;
              } else {
#line 1046
                if (numargs < 32) {
#line 1046
                  __cil_tmp___74 = numargs;
#line 1046
                  numargs ++;
#line 1046
                  __cil_tmp___75 = __builtin_va_arg(ap, int );
#line 1046
                  args[__cil_tmp___74].val_int = __cil_tmp___75;
#line 1046
                  __cil_tmp___77 = __cil_tmp___75;
                } else {
#line 1046
                  __cil_tmp___76 = __builtin_va_arg(ap, int );
#line 1046
                  __cil_tmp___77 = __cil_tmp___76;
                }
#line 1046
                __cil_tmp___78 = __cil_tmp___77;
              }
#line 1046
              __cil_tmp___80 = __cil_tmp___78;
            }
#line 1046
            __cil_tmp___91 = (long )((signed char )__cil_tmp___80);
          } else {
#line 1046
            if (is_pos_arg) {
#line 1046
              if (N < numargs) {
#line 1046
                __cil_tmp___82 = args[N].val_int;
              } else {
#line 1046
                __cil_tmp___81 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                              args, arg_type, & saved_fmt);
#line 1046
                __cil_tmp___82 = __cil_tmp___81->val_int;
              }
#line 1046
              __cil_tmp___90 = __cil_tmp___82;
            } else {
#line 1046
              __cil_tmp___89 = arg_index;
#line 1046
              arg_index ++;
#line 1046
              if (__cil_tmp___89 < numargs) {
#line 1046
                __cil_tmp___88 = args[N].val_int;
              } else {
#line 1046
                if (numargs < 32) {
#line 1046
                  __cil_tmp___84 = numargs;
#line 1046
                  numargs ++;
#line 1046
                  __cil_tmp___85 = __builtin_va_arg(ap, int );
#line 1046
                  args[__cil_tmp___84].val_int = __cil_tmp___85;
#line 1046
                  __cil_tmp___87 = __cil_tmp___85;
                } else {
#line 1046
                  __cil_tmp___86 = __builtin_va_arg(ap, int );
#line 1046
                  __cil_tmp___87 = __cil_tmp___86;
                }
#line 1046
                __cil_tmp___88 = __cil_tmp___87;
              }
#line 1046
              __cil_tmp___90 = __cil_tmp___88;
            }
#line 1046
            __cil_tmp___91 = (long )__cil_tmp___90;
          }
#line 1046
          __cil_tmp___92 = __cil_tmp___91;
        }
#line 1046
        __cil_tmp___93 = __cil_tmp___92;
      }
#line 1046
      _uquad = (unsigned long long )__cil_tmp___93;
    }
#line 1048
    if ((long long )_uquad < 0LL) {
#line 1054
      _uquad = - _uquad;
#line 1055
      sign = (char )'-';
    }
#line 1057
    base = (enum __anonenum_base_22___1 )1;
#line 1058
    goto number;
    case 97: 
    case 65: 
    case 70: 
    case 101: 
    case 69: 
    case 102: 
    case 103: 
    case 71: 
#line 1071
    if (flags & 8) {
#line 1072
      if (is_pos_arg) {
#line 1072
        if (N < numargs) {
#line 1072
          __cil_tmp___95 = args[N].val__LONG_DOUBLE;
        } else {
#line 1072
          __cil_tmp___94 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                        arg_type, & saved_fmt);
#line 1072
          __cil_tmp___95 = __cil_tmp___94->val__LONG_DOUBLE;
        }
#line 1072
        __cil_tmp___103 = __cil_tmp___95;
      } else {
#line 1072
        __cil_tmp___102 = arg_index;
#line 1072
        arg_index ++;
#line 1072
        if (__cil_tmp___102 < numargs) {
#line 1072
          __cil_tmp___101 = args[N].val__LONG_DOUBLE;
        } else {
#line 1072
          if (numargs < 32) {
#line 1072
            __cil_tmp___97 = numargs;
#line 1072
            numargs ++;
#line 1072
            __cil_tmp___98 = __builtin_va_arg(ap, long double );
#line 1072
            args[__cil_tmp___97].val__LONG_DOUBLE = __cil_tmp___98;
#line 1072
            __cil_tmp___100 = __cil_tmp___98;
          } else {
#line 1072
            __cil_tmp___99 = __builtin_va_arg(ap, long double );
#line 1072
            __cil_tmp___100 = __cil_tmp___99;
          }
#line 1072
          __cil_tmp___101 = __cil_tmp___100;
        }
#line 1072
        __cil_tmp___103 = __cil_tmp___101;
      }
#line 1072
      _double_.fp = (double )__cil_tmp___103;
    } else
#line 1074
    if (is_pos_arg) {
#line 1074
      if (N < numargs) {
#line 1074
        __cil_tmp___105 = args[N].val_double;
      } else {
#line 1074
        __cil_tmp___104 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                       arg_type, & saved_fmt);
#line 1074
        __cil_tmp___105 = __cil_tmp___104->val_double;
      }
#line 1074
      _double_.fp = __cil_tmp___105;
    } else {
#line 1074
      __cil_tmp___112 = arg_index;
#line 1074
      arg_index ++;
#line 1074
      if (__cil_tmp___112 < numargs) {
#line 1074
        __cil_tmp___111 = args[N].val_double;
      } else {
#line 1074
        if (numargs < 32) {
#line 1074
          __cil_tmp___107 = numargs;
#line 1074
          numargs ++;
#line 1074
          __cil_tmp___108 = __builtin_va_arg(ap, double );
#line 1074
          args[__cil_tmp___107].val_double = __cil_tmp___108;
#line 1074
          __cil_tmp___110 = __cil_tmp___108;
        } else {
#line 1074
          __cil_tmp___109 = __builtin_va_arg(ap, double );
#line 1074
          __cil_tmp___110 = __cil_tmp___109;
        }
#line 1074
        __cil_tmp___111 = __cil_tmp___110;
      }
#line 1074
      _double_.fp = __cil_tmp___111;
    }
#line 1083
    if (sizeof(_double_.fp) == sizeof(float )) {
#line 1083
      __cil_tmp___113 = __fpclassifyf((float )_double_.fp);
#line 1083
      __cil_tmp___115 = __cil_tmp___113;
    } else {
#line 1083
      __cil_tmp___114 = __fpclassifyd(_double_.fp);
#line 1083
      __cil_tmp___115 = __cil_tmp___114;
    }
#line 1083
    if (__cil_tmp___115 == 1) {
#line 1084
      if (_double_.fp < (double )0) {
#line 1085
        sign = (char )'-';
      }
#line 1086
      if (ch <= 71) {
#line 1087
        cp = (char *)"INF";
      } else {
#line 1089
        cp = (char *)"inf";
      }
#line 1090
      size = 3;
#line 1091
      flags &= -129;
#line 1092
      break;
    }
#line 1094
    if (sizeof(_double_.fp) == sizeof(float )) {
#line 1094
      __cil_tmp___116 = __fpclassifyf((float )_double_.fp);
#line 1094
      __cil_tmp___118 = __cil_tmp___116;
    } else {
#line 1094
      __cil_tmp___117 = __fpclassifyd(_double_.fp);
#line 1094
      __cil_tmp___118 = __cil_tmp___117;
    }
#line 1094
    if (__cil_tmp___118 == 0) {
#line 1095
      if (ch <= 71) {
#line 1096
        cp = (char *)"NAN";
      } else {
#line 1098
        cp = (char *)"nan";
      }
#line 1099
      size = 3;
#line 1100
      flags &= -129;
#line 1101
      break;
    }
#line 1137
    if (ch == 97 || ch == 65) {
#line 1138
      ox[0] = (char )'0';
#line 1139
      ox[1] = (char )(ch == 97 ? 'x' : 'X');
#line 1140
      flags |= 2;
#line 1141
      if (prec >= 100) {
#line 1143
        __cil_tmp___119 = _malloc_r(data, (unsigned int )(prec + 1));
#line 1143
        malloc_buf = (char *)__cil_tmp___119;
#line 1143
        if ((unsigned int )malloc_buf == (unsigned int )((void *)0)) {
#line 1147
          fp->_flags = (short )((int )fp->_flags | 64);
#line 1148
          goto error;
        }
#line 1150
        cp = malloc_buf;
      } else {
#line 1153
        cp = buf;
      }
    } else
#line 1156
    if (prec == -1) {
#line 1157
      prec = 6;
    } else
#line 1158
    if ((ch == 103 || ch == 71) && prec == 0) {
#line 1159
      prec = 1;
    }
#line 1162
    flags |= 256;
#line 1164
    cp = cvt___0(data, _double_.fp, prec, flags, & softsign, & expt, ch, & ndig, cp);
#line 1167
    if (ch == 103 || ch == 71) {
#line 1168
      if (expt <= -4 || expt > prec) {
#line 1169
        ch -= 2;
      } else {
#line 1171
        ch = 'g';
      }
    } else
#line 1174
    if (ch == 70) {
#line 1175
      ch = 'f';
    }
#line 1177
    if (ch <= 101) {
#line 1178
      expt --;
#line 1179
      expsize = exponent___0(expstr, expt, ch);
#line 1180
      size = expsize + ndig;
#line 1181
      if (ndig > 1 || flags & 1) {
#line 1182
        size ++;
      }
#line 1184
      flags &= -1025;
    } else {
#line 1187
      if (ch == 102) {
#line 1188
        if (expt > 0) {
#line 1189
          size = expt;
#line 1190
          if (prec || flags & 1) {
#line 1191
            size += prec + 1;
          }
        } else {
#line 1193
          size = prec || flags & 1 ? prec + 2 : 1;
        }
      } else
#line 1196
      if (expt >= ndig) {
#line 1197
        size = expt;
#line 1198
        if (flags & 1) {
#line 1199
          size ++;
        }
      } else {
#line 1201
        size = ndig + (expt > 0 ? 1 : 2 - expt);
      }
#line 1204
      if (flags & 1024 && expt > 0) {
#line 1206
        nrepeats = 0;
#line 1206
        nseps = nrepeats;
#line 1207
        lead = expt;
#line 1208
        while ((int const   )*grouping != 127) {
#line 1209
          if (lead <= (int )*grouping) {
#line 1210
            break;
          }
#line 1211
          lead -= (int )*grouping;
#line 1212
          if (*(grouping + 1)) {
#line 1213
            nseps ++;
#line 1214
            grouping ++;
          } else {
#line 1216
            nrepeats ++;
          }
        }
#line 1218
        size = (int )((unsigned int )size + (unsigned int )(nseps + nrepeats) * thsnd_len);
      } else {
#line 1221
        lead = expt;
      }
    }
#line 1224
    if (softsign) {
#line 1225
      sign = (char )'-';
    }
#line 1226
    break;
    case 110: 
#line 1230
    if (flags & 32) {
#line 1231
      if (is_pos_arg) {
#line 1231
        if (N < numargs) {
#line 1231
          __cil_tmp___121 = args[N].val_quad_ptr_t;
        } else {
#line 1231
          __cil_tmp___120 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1231
          __cil_tmp___121 = __cil_tmp___120->val_quad_ptr_t;
        }
#line 1231
        __cil_tmp___129 = __cil_tmp___121;
      } else {
#line 1231
        __cil_tmp___128 = arg_index;
#line 1231
        arg_index ++;
#line 1231
        if (__cil_tmp___128 < numargs) {
#line 1231
          __cil_tmp___127 = args[N].val_quad_ptr_t;
        } else {
#line 1231
          if (numargs < 32) {
#line 1231
            __cil_tmp___123 = numargs;
#line 1231
            numargs ++;
#line 1231
            __cil_tmp___124 = __builtin_va_arg(ap, quad_ptr_t );
#line 1231
            args[__cil_tmp___123].val_quad_ptr_t = __cil_tmp___124;
#line 1231
            __cil_tmp___126 = __cil_tmp___124;
          } else {
#line 1231
            __cil_tmp___125 = __builtin_va_arg(ap, quad_ptr_t );
#line 1231
            __cil_tmp___126 = __cil_tmp___125;
          }
#line 1231
          __cil_tmp___127 = __cil_tmp___126;
        }
#line 1231
        __cil_tmp___129 = __cil_tmp___127;
      }
#line 1231
      *__cil_tmp___129 = (long long )ret;
    } else
#line 1234
    if (flags & 16) {
#line 1235
      if (is_pos_arg) {
#line 1235
        if (N < numargs) {
#line 1235
          __cil_tmp___131 = args[N].val_long_ptr_t;
        } else {
#line 1235
          __cil_tmp___130 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1235
          __cil_tmp___131 = __cil_tmp___130->val_long_ptr_t;
        }
#line 1235
        __cil_tmp___139 = __cil_tmp___131;
      } else {
#line 1235
        __cil_tmp___138 = arg_index;
#line 1235
        arg_index ++;
#line 1235
        if (__cil_tmp___138 < numargs) {
#line 1235
          __cil_tmp___137 = args[N].val_long_ptr_t;
        } else {
#line 1235
          if (numargs < 32) {
#line 1235
            __cil_tmp___133 = numargs;
#line 1235
            numargs ++;
#line 1235
            __cil_tmp___134 = __builtin_va_arg(ap, long_ptr_t );
#line 1235
            args[__cil_tmp___133].val_long_ptr_t = __cil_tmp___134;
#line 1235
            __cil_tmp___136 = __cil_tmp___134;
          } else {
#line 1235
            __cil_tmp___135 = __builtin_va_arg(ap, long_ptr_t );
#line 1235
            __cil_tmp___136 = __cil_tmp___135;
          }
#line 1235
          __cil_tmp___137 = __cil_tmp___136;
        }
#line 1235
        __cil_tmp___139 = __cil_tmp___137;
      }
#line 1235
      *__cil_tmp___139 = (long )ret;
    } else
#line 1236
    if (flags & 64) {
#line 1237
      if (is_pos_arg) {
#line 1237
        if (N < numargs) {
#line 1237
          __cil_tmp___141 = args[N].val_short_ptr_t;
        } else {
#line 1237
          __cil_tmp___140 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1237
          __cil_tmp___141 = __cil_tmp___140->val_short_ptr_t;
        }
#line 1237
        __cil_tmp___149 = __cil_tmp___141;
      } else {
#line 1237
        __cil_tmp___148 = arg_index;
#line 1237
        arg_index ++;
#line 1237
        if (__cil_tmp___148 < numargs) {
#line 1237
          __cil_tmp___147 = args[N].val_short_ptr_t;
        } else {
#line 1237
          if (numargs < 32) {
#line 1237
            __cil_tmp___143 = numargs;
#line 1237
            numargs ++;
#line 1237
            __cil_tmp___144 = __builtin_va_arg(ap, short_ptr_t );
#line 1237
            args[__cil_tmp___143].val_short_ptr_t = __cil_tmp___144;
#line 1237
            __cil_tmp___146 = __cil_tmp___144;
          } else {
#line 1237
            __cil_tmp___145 = __builtin_va_arg(ap, short_ptr_t );
#line 1237
            __cil_tmp___146 = __cil_tmp___145;
          }
#line 1237
          __cil_tmp___147 = __cil_tmp___146;
        }
#line 1237
        __cil_tmp___149 = __cil_tmp___147;
      }
#line 1237
      *__cil_tmp___149 = (short )ret;
    } else
#line 1239
    if (flags & 512) {
#line 1240
      if (is_pos_arg) {
#line 1240
        if (N < numargs) {
#line 1240
          __cil_tmp___151 = args[N].val_char_ptr_t;
        } else {
#line 1240
          __cil_tmp___150 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1240
          __cil_tmp___151 = __cil_tmp___150->val_char_ptr_t;
        }
#line 1240
        __cil_tmp___159 = __cil_tmp___151;
      } else {
#line 1240
        __cil_tmp___158 = arg_index;
#line 1240
        arg_index ++;
#line 1240
        if (__cil_tmp___158 < numargs) {
#line 1240
          __cil_tmp___157 = args[N].val_char_ptr_t;
        } else {
#line 1240
          if (numargs < 32) {
#line 1240
            __cil_tmp___153 = numargs;
#line 1240
            numargs ++;
#line 1240
            __cil_tmp___154 = __builtin_va_arg(ap, char_ptr_t );
#line 1240
            args[__cil_tmp___153].val_char_ptr_t = __cil_tmp___154;
#line 1240
            __cil_tmp___156 = __cil_tmp___154;
          } else {
#line 1240
            __cil_tmp___155 = __builtin_va_arg(ap, char_ptr_t );
#line 1240
            __cil_tmp___156 = __cil_tmp___155;
          }
#line 1240
          __cil_tmp___157 = __cil_tmp___156;
        }
#line 1240
        __cil_tmp___159 = __cil_tmp___157;
      }
#line 1240
      *__cil_tmp___159 = (char )ret;
    } else {
#line 1243
      if (is_pos_arg) {
#line 1243
        if (N < numargs) {
#line 1243
          __cil_tmp___161 = args[N].val_int_ptr_t;
        } else {
#line 1243
          __cil_tmp___160 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1243
          __cil_tmp___161 = __cil_tmp___160->val_int_ptr_t;
        }
#line 1243
        __cil_tmp___169 = __cil_tmp___161;
      } else {
#line 1243
        __cil_tmp___168 = arg_index;
#line 1243
        arg_index ++;
#line 1243
        if (__cil_tmp___168 < numargs) {
#line 1243
          __cil_tmp___167 = args[N].val_int_ptr_t;
        } else {
#line 1243
          if (numargs < 32) {
#line 1243
            __cil_tmp___163 = numargs;
#line 1243
            numargs ++;
#line 1243
            __cil_tmp___164 = __builtin_va_arg(ap, int_ptr_t );
#line 1243
            args[__cil_tmp___163].val_int_ptr_t = __cil_tmp___164;
#line 1243
            __cil_tmp___166 = __cil_tmp___164;
          } else {
#line 1243
            __cil_tmp___165 = __builtin_va_arg(ap, int_ptr_t );
#line 1243
            __cil_tmp___166 = __cil_tmp___165;
          }
#line 1243
          __cil_tmp___167 = __cil_tmp___166;
        }
#line 1243
        __cil_tmp___169 = __cil_tmp___167;
      }
#line 1243
      *__cil_tmp___169 = ret;
    }
#line 1244
    goto __Cont;
    case 79: 
#line 1246
    flags |= 16;
    case 111: 
#line 1249
    if (flags & 32) {
#line 1249
      if (is_pos_arg) {
#line 1249
        if (N < numargs) {
#line 1249
          __cil_tmp___171 = args[N].val_u_quad_t;
        } else {
#line 1249
          __cil_tmp___170 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1249
          __cil_tmp___171 = __cil_tmp___170->val_u_quad_t;
        }
#line 1249
        __cil_tmp___179 = __cil_tmp___171;
      } else {
#line 1249
        __cil_tmp___178 = arg_index;
#line 1249
        arg_index ++;
#line 1249
        if (__cil_tmp___178 < numargs) {
#line 1249
          __cil_tmp___177 = args[N].val_u_quad_t;
        } else {
#line 1249
          if (numargs < 32) {
#line 1249
            __cil_tmp___173 = numargs;
#line 1249
            numargs ++;
#line 1249
            __cil_tmp___174 = __builtin_va_arg(ap, unsigned long long );
#line 1249
            args[__cil_tmp___173].val_u_quad_t = __cil_tmp___174;
#line 1249
            __cil_tmp___176 = __cil_tmp___174;
          } else {
#line 1249
            __cil_tmp___175 = __builtin_va_arg(ap, unsigned long long );
#line 1249
            __cil_tmp___176 = __cil_tmp___175;
          }
#line 1249
          __cil_tmp___177 = __cil_tmp___176;
        }
#line 1249
        __cil_tmp___179 = __cil_tmp___177;
      }
#line 1249
      _uquad = __cil_tmp___179;
    } else {
#line 1249
      if (flags & 16) {
#line 1249
        if (is_pos_arg) {
#line 1249
          if (N < numargs) {
#line 1249
            __cil_tmp___181 = args[N].val_u_long;
          } else {
#line 1249
            __cil_tmp___180 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                           arg_type, & saved_fmt);
#line 1249
            __cil_tmp___181 = __cil_tmp___180->val_u_long;
          }
#line 1249
          __cil_tmp___189 = __cil_tmp___181;
        } else {
#line 1249
          __cil_tmp___188 = arg_index;
#line 1249
          arg_index ++;
#line 1249
          if (__cil_tmp___188 < numargs) {
#line 1249
            __cil_tmp___187 = args[N].val_u_long;
          } else {
#line 1249
            if (numargs < 32) {
#line 1249
              __cil_tmp___183 = numargs;
#line 1249
              numargs ++;
#line 1249
              __cil_tmp___184 = __builtin_va_arg(ap, u_long );
#line 1249
              args[__cil_tmp___183].val_u_long = __cil_tmp___184;
#line 1249
              __cil_tmp___186 = __cil_tmp___184;
            } else {
#line 1249
              __cil_tmp___185 = __builtin_va_arg(ap, u_long );
#line 1249
              __cil_tmp___186 = __cil_tmp___185;
            }
#line 1249
            __cil_tmp___187 = __cil_tmp___186;
          }
#line 1249
          __cil_tmp___189 = __cil_tmp___187;
        }
#line 1249
        __cil_tmp___222 = __cil_tmp___189;
      } else {
#line 1249
        if (flags & 64) {
#line 1249
          if (is_pos_arg) {
#line 1249
            if (N < numargs) {
#line 1249
              __cil_tmp___191 = args[N].val_int;
            } else {
#line 1249
              __cil_tmp___190 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                             args, arg_type, & saved_fmt);
#line 1249
              __cil_tmp___191 = __cil_tmp___190->val_int;
            }
#line 1249
            __cil_tmp___199 = __cil_tmp___191;
          } else {
#line 1249
            __cil_tmp___198 = arg_index;
#line 1249
            arg_index ++;
#line 1249
            if (__cil_tmp___198 < numargs) {
#line 1249
              __cil_tmp___197 = args[N].val_int;
            } else {
#line 1249
              if (numargs < 32) {
#line 1249
                __cil_tmp___193 = numargs;
#line 1249
                numargs ++;
#line 1249
                __cil_tmp___194 = __builtin_va_arg(ap, int );
#line 1249
                args[__cil_tmp___193].val_int = __cil_tmp___194;
#line 1249
                __cil_tmp___196 = __cil_tmp___194;
              } else {
#line 1249
                __cil_tmp___195 = __builtin_va_arg(ap, int );
#line 1249
                __cil_tmp___196 = __cil_tmp___195;
              }
#line 1249
              __cil_tmp___197 = __cil_tmp___196;
            }
#line 1249
            __cil_tmp___199 = __cil_tmp___197;
          }
#line 1249
          __cil_tmp___221 = (unsigned long )((unsigned short )__cil_tmp___199);
        } else {
#line 1249
          if (flags & 512) {
#line 1249
            if (is_pos_arg) {
#line 1249
              if (N < numargs) {
#line 1249
                __cil_tmp___201 = args[N].val_int;
              } else {
#line 1249
                __cil_tmp___200 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                               args, arg_type, & saved_fmt);
#line 1249
                __cil_tmp___201 = __cil_tmp___200->val_int;
              }
#line 1249
              __cil_tmp___209 = __cil_tmp___201;
            } else {
#line 1249
              __cil_tmp___208 = arg_index;
#line 1249
              arg_index ++;
#line 1249
              if (__cil_tmp___208 < numargs) {
#line 1249
                __cil_tmp___207 = args[N].val_int;
              } else {
#line 1249
                if (numargs < 32) {
#line 1249
                  __cil_tmp___203 = numargs;
#line 1249
                  numargs ++;
#line 1249
                  __cil_tmp___204 = __builtin_va_arg(ap, int );
#line 1249
                  args[__cil_tmp___203].val_int = __cil_tmp___204;
#line 1249
                  __cil_tmp___206 = __cil_tmp___204;
                } else {
#line 1249
                  __cil_tmp___205 = __builtin_va_arg(ap, int );
#line 1249
                  __cil_tmp___206 = __cil_tmp___205;
                }
#line 1249
                __cil_tmp___207 = __cil_tmp___206;
              }
#line 1249
              __cil_tmp___209 = __cil_tmp___207;
            }
#line 1249
            __cil_tmp___220 = (unsigned long )((unsigned char )__cil_tmp___209);
          } else {
#line 1249
            if (is_pos_arg) {
#line 1249
              if (N < numargs) {
#line 1249
                __cil_tmp___211 = args[N].val_u_int;
              } else {
#line 1249
                __cil_tmp___210 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                               args, arg_type, & saved_fmt);
#line 1249
                __cil_tmp___211 = __cil_tmp___210->val_u_int;
              }
#line 1249
              __cil_tmp___219 = __cil_tmp___211;
            } else {
#line 1249
              __cil_tmp___218 = arg_index;
#line 1249
              arg_index ++;
#line 1249
              if (__cil_tmp___218 < numargs) {
#line 1249
                __cil_tmp___217 = args[N].val_u_int;
              } else {
#line 1249
                if (numargs < 32) {
#line 1249
                  __cil_tmp___213 = numargs;
#line 1249
                  numargs ++;
#line 1249
                  __cil_tmp___214 = __builtin_va_arg(ap, u_int );
#line 1249
                  args[__cil_tmp___213].val_u_int = __cil_tmp___214;
#line 1249
                  __cil_tmp___216 = __cil_tmp___214;
                } else {
#line 1249
                  __cil_tmp___215 = __builtin_va_arg(ap, u_int );
#line 1249
                  __cil_tmp___216 = __cil_tmp___215;
                }
#line 1249
                __cil_tmp___217 = __cil_tmp___216;
              }
#line 1249
              __cil_tmp___219 = __cil_tmp___217;
            }
#line 1249
            __cil_tmp___220 = (unsigned long )__cil_tmp___219;
          }
#line 1249
          __cil_tmp___221 = __cil_tmp___220;
        }
#line 1249
        __cil_tmp___222 = __cil_tmp___221;
      }
#line 1249
      _uquad = (unsigned long long )__cil_tmp___222;
    }
#line 1250
    base = (enum __anonenum_base_22___1 )0;
#line 1252
    flags &= -1025;
#line 1254
    goto nosign;
    case 112: 
#line 1264
    if (is_pos_arg) {
#line 1264
      if (N < numargs) {
#line 1264
        __cil_tmp___224 = args[N].val_void_ptr_t;
      } else {
#line 1264
        __cil_tmp___223 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                       arg_type, & saved_fmt);
#line 1264
        __cil_tmp___224 = __cil_tmp___223->val_void_ptr_t;
      }
#line 1264
      __cil_tmp___232 = __cil_tmp___224;
    } else {
#line 1264
      __cil_tmp___231 = arg_index;
#line 1264
      arg_index ++;
#line 1264
      if (__cil_tmp___231 < numargs) {
#line 1264
        __cil_tmp___230 = args[N].val_void_ptr_t;
      } else {
#line 1264
        if (numargs < 32) {
#line 1264
          __cil_tmp___226 = numargs;
#line 1264
          numargs ++;
#line 1264
          __cil_tmp___227 = __builtin_va_arg(ap, void_ptr_t );
#line 1264
          args[__cil_tmp___226].val_void_ptr_t = __cil_tmp___227;
#line 1264
          __cil_tmp___229 = __cil_tmp___227;
        } else {
#line 1264
          __cil_tmp___228 = __builtin_va_arg(ap, void_ptr_t );
#line 1264
          __cil_tmp___229 = __cil_tmp___228;
        }
#line 1264
        __cil_tmp___230 = __cil_tmp___229;
      }
#line 1264
      __cil_tmp___232 = __cil_tmp___230;
    }
#line 1264
    _uquad = (unsigned long long )((unsigned long )__cil_tmp___232);
#line 1265
    base = (enum __anonenum_base_22___1 )2;
#line 1266
    xdigs = (char *)"0123456789abcdef";
#line 1267
    flags |= 2;
#line 1268
    ox[0] = (char )'0';
#line 1269
    ch = 'x';
#line 1269
    ox[1] = (char )ch;
#line 1270
    goto nosign;
    case 115: 
    case 83: 
#line 1275
    sign = (char )'\000';
#line 1276
    if (is_pos_arg) {
#line 1276
      if (N < numargs) {
#line 1276
        __cil_tmp___234 = args[N].val_char_ptr_t;
      } else {
#line 1276
        __cil_tmp___233 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                       arg_type, & saved_fmt);
#line 1276
        __cil_tmp___234 = __cil_tmp___233->val_char_ptr_t;
      }
#line 1276
      cp = __cil_tmp___234;
    } else {
#line 1276
      __cil_tmp___241 = arg_index;
#line 1276
      arg_index ++;
#line 1276
      if (__cil_tmp___241 < numargs) {
#line 1276
        __cil_tmp___240 = args[N].val_char_ptr_t;
      } else {
#line 1276
        if (numargs < 32) {
#line 1276
          __cil_tmp___236 = numargs;
#line 1276
          numargs ++;
#line 1276
          __cil_tmp___237 = __builtin_va_arg(ap, char_ptr_t );
#line 1276
          args[__cil_tmp___236].val_char_ptr_t = __cil_tmp___237;
#line 1276
          __cil_tmp___239 = __cil_tmp___237;
        } else {
#line 1276
          __cil_tmp___238 = __builtin_va_arg(ap, char_ptr_t );
#line 1276
          __cil_tmp___239 = __cil_tmp___238;
        }
#line 1276
        __cil_tmp___240 = __cil_tmp___239;
      }
#line 1276
      cp = __cil_tmp___240;
    }
#line 1282
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 1283
      cp = (char *)"(null)";
#line 1284
      size = (unsigned int )prec > 6U ? 6 : prec;
    } else
#line 1351
    if (prec >= 0) {
#line 1357
      __cil_tmp___242 = memchr((void const   *)cp, 0, (unsigned int )prec);
#line 1357
      p = (char *)__cil_tmp___242;
#line 1359
      if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 1360
        size = p - cp;
#line 1361
        if (size > prec) {
#line 1362
          size = prec;
        }
      } else {
#line 1364
        size = prec;
      }
    } else {
#line 1366
      __cil_tmp___243 = strlen((char const   *)cp);
#line 1366
      size = (int )__cil_tmp___243;
    }
#line 1368
    break;
    case 85: 
#line 1370
    flags |= 16;
    case 117: 
#line 1373
    if (flags & 32) {
#line 1373
      if (is_pos_arg) {
#line 1373
        if (N < numargs) {
#line 1373
          __cil_tmp___245 = args[N].val_u_quad_t;
        } else {
#line 1373
          __cil_tmp___244 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1373
          __cil_tmp___245 = __cil_tmp___244->val_u_quad_t;
        }
#line 1373
        __cil_tmp___253 = __cil_tmp___245;
      } else {
#line 1373
        __cil_tmp___252 = arg_index;
#line 1373
        arg_index ++;
#line 1373
        if (__cil_tmp___252 < numargs) {
#line 1373
          __cil_tmp___251 = args[N].val_u_quad_t;
        } else {
#line 1373
          if (numargs < 32) {
#line 1373
            __cil_tmp___247 = numargs;
#line 1373
            numargs ++;
#line 1373
            __cil_tmp___248 = __builtin_va_arg(ap, unsigned long long );
#line 1373
            args[__cil_tmp___247].val_u_quad_t = __cil_tmp___248;
#line 1373
            __cil_tmp___250 = __cil_tmp___248;
          } else {
#line 1373
            __cil_tmp___249 = __builtin_va_arg(ap, unsigned long long );
#line 1373
            __cil_tmp___250 = __cil_tmp___249;
          }
#line 1373
          __cil_tmp___251 = __cil_tmp___250;
        }
#line 1373
        __cil_tmp___253 = __cil_tmp___251;
      }
#line 1373
      _uquad = __cil_tmp___253;
    } else {
#line 1373
      if (flags & 16) {
#line 1373
        if (is_pos_arg) {
#line 1373
          if (N < numargs) {
#line 1373
            __cil_tmp___255 = args[N].val_u_long;
          } else {
#line 1373
            __cil_tmp___254 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                           arg_type, & saved_fmt);
#line 1373
            __cil_tmp___255 = __cil_tmp___254->val_u_long;
          }
#line 1373
          __cil_tmp___263 = __cil_tmp___255;
        } else {
#line 1373
          __cil_tmp___262 = arg_index;
#line 1373
          arg_index ++;
#line 1373
          if (__cil_tmp___262 < numargs) {
#line 1373
            __cil_tmp___261 = args[N].val_u_long;
          } else {
#line 1373
            if (numargs < 32) {
#line 1373
              __cil_tmp___257 = numargs;
#line 1373
              numargs ++;
#line 1373
              __cil_tmp___258 = __builtin_va_arg(ap, u_long );
#line 1373
              args[__cil_tmp___257].val_u_long = __cil_tmp___258;
#line 1373
              __cil_tmp___260 = __cil_tmp___258;
            } else {
#line 1373
              __cil_tmp___259 = __builtin_va_arg(ap, u_long );
#line 1373
              __cil_tmp___260 = __cil_tmp___259;
            }
#line 1373
            __cil_tmp___261 = __cil_tmp___260;
          }
#line 1373
          __cil_tmp___263 = __cil_tmp___261;
        }
#line 1373
        __cil_tmp___296 = __cil_tmp___263;
      } else {
#line 1373
        if (flags & 64) {
#line 1373
          if (is_pos_arg) {
#line 1373
            if (N < numargs) {
#line 1373
              __cil_tmp___265 = args[N].val_int;
            } else {
#line 1373
              __cil_tmp___264 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                             args, arg_type, & saved_fmt);
#line 1373
              __cil_tmp___265 = __cil_tmp___264->val_int;
            }
#line 1373
            __cil_tmp___273 = __cil_tmp___265;
          } else {
#line 1373
            __cil_tmp___272 = arg_index;
#line 1373
            arg_index ++;
#line 1373
            if (__cil_tmp___272 < numargs) {
#line 1373
              __cil_tmp___271 = args[N].val_int;
            } else {
#line 1373
              if (numargs < 32) {
#line 1373
                __cil_tmp___267 = numargs;
#line 1373
                numargs ++;
#line 1373
                __cil_tmp___268 = __builtin_va_arg(ap, int );
#line 1373
                args[__cil_tmp___267].val_int = __cil_tmp___268;
#line 1373
                __cil_tmp___270 = __cil_tmp___268;
              } else {
#line 1373
                __cil_tmp___269 = __builtin_va_arg(ap, int );
#line 1373
                __cil_tmp___270 = __cil_tmp___269;
              }
#line 1373
              __cil_tmp___271 = __cil_tmp___270;
            }
#line 1373
            __cil_tmp___273 = __cil_tmp___271;
          }
#line 1373
          __cil_tmp___295 = (unsigned long )((unsigned short )__cil_tmp___273);
        } else {
#line 1373
          if (flags & 512) {
#line 1373
            if (is_pos_arg) {
#line 1373
              if (N < numargs) {
#line 1373
                __cil_tmp___275 = args[N].val_int;
              } else {
#line 1373
                __cil_tmp___274 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                               args, arg_type, & saved_fmt);
#line 1373
                __cil_tmp___275 = __cil_tmp___274->val_int;
              }
#line 1373
              __cil_tmp___283 = __cil_tmp___275;
            } else {
#line 1373
              __cil_tmp___282 = arg_index;
#line 1373
              arg_index ++;
#line 1373
              if (__cil_tmp___282 < numargs) {
#line 1373
                __cil_tmp___281 = args[N].val_int;
              } else {
#line 1373
                if (numargs < 32) {
#line 1373
                  __cil_tmp___277 = numargs;
#line 1373
                  numargs ++;
#line 1373
                  __cil_tmp___278 = __builtin_va_arg(ap, int );
#line 1373
                  args[__cil_tmp___277].val_int = __cil_tmp___278;
#line 1373
                  __cil_tmp___280 = __cil_tmp___278;
                } else {
#line 1373
                  __cil_tmp___279 = __builtin_va_arg(ap, int );
#line 1373
                  __cil_tmp___280 = __cil_tmp___279;
                }
#line 1373
                __cil_tmp___281 = __cil_tmp___280;
              }
#line 1373
              __cil_tmp___283 = __cil_tmp___281;
            }
#line 1373
            __cil_tmp___294 = (unsigned long )((unsigned char )__cil_tmp___283);
          } else {
#line 1373
            if (is_pos_arg) {
#line 1373
              if (N < numargs) {
#line 1373
                __cil_tmp___285 = args[N].val_u_int;
              } else {
#line 1373
                __cil_tmp___284 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                               args, arg_type, & saved_fmt);
#line 1373
                __cil_tmp___285 = __cil_tmp___284->val_u_int;
              }
#line 1373
              __cil_tmp___293 = __cil_tmp___285;
            } else {
#line 1373
              __cil_tmp___292 = arg_index;
#line 1373
              arg_index ++;
#line 1373
              if (__cil_tmp___292 < numargs) {
#line 1373
                __cil_tmp___291 = args[N].val_u_int;
              } else {
#line 1373
                if (numargs < 32) {
#line 1373
                  __cil_tmp___287 = numargs;
#line 1373
                  numargs ++;
#line 1373
                  __cil_tmp___288 = __builtin_va_arg(ap, u_int );
#line 1373
                  args[__cil_tmp___287].val_u_int = __cil_tmp___288;
#line 1373
                  __cil_tmp___290 = __cil_tmp___288;
                } else {
#line 1373
                  __cil_tmp___289 = __builtin_va_arg(ap, u_int );
#line 1373
                  __cil_tmp___290 = __cil_tmp___289;
                }
#line 1373
                __cil_tmp___291 = __cil_tmp___290;
              }
#line 1373
              __cil_tmp___293 = __cil_tmp___291;
            }
#line 1373
            __cil_tmp___294 = (unsigned long )__cil_tmp___293;
          }
#line 1373
          __cil_tmp___295 = __cil_tmp___294;
        }
#line 1373
        __cil_tmp___296 = __cil_tmp___295;
      }
#line 1373
      _uquad = (unsigned long long )__cil_tmp___296;
    }
#line 1374
    base = (enum __anonenum_base_22___1 )1;
#line 1375
    goto nosign;
    case 88: 
#line 1377
    xdigs = (char *)"0123456789ABCDEF";
#line 1378
    goto hex;
    case 120: 
#line 1380
    xdigs = (char *)"0123456789abcdef";
    hex: 
#line 1381
    if (flags & 32) {
#line 1381
      if (is_pos_arg) {
#line 1381
        if (N < numargs) {
#line 1381
          __cil_tmp___298 = args[N].val_u_quad_t;
        } else {
#line 1381
          __cil_tmp___297 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                         arg_type, & saved_fmt);
#line 1381
          __cil_tmp___298 = __cil_tmp___297->val_u_quad_t;
        }
#line 1381
        __cil_tmp___306 = __cil_tmp___298;
      } else {
#line 1381
        __cil_tmp___305 = arg_index;
#line 1381
        arg_index ++;
#line 1381
        if (__cil_tmp___305 < numargs) {
#line 1381
          __cil_tmp___304 = args[N].val_u_quad_t;
        } else {
#line 1381
          if (numargs < 32) {
#line 1381
            __cil_tmp___300 = numargs;
#line 1381
            numargs ++;
#line 1381
            __cil_tmp___301 = __builtin_va_arg(ap, unsigned long long );
#line 1381
            args[__cil_tmp___300].val_u_quad_t = __cil_tmp___301;
#line 1381
            __cil_tmp___303 = __cil_tmp___301;
          } else {
#line 1381
            __cil_tmp___302 = __builtin_va_arg(ap, unsigned long long );
#line 1381
            __cil_tmp___303 = __cil_tmp___302;
          }
#line 1381
          __cil_tmp___304 = __cil_tmp___303;
        }
#line 1381
        __cil_tmp___306 = __cil_tmp___304;
      }
#line 1381
      _uquad = __cil_tmp___306;
    } else {
#line 1381
      if (flags & 16) {
#line 1381
        if (is_pos_arg) {
#line 1381
          if (N < numargs) {
#line 1381
            __cil_tmp___308 = args[N].val_u_long;
          } else {
#line 1381
            __cil_tmp___307 = get_arg___11(data, N, fmt_anchor, & ap, & numargs, args,
                                           arg_type, & saved_fmt);
#line 1381
            __cil_tmp___308 = __cil_tmp___307->val_u_long;
          }
#line 1381
          __cil_tmp___316 = __cil_tmp___308;
        } else {
#line 1381
          __cil_tmp___315 = arg_index;
#line 1381
          arg_index ++;
#line 1381
          if (__cil_tmp___315 < numargs) {
#line 1381
            __cil_tmp___314 = args[N].val_u_long;
          } else {
#line 1381
            if (numargs < 32) {
#line 1381
              __cil_tmp___310 = numargs;
#line 1381
              numargs ++;
#line 1381
              __cil_tmp___311 = __builtin_va_arg(ap, u_long );
#line 1381
              args[__cil_tmp___310].val_u_long = __cil_tmp___311;
#line 1381
              __cil_tmp___313 = __cil_tmp___311;
            } else {
#line 1381
              __cil_tmp___312 = __builtin_va_arg(ap, u_long );
#line 1381
              __cil_tmp___313 = __cil_tmp___312;
            }
#line 1381
            __cil_tmp___314 = __cil_tmp___313;
          }
#line 1381
          __cil_tmp___316 = __cil_tmp___314;
        }
#line 1381
        __cil_tmp___349 = __cil_tmp___316;
      } else {
#line 1381
        if (flags & 64) {
#line 1381
          if (is_pos_arg) {
#line 1381
            if (N < numargs) {
#line 1381
              __cil_tmp___318 = args[N].val_int;
            } else {
#line 1381
              __cil_tmp___317 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                             args, arg_type, & saved_fmt);
#line 1381
              __cil_tmp___318 = __cil_tmp___317->val_int;
            }
#line 1381
            __cil_tmp___326 = __cil_tmp___318;
          } else {
#line 1381
            __cil_tmp___325 = arg_index;
#line 1381
            arg_index ++;
#line 1381
            if (__cil_tmp___325 < numargs) {
#line 1381
              __cil_tmp___324 = args[N].val_int;
            } else {
#line 1381
              if (numargs < 32) {
#line 1381
                __cil_tmp___320 = numargs;
#line 1381
                numargs ++;
#line 1381
                __cil_tmp___321 = __builtin_va_arg(ap, int );
#line 1381
                args[__cil_tmp___320].val_int = __cil_tmp___321;
#line 1381
                __cil_tmp___323 = __cil_tmp___321;
              } else {
#line 1381
                __cil_tmp___322 = __builtin_va_arg(ap, int );
#line 1381
                __cil_tmp___323 = __cil_tmp___322;
              }
#line 1381
              __cil_tmp___324 = __cil_tmp___323;
            }
#line 1381
            __cil_tmp___326 = __cil_tmp___324;
          }
#line 1381
          __cil_tmp___348 = (unsigned long )((unsigned short )__cil_tmp___326);
        } else {
#line 1381
          if (flags & 512) {
#line 1381
            if (is_pos_arg) {
#line 1381
              if (N < numargs) {
#line 1381
                __cil_tmp___328 = args[N].val_int;
              } else {
#line 1381
                __cil_tmp___327 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                               args, arg_type, & saved_fmt);
#line 1381
                __cil_tmp___328 = __cil_tmp___327->val_int;
              }
#line 1381
              __cil_tmp___336 = __cil_tmp___328;
            } else {
#line 1381
              __cil_tmp___335 = arg_index;
#line 1381
              arg_index ++;
#line 1381
              if (__cil_tmp___335 < numargs) {
#line 1381
                __cil_tmp___334 = args[N].val_int;
              } else {
#line 1381
                if (numargs < 32) {
#line 1381
                  __cil_tmp___330 = numargs;
#line 1381
                  numargs ++;
#line 1381
                  __cil_tmp___331 = __builtin_va_arg(ap, int );
#line 1381
                  args[__cil_tmp___330].val_int = __cil_tmp___331;
#line 1381
                  __cil_tmp___333 = __cil_tmp___331;
                } else {
#line 1381
                  __cil_tmp___332 = __builtin_va_arg(ap, int );
#line 1381
                  __cil_tmp___333 = __cil_tmp___332;
                }
#line 1381
                __cil_tmp___334 = __cil_tmp___333;
              }
#line 1381
              __cil_tmp___336 = __cil_tmp___334;
            }
#line 1381
            __cil_tmp___347 = (unsigned long )((unsigned char )__cil_tmp___336);
          } else {
#line 1381
            if (is_pos_arg) {
#line 1381
              if (N < numargs) {
#line 1381
                __cil_tmp___338 = args[N].val_u_int;
              } else {
#line 1381
                __cil_tmp___337 = get_arg___11(data, N, fmt_anchor, & ap, & numargs,
                                               args, arg_type, & saved_fmt);
#line 1381
                __cil_tmp___338 = __cil_tmp___337->val_u_int;
              }
#line 1381
              __cil_tmp___346 = __cil_tmp___338;
            } else {
#line 1381
              __cil_tmp___345 = arg_index;
#line 1381
              arg_index ++;
#line 1381
              if (__cil_tmp___345 < numargs) {
#line 1381
                __cil_tmp___344 = args[N].val_u_int;
              } else {
#line 1381
                if (numargs < 32) {
#line 1381
                  __cil_tmp___340 = numargs;
#line 1381
                  numargs ++;
#line 1381
                  __cil_tmp___341 = __builtin_va_arg(ap, u_int );
#line 1381
                  args[__cil_tmp___340].val_u_int = __cil_tmp___341;
#line 1381
                  __cil_tmp___343 = __cil_tmp___341;
                } else {
#line 1381
                  __cil_tmp___342 = __builtin_va_arg(ap, u_int );
#line 1381
                  __cil_tmp___343 = __cil_tmp___342;
                }
#line 1381
                __cil_tmp___344 = __cil_tmp___343;
              }
#line 1381
              __cil_tmp___346 = __cil_tmp___344;
            }
#line 1381
            __cil_tmp___347 = (unsigned long )__cil_tmp___346;
          }
#line 1381
          __cil_tmp___348 = __cil_tmp___347;
        }
#line 1381
        __cil_tmp___349 = __cil_tmp___348;
      }
#line 1381
      _uquad = (unsigned long long )__cil_tmp___349;
    }
#line 1382
    base = (enum __anonenum_base_22___1 )2;
#line 1384
    if (flags & 1 && _uquad != 0ULL) {
#line 1385
      ox[0] = (char )'0';
#line 1386
      ox[1] = (char )ch;
#line 1387
      flags |= 2;
    }
#line 1391
    flags &= -1025;
    nosign: 
#line 1394
    sign = (char )'\000';
    number: 
#line 1400
    dprec = prec;
#line 1400
    if (dprec >= 0) {
#line 1401
      flags &= -129;
    }
#line 1408
    cp = buf + 100;
#line 1409
    if (_uquad != 0ULL || prec != 0) {
#line 1415
      switch ((int )base) {
      case 0: 
#line 1417
      while (1) {
#line 1418
        cp --;
#line 1418
        *cp = (char )((_uquad & 7ULL) + 48ULL);
#line 1419
        _uquad >>= 3;
#line 1417
        if (! _uquad) {
#line 1417
          break;
        }
      }
#line 1422
      if (flags & 1 && (int )*cp != 48) {
#line 1423
        cp --;
#line 1423
        *cp = (char )'0';
      }
#line 1424
      break;
      case 1: 
#line 1428
      if (_uquad < 10ULL) {
#line 1429
        cp --;
#line 1429
        *cp = (char )(_uquad + 48ULL);
#line 1430
        break;
      }
#line 1433
      ndig = 0;
#line 1435
      while (1) {
#line 1436
        cp --;
#line 1436
        *cp = (char )(_uquad % 10ULL + 48ULL);
#line 1438
        ndig ++;
#line 1441
        if (((flags & 1024 && ndig == (int )*grouping) && (int const   )*grouping != 127) && _uquad > 9ULL) {
#line 1445
          cp -= thsnd_len;
#line 1446
          strncpy(cp, (char const   *)thousands_sep, thsnd_len);
#line 1448
          ndig = 0;
#line 1453
          if ((int const   )*(grouping + 1) != 0) {
#line 1454
            grouping ++;
          }
        }
#line 1457
        _uquad /= 10ULL;
#line 1435
        if (! (_uquad != 0ULL)) {
#line 1435
          break;
        }
      }
#line 1459
      break;
      case 2: 
#line 1462
      while (1) {
#line 1463
        cp --;
#line 1463
        *cp = *(xdigs + (_uquad & 15ULL));
#line 1464
        _uquad >>= 4;
#line 1462
        if (! _uquad) {
#line 1462
          break;
        }
      }
#line 1466
      break;
      default: 
#line 1469
      cp = (char *)"bug in vfprintf: bad base";
#line 1470
      __cil_tmp___350 = strlen((char const   *)cp);
#line 1470
      size = (int )__cil_tmp___350;
#line 1471
      goto skipsize;
      }
    } else
#line 1483
    if ((unsigned int )base == 0U && flags & 1) {
#line 1484
      cp --;
#line 1484
      *cp = (char )'0';
    }
#line 1486
    size = (buf + 100) - cp;
    skipsize: 
#line 1488
    break;
    default: 
#line 1490
    if (ch == 0) {
#line 1491
      goto done;
    }
#line 1493
    cp = buf;
#line 1494
    *cp = (char )ch;
#line 1495
    size = 1;
#line 1496
    sign = (char )'\000';
#line 1497
    break;
    }
#line 1515
    realsz = dprec > size ? dprec : size;
#line 1516
    if (sign) {
#line 1517
      realsz ++;
    }
#line 1518
    if (flags & 2) {
#line 1519
      realsz += 2;
    }
#line 1522
    if ((flags & 132) == 0) {
#line 1523
      n = width - realsz;
#line 1523
      if (n > 0) {
#line 1523
        while (n > 16) {
#line 1523
          iovp->iov_base = (void const   *)(blanks___5);
#line 1523
          iovp->iov_len = 16U;
#line 1523
          uio.uio_resid += 16;
#line 1523
          iovp ++;
#line 1523
          (uio.uio_iovcnt) ++;
#line 1523
          if (uio.uio_iovcnt >= 8) {
#line 1523
            __cil_tmp___351 = __sprint_r(data, fp, & uio);
#line 1523
            if (__cil_tmp___351) {
#line 1523
              goto error;
            }
#line 1523
            iovp = iov;
          }
#line 1523
          n -= 16;
        }
#line 1523
        iovp->iov_base = (void const   *)(blanks___5);
#line 1523
        iovp->iov_len = (unsigned int )n;
#line 1523
        uio.uio_resid += n;
#line 1523
        iovp ++;
#line 1523
        (uio.uio_iovcnt) ++;
#line 1523
        if (uio.uio_iovcnt >= 8) {
#line 1523
          __cil_tmp___352 = __sprint_r(data, fp, & uio);
#line 1523
          if (__cil_tmp___352) {
#line 1523
            goto error;
          }
#line 1523
          iovp = iov;
        }
      }
    }
#line 1526
    if (sign) {
#line 1527
      iovp->iov_base = (void const   *)(& sign);
#line 1527
      iovp->iov_len = 1U;
#line 1527
      (uio.uio_resid) ++;
#line 1527
      iovp ++;
#line 1527
      (uio.uio_iovcnt) ++;
#line 1527
      if (uio.uio_iovcnt >= 8) {
#line 1527
        __cil_tmp___353 = __sprint_r(data, fp, & uio);
#line 1527
        if (__cil_tmp___353) {
#line 1527
          goto error;
        }
#line 1527
        iovp = iov;
      }
    }
#line 1528
    if (flags & 2) {
#line 1529
      iovp->iov_base = (void const   *)(ox);
#line 1529
      iovp->iov_len = 2U;
#line 1529
      uio.uio_resid += 2;
#line 1529
      iovp ++;
#line 1529
      (uio.uio_iovcnt) ++;
#line 1529
      if (uio.uio_iovcnt >= 8) {
#line 1529
        __cil_tmp___354 = __sprint_r(data, fp, & uio);
#line 1529
        if (__cil_tmp___354) {
#line 1529
          goto error;
        }
#line 1529
        iovp = iov;
      }
    }
#line 1532
    if ((flags & 132) == 128) {
#line 1533
      n = width - realsz;
#line 1533
      if (n > 0) {
#line 1533
        while (n > 16) {
#line 1533
          iovp->iov_base = (void const   *)(zeroes___5);
#line 1533
          iovp->iov_len = 16U;
#line 1533
          uio.uio_resid += 16;
#line 1533
          iovp ++;
#line 1533
          (uio.uio_iovcnt) ++;
#line 1533
          if (uio.uio_iovcnt >= 8) {
#line 1533
            __cil_tmp___355 = __sprint_r(data, fp, & uio);
#line 1533
            if (__cil_tmp___355) {
#line 1533
              goto error;
            }
#line 1533
            iovp = iov;
          }
#line 1533
          n -= 16;
        }
#line 1533
        iovp->iov_base = (void const   *)(zeroes___5);
#line 1533
        iovp->iov_len = (unsigned int )n;
#line 1533
        uio.uio_resid += n;
#line 1533
        iovp ++;
#line 1533
        (uio.uio_iovcnt) ++;
#line 1533
        if (uio.uio_iovcnt >= 8) {
#line 1533
          __cil_tmp___356 = __sprint_r(data, fp, & uio);
#line 1533
          if (__cil_tmp___356) {
#line 1533
            goto error;
          }
#line 1533
          iovp = iov;
        }
      }
    }
#line 1536
    n = dprec - size;
#line 1536
    if (n > 0) {
#line 1536
      while (n > 16) {
#line 1536
        iovp->iov_base = (void const   *)(zeroes___5);
#line 1536
        iovp->iov_len = 16U;
#line 1536
        uio.uio_resid += 16;
#line 1536
        iovp ++;
#line 1536
        (uio.uio_iovcnt) ++;
#line 1536
        if (uio.uio_iovcnt >= 8) {
#line 1536
          __cil_tmp___357 = __sprint_r(data, fp, & uio);
#line 1536
          if (__cil_tmp___357) {
#line 1536
            goto error;
          }
#line 1536
          iovp = iov;
        }
#line 1536
        n -= 16;
      }
#line 1536
      iovp->iov_base = (void const   *)(zeroes___5);
#line 1536
      iovp->iov_len = (unsigned int )n;
#line 1536
      uio.uio_resid += n;
#line 1536
      iovp ++;
#line 1536
      (uio.uio_iovcnt) ++;
#line 1536
      if (uio.uio_iovcnt >= 8) {
#line 1536
        __cil_tmp___358 = __sprint_r(data, fp, & uio);
#line 1536
        if (__cil_tmp___358) {
#line 1536
          goto error;
        }
#line 1536
        iovp = iov;
      }
    }
#line 1540
    if ((flags & 256) == 0) {
#line 1541
      iovp->iov_base = (void const   *)cp;
#line 1541
      iovp->iov_len = (unsigned int )size;
#line 1541
      uio.uio_resid += size;
#line 1541
      iovp ++;
#line 1541
      (uio.uio_iovcnt) ++;
#line 1541
      if (uio.uio_iovcnt >= 8) {
#line 1541
        __cil_tmp___359 = __sprint_r(data, fp, & uio);
#line 1541
        if (__cil_tmp___359) {
#line 1541
          goto error;
        }
#line 1541
        iovp = iov;
      }
    } else
#line 1543
    if (ch >= 102) {
#line 1544
      if (_double_.fp == (double )0) {
#line 1546
        iovp->iov_base = (void const   *)"0";
#line 1546
        iovp->iov_len = 1U;
#line 1546
        (uio.uio_resid) ++;
#line 1546
        iovp ++;
#line 1546
        (uio.uio_iovcnt) ++;
#line 1546
        if (uio.uio_iovcnt >= 8) {
#line 1546
          __cil_tmp___360 = __sprint_r(data, fp, & uio);
#line 1546
          if (__cil_tmp___360) {
#line 1546
            goto error;
          }
#line 1546
          iovp = iov;
        }
#line 1547
        if (expt < ndig || flags & 1) {
#line 1548
          iovp->iov_base = (void const   *)decimal_point;
#line 1548
          iovp->iov_len = decp_len;
#line 1548
          uio.uio_resid = (int )((unsigned int )uio.uio_resid + decp_len);
#line 1548
          iovp ++;
#line 1548
          (uio.uio_iovcnt) ++;
#line 1548
          if (uio.uio_iovcnt >= 8) {
#line 1548
            __cil_tmp___361 = __sprint_r(data, fp, & uio);
#line 1548
            if (__cil_tmp___361) {
#line 1548
              goto error;
            }
#line 1548
            iovp = iov;
          }
#line 1549
          n = ndig - 1;
#line 1549
          if (n > 0) {
#line 1549
            while (n > 16) {
#line 1549
              iovp->iov_base = (void const   *)(zeroes___5);
#line 1549
              iovp->iov_len = 16U;
#line 1549
              uio.uio_resid += 16;
#line 1549
              iovp ++;
#line 1549
              (uio.uio_iovcnt) ++;
#line 1549
              if (uio.uio_iovcnt >= 8) {
#line 1549
                __cil_tmp___362 = __sprint_r(data, fp, & uio);
#line 1549
                if (__cil_tmp___362) {
#line 1549
                  goto error;
                }
#line 1549
                iovp = iov;
              }
#line 1549
              n -= 16;
            }
#line 1549
            iovp->iov_base = (void const   *)(zeroes___5);
#line 1549
            iovp->iov_len = (unsigned int )n;
#line 1549
            uio.uio_resid += n;
#line 1549
            iovp ++;
#line 1549
            (uio.uio_iovcnt) ++;
#line 1549
            if (uio.uio_iovcnt >= 8) {
#line 1549
              __cil_tmp___363 = __sprint_r(data, fp, & uio);
#line 1549
              if (__cil_tmp___363) {
#line 1549
                goto error;
              }
#line 1549
              iovp = iov;
            }
          }
        }
      } else
#line 1551
      if (expt <= 0) {
#line 1552
        iovp->iov_base = (void const   *)"0";
#line 1552
        iovp->iov_len = 1U;
#line 1552
        (uio.uio_resid) ++;
#line 1552
        iovp ++;
#line 1552
        (uio.uio_iovcnt) ++;
#line 1552
        if (uio.uio_iovcnt >= 8) {
#line 1552
          __cil_tmp___364 = __sprint_r(data, fp, & uio);
#line 1552
          if (__cil_tmp___364) {
#line 1552
            goto error;
          }
#line 1552
          iovp = iov;
        }
#line 1553
        if ((expt || ndig) || flags & 1) {
#line 1554
          iovp->iov_base = (void const   *)decimal_point;
#line 1554
          iovp->iov_len = decp_len;
#line 1554
          uio.uio_resid = (int )((unsigned int )uio.uio_resid + decp_len);
#line 1554
          iovp ++;
#line 1554
          (uio.uio_iovcnt) ++;
#line 1554
          if (uio.uio_iovcnt >= 8) {
#line 1554
            __cil_tmp___365 = __sprint_r(data, fp, & uio);
#line 1554
            if (__cil_tmp___365) {
#line 1554
              goto error;
            }
#line 1554
            iovp = iov;
          }
#line 1555
          n = - expt;
#line 1555
          if (n > 0) {
#line 1555
            while (n > 16) {
#line 1555
              iovp->iov_base = (void const   *)(zeroes___5);
#line 1555
              iovp->iov_len = 16U;
#line 1555
              uio.uio_resid += 16;
#line 1555
              iovp ++;
#line 1555
              (uio.uio_iovcnt) ++;
#line 1555
              if (uio.uio_iovcnt >= 8) {
#line 1555
                __cil_tmp___366 = __sprint_r(data, fp, & uio);
#line 1555
                if (__cil_tmp___366) {
#line 1555
                  goto error;
                }
#line 1555
                iovp = iov;
              }
#line 1555
              n -= 16;
            }
#line 1555
            iovp->iov_base = (void const   *)(zeroes___5);
#line 1555
            iovp->iov_len = (unsigned int )n;
#line 1555
            uio.uio_resid += n;
#line 1555
            iovp ++;
#line 1555
            (uio.uio_iovcnt) ++;
#line 1555
            if (uio.uio_iovcnt >= 8) {
#line 1555
              __cil_tmp___367 = __sprint_r(data, fp, & uio);
#line 1555
              if (__cil_tmp___367) {
#line 1555
                goto error;
              }
#line 1555
              iovp = iov;
            }
          }
#line 1556
          iovp->iov_base = (void const   *)cp;
#line 1556
          iovp->iov_len = (unsigned int )ndig;
#line 1556
          uio.uio_resid += ndig;
#line 1556
          iovp ++;
#line 1556
          (uio.uio_iovcnt) ++;
#line 1556
          if (uio.uio_iovcnt >= 8) {
#line 1556
            __cil_tmp___368 = __sprint_r(data, fp, & uio);
#line 1556
            if (__cil_tmp___368) {
#line 1556
              goto error;
            }
#line 1556
            iovp = iov;
          }
        }
      } else {
#line 1559
        convbuf = cp;
#line 1560
        n___0 = (convbuf + ndig) - cp;
#line 1560
        if (n___0 > lead) {
#line 1560
          n___0 = lead;
        }
#line 1560
        if (n___0 > 0) {
#line 1560
          iovp->iov_base = (void const   *)cp;
#line 1560
          iovp->iov_len = (unsigned int )n___0;
#line 1560
          uio.uio_resid += n___0;
#line 1560
          iovp ++;
#line 1560
          (uio.uio_iovcnt) ++;
#line 1560
          if (uio.uio_iovcnt >= 8) {
#line 1560
            __cil_tmp___369 = __sprint_r(data, fp, & uio);
#line 1560
            if (__cil_tmp___369) {
#line 1560
              goto error;
            }
#line 1560
            iovp = iov;
          }
        }
#line 1560
        n___0 = lead - (n___0 > 0 ? n___0 : 0);
#line 1560
        if (n___0 > 0) {
#line 1560
          while (n___0 > 16) {
#line 1560
            iovp->iov_base = (void const   *)(zeroes___5);
#line 1560
            iovp->iov_len = 16U;
#line 1560
            uio.uio_resid += 16;
#line 1560
            iovp ++;
#line 1560
            (uio.uio_iovcnt) ++;
#line 1560
            if (uio.uio_iovcnt >= 8) {
#line 1560
              __cil_tmp___370 = __sprint_r(data, fp, & uio);
#line 1560
              if (__cil_tmp___370) {
#line 1560
                goto error;
              }
#line 1560
              iovp = iov;
            }
#line 1560
            n___0 -= 16;
          }
#line 1560
          iovp->iov_base = (void const   *)(zeroes___5);
#line 1560
          iovp->iov_len = (unsigned int )n___0;
#line 1560
          uio.uio_resid += n___0;
#line 1560
          iovp ++;
#line 1560
          (uio.uio_iovcnt) ++;
#line 1560
          if (uio.uio_iovcnt >= 8) {
#line 1560
            __cil_tmp___371 = __sprint_r(data, fp, & uio);
#line 1560
            if (__cil_tmp___371) {
#line 1560
              goto error;
            }
#line 1560
            iovp = iov;
          }
        }
#line 1562
        cp += lead;
#line 1564
        if (flags & 1024) {
#line 1565
          while (nseps > 0 || nrepeats > 0) {
#line 1566
            if (nrepeats > 0) {
#line 1567
              nrepeats --;
            } else {
#line 1569
              grouping --;
#line 1570
              nseps --;
            }
#line 1572
            iovp->iov_base = (void const   *)thousands_sep;
#line 1572
            iovp->iov_len = thsnd_len;
#line 1572
            uio.uio_resid = (int )((unsigned int )uio.uio_resid + thsnd_len);
#line 1572
            iovp ++;
#line 1572
            (uio.uio_iovcnt) ++;
#line 1572
            if (uio.uio_iovcnt >= 8) {
#line 1572
              __cil_tmp___372 = __sprint_r(data, fp, & uio);
#line 1572
              if (__cil_tmp___372) {
#line 1572
                goto error;
              }
#line 1572
              iovp = iov;
            }
#line 1573
            n___1 = (convbuf + ndig) - cp;
#line 1573
            if (n___1 > (int )*grouping) {
#line 1573
              n___1 = (int )*grouping;
            }
#line 1573
            if (n___1 > 0) {
#line 1573
              iovp->iov_base = (void const   *)cp;
#line 1573
              iovp->iov_len = (unsigned int )n___1;
#line 1573
              uio.uio_resid += n___1;
#line 1573
              iovp ++;
#line 1573
              (uio.uio_iovcnt) ++;
#line 1573
              if (uio.uio_iovcnt >= 8) {
#line 1573
                __cil_tmp___373 = __sprint_r(data, fp, & uio);
#line 1573
                if (__cil_tmp___373) {
#line 1573
                  goto error;
                }
#line 1573
                iovp = iov;
              }
            }
#line 1573
            n___1 = (int )((int const   )*grouping - (int const   )(n___1 > 0 ? n___1 : 0));
#line 1573
            if (n___1 > 0) {
#line 1573
              while (n___1 > 16) {
#line 1573
                iovp->iov_base = (void const   *)(zeroes___5);
#line 1573
                iovp->iov_len = 16U;
#line 1573
                uio.uio_resid += 16;
#line 1573
                iovp ++;
#line 1573
                (uio.uio_iovcnt) ++;
#line 1573
                if (uio.uio_iovcnt >= 8) {
#line 1573
                  __cil_tmp___374 = __sprint_r(data, fp, & uio);
#line 1573
                  if (__cil_tmp___374) {
#line 1573
                    goto error;
                  }
#line 1573
                  iovp = iov;
                }
#line 1573
                n___1 -= 16;
              }
#line 1573
              iovp->iov_base = (void const   *)(zeroes___5);
#line 1573
              iovp->iov_len = (unsigned int )n___1;
#line 1573
              uio.uio_resid += n___1;
#line 1573
              iovp ++;
#line 1573
              (uio.uio_iovcnt) ++;
#line 1573
              if (uio.uio_iovcnt >= 8) {
#line 1573
                __cil_tmp___375 = __sprint_r(data, fp, & uio);
#line 1573
                if (__cil_tmp___375) {
#line 1573
                  goto error;
                }
#line 1573
                iovp = iov;
              }
            }
#line 1575
            cp += (int const   )*grouping;
          }
#line 1577
          if ((unsigned int )cp > (unsigned int )(convbuf + ndig)) {
#line 1578
            cp = convbuf + ndig;
          }
        }
#line 1581
        if (expt < ndig || flags & 1) {
#line 1582
          iovp->iov_base = (void const   *)decimal_point;
#line 1582
          iovp->iov_len = decp_len;
#line 1582
          uio.uio_resid = (int )((unsigned int )uio.uio_resid + decp_len);
#line 1582
          iovp ++;
#line 1582
          (uio.uio_iovcnt) ++;
#line 1582
          if (uio.uio_iovcnt >= 8) {
#line 1582
            __cil_tmp___376 = __sprint_r(data, fp, & uio);
#line 1582
            if (__cil_tmp___376) {
#line 1582
              goto error;
            }
#line 1582
            iovp = iov;
          }
        }
#line 1583
        n___2 = (convbuf + ndig) - cp;
#line 1583
        if (n___2 > ndig - expt) {
#line 1583
          n___2 = ndig - expt;
        }
#line 1583
        if (n___2 > 0) {
#line 1583
          iovp->iov_base = (void const   *)cp;
#line 1583
          iovp->iov_len = (unsigned int )n___2;
#line 1583
          uio.uio_resid += n___2;
#line 1583
          iovp ++;
#line 1583
          (uio.uio_iovcnt) ++;
#line 1583
          if (uio.uio_iovcnt >= 8) {
#line 1583
            __cil_tmp___377 = __sprint_r(data, fp, & uio);
#line 1583
            if (__cil_tmp___377) {
#line 1583
              goto error;
            }
#line 1583
            iovp = iov;
          }
        }
#line 1583
        n___2 = (ndig - expt) - (n___2 > 0 ? n___2 : 0);
#line 1583
        if (n___2 > 0) {
#line 1583
          while (n___2 > 16) {
#line 1583
            iovp->iov_base = (void const   *)(zeroes___5);
#line 1583
            iovp->iov_len = 16U;
#line 1583
            uio.uio_resid += 16;
#line 1583
            iovp ++;
#line 1583
            (uio.uio_iovcnt) ++;
#line 1583
            if (uio.uio_iovcnt >= 8) {
#line 1583
              __cil_tmp___378 = __sprint_r(data, fp, & uio);
#line 1583
              if (__cil_tmp___378) {
#line 1583
                goto error;
              }
#line 1583
              iovp = iov;
            }
#line 1583
            n___2 -= 16;
          }
#line 1583
          iovp->iov_base = (void const   *)(zeroes___5);
#line 1583
          iovp->iov_len = (unsigned int )n___2;
#line 1583
          uio.uio_resid += n___2;
#line 1583
          iovp ++;
#line 1583
          (uio.uio_iovcnt) ++;
#line 1583
          if (uio.uio_iovcnt >= 8) {
#line 1583
            __cil_tmp___379 = __sprint_r(data, fp, & uio);
#line 1583
            if (__cil_tmp___379) {
#line 1583
              goto error;
            }
#line 1583
            iovp = iov;
          }
        }
      }
    } else {
#line 1587
      if (ndig > 1 || flags & 1) {
#line 1588
        iovp->iov_base = (void const   *)cp;
#line 1588
        iovp->iov_len = 1U;
#line 1588
        (uio.uio_resid) ++;
#line 1588
        iovp ++;
#line 1588
        (uio.uio_iovcnt) ++;
#line 1588
        if (uio.uio_iovcnt >= 8) {
#line 1588
          __cil_tmp___380 = __sprint_r(data, fp, & uio);
#line 1588
          if (__cil_tmp___380) {
#line 1588
            goto error;
          }
#line 1588
          iovp = iov;
        }
#line 1589
        cp ++;
#line 1590
        iovp->iov_base = (void const   *)decimal_point;
#line 1590
        iovp->iov_len = decp_len;
#line 1590
        uio.uio_resid = (int )((unsigned int )uio.uio_resid + decp_len);
#line 1590
        iovp ++;
#line 1590
        (uio.uio_iovcnt) ++;
#line 1590
        if (uio.uio_iovcnt >= 8) {
#line 1590
          __cil_tmp___381 = __sprint_r(data, fp, & uio);
#line 1590
          if (__cil_tmp___381) {
#line 1590
            goto error;
          }
#line 1590
          iovp = iov;
        }
#line 1591
        if (_double_.fp) {
#line 1592
          iovp->iov_base = (void const   *)cp;
#line 1592
          iovp->iov_len = (unsigned int )(ndig - 1);
#line 1592
          uio.uio_resid += ndig - 1;
#line 1592
          iovp ++;
#line 1592
          (uio.uio_iovcnt) ++;
#line 1592
          if (uio.uio_iovcnt >= 8) {
#line 1592
            __cil_tmp___382 = __sprint_r(data, fp, & uio);
#line 1592
            if (__cil_tmp___382) {
#line 1592
              goto error;
            }
#line 1592
            iovp = iov;
          }
        } else {
#line 1595
          n = ndig - 1;
#line 1595
          if (n > 0) {
#line 1595
            while (n > 16) {
#line 1595
              iovp->iov_base = (void const   *)(zeroes___5);
#line 1595
              iovp->iov_len = 16U;
#line 1595
              uio.uio_resid += 16;
#line 1595
              iovp ++;
#line 1595
              (uio.uio_iovcnt) ++;
#line 1595
              if (uio.uio_iovcnt >= 8) {
#line 1595
                __cil_tmp___383 = __sprint_r(data, fp, & uio);
#line 1595
                if (__cil_tmp___383) {
#line 1595
                  goto error;
                }
#line 1595
                iovp = iov;
              }
#line 1595
              n -= 16;
            }
#line 1595
            iovp->iov_base = (void const   *)(zeroes___5);
#line 1595
            iovp->iov_len = (unsigned int )n;
#line 1595
            uio.uio_resid += n;
#line 1595
            iovp ++;
#line 1595
            (uio.uio_iovcnt) ++;
#line 1595
            if (uio.uio_iovcnt >= 8) {
#line 1595
              __cil_tmp___384 = __sprint_r(data, fp, & uio);
#line 1595
              if (__cil_tmp___384) {
#line 1595
                goto error;
              }
#line 1595
              iovp = iov;
            }
          }
        }
      } else {
#line 1597
        iovp->iov_base = (void const   *)cp;
#line 1597
        iovp->iov_len = 1U;
#line 1597
        (uio.uio_resid) ++;
#line 1597
        iovp ++;
#line 1597
        (uio.uio_iovcnt) ++;
#line 1597
        if (uio.uio_iovcnt >= 8) {
#line 1597
          __cil_tmp___385 = __sprint_r(data, fp, & uio);
#line 1597
          if (__cil_tmp___385) {
#line 1597
            goto error;
          }
#line 1597
          iovp = iov;
        }
      }
#line 1598
      iovp->iov_base = (void const   *)(expstr);
#line 1598
      iovp->iov_len = (unsigned int )expsize;
#line 1598
      uio.uio_resid += expsize;
#line 1598
      iovp ++;
#line 1598
      (uio.uio_iovcnt) ++;
#line 1598
      if (uio.uio_iovcnt >= 8) {
#line 1598
        __cil_tmp___386 = __sprint_r(data, fp, & uio);
#line 1598
        if (__cil_tmp___386) {
#line 1598
          goto error;
        }
#line 1598
        iovp = iov;
      }
    }
#line 1605
    if (flags & 4) {
#line 1606
      n = width - realsz;
#line 1606
      if (n > 0) {
#line 1606
        while (n > 16) {
#line 1606
          iovp->iov_base = (void const   *)(blanks___5);
#line 1606
          iovp->iov_len = 16U;
#line 1606
          uio.uio_resid += 16;
#line 1606
          iovp ++;
#line 1606
          (uio.uio_iovcnt) ++;
#line 1606
          if (uio.uio_iovcnt >= 8) {
#line 1606
            __cil_tmp___387 = __sprint_r(data, fp, & uio);
#line 1606
            if (__cil_tmp___387) {
#line 1606
              goto error;
            }
#line 1606
            iovp = iov;
          }
#line 1606
          n -= 16;
        }
#line 1606
        iovp->iov_base = (void const   *)(blanks___5);
#line 1606
        iovp->iov_len = (unsigned int )n;
#line 1606
        uio.uio_resid += n;
#line 1606
        iovp ++;
#line 1606
        (uio.uio_iovcnt) ++;
#line 1606
        if (uio.uio_iovcnt >= 8) {
#line 1606
          __cil_tmp___388 = __sprint_r(data, fp, & uio);
#line 1606
          if (__cil_tmp___388) {
#line 1606
            goto error;
          }
#line 1606
          iovp = iov;
        }
      }
    }
#line 1609
    ret += width > realsz ? width : realsz;
#line 1611
    if (uio.uio_resid) {
#line 1611
      __cil_tmp___389 = __sprint_r(data, fp, & uio);
#line 1611
      if (__cil_tmp___389) {
#line 1611
        goto error;
      }
    }
#line 1611
    uio.uio_iovcnt = 0;
#line 1611
    iovp = iov;
#line 1613
    if ((unsigned int )malloc_buf != (unsigned int )((void *)0)) {
#line 1614
      _free_r(data, (void *)malloc_buf);
#line 1615
      malloc_buf = (char *)((void *)0);
    }
    __Cont: ;
  }
  done: 
#line 1619
  if (uio.uio_resid) {
#line 1619
    __cil_tmp___390 = __sprint_r(data, fp, & uio);
#line 1619
    if (__cil_tmp___390) {
#line 1619
      goto error;
    }
  }
#line 1619
  uio.uio_iovcnt = 0;
#line 1619
  iovp = iov;
  error: 
#line 1621
  if ((unsigned int )malloc_buf != (unsigned int )((void *)0)) {
#line 1622
    _free_r(data, (void *)malloc_buf);
  }
#line 1624
  if ((int )fp->_flags & 512) {

  }
#line 1626
  return (((int )fp->_flags & 64) != 0 ? -1 : ret);
}
}
#line 1639 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static char *cvt___0(struct _reent *data , double value , int ndigits , int flags ,
                     char *sign , int *decpt , int ch , int *length , char *buf ) 
{ int mode ;
  int dsgn ;
  char *digits ;
  char *bp ;
  char *rve ;
  union double_union tmp ;
  double __cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  char *__cil_tmp___4 ;

  {
#line 1648
  tmp.d = value;
#line 1649
  if (tmp.i[1] & 2147483648U) {
#line 1650
    value = - value;
#line 1651
    *sign = (char )'-';
  } else {
#line 1653
    *sign = (char )'\000';
  }
#line 1670
  if (ch == 97 || ch == 65) {
#line 1675
    __cil_tmp = frexp(value, decpt);
#line 1675
    value = __cil_tmp / (double )8;
#line 1676
    if (! value) {
#line 1677
      *decpt = 1;
    }
#line 1678
    digits = (char *)(ch == 97 ? "0123456789abcdef" : "0123456789ABCDEF");
#line 1679
    bp = buf;
#line 1680
    while (1) {
#line 1681
      value *= (double )16;
#line 1682
      mode = (int )value;
#line 1683
      value -= (double )mode;
#line 1684
      __cil_tmp___0 = bp;
#line 1684
      bp ++;
#line 1684
      *__cil_tmp___0 = *(digits + mode);
#line 1680
      __cil_tmp___1 = ndigits;
#line 1680
      ndigits --;
#line 1680
      if (! (__cil_tmp___1 && value)) {
#line 1680
        break;
      }
    }
#line 1686
    if (value > 0.5 || (value == 0.5 && mode & 1)) {
#line 1688
      rve = bp;
#line 1689
      while (1) {
#line 1689
        rve --;
#line 1689
        if (! ((int )*rve == (int )*(digits + 15))) {
#line 1689
          break;
        }
#line 1690
        *rve = (char )'0';
      }
#line 1692
      *rve = (char )((int )*rve == 57 ? (int )*(digits + 10) : (int )*rve + 1);
    } else {
#line 1694
      while (1) {
#line 1694
        __cil_tmp___3 = ndigits;
#line 1694
        ndigits --;
#line 1694
        if (! (__cil_tmp___3 >= 0)) {
#line 1694
          break;
        }
#line 1695
        __cil_tmp___2 = bp;
#line 1695
        bp ++;
#line 1695
        *__cil_tmp___2 = (char )'0';
      }
    }
#line 1698
    *length = bp - buf;
#line 1699
    return (buf);
  }
#line 1702
  if (ch == 102 || ch == 70) {
#line 1703
    mode = 3;
  } else {
#line 1709
    if (ch == 101 || ch == 69) {
#line 1710
      ndigits ++;
    }
#line 1712
    mode = 2;
  }
#line 1715
  digits = _dtoa_r(data, value, mode, ndigits, decpt, & dsgn, & rve);
#line 1717
  if ((ch != 103 && ch != 71) || flags & 1) {
#line 1718
    bp = digits + ndigits;
#line 1719
    if (ch == 102 || ch == 70) {
#line 1720
      if ((int )*digits == 48 && value) {
#line 1721
        *decpt = - ndigits + 1;
      }
#line 1722
      bp += *decpt;
    }
#line 1724
    if (value == (double )0) {
#line 1725
      rve = bp;
    }
#line 1726
    while ((unsigned int )rve < (unsigned int )bp) {
#line 1727
      __cil_tmp___4 = rve;
#line 1727
      rve ++;
#line 1727
      *__cil_tmp___4 = (char )'0';
    }
  }
#line 1729
  *length = rve - digits;
#line 1730
  return (digits);
}
}
#line 1733 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static int exponent___0(char *p0 , int exp___0 , int fmtch ) 
{ register char *p ;
  register char *t ;
  char expbuf[7] ;
  int isa ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  char *__cil_tmp___5 ;

  {
#line 1739
  isa = fmtch == 97 || fmtch == 65;
#line 1744
  p = p0;
#line 1745
  __cil_tmp = p;
#line 1745
  p ++;
#line 1745
  *__cil_tmp = (char )(isa ? 15 + fmtch : fmtch);
#line 1746
  if (exp___0 < 0) {
#line 1747
    exp___0 = - exp___0;
#line 1748
    __cil_tmp___0 = p;
#line 1748
    p ++;
#line 1748
    *__cil_tmp___0 = (char )'-';
  } else {
#line 1751
    __cil_tmp___1 = p;
#line 1751
    p ++;
#line 1751
    *__cil_tmp___1 = (char )'+';
  }
#line 1752
  t = expbuf + 7;
#line 1753
  if (exp___0 > 9) {
#line 1754
    while (1) {
#line 1755
      t --;
#line 1755
      *t = (char )(exp___0 % 10 + 48);
#line 1754
      exp___0 /= 10;
#line 1754
      if (! (exp___0 > 9)) {
#line 1754
        break;
      }
    }
#line 1757
    t --;
#line 1757
    *t = (char )(exp___0 + 48);
#line 1758
    while ((unsigned int )t < (unsigned int )(expbuf + 7)) {
#line 1758
      __cil_tmp___2 = p;
#line 1758
      p ++;
#line 1758
      __cil_tmp___3 = t;
#line 1758
      t ++;
#line 1758
      *__cil_tmp___2 = *__cil_tmp___3;
    }
  } else {
#line 1761
    if (! isa) {
#line 1762
      __cil_tmp___4 = p;
#line 1762
      p ++;
#line 1762
      *__cil_tmp___4 = (char )'0';
    }
#line 1763
    __cil_tmp___5 = p;
#line 1763
    p ++;
#line 1763
    *__cil_tmp___5 = (char )(exp___0 + 48);
  }
#line 1765
  return (p - p0);
}
}
#line 1876 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vfprintf.c"
static union arg_val *get_arg___11(struct _reent *data , int n , char *fmt , va_list *ap ,
                                   int *numargs_p , union arg_val *args , int *arg_type ,
                                   char **last_fmt ) 
{ int ch ;
  int number ;
  int flags ;
  int spec_type ;
  int numargs ;
  __CH_CLASS chtype ;
  __STATE state ;
  __STATE next_state ;
  __ACTION action ;
  int pos ;
  int last_arg ;
  int max_pos_arg ;
  char *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;

  {
#line 1890
  numargs = *numargs_p;
#line 1895
  max_pos_arg = n;
#line 1905
  if ((unsigned int )*last_fmt != (unsigned int )((void *)0)) {
#line 1906
    fmt = *last_fmt;
  }
#line 1914
  while (*fmt && n >= numargs) {
#line 1928
    while ((int )*fmt != 0 && (int )*fmt != 37) {
#line 1929
      fmt ++;
    }
#line 1931
    if ((int )*fmt == 0) {
#line 1932
      break;
    }
#line 1934
    state = (enum __anonenum___STATE_12 )0;
#line 1935
    flags = 0;
#line 1936
    pos = -1;
#line 1937
    number = 0;
#line 1938
    spec_type = 0;
#line 1943
    while ((unsigned int )state != 11U) {
#line 1945
      __cil_tmp = fmt;
#line 1945
      fmt ++;
#line 1945
      ch = (int )*__cil_tmp;
#line 1946
      chtype = (enum __anonenum___CH_CLASS_11 )__chclass[ch];
#line 1947
      next_state = (enum __anonenum___STATE_12 )__state_table[state][chtype];
#line 1948
      action = (enum __anonenum___ACTION_13 )__action_table[state][chtype];
#line 1949
      state = next_state;
#line 1951
      switch ((int )action) {
      case 3: 
#line 1954
      switch (ch) {
      case 104: 
#line 1958
      break;
      case 76: 
#line 1960
      flags |= 8;
#line 1961
      break;
      case 113: 
#line 1963
      flags |= 32;
#line 1964
      break;
      case 106: 
#line 1967
      if (sizeof(intmax_t ) == sizeof(long )) {
#line 1968
        flags |= 16;
      } else {
#line 1970
        flags |= 32;
      }
#line 1971
      break;
      case 122: 
#line 1973
      if (! (sizeof(size_t ) <= sizeof(int ))) {
#line 1975
        if (sizeof(size_t ) <= sizeof(long )) {
#line 1976
          flags |= 16;
        } else {
#line 1982
          flags |= 32;
        }
      }
#line 1983
      break;
      case 116: 
#line 1985
      if (! (sizeof(ptrdiff_t ) <= sizeof(int ))) {
#line 1987
        if (sizeof(ptrdiff_t ) <= sizeof(long )) {
#line 1988
          flags |= 16;
        } else {
#line 1994
          flags |= 32;
        }
      }
#line 1995
      break;
      default: 
#line 2000
      if ((int )*fmt == 108) {
#line 2002
        flags |= 32;
#line 2003
        fmt ++;
      } else {
#line 2007
        flags |= 16;
      }
#line 2008
      break;
      }
#line 2010
      break;
      case 4: 
#line 2013
      numargs &= 31;
#line 2015
      switch (ch) {
      case 100: 
      case 105: 
      case 111: 
      case 120: 
      case 88: 
      case 117: 
#line 2023
      if (flags & 16) {
#line 2024
        spec_type = 1;
      } else
#line 2026
      if (flags & 32) {
#line 2027
        spec_type = 2;
      } else {
#line 2030
        spec_type = 0;
      }
#line 2031
      break;
      case 68: 
      case 85: 
      case 79: 
#line 2035
      spec_type = 1;
#line 2036
      break;
      case 97: 
      case 65: 
      case 70: 
      case 102: 
      case 103: 
      case 71: 
      case 69: 
      case 101: 
#line 2052
      spec_type = 4;
#line 2053
      break;
      case 115: 
      case 83: 
      case 112: 
      case 110: 
#line 2060
      spec_type = 3;
#line 2061
      break;
      case 99: 
#line 2064
      if (flags & 16) {
#line 2065
        spec_type = 6;
      } else {
#line 2068
        spec_type = 0;
      }
#line 2069
      break;
      case 67: 
#line 2072
      spec_type = 6;
#line 2073
      break;
      }
#line 2079
      if (pos != -1) {
#line 2080
        *(arg_type + pos) = spec_type;
      } else {
#line 2083
        switch (spec_type) {
        case 1: 
#line 2086
        __cil_tmp___0 = numargs;
#line 2086
        numargs ++;
#line 2086
        (args + __cil_tmp___0)->val_long = __builtin_va_arg(*ap, long );
#line 2087
        break;
        case 2: 
#line 2089
        __cil_tmp___1 = numargs;
#line 2089
        numargs ++;
#line 2089
        (args + __cil_tmp___1)->val_quad_t = __builtin_va_arg(*ap, long long );
#line 2090
        break;
        case 6: 
#line 2092
        __cil_tmp___2 = numargs;
#line 2092
        numargs ++;
#line 2092
        (args + __cil_tmp___2)->val_wint_t = __builtin_va_arg(*ap, wint_t );
#line 2093
        break;
        case 0: 
#line 2095
        __cil_tmp___3 = numargs;
#line 2095
        numargs ++;
#line 2095
        (args + __cil_tmp___3)->val_int = __builtin_va_arg(*ap, int );
#line 2096
        break;
        case 3: 
#line 2098
        __cil_tmp___4 = numargs;
#line 2098
        numargs ++;
#line 2098
        (args + __cil_tmp___4)->val_char_ptr_t = __builtin_va_arg(*ap, char *);
#line 2099
        break;
        case 4: 
#line 2101
        __cil_tmp___5 = numargs;
#line 2101
        numargs ++;
#line 2101
        (args + __cil_tmp___5)->val_double = __builtin_va_arg(*ap, double );
#line 2102
        break;
        case 5: 
#line 2104
        __cil_tmp___6 = numargs;
#line 2104
        numargs ++;
#line 2104
        (args + __cil_tmp___6)->val__LONG_DOUBLE = __builtin_va_arg(*ap, long double );
#line 2105
        break;
        }
      }
#line 2109
      break;
      case 7: 
#line 2111
      if (*(arg_type + 0) == -1) {
#line 2112
        memset((void *)arg_type, 0, (unsigned int )(sizeof(int ) * 32UL));
      }
#line 2113
      pos = number - 1;
#line 2114
      max_pos_arg = max_pos_arg > pos ? max_pos_arg : pos;
#line 2115
      break;
      case 8: 
#line 2117
      if (*(arg_type + 0) == -1) {
#line 2118
        memset((void *)arg_type, 0, (unsigned int )(sizeof(int ) * 32UL));
      }
#line 2119
      number --;
#line 2120
      *(arg_type + number) = 0;
#line 2121
      max_pos_arg = max_pos_arg > number ? max_pos_arg : number;
#line 2122
      break;
      case 6: 
#line 2124
      fmt --;
      case 5: 
#line 2127
      __cil_tmp___7 = numargs;
#line 2127
      numargs ++;
#line 2127
      (args + __cil_tmp___7)->val_int = __builtin_va_arg(*ap, int );
#line 2128
      break;
      case 1: 
#line 2130
      number = ch - 48;
#line 2131
      while (1) {
#line 2131
        ch = (int )*fmt;
#line 2131
        if (! (ch != 0 && (unsigned int )(ch - 48) <= 9U)) {
#line 2131
          break;
        }
#line 2133
        number = number * 10 + (ch - 48);
#line 2134
        fmt ++;
      }
#line 2136
      break;
      case 2: 
#line 2138
      while (1) {
#line 2138
        ch = (int )*fmt;
#line 2138
        if (! (ch != 0 && (unsigned int )(ch - 48) <= 9U)) {
#line 2138
          break;
        }
#line 2139
        fmt ++;
      }
#line 2140
      break;
      default: 
#line 2143
      break;
      }
    }
  }
#line 2150
  if ((int )*fmt == 0) {
#line 2151
    last_arg = max_pos_arg;
  } else {
#line 2153
    last_arg = n;
  }
#line 2155
  while (numargs <= last_arg) {
#line 2157
    switch (*(arg_type + numargs)) {
    case 1: 
#line 2160
    __cil_tmp___8 = numargs;
#line 2160
    numargs ++;
#line 2160
    (args + __cil_tmp___8)->val_long = __builtin_va_arg(*ap, long );
#line 2161
    break;
    case 2: 
#line 2163
    __cil_tmp___9 = numargs;
#line 2163
    numargs ++;
#line 2163
    (args + __cil_tmp___9)->val_quad_t = __builtin_va_arg(*ap, long long );
#line 2164
    break;
    case 3: 
#line 2166
    __cil_tmp___10 = numargs;
#line 2166
    numargs ++;
#line 2166
    (args + __cil_tmp___10)->val_char_ptr_t = __builtin_va_arg(*ap, char *);
#line 2167
    break;
    case 4: 
#line 2169
    __cil_tmp___11 = numargs;
#line 2169
    numargs ++;
#line 2169
    (args + __cil_tmp___11)->val_double = __builtin_va_arg(*ap, double );
#line 2170
    break;
    case 5: 
#line 2172
    __cil_tmp___12 = numargs;
#line 2172
    numargs ++;
#line 2172
    (args + __cil_tmp___12)->val__LONG_DOUBLE = __builtin_va_arg(*ap, long double );
#line 2173
    break;
    case 6: 
#line 2175
    __cil_tmp___13 = numargs;
#line 2175
    numargs ++;
#line 2175
    (args + __cil_tmp___13)->val_wint_t = __builtin_va_arg(*ap, wint_t );
#line 2176
    break;
    default: 
#line 2179
    __cil_tmp___14 = numargs;
#line 2179
    numargs ++;
#line 2179
    (args + __cil_tmp___14)->val_int = __builtin_va_arg(*ap, int );
#line 2180
    break;
    }
  }
#line 2186
  *numargs_p = numargs;
#line 2187
  *last_fmt = fmt;
#line 2188
  return (args + n);
}
}
#line 1 "lib_a-vfscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-YaJ30Hzk.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vfwprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vG2hZ764.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2,-fshort-enums")
#line 1 "lib_a-vfwscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-HhvdkEPZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-viprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-J5YoUS3b.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-viscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-DlmC2JI1.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SareZ2Vj.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-gDJyzlCS.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vsiprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ex9jCtzZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vsiscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-sxdTVFUr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vsniprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-i3CwaYnV.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vsnprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-g0dGGQCO.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 476 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/stdio.h"
int _vsnprintf_r(struct _reent *ptr , char *str , size_t size , char const   *fmt ,
                 va_list ap ) ;
#line 32 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vsnprintf.c"
int vsnprintf(char *str , size_t size , char const   *fmt , va_list ap ) 
{ int __cil_tmp ;

  {
#line 39
  __cil_tmp = _vsnprintf_r(_impure_ptr, str, size, fmt, ap);
#line 39
  return (__cil_tmp);
}
}
#line 44 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/vsnprintf.c"
int _vsnprintf_r(struct _reent *ptr , char *str , size_t size , char const   *fmt ,
                 va_list ap ) 
{ int ret ;
  FILE f ;

  {
#line 55
  if (size > 2147483647U) {
#line 57
    ptr->_errno = 139;
#line 58
    return (-1);
  }
#line 60
  f._flags = (short)520;
#line 61
  f._p = (unsigned char *)str;
#line 61
  f._bf._base = f._p;
#line 62
  f._w = (int )(size > 0U ? size - 1U : 0U);
#line 62
  f._bf._size = f._w;
#line 63
  f._file = (short)-1;
#line 64
  ret = _svfprintf_r(ptr, & f, fmt, ap);
#line 65
  if (ret < -1) {
#line 66
    ptr->_errno = 139;
  }
#line 67
  if (size > 0U) {
#line 68
    *(f._p) = (unsigned char)0;
  }
#line 69
  return (ret);
}
}
#line 1 "lib_a-vsprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-rEZQ9bW1.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vsscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-VQ4g5ZbI.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vswprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Av72EO32.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vswscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-PXPHPEeW.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vwprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wtBaaD1i.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-vwscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SXvXKHNs.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wbuf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jYWdMov3.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 35 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/wbuf.c"
int __swbuf_r(struct _reent *ptr , int c , FILE *fp ) 
{ register int n ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  unsigned char *__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 45
  while (1) {
#line 45
    if (ptr && ! ptr->__sdidinit) {
#line 45
      __sinit(ptr);
    }
#line 45
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 45
      fp = ptr->_stdin;
    } else
#line 45
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 45
      fp = ptr->_stdout;
    } else
#line 45
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 45
      fp = ptr->_stderr;
    }
#line 45
    break;
  }
#line 55
  fp->_w = fp->_lbfsize;
#line 56
  if (((int )fp->_flags & 8) == 0 || (unsigned int )fp->_bf._base == (unsigned int )((void *)0)) {
#line 56
    __cil_tmp = __swsetup_r(ptr, fp);
#line 56
    if (__cil_tmp) {
#line 58
      fp->_flags = (short )((int )fp->_flags | 64);
#line 59
      ptr->_errno = 9;
#line 60
      return (-1);
    }
  }
#line 62
  c = (int )((unsigned char )c);
#line 64
  while (1) {
#line 64
    if (! ((int )fp->_flags & 8192)) {
#line 64
      fp->_flags = (short )((int )fp->_flags | 8192);
#line 64
      fp->_flags2 &= -8193;
    }
#line 64
    break;
  }
#line 76
  n = fp->_p - fp->_bf._base;
#line 77
  if (n >= fp->_bf._size) {
#line 79
    __cil_tmp___0 = _fflush_r(ptr, fp);
#line 79
    if (__cil_tmp___0) {
#line 80
      return (-1);
    }
#line 81
    n = 0;
  }
#line 83
  (fp->_w) --;
#line 84
  __cil_tmp___1 = fp->_p;
#line 84
  (fp->_p) ++;
#line 84
  *__cil_tmp___1 = (unsigned char )c;
#line 85
  n ++;
#line 85
  if (n == fp->_bf._size || ((int )fp->_flags & 1 && c == 10)) {
#line 86
    __cil_tmp___2 = _fflush_r(ptr, fp);
#line 86
    if (__cil_tmp___2) {
#line 87
      return (-1);
    }
  }
#line 88
  return (c);
}
}
#line 1 "lib_a-wcpcpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Pk0e6P7J.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcpncpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vffJ1jbF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcrtomb.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-69Dt1fuZ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 14 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/local.h"
int (*__wctomb)(struct _reent * , char * , wchar_t  , char const   *charset , mbstate_t * ) ;
#line 9 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/wcrtomb.c"
size_t _wcrtomb_r(struct _reent *ptr , char *s , wchar_t wc , mbstate_t *ps ) 
{ int retval ;
  char buf[10] ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 16
  retval = 0;
#line 27
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 28
    __cil_tmp = __locale_charset();
#line 28
    retval = (*__wctomb)(ptr, buf, (short)0, (char const   *)__cil_tmp, ps);
  } else {
#line 30
    __cil_tmp___0 = __locale_charset();
#line 30
    retval = (*__wctomb)(ptr, s, wc, (char const   *)__cil_tmp___0, ps);
  }
#line 32
  if (retval == -1) {
#line 34
    ps->__count = 0;
#line 35
    ptr->_errno = 138;
#line 36
    return (4294967295U);
  } else {
#line 39
    return ((unsigned int )retval);
  }
}
}
#line 1 "lib_a-wcscasecmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-JBojN8yr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcscat.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Fsc8xdrH.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcschr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ZAiuIh0W.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcscmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-LueXgKOy.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcscoll.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-O2SwIC4u.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcscpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ts3GED6u.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcscspn.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-XqkcWvIR.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsdup.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-eJnLxZQC.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsftime.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ExxM2l5k.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcslcat.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-pcJ9XNAT.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcslcpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cPOurJhQ.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcslen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Vwez9d5K.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsncasecmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-A91ImmJI.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsncat.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-O50EE2qL.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsncmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-a64BXjQO.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsncpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-nJdKTpfw.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsnlen.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-RgsfD06p.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsnrtombs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-U1ZtZRTT.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcspbrk.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-mke4T7PW.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsrchr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wOrGBxT4.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsrtombs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wsLe6iB9.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsspn.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-s253AD1d.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsstr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-zacGS3bY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstod.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dRxHnUmn.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstok.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wbV4qvyg.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstol.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-A0bK62LB.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstoll.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-gdT1k25M.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstoll_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-yeslPDYR.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstombs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cd1dGrtd.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstombs_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-nRlk5lRN.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstoul.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IybMxOM7.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstoull.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-FtQMDIeE.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcstoull_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-q2jsqWIS.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcswidth.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-uVjmtRjN.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcsxfrm.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-zA67F4iC.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wctob.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-KbmUD2aa.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wctomb.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1RqJoPIB.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wctomb_r.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-KzKiljMy.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 16 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/local.h"
int __ascii_wctomb(struct _reent *r , char *s , wchar_t _wchar , char const   *charset ,
                   mbstate_t *state ) ;
#line 9 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/wctomb_r.c"
int (*__wctomb)(struct _reent * , char * , wchar_t  , char const   *charset , mbstate_t * )  =    & __ascii_wctomb;
#line 28 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdlib/wctomb_r.c"
int __ascii_wctomb(struct _reent *r , char *s , wchar_t _wchar , char const   *charset ,
                   mbstate_t *state ) 
{ wint_t wchar ;

  {
#line 39
  wchar = (int )_wchar;
#line 41
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 42
    return (0);
  }
#line 47
  if ((unsigned int )wchar >= 256U) {
#line 50
    r->_errno = 138;
#line 51
    return (-1);
  }
#line 54
  *s = (char )wchar;
#line 55
  return (1);
}
}
#line 1 "lib_a-wctrans.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-pciB6MC8.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wctype.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-V35D1frw.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wcwidth.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Pb4EyrFF.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wmemchr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SmgsOYNt.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wmemcmp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dcj5mBX3.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wmemcpy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-e9mVDI1w.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wmemmove.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-WvtoLXgc.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wmemset.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-HYRHURfH.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wordexp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-OfsXS0CY.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wordfree.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-eyW65Cqr.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wprintf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-744LQozy.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-writer.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Ppgn6ZMo.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wscanf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-cDPXDPEj.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 1 "lib_a-wsetup.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-c5UjdZ3A.i","-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/newlib/,-B/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/build/otter/libgloss/otter,-fno-builtin,-g,-O2")
#line 31 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/stdio/wsetup.c"
int __swsetup_r(struct _reent *ptr , FILE *fp ) 
{ 

  {
#line 38
  while (1) {
#line 38
    if (_impure_ptr && ! _impure_ptr->__sdidinit) {
#line 38
      __sinit(_impure_ptr);
    }
#line 38
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdin))) {
#line 38
      fp = _impure_ptr->_stdin;
    } else
#line 38
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stdout))) {
#line 38
      fp = _impure_ptr->_stdout;
    } else
#line 38
    if ((unsigned int )fp == (unsigned int )((FILE *)(& __sf_fake_stderr))) {
#line 38
      fp = _impure_ptr->_stderr;
    }
#line 38
    break;
  }
#line 44
  if (((int )fp->_flags & 8) == 0) {
#line 46
    if (((int )fp->_flags & 16) == 0) {
#line 47
      return (-1);
    }
#line 48
    if ((int )fp->_flags & 4) {
#line 51
      if ((unsigned int )fp->_ub._base != (unsigned int )((void *)0)) {
#line 52
        if ((unsigned int )fp->_ub._base != (unsigned int )(fp->_ubuf)) {
#line 52
          _free_r(ptr, (void *)((char *)fp->_ub._base));
        }
#line 52
        fp->_ub._base = (unsigned char *)((void *)0);
      }
#line 53
      fp->_flags = (short )((int )fp->_flags & -37);
#line 54
      fp->_r = 0;
#line 55
      fp->_p = fp->_bf._base;
    }
#line 57
    fp->_flags = (short )((int )fp->_flags | 8);
  }
#line 65
  if ((unsigned int )fp->_bf._base == (unsigned int )((void *)0) && (! ((int )fp->_flags & 512) || (int )fp->_flags & 128)) {
#line 67
    __smakebuf_r(ptr, fp);
  }
#line 69
  if ((int )fp->_flags & 1) {
#line 76
    fp->_w = 0;
#line 77
    fp->_lbfsize = - fp->_bf._size;
  } else {
#line 80
    fp->_w = (int )fp->_flags & 2 ? 0 : fp->_bf._size;
  }
#line 82
  return (! fp->_bf._base && (int )fp->_flags & 128 ? -1 : 0);
}
}
#line 1 "cil-716PmxNE.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-QHzBeNgm.i","")
#line 8 "syscalls/arpa/inet.c"
int inet_aton(char const   *cp , struct in_addr *addrptr ) 
{ in_addr_t addr ;
  int value ;
  int part ;
  char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  char c ;
  char const   *__cil_tmp___1 ;

  {
#line 14
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 15
    return (0);
  }
#line 18
  addr = 0U;
#line 19
  part = 1;
#line 19
  while (part <= 4) {
#line 21
    if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int const   )*cp))) + (int )*cp) & 4)) {
#line 22
      return (0);
    }
#line 24
    value = 0;
#line 25
    while ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int const   )*cp))) + (int )*cp) & 4) {
#line 26
      value *= 10;
#line 27
      __cil_tmp = cp;
#line 27
      cp ++;
#line 27
      value += (int )((int const   )*__cil_tmp - 48);
#line 28
      if (value > 255) {
#line 29
        return (0);
      }
    }
#line 32
    if (part < 4) {
#line 33
      __cil_tmp___0 = cp;
#line 33
      cp ++;
#line 33
      if ((int const   )*__cil_tmp___0 != 46) {
#line 34
        return (0);
      }
    } else {
#line 36
      __cil_tmp___1 = cp;
#line 36
      cp ++;
#line 36
      c = (char )*__cil_tmp___1;
#line 37
      if ((int )c != 0 && ! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 8)) {
#line 38
        return (0);
      }
    }
#line 41
    addr <<= 8;
#line 42
    addr |= (unsigned int )value;
#line 19
    part ++;
  }
#line 52
  if (addrptr) {
#line 53
    addrptr->s_addr = ((((addr & 4278190080U) >> 24) | ((addr & 16711680U) >> 8)) | ((addr & 65280U) << 8)) | ((addr & 255U) << 24);
  }
#line 56
  return (1);
}
}
#line 162 "syscalls/arpa/inet.c"
char *inet_ntoa(struct in_addr in ) 
{ in_addr_t addr ;
  in_addr_t addr2 ;
  int numdigits ;
  int i ;
  char *buf ;
  void *__cil_tmp ;
  int j ;
  int i___0 ;

  {
#line 164
  addr = ((((in.s_addr & 4278190080U) >> 24) | ((in.s_addr & 16711680U) >> 8)) | ((in.s_addr & 65280U) << 8)) | ((in.s_addr & 255U) << 24);
#line 166
  addr2 = addr;
#line 167
  numdigits = 4;
#line 168
  i = 0;
#line 168
  while (i < 4) {
#line 170
    numdigits ++;
#line 171
    if ((addr2 & 255U) > 10U) {
#line 172
      numdigits ++;
    }
#line 173
    if ((addr2 & 255U) > 100U) {
#line 174
      numdigits ++;
    }
#line 175
    addr2 >>= 8;
#line 168
    i ++;
  }
#line 178
  __cil_tmp = malloc((unsigned int )numdigits);
#line 178
  buf = (char *)__cil_tmp;
#line 179
  j = numdigits - 1;
#line 181
  i___0 = 0;
#line 181
  while (i___0 < 4) {
#line 184
    *(buf + j) = (char )'.';
#line 185
    j --;
#line 187
    *(buf + j) = (char )(48U + (addr & 255U) % 10U);
#line 188
    j --;
#line 189
    if ((addr & 255U) > 10U) {
#line 191
      *(buf + j) = (char )(48U + ((addr & 255U) / 10U) % 10U);
#line 192
      j --;
    }
#line 194
    if ((addr & 255U) > 100U) {
#line 196
      *(buf + j) = (char )(48U + (addr & 255U) / 100U);
#line 197
      j --;
    }
#line 200
    addr >>= 8;
#line 181
    i___0 ++;
  }
#line 203
  *(buf + (numdigits - 1)) = (char)0;
#line 205
  return (buf);
}
}
#line 1 "cil-eh0nTVrT.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5X0HbsLn.i","")
#line 56 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_builtins.h"
extern void __EVALSTR(char const   *str , size_t len ) ;
#line 5 "syscalls/assert/assert.c"
void __libc_failwith(char *msg ) 
{ size_t __cil_tmp ;

  {
#line 7
  __cil_tmp = strlen((char const   *)msg);
#line 7
  __EVALSTR((char const   *)msg, __cil_tmp);
#line 8
  abort();
}
}
#line 1 "cil-G9JNkTwC.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Wfkgl99o.i","")
#line 94 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_inode *__otter_fs_find_inode_in_dir(char const   *name , struct __otter_fs_dnode *dir ) ;
#line 99
struct __otter_fs_dnode *__otter_fs_find_dnode(char const   *name_in ) ;
#line 118
int __otter_fs_more_fd(int arg ) ;
#line 120
int __otter_fs_open_file(struct __otter_fs_inode *inode , int mode ) ;
#line 121
int __otter_fs_open_dir(struct __otter_fs_dnode *dnode , int mode ) ;
#line 130
struct __otter_fs_inode *__otter_fs_touch(char const   *name , struct __otter_fs_dnode *dir ) ;
#line 135
int __otter_fs_change_open_mode(struct __otter_fs_open_file_table_entry *open_file ,
                                int mode ) ;
#line 143
struct __otter_fs_dnode *find_filename_and_dnode(char const   *path , char **basename ) ;
#line 144
struct __otter_fs_open_file_table_entry *get_open_file_from_fd(int fd ) ;
#line 19 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_builtins.h"
extern void __ASSERT(_Bool  ) ;
#line 17 "syscalls/fcntl/__otter_fcntl.c"
int fcntl(int fd , int cmd  , ...) 
{ va_list varargs ;
  int r ;
  int start ;
  int __cil_tmp ;
  int fd2 ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp___2 ;
  struct __otter_fs_open_file_table_entry *open_file___0 ;
  struct __otter_fs_open_file_table_entry *__cil_tmp___3 ;
  int mode ;
  int __cil_tmp___4 ;
  struct __otter_fs_open_file_table_entry *open_file___1 ;
  struct __otter_fs_open_file_table_entry *__cil_tmp___5 ;
  int *__cil_tmp___6 ;

  {
#line 20
  __builtin_va_start(varargs, cmd);
#line 22
  r = -1;
#line 24
  switch (cmd) {
  case 1: 
#line 28
  __cil_tmp = __builtin_va_arg(varargs, int );
#line 28
  start = __cil_tmp;
#line 29
  __cil_tmp___0 = __otter_fs_more_fd(start);
#line 29
  fd2 = __cil_tmp___0;
#line 30
  if (fd2 == -1) {
#line 32
    __cil_tmp___1 = __errno();
#line 32
    *__cil_tmp___1 = 24;
#line 33
    break;
  }
#line 36
  __cil_tmp___2 = get_open_file_from_fd(fd);
#line 36
  open_file = __cil_tmp___2;
#line 37
  if (open_file) {
#line 39
    *(__otter_fs_fd_table + fd2) = *(__otter_fs_fd_table + fd);
#line 40
    (open_file->openno) ++;
#line 41
    r = fd2;
  }
#line 43
  break;
  case 2: 
#line 46
  break;
  case 3: 
#line 48
  break;
  case 4: 
#line 51
  __cil_tmp___3 = get_open_file_from_fd(fd);
#line 51
  open_file___0 = __cil_tmp___3;
#line 52
  if (open_file___0) {
#line 54
    r = open_file___0->mode;
  }
#line 56
  break;
  case 5: 
#line 60
  __cil_tmp___4 = __builtin_va_arg(varargs, int );
#line 60
  mode = __cil_tmp___4;
#line 62
  __cil_tmp___5 = get_open_file_from_fd(fd);
#line 62
  open_file___1 = __cil_tmp___5;
#line 64
  if (open_file___1) {
#line 66
    r = __otter_fs_change_open_mode(open_file___1, mode);
  }
#line 68
  break;
  case 6: 
#line 71
  break;
  case 7: 
#line 73
  break;
  case 8: 
#line 75
  break;
  case 9: 
#line 77
  break;
  case 10: 
#line 79
  break;
  default: 
#line 81
  __cil_tmp___6 = __errno();
#line 81
  *__cil_tmp___6 = 22;
#line 82
  break;
  }
#line 85
  __builtin_va_end(varargs);
#line 87
  return (r);
}
}
#line 90 "syscalls/fcntl/__otter_fcntl.c"
int __otter_libc_vopen(char const   *path , int oflag , va_list varargs ) 
{ struct __otter_fs_dnode *dnode ;
  struct __otter_fs_dnode *__cil_tmp ;
  int __cil_tmp___0 ;
  char *filename ;
  int *__cil_tmp___1 ;
  struct __otter_fs_inode *inode ;
  struct __otter_fs_inode *__cil_tmp___2 ;
  mode_t mode ;
  mode_t __cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int fd ;
  int __cil_tmp___7 ;

  {
#line 92
  if (128 & oflag) {

  }
#line 98
  if (32 & oflag && ! (2 & oflag)) {
#line 100
    __ASSERT((_Bool)0);
  }
#line 103
  __cil_tmp = __otter_fs_find_dnode(path);
#line 103
  dnode = __cil_tmp;
#line 104
  if (dnode) {
#line 106
    if (32 & oflag) {
#line 108
      __ASSERT((_Bool)0);
    }
#line 111
    __cil_tmp___0 = __otter_fs_open_dir(dnode, oflag);
#line 111
    return (__cil_tmp___0);
  }
#line 117
  dnode = find_filename_and_dnode(path, & filename);
#line 119
  if (! dnode) {
#line 121
    __cil_tmp___1 = __errno();
#line 121
    *__cil_tmp___1 = 2;
#line 122
    return (-1);
  }
#line 125
  __cil_tmp___2 = __otter_fs_find_inode_in_dir((char const   *)filename, dnode);
#line 125
  inode = __cil_tmp___2;
#line 126
  if (! inode) {
#line 128
    if (4 & oflag) {
#line 130
      __cil_tmp___5 = __errno();
#line 130
      if (*__cil_tmp___5 == 2) {
#line 133
        __cil_tmp___3 = __builtin_va_arg(varargs, mode_t );
#line 133
        mode = __cil_tmp___3;
#line 135
        inode = __otter_fs_touch((char const   *)filename, dnode);
#line 136
        if (! inode) {
#line 137
          return (-1);
        }
#line 138
        inode->permissions = (int )((mode & 4095U) | 12288U);
#line 139
        __cil_tmp___4 = __errno();
#line 139
        *__cil_tmp___4 = 0;
      } else {
#line 142
        return (-1);
      }
    } else {
#line 145
      return (-1);
    }
  } else
#line 149
  if (4 & oflag && 8 & oflag) {
#line 151
    __cil_tmp___6 = __errno();
#line 151
    *__cil_tmp___6 = 17;
#line 152
    return (-1);
  }
#line 158
  __cil_tmp___7 = __otter_fs_open_file(inode, oflag);
#line 158
  fd = __cil_tmp___7;
#line 159
  if (fd == -1) {
#line 160
    return (-1);
  }
#line 162
  if (32 & oflag && inode->type == 0) {
#line 164
    inode->size = 0;
#line 165
    free((void *)inode->data);
#line 166
    inode->data = (char *)((void *)0);
  }
#line 169
  return (fd);
}
}
#line 1 "cil-dhV4Wior.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hDNHJi9u.i","")
#line 6 "syscalls/fcntl/open.c"
int open(char const   *path , int oflag  , ...) 
{ va_list varargs ;
  int result ;
  int __cil_tmp ;

  {
#line 8
  __builtin_va_start(varargs, oflag);
#line 9
  __cil_tmp = __otter_libc_vopen(path, oflag, varargs);
#line 9
  result = __cil_tmp;
#line 10
  __builtin_va_end(varargs);
#line 11
  return (result);
}
}
#line 1 "cil-G908lcpf.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-IUlZ4UDT.i","")
#line 14 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_user.h"
uid_t __otter_uid ;
#line 1 "cil-Pv2sKAJd.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-jW8KM8Iu.i","")
#line 1 "cil-03ayb2q4.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-xPHgjhNo.i","")
#line 1 "cil-iEXhcfiD.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7PdvPozj.i","")
#line 1 "cil-VFwp76dQ.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-oCUa11Rd.i","")
#line 7 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/multiotter_builtins.h"
void __otter_multi_gfree(void *p ) ;
#line 8
pid_t __otter_multi_fork(void) ;
#line 10
pid_t __otter_multi_get_pid(void) ;
#line 9 "syscalls/otter/multiotter_builtins_stub.c"
void *__otter_multi_gmalloc(size_t size ) 
{ void *__cil_tmp ;

  {
#line 10
  __cil_tmp = malloc(size);
#line 10
  return (__cil_tmp);
}
}
#line 13 "syscalls/otter/multiotter_builtins_stub.c"
void __otter_multi_gfree(void *p ) 
{ 

  {
#line 14
  free(p);
#line 15
  return;
}
}
#line 17 "syscalls/otter/multiotter_builtins_stub.c"
pid_t __otter_multi_fork(void) 
{ 

  {
#line 19
  return (1);
}
}
#line 22 "syscalls/otter/multiotter_builtins_stub.c"
pid_t __otter_multi_get_pid(void) 
{ 

  {
#line 23
  return (1);
}
}
#line 1 "cil-TgHbr02u.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-NOqy3JBp.i","")
#line 95 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dnode *__otter_fs_find_dnode_in_dir(char const   *name , struct __otter_fs_dnode *dir ) ;
#line 97
struct __otter_fs_dnode *__otter_fs_find_dnode_in_tree(char *name , struct __otter_fs_dnode *tree ) ;
#line 117
int __otter_fs_next_fd(void) ;
#line 119
int __otter_fs_next_global_fd(void) ;
#line 125
int __otter_fs_legal_name(char const   *name ) ;
#line 129
struct __otter_fs_dnode *__otter_fs_mkdir(char const   *name , struct __otter_fs_dnode *dir ) ;
#line 131
int __otter_fs_unlink_in_dir(char const   *name , struct __otter_fs_dnode *dir ) ;
#line 133
int __otter_fs_link_file(char const   *name , struct __otter_fs_inode *target , struct __otter_fs_dnode *dir ) ;
#line 8 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_builtins.h"
extern size_t __otter_get_allocated_size(void *ptr ) ;
#line 15 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/multiotter_builtins.h"
void *__otter_multi_gcalloc(size_t count , size_t size ) ;
#line 20 "syscalls/otter/otter_fs.c"
uid_t __otter_uid  =    (unsigned short)1;
#line 23 "syscalls/otter/otter_fs.c"
int __otter_fs_is_owner(int filep ) 
{ 

  {
#line 25
  return ((filep & 8192 && (int )__otter_uid == 1) || (int )__otter_uid == 0);
}
}
#line 28 "syscalls/otter/otter_fs.c"
int __otter_fs_is_group(int filep ) 
{ 

  {
#line 30
  return ((filep & 4096 && (int )__otter_uid == 1) || (int )__otter_uid == 0);
}
}
#line 33 "syscalls/otter/otter_fs.c"
int __otter_fs_can_permission(int filep , int wantp ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 35
  __cil_tmp___0 = __otter_fs_is_owner(filep);
#line 35
  if (__cil_tmp___0) {
#line 36
    wantp <<= 6;
  } else {
#line 37
    __cil_tmp = __otter_fs_is_group(filep);
#line 37
    if (__cil_tmp) {
#line 38
      wantp <<= 3;
    }
  }
#line 40
  return ((filep & wantp) == wantp);
}
}
#line 43 "syscalls/otter/otter_fs.c"
struct __otter_fs_inode *__otter_fs_find_inode_in_dir(char const   *name , struct __otter_fs_dnode *dir ) 
{ int *__cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  struct __otter_fs_filelist *files ;
  int cmp ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;

  {
#line 45
  __cil_tmp___0 = __otter_fs_can_permission(dir->permissions, 1);
#line 45
  if (! __cil_tmp___0) {
#line 46
    __cil_tmp = __errno();
#line 46
    *__cil_tmp = 13;
#line 46
    return ((struct __otter_fs_inode *)((void *)0));
  }
#line 48
  if (dir->numfiles == 0) {
#line 49
    __cil_tmp___1 = __errno();
#line 49
    *__cil_tmp___1 = 2;
#line 49
    return ((struct __otter_fs_inode *)((void *)0));
  }
#line 51
  files = dir->files;
#line 53
  while (files) {
#line 55
    __cil_tmp___2 = strcmp((char const   *)files->name, name);
#line 55
    cmp = __cil_tmp___2;
#line 56
    if (cmp == 0) {
#line 57
      return (files->inode);
    }
#line 58
    files = files->next;
  }
#line 61
  __cil_tmp___3 = __errno();
#line 61
  *__cil_tmp___3 = 2;
#line 61
  return ((struct __otter_fs_inode *)((void *)0));
}
}
#line 64 "syscalls/otter/otter_fs.c"
struct __otter_fs_dnode *__otter_fs_find_dnode_in_dir(char const   *name , struct __otter_fs_dnode *dir ) 
{ int *__cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  struct __otter_fs_dirlist *dirs ;
  int cmp ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;

  {
#line 66
  __cil_tmp___0 = __otter_fs_can_permission(dir->permissions, 1);
#line 66
  if (! __cil_tmp___0) {
#line 67
    __cil_tmp = __errno();
#line 67
    *__cil_tmp = 13;
#line 67
    return ((struct __otter_fs_dnode *)((void *)0));
  }
#line 69
  if (dir->numdirs == 0) {
#line 70
    __cil_tmp___1 = __errno();
#line 70
    *__cil_tmp___1 = 2;
#line 70
    return ((struct __otter_fs_dnode *)((void *)0));
  }
#line 72
  dirs = dir->dirs;
#line 74
  while (dirs) {
#line 76
    __cil_tmp___2 = strcmp((char const   *)dirs->name, name);
#line 76
    cmp = __cil_tmp___2;
#line 77
    if (cmp == 0) {
#line 78
      return (dirs->dnode);
    }
#line 79
    dirs = dirs->next;
  }
#line 82
  __cil_tmp___3 = __errno();
#line 82
  *__cil_tmp___3 = 2;
#line 82
  return ((struct __otter_fs_dnode *)((void *)0));
}
}
#line 117 "syscalls/otter/otter_fs.c"
struct __otter_fs_dnode *__otter_fs_find_dnode_in_tree(char *name , struct __otter_fs_dnode *tree ) 
{ int *__cil_tmp ;
  int __cil_tmp___0 ;
  char *s ;
  char *__cil_tmp___1 ;
  struct __otter_fs_dnode *__cil_tmp___2 ;
  struct __otter_fs_dnode *d ;
  struct __otter_fs_dnode *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  struct __otter_fs_dnode *__cil_tmp___6 ;

  {
#line 119
  __cil_tmp___0 = __otter_fs_can_permission(tree->permissions, 1);
#line 119
  if (! __cil_tmp___0) {
#line 120
    __cil_tmp = __errno();
#line 120
    *__cil_tmp = 13;
#line 120
    return ((struct __otter_fs_dnode *)((void *)0));
  }
#line 122
  __cil_tmp___1 = strchr((char const   *)name, '/');
#line 122
  s = __cil_tmp___1;
#line 124
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 126
    __cil_tmp___2 = __otter_fs_find_dnode_in_dir((char const   *)name, tree);
#line 126
    return (__cil_tmp___2);
  }
#line 130
  *s = (char)0;
#line 131
  __cil_tmp___3 = __otter_fs_find_dnode_in_dir((char const   *)name, tree);
#line 131
  d = __cil_tmp___3;
#line 132
  *s = (char )'/';
#line 134
  if ((unsigned int )d == (unsigned int )((void *)0)) {
#line 136
    __cil_tmp___4 = __errno();
#line 136
    *__cil_tmp___4 = 2;
#line 136
    return ((struct __otter_fs_dnode *)((void *)0));
  }
#line 139
  while ((int )*s == 47) {
#line 141
    s ++;
#line 142
    if ((int )*s == 0) {
#line 143
      __cil_tmp___5 = __errno();
#line 143
      *__cil_tmp___5 = 2;
#line 143
      return ((struct __otter_fs_dnode *)((void *)0));
    }
  }
#line 146
  __cil_tmp___6 = __otter_fs_find_dnode_in_tree(s, d);
#line 146
  return (__cil_tmp___6);
}
}
#line 171 "syscalls/otter/otter_fs.c"
struct __otter_fs_dnode *__otter_fs_find_dnode(char const   *name_in ) 
{ char *name ;
  size_t __cil_tmp ;
  void *__cil_tmp___0 ;
  struct __otter_fs_dnode *dnode ;
  int *__cil_tmp___1 ;

  {
#line 173
  __cil_tmp = __otter_get_allocated_size((void *)name_in);
#line 173
  __cil_tmp___0 = malloc(__cil_tmp);
#line 173
  name = (char *)__cil_tmp___0;
#line 174
  strcpy(name, name_in);
#line 176
  if (name) {
#line 179
    if ((int )*name == 47) {
#line 181
      dnode = __otter_fs_find_dnode_in_tree(name + 1, __otter_fs_root);
    } else {
#line 184
      dnode = __otter_fs_find_dnode_in_tree(name, __otter_fs_pwd);
    }
#line 186
    free((void *)name);
#line 187
    return (dnode);
  }
#line 190
  __cil_tmp___1 = __errno();
#line 190
  *__cil_tmp___1 = 2;
#line 190
  return ((struct __otter_fs_dnode *)((void *)0));
}
}
#line 193 "syscalls/otter/otter_fs.c"
int __otter_fs_legal_char(char c ) 
{ 

  {
#line 195
  return ((int )(((((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 7) | (int const   )((int )c == 45)) | (int const   )((int )c == 95)) | (int const   )((int )c == 46)));
}
}
#line 199 "syscalls/otter/otter_fs.c"
int __otter_fs_legal_name(char const   *name ) 
{ int __cil_tmp ;

  {
#line 201
  if (name) {
#line 203
    if ((int const   )*name == 0) {
#line 204
      return (0);
    }
#line 205
    if ((int const   )*name == 45) {
#line 206
      return (0);
    }
#line 208
    while (1) {
#line 210
      if ((int const   )*name == 0) {
#line 211
        return (1);
      }
#line 212
      __cil_tmp = __otter_fs_legal_char((char )*name);
#line 212
      if (! __cil_tmp) {
#line 213
        return (0);
      }
#line 208
      name ++;
    }
  }
#line 218
  return (0);
}
}
#line 241 "syscalls/otter/otter_fs.c"
int __otter_fs_umask  =    12781;
#line 243 "syscalls/otter/otter_fs.c"
struct __otter_fs_dnode *__otter_fs_mkdir(char const   *name , struct __otter_fs_dnode *dir ) 
{ int *__cil_tmp ;
  int __cil_tmp___0 ;
  struct __otter_fs_dnode *d ;
  struct __otter_fs_dnode *__cil_tmp___1 ;
  struct __otter_fs_inode *f ;
  struct __otter_fs_inode *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  struct __otter_fs_dirlist *dirs ;
  struct __otter_fs_dirlist *pdirs ;
  struct __otter_fs_dnode *newdir ;
  void *__cil_tmp___4 ;
  struct __otter_fs_dirlist *basic_dir_entries1 ;
  void *__cil_tmp___5 ;
  struct __otter_fs_dirlist *basic_dir_entries0 ;
  void *__cil_tmp___6 ;
  struct __otter_fs_dirlist *newdirlist ;
  void *__cil_tmp___7 ;
  int __cil_tmp___8 ;
  int *__cil_tmp___9 ;

  {
#line 245
  __cil_tmp___0 = __otter_fs_can_permission(dir->permissions, 2);
#line 245
  if (! __cil_tmp___0) {
#line 246
    __cil_tmp = __errno();
#line 246
    *__cil_tmp = 13;
#line 246
    return ((struct __otter_fs_dnode *)((void *)0));
  }
#line 248
  __cil_tmp___8 = __otter_fs_legal_name(name);
#line 248
  if (__cil_tmp___8) {
#line 250
    __cil_tmp___1 = __otter_fs_find_dnode_in_dir(name, dir);
#line 250
    d = __cil_tmp___1;
#line 251
    __cil_tmp___2 = __otter_fs_find_inode_in_dir(name, dir);
#line 251
    f = __cil_tmp___2;
#line 252
    if (d || f) {
#line 253
      __cil_tmp___3 = __errno();
#line 253
      *__cil_tmp___3 = 17;
#line 253
      return ((struct __otter_fs_dnode *)((void *)0));
    }
#line 255
    dirs = dir->dirs;
#line 256
    pdirs = (struct __otter_fs_dirlist *)((void *)0);
#line 258
    while (dirs) {
#line 260
      pdirs = dirs;
#line 261
      dirs = dirs->next;
    }
#line 264
    __cil_tmp___4 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_dnode ));
#line 264
    newdir = (struct __otter_fs_dnode *)__cil_tmp___4;
#line 265
    __cil_tmp___5 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_dirlist ));
#line 265
    basic_dir_entries1 = (struct __otter_fs_dirlist *)__cil_tmp___5;
#line 266
    __cil_tmp___6 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_dirlist ));
#line 266
    basic_dir_entries0 = (struct __otter_fs_dirlist *)__cil_tmp___6;
#line 267
    basic_dir_entries1->name = (char *)"..";
#line 268
    basic_dir_entries1->dnode = dir;
#line 269
    basic_dir_entries1->next = (struct __otter_fs_dirlist *)((void *)0);
#line 270
    basic_dir_entries0->name = (char *)".";
#line 271
    basic_dir_entries0->dnode = newdir;
#line 272
    basic_dir_entries0->next = basic_dir_entries1;
#line 273
    newdir->linkno = 1;
#line 274
    newdir->numfiles = 0;
#line 275
    newdir->numdirs = 2;
#line 276
    newdir->files = (struct __otter_fs_filelist *)((void *)0);
#line 277
    newdir->dirs = basic_dir_entries0;
#line 278
    newdir->r_openno = 0;
#line 279
    newdir->permissions = __otter_fs_umask;
#line 280
    __cil_tmp___7 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_dirlist ));
#line 280
    newdirlist = (struct __otter_fs_dirlist *)__cil_tmp___7;
#line 281
    newdirlist->name = (char *)name;
#line 282
    newdirlist->dnode = newdir;
#line 283
    newdirlist->next = (struct __otter_fs_dirlist *)((void *)0);
#line 285
    (dir->numdirs) ++;
#line 287
    if (pdirs) {
#line 288
      pdirs->next = newdirlist;
    } else {
#line 290
      dir->dirs = newdirlist;
    }
#line 292
    return (newdir);
  }
#line 295
  __cil_tmp___9 = __errno();
#line 295
  *__cil_tmp___9 = 22;
#line 295
  return ((struct __otter_fs_dnode *)((void *)0));
}
}
#line 298 "syscalls/otter/otter_fs.c"
struct __otter_fs_inode *__otter_fs_touch(char const   *name , struct __otter_fs_dnode *dir ) 
{ int *__cil_tmp ;
  int __cil_tmp___0 ;
  struct __otter_fs_dnode *d ;
  struct __otter_fs_dnode *__cil_tmp___1 ;
  struct __otter_fs_inode *f ;
  struct __otter_fs_inode *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  struct __otter_fs_filelist *files ;
  struct __otter_fs_filelist *pfiles ;
  struct __otter_fs_inode *newfile ;
  void *__cil_tmp___4 ;
  struct __otter_fs_filelist *newfilelist ;
  void *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  int *__cil_tmp___7 ;

  {
#line 300
  __cil_tmp___0 = __otter_fs_can_permission(dir->permissions, 2);
#line 300
  if (! __cil_tmp___0) {
#line 301
    __cil_tmp = __errno();
#line 301
    *__cil_tmp = 13;
#line 301
    return ((struct __otter_fs_inode *)((void *)0));
  }
#line 303
  __cil_tmp___6 = __otter_fs_legal_name(name);
#line 303
  if (__cil_tmp___6) {
#line 305
    __cil_tmp___1 = __otter_fs_find_dnode_in_dir(name, dir);
#line 305
    d = __cil_tmp___1;
#line 306
    __cil_tmp___2 = __otter_fs_find_inode_in_dir(name, dir);
#line 306
    f = __cil_tmp___2;
#line 307
    if (d || f) {
#line 308
      __cil_tmp___3 = __errno();
#line 308
      *__cil_tmp___3 = 17;
#line 308
      return ((struct __otter_fs_inode *)((void *)0));
    }
#line 310
    files = dir->files;
#line 311
    pfiles = (struct __otter_fs_filelist *)((void *)0);
#line 313
    while (files) {
#line 315
      pfiles = files;
#line 316
      files = files->next;
    }
#line 319
    __cil_tmp___4 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_inode ));
#line 319
    newfile = (struct __otter_fs_inode *)__cil_tmp___4;
#line 320
    newfile->linkno = 1;
#line 321
    newfile->size = 0;
#line 322
    newfile->type = 0;
#line 323
    newfile->permissions = __otter_fs_umask;
#line 324
    newfile->data = (char *)((void *)0);
#line 325
    newfile->numblocks = 0;
#line 326
    newfile->r_openno = 0;
#line 327
    newfile->w_openno = 0;
#line 328
    __cil_tmp___5 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_filelist ));
#line 328
    newfilelist = (struct __otter_fs_filelist *)__cil_tmp___5;
#line 329
    newfilelist->name = (char *)name;
#line 330
    newfilelist->inode = newfile;
#line 331
    newfilelist->next = (struct __otter_fs_filelist *)((void *)0);
#line 333
    (dir->numfiles) ++;
#line 335
    if (pfiles) {
#line 336
      pfiles->next = newfilelist;
    } else {
#line 338
      dir->files = newfilelist;
    }
#line 340
    return (newfile);
  }
#line 343
  __cil_tmp___7 = __errno();
#line 343
  *__cil_tmp___7 = 22;
#line 343
  return ((struct __otter_fs_inode *)((void *)0));
}
}
#line 346 "syscalls/otter/otter_fs.c"
int __otter_fs_unlink_in_dir(char const   *name , struct __otter_fs_dnode *dir ) 
{ int *__cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  struct __otter_fs_dnode *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  struct __otter_fs_filelist *files ;
  struct __otter_fs_filelist *pfiles ;
  int cmp ;
  int __cil_tmp___4 ;
  struct __otter_fs_inode *inode ;
  int *__cil_tmp___5 ;

  {
#line 348
  __cil_tmp___0 = __otter_fs_can_permission(dir->permissions, 2);
#line 348
  if (! __cil_tmp___0) {
#line 349
    __cil_tmp = __errno();
#line 349
    *__cil_tmp = 13;
#line 349
    return ((int )((void *)0));
  }
#line 351
  __cil_tmp___2 = __otter_fs_find_dnode_in_dir(name, dir);
#line 351
  if (__cil_tmp___2) {
#line 352
    __cil_tmp___1 = __errno();
#line 352
    *__cil_tmp___1 = 1;
#line 352
    return ((int )((void *)0));
  }
#line 354
  if (dir->numfiles == 0) {
#line 355
    __cil_tmp___3 = __errno();
#line 355
    *__cil_tmp___3 = 2;
#line 355
    return ((int )((void *)0));
  }
#line 357
  files = dir->files;
#line 358
  pfiles = (struct __otter_fs_filelist *)((void *)0);
#line 360
  while (files) {
#line 362
    __cil_tmp___4 = strcmp((char const   *)files->name, name);
#line 362
    cmp = __cil_tmp___4;
#line 363
    if (cmp == 0) {
#line 365
      inode = files->inode;
#line 366
      (inode->linkno) --;
#line 368
      if ((unsigned int )pfiles == (unsigned int )((void *)0)) {
#line 370
        dir->files = files->next;
      } else {
#line 374
        pfiles->next = files->next;
      }
#line 377
      if (inode->linkno == 0) {
#line 379
        if (! (inode->r_openno | inode->w_openno)) {
#line 381
          free((void *)inode->data);
#line 382
          free((void *)inode);
        }
      }
#line 386
      return (1);
    }
#line 388
    pfiles = files;
#line 389
    files = files->next;
  }
#line 392
  __cil_tmp___5 = __errno();
#line 392
  *__cil_tmp___5 = 2;
#line 392
  return ((int )((void *)0));
}
}
#line 449 "syscalls/otter/otter_fs.c"
int __otter_fs_link_file(char const   *name , struct __otter_fs_inode *target , struct __otter_fs_dnode *dir ) 
{ int *__cil_tmp ;
  int __cil_tmp___0 ;
  struct __otter_fs_dnode *d ;
  struct __otter_fs_dnode *__cil_tmp___1 ;
  struct __otter_fs_inode *f ;
  struct __otter_fs_inode *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  struct __otter_fs_dirlist *files ;
  struct __otter_fs_dirlist *pfiles ;
  struct __otter_fs_filelist *newfilelist ;
  void *__cil_tmp___4 ;
  int __cil_tmp___5 ;
  int *__cil_tmp___6 ;

  {
#line 451
  __cil_tmp___0 = __otter_fs_can_permission(dir->permissions, 2);
#line 451
  if (! __cil_tmp___0) {
#line 452
    __cil_tmp = __errno();
#line 452
    *__cil_tmp = 13;
#line 452
    return ((int )((void *)0));
  }
#line 454
  __cil_tmp___5 = __otter_fs_legal_name(name);
#line 454
  if (__cil_tmp___5) {
#line 456
    __cil_tmp___1 = __otter_fs_find_dnode_in_dir(name, dir);
#line 456
    d = __cil_tmp___1;
#line 457
    __cil_tmp___2 = __otter_fs_find_inode_in_dir(name, dir);
#line 457
    f = __cil_tmp___2;
#line 458
    if (d || f) {
#line 459
      __cil_tmp___3 = __errno();
#line 459
      *__cil_tmp___3 = 17;
#line 459
      return ((int )((void *)0));
    }
#line 461
    files = (struct __otter_fs_dirlist *)dir->files;
#line 462
    pfiles = (struct __otter_fs_dirlist *)((void *)0);
#line 464
    while (files) {
#line 466
      pfiles = files;
#line 467
      files = files->next;
    }
#line 470
    __cil_tmp___4 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_filelist ));
#line 470
    newfilelist = (struct __otter_fs_filelist *)__cil_tmp___4;
#line 471
    newfilelist->name = (char *)name;
#line 472
    newfilelist->inode = target;
#line 473
    newfilelist->next = (struct __otter_fs_filelist *)((void *)0);
#line 475
    (target->linkno) ++;
#line 477
    (dir->numfiles) ++;
#line 478
    if (pfiles) {
#line 479
      pfiles->next = (struct __otter_fs_dirlist *)newfilelist;
    } else {
#line 481
      dir->files = newfilelist;
    }
#line 483
    return (1);
  }
#line 486
  __cil_tmp___6 = __errno();
#line 486
  *__cil_tmp___6 = 22;
#line 486
  return ((int )((void *)0));
}
}
#line 532 "syscalls/otter/otter_fs.c"
int __otter_fs_next_fd(void) 
{ int fd ;

  {
#line 534
  fd = 0;
#line 534
  while (fd < 64) {
#line 536
    if (*(__otter_fs_fd_table + fd) == -1) {
#line 537
      return (fd);
    }
#line 534
    fd ++;
  }
#line 540
  return (-1);
}
}
#line 544 "syscalls/otter/otter_fs.c"
int __otter_fs_more_fd(int arg ) 
{ int fd ;

  {
#line 546
  fd = arg;
#line 546
  while (fd < 64) {
#line 548
    if (*(__otter_fs_fd_table + fd) == -1) {
#line 549
      return (fd);
    }
#line 546
    fd ++;
  }
#line 552
  return (-1);
}
}
#line 556 "syscalls/otter/otter_fs.c"
int __otter_fs_next_global_fd(void) 
{ int i ;

  {
#line 558
  i = 0;
#line 558
  while (i < 128) {
#line 560
    if ((__otter_fs_open_file_table + i)->openno == 0) {
#line 561
      return (i);
    }
#line 558
    i ++;
  }
#line 564
  return (-1);
}
}
#line 567 "syscalls/otter/otter_fs.c"
int __otter_fs_open_file(struct __otter_fs_inode *inode , int mode ) 
{ int permissions ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  int fd ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int ft ;
  int __cil_tmp___3 ;
  int *__cil_tmp___4 ;

  {
#line 569
  __otter_multi_begin_atomic();
#line 570
  permissions = 0;
#line 571
  if (mode & 1) {
#line 572
    permissions += 2;
  }
#line 573
  if (mode & 2) {
#line 574
    permissions += 4;
  }
#line 576
  __cil_tmp___0 = __otter_fs_can_permission(inode->permissions, permissions);
#line 576
  if (! __cil_tmp___0) {
#line 578
    __cil_tmp = __errno();
#line 578
    *__cil_tmp = 13;
#line 579
    __otter_multi_end_atomic();
#line 580
    return (-1);
  }
#line 583
  __cil_tmp___1 = __otter_fs_next_fd();
#line 583
  fd = __cil_tmp___1;
#line 584
  if (fd == -1) {
#line 586
    __cil_tmp___2 = __errno();
#line 586
    *__cil_tmp___2 = 24;
#line 587
    __otter_multi_end_atomic();
#line 588
    return (-1);
  }
#line 591
  __cil_tmp___3 = __otter_fs_next_global_fd();
#line 591
  ft = __cil_tmp___3;
#line 592
  if (ft == -1) {
#line 594
    __cil_tmp___4 = __errno();
#line 594
    *__cil_tmp___4 = 23;
#line 595
    __otter_multi_end_atomic();
#line 596
    return (-1);
  }
#line 599
  if (mode & 1) {
#line 600
    (inode->r_openno) ++;
  }
#line 601
  if (mode & 2) {
#line 602
    (inode->w_openno) ++;
  }
#line 604
  *(__otter_fs_fd_table + fd) = ft;
#line 605
  (__otter_fs_open_file_table + ft)->mode = mode;
#line 606
  (__otter_fs_open_file_table + ft)->type = inode->type;
#line 607
  (__otter_fs_open_file_table + ft)->inode = inode;
#line 608
  (__otter_fs_open_file_table + ft)->dnode = (struct __otter_fs_dnode *)((void *)0);
#line 609
  (__otter_fs_open_file_table + ft)->offset = 0;
#line 610
  (__otter_fs_open_file_table + ft)->openno = 1;
#line 612
  __otter_multi_end_atomic();
#line 613
  return (fd);
}
}
#line 616 "syscalls/otter/otter_fs.c"
int __otter_fs_open_dir(struct __otter_fs_dnode *dnode , int mode ) 
{ int permissions ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int fd ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int ft ;
  int __cil_tmp___4 ;
  int *__cil_tmp___5 ;

  {
#line 618
  permissions = 0;
#line 619
  if (mode & 1) {
#line 620
    permissions = 2;
  }
#line 621
  if (mode & 2) {
#line 623
    __cil_tmp = __errno();
#line 623
    *__cil_tmp = 21;
#line 624
    return (-1);
  }
#line 627
  __cil_tmp___1 = __otter_fs_can_permission(dnode->permissions, permissions);
#line 627
  if (! __cil_tmp___1) {
#line 629
    __cil_tmp___0 = __errno();
#line 629
    *__cil_tmp___0 = 13;
#line 630
    return (-1);
  }
#line 633
  __cil_tmp___2 = __otter_fs_next_fd();
#line 633
  fd = __cil_tmp___2;
#line 634
  if (fd == -1) {
#line 636
    __cil_tmp___3 = __errno();
#line 636
    *__cil_tmp___3 = 24;
#line 637
    return (-1);
  }
#line 640
  __cil_tmp___4 = __otter_fs_next_global_fd();
#line 640
  ft = __cil_tmp___4;
#line 641
  if (ft == -1) {
#line 643
    __cil_tmp___5 = __errno();
#line 643
    *__cil_tmp___5 = 23;
#line 644
    return (-1);
  }
#line 647
  (dnode->r_openno) ++;
#line 649
  *(__otter_fs_fd_table + fd) = ft;
#line 650
  (__otter_fs_open_file_table + ft)->mode = mode;
#line 651
  (__otter_fs_open_file_table + ft)->type = 1;
#line 652
  (__otter_fs_open_file_table + ft)->inode = (struct __otter_fs_inode *)((void *)0);
#line 653
  (__otter_fs_open_file_table + ft)->dnode = dnode;
#line 654
  (__otter_fs_open_file_table + ft)->offset = 0;
#line 655
  (__otter_fs_open_file_table + ft)->openno = 1;
#line 657
  return (fd);
}
}
#line 660 "syscalls/otter/otter_fs.c"
int __otter_fs_change_open_mode(struct __otter_fs_open_file_table_entry *open_file ,
                                int mode ) 
{ int old_mode ;
  int changed ;
  int add ;
  int remove___0 ;
  int permissions ;
  int *__cil_tmp ;
  struct __otter_fs_dnode *dnode ;
  int *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  struct __otter_fs_inode *inode ;
  int *__cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 662
  old_mode = open_file->mode;
#line 663
  changed = old_mode ^ mode;
#line 664
  add = changed & mode;
#line 665
  remove___0 = changed & old_mode;
#line 667
  permissions = 0;
#line 668
  if (add & 1) {
#line 669
    permissions += 2;
  }
#line 670
  if (add & 2) {
#line 672
    permissions += 4;
#line 674
    if (open_file->type == 1) {
#line 676
      __cil_tmp = __errno();
#line 676
      *__cil_tmp = 21;
#line 677
      return (-1);
    }
  }
#line 681
  if (open_file->type == 1) {
#line 683
    dnode = open_file->dnode;
#line 685
    __cil_tmp___1 = __otter_fs_can_permission(dnode->permissions, permissions);
#line 685
    if (! __cil_tmp___1) {
#line 687
      __cil_tmp___0 = __errno();
#line 687
      *__cil_tmp___0 = 13;
#line 688
      return (-1);
    }
#line 691
    if (add & 1) {
#line 692
      (dnode->r_openno) ++;
    }
#line 694
    if (remove___0 & 1) {
#line 695
      (dnode->r_openno) --;
    }
  } else {
#line 699
    inode = open_file->inode;
#line 701
    __cil_tmp___3 = __otter_fs_can_permission(inode->permissions, permissions);
#line 701
    if (! __cil_tmp___3) {
#line 703
      __cil_tmp___2 = __errno();
#line 703
      *__cil_tmp___2 = 13;
#line 704
      return (-1);
    }
#line 707
    if (add & 1) {
#line 708
      (inode->r_openno) ++;
    }
#line 709
    if (add & 2) {
#line 710
      (inode->w_openno) ++;
    }
#line 712
    if (remove___0 & 1) {
#line 713
      (inode->r_openno) --;
    }
#line 714
    if (remove___0 & 2) {
#line 715
      (inode->w_openno) --;
    }
  }
#line 718
  open_file->mode = mode;
#line 720
  return (0);
}
}
#line 733 "syscalls/otter/otter_fs.c"
struct __otter_fs_dnode *__otter_fs_mkroot(void) 
{ struct __otter_fs_dnode *newdir ;
  void *__cil_tmp ;
  struct __otter_fs_dirlist *basic_dir_entries1 ;
  void *__cil_tmp___0 ;
  struct __otter_fs_dirlist *basic_dir_entries0 ;
  void *__cil_tmp___1 ;

  {
#line 735
  __cil_tmp = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_dnode ));
#line 735
  newdir = (struct __otter_fs_dnode *)__cil_tmp;
#line 736
  __cil_tmp___0 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_dirlist ));
#line 736
  basic_dir_entries1 = (struct __otter_fs_dirlist *)__cil_tmp___0;
#line 737
  __cil_tmp___1 = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_dirlist ));
#line 737
  basic_dir_entries0 = (struct __otter_fs_dirlist *)__cil_tmp___1;
#line 738
  basic_dir_entries1->name = (char *)"..";
#line 739
  basic_dir_entries1->dnode = newdir;
#line 740
  basic_dir_entries1->next = (struct __otter_fs_dirlist *)((void *)0);
#line 741
  basic_dir_entries0->name = (char *)".";
#line 742
  basic_dir_entries0->dnode = newdir;
#line 743
  basic_dir_entries0->next = basic_dir_entries1;
#line 744
  newdir->linkno = 1;
#line 745
  newdir->numfiles = 0;
#line 746
  newdir->numdirs = 2;
#line 747
  newdir->files = (struct __otter_fs_filelist *)((void *)0);
#line 748
  newdir->dirs = basic_dir_entries0;
#line 749
  newdir->permissions = 12781;
#line 751
  return (newdir);
}
}
#line 754 "syscalls/otter/otter_fs.c"
void __otter_fs_mount(void) 
{ struct __otter_fs_dnode *root ;
  struct __otter_fs_dnode *__cil_tmp ;
  struct __otter_fs_dnode *wrk ;
  struct __otter_fs_dnode *__cil_tmp___0 ;
  struct __otter_fs_dnode *tmp ;
  struct __otter_fs_dnode *__cil_tmp___1 ;
  struct __otter_fs_dnode *dev ;
  struct __otter_fs_dnode *__cil_tmp___2 ;
  struct __otter_fs_inode *tty ;
  struct __otter_fs_inode *__cil_tmp___3 ;
  struct __otter_fs_inode *null ;
  struct __otter_fs_inode *__cil_tmp___4 ;
  struct __otter_fs_inode *zero ;
  struct __otter_fs_inode *__cil_tmp___5 ;
  void *__cil_tmp___6 ;
  void *__cil_tmp___7 ;

  {
#line 756
  __cil_tmp = __otter_fs_mkroot();
#line 756
  root = __cil_tmp;
#line 757
  __cil_tmp___0 = __otter_fs_mkdir("wrk", root);
#line 757
  wrk = __cil_tmp___0;
#line 758
  __cil_tmp___1 = __otter_fs_mkdir("tmp", root);
#line 758
  tmp = __cil_tmp___1;
#line 759
  __cil_tmp___2 = __otter_fs_mkdir("dev", root);
#line 759
  dev = __cil_tmp___2;
#line 761
  __cil_tmp___3 = __otter_fs_touch("tty", dev);
#line 761
  tty = __cil_tmp___3;
#line 762
  __cil_tmp___4 = __otter_fs_touch("null", dev);
#line 762
  null = __cil_tmp___4;
#line 763
  __cil_tmp___5 = __otter_fs_touch("zero", dev);
#line 763
  zero = __cil_tmp___5;
#line 764
  __otter_fs_link_file("console", tty, dev);
#line 766
  tty->permissions = 438;
#line 767
  null->permissions = 438;
#line 768
  zero->permissions = 438;
#line 770
  tty->type = 192;
#line 771
  null->type = 320;
#line 772
  zero->type = 448;
#line 774
  wrk->permissions = 511;
#line 775
  tmp->permissions = 1023;
#line 776
  dev->permissions = 511;
#line 777
  root->permissions = 493;
#line 779
  __otter_fs_root = root;
#line 780
  __otter_fs_pwd = wrk;
#line 783
  __cil_tmp___6 = malloc((unsigned int )(sizeof(int ) * 64UL));
#line 783
  __otter_fs_fd_table = (int *)__cil_tmp___6;
#line 784
  memset((void *)__otter_fs_fd_table, -1, (unsigned int )(64UL * sizeof(int )));
#line 785
  __cil_tmp___7 = __otter_multi_gcalloc((unsigned int )sizeof(struct __otter_fs_open_file_table_entry ),
                                        128U);
#line 785
  __otter_fs_open_file_table = (struct __otter_fs_open_file_table_entry *)__cil_tmp___7;
#line 786
  return;
}
}
#line 788 "syscalls/otter/otter_fs.c"
void __otter_fs_init_stdin_out_err(void) 
{ 

  {
#line 792
  _impure_ptr->_stdin = fopen("/dev/tty", "r+");
#line 793
  _impure_ptr->_stdout = fopen("/dev/tty", "w");
#line 794
  _impure_ptr->_stderr = fopen("/dev/tty", "r+");
#line 795
  return;
}
}
#line 1 "cil-pXxPD9F5.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ttqA4Xvm.i","")
#line 48 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
int __otter_fs_pipe_is_empty(struct __otter_fs_pipe_data *pipe___0 ) ;
#line 49
int __otter_fs_pipe_is_full(struct __otter_fs_pipe_data *pipe___0 ) ;
#line 146
struct __otter_fs_pipe_data *__otter_fs_init_new_pipe_data(void) ;
#line 147
struct __otter_fs_pipe_data *__otter_libc_get_pipe_data_from_open_file(struct __otter_fs_open_file_table_entry *open_file ) ;
#line 149
struct __otter_fs_sock_data *__otter_fs_init_new_socket_data(void) ;
#line 150
struct __otter_fs_inode *__otter_fs_init_new_socket(void) ;
#line 151
void __otter_fs_free_socket(struct __otter_fs_inode *inode ) ;
#line 22 "syscalls/otter/otter_fs_util.c"
struct __otter_fs_dnode *find_filename_and_dnode(char const   *path , char **basename ) 
{ char const   *basename_finder ;
  char *__cil_tmp ;
  struct __otter_fs_dnode *dnode ;
  char *name ;
  char *__cil_tmp___0 ;

  {
#line 24
  __cil_tmp = strrchr(path, '/');
#line 24
  basename_finder = (char const   *)__cil_tmp;
#line 27
  if (basename_finder) {
#line 31
    __cil_tmp___0 = strdup(path);
#line 31
    name = __cil_tmp___0;
#line 33
    *(name + (basename_finder - path)) = (char)0;
#line 35
    *basename = (char *)(basename_finder + 1);
#line 36
    dnode = __otter_fs_find_dnode((char const   *)name);
#line 37
    free((void *)name);
  } else {
#line 41
    dnode = __otter_fs_pwd;
#line 42
    *basename = (char *)path;
  }
#line 45
  return (dnode);
}
}
#line 50 "syscalls/otter/otter_fs_util.c"
struct __otter_fs_open_file_table_entry *get_open_file_from_fd(int fd ) 
{ int *__cil_tmp ;
  int open_file_index ;
  int *__cil_tmp___0 ;

  {
#line 52
  if (fd < 0 || fd >= 64) {
#line 54
    __cil_tmp = __errno();
#line 54
    *__cil_tmp = 9;
#line 55
    return ((struct __otter_fs_open_file_table_entry *)((void *)0));
  }
#line 57
  open_file_index = *(__otter_fs_fd_table + fd);
#line 58
  if (open_file_index == -1) {
#line 60
    __cil_tmp___0 = __errno();
#line 60
    *__cil_tmp___0 = 9;
#line 61
    return ((struct __otter_fs_open_file_table_entry *)((void *)0));
  }
#line 63
  return (__otter_fs_open_file_table + open_file_index);
}
}
#line 66 "syscalls/otter/otter_fs_util.c"
struct __otter_fs_pipe_data *__otter_fs_init_new_pipe_data(void) 
{ struct __otter_fs_pipe_data *pipe___0 ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 68
  __cil_tmp = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_pipe_data ));
#line 68
  pipe___0 = (struct __otter_fs_pipe_data *)__cil_tmp;
#line 69
  pipe___0->rhead = 1023;
#line 70
  pipe___0->whead = 0;
#line 71
  __cil_tmp___0 = __otter_multi_gmalloc(1024U);
#line 71
  pipe___0->data = (char *)__cil_tmp___0;
#line 72
  return (pipe___0);
}
}
#line 75 "syscalls/otter/otter_fs_util.c"
struct __otter_fs_pipe_data *__otter_libc_get_pipe_data_from_open_file(struct __otter_fs_open_file_table_entry *open_file ) 
{ 

  {
#line 76
  __ASSERT((_Bool )(open_file->type == 64));
#line 77
  return ((struct __otter_fs_pipe_data *)(open_file->inode)->data);
}
}
#line 80 "syscalls/otter/otter_fs_util.c"
int __otter_fs_pipe_is_empty(struct __otter_fs_pipe_data *pipe___0 ) 
{ 

  {
#line 81
  return ((pipe___0->rhead + 1) % 1024 == pipe___0->whead);
}
}
#line 84 "syscalls/otter/otter_fs_util.c"
int __otter_fs_pipe_is_full(struct __otter_fs_pipe_data *pipe___0 ) 
{ 

  {
#line 85
  return (pipe___0->rhead == pipe___0->whead);
}
}
#line 88 "syscalls/otter/otter_fs_util.c"
struct __otter_fs_sock_data *__otter_fs_init_new_socket_data(void) 
{ struct __otter_fs_sock_data *sock ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 90
  __cil_tmp = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_sock_data ));
#line 90
  sock = (struct __otter_fs_sock_data *)__cil_tmp;
#line 91
  __cil_tmp___0 = __otter_multi_gcalloc(16U, 1U);
#line 91
  sock->addr = (struct sockaddr *)__cil_tmp___0;
#line 92
  sock->state = 0;
#line 93
  sock->options = 0;
#line 94
  sock->recv_data = (struct __otter_fs_pipe_data *)((void *)0);
#line 95
  sock->sock_queue = (struct __otter_fs_sock_data **)((void *)0);
#line 96
  sock->backlog = 0;
#line 97
  return (sock);
}
}
#line 100 "syscalls/otter/otter_fs_util.c"
struct __otter_fs_inode *__otter_fs_init_new_socket(void) 
{ struct __otter_fs_inode *inode ;
  void *__cil_tmp ;
  struct __otter_fs_sock_data *__cil_tmp___0 ;

  {
#line 102
  __cil_tmp = __otter_multi_gmalloc((unsigned int )sizeof(struct __otter_fs_inode ));
#line 102
  inode = (struct __otter_fs_inode *)__cil_tmp;
#line 103
  inode->linkno = 0;
#line 104
  inode->size = 0;
#line 105
  inode->type = 576;
#line 106
  inode->permissions = __otter_fs_umask | 511;
#line 107
  __cil_tmp___0 = __otter_fs_init_new_socket_data();
#line 107
  inode->data = (char *)((void *)__cil_tmp___0);
#line 108
  inode->r_openno = 0;
#line 109
  inode->w_openno = 0;
#line 110
  inode->numblocks = 0;
#line 111
  return (inode);
}
}
#line 114 "syscalls/otter/otter_fs_util.c"
void __otter_fs_free_socket(struct __otter_fs_inode *inode ) 
{ 

  {
#line 116
  if (! inode) {
#line 117
    return;
  }
#line 119
  if (inode->data) {
#line 121
    if (((struct __otter_fs_sock_data *)inode->data)->recv_data) {
#line 123
      __otter_multi_gfree((void *)(((struct __otter_fs_sock_data *)inode->data)->recv_data)->data);
#line 124
      __otter_multi_gfree((void *)((struct __otter_fs_sock_data *)inode->data)->recv_data);
    }
#line 126
    __otter_multi_gfree((void *)((struct __otter_fs_sock_data *)inode->data)->sock_queue);
#line 127
    __otter_multi_gfree((void *)((struct __otter_fs_sock_data *)inode->data)->addr);
#line 128
    __otter_multi_gfree((void *)inode->data);
  }
#line 130
  __otter_multi_gfree((void *)inode);
#line 131
  return;
}
}
#line 1 "cil-E4TrXFa0.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-RkvwcYM5.i","")
#line 29 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_scheduler.h"
void __otter_multi_time_wait(unsigned int ticks ) ;
#line 4 "syscalls/otter/otter_scheduler_stub.c"
void __otter_multi_begin_atomic(void) 
{ 

  {
#line 6
  return;
}
}
#line 8 "syscalls/otter/otter_scheduler_stub.c"
void __otter_multi_end_atomic(void) 
{ 

  {
#line 10
  return;
}
}
#line 12 "syscalls/otter/otter_scheduler_stub.c"
void __otter_multi_time_wait(unsigned int ticks ) 
{ 

  {
#line 14
  return;
}
}
#line 16 "syscalls/otter/otter_scheduler_stub.c"
void __otter_multi_io_block(void * x , ...) 
{ 

  {
#line 18
  return;
}
}
#line 1 "cil-oFxR9tEM.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-qwiYNBng.i","")
#line 6 "syscalls/pthread/equal.c"
int pthread_equal(pthread_t t1 , pthread_t t2 ) 
{ 

  {
#line 7
  __ASSERT((_Bool )(t1 == 0U && t2 == 0U));
#line 8
  return (1);
}
}
#line 1 "cil-jT21t8E6.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-DmikxOmv.i","")
#line 3 "syscalls/pthread/self.c"
pthread_t pthread_self(void) 
{ 

  {
#line 4
  return (0U);
}
}
#line 1 "cil-0XKjIvyY.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-g271TBsB.i","")
#line 1 "cil-vhp7MCFp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-I6Fgf8j2.i","")
#line 22 "syscalls/stdio/_rename_r.c"
int _rename_r(struct _reent *ignored , char const   *old_path , char const   *new_path ) 
{ struct __otter_fs_dnode *old_dir ;
  struct __otter_fs_dnode *new_dir ;
  char *old_filename ;
  char *new_filename ;
  struct __otter_fs_inode *old_inode ;

  {
#line 28
  old_dir = find_filename_and_dnode(old_path, & old_filename);
#line 29
  if (! old_dir) {
#line 29
    return (-1);
  }
#line 30
  old_inode = __otter_fs_find_inode_in_dir((char const   *)old_filename, old_dir);
#line 31
  if (! old_inode) {
#line 31
    return (-1);
  }
#line 34
  new_dir = find_filename_and_dnode(new_path, & new_filename);
#line 35
  if (! new_dir) {
#line 35
    return (-1);
  }
#line 38
  __otter_multi_begin_atomic();
#line 41
  __otter_fs_unlink_in_dir((char const   *)new_filename, new_dir);
#line 43
  __otter_fs_link_file((char const   *)new_filename, old_inode, new_dir);
#line 45
  __otter_fs_unlink_in_dir((char const   *)old_filename, old_dir);
#line 47
  __otter_multi_end_atomic();
#line 49
  return (0);
}
}
#line 1 "cil-Qm5ZvaXe.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-2ihEKgXM.i","")
#line 7 "syscalls/stdlib/_free_r.c"
void _free_r(struct _reent *r , void *p ) 
{ 

  {
#line 8
  free(p);
#line 9
  return;
}
}
#line 1 "cil-4WzMR3ys.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-GvtBFNFW.i","")
#line 7 "syscalls/stdlib/_malloc_r.c"
void *_malloc_r(struct _reent *r , size_t s ) 
{ void *__cil_tmp ;

  {
#line 8
  __cil_tmp = malloc(s);
#line 8
  return (__cil_tmp);
}
}
#line 1 "cil-bBXsgreb.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CanPwu7w.i","")
#line 7 "syscalls/stdlib/_realloc_r.c"
void *_realloc_r(struct _reent *r , void *p , size_t s ) 
{ void *__cil_tmp ;

  {
#line 8
  __cil_tmp = realloc(p, s);
#line 8
  return (__cil_tmp);
}
}
#line 1 "cil-GrmrOSfQ.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-AHtYoZoW.i","")
#line 3 "syscalls/stdlib/abort.c"
 __attribute__((__noreturn__)) void abort(void) ;
#line 3 "syscalls/stdlib/abort.c"
void abort(void) 
{ 

  {
#line 4
  exit(1);
}
}
#line 1 "cil-GLwgBZMG.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-gbrxfNaX.i","")
#line 6 "syscalls/stdlib/calloc.c"
static void *__otter_calloc(size_t count , size_t size , void *(*alloc)(size_t  ) ) 
{ size_t len ;
  void *ptr ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 8
  len = count * size;
#line 9
  __cil_tmp = (*alloc)(len);
#line 9
  ptr = __cil_tmp;
#line 10
  __cil_tmp___0 = memset(ptr, 0, len);
#line 10
  return (__cil_tmp___0);
}
}
#line 13
void *calloc(size_t count , size_t size )  __attribute__((__deprecated__)) ;
#line 13 "syscalls/stdlib/calloc.c"
void *calloc(size_t count , size_t size ) 
{ void *__cil_tmp ;

  {
#line 14
  __cil_tmp = __otter_calloc(count, size, & malloc);
#line 14
  return (__cil_tmp);
}
}
#line 17 "syscalls/stdlib/calloc.c"
void *__otter_multi_gcalloc(size_t count , size_t size ) 
{ void *__cil_tmp ;

  {
#line 18
  __cil_tmp = __otter_calloc(count, size, & __otter_multi_gmalloc);
#line 18
  return (__cil_tmp);
}
}
#line 1 "cil-4sWx9PWr.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-hMJVb2fI.i","")
#line 16 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/multiotter_builtins.h"
void *__otter_multi_grealloc(void *ptr , size_t size ) ;
#line 13 "syscalls/stdlib/realloc.c"
static void *__otter_realloc(void *ptr , size_t size , void *(*alloc)(size_t  ) ,
                             void (*my_free)(void * ) ) 
{ void *__cil_tmp ;
  size_t old_size ;
  size_t __cil_tmp___0 ;
  char *ptr2 ;
  void *__cil_tmp___1 ;

  {
#line 15
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 16
    __cil_tmp = (*alloc)(size);
#line 16
    return (__cil_tmp);
  }
#line 17
  if (size == 0U) {
#line 19
    (*my_free)(ptr);
#line 20
    return ((void *)0);
  }
#line 23
  __cil_tmp___0 = __otter_get_allocated_size(ptr);
#line 23
  old_size = __cil_tmp___0;
#line 24
  __cil_tmp___1 = (*alloc)(size);
#line 24
  ptr2 = (char *)__cil_tmp___1;
#line 25
  size = size > old_size ? old_size : size;
#line 26
  memcpy((void *)ptr2, (void const   *)ptr, size);
#line 27
  (*my_free)(ptr);
#line 29
  return ((void *)ptr2);
}
}
#line 32
void *realloc(void *ptr , size_t size )  __attribute__((__deprecated__)) ;
#line 32 "syscalls/stdlib/realloc.c"
void *realloc(void *ptr , size_t size ) 
{ void *__cil_tmp ;

  {
#line 33
  __cil_tmp = __otter_realloc(ptr, size, & malloc, & free);
#line 33
  return (__cil_tmp);
}
}
#line 36 "syscalls/stdlib/realloc.c"
void *__otter_multi_grealloc(void *ptr , size_t size ) 
{ void *__cil_tmp ;

  {
#line 37
  __cil_tmp = __otter_realloc(ptr, size, & __otter_multi_gmalloc, & __otter_multi_gfree);
#line 37
  return (__cil_tmp);
}
}
#line 1 "cil-U7QHyihp.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-XikxgfsT.i","")
#line 45 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_builtins.h"
extern uintmax_t __SYMBOLIC(void * ) ;
#line 5 "syscalls/signal/kill.c"
int kill(pid_t pid , int sig ) 
{ int __otter_success ;
  int __tmp ;
  int *__cil_tmp ;

  {
#line 7
  __SYMBOLIC((void *)(& __otter_success));
#line 7
  if (! __otter_success) {
#line 7
    __SYMBOLIC((void *)(& __tmp));
#line 7
    __cil_tmp = __errno();
#line 7
    *__cil_tmp = __tmp;
#line 7
    return (-1);
  } else {
#line 9
    return (0);
  }
}
}
#line 1 "cil-fp4SF7kw.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-LkMp4equ.i","")
#line 1 "cil-TWZooz4w.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-7eY2GHZT.i","")
#line 1 "cil-wuMUuzi7.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SlGcty15.i","")
#line 1 "cil-cnRWSZeL.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-r4IH97Fw.i","")
#line 1 "cil-9sPP5TOU.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-9gRmU62u.i","")
#line 126 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
struct __otter_fs_sock_data *__otter_libc_get_sock_data_from_open_file(struct __otter_fs_open_file_table_entry *open_file ) ;
#line 3 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/time.h"
int nanosleep(struct timespec  const  *rqtp , struct timespec *rmtp ) ;
#line 31 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_scheduler.h"
extern void __otter_multi_io_block_array(void **ptrarray , size_t len ) ;
#line 63 "syscalls/sys/select/select.c"
static void *ready_to_read(struct __otter_fs_open_file_table_entry *open_file ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  int __cil_tmp___0 ;
  struct __otter_fs_pipe_data *pipe___0 ;
  struct __otter_fs_pipe_data *__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 64
  if (open_file->type == 576) {
#line 65
    __cil_tmp = __otter_libc_get_sock_data_from_open_file(open_file);
#line 65
    sock = __cil_tmp;
#line 66
    switch (sock->state) {
    case 1: 
#line 69
    if ((unsigned int )*(sock->sock_queue + 0) != (unsigned int )((void *)0)) {
#line 70
      return ((void *)0);
    } else {
#line 73
      return ((void *)sock->sock_queue);
    }
    case 4: 
    case 7: 
    case 8: 
#line 79
    __cil_tmp___0 = __otter_fs_pipe_is_empty(sock->recv_data);
#line 79
    if (__cil_tmp___0) {
#line 83
      return ((void *)(& (sock->recv_data)->whead));
    } else {
#line 80
      return ((void *)0);
    }
    case 0: 
    case 2: 
    case 3: 
    case 5: 
    case 6: 
    case 9: 
    case 10: 
    case 11: 
#line 94
    return ((void *)0);
    }
#line 96
    __ASSERT((_Bool)0);
#line 97
    abort();
  } else
#line 98
  if (open_file->type == 64) {
#line 99
    __cil_tmp___1 = __otter_libc_get_pipe_data_from_open_file(open_file);
#line 99
    pipe___0 = __cil_tmp___1;
#line 100
    __cil_tmp___2 = __otter_fs_pipe_is_empty(pipe___0);
#line 100
    if (__cil_tmp___2) {
#line 105
      return ((void *)(& pipe___0->whead));
    } else {
#line 102
      return ((void *)0);
    }
  } else {
#line 108
    return ((void *)0);
  }
}
}
#line 115 "syscalls/sys/select/select.c"
static void *ready_to_write(struct __otter_fs_open_file_table_entry *open_file ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  int __cil_tmp___0 ;
  struct __otter_fs_pipe_data *pipe___0 ;
  struct __otter_fs_pipe_data *__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 116
  if (open_file->type == 576) {
#line 117
    __cil_tmp = __otter_libc_get_sock_data_from_open_file(open_file);
#line 117
    sock = __cil_tmp;
#line 118
    switch (sock->state) {
    case 4: 
    case 5: 
#line 122
    __cil_tmp___0 = __otter_fs_pipe_is_full((*(sock->sock_queue + 0))->recv_data);
#line 122
    if (__cil_tmp___0) {
#line 126
      return ((void *)(& ((*(sock->sock_queue + 0))->recv_data)->rhead));
    } else {
#line 123
      return ((void *)0);
    }
    case 3: 
#line 131
    return ((void *)0);
    case 0: 
    case 1: 
    case 2: 
    case 6: 
    case 7: 
    case 8: 
    case 9: 
    case 10: 
    case 11: 
#line 142
    return ((void *)0);
    }
#line 144
    __ASSERT((_Bool)0);
#line 145
    abort();
  } else
#line 146
  if (open_file->type == 64) {
#line 147
    __cil_tmp___1 = __otter_libc_get_pipe_data_from_open_file(open_file);
#line 147
    pipe___0 = __cil_tmp___1;
#line 148
    __cil_tmp___2 = __otter_fs_pipe_is_full(pipe___0);
#line 148
    if (__cil_tmp___2) {
#line 150
      return ((void *)(& pipe___0->rhead));
    } else {
#line 152
      return ((void *)0);
    }
  } else {
#line 155
    return ((void *)0);
  }
}
}
#line 161 "syscalls/sys/select/select.c"
static int is_set(int fd , _types_fd_set *fd_set_p ) 
{ 

  {
#line 162
  return (fd_set_p && fd_set_p->fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] & (1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL)));
}
}
#line 188 "syscalls/sys/select/select.c"
static int select_helper(int nfds , _types_fd_set *readfds , _types_fd_set *writefds ,
                         _types_fd_set *errorfds ) 
{ int num_ready_fds ;
  void **watch_list ;
  void *__cil_tmp ;
  size_t watch_list_len ;
  int fd ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  void *ptr ;
  void *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  void *ptr___0 ;
  void *__cil_tmp___7 ;
  int __cil_tmp___8 ;

  {
#line 189
  num_ready_fds = 0;
#line 194
  __cil_tmp = malloc((unsigned int )((sizeof(void *) * (unsigned long )nfds) * 3UL));
#line 194
  watch_list = (void **)__cil_tmp;
#line 195
  watch_list_len = 0U;
#line 197
  fd = 0;
#line 197
  while (fd < nfds) {
#line 198
    __cil_tmp___0 = is_set(fd, readfds);
#line 198
    if (! __cil_tmp___0) {
#line 198
      __cil_tmp___1 = is_set(fd, writefds);
#line 198
      if (! __cil_tmp___1) {
#line 199
        goto __Cont;
      }
    }
#line 201
    __cil_tmp___2 = is_set(fd, errorfds);
#line 201
    if (__cil_tmp___2) {
#line 202
      __EVALSTR("The current implementation of select doesn\'t handle errorfds", 100U);
#line 203
      __ASSERT((_Bool)0);
    }
#line 206
    __cil_tmp___3 = get_open_file_from_fd(fd);
#line 206
    open_file = __cil_tmp___3;
#line 207
    if (! open_file) {
#line 208
      __cil_tmp___4 = __errno();
#line 208
      *__cil_tmp___4 = 9;
#line 209
      free((void *)watch_list);
#line 210
      return (-1);
    }
#line 213
    __cil_tmp___6 = is_set(fd, readfds);
#line 213
    if (__cil_tmp___6) {
#line 213
      __cil_tmp___5 = ready_to_read(open_file);
#line 213
      ptr = __cil_tmp___5;
#line 213
      if (ptr) {
#line 213
        readfds->fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] &= ~ (1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL));
#line 213
        *(watch_list + watch_list_len) = ptr;
#line 213
        watch_list_len ++;
      } else {
#line 213
        num_ready_fds ++;
      }
    }
#line 214
    __cil_tmp___8 = is_set(fd, writefds);
#line 214
    if (__cil_tmp___8) {
#line 214
      __cil_tmp___7 = ready_to_write(open_file);
#line 214
      ptr___0 = __cil_tmp___7;
#line 214
      if (ptr___0) {
#line 214
        writefds->fds_bits[(unsigned long )fd / (sizeof(fd_mask ) * 8UL)] &= ~ (1L << (unsigned long )fd % (sizeof(fd_mask ) * 8UL));
#line 214
        *(watch_list + watch_list_len) = ptr___0;
#line 214
        watch_list_len ++;
      } else {
#line 214
        num_ready_fds ++;
      }
    }
    __Cont: 
#line 197
    fd ++;
  }
#line 219
  if (num_ready_fds) {
#line 220
    free((void *)watch_list);
#line 221
    return (num_ready_fds);
  }
#line 225
  __otter_multi_io_block_array(watch_list, watch_list_len);
#line 226
  __otter_multi_begin_atomic();
#line 227
  free((void *)watch_list);
#line 228
  return (-2);
}
}
#line 232 "syscalls/sys/select/select.c"
static void copy_fd_set(_types_fd_set *dest , _types_fd_set *src ) 
{ 

  {
#line 233
  if (src && dest) {
#line 234
    memcpy((void *)dest, (void const   *)src, (unsigned int )sizeof(_types_fd_set ));
  }
#line 236
  return;
}
}
#line 238 "syscalls/sys/select/select.c"
int select(int nfds , _types_fd_set *readfds , _types_fd_set *writefds , _types_fd_set *errorfds ,
           struct timeval * __restrict  timeout ) 
{ int *__cil_tmp ;
  struct timespec t ;
  _types_fd_set *read_copy ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;
  _types_fd_set *write_copy ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  _types_fd_set *error_copy ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;
  int retval ;

  {
#line 240
  if (nfds < 0 || nfds >= 64) {
#line 241
    __cil_tmp = __errno();
#line 241
    *__cil_tmp = 22;
#line 242
    return (-1);
  }
#line 245
  if (nfds == 0) {
#line 246
    t.tv_sec = timeout->tv_sec;
#line 246
    t.tv_nsec = timeout->tv_usec * 1000L;
#line 247
    nanosleep((struct timespec  const  *)(& t), (struct timespec *)((void *)0));
#line 248
    return (0);
  }
#line 252
  if (readfds) {
#line 252
    __cil_tmp___0 = malloc((unsigned int )sizeof(_types_fd_set ));
#line 252
    __cil_tmp___1 = __cil_tmp___0;
  } else {
#line 252
    __cil_tmp___1 = (void *)0;
  }
#line 252
  read_copy = (_types_fd_set *)__cil_tmp___1;
#line 253
  if (writefds) {
#line 253
    __cil_tmp___2 = malloc((unsigned int )sizeof(_types_fd_set ));
#line 253
    __cil_tmp___3 = __cil_tmp___2;
  } else {
#line 253
    __cil_tmp___3 = (void *)0;
  }
#line 253
  write_copy = (_types_fd_set *)__cil_tmp___3;
#line 254
  if (errorfds) {
#line 254
    __cil_tmp___4 = malloc((unsigned int )sizeof(_types_fd_set ));
#line 254
    __cil_tmp___5 = __cil_tmp___4;
  } else {
#line 254
    __cil_tmp___5 = (void *)0;
  }
#line 254
  error_copy = (_types_fd_set *)__cil_tmp___5;
#line 262
  while (1) {
#line 263
    copy_fd_set(read_copy, readfds);
#line 264
    copy_fd_set(write_copy, writefds);
#line 265
    copy_fd_set(error_copy, errorfds);
#line 266
    __otter_multi_begin_atomic();
#line 267
    retval = select_helper(nfds, read_copy, write_copy, error_copy);
#line 268
    __otter_multi_end_atomic();
#line 262
    if (! (retval == -2)) {
#line 262
      break;
    }
  }
#line 273
  if (retval != -1) {
#line 274
    copy_fd_set(readfds, read_copy);
#line 275
    copy_fd_set(writefds, write_copy);
#line 276
    copy_fd_set(errorfds, error_copy);
  }
#line 279
  free((void *)read_copy);
#line 280
  free((void *)write_copy);
#line 281
  free((void *)error_copy);
#line 282
  return (retval);
}
}
#line 1 "cil-NZPLOvUE.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Cr1Kkq58.i","")
#line 125 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/socket.h"
struct __otter_fs_sock_data *__otter_libc_get_sock_data(int fd ) ;
#line 127
void __otter_libc_flush_sock_queue(struct __otter_fs_sock_data *sock ) ;
#line 129
ssize_t __otter_libc_read_pipe_data(struct __otter_fs_pipe_data *pipe___0 , void *buf ,
                                    size_t num ) ;
#line 133
ssize_t __otter_libc_pread_pipe_data(struct __otter_fs_pipe_data *pipe___0 , void *buf ,
                                     size_t num ) ;
#line 137
ssize_t __otter_libc_write_socket(struct __otter_fs_open_file_table_entry *open_file ,
                                  void *buf , size_t num ) ;
#line 141
int __otter_libc_shutdown_sock_data(struct __otter_fs_sock_data *sock , int how ) ;
#line 16 "syscalls/sys/socket/__otter_socket.c"
unsigned short __otter_sock_free_port  =    (unsigned short)5000;
#line 18 "syscalls/sys/socket/__otter_socket.c"
int socket(int domain , int type , int protocol ) 
{ int fd ;
  struct __otter_fs_inode *inode ;
  struct __otter_fs_inode *__cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 20
  fd = -1;
#line 22
  switch (domain) {
  case 1: 
  case 2: 
  case 3: 
#line 28
  __cil_tmp = __otter_fs_init_new_socket();
#line 28
  inode = __cil_tmp;
#line 30
  if (type == 1) {
#line 32
    ((struct __otter_fs_sock_data *)inode->data)->state = 11;
#line 33
    ((struct __otter_fs_sock_data *)inode->data)->recv_data = __otter_fs_init_new_pipe_data();
  }
#line 36
  fd = __otter_fs_open_file(inode, 3);
#line 38
  if (fd == -1) {
#line 40
    __otter_fs_free_socket(inode);
#line 41
    return (-1);
  }
#line 44
  (((struct __otter_fs_sock_data *)inode->data)->addr)->sa_family = (unsigned short )domain;
#line 46
  break;
  default: 
#line 51
  __cil_tmp___0 = __errno();
#line 51
  *__cil_tmp___0 = 106;
#line 52
  return (-1);
  }
#line 55
  return (fd);
}
}
#line 58 "syscalls/sys/socket/__otter_socket.c"
struct __otter_fs_sock_data *__otter_libc_get_sock_data_from_open_file(struct __otter_fs_open_file_table_entry *open_file ) 
{ 

  {
#line 59
  __ASSERT((_Bool )(open_file->type == 576));
#line 60
  return ((struct __otter_fs_sock_data *)(open_file->inode)->data);
}
}
#line 63 "syscalls/sys/socket/__otter_socket.c"
struct __otter_fs_sock_data *__otter_libc_get_sock_data(int fd ) 
{ struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp ;
  int *__cil_tmp___0 ;
  struct __otter_fs_sock_data *__cil_tmp___1 ;

  {
#line 65
  __cil_tmp = get_open_file_from_fd(fd);
#line 65
  open_file = __cil_tmp;
#line 66
  if (! open_file) {
#line 68
    return ((struct __otter_fs_sock_data *)((void *)0));
  }
#line 71
  if (open_file->type != 576) {
#line 73
    __cil_tmp___0 = __errno();
#line 73
    *__cil_tmp___0 = 108;
#line 74
    return ((struct __otter_fs_sock_data *)((void *)0));
  }
#line 77
  __cil_tmp___1 = __otter_libc_get_sock_data_from_open_file(open_file);
#line 77
  return (__cil_tmp___1);
}
}
#line 80 "syscalls/sys/socket/__otter_socket.c"
int __otter_libc_setsockopt_sol_socket(struct __otter_fs_sock_data *sock , int option_name ,
                                       void const   *option_value , socklen_t option_len ) 
{ int *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 82
  switch (option_name) {
  case 2048: 
  case 1: 
  case 32: 
  case 8: 
  case 128: 
  case 65536: 
#line 91
  if ((unsigned long )option_len < sizeof(int )) {
#line 93
    __cil_tmp = __errno();
#line 93
    *__cil_tmp = 14;
#line 94
    return (-1);
  }
#line 97
  if (*((int *)option_value)) {
#line 99
    sock->options |= option_name;
  } else {
#line 103
    sock->options &= ~ option_name;
  }
#line 105
  return (0);
  case 64: 
#line 110
  if ((unsigned long )option_len < sizeof(struct linger )) {
#line 112
    __cil_tmp___0 = __errno();
#line 112
    *__cil_tmp___0 = 14;
#line 113
    return (-1);
  }
#line 116
  if (((struct linger *)option_value)->l_onoff) {
#line 118
    sock->options |= option_name;
  } else {
#line 122
    sock->options &= ~ option_name;
  }
#line 124
  return (0);
  default: 
#line 137
  __cil_tmp___1 = __errno();
#line 137
  *__cil_tmp___1 = 22;
#line 138
  return (-1);
  }
}
}
#line 142 "syscalls/sys/socket/__otter_socket.c"
int __otter_libc_getsockopt_sol_socket(struct __otter_fs_sock_data *sock , int option_name ,
                                       void const   *option_value , socklen_t option_len ) 
{ int *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 144
  switch (option_name) {
  case 2048: 
  case 1: 
  case 2: 
  case 4: 
  case 32: 
  case 8: 
  case 128: 
  case 65536: 
#line 155
  if ((unsigned long )option_len < sizeof(int )) {
#line 157
    __cil_tmp = __errno();
#line 157
    *__cil_tmp = 14;
#line 158
    return (-1);
  }
#line 161
  *((int *)option_value) = sock->options & option_name ? 1 : 0;
#line 163
  return (0);
  case 256: 
  case 4096: 
#line 167
  if ((unsigned long )option_len < sizeof(int )) {
#line 169
    __cil_tmp___0 = __errno();
#line 169
    *__cil_tmp___0 = 14;
#line 170
    return (-1);
  }
#line 173
  *((int *)option_value) = 1024;
#line 175
  return (0);
  case 16: 
#line 179
  return (0);
  case 64: 
#line 184
  if ((unsigned long )option_len < sizeof(struct linger )) {
#line 186
    __cil_tmp___1 = __errno();
#line 186
    *__cil_tmp___1 = 14;
#line 187
    return (-1);
  }
#line 190
  ((struct linger *)option_value)->l_onoff = sock->options & option_name ? 1 : 0;
#line 191
  ((struct linger *)option_value)->l_linger = 16;
#line 193
  return (0);
  default: 
#line 201
  __cil_tmp___2 = __errno();
#line 201
  *__cil_tmp___2 = 22;
#line 202
  return (-1);
  }
}
}
#line 219 "syscalls/sys/socket/__otter_socket.c"
int __otter_libc_setsockopt_ipproto_tcp(struct __otter_fs_sock_data *sock , int option_name ,
                                        void const   *option_value , socklen_t option_len ) 
{ int *__cil_tmp ;

  {
#line 221
  switch (option_name) {
  case 1: 
#line 224
  return (0);
  default: 
#line 227
  __cil_tmp = __errno();
#line 227
  *__cil_tmp = 22;
#line 228
  return (-1);
  }
}
}
#line 232 "syscalls/sys/socket/__otter_socket.c"
int setsockopt(int socket_fd , int level , int option_name , void const   *option_value ,
               socklen_t option_len ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 234
  __cil_tmp = __otter_libc_get_sock_data(socket_fd);
#line 234
  sock = __cil_tmp;
#line 235
  if (! sock) {
#line 237
    return (-1);
  }
#line 240
  switch (level) {
  case -1: 
#line 243
  __cil_tmp___0 = __otter_libc_setsockopt_sol_socket(sock, option_name, option_value,
                                                     option_len);
#line 243
  return (__cil_tmp___0);
  case 3: 
#line 245
  __cil_tmp___1 = __otter_libc_setsockopt_ipproto_tcp(sock, option_name, option_value,
                                                      option_len);
#line 245
  return (__cil_tmp___1);
  default: 
#line 251
  __cil_tmp___2 = __errno();
#line 251
  *__cil_tmp___2 = 22;
#line 252
  return (-1);
  }
#line 255
  return (-1);
}
}
#line 284 "syscalls/sys/socket/__otter_socket.c"
int bind(int socket_fd , struct sockaddr  const  *address , socklen_t address_len ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int l ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  struct sockaddr_in *a ;
  struct sockaddr_in6 *a___0 ;
  int *__cil_tmp___5 ;
  int addr_used ;
  int i ;
  struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_sock_data *other ;
  struct __otter_fs_sock_data *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int *__cil_tmp___8 ;

  {
#line 286
  __cil_tmp = __otter_libc_get_sock_data(socket_fd);
#line 286
  sock = __cil_tmp;
#line 287
  if (! sock) {
#line 289
    return (-1);
  }
#line 292
  if ((unsigned int )address == (unsigned int )((void *)0)) {
#line 294
    __cil_tmp___0 = __errno();
#line 294
    *__cil_tmp___0 = 14;
#line 295
    return (-1);
  }
#line 298
  if ((int )(sock->addr)->sa_family != (int )address->sa_family) {
#line 300
    __cil_tmp___1 = __errno();
#line 300
    *__cil_tmp___1 = 106;
#line 301
    return (-1);
  }
#line 304
  l = 0;
#line 305
  __otter_libc_getsockopt_sol_socket(sock, 65536, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 306
  if (l != 0) {
#line 308
    __cil_tmp___2 = __errno();
#line 308
    *__cil_tmp___2 = 22;
#line 309
    return (-1);
  }
#line 313
  switch (sock->state) {
  case 0: 
#line 316
  break;
  case 1: 
  case 2: 
  case 3: 
#line 320
  __cil_tmp___3 = __errno();
#line 320
  *__cil_tmp___3 = 22;
#line 321
  return (-1);
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
  case 10: 
#line 329
  __cil_tmp___4 = __errno();
#line 329
  *__cil_tmp___4 = 127;
#line 330
  return (-1);
  case 11: 
#line 332
  break;
  default: 
#line 334
  __ASSERT((_Bool)0);
  }
#line 337
  memcpy((void *)sock->addr, (void const   *)address, address_len);
#line 340
  switch ((int )(sock->addr)->sa_family) {
  case 1: 
#line 343
  break;
  case 2: 
#line 346
  a = (struct sockaddr_in *)sock->addr;
#line 348
  if (a->sin_addr.s_addr == 0U) {
#line 350
    a->sin_addr.s_addr = 16777343U;
  }
#line 353
  if ((int )a->sin_port == 0) {
#line 355
    a->sin_port = __otter_sock_free_port;
#line 356
    __otter_sock_free_port = (unsigned short )((int )__otter_sock_free_port + 1);
  } else
#line 358
  if ((int )a->sin_port >= (int )__otter_sock_free_port) {
#line 360
    __otter_sock_free_port = (unsigned short )((int )a->sin_port + 1);
  }
#line 363
  break;
  case 3: 
#line 366
  a___0 = (struct sockaddr_in6 *)sock->addr;
#line 368
  if (((a___0->sin6_addr.in6_u.u6_addr32[0] == 0U && a___0->sin6_addr.in6_u.u6_addr32[1] == 0U) && a___0->sin6_addr.in6_u.u6_addr32[2] == 0U) && a___0->sin6_addr.in6_u.u6_addr32[3] == 0U) {

  }
#line 373
  if ((int )a___0->sin6_port == 0) {
#line 375
    a___0->sin6_port = __otter_sock_free_port;
#line 376
    __otter_sock_free_port = (unsigned short )((int )__otter_sock_free_port + 1);
  } else
#line 378
  if ((int )a___0->sin6_port >= (int )__otter_sock_free_port) {
#line 380
    __otter_sock_free_port = (unsigned short )((int )a___0->sin6_port + 1);
  }
#line 383
  break;
  default: 
#line 386
  __cil_tmp___5 = __errno();
#line 386
  *__cil_tmp___5 = 106;
#line 387
  return (-1);
  }
#line 391
  addr_used = 0;
#line 393
  __otter_multi_begin_atomic();
#line 394
  i = 0;
#line 394
  while (i < 128) {
#line 397
    open_file = __otter_fs_open_file_table + i;
#line 398
    if (open_file->openno == 0 || open_file->type != 576) {
#line 399
      goto __Cont;
    }
#line 401
    __cil_tmp___6 = __otter_libc_get_sock_data_from_open_file(open_file);
#line 401
    other = __cil_tmp___6;
#line 402
    if ((unsigned int )other == (unsigned int )((void *)0)) {
#line 404
      goto __Cont;
    }
#line 407
    __otter_libc_getsockopt_sol_socket(other, 65536, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 408
    if (! l) {
#line 410
      goto __Cont;
    }
#line 413
    __cil_tmp___7 = memcmp((void const   *)other->addr, (void const   *)sock->addr,
                           address_len);
#line 413
    if (__cil_tmp___7 == 0) {
#line 415
      __otter_libc_getsockopt_sol_socket(other, 2048, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 416
      if (! l) {
#line 418
        addr_used = 1;
#line 419
        break;
      }
#line 421
      __otter_libc_getsockopt_sol_socket(sock, 2048, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 422
      if (! l) {
#line 424
        addr_used = 1;
#line 425
        break;
      }
    }
    __Cont: 
#line 394
    i ++;
  }
#line 429
  __otter_multi_end_atomic();
#line 431
  if (addr_used) {
#line 433
    __cil_tmp___8 = __errno();
#line 433
    *__cil_tmp___8 = 112;
#line 434
    return (-1);
  }
#line 437
  l = 1;
#line 438
  __otter_libc_setsockopt_sol_socket(sock, 65536, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 440
  return (0);
}
}
#line 443 "syscalls/sys/socket/__otter_socket.c"
int listen(int socket_fd , int backlog ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  int l ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  void *__cil_tmp___3 ;

  {
#line 445
  __cil_tmp = __otter_libc_get_sock_data(socket_fd);
#line 445
  sock = __cil_tmp;
#line 446
  if (! sock) {
#line 448
    return (-1);
  }
#line 451
  if (backlog < 0) {
#line 453
    backlog = 0;
  }
#line 456
  l = 0;
#line 457
  __otter_libc_getsockopt_sol_socket(sock, 65536, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 458
  if (l != 1) {
#line 460
    __cil_tmp___0 = __errno();
#line 460
    *__cil_tmp___0 = 121;
#line 461
    return (-1);
  }
#line 465
  switch (sock->state) {
  case 0: 
#line 468
  break;
  case 1: 
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
  case 10: 
#line 479
  __cil_tmp___1 = __errno();
#line 479
  *__cil_tmp___1 = 22;
#line 480
  return (-1);
  case 11: 
#line 482
  __cil_tmp___2 = __errno();
#line 482
  *__cil_tmp___2 = 95;
#line 483
  return (-1);
  default: 
#line 485
  __ASSERT((_Bool)0);
  }
#line 488
  __cil_tmp___3 = __otter_multi_gcalloc((unsigned int )(backlog + 1), (unsigned int )sizeof(struct __otter_fs_sock_data *));
#line 488
  sock->sock_queue = (struct __otter_fs_sock_data **)__cil_tmp___3;
#line 489
  sock->backlog = backlog;
#line 490
  sock->state = 1;
#line 491
  l = 1;
#line 492
  __otter_libc_setsockopt_sol_socket(sock, 1, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 494
  return (0);
}
}
#line 498 "syscalls/sys/socket/__otter_socket.c"
void __otter_sock_pop_queue(struct __otter_fd_sock_data **q , int len ) 
{ int i ;

  {
#line 500
  i = 0;
#line 500
  while (i < len - 1) {
#line 502
    *(q + i) = *(q + (i + 1));
#line 500
    i ++;
  }
#line 505
  *(q + (len - 1)) = (struct __otter_fd_sock_data *)((void *)0);
#line 506
  return;
}
}
#line 508 "syscalls/sys/socket/__otter_socket.c"
int accept(int socket_fd , struct sockaddr *address , socklen_t *address_len ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  struct __otter_fs_sock_data *sock_other ;
  int fd ;
  int __cil_tmp___3 ;
  struct __otter_fs_sock_data *sock2 ;
  struct __otter_fs_sock_data *__cil_tmp___4 ;
  int l ;
  void *__cil_tmp___5 ;

  {
#line 510
  __cil_tmp = __otter_libc_get_sock_data(socket_fd);
#line 510
  sock = __cil_tmp;
#line 511
  if (! sock) {
#line 513
    return (-1);
  }
#line 517
  switch (sock->state) {
  case 0: 
#line 520
  __cil_tmp___0 = __errno();
#line 520
  *__cil_tmp___0 = 22;
#line 521
  return (-1);
  case 1: 
#line 523
  break;
  case 2: 
  case 3: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
  case 10: 
#line 533
  __cil_tmp___1 = __errno();
#line 533
  *__cil_tmp___1 = 22;
#line 534
  return (-1);
  case 11: 
#line 536
  __cil_tmp___2 = __errno();
#line 536
  *__cil_tmp___2 = 95;
#line 537
  return (-1);
  default: 
#line 539
  __ASSERT((_Bool)0);
  }
#line 543
  __otter_multi_begin_atomic();
#line 544
  while (sock->state == 1) {
#line 546
    if (*(sock->sock_queue + 0)) {
#line 549
      sock_other = *(sock->sock_queue + 0);
#line 550
      if (sock_other->state != 3) {
#line 552
        __otter_sock_pop_queue((struct __otter_fd_sock_data **)sock->sock_queue, sock->backlog + 1);
#line 553
        break;
      }
#line 555
      __cil_tmp___3 = socket((int )(sock->addr)->sa_family, 2, 0);
#line 555
      fd = __cil_tmp___3;
#line 556
      if (fd == -1) {
#line 558
        __otter_sock_pop_queue((struct __otter_fd_sock_data **)sock->sock_queue, sock->backlog + 1);
#line 559
        sock_other->state = 0;
#line 560
        __otter_multi_end_atomic();
#line 561
        return (-1);
      }
#line 564
      __cil_tmp___4 = __otter_libc_get_sock_data(fd);
#line 564
      sock2 = __cil_tmp___4;
#line 565
      sock2->state = 4;
#line 566
      memcpy((void *)sock2->addr, (void const   *)sock->addr, 16U);
#line 567
      sock2->options = sock->options;
#line 568
      l = 0;
#line 569
      __otter_libc_setsockopt_sol_socket(sock2, 1, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 570
      __cil_tmp___5 = __otter_multi_gcalloc(1U, (unsigned int )sizeof(struct __otter_fs_sock_data *));
#line 570
      sock2->sock_queue = (struct __otter_fs_sock_data **)__cil_tmp___5;
#line 571
      *(sock2->sock_queue + 0) = sock_other;
#line 572
      sock2->recv_data = __otter_fs_init_new_pipe_data();
#line 573
      __otter_sock_pop_queue((struct __otter_fd_sock_data **)sock->sock_queue, sock->backlog + 1);
#line 574
      *(sock_other->sock_queue + 0) = sock2;
#line 575
      sock_other->state = 4;
#line 577
      if (address) {
#line 579
        memcpy((void *)address, (void const   *)sock_other->addr, 16U);
#line 580
        *address_len = 16U;
      }
#line 583
      __otter_multi_end_atomic();
#line 584
      return (fd);
    } else {
#line 588
      __otter_multi_io_block((void *)sock, sock->sock_queue);
    }
#line 590
    __otter_multi_begin_atomic();
  }
#line 592
  __otter_multi_end_atomic();
#line 594
  return (-1);
}
}
#line 597 "syscalls/sys/socket/__otter_socket.c"
void __otter_libc_flush_sock_queue(struct __otter_fs_sock_data *sock ) 
{ int i ;

  {
#line 599
  i = 0;
#line 599
  while (i < sock->backlog + 1) {
#line 601
    if ((unsigned int )*(sock->sock_queue + i) != (unsigned int )((void *)0)) {
#line 603
      (*(sock->sock_queue + i))->state = 0;
#line 604
      __otter_multi_gfree((void *)(*(sock->sock_queue + i))->sock_queue);
#line 605
      (*(sock->sock_queue + i))->sock_queue = (struct __otter_fs_sock_data **)((void *)0);
    }
#line 599
    i ++;
  }
#line 608
  return;
}
}
#line 610 "syscalls/sys/socket/__otter_socket.c"
int connect(int socket_fd , struct sockaddr  const  *address , socklen_t address_len ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  int *__cil_tmp___0 ;
  int l ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int q_size ;
  struct __otter_fs_sock_data *best_sock ;
  int i ;
  struct __otter_fs_open_file_table_entry *open_file___0 ;
  struct __otter_fs_sock_data *recv___0 ;
  struct __otter_fs_sock_data *__cil_tmp___8 ;
  int q2 ;
  int j ;
  int __cil_tmp___9 ;
  int *__cil_tmp___10 ;
  void *__cil_tmp___11 ;
  int i___0 ;
  struct __otter_fs_open_file_table_entry *open_file___1 ;
  struct __otter_fs_open_file_table_entry *__cil_tmp___12 ;
  int *__cil_tmp___13 ;
  int *__cil_tmp___14 ;
  int *__cil_tmp___15 ;

  {
#line 612
  __cil_tmp = __otter_libc_get_sock_data(socket_fd);
#line 612
  sock = __cil_tmp;
#line 613
  if (! sock) {
#line 615
    return (-1);
  }
#line 619
  if ((unsigned int )address == (unsigned int )((void *)0)) {
#line 621
    __cil_tmp___0 = __errno();
#line 621
    *__cil_tmp___0 = 14;
#line 622
    return (-1);
  }
#line 626
  l = 0;
#line 627
  __otter_libc_getsockopt_sol_socket(sock, 65536, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 628
  if (l != 1) {
#line 630
    switch ((int )(sock->addr)->sa_family) {
    case 1: 
#line 633
    break;
    case 2: 
    case 3: 
#line 636
    __cil_tmp___2 = bind(socket_fd, (struct sockaddr  const  *)sock->addr, address_len);
#line 636
    if (__cil_tmp___2 == -1) {
#line 638
      __cil_tmp___1 = __errno();
#line 638
      *__cil_tmp___1 = 125;
#line 639
      return (-1);
    }
#line 641
    break;
    default: 
#line 644
    __cil_tmp___3 = __errno();
#line 644
    *__cil_tmp___3 = 106;
#line 645
    return (-1);
    }
  }
#line 650
  switch (sock->state) {
  case 0: 
#line 653
  break;
  case 1: 
#line 656
  l = 0;
#line 657
  __otter_libc_setsockopt_sol_socket(sock, 1, (void const   *)(& l), (unsigned int )sizeof(int ));
#line 660
  __otter_libc_flush_sock_queue(sock);
#line 662
  __otter_multi_gfree((void *)sock->sock_queue);
#line 663
  sock->sock_queue = (struct __otter_fs_sock_data **)((void *)0);
#line 665
  break;
  case 3: 
#line 668
  __cil_tmp___4 = get_open_file_from_fd(socket_fd);
#line 668
  open_file = __cil_tmp___4;
#line 669
  if (open_file->mode & 128) {
#line 671
    __cil_tmp___5 = __errno();
#line 671
    *__cil_tmp___5 = 120;
#line 672
    return (-1);
  }
  case 2: 
  case 4: 
  case 5: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
  case 10: 
#line 684
  __cil_tmp___6 = __errno();
#line 684
  *__cil_tmp___6 = 22;
#line 685
  return (-1);
  case 11: 
#line 687
  __cil_tmp___7 = __errno();
#line 687
  *__cil_tmp___7 = 95;
#line 688
  return (-1);
  default: 
#line 690
  __ASSERT((_Bool)0);
  }
#line 693
  __otter_multi_begin_atomic();
#line 694
  q_size = 0;
#line 695
  best_sock = (struct __otter_fs_sock_data *)((void *)0);
#line 696
  i = 0;
#line 696
  while (i < 128) {
#line 699
    open_file___0 = __otter_fs_open_file_table + i;
#line 700
    if (open_file___0->openno == 0 || open_file___0->type != 576) {
#line 701
      goto __Cont;
    }
#line 702
    __cil_tmp___8 = __otter_libc_get_sock_data_from_open_file(open_file___0);
#line 702
    recv___0 = __cil_tmp___8;
#line 703
    if (recv___0->state != 1) {
#line 704
      goto __Cont;
    }
#line 707
    __cil_tmp___9 = memcmp((void const   *)recv___0->addr, (void const   *)address,
                           16U);
#line 707
    if (__cil_tmp___9 == 0) {
#line 709
      q2 = 0;
#line 710
      j = 0;
#line 710
      while (i < recv___0->backlog + 1) {
#line 712
        if ((unsigned int )*(recv___0->sock_queue + j) != (unsigned int )((void *)0)) {
#line 713
          q2 ++;
        } else {
#line 715
          break;
        }
#line 710
        j ++;
      }
#line 719
      if ((unsigned int )best_sock == (unsigned int )((void *)0) || q_size > q2) {
#line 721
        q_size = q2;
#line 722
        best_sock = recv___0;
      }
    }
    __Cont: 
#line 696
    i ++;
  }
#line 727
  if ((unsigned int )best_sock == (unsigned int )((void *)0)) {
#line 729
    __cil_tmp___10 = __errno();
#line 729
    *__cil_tmp___10 = 111;
#line 730
    __otter_multi_end_atomic();
#line 731
    return (-1);
  }
#line 734
  sock->state = 3;
#line 735
  __cil_tmp___11 = __otter_multi_gcalloc(1U, (unsigned int )sizeof(struct __otter_fs_sock_data *));
#line 735
  sock->sock_queue = (struct __otter_fs_sock_data **)__cil_tmp___11;
#line 736
  sock->recv_data = __otter_fs_init_new_pipe_data();
#line 737
  *(sock->sock_queue + 0) = best_sock;
#line 739
  i___0 = 0;
#line 739
  while (i___0 < best_sock->backlog + 1) {
#line 741
    if ((unsigned int )*(best_sock->sock_queue + i___0) == (unsigned int )((void *)0)) {
#line 743
      *(best_sock->sock_queue + i___0) = sock;
#line 744
      __otter_multi_end_atomic();
#line 746
      __cil_tmp___12 = get_open_file_from_fd(socket_fd);
#line 746
      open_file___1 = __cil_tmp___12;
#line 747
      if (sock->state == 3 && open_file___1->mode & 128) {
#line 749
        __cil_tmp___13 = __errno();
#line 749
        *__cil_tmp___13 = 119;
#line 750
        return (-1);
      }
#line 753
      __otter_multi_begin_atomic();
#line 753
      while (sock->state == 3) {
#line 753
        __otter_multi_io_block((void *)sock);
#line 753
        __otter_multi_begin_atomic();
      }
#line 753
      __otter_multi_end_atomic();
#line 755
      if (sock->state == 4) {
#line 757
        return (0);
      } else {
#line 761
        __cil_tmp___14 = __errno();
#line 761
        *__cil_tmp___14 = 111;
#line 762
        return (-1);
      }
    }
#line 739
    i___0 ++;
  }
#line 767
  __otter_multi_end_atomic();
#line 768
  __cil_tmp___15 = __errno();
#line 768
  *__cil_tmp___15 = 111;
#line 769
  return (-1);
}
}
#line 772 "syscalls/sys/socket/__otter_socket.c"
int __otter_libc_shutdown_sock_data(struct __otter_fs_sock_data *sock , int how ) 
{ int *__cil_tmp ;
  struct __otter_fs_sock_data *other ;
  int *__cil_tmp___0 ;
  struct __otter_fs_sock_data *other___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  struct __otter_fs_sock_data *other___1 ;
  int *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;

  {
#line 775
  switch (sock->state) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
#line 781
  __cil_tmp = __errno();
#line 781
  *__cil_tmp = 128;
#line 782
  return (-1);
  case 4: 
#line 785
  other = *(sock->sock_queue + 0);
#line 786
  switch (how) {
  case 1: 
#line 789
  other->state = 7;
#line 790
  sock->state = 5;
#line 791
  other->state = 8;
#line 792
  return (0);
  case 2: 
#line 794
  sock->state = 7;
#line 795
  other->state = 5;
#line 796
  sock->state = 8;
#line 797
  return (0);
  case 4: 
#line 799
  sock->state = 7;
#line 800
  other->state = 7;
#line 801
  sock->state = 9;
#line 802
  other->state = 9;
#line 803
  sock->state = 10;
#line 804
  other->state = 10;
#line 805
  sock->state = 0;
#line 806
  other->state = 0;
#line 807
  *(sock->sock_queue + 0) = (struct __otter_fs_sock_data *)((void *)0);
#line 808
  *(other->sock_queue + 0) = (struct __otter_fs_sock_data *)((void *)0);
#line 809
  return (0);
  default: 
#line 811
  __cil_tmp___0 = __errno();
#line 811
  *__cil_tmp___0 = 22;
#line 812
  return (-1);
  }
#line 815
  break;
  case 5: 
#line 818
  other___0 = *(sock->sock_queue + 0);
#line 819
  switch (how) {
  case 1: 
#line 822
  return (0);
  case 2: 
  case 4: 
#line 825
  sock->state = 6;
#line 826
  other___0->state = 10;
#line 827
  sock->state = 0;
#line 828
  other___0->state = 0;
#line 829
  *(sock->sock_queue + 0) = (struct __otter_fs_sock_data *)((void *)0);
#line 830
  *(other___0->sock_queue + 0) = (struct __otter_fs_sock_data *)((void *)0);
#line 831
  return (0);
  default: 
#line 833
  __cil_tmp___1 = __errno();
#line 833
  *__cil_tmp___1 = 22;
#line 834
  return (-1);
  }
#line 837
  break;
  case 6: 
#line 839
  __cil_tmp___2 = __errno();
#line 839
  *__cil_tmp___2 = 128;
#line 840
  return (-1);
  case 7: 
  case 8: 
#line 844
  other___1 = *(sock->sock_queue + 0);
#line 845
  switch (how) {
  case 2: 
#line 848
  return (0);
  case 1: 
  case 4: 
#line 851
  other___1->state = 6;
#line 852
  sock->state = 10;
#line 853
  sock->state = 0;
#line 854
  other___1->state = 0;
#line 855
  *(sock->sock_queue + 0) = (struct __otter_fs_sock_data *)((void *)0);
#line 856
  *(other___1->sock_queue + 0) = (struct __otter_fs_sock_data *)((void *)0);
#line 857
  return (0);
  default: 
#line 859
  __cil_tmp___3 = __errno();
#line 859
  *__cil_tmp___3 = 22;
#line 860
  return (-1);
  }
#line 863
  break;
  case 9: 
  case 10: 
#line 866
  __cil_tmp___4 = __errno();
#line 866
  *__cil_tmp___4 = 128;
#line 867
  return (-1);
  case 11: 
#line 869
  __cil_tmp___5 = __errno();
#line 869
  *__cil_tmp___5 = 95;
#line 870
  return (-1);
  default: 
#line 872
  __ASSERT((_Bool)0);
  }
#line 875
  __ASSERT((_Bool)0);
#line 876
  return (-1);
}
}
#line 953
int __otter_libc_recv_socket(struct __otter_fs_open_file_table_entry *open_file ,
                             void *buf , size_t num , int flags ) ;
#line 956 "syscalls/sys/socket/__otter_socket.c"
int __otter_libc_recv_socket(struct __otter_fs_open_file_table_entry *open_file ,
                             void *buf , size_t num , int flags ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  ssize_t __cil_tmp___4 ;
  ssize_t __cil_tmp___5 ;

  {
#line 958
  __cil_tmp = __otter_libc_get_sock_data_from_open_file(open_file);
#line 958
  sock = __cil_tmp;
#line 959
  if (! sock) {
#line 961
    return (-1);
  }
#line 964
  switch (sock->state) {
  case 0: 
#line 967
  return (0);
  case 1: 
  case 2: 
  case 3: 
  case 5: 
  case 6: 
  case 9: 
  case 10: 
  case 11: 
#line 977
  __cil_tmp___0 = __errno();
#line 977
  *__cil_tmp___0 = 128;
#line 978
  return (-1);
#line 979
  break;
  case 4: 
  case 7: 
  case 8: 
#line 986
  __cil_tmp___3 = __otter_fs_pipe_is_empty(sock->recv_data);
#line 986
  if (__cil_tmp___3) {
#line 988
    if (open_file->mode & 128) {
#line 990
      __cil_tmp___1 = __errno();
#line 990
      *__cil_tmp___1 = 11;
#line 991
      return (-1);
    }
#line 994
    __otter_multi_begin_atomic();
#line 994
    while (1) {
#line 994
      __cil_tmp___2 = __otter_fs_pipe_is_empty(sock->recv_data);
#line 994
      if (! (__cil_tmp___2 && ((sock->state == 4 || sock->state == 7) || sock->state == 8))) {
#line 994
        break;
      }
#line 994
      __otter_multi_io_block((void *)sock->recv_data, sock);
#line 994
      __otter_multi_begin_atomic();
    }
#line 994
    __otter_multi_end_atomic();
#line 1006
    switch (sock->state) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    case 5: 
    case 6: 
    case 9: 
    case 10: 
    case 11: 
#line 1017
    return (0);
    case 4: 
    case 7: 
    case 8: 
#line 1022
    break;
    }
  }
#line 1029
  if (flags & 16) {
#line 1030
    __cil_tmp___4 = __otter_libc_pread_pipe_data(sock->recv_data, buf, num);
#line 1030
    return (__cil_tmp___4);
  } else {
#line 1032
    __cil_tmp___5 = __otter_libc_read_pipe_data(sock->recv_data, buf, num);
#line 1032
    return (__cil_tmp___5);
  }
  }
#line 1036
  __ASSERT((_Bool)0);
#line 1037
  abort();
}
}
#line 1 "cil-fkWEjxfm.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-79BCMuDh.i","")
#line 101 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/otter_fs.h"
int __otter_libc_inode_stat(struct __otter_fs_inode *inode , struct stat *s ) ;
#line 102
int __otter_libc_dnode_stat(struct __otter_fs_dnode *dnode , struct stat *s ) ;
#line 50 "syscalls/sys/stat/__otter_stat.c"
mode_t __otter_fs_type_to_mode(int type ) 
{ 

  {
#line 52
  switch (type) {
  case 0: 
#line 54
  return (524288U);
  case 1: 
#line 55
  return (1048576U);
  case 64: 
#line 56
  return (262144U);
  case 192: 
#line 57
  return (131072U);
  case 320: 
#line 58
  return (131072U);
  case 576: 
#line 59
  return (4194304U);
  default: 
#line 60
  return (0U);
  }
#line 63
  return (0U);
}
}
#line 66 "syscalls/sys/stat/__otter_stat.c"
int __otter_libc_inode_stat(struct __otter_fs_inode *inode , struct stat *s ) 
{ mode_t __cil_tmp ;

  {
#line 68
  s->st_dev = (short)0;
#line 69
  s->st_ino = (unsigned short )((int )inode);
#line 70
  __cil_tmp = __otter_fs_type_to_mode(inode->type);
#line 70
  s->st_mode = (unsigned int )inode->permissions | __cil_tmp;
#line 71
  s->st_nlink = (unsigned short )inode->linkno;
#line 72
  s->st_uid = (unsigned short )((inode->permissions & 8192) >> 13);
#line 73
  s->st_gid = (unsigned short )((inode->permissions & 4096) >> 12);
#line 74
  switch (inode->type) {
  case 192: 
  case 320: 
#line 78
  s->st_rdev = (short )inode->type;
#line 79
  break;
  default: 
#line 81
  s->st_rdev = (short)0;
#line 82
  break;
  }
#line 84
  s->st_size = (long )inode->size;
#line 85
  s->st_blksize = 256;
#line 86
  s->st_blocks = inode->numblocks;
#line 88
  return (0);
}
}
#line 91 "syscalls/sys/stat/__otter_stat.c"
int __otter_libc_dnode_stat(struct __otter_fs_dnode *dnode , struct stat *s ) 
{ 

  {
#line 93
  s->st_dev = (short)0;
#line 94
  s->st_ino = (unsigned short )((int )dnode);
#line 95
  s->st_mode = (unsigned int )(dnode->permissions | 1048576);
#line 96
  s->st_nlink = (unsigned short )dnode->linkno;
#line 97
  s->st_uid = (unsigned short )((dnode->permissions & 8192) >> 13);
#line 98
  s->st_gid = (unsigned short )((dnode->permissions & 4096) >> 12);
#line 99
  s->st_rdev = (short)0;
#line 100
  s->st_size = (long )(dnode->numfiles + dnode->numdirs);
#line 101
  s->st_blksize = 256;
#line 102
  s->st_blocks = (dnode->numfiles + dnode->numdirs) / 256 + 1;
#line 104
  return (0);
}
}
#line 107 "syscalls/sys/stat/__otter_stat.c"
int __otter_libc_fstat(int fd , struct stat *s ) 
{ struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp ;
  struct __otter_fs_dnode *dnode ;
  int __cil_tmp___0 ;
  struct __otter_fs_inode *inode ;
  int __cil_tmp___1 ;

  {
#line 109
  __cil_tmp = get_open_file_from_fd(fd);
#line 109
  open_file = __cil_tmp;
#line 110
  if (! open_file) {
#line 110
    return (-1);
  }
#line 112
  if (open_file->type == 1) {
#line 114
    dnode = open_file->dnode;
#line 115
    __cil_tmp___0 = __otter_libc_dnode_stat(dnode, s);
#line 115
    return (__cil_tmp___0);
  } else {
#line 119
    inode = open_file->inode;
#line 120
    __cil_tmp___1 = __otter_libc_inode_stat(inode, s);
#line 120
    return (__cil_tmp___1);
  }
}
}
#line 1 "cil-RDBJO6e0.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-dssgQ3Dn.i","")
#line 5 "syscalls/sys/stat/fstat.c"
int fstat(int fildes , struct stat *buf ) 
{ int __cil_tmp ;

  {
#line 6
  __cil_tmp = __otter_libc_fstat(fildes, buf);
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-53r13Swy.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-OIgvz0MZ.i","")
#line 1 "cil-YEj9wq1t.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-4db7YLJq.i","")
#line 8 "syscalls/sys/time/gettimeofday.c"
static unsigned long long __otter_syscalls_current_time  ;
#line 6 "syscalls/sys/time/gettimeofday.c"
static unsigned long long __otter_syscalls_get_current_time(void) 
{ unsigned long long __cil_tmp ;

  {
#line 16
  __cil_tmp = __otter_syscalls_current_time;
#line 16
  __otter_syscalls_current_time ++;
#line 16
  return (__cil_tmp);
}
}
#line 20 "syscalls/sys/time/gettimeofday.c"
int gettimeofday(struct timeval *tv , void *tzp ) 
{ unsigned long long now ;
  unsigned long long __cil_tmp ;

  {
#line 22
  __ASSERT((_Bool )((unsigned int )tzp == (unsigned int )((void *)0)));
#line 23
  __cil_tmp = __otter_syscalls_get_current_time();
#line 23
  now = __cil_tmp;
#line 24
  tv->tv_sec = (long )(now >> 30);
#line 25
  tv->tv_usec = (long )(now & (unsigned long long )((1 << 30) - 1));
#line 33
  return (0);
}
}
#line 1 "cil-VJJsuQl0.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-uEeElAUF.i","")
#line 1 "cil-ksRlOFCs.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-zYtFqyqS.i","")
#line 1 "cil-F7e1AIe5.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-5F4cARTd.i","")
#line 202 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/sys/syslog.h"
void vsyslog(int pri , char const   *fmt , va_list ap ) ;
#line 123 "syscalls/syslog/syslog.c"
void openlog(char const   *ident , int logstat , int logfac ) 
{ 

  {
#line 126
  return;
}
}
#line 132 "syscalls/syslog/syslog.c"
void vsyslog(int pri , char const   *fmt , va_list ap ) 
{ 

  {
#line 135
  return;
}
}
#line 137 "syscalls/syslog/syslog.c"
void syslog(int pri , char const   *fmt  , ...) 
{ va_list ap ;

  {
#line 141
  __builtin_va_start(ap, fmt);
#line 142
  vsyslog(pri, fmt, ap);
#line 143
  __builtin_va_end(ap);
#line 144
  return;
}
}
#line 1 "cil-Dn8t5I1U.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-DFFI9elB.i","")
#line 1 "cil-dJsJNBr8.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-89ke5a2X.i","")
#line 1 "cil-auKkAuCx.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-MGj0pseS.i","")
#line 5 "syscalls/time/nanosleep.c"
int nanosleep(struct timespec  const  *rqtp , struct timespec *rmtp ) 
{ int *__cil_tmp ;
  time_t __cil_tmp___0 ;

  {
#line 7
  if ((rqtp->tv_sec < 0L || rqtp->tv_nsec < 0L) || rqtp->tv_nsec >= 1000000000L) {
#line 9
    __cil_tmp = __errno();
#line 9
    *__cil_tmp = 22;
#line 10
    return (-1);
  }
#line 13
  while (1) {
#line 13
    __cil_tmp___0 = (long )rqtp->tv_sec;
#line 13
    (rqtp->tv_sec) --;
#line 13
    if (! __cil_tmp___0) {
#line 13
      break;
    }
#line 14
    __otter_multi_time_wait((unsigned int )(1 << 30));
  }
#line 16
  __otter_multi_time_wait((unsigned int )rqtp->tv_nsec);
#line 21
  return (0);
}
}
#line 1 "cil-Cq8mEJYg.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SXtqVQ19.i","")
#line 96 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
pid_t getppid(void) ;
#line 11 "/Users/elnatan/Documents/workspace/clean-symexe/newlib-1.19.0/otter/include/otter/multiotter_builtins.h"
extern void __otter_multi_set_parent_pid(pid_t pid ) ;
#line 12
extern pid_t __otter_multi_get_parent_pid(pid_t pid ) ;
#line 15 "syscalls/unistd/__otter_unistd.c"
int __otter_libc_close(int fd ) 
{ struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp ;
  struct __otter_fs_dnode *dnode ;
  struct __otter_fs_inode *inode ;
  struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp___0 ;
  struct linger l ;
  int __cil_tmp___1 ;
  int found ;
  int i ;

  {
#line 17
  __cil_tmp = get_open_file_from_fd(fd);
#line 17
  open_file = __cil_tmp;
#line 18
  if (! open_file) {
#line 18
    return (-1);
  }
#line 20
  __otter_multi_begin_atomic();
#line 21
  *(__otter_fs_fd_table + fd) = -1;
#line 23
  (open_file->openno) --;
#line 25
  if (open_file->type == 1) {
#line 27
    dnode = open_file->dnode;
#line 28
    (dnode->r_openno) --;
#line 30
    if (dnode->linkno == 0 && dnode->r_openno == 0) {
#line 32
      free((void *)dnode->dirs);
#line 33
      free((void *)dnode->files);
#line 34
      free((void *)dnode);
    }
#line 37
    __otter_multi_end_atomic();
#line 38
    return (0);
  }
#line 41
  if (open_file->openno == 0) {
#line 43
    inode = open_file->inode;
#line 44
    if (open_file->mode & 1) {
#line 45
      (inode->r_openno) --;
    }
#line 46
    if (open_file->mode & 2) {
#line 47
      (inode->w_openno) --;
    }
#line 49
    if (inode->r_openno || inode->w_openno) {
#line 51
      __otter_multi_end_atomic();
#line 52
      return (0);
    }
#line 55
    if (open_file->type == 576) {
#line 57
      __cil_tmp___0 = __otter_libc_get_sock_data_from_open_file(open_file);
#line 57
      sock = __cil_tmp___0;
#line 60
      __otter_libc_getsockopt_sol_socket(sock, 64, (void const   *)(& l), (unsigned int )sizeof(struct linger ));
#line 61
      if (l.l_onoff) {
#line 63
        if ((sock->sock_queue && *(sock->sock_queue + 0)) && (*(sock->sock_queue + 0))->recv_data) {
#line 65
          __otter_multi_begin_atomic();
#line 65
          while (1) {
#line 65
            __cil_tmp___1 = __otter_fs_pipe_is_empty((*(sock->sock_queue + 0))->recv_data);
#line 65
            if (! __cil_tmp___1) {
#line 65
              break;
            }
#line 65
            __otter_multi_io_block((void *)(*(sock->sock_queue + 0))->recv_data);
#line 65
            __otter_multi_begin_atomic();
          }
#line 65
          __otter_multi_end_atomic();
        }
      }
#line 69
      switch (sock->state) {
      case 0: 
#line 72
      break;
      case 1: 
      case 2: 
#line 75
      __otter_libc_flush_sock_queue(sock);
#line 76
      break;
      case 3: 
#line 79
      found = 0;
#line 80
      i = 0;
#line 80
      while (i < (*(sock->sock_queue + 0))->backlog) {
#line 82
        if ((unsigned int )*((*(sock->sock_queue + 0))->sock_queue + i) == (unsigned int )sock) {
#line 84
          found = 1;
        }
#line 87
        if (found) {
#line 89
          *((*(sock->sock_queue + 0))->sock_queue + i) = *((*(sock->sock_queue + 0))->sock_queue + (i + 1));
        }
#line 80
        i ++;
      }
#line 93
      if (found) {
#line 94
        *((*(sock->sock_queue + 0))->sock_queue + (*(sock->sock_queue + 0))->backlog) = (struct __otter_fs_sock_data *)((void *)0);
      } else
#line 95
      if ((unsigned int )*((*(sock->sock_queue + 0))->sock_queue + (*(sock->sock_queue + 0))->backlog) == (unsigned int )sock) {
#line 96
        *((*(sock->sock_queue + 0))->sock_queue + (*(sock->sock_queue + 0))->backlog) = (struct __otter_fs_sock_data *)((void *)0);
      } else {
#line 98
        __ASSERT((_Bool)0);
      }
#line 100
      *(sock->sock_queue + 0) = (struct __otter_fs_sock_data *)((void *)0);
#line 102
      break;
      case 4: 
      case 5: 
#line 105
      __otter_libc_shutdown_sock_data(sock, 4);
#line 106
      break;
      case 6: 
#line 108
      __ASSERT((_Bool)0);
#line 109
      break;
      case 7: 
      case 8: 
#line 112
      __otter_libc_shutdown_sock_data(sock, 4);
#line 113
      break;
      case 9: 
      case 10: 
#line 116
      __ASSERT((_Bool)0);
      case 11: 
#line 118
      break;
      default: 
#line 120
      __ASSERT((_Bool)0);
      }
#line 123
      __otter_fs_free_socket(inode);
#line 124
      __otter_multi_end_atomic();
#line 125
      return (0);
    }
#line 128
    if (open_file->type == 64) {
#line 130
      inode->size = 0;
#line 131
      free((void *)inode->data);
#line 132
      inode->data = (char *)((void *)0);
    }
#line 135
    if (inode->linkno == 0) {
#line 137
      free((void *)inode->data);
#line 138
      free((void *)inode);
    }
  }
#line 142
  __otter_multi_end_atomic();
#line 143
  return (0);
}
}
#line 147 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_read_file(struct __otter_fs_open_file_table_entry *open_file ,
                               void *buf , size_t num , off_t offset ) 
{ struct __otter_fs_inode *inode ;

  {
#line 153
  __otter_multi_begin_atomic();
#line 155
  inode = open_file->inode;
#line 162
  num = (unsigned int )((unsigned long )inode->size < (unsigned long )offset + (unsigned long )num ? (unsigned long )((long )inode->size - offset) : (unsigned long )num);
#line 163
  memcpy(buf, (void const   *)(inode->data + offset), num);
#line 165
  __otter_multi_end_atomic();
#line 167
  return ((int )num);
}
}
#line 170 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_write_file(struct __otter_fs_open_file_table_entry *open_file ,
                                void *buf , size_t num , off_t offset ) 
{ struct __otter_fs_inode *inode ;
  int physicalsize ;
  int newblocks ;
  void *__cil_tmp ;

  {
#line 176
  __otter_multi_begin_atomic();
#line 178
  inode = open_file->inode;
#line 180
  physicalsize = 256 * inode->numblocks;
#line 182
  if ((unsigned long )offset + (unsigned long )num > (unsigned long )physicalsize) {
#line 188
    newblocks = (int )(((unsigned long )offset + (unsigned long )num) / 256UL + 1UL);
#line 189
    __cil_tmp = __otter_multi_grealloc((void *)inode->data, (unsigned int )(newblocks * 256));
#line 189
    inode->data = (char *)__cil_tmp;
#line 191
    memset((void *)(inode->data + physicalsize), 0, (unsigned int )((newblocks - inode->numblocks) * 256));
#line 192
    inode->numblocks = newblocks;
  }
#line 195
  memcpy((void *)(inode->data + offset), (void const   *)buf, num);
#line 197
  if ((unsigned long )inode->size < (unsigned long )offset + (unsigned long )num) {
#line 199
    inode->size = (int )((unsigned long )offset + (unsigned long )num);
  }
#line 202
  __otter_multi_end_atomic();
#line 204
  return ((int )num);
}
}
#line 208 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_read_tty(void *buf , size_t num ) 
{ char data ;
  int i ;

  {
#line 211
  i = 0;
#line 211
  while ((unsigned int )i < num) {
#line 213
    __SYMBOLIC((void *)&data);
#line 215
    if ((int )data != 0) {
#line 217
      *((char *)buf + i) = data;
    } else {
#line 221
      return (i);
    }
#line 211
    i ++;
  }
#line 224
  return ((int )num);
}
}
#line 228 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_pread_pipe_data(struct __otter_fs_pipe_data *pipe___0 , void *buf ,
                                     size_t num ) 
{ int i ;

  {
#line 233
  __otter_multi_begin_atomic();
#line 236
  i = 0;
#line 236
  while ((unsigned int )i < num) {
#line 239
    if (((i + pipe___0->rhead) + 1) % 1024 != pipe___0->whead) {
#line 241
      *((char *)buf + i) = *(pipe___0->data + ((i + pipe___0->rhead) + 1) % 1024);
    } else {
#line 245
      __otter_multi_end_atomic();
#line 246
      return (i);
    }
#line 236
    i ++;
  }
#line 249
  __otter_multi_end_atomic();
#line 251
  return ((int )num);
}
}
#line 255 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_read_pipe_data(struct __otter_fs_pipe_data *pipe___0 , void *buf ,
                                    size_t num ) 
{ ssize_t __cil_tmp ;

  {
#line 260
  __cil_tmp = __otter_libc_pread_pipe_data(pipe___0, buf, num);
#line 260
  num = (unsigned int )__cil_tmp;
#line 262
  pipe___0->rhead = (int )(((unsigned int )pipe___0->rhead + num) % 1024U);
#line 263
  return ((int )num);
}
}
#line 266 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_write_pipe_data(struct __otter_fs_pipe_data *pipe___0 , void *buf ,
                                     size_t num ) 
{ int i ;

  {
#line 271
  __otter_multi_begin_atomic();
#line 273
  i = 0;
#line 273
  while ((unsigned int )i < num) {
#line 276
    if ((i + pipe___0->whead) % 1024 != pipe___0->rhead) {
#line 278
      *(pipe___0->data + (i + pipe___0->whead) % 1024) = *((char *)buf + i);
    } else {
#line 282
      while ((i + pipe___0->whead) % 1024 != pipe___0->rhead) {
#line 284
        __otter_multi_io_block((void *)(& pipe___0->rhead));
#line 285
        __otter_multi_begin_atomic();
      }
    }
#line 273
    i ++;
  }
#line 289
  __otter_multi_end_atomic();
#line 291
  pipe___0->whead = (int )(((unsigned int )pipe___0->whead + num) % 1024U);
#line 292
  return ((int )num);
}
}
#line 295 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_read_pipe(struct __otter_fs_open_file_table_entry *open_file ,
                               void *buf , size_t num ) 
{ struct __otter_fs_pipe_data *pipe___0 ;
  struct __otter_fs_pipe_data *__cil_tmp ;
  int *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  ssize_t __cil_tmp___3 ;

  {
#line 300
  __cil_tmp = __otter_libc_get_pipe_data_from_open_file(open_file);
#line 300
  pipe___0 = __cil_tmp;
#line 303
  __cil_tmp___2 = __otter_fs_pipe_is_empty(pipe___0);
#line 303
  if (__cil_tmp___2) {
#line 304
    if (open_file->mode & 128) {
#line 306
      __cil_tmp___0 = __errno();
#line 306
      *__cil_tmp___0 = 11;
#line 307
      return (-1);
    }
#line 309
    __otter_multi_begin_atomic();
#line 309
    while (1) {
#line 309
      __cil_tmp___1 = __otter_fs_pipe_is_empty(pipe___0);
#line 309
      if (! __cil_tmp___1) {
#line 309
        break;
      }
#line 309
      __otter_multi_io_block((void *)pipe___0);
#line 309
      __otter_multi_begin_atomic();
    }
#line 309
    __otter_multi_end_atomic();
  }
#line 315
  __cil_tmp___3 = __otter_libc_read_pipe_data(pipe___0, buf, num);
#line 315
  return (__cil_tmp___3);
}
}
#line 318 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_write_pipe(struct __otter_fs_open_file_table_entry *open_file ,
                                void *buf , size_t num ) 
{ struct __otter_fs_inode *inode ;
  struct __otter_fs_pipe_data *pipe___0 ;
  int *__cil_tmp ;
  ssize_t __cil_tmp___0 ;

  {
#line 323
  inode = open_file->inode;
#line 324
  pipe___0 = (struct __otter_fs_pipe_data *)inode->data;
#line 325
  if (inode->r_openno == 0) {
#line 327
    __cil_tmp = __errno();
#line 327
    *__cil_tmp = 32;
#line 329
    return (-1);
  }
#line 332
  __cil_tmp___0 = __otter_libc_write_pipe_data(pipe___0, buf, num);
#line 332
  return (__cil_tmp___0);
}
}
#line 335 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_write_socket(struct __otter_fs_open_file_table_entry *open_file ,
                                  void *buf , size_t num ) 
{ struct __otter_fs_sock_data *sock ;
  struct __otter_fs_sock_data *__cil_tmp ;
  ssize_t __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  ssize_t __cil_tmp___2 ;

  {
#line 340
  __cil_tmp = __otter_libc_get_sock_data_from_open_file(open_file);
#line 340
  sock = __cil_tmp;
#line 342
  switch (sock->state) {
  case 3: 
#line 346
  __otter_multi_begin_atomic();
#line 346
  while (sock->state == 3) {
#line 346
    __otter_multi_io_block((void *)sock);
#line 346
    __otter_multi_begin_atomic();
  }
#line 346
  __otter_multi_end_atomic();
#line 347
  __cil_tmp___0 = __otter_libc_write_socket(open_file, buf, num);
#line 347
  return (__cil_tmp___0);
  case 0: 
  case 1: 
  case 2: 
  case 6: 
  case 7: 
  case 8: 
  case 9: 
  case 10: 
  case 11: 
#line 359
  __cil_tmp___1 = __errno();
#line 359
  *__cil_tmp___1 = 128;
#line 360
  return (-1);
  case 4: 
  case 5: 
#line 365
  __cil_tmp___2 = __otter_libc_write_pipe_data((*(sock->sock_queue + 0))->recv_data,
                                               buf, num);
#line 365
  return (__cil_tmp___2);
  }
#line 368
  __ASSERT((_Bool)0);
#line 369
  abort();
}
}
#line 372 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_read2(struct __otter_fs_open_file_table_entry *open_file , void *buf ,
                           size_t num , off_t offset ) 
{ int *__cil_tmp ;
  ssize_t __cil_tmp___0 ;
  ssize_t __cil_tmp___1 ;
  ssize_t __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int *__cil_tmp___4 ;

  {
#line 378
  if (num == 0U) {
#line 379
    return (0);
  }
#line 381
  if (offset < 0L) {
#line 383
    __cil_tmp = __errno();
#line 383
    *__cil_tmp = 22;
#line 384
    return (-1);
  }
#line 387
  switch (open_file->type) {
  case 0: 
#line 390
  __cil_tmp___0 = __otter_libc_read_file(open_file, buf, num, offset);
#line 390
  return (__cil_tmp___0);
  case 192: 
#line 392
  __cil_tmp___1 = __otter_libc_read_tty(buf, num);
#line 392
  return (__cil_tmp___1);
  case 64: 
#line 394
  __cil_tmp___2 = __otter_libc_read_pipe(open_file, buf, num);
#line 394
  return (__cil_tmp___2);
  case 576: 
#line 397
  __cil_tmp___3 = __otter_libc_recv_socket(open_file, buf, num, 0);
#line 397
  return (__cil_tmp___3);
  case 1: 
#line 399
  __cil_tmp___4 = __errno();
#line 399
  *__cil_tmp___4 = 21;
#line 400
  return (-1);
  case 320: 
#line 402
  return (0);
  case 448: 
#line 404
  memset(buf, 0, num);
#line 405
  return ((int )num);
  }
#line 407
  __ASSERT((_Bool)0);
#line 408
  abort();
}
}
#line 411 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_read(int fd , void *buf , size_t num ) 
{ struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp ;
  int *__cil_tmp___0 ;
  int numread ;
  ssize_t __cil_tmp___1 ;

  {
#line 413
  __cil_tmp = get_open_file_from_fd(fd);
#line 413
  open_file = __cil_tmp;
#line 414
  if (! open_file) {
#line 414
    return (-1);
  }
#line 416
  if (! (open_file->mode & 1)) {
#line 418
    __cil_tmp___0 = __errno();
#line 418
    *__cil_tmp___0 = 9;
#line 419
    return (-1);
  }
#line 422
  __cil_tmp___1 = __otter_libc_read2(open_file, buf, num, (long )open_file->offset);
#line 422
  numread = __cil_tmp___1;
#line 424
  if (numread == -1) {
#line 425
    return (-1);
  }
#line 427
  open_file->offset += numread;
#line 428
  return (numread);
}
}
#line 451 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_write2(struct __otter_fs_open_file_table_entry *open_file , void *buf ,
                            size_t num , off_t offset ) 
{ int *__cil_tmp ;
  ssize_t __cil_tmp___0 ;
  ssize_t __cil_tmp___1 ;
  ssize_t __cil_tmp___2 ;

  {
#line 457
  if (num == 0U) {
#line 458
    return (0);
  }
#line 460
  if (offset < 0L) {
#line 462
    __cil_tmp = __errno();
#line 462
    *__cil_tmp = 22;
#line 463
    return (-1);
  }
#line 466
  switch (open_file->type) {
  case 192: 
#line 469
  __EVALSTR((char const   *)buf, num);
#line 474
  return ((int )num);
  case 0: 
#line 476
  __cil_tmp___0 = __otter_libc_write_file(open_file, buf, num, offset);
#line 476
  return (__cil_tmp___0);
  case 64: 
#line 478
  __cil_tmp___1 = __otter_libc_write_pipe(open_file, buf, num);
#line 478
  return (__cil_tmp___1);
  case 576: 
#line 480
  __cil_tmp___2 = __otter_libc_write_socket(open_file, buf, num);
#line 480
  return (__cil_tmp___2);
  case 1: 
#line 482
  __ASSERT((_Bool)0);
#line 483
  abort();
  case 320: 
  case 448: 
#line 486
  return ((int )num);
  }
#line 488
  __ASSERT((_Bool)0);
#line 489
  abort();
}
}
#line 492 "syscalls/unistd/__otter_unistd.c"
ssize_t __otter_libc_write(int fd , void const   *buf , size_t num ) 
{ struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp ;
  int *__cil_tmp___0 ;
  int numwrite ;
  ssize_t __cil_tmp___1 ;

  {
#line 494
  __cil_tmp = get_open_file_from_fd(fd);
#line 494
  open_file = __cil_tmp;
#line 495
  if (! open_file) {
#line 495
    return (-1);
  }
#line 497
  if (! (open_file->mode & 2)) {
#line 499
    __cil_tmp___0 = __errno();
#line 499
    *__cil_tmp___0 = 9;
#line 500
    return (-1);
  }
#line 503
  if (open_file->mode & 64) {
#line 505
    open_file->offset = (open_file->inode)->size;
  }
#line 508
  __cil_tmp___1 = __otter_libc_write2(open_file, (void *)buf, num, (long )open_file->offset);
#line 508
  numwrite = __cil_tmp___1;
#line 510
  if (numwrite == -1) {
#line 511
    return (-1);
  }
#line 516
  open_file->offset += numwrite;
#line 517
  return (numwrite);
}
}
#line 540 "syscalls/unistd/__otter_unistd.c"
off_t __otter_libc_lseek(int fd , off_t offset , int whence ) 
{ struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp ;
  int *__cil_tmp___0 ;
  off_t newOffset ;
  struct __otter_fs_inode *inode ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 542
  __cil_tmp = get_open_file_from_fd(fd);
#line 542
  open_file = __cil_tmp;
#line 543
  if (! open_file) {
#line 543
    return (-1L);
  }
#line 545
  if (open_file->type != 0) {
#line 547
    __cil_tmp___0 = __errno();
#line 547
    *__cil_tmp___0 = 29;
#line 548
    return (-1L);
  }
#line 553
  switch (whence) {
  case 0: 
#line 556
  newOffset = offset;
#line 557
  break;
  case 1: 
#line 559
  newOffset = (long )open_file->offset + offset;
#line 560
  break;
  case 2: 
#line 563
  inode = open_file->inode;
#line 564
  newOffset = (long )inode->size + offset;
#line 565
  break;
  default: 
#line 568
  __cil_tmp___1 = __errno();
#line 568
  *__cil_tmp___1 = 22;
#line 569
  return (-1L);
  }
#line 571
  if (newOffset < 0L) {
#line 572
    __cil_tmp___2 = __errno();
#line 572
    *__cil_tmp___2 = 22;
#line 573
    return (-1L);
  }
#line 575
  open_file->offset = (int )newOffset;
#line 577
  return (newOffset);
}
}
#line 625 "syscalls/unistd/__otter_unistd.c"
int fork(void) 
{ struct __otter_fs_open_file_table_entry *open_file ;
  int fd ;
  pid_t __cil_tmp ;

  {
#line 627
  __otter_multi_begin_atomic();
#line 630
  if (__otter_fs_open_file_table) {
#line 632
    fd = 0;
#line 632
    while (fd < 64) {
#line 634
      open_file = get_open_file_from_fd(fd);
#line 635
      if (open_file) {
#line 637
        (open_file->openno) ++;
      }
#line 632
      fd ++;
    }
  }
#line 642
  __otter_multi_end_atomic();
#line 644
  __cil_tmp = __otter_multi_fork();
#line 644
  return (__cil_tmp);
}
}
#line 647 "syscalls/unistd/__otter_unistd.c"
pid_t __otter_libc_setsid(void) 
{ pid_t parent ;
  pid_t __cil_tmp ;
  int *__cil_tmp___0 ;
  pid_t pid ;
  pid_t __cil_tmp___1 ;

  {
#line 649
  __cil_tmp = getppid();
#line 649
  parent = __cil_tmp;
#line 650
  if (parent < 0) {
#line 652
    __cil_tmp___0 = __errno();
#line 652
    *__cil_tmp___0 = 1;
#line 653
    return (-1);
  }
#line 656
  __cil_tmp___1 = getpid();
#line 656
  pid = __cil_tmp___1;
#line 657
  __otter_multi_set_parent_pid(- pid - 2);
#line 658
  return (- pid - 2);
}
}
#line 661 "syscalls/unistd/__otter_unistd.c"
pid_t __otter_libc_getppid(void) 
{ pid_t __cil_tmp ;
  pid_t __cil_tmp___0 ;

  {
#line 663
  __cil_tmp = getpid();
#line 663
  __cil_tmp___0 = __otter_multi_get_parent_pid(__cil_tmp);
#line 663
  return (__cil_tmp___0);
}
}
#line 699 "syscalls/unistd/__otter_unistd.c"
int chdir(char const   *path ) 
{ char *name ;
  size_t __cil_tmp ;
  void *__cil_tmp___0 ;
  struct __otter_fs_dnode *dnode ;
  struct __otter_fs_dnode *__cil_tmp___1 ;

  {
#line 701
  __cil_tmp = strlen(path);
#line 701
  __cil_tmp___0 = malloc(__cil_tmp + 1U);
#line 701
  name = (char *)__cil_tmp___0;
#line 702
  strcpy(name, path);
#line 703
  __cil_tmp___1 = __otter_fs_find_dnode((char const   *)name);
#line 703
  dnode = __cil_tmp___1;
#line 705
  if (! dnode) {
#line 707
    free((void *)name);
#line 708
    return (-1);
  }
#line 711
  __otter_fs_pwd = dnode;
#line 713
  free((void *)name);
#line 714
  return (0);
}
}
#line 1 "cil-qLNdLrWD.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-lnAhSEM9.i","")
#line 1 "cil-5gdqOei5.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-iEWHBQpm.i","")
#line 1 "cil-aXmiP8ED.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-O0CU0SHb.i","")
#line 1 "cil-lT6Q89ZC.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-4SuJm56F.i","")
#line 5 "syscalls/unistd/close.c"
int close(int fildes ) 
{ int __cil_tmp ;

  {
#line 6
  __cil_tmp = __otter_libc_close(fildes);
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-2OSifL16.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-xDsicLlX.i","")
#line 1 "cil-wBLbNFk7.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-1Ho1uklY.i","")
#line 7 "syscalls/unistd/dup2.c"
int dup2(int fd1 , int fd2 ) 
{ int *__cil_tmp ;
  struct __otter_fs_open_file_table_entry *open_file ;
  struct __otter_fs_open_file_table_entry *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 9
  if (fd2 < 0 || fd2 >= 64) {
#line 11
    __cil_tmp = __errno();
#line 11
    *__cil_tmp = 9;
#line 12
    return (-1);
  }
#line 15
  __cil_tmp___0 = get_open_file_from_fd(fd1);
#line 15
  open_file = __cil_tmp___0;
#line 16
  if (! open_file) {
#line 18
    __cil_tmp___1 = __errno();
#line 18
    *__cil_tmp___1 = 9;
#line 19
    return (-1);
  }
#line 22
  if (*(__otter_fs_fd_table + fd1) == *(__otter_fs_fd_table + fd2)) {
#line 23
    return (fd2);
  }
#line 25
  open_file = get_open_file_from_fd(fd2);
#line 27
  if (open_file) {
#line 29
    close(fd2);
  }
#line 32
  __cil_tmp___2 = fcntl(fd1, 1, fd2);
#line 32
  return (__cil_tmp___2);
}
}
#line 1 "cil-MkBe5N4m.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-6k5RaQTX.i","")
#line 4 "syscalls/unistd/fsync.c"
int fsync(int fildes ) 
{ 

  {
#line 5
  return (0);
}
}
#line 1 "cil-rUGSO5qc.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Psnki20G.i","")
#line 1 "cil-ffvlMEjG.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-vdQC1WpW.i","")
#line 1 "cil-kF6B4pud.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-0tHJNtz2.i","")
#line 1 "cil-LENEn4QR.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Kv1qs4EW.i","")
#line 1 "cil-cazXpiFM.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-SmlRy6C1.i","")
#line 1 "cil-C7QA3Ova.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-pxmbSIWe.i","")
#line 1 "cil-F8mYwP0Q.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-W9gnWMbM.i","")
#line 1 "cil-kZnOZT0M.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-I8XCHAEO.i","")
#line 1 "cil-auIUgoJg.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-n3V8E8YT.i","")
#line 4 "syscalls/unistd/getpid.c"
int getpid(void) 
{ pid_t __cil_tmp ;

  {
#line 6
  __cil_tmp = __otter_multi_get_pid();
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-OHZY5xXY.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-yieIdCvw.i","")
#line 5 "syscalls/unistd/getppid.c"
pid_t getppid(void) 
{ pid_t __cil_tmp ;

  {
#line 6
  __cil_tmp = __otter_libc_getppid();
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-FGfCnH46.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-sTQGukPT.i","")
#line 1 "cil-ocxwihl8.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Y5VvI3Uv.i","")
#line 1 "cil-PZBboRHD.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-kUJyeJsS.i","")
#line 5 "syscalls/unistd/lseek.c"
off_t lseek(int fd , off_t offset , int whence ) 
{ off_t __cil_tmp ;

  {
#line 6
  __cil_tmp = __otter_libc_lseek(fd, offset, whence);
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-6mvf4dAL.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-T7QFwyTE.i","")
#line 5 "syscalls/unistd/read.c"
int read(int fd , void *buf , size_t num ) 
{ ssize_t __cil_tmp ;

  {
#line 6
  __cil_tmp = __otter_libc_read(fd, buf, num);
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-rtIafB6j.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-moJph47v.i","")
#line 1 "cil-HE6b56Sv.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-CsbFsyKD.i","")
#line 1 "cil-VO27DONg.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-r1ZvXQbr.i","")
#line 1 "cil-PBQWj48H.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wTMtM0es.i","")
#line 5 "syscalls/unistd/setsid.c"
pid_t setsid(void) 
{ pid_t __cil_tmp ;

  {
#line 6
  __cil_tmp = __otter_libc_setsid();
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-uscjyqzl.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-H2fQ4MeC.i","")
#line 1 "cil-BEBDVnJ0.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-AMJ57hVa.i","")
#line 4 "syscalls/unistd/sleep.c"
unsigned int sleep(unsigned int seconds ) 
{ struct timespec t ;

  {
#line 5
  t.tv_sec = (long )seconds;
#line 5
  t.tv_nsec = 0L;
#line 6
  nanosleep((struct timespec  const  *)(& t), (struct timespec *)((void *)0));
#line 7
  return (0U);
}
}
#line 1 "cil-GrS6pmV4.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-aMHFFenr.i","")
#line 1 "cil-33qfvXuH.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-Ze6DkAee.i","")
#line 1 "cil-btMCtjoE.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-FZUOdNn6.i","")
#line 5 "syscalls/unistd/unlink.c"
int unlink(char const   *path ) 
{ char *filename ;
  struct __otter_fs_dnode *dnode ;
  struct __otter_fs_dnode *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 8
  __cil_tmp = find_filename_and_dnode(path, & filename);
#line 8
  dnode = __cil_tmp;
#line 10
  if (! dnode) {
#line 11
    return (-1);
  }
#line 13
  __cil_tmp___0 = __otter_fs_unlink_in_dir((char const   *)filename, dnode);
#line 13
  return (__cil_tmp___0 - 1);
}
}
#line 1 "cil-pS4CVUCV.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-wvtM2OiV.i","")
#line 5 "syscalls/unistd/write.c"
int write(int fd , void const   *buf , size_t num ) 
{ ssize_t __cil_tmp ;

  {
#line 6
  __cil_tmp = __otter_libc_write(fd, buf, num);
#line 6
  return (__cil_tmp);
}
}
#line 1 "net.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-ehFK6tVx.i","-std=c99,-pedantic,-O3,-fPIC,-Wall,-W,-Wwrite-strings,-g,-ggdb")
#line 40 "net.h"
int redisContextConnectTcp(redisContext *c , char const   *addr , int port ) ;
#line 51 "net.c"
void __redisSetError(redisContext *c , int type , sds errstr ) ;
#line 53 "net.c"
static int redisCreateSocket(redisContext *c , int type ) 
{ int s ;
  int on ;
  int __cil_tmp ;

  {
#line 54
  on = 1;
#line 55
  s = socket(type, 2, 0);
#line 55
  if (s == -1) {
#line 56
    __redisSetError(c, 1, (char *)((void *)0));
#line 57
    return (-1);
  }
#line 59
  if (type == 2) {
#line 60
    __cil_tmp = setsockopt(s, -1, 2048, (void const   *)(& on), (unsigned int )sizeof(on));
#line 60
    if (__cil_tmp == -1) {
#line 61
      __redisSetError(c, 1, (char *)((void *)0));
#line 62
      close(s);
#line 63
      return (-1);
    }
  }
#line 66
  return (s);
}
}
#line 69 "net.c"
static int redisSetNonBlock(redisContext *c , int fd ) 
{ int flags ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  sds __cil_tmp___1 ;
  sds __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  sds __cil_tmp___5 ;
  sds __cil_tmp___6 ;
  int __cil_tmp___7 ;

  {
#line 75
  flags = fcntl(fd, 4);
#line 75
  if (flags == -1) {
#line 76
    __cil_tmp = __errno();
#line 76
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 76
    __cil_tmp___1 = sdsempty();
#line 76
    __cil_tmp___2 = sdscatprintf(__cil_tmp___1, "fcntl(F_GETFL): %s", __cil_tmp___0);
#line 76
    __redisSetError(c, 1, __cil_tmp___2);
#line 78
    close(fd);
#line 79
    return (-1);
  }
#line 81
  __cil_tmp___7 = fcntl(fd, 5, flags | 128);
#line 81
  if (__cil_tmp___7 == -1) {
#line 82
    __cil_tmp___3 = __errno();
#line 82
    __cil_tmp___4 = strerror(*__cil_tmp___3);
#line 82
    __cil_tmp___5 = sdsempty();
#line 82
    __cil_tmp___6 = sdscatprintf(__cil_tmp___5, "fcntl(F_SETFL,O_NONBLOCK): %s", __cil_tmp___4);
#line 82
    __redisSetError(c, 1, __cil_tmp___6);
#line 84
    close(fd);
#line 85
    return (-1);
  }
#line 87
  return (0);
}
}
#line 90 "net.c"
static int redisSetTcpNoDelay(redisContext *c , int fd ) 
{ int yes ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  sds __cil_tmp___1 ;
  sds __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 91
  yes = 1;
#line 92
  __cil_tmp___3 = setsockopt(fd, 3, 1, (void const   *)(& yes), (unsigned int )sizeof(yes));
#line 92
  if (__cil_tmp___3 == -1) {
#line 93
    __cil_tmp = __errno();
#line 93
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 93
    __cil_tmp___1 = sdsempty();
#line 93
    __cil_tmp___2 = sdscatprintf(__cil_tmp___1, "setsockopt(TCP_NODELAY): %s", __cil_tmp___0);
#line 93
    __redisSetError(c, 1, __cil_tmp___2);
#line 95
    return (-1);
  }
#line 97
  return (0);
}
}
#line 100 "net.c"
int redisContextConnectTcp(redisContext *c , char const   *addr , int port ) 
{ int s ;
  int blocking ;
  struct sockaddr_in sa ;
  int __cil_tmp ;
  struct hostent *he ;
  sds __cil_tmp___0 ;
  sds __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;

  {
#line 102
  blocking = c->flags & 1;
#line 105
  s = redisCreateSocket(c, 2);
#line 105
  if (s == -1) {
#line 106
    return (-1);
  }
#line 107
  if (! blocking) {
#line 107
    __cil_tmp = redisSetNonBlock(c, s);
#line 107
    if (__cil_tmp == -1) {
#line 108
      return (-1);
    }
  }
#line 110
  memset((void *)(& sa), 0, (unsigned int )sizeof(sa));
#line 111
  sa.sin_family = (unsigned short)2;
#line 112
  sa.sin_port = (unsigned short )(((port & 65280) >> 8) | ((port & 255) << 8));
#line 113
  __cil_tmp___2 = inet_aton(addr, & sa.sin_addr);
#line 113
  if (__cil_tmp___2 == 0) {
#line 116
    he = gethostbyname(addr);
#line 117
    if ((unsigned int )he == (unsigned int )((void *)0)) {
#line 118
      __cil_tmp___0 = sdsempty();
#line 118
      __cil_tmp___1 = sdscatprintf(__cil_tmp___0, "Can\'t resolve: %s", addr);
#line 118
      __redisSetError(c, 2, __cil_tmp___1);
#line 120
      close(s);
#line 121
      return (-1);
    }
#line 123
    memcpy((void *)(& sa.sin_addr), (void const   *)*(he->h_addr_list + 0), (unsigned int )sizeof(struct in_addr ));
  }
#line 126
  __cil_tmp___4 = connect(s, (struct sockaddr  const  *)((struct sockaddr *)(& sa)),
                          (unsigned int )sizeof(sa));
#line 126
  if (__cil_tmp___4 == -1) {
#line 127
    __cil_tmp___3 = __errno();
#line 127
    if (! (*__cil_tmp___3 == 119 && ! blocking)) {
#line 130
      __redisSetError(c, 1, (char *)((void *)0));
#line 131
      close(s);
#line 132
      return (-1);
    }
  }
#line 136
  __cil_tmp___5 = redisSetTcpNoDelay(c, s);
#line 136
  if (__cil_tmp___5 != 0) {
#line 137
    close(s);
#line 138
    return (-1);
  }
#line 141
  c->fd = s;
#line 142
  c->flags |= 2;
#line 143
  return (0);
}
}
#line 1 "hiredis.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-e2LReEBL.i","-std=c99,-pedantic,-O3,-fPIC,-Wall,-W,-Wwrite-strings,-g,-ggdb")
#line 121 "hiredis.h"
void *redisReplyReaderCreate(void) ;
#line 122
int redisReplyReaderSetReplyObjectFunctions(void *reader , redisReplyObjectFunctions *fn ) ;
#line 127
void redisReplyReaderFeed(void *reader , char *buf , size_t len ) ;
#line 128
int redisReplyReaderGetReply(void *reader , void **reply ) ;
#line 131
int redisvFormatCommand(char **target , char const   *format , va_list ap ) ;
#line 141
int redisBufferRead(redisContext *c ) ;
#line 142
int redisBufferWrite(redisContext *c , int *done ) ;
#line 148
int redisGetReply(redisContext *c , void **reply ) ;
#line 149
int redisGetReplyFromReader(redisContext *c , void **reply ) ;
#line 162
void *redisvCommand(redisContext *c , char const   *format , va_list ap ) ;
#line 35 "util.h"
static void redisOOM(void) 
{ 

  {
#line 36
  fprintf(_impure_ptr->_stderr, "Out of memory in hiredis");
#line 37
  exit(1);
}
}
#line 58 "hiredis.c"
static redisReply *createReplyObject(int type ) ;
#line 59
static void *createStringObject___0(redisReadTask const   *task , char *str , size_t len ) ;
#line 60
static void *createArrayObject(redisReadTask const   *task , int elements ) ;
#line 61
static void *createIntegerObject(redisReadTask const   *task , long long value ) ;
#line 62
static void *createNilObject(redisReadTask const   *task ) ;
#line 63
static void redisSetReplyReaderError(redisReader *r , sds err ) ;
#line 66 "hiredis.c"
static redisReplyObjectFunctions defaultFunctions  =    {& createStringObject___0, & createArrayObject, & createIntegerObject, & createNilObject,
    & freeReplyObject};
#line 75 "hiredis.c"
static redisReply *createReplyObject(int type ) 
{ redisReply *r ;
  void *__cil_tmp ;

  {
#line 76
  __cil_tmp = malloc((unsigned int )sizeof(*r));
#line 76
  r = (redisReply *)__cil_tmp;
#line 78
  if (! r) {
#line 78
    redisOOM();
  }
#line 79
  r->type = type;
#line 80
  return (r);
}
}
#line 84 "hiredis.c"
void freeReplyObject(void *reply ) 
{ redisReply *r ;
  size_t j ;

  {
#line 85
  r = (redisReply *)reply;
#line 88
  switch (r->type) {
  case 3: 
#line 90
  break;
  case 2: 
#line 92
  j = 0U;
#line 92
  while (j < r->elements) {
#line 93
    if (*(r->element + j)) {
#line 93
      freeReplyObject((void *)*(r->element + j));
    }
#line 92
    j ++;
  }
#line 94
  free((void *)r->element);
#line 95
  break;
  case 6: 
  case 5: 
  case 1: 
#line 99
  free((void *)r->str);
#line 100
  break;
  }
#line 102
  free((void *)r);
#line 103
  return;
}
}
#line 105 "hiredis.c"
static void *createStringObject___0(redisReadTask const   *task , char *str , size_t len ) 
{ redisReply *r ;
  redisReply *__cil_tmp ;
  char *value ;
  void *__cil_tmp___0 ;
  redisReply *parent ;

  {
#line 106
  __cil_tmp = createReplyObject((int )task->type);
#line 106
  r = __cil_tmp;
#line 107
  __cil_tmp___0 = malloc(len + 1U);
#line 107
  value = (char *)__cil_tmp___0;
#line 108
  if (! value) {
#line 108
    redisOOM();
  }
#line 109
  if (((task->type == 6 || task->type == 5) || task->type == 1) == 0) {
#line 109
    __libc_failwith((char *)"Assertion failed: task->type == REDIS_REPLY_ERROR || task->type == REDIS_REPLY_STATUS || task->type == REDIS_REPLY_STRING at hiredis.c:111");
  }
#line 114
  memcpy((void *)value, (void const   *)str, len);
#line 115
  *(value + len) = (char )'\000';
#line 116
  r->str = value;
#line 117
  r->len = (int )len;
#line 119
  if (task->parent) {
#line 120
    parent = (redisReply *)(task->parent)->obj;
#line 121
    if ((parent->type == 2) == 0) {
#line 121
      __libc_failwith((char *)"Assertion failed: parent->type == REDIS_REPLY_ARRAY at hiredis.c:121");
    }
#line 122
    *(parent->element + task->idx) = r;
  }
#line 124
  return ((void *)r);
}
}
#line 127 "hiredis.c"
static void *createArrayObject(redisReadTask const   *task , int elements ) 
{ redisReply *r ;
  redisReply *__cil_tmp ;
  struct redisReply **__cil_tmp___0 ;
  void *__cil_tmp___1 ;
  redisReply *parent ;

  {
#line 128
  __cil_tmp = createReplyObject(2);
#line 128
  r = __cil_tmp;
#line 129
  r->elements = (unsigned int )elements;
#line 130
  __cil_tmp___1 = calloc((unsigned int )sizeof(redisReply *), (unsigned int )elements);
#line 130
  __cil_tmp___0 = (struct redisReply **)__cil_tmp___1;
#line 130
  r->element = __cil_tmp___0;
#line 130
  if ((unsigned int )__cil_tmp___0 == (unsigned int )((void *)0)) {
#line 131
    redisOOM();
  }
#line 132
  if (task->parent) {
#line 133
    parent = (redisReply *)(task->parent)->obj;
#line 134
    if ((parent->type == 2) == 0) {
#line 134
      __libc_failwith((char *)"Assertion failed: parent->type == REDIS_REPLY_ARRAY at hiredis.c:134");
    }
#line 135
    *(parent->element + task->idx) = r;
  }
#line 137
  return ((void *)r);
}
}
#line 140 "hiredis.c"
static void *createIntegerObject(redisReadTask const   *task , long long value ) 
{ redisReply *r ;
  redisReply *__cil_tmp ;
  redisReply *parent ;

  {
#line 141
  __cil_tmp = createReplyObject(3);
#line 141
  r = __cil_tmp;
#line 142
  r->integer = value;
#line 143
  if (task->parent) {
#line 144
    parent = (redisReply *)(task->parent)->obj;
#line 145
    if ((parent->type == 2) == 0) {
#line 145
      __libc_failwith((char *)"Assertion failed: parent->type == REDIS_REPLY_ARRAY at hiredis.c:145");
    }
#line 146
    *(parent->element + task->idx) = r;
  }
#line 148
  return ((void *)r);
}
}
#line 151 "hiredis.c"
static void *createNilObject(redisReadTask const   *task ) 
{ redisReply *r ;
  redisReply *__cil_tmp ;
  redisReply *parent ;

  {
#line 152
  __cil_tmp = createReplyObject(4);
#line 152
  r = __cil_tmp;
#line 153
  if (task->parent) {
#line 154
    parent = (redisReply *)(task->parent)->obj;
#line 155
    if ((parent->type == 2) == 0) {
#line 155
      __libc_failwith((char *)"Assertion failed: parent->type == REDIS_REPLY_ARRAY at hiredis.c:155");
    }
#line 156
    *(parent->element + task->idx) = r;
  }
#line 158
  return ((void *)r);
}
}
#line 161 "hiredis.c"
static char *readBytes(redisReader *r , unsigned int bytes ) 
{ char *p ;

  {
#line 163
  if (r->len - r->pos >= bytes) {
#line 164
    p = r->buf + r->pos;
#line 165
    r->pos += bytes;
#line 166
    return (p);
  }
#line 168
  return ((char *)((void *)0));
}
}
#line 172 "hiredis.c"
static char *seekNewline(char *s , size_t len ) 
{ int pos ;
  int _len ;

  {
#line 173
  pos = 0;
#line 174
  _len = (int )(len - 1U);
#line 180
  while (pos < _len) {
#line 181
    while (pos < _len && (int )*(s + pos) != 13) {
#line 181
      pos ++;
    }
#line 182
    if ((int )*(s + pos) != 13) {
#line 184
      return ((char *)((void *)0));
    } else
#line 186
    if ((int )*(s + (pos + 1)) == 10) {
#line 188
      return (s + pos);
    } else {
#line 191
      pos ++;
    }
  }
#line 195
  return ((char *)((void *)0));
}
}
#line 200 "hiredis.c"
static long long readLongLong(char *s ) 
{ long long v ;
  int dec ;
  int mult ;
  char c ;
  char *__cil_tmp ;

  {
#line 201
  v = 0LL;
#line 202
  mult = 1;
#line 205
  if ((int )*s == 45) {
#line 206
    mult = -1;
#line 207
    s ++;
  } else
#line 208
  if ((int )*s == 43) {
#line 209
    mult = 1;
#line 210
    s ++;
  }
#line 213
  while (1) {
#line 213
    __cil_tmp = s;
#line 213
    s ++;
#line 213
    c = *__cil_tmp;
#line 213
    if (! ((int )c != 13)) {
#line 213
      break;
    }
#line 214
    dec = (int )c - 48;
#line 215
    if (dec >= 0 && dec < 10) {
#line 216
      v *= 10LL;
#line 217
      v += (long long )dec;
    } else {
#line 220
      return (-1LL);
    }
  }
#line 224
  return ((long long )mult * v);
}
}
#line 227 "hiredis.c"
static char *readLine(redisReader *r , int *_len ) 
{ char *p ;
  char *s ;
  int len ;

  {
#line 231
  p = r->buf + r->pos;
#line 232
  s = seekNewline(p, r->len - r->pos);
#line 233
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 234
    len = s - (r->buf + r->pos);
#line 235
    r->pos += (unsigned int )(len + 2);
#line 236
    if (_len) {
#line 236
      *_len = len;
    }
#line 237
    return (p);
  }
#line 239
  return ((char *)((void *)0));
}
}
#line 242 "hiredis.c"
static void moveToNextTask(redisReader *r ) 
{ redisReadTask *cur ;
  redisReadTask *prv ;

  {
#line 244
  while (r->ridx >= 0) {
#line 246
    if (r->ridx == 0) {
#line 247
      (r->ridx) --;
#line 248
      return;
    }
#line 251
    cur = & r->rstack[r->ridx];
#line 252
    prv = & r->rstack[r->ridx - 1];
#line 253
    if ((prv->type == 2) == 0) {
#line 253
      __libc_failwith((char *)"Assertion failed: prv->type == REDIS_REPLY_ARRAY at hiredis.c:253");
    }
#line 254
    if (cur->idx == prv->elements - 1) {
#line 255
      (r->ridx) --;
    } else {
#line 258
      if ((cur->idx < prv->elements) == 0) {
#line 258
        __libc_failwith((char *)"Assertion failed: cur->idx < prv->elements at hiredis.c:258");
      }
#line 259
      cur->type = -1;
#line 260
      cur->elements = -1;
#line 261
      (cur->idx) ++;
#line 262
      return;
    }
  }
#line 265
  return;
}
}
#line 267 "hiredis.c"
static int processLineItem(redisReader *r ) 
{ redisReadTask *cur ;
  void *obj ;
  char *p ;
  int len ;
  long long __cil_tmp ;

  {
#line 268
  cur = & r->rstack[r->ridx];
#line 273
  p = readLine(r, & len);
#line 273
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 274
    if (r->fn) {
#line 275
      if (cur->type == 3) {
#line 276
        __cil_tmp = readLongLong(p);
#line 276
        obj = (*((r->fn)->createInteger))((redisReadTask const   *)cur, __cil_tmp);
      } else {
#line 278
        obj = (*((r->fn)->createString))((redisReadTask const   *)cur, p, (unsigned int )len);
      }
    } else {
#line 281
      obj = (void *)((unsigned int )cur->type);
    }
#line 285
    if (r->ridx == 0) {
#line 285
      r->reply = obj;
    }
#line 286
    moveToNextTask(r);
#line 287
    return (0);
  }
#line 289
  return (-1);
}
}
#line 292 "hiredis.c"
static int processBulkItem(redisReader *r ) 
{ redisReadTask *cur ;
  void *obj ;
  char *p ;
  char *s ;
  long len ;
  unsigned long bytelen ;
  int success ;
  long long __cil_tmp ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;

  {
#line 293
  cur = & r->rstack[r->ridx];
#line 294
  obj = (void *)0;
#line 298
  success = 0;
#line 300
  p = r->buf + r->pos;
#line 301
  s = seekNewline(p, r->len - r->pos);
#line 302
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 303
    p = r->buf + r->pos;
#line 304
    bytelen = (unsigned long )((s - (r->buf + r->pos)) + 2);
#line 305
    __cil_tmp = readLongLong(p);
#line 305
    len = (long )__cil_tmp;
#line 307
    if (len < 0L) {
#line 309
      if (r->fn) {
#line 309
        __cil_tmp___0 = (*((r->fn)->createNil))((redisReadTask const   *)cur);
#line 309
        obj = __cil_tmp___0;
      } else {
#line 309
        obj = (void *)4;
      }
#line 311
      success = 1;
    } else {
#line 314
      bytelen += (unsigned long )(len + 2L);
#line 315
      if ((unsigned long )r->pos + bytelen <= (unsigned long )r->len) {
#line 316
        if (r->fn) {
#line 316
          __cil_tmp___1 = (*((r->fn)->createString))((redisReadTask const   *)cur,
                                                     s + 2, (unsigned int )len);
#line 316
          obj = __cil_tmp___1;
        } else {
#line 316
          obj = (void *)1;
        }
#line 318
        success = 1;
      }
    }
#line 323
    if (success) {
#line 324
      r->pos = (unsigned int )((unsigned long )r->pos + bytelen);
#line 327
      if (r->ridx == 0) {
#line 327
        r->reply = obj;
      }
#line 328
      moveToNextTask(r);
#line 329
      return (0);
    }
  }
#line 332
  return (-1);
}
}
#line 335 "hiredis.c"
static int processMultiBulkItem(redisReader *r ) 
{ redisReadTask *cur ;
  void *obj ;
  char *p ;
  long elements ;
  int root ;
  sds __cil_tmp ;
  sds __cil_tmp___0 ;
  long long __cil_tmp___1 ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;

  {
#line 336
  cur = & r->rstack[r->ridx];
#line 340
  root = 0;
#line 343
  if (r->ridx == 2) {
#line 344
    __cil_tmp = sdsempty();
#line 344
    __cil_tmp___0 = sdscatprintf(__cil_tmp, "No support for nested multi bulk replies with depth > 1");
#line 344
    redisSetReplyReaderError(r, __cil_tmp___0);
#line 346
    return (-1);
  }
#line 349
  p = readLine(r, (int *)((void *)0));
#line 349
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 350
    __cil_tmp___1 = readLongLong(p);
#line 350
    elements = (long )__cil_tmp___1;
#line 351
    root = r->ridx == 0;
#line 353
    if (elements == -1L) {
#line 354
      if (r->fn) {
#line 354
        __cil_tmp___2 = (*((r->fn)->createNil))((redisReadTask const   *)cur);
#line 354
        obj = __cil_tmp___2;
      } else {
#line 354
        obj = (void *)4;
      }
#line 356
      moveToNextTask(r);
    } else {
#line 358
      if (r->fn) {
#line 358
        __cil_tmp___3 = (*((r->fn)->createArray))((redisReadTask const   *)cur, (int )elements);
#line 358
        obj = __cil_tmp___3;
      } else {
#line 358
        obj = (void *)2;
      }
#line 362
      if (elements > 0L) {
#line 363
        cur->elements = (int )elements;
#line 364
        cur->obj = obj;
#line 365
        (r->ridx) ++;
#line 366
        r->rstack[r->ridx].type = -1;
#line 367
        r->rstack[r->ridx].elements = -1;
#line 368
        r->rstack[r->ridx].idx = 0;
#line 369
        r->rstack[r->ridx].obj = (void *)0;
#line 370
        r->rstack[r->ridx].parent = cur;
#line 371
        r->rstack[r->ridx].privdata = r->privdata;
      } else {
#line 373
        moveToNextTask(r);
      }
    }
#line 378
    if (root) {
#line 378
      r->reply = obj;
    }
#line 379
    return (0);
  }
#line 381
  return (-1);
}
}
#line 384 "hiredis.c"
static int processItem(redisReader *r ) 
{ redisReadTask *cur ;
  char *p ;
  sds byte ;
  sds __cil_tmp ;
  sds __cil_tmp___0 ;
  sds __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 385
  cur = & r->rstack[r->ridx];
#line 390
  if (cur->type < 0) {
#line 391
    p = readBytes(r, 1U);
#line 391
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 392
      switch ((int )*(p + 0)) {
      case 45: 
#line 394
      cur->type = 6;
#line 395
      break;
      case 43: 
#line 397
      cur->type = 5;
#line 398
      break;
      case 58: 
#line 400
      cur->type = 3;
#line 401
      break;
      case 36: 
#line 403
      cur->type = 1;
#line 404
      break;
      case 42: 
#line 406
      cur->type = 2;
#line 407
      break;
      default: 
#line 409
      __cil_tmp = sdsempty();
#line 409
      byte = sdscatrepr(__cil_tmp, p, 1U);
#line 410
      __cil_tmp___0 = sdsempty();
#line 410
      __cil_tmp___1 = sdscatprintf(__cil_tmp___0, "Protocol error, got %s as reply type byte",
                                   byte);
#line 410
      redisSetReplyReaderError(r, __cil_tmp___1);
#line 412
      sdsfree(byte);
#line 413
      return (-1);
      }
    } else {
#line 417
      return (-1);
    }
  }
#line 422
  switch (cur->type) {
  case 6: 
  case 5: 
  case 3: 
#line 426
  __cil_tmp___2 = processLineItem(r);
#line 426
  return (__cil_tmp___2);
  case 1: 
#line 428
  __cil_tmp___3 = processBulkItem(r);
#line 428
  return (__cil_tmp___3);
  case 2: 
#line 430
  __cil_tmp___4 = processMultiBulkItem(r);
#line 430
  return (__cil_tmp___4);
  default: 
#line 432
  __libc_failwith((char *)"Assertion failed: NULL at hiredis.c:432");
#line 433
  return (-1);
  }
}
}
#line 437 "hiredis.c"
void *redisReplyReaderCreate(void) 
{ redisReader *r ;
  void *__cil_tmp ;

  {
#line 438
  __cil_tmp = calloc((unsigned int )sizeof(redisReader ), 1U);
#line 438
  r = (redisReader *)__cil_tmp;
#line 439
  r->error = (char *)((void *)0);
#line 440
  r->fn = & defaultFunctions;
#line 441
  r->buf = sdsempty();
#line 442
  r->ridx = -1;
#line 443
  return ((void *)r);
}
}
#line 448 "hiredis.c"
int redisReplyReaderSetReplyObjectFunctions(void *reader , redisReplyObjectFunctions *fn ) 
{ redisReader *r ;

  {
#line 449
  r = (redisReader *)reader;
#line 450
  if ((unsigned int )r->reply == (unsigned int )((void *)0)) {
#line 451
    r->fn = fn;
#line 452
    return (0);
  }
#line 454
  return (-1);
}
}
#line 488 "hiredis.c"
static void redisSetReplyReaderError(redisReader *r , sds err ) 
{ 

  {
#line 489
  if ((unsigned int )r->reply != (unsigned int )((void *)0)) {
#line 490
    (*((r->fn)->freeObject))(r->reply);
  }
#line 493
  if ((unsigned int )r->buf != (unsigned int )((void *)0)) {
#line 494
    sdsfree(r->buf);
#line 495
    r->buf = sdsempty();
#line 496
    r->pos = 0U;
  }
#line 498
  r->ridx = -1;
#line 499
  r->error = err;
#line 500
  return;
}
}
#line 507 "hiredis.c"
void redisReplyReaderFeed(void *reader , char *buf , size_t len ) 
{ redisReader *r ;

  {
#line 508
  r = (redisReader *)reader;
#line 511
  if ((unsigned int )buf != (unsigned int )((void *)0) && len >= 1U) {
#line 512
    r->buf = sdscatlen(r->buf, (void const   *)buf, len);
#line 513
    r->len = sdslen(r->buf);
  }
#line 515
  return;
}
}
#line 517 "hiredis.c"
int redisReplyReaderGetReply(void *reader , void **reply ) 
{ redisReader *r ;
  int __cil_tmp ;
  void *aux ;
  size_t __cil_tmp___0 ;

  {
#line 518
  r = (redisReader *)reader;
#line 519
  if ((unsigned int )reply != (unsigned int )((void *)0)) {
#line 519
    *reply = (void *)0;
  }
#line 522
  if (r->len == 0U) {
#line 523
    return (0);
  }
#line 526
  if (r->ridx == -1) {
#line 527
    r->rstack[0].type = -1;
#line 528
    r->rstack[0].elements = -1;
#line 529
    r->rstack[0].idx = -1;
#line 530
    r->rstack[0].obj = (void *)0;
#line 531
    r->rstack[0].parent = (struct redisReadTask *)((void *)0);
#line 532
    r->rstack[0].privdata = r->privdata;
#line 533
    r->ridx = 0;
  }
#line 537
  while (r->ridx >= 0) {
#line 538
    __cil_tmp = processItem(r);
#line 538
    if (__cil_tmp < 0) {
#line 539
      break;
    }
  }
#line 542
  if (r->pos > 0U) {
#line 543
    if (r->pos == r->len) {
#line 545
      sdsfree(r->buf);
#line 546
      r->buf = sdsempty();
    } else {
#line 548
      r->buf = sdsrange(r->buf, (int )r->pos, (int )r->len);
    }
#line 550
    r->pos = 0U;
#line 551
    r->len = sdslen(r->buf);
  }
#line 555
  if (r->ridx == -1) {
#line 556
    aux = r->reply;
#line 557
    r->reply = (void *)0;
#line 560
    if (r->len == 0U) {
#line 560
      __cil_tmp___0 = sdsavail(r->buf);
#line 560
      if (__cil_tmp___0 > 16384U) {
#line 561
        sdsfree(r->buf);
#line 562
        r->buf = sdsempty();
#line 563
        r->pos = 0U;
      }
    }
#line 567
    if ((unsigned int )r->error != (unsigned int )((void *)0)) {
#line 568
      return (-1);
    } else
#line 570
    if ((unsigned int )reply != (unsigned int )((void *)0)) {
#line 570
      *reply = aux;
    }
  }
#line 573
  return (0);
}
}
#line 577 "hiredis.c"
static int intlen(int i ) 
{ int len ;

  {
#line 578
  len = 0;
#line 579
  if (i < 0) {
#line 580
    len ++;
#line 581
    i = - i;
  }
#line 583
  while (1) {
#line 584
    len ++;
#line 585
    i /= 10;
#line 583
    if (! i) {
#line 583
      break;
    }
  }
#line 587
  return (len);
}
}
#line 591 "hiredis.c"
static void addArgument(sds a , char ***argv , int *argc , int *totlen ) 
{ char **__cil_tmp ;
  void *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  size_t __cil_tmp___3 ;

  {
#line 592
  (*argc) ++;
#line 593
  __cil_tmp___0 = realloc((void *)*argv, (unsigned int )(sizeof(char *) * (unsigned long )*argc));
#line 593
  __cil_tmp = (char **)__cil_tmp___0;
#line 593
  *argv = __cil_tmp;
#line 593
  if ((unsigned int )__cil_tmp == (unsigned int )((void *)0)) {
#line 593
    redisOOM();
  }
#line 594
  if (totlen) {
#line 594
    __cil_tmp___1 = sdslen(a);
#line 594
    __cil_tmp___2 = intlen((int )__cil_tmp___1);
#line 594
    __cil_tmp___3 = sdslen(a);
#line 594
    *totlen = (int )(((unsigned int )(((*totlen + 1) + __cil_tmp___2) + 2) + __cil_tmp___3) + 2U);
  }
#line 595
  *(*argv + (*argc - 1)) = a;
#line 596
  return;
}
}
#line 598 "hiredis.c"
int redisvFormatCommand(char **target , char const   *format , va_list ap ) 
{ size_t size ;
  char const   *arg ;
  char const   *c ;
  char *cmd ;
  int pos ;
  sds current ;
  int interpolated ;
  char **argv ;
  int argc ;
  int j ;
  int totlen ;
  size_t __cil_tmp ;
  char _format[16] ;
  char const   *_p ;
  size_t _l ;
  va_list _cpy ;
  char *__cil_tmp___0 ;
  size_t __cil_tmp___2 ;
  int __cil_tmp___3 ;
  void *__cil_tmp___4 ;
  size_t __cil_tmp___5 ;
  int __cil_tmp___6 ;
  size_t __cil_tmp___7 ;
  size_t __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;

  {
#line 600
  c = format;
#line 601
  cmd = (char *)((void *)0);
#line 604
  interpolated = 0;
#line 605
  argv = (char **)((void *)0);
#line 606
  argc = 0;
#line 607
  totlen = 0;
#line 610
  if ((unsigned int )target == (unsigned int )((void *)0)) {
#line 611
    return (-1);
  }
#line 614
  current = sdsempty();
#line 615
  while ((int const   )*c != 0) {
#line 616
    if ((int const   )*c != 37 || (int const   )*(c + 1) == 0) {
#line 617
      if ((int const   )*c == 32) {
#line 618
        __cil_tmp = sdslen(current);
#line 618
        if (__cil_tmp != 0U) {
#line 619
          addArgument(current, & argv, & argc, & totlen);
#line 620
          current = sdsempty();
#line 621
          interpolated = 0;
        }
      } else {
#line 624
        current = sdscatlen(current, (void const   *)c, 1U);
      }
    } else {
#line 627
      switch ((int )*(c + 1)) {
      case 115: 
#line 629
      arg = __builtin_va_arg(ap, char *);
#line 630
      size = strlen(arg);
#line 631
      if (size > 0U) {
#line 632
        current = sdscatlen(current, (void const   *)arg, size);
      }
#line 633
      interpolated = 1;
#line 634
      break;
      case 98: 
#line 636
      arg = __builtin_va_arg(ap, char *);
#line 637
      size = __builtin_va_arg(ap, size_t );
#line 638
      if (size > 0U) {
#line 639
        current = sdscatlen(current, (void const   *)arg, size);
      }
#line 640
      interpolated = 1;
#line 641
      break;
      case 37: 
#line 643
      current = sdscat(current, "%");
#line 644
      break;
      default: 
#line 649
      _p = c + 1;
#line 650
      _l = 0U;
#line 654
      if ((int const   )*_p != 0 && (int const   )*_p == 35) {
#line 654
        _p ++;
      }
#line 655
      if ((int const   )*_p != 0 && (int const   )*_p == 48) {
#line 655
        _p ++;
      }
#line 656
      if ((int const   )*_p != 0 && (int const   )*_p == 45) {
#line 656
        _p ++;
      }
#line 657
      if ((int const   )*_p != 0 && (int const   )*_p == 32) {
#line 657
        _p ++;
      }
#line 658
      if ((int const   )*_p != 0 && (int const   )*_p == 43) {
#line 658
        _p ++;
      }
#line 661
      while ((int const   )*_p != 0 && (int const   )*((__ctype_ptr__ + sizeof(*("" + (int const   )*_p))) + (int )*_p) & 4) {
#line 661
        _p ++;
      }
#line 664
      if ((int const   )*_p == 46) {
#line 665
        _p ++;
#line 666
        while ((int const   )*_p != 0 && (int const   )*((__ctype_ptr__ + sizeof(*("" + (int const   )*_p))) + (int )*_p) & 4) {
#line 666
          _p ++;
        }
      }
#line 670
      if ((int const   )*_p != 0) {
#line 671
        if ((int const   )*_p == 104 || (int const   )*_p == 108) {
#line 673
          if ((int const   )*(_p + 0) == (int const   )*(_p + 1)) {
#line 673
            _p ++;
          }
#line 674
          _p ++;
        }
      }
#line 679
      if ((int const   )*_p != 0) {
#line 679
        __cil_tmp___0 = strchr("diouxXeEfFgGaA", (int )*_p);
#line 679
        if ((unsigned int )__cil_tmp___0 != (unsigned int )((void *)0)) {
#line 680
          _l = (unsigned int )((_p + 1) - c);
#line 681
          if ((unsigned long )_l < sizeof(_format) - 2UL) {
#line 682
            memcpy((void *)(_format), (void const   *)c, _l);
#line 683
            _format[_l] = (char )'\000';
#line 684
            __builtin_va_copy(_cpy, ap);
#line 685
            current = sdscatvprintf(current, (char const   *)(_format), _cpy);
#line 686
            interpolated = 1;
#line 687
            __builtin_va_end(_cpy);
#line 691
            c = _p - 1;
          }
        }
      }
#line 696
      __builtin_va_arg(ap, void *);
      }
#line 699
      c ++;
    }
#line 701
    c ++;
  }
#line 705
  if (interpolated) {
#line 706
    addArgument(current, & argv, & argc, & totlen);
  } else {
#line 705
    __cil_tmp___2 = sdslen(current);
#line 705
    if (__cil_tmp___2 != 0U) {
#line 706
      addArgument(current, & argv, & argc, & totlen);
    } else {
#line 708
      sdsfree(current);
    }
  }
#line 712
  __cil_tmp___3 = intlen(argc);
#line 712
  totlen += (1 + __cil_tmp___3) + 2;
#line 715
  __cil_tmp___4 = malloc((unsigned int )(totlen + 1));
#line 715
  cmd = (char *)__cil_tmp___4;
#line 716
  if (! cmd) {
#line 716
    redisOOM();
  }
#line 717
  pos = sprintf(cmd, "*%d\r\n", argc);
#line 718
  j = 0;
#line 718
  while (j < argc) {
#line 719
    __cil_tmp___5 = sdslen(*(argv + j));
#line 719
    __cil_tmp___6 = sprintf(cmd + pos, "$%zu\r\n", __cil_tmp___5);
#line 719
    pos += __cil_tmp___6;
#line 720
    __cil_tmp___7 = sdslen(*(argv + j));
#line 720
    memcpy((void *)(cmd + pos), (void const   *)*(argv + j), __cil_tmp___7);
#line 721
    __cil_tmp___8 = sdslen(*(argv + j));
#line 721
    pos = (int )((unsigned int )pos + __cil_tmp___8);
#line 722
    sdsfree(*(argv + j));
#line 723
    __cil_tmp___9 = pos;
#line 723
    pos ++;
#line 723
    *(cmd + __cil_tmp___9) = (char )'\r';
#line 724
    __cil_tmp___10 = pos;
#line 724
    pos ++;
#line 724
    *(cmd + __cil_tmp___10) = (char )'\n';
#line 718
    j ++;
  }
#line 726
  if ((pos == totlen) == 0) {
#line 726
    __libc_failwith((char *)"Assertion failed: pos == totlen at hiredis.c:726");
  }
#line 727
  free((void *)argv);
#line 728
  *(cmd + totlen) = (char )'\000';
#line 729
  *target = cmd;
#line 730
  return (totlen);
}
}
#line 790 "hiredis.c"
void __redisSetError(redisContext *c , int type , sds errstr ) 
{ int *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 791
  c->err = type;
#line 792
  if ((unsigned int )errstr != (unsigned int )((void *)0)) {
#line 793
    c->errstr = errstr;
  } else {
#line 796
    if ((type == 1) == 0) {
#line 796
      __libc_failwith((char *)"Assertion failed: type == REDIS_ERR_IO at hiredis.c:796");
    }
#line 797
    __cil_tmp = __errno();
#line 797
    __cil_tmp___0 = strerror(*__cil_tmp);
#line 797
    c->errstr = sdsnew((char const   *)__cil_tmp___0);
  }
#line 799
  return;
}
}
#line 801 "hiredis.c"
static redisContext *redisContextInit(void) 
{ redisContext *c ;
  void *__cil_tmp ;

  {
#line 802
  __cil_tmp = calloc((unsigned int )sizeof(redisContext ), 1U);
#line 802
  c = (redisContext *)__cil_tmp;
#line 803
  c->err = 0;
#line 804
  c->errstr = (char *)((void *)0);
#line 805
  c->obuf = sdsempty();
#line 806
  c->fn = & defaultFunctions;
#line 807
  c->reader = (void *)0;
#line 808
  return (c);
}
}
#line 827 "hiredis.c"
redisContext *redisConnect(char const   *ip , int port ) 
{ redisContext *c ;
  redisContext *__cil_tmp ;

  {
#line 828
  __cil_tmp = redisContextInit();
#line 828
  c = __cil_tmp;
#line 829
  c->flags |= 1;
#line 830
  redisContextConnectTcp(c, ip, port);
#line 831
  return (c);
}
}
#line 866 "hiredis.c"
static void __redisCreateReplyReader(redisContext *c ) 
{ int __cil_tmp ;

  {
#line 867
  if ((unsigned int )c->reader == (unsigned int )((void *)0)) {
#line 868
    c->reader = redisReplyReaderCreate();
#line 869
    __cil_tmp = redisReplyReaderSetReplyObjectFunctions(c->reader, c->fn);
#line 869
    if ((__cil_tmp == 0) == 0) {
#line 869
      __libc_failwith((char *)"Assertion failed: redisReplyReaderSetReplyObjectFunctions(c->reader,c->fn) == REDIS_OK at hiredis.c:869");
    }
  }
#line 871
  return;
}
}
#line 878 "hiredis.c"
int redisBufferRead(redisContext *c ) 
{ char buf[2048] ;
  int nread ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  sds __cil_tmp___1 ;

  {
#line 880
  __cil_tmp = read(c->fd, (void *)(buf), (unsigned int )sizeof(buf));
#line 880
  nread = __cil_tmp;
#line 881
  if (nread == -1) {
#line 882
    __cil_tmp___0 = __errno();
#line 882
    if (! (*__cil_tmp___0 == 11)) {
#line 885
      __redisSetError(c, 1, (char *)((void *)0));
#line 886
      return (-1);
    }
  } else
#line 888
  if (nread == 0) {
#line 889
    __cil_tmp___1 = sdsnew("Server closed the connection");
#line 889
    __redisSetError(c, 3, __cil_tmp___1);
#line 891
    return (-1);
  } else {
#line 893
    __redisCreateReplyReader(c);
#line 894
    redisReplyReaderFeed(c->reader, buf, (unsigned int )nread);
  }
#line 896
  return (0);
}
}
#line 908 "hiredis.c"
int redisBufferWrite(redisContext *c , int *done ) 
{ int nwritten ;
  size_t __cil_tmp ;
  int *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  size_t __cil_tmp___3 ;

  {
#line 910
  __cil_tmp___2 = sdslen(c->obuf);
#line 910
  if (__cil_tmp___2 > 0U) {
#line 911
    __cil_tmp = sdslen(c->obuf);
#line 911
    nwritten = write(c->fd, (void const   *)c->obuf, __cil_tmp);
#line 912
    if (nwritten == -1) {
#line 913
      __cil_tmp___0 = __errno();
#line 913
      if (! (*__cil_tmp___0 == 11)) {
#line 916
        __redisSetError(c, 1, (char *)((void *)0));
#line 917
        return (-1);
      }
    } else
#line 919
    if (nwritten > 0) {
#line 920
      __cil_tmp___1 = sdslen(c->obuf);
#line 920
      if (nwritten == (int )__cil_tmp___1) {
#line 921
        sdsfree(c->obuf);
#line 922
        c->obuf = sdsempty();
      } else {
#line 924
        c->obuf = sdsrange(c->obuf, nwritten, -1);
      }
    }
  }
#line 928
  if ((unsigned int )done != (unsigned int )((void *)0)) {
#line 928
    __cil_tmp___3 = sdslen(c->obuf);
#line 928
    *done = __cil_tmp___3 == 0U;
  }
#line 929
  return (0);
}
}
#line 934 "hiredis.c"
int redisGetReplyFromReader(redisContext *c , void **reply ) 
{ sds __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 935
  __redisCreateReplyReader(c);
#line 936
  __cil_tmp___0 = redisReplyReaderGetReply(c->reader, reply);
#line 936
  if (__cil_tmp___0 == -1) {
#line 937
    __cil_tmp = sdsnew((char const   *)((redisReader *)c->reader)->error);
#line 937
    __redisSetError(c, 4, __cil_tmp);
#line 939
    return (-1);
  }
#line 941
  return (0);
}
}
#line 944 "hiredis.c"
int redisGetReply(redisContext *c , void **reply ) 
{ int wdone ;
  void *aux ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 945
  wdone = 0;
#line 946
  aux = (void *)0;
#line 949
  __cil_tmp = redisGetReplyFromReader(c, & aux);
#line 949
  if (__cil_tmp == -1) {
#line 950
    return (-1);
  }
#line 953
  if ((unsigned int )aux == (unsigned int )((void *)0) && c->flags & 1) {
#line 955
    while (1) {
#line 956
      __cil_tmp___0 = redisBufferWrite(c, & wdone);
#line 956
      if (__cil_tmp___0 == -1) {
#line 957
        return (-1);
      }
#line 955
      if (! (! wdone)) {
#line 955
        break;
      }
    }
#line 961
    while (1) {
#line 962
      __cil_tmp___1 = redisBufferRead(c);
#line 962
      if (__cil_tmp___1 == -1) {
#line 963
        return (-1);
      }
#line 964
      __cil_tmp___2 = redisGetReplyFromReader(c, & aux);
#line 964
      if (__cil_tmp___2 == -1) {
#line 965
        return (-1);
      }
#line 961
      if (! ((unsigned int )aux == (unsigned int )((void *)0))) {
#line 961
        break;
      }
    }
  }
#line 970
  if ((unsigned int )reply != (unsigned int )((void *)0)) {
#line 970
    *reply = aux;
  }
#line 971
  return (0);
}
}
#line 981 "hiredis.c"
void __redisAppendCommand(redisContext *c , char *cmd , size_t len ) 
{ 

  {
#line 982
  c->obuf = sdscatlen(c->obuf, (void const   *)cmd, len);
#line 983
  return;
}
}
#line 1019 "hiredis.c"
static void *__redisCommand(redisContext *c , char *cmd , size_t len ) 
{ void *aux ;
  int __cil_tmp ;

  {
#line 1020
  aux = (void *)0;
#line 1021
  __redisAppendCommand(c, cmd, len);
#line 1023
  if (c->flags & 1) {
#line 1024
    __cil_tmp = redisGetReply(c, & aux);
#line 1024
    if (__cil_tmp == 0) {
#line 1025
      return (aux);
    }
#line 1026
    return ((void *)0);
  }
#line 1028
  return ((void *)0);
}
}
#line 1031 "hiredis.c"
void *redisvCommand(redisContext *c , char const   *format , va_list ap ) 
{ char *cmd ;
  int len ;
  void *reply ;

  {
#line 1034
  reply = (void *)0;
#line 1035
  len = redisvFormatCommand(& cmd, format, ap);
#line 1036
  reply = __redisCommand(c, cmd, (unsigned int )len);
#line 1037
  free((void *)cmd);
#line 1038
  return (reply);
}
}
#line 1041 "hiredis.c"
void *redisCommand(redisContext *c , char const   *format  , ...) 
{ va_list ap ;
  void *reply ;

  {
#line 1043
  reply = (void *)0;
#line 1044
  __builtin_va_start(ap, format);
#line 1045
  reply = redisvCommand(c, format, ap);
#line 1046
  __builtin_va_end(ap);
#line 1047
  return (reply);
}
}
#line 1 "sds.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-s0jJ92wE.i","-std=c99,-pedantic,-O3,-fPIC,-Wall,-W,-Wwrite-strings,-g,-ggdb")
#line 1 "async.o"
#pragma merger(0,"/var/folders/um/umjUk6OtFFOwiTTOJ1ILQ++++TM/-Tmp-/cil-eybLyhid.i","-std=c99,-pedantic,-O3,-fPIC,-Wall,-W,-Wwrite-strings,-g,-ggdb")
