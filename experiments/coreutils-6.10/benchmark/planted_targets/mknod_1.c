/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 11 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/stddef.h"
typedef int wint_t;
#line 7 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/lock.h"
typedef int _LOCK_RECURSIVE_T;
#line 24 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef short __dev_t;
#line 44 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef long _fpos_t;
#line 67 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
union __anonunion___value_2 {
   wint_t __wch ;
   unsigned char __wchb[4] ;
};
#line 67 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
struct __anonstruct__mbstate_t_1 {
   int __count ;
   union __anonunion___value_2 __value ;
};
#line 67 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef struct __anonstruct__mbstate_t_1 _mbstate_t;
#line 79 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef _LOCK_RECURSIVE_T _flock_t;
#line 21 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
typedef unsigned long __ULong;
#line 37
struct _reent;
#line 44 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _Bigint {
   struct _Bigint *_next ;
   int _k ;
   int _maxwds ;
   int _sign ;
   int _wds ;
   __ULong _x[1] ;
};
#line 52 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct __tm {
   int __tm_sec ;
   int __tm_min ;
   int __tm_hour ;
   int __tm_mday ;
   int __tm_mon ;
   int __tm_year ;
   int __tm_wday ;
   int __tm_yday ;
   int __tm_isdst ;
};
#line 71 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _on_exit_args {
   void *_fnargs[32] ;
   void *_dso_handle[32] ;
   __ULong _fntypes ;
   __ULong _is_cxa ;
};
#line 82 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _atexit {
   struct _atexit *_next ;
   int _ind ;
   void (*_fns[32])(void) ;
   struct _on_exit_args *_on_exit_args_ptr ;
};
#line 105 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct __sbuf {
   unsigned char *_base ;
   int _size ;
};
#line 169 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct __sFILE {
   unsigned char *_p ;
   int _r ;
   int _w ;
   short _flags ;
   short _file ;
   struct __sbuf _bf ;
   int _lbfsize ;
   struct _reent *_data ;
   void *_cookie ;
   int (*_read)(struct _reent * , void * , char * , int  ) ;
   int (*_write)(struct _reent * , void * , char const   * , int  ) ;
   _fpos_t (*_seek)(struct _reent * , void * , _fpos_t  , int  ) ;
   int (*_close)(struct _reent * , void * ) ;
   struct __sbuf _ub ;
   unsigned char *_up ;
   int _ur ;
   unsigned char _ubuf[3] ;
   unsigned char _nbuf[1] ;
   struct __sbuf _lb ;
   int _blksize ;
   int _offset ;
   _flock_t _lock ;
   _mbstate_t _mbstate ;
   int _flags2 ;
};
#line 273 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
typedef struct __sFILE __FILE;
#line 277 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _glue {
   struct _glue *_next ;
   int _niobs ;
   __FILE *_iobs ;
};
#line 305 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _rand48 {
   unsigned short _seed[3] ;
   unsigned short _mult[3] ;
   unsigned short _add ;
   unsigned long long _rand_next ;
};
#line 330 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _mprec {
   struct _Bigint *_result ;
   int _result_k ;
   struct _Bigint *_p5s ;
   struct _Bigint **_freelist ;
};
#line 340 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _misc_reent {
   char *_strtok_last ;
   _mbstate_t _mblen_state ;
   _mbstate_t _wctomb_state ;
   _mbstate_t _mbtowc_state ;
   char _l64a_buf[8] ;
   int _getdate_err ;
   _mbstate_t _mbrlen_state ;
   _mbstate_t _mbrtowc_state ;
   _mbstate_t _mbsrtowcs_state ;
   _mbstate_t _wcrtomb_state ;
   _mbstate_t _wcsrtombs_state ;
};
#line 358 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
struct _reent {
   int _errno ;
   __FILE *_stdin ;
   __FILE *_stdout ;
   __FILE *_stderr ;
   int _inc ;
   char *_emergency ;
   int __sdidinit ;
   int _current_category ;
   char const   *_current_locale ;
   struct _mprec *_mp ;
   void (*__cleanup)(struct _reent * ) ;
   int _gamma_signgam ;
   int _cvtlen ;
   char *_cvtbuf ;
   struct _rand48 *_r48 ;
   struct __tm *_localtime_buf ;
   char *_asctime_buf ;
   void (**_sig_func)(int  ) ;
   struct _atexit *_atexit ;
   struct _atexit _atexit0 ;
   struct _glue __sglue ;
   __FILE *__sf ;
   struct _misc_reent *_misc ;
   char *_signal_buf ;
};
#line 163 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef __dev_t dev_t;
#line 195 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned int mode_t;
#line 50 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
typedef __FILE FILE;
#line 161 "../lib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 126 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/socket.h"
struct __otter_fs_open_file_table_entry;
#line 24 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_inode;
#line 25
struct __otter_fs_filelist;
#line 26
struct __otter_fs_dirlist;
#line 27
struct __otter_fs_dnode;
#line 29 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_inode {
   int linkno ;
   int size ;
   int numblocks ;
   int type ;
   int permissions ;
   char *data ;
   int r_openno ;
   int w_openno ;
};
#line 66 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_filelist {
   char *name ;
   struct __otter_fs_inode *inode ;
   struct __otter_fs_filelist *next ;
};
#line 73 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dirlist {
   char *name ;
   struct __otter_fs_dnode *dnode ;
   struct __otter_fs_dirlist *next ;
};
#line 80 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dnode {
   int linkno ;
   int numdirs ;
   int numfiles ;
   struct __otter_fs_dirlist *dirs ;
   struct __otter_fs_filelist *files ;
   int permissions ;
   int r_openno ;
};
#line 104 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_open_file_table_entry {
   int mode ;
   int offset ;
   int type ;
   struct __otter_fs_inode *inode ;
   struct __otter_fs_dnode *dnode ;
   int openno ;
};
#line 25 "../lib/modechange.h"
struct mode_change;
#line 26 "../lib/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "../lib/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 4 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef int _ssize_t;
#line 181 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef _ssize_t ssize_t;
#line 31 "base64.h"
struct base64_decode_context {
   unsigned int i ;
   char buf[4] ;
};
#line 6 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/machine/_types.h"
typedef int blkcnt_t;
#line 7 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/machine/_types.h"
typedef int blksize_t;
#line 16 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef long _off_t;
#line 29 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef unsigned short __uid_t;
#line 32 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/_types.h"
typedef unsigned short __gid_t;
#line 109 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef long time_t;
#line 133 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned short ino_t;
#line 162 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef _off_t off_t;
#line 164 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef __uid_t uid_t;
#line 165 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef __gid_t gid_t;
#line 200 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef unsigned short nlink_t;
#line 101 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct stat;
#line 9 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/stat.h"
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   off_t st_size ;
   time_t st_atime ;
   time_t st_mtime ;
   time_t st_ctime ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
};
#line 54 "hash.h"
struct hash_table;
#line 56 "hash.h"
typedef struct hash_table Hash_table;
#line 9 "hash-triple.h"
struct F_triple {
   char *name ;
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 114 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
#line 33 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
#line 120 "getdate.y"
struct __anonstruct_textint_16 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
#line 120 "getdate.y"
typedef struct __anonstruct_textint_16 textint;
#line 128 "getdate.y"
struct __anonstruct_table_17 {
   char const   *name ;
   int type ;
   int value ;
};
#line 128 "getdate.y"
typedef struct __anonstruct_table_17 table;
#line 141 "getdate.y"
struct __anonstruct_relative_time_20 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long seconds ;
   long ns ;
};
#line 141 "getdate.y"
typedef struct __anonstruct_relative_time_20 relative_time;
#line 160 "getdate.y"
struct __anonstruct_parser_control_21 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
#line 160 "getdate.y"
typedef struct __anonstruct_parser_control_21 parser_control;
#line 205
union YYSTYPE;
#line 322 "getdate.y"
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 322 "getdate.y"
typedef union YYSTYPE YYSTYPE;
#line 419 "getdate.c"
typedef unsigned char yytype_uint8;
#line 426 "getdate.c"
typedef signed char yytype_int8;
#line 440 "getdate.c"
typedef short yytype_int16;
#line 571 "getdate.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 26 "linebuffer.h"
struct linebuffer {
   size_t size ;
   size_t length ;
   char *buffer ;
};
#line 36 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/langinfo.h"
typedef int nl_item;
#line 50 "malloca.c"
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
#line 54 "malloca.c"
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 4U) - 1U) / 4U) * 4U - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
#line 7 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/stddef.h"
typedef short wchar_t;
#line 47 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wchar.h"
typedef _mbstate_t mbstate_t;
#line 161 "mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 109 "mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 202 "mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 25 "randread.h"
struct randread_source;
#line 30 "randint.h"
typedef unsigned long long randint;
#line 33
struct randint_source;
#line 58 "randint.c"
struct randint_source {
   struct randread_source *source ;
   randint randnum ;
   randint randmax ;
};
#line 17 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/stddef.h"
typedef long long ptrdiff_t;
#line 33 "rand-isaac.h"
struct isaac_state {
   unsigned int mm[1 << 8] ;
   unsigned int iv[8] ;
   unsigned int a ;
   unsigned int b ;
   unsigned int c ;
};
#line 73 "randread.c"
union __anonunion_data_13 {
   unsigned int w[1 << 8] ;
   unsigned char b[(unsigned int )(1 << 8) * sizeof(unsigned int )] ;
};
#line 73 "randread.c"
struct isaac {
   size_t buffered ;
   struct isaac_state state ;
   union __anonunion_data_13 data ;
};
#line 73 "randread.c"
union __anonunion_buf_12 {
   char c[2U * ((unsigned int )(1 << 8) * sizeof(unsigned int ))] ;
   struct isaac isaac ;
};
#line 73 "randread.c"
struct randread_source {
   FILE *source ;
   void (*handler)(void const   * ) ;
   void const   *handler_arg ;
   union __anonunion_buf_12 buf ;
};
#line 249 "randread.c"
struct __anonstruct_15 {
   char c ;
   unsigned int x ;
};
#line 171 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef int pid_t;
#line 28 "xtime.h"
typedef long long xtime_t;
#line 142 "obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "obstack.h"
union __anonunion_temp_11 {
   ptrdiff_t tempint ;
   void *tempptr ;
};
#line 149 "obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_11 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 28 "readtokens0.h"
struct Tokens {
   size_t n_tok ;
   char **tok ;
   size_t *tok_len ;
   struct obstack o_data ;
   struct obstack o_tok ;
   struct obstack o_tok_len ;
};
#line 28 "savewd.h"
union __anonunion_val_7 {
   int fd ;
   int errnum ;
   pid_t child ;
};
#line 28
enum __anonenum_state_8 {
    INITIAL_STATE = 0,
    FD_STATE = 1,
    FD_POST_CHDIR_STATE = 2,
    FORKING_STATE = 3,
    ERROR_STATE = 4,
    FINAL_STATE = 5
} ;
#line 28 "savewd.h"
struct savewd {
   enum __anonenum_state_8 state ;
   union __anonunion_val_7 val ;
};
#line 26 "./unitypes.h"
typedef unsigned int ucs4_t;
#line 4 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/stdarg.h"
typedef __builtin_va_list va_list;
#line 27 "quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    escape_quoting_style = 4,
    locale_quoting_style = 5,
    clocale_quoting_style = 6
} ;
#line 28 "backupfile.h"
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
#line 11 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/dirent.h"
struct _dirdesc {
   int dd_fd ;
   long dd_loc ;
   long dd_size ;
   char *dd_buf ;
   int dd_len ;
   long dd_seek ;
};
#line 11 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/dirent.h"
typedef struct _dirdesc DIR;
#line 23
struct dirent;
#line 29 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/dirent.h"
struct dirent {
   long d_ino ;
   off_t d_off ;
   unsigned short d_reclen ;
   char d_name[1] ;
};
#line 153 "backupfile.c"
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
#line 51 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct sockaddr;
#line 73 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/socket.h"
typedef unsigned int socklen_t;
#line 74 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/socket.h"
typedef unsigned short sa_family_t;
#line 78 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 39 "getaddrinfo.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 21 "canonicalize.h"
enum canonicalize_mode_t {
    CAN_EXISTING = 0,
    CAN_ALL_BUT_LAST = 1,
    CAN_MISSING = 2
} ;
#line 32 "canonicalize.h"
typedef enum canonicalize_mode_t canonicalize_mode_t;
#line 40 "hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 52 "hash.h"
typedef struct hash_tuning Hash_tuning;
#line 37 "chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 7 "dev-ino.h"
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 28 "cycle-check.h"
struct cycle_check_state {
   struct dev_ino dev_ino ;
   unsigned long long chdir_counter ;
   int magic ;
};
#line 34 "exclude.h"
struct exclude;
#line 60 "exclude.c"
struct patopts {
   char const   *pattern ;
   int options ;
};
#line 68 "exclude.c"
struct exclude {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 23 "save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 18 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wctype.h"
typedef int wctype_t;
#line 1023 "fnmatch_loop.c"
struct patternlist {
   struct patternlist *next ;
   char str[1] ;
};
#line 1023 "fnmatch_loop.c"
struct patternlist___0 {
   struct patternlist *next ;
   wchar_t str[1] ;
};
#line 31 "i-ring.h"
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
#line 39 "i-ring.h"
typedef struct I_ring I_ring;
#line 68 "fts_.h"
union __anonunion_fts_cycle_11 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
#line 68
struct _ftsent;
#line 68 "fts_.h"
struct __anonstruct_FTS_10 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   union __anonunion_fts_cycle_11 fts_cycle ;
   I_ring fts_fd_ring ;
};
#line 68 "fts_.h"
typedef struct __anonstruct_FTS_10 FTS;
#line 173 "fts_.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[1] ;
};
#line 173 "fts_.h"
typedef struct _ftsent FTSENT;
#line 24 "fts-cycle.c"
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
#line 39 "gai_strerror.c"
struct __anonstruct_values_12 {
   int code ;
   char const   *msg ;
};
#line 39 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netinet/in.h"
typedef unsigned short in_port_t;
#line 40 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netinet/in.h"
typedef unsigned int in_addr_t;
#line 13 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/arpa/inet.h"
struct in_addr;
#line 44 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 51 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[8] ;
};
#line 59 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netinet/in.h"
union __anonunion_in6_u_7 {
   unsigned char u6_addr8[16] ;
   unsigned short u6_addr16[8] ;
   unsigned int u6_addr32[4] ;
};
#line 59 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_7 in6_u ;
};
#line 78 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   int sin6_flowinfo ;
   struct in6_addr sin6_addr ;
};
#line 6 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 33 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 137 "getaddrinfo.c"
struct v6_pair {
   struct addrinfo addrinfo ;
   struct sockaddr_in6 sockaddr_in6 ;
};
#line 143 "getaddrinfo.c"
struct v4_pair {
   struct addrinfo addrinfo ;
   struct sockaddr_in sockaddr_in ;
};
#line 11 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 32 "getopt_int.h"
enum __anonenum___ordering_11 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 32 "getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __anonenum___ordering_11 __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 96 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/termios.h"
typedef unsigned char cc_t;
#line 97 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/termios.h"
typedef unsigned short tcflag_t;
#line 98 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/termios.h"
typedef char speed_t;
#line 100 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   char c_line ;
   cc_t c_cc[13] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 8 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/termios.h"
struct __anonstruct__TERMIOS_TABLE_11 {
   struct termios mode ;
   int has_set ;
};
#line 263 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef long suseconds_t;
#line 17 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/time.h"
struct timeval {
   time_t tv_sec ;
   suseconds_t tv_usec ;
};
#line 6 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/grp.h"
struct group {
   char *gr_name ;
   gid_t gr_gid ;
   char **gr_mem ;
};
#line 34 "hash.h"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 49 "hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 26 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_p_sign_posn ;
};
#line 6 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/pwd.h"
struct passwd {
   char *pw_name ;
   uid_t pw_uid ;
   gid_t pw_gid ;
   char *pw_dir ;
   char *pw_shell ;
   char *pw_passwd ;
};
#line 36 "idcache.c"
union __anonunion_id_12 {
   uid_t u ;
   gid_t g ;
};
#line 36 "idcache.c"
struct userid {
   union __anonunion_id_12 id ;
   struct userid *next ;
   char name[] ;
};
#line 146 "inet_ntop.c"
struct __anonstruct_best_9 {
   int base ;
   int len ;
};
#line 68 "isnan.c"
union __anonunion_memory_double_3 {
   double value ;
   unsigned int word[((sizeof(double ) + sizeof(unsigned int )) - 1U) / sizeof(unsigned int )] ;
};
#line 68 "isnan.c"
typedef union __anonunion_memory_double_3 memory_double;
#line 68 "isnan.c"
union __anonunion_memory_double_3___0 {
   float value ;
   unsigned int word[((sizeof(float ) + sizeof(unsigned int )) - 1U) / sizeof(unsigned int )] ;
};
#line 68 "isnan.c"
typedef union __anonunion_memory_double_3___0 memory_double___0;
#line 60 "md5.h"
struct md5_ctx {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int total[2] ;
   unsigned int buflen ;
   unsigned int buffer[32] ;
};
#line 250 "md5.c"
struct __anonstruct_12 {
   char c ;
   unsigned int x ;
};
#line 53 "memcmp.c"
typedef unsigned char byte;
#line 98 "modechange.c"
struct mode_change {
   char op ;
   char flag ;
   mode_t affected ;
   mode_t value ;
   mode_t mentioned ;
};
#line 26 "mountlist.h"
struct mount_entry {
   char *me_devname ;
   char *me_mountdir ;
   char *me_type ;
   dev_t me_dev ;
   unsigned int me_dummy : 1 ;
   unsigned int me_remote : 1 ;
   unsigned int me_type_malloced : 1 ;
   struct mount_entry *me_next ;
};
#line 51 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 222 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef long fd_mask;
#line 230 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
struct _types_fd_set {
   fd_mask fds_bits[(64U + (sizeof(fd_mask ) * 8U - 1U)) / (sizeof(fd_mask ) * 8U)] ;
};
#line 230 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/types.h"
typedef struct _types_fd_set _types_fd_set;
#line 15 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/signal.h"
typedef unsigned long sigset_t;
#line 110 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/signal.h"
struct sigaction {
   void (*sa_handler)(int  ) ;
   sigset_t sa_mask ;
   int sa_flags ;
};
#line 9 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/signal.h"
typedef int sig_atomic_t;
#line 51 "printf-args.h"
enum __anonenum_arg_type_8 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 51 "printf-args.h"
typedef enum __anonenum_arg_type_8 arg_type;
#line 93 "printf-args.h"
union __anonunion_a_10 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 93 "printf-args.h"
struct __anonstruct_argument_9 {
   arg_type type ;
   union __anonunion_a_10 a ;
};
#line 93 "printf-args.h"
typedef struct __anonstruct_argument_9 argument;
#line 140 "printf-args.h"
struct __anonstruct_arguments_11 {
   size_t count ;
   argument *arg ;
};
#line 140 "printf-args.h"
typedef struct __anonstruct_arguments_11 arguments;
#line 45 "printf-parse.h"
struct __anonstruct_char_directive_12 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 45 "printf-parse.h"
typedef struct __anonstruct_char_directive_12 char_directive;
#line 62 "printf-parse.h"
struct __anonstruct_char_directives_13 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
};
#line 62 "printf-parse.h"
typedef struct __anonstruct_char_directives_13 char_directives;
#line 65 "quotearg.h"
struct quoting_options;
#line 63 "quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   unsigned int quote_these_too[255U / (sizeof(int ) * 8U) + 1U] ;
};
#line 551 "quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 25 "readtokens.h"
struct tokenbuffer {
   size_t size ;
   char *buffer ;
};
#line 30 "readtokens.h"
typedef struct tokenbuffer token_buffer;
#line 58 "./regex.h"
typedef ssize_t regoff_t;
#line 63 "./regex.h"
typedef size_t __re_idx_t;
#line 66 "./regex.h"
typedef size_t __re_size_t;
#line 70 "./regex.h"
typedef size_t __re_long_size_t;
#line 96 "./regex.h"
typedef unsigned long reg_syntax_t;
#line 374
enum __anonenum_reg_errcode_t_7 {
    _REG_ENOSYS = -1,
    _REG_NOERROR = 0,
    _REG_NOMATCH = 1,
    _REG_BADPAT = 2,
    _REG_ECOLLATE = 3,
    _REG_ECTYPE = 4,
    _REG_EESCAPE = 5,
    _REG_ESUBREG = 6,
    _REG_EBRACK = 7,
    _REG_EPAREN = 8,
    _REG_EBRACE = 9,
    _REG_BADBR = 10,
    _REG_ERANGE = 11,
    _REG_ESPACE = 12,
    _REG_BADRPT = 13,
    _REG_EEND = 14,
    _REG_ESIZE = 15,
    _REG_ERPAREN = 16
} ;
#line 374 "./regex.h"
typedef enum __anonenum_reg_errcode_t_7 reg_errcode_t;
#line 452 "./regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 520 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 524 "./regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 543 "./regex.h"
struct __anonstruct_regmatch_t_8 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 543 "./regex.h"
typedef struct __anonstruct_regmatch_t_8 regmatch_t;
#line 130 "regex_internal.h"
typedef __re_idx_t Idx;
#line 153 "regex_internal.h"
typedef __re_size_t re_hashval_t;
#line 157 "regex_internal.h"
typedef unsigned long bitset_word_t;
#line 198 "regex_internal.h"
typedef bitset_word_t bitset_t[8];
#line 199 "regex_internal.h"
typedef bitset_word_t *re_bitset_ptr_t;
#line 200 "regex_internal.h"
typedef bitset_word_t const   *re_const_bitset_ptr_t;
#line 213
enum __anonenum_re_context_type_13 {
    INSIDE_WORD = 5,
    WORD_FIRST = 6,
    WORD_LAST = 9,
    INSIDE_NOTWORD = 10,
    LINE_FIRST = 16,
    LINE_LAST = 32,
    BUF_FIRST = 64,
    BUF_LAST = 128,
    WORD_DELIM = 256,
    NOT_WORD_DELIM = 512
} ;
#line 213 "regex_internal.h"
typedef enum __anonenum_re_context_type_13 re_context_type;
#line 227 "regex_internal.h"
struct __anonstruct_re_node_set_14 {
   Idx alloc ;
   Idx nelem ;
   Idx *elems ;
};
#line 227 "regex_internal.h"
typedef struct __anonstruct_re_node_set_14 re_node_set;
#line 234
enum __anonenum_re_token_type_t_15 {
    NON_TYPE = 0,
    CHARACTER = 1,
    END_OF_RE = 2,
    SIMPLE_BRACKET = 3,
    OP_BACK_REF = 4,
    OP_PERIOD = 5,
    COMPLEX_BRACKET = 6,
    OP_UTF8_PERIOD = 7,
    OP_OPEN_SUBEXP = 8,
    OP_CLOSE_SUBEXP = 9,
    OP_ALT = 10,
    OP_DUP_ASTERISK = 11,
    ANCHOR = 12,
    CONCAT = 16,
    SUBEXP = 17,
    OP_DUP_PLUS = 18,
    OP_DUP_QUESTION = 19,
    OP_OPEN_BRACKET = 20,
    OP_CLOSE_BRACKET = 21,
    OP_CHARSET_RANGE = 22,
    OP_OPEN_DUP_NUM = 23,
    OP_CLOSE_DUP_NUM = 24,
    OP_NON_MATCH_LIST = 25,
    OP_OPEN_COLL_ELEM = 26,
    OP_CLOSE_COLL_ELEM = 27,
    OP_OPEN_EQUIV_CLASS = 28,
    OP_CLOSE_EQUIV_CLASS = 29,
    OP_OPEN_CHAR_CLASS = 30,
    OP_CLOSE_CHAR_CLASS = 31,
    OP_WORD = 32,
    OP_NOTWORD = 33,
    OP_SPACE = 34,
    OP_NOTSPACE = 35,
    BACK_SLASH = 36
} ;
#line 234 "regex_internal.h"
typedef enum __anonenum_re_token_type_t_15 re_token_type_t;
#line 286 "regex_internal.h"
struct __anonstruct_re_charset_t_16 {
   wchar_t *mbchars ;
   wchar_t *range_starts ;
   wchar_t *range_ends ;
   wctype_t *char_classes ;
   unsigned int non_match : 1 ;
   Idx nmbchars ;
   Idx ncoll_syms ;
   Idx nequiv_classes ;
   Idx nranges ;
   Idx nchar_classes ;
};
#line 286 "regex_internal.h"
typedef struct __anonstruct_re_charset_t_16 re_charset_t;
#line 333 "regex_internal.h"
union __anonunion_opr_18 {
   unsigned char c ;
   re_bitset_ptr_t sbcset ;
   re_charset_t *mbcset ;
   Idx idx ;
   re_context_type ctx_type ;
};
#line 333 "regex_internal.h"
struct __anonstruct_re_token_t_17 {
   union __anonunion_opr_18 opr ;
   re_token_type_t type ;
   unsigned int constraint : 10 ;
   unsigned int duplicated : 1 ;
   unsigned int opt_subexp : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int mb_partial : 1 ;
   unsigned int word_char : 1 ;
};
#line 333 "regex_internal.h"
typedef struct __anonstruct_re_token_t_17 re_token_t;
#line 364 "regex_internal.h"
struct re_string_t {
   unsigned char const   *raw_mbs ;
   unsigned char *mbs ;
   wint_t *wcs ;
   Idx *offsets ;
   mbstate_t cur_state ;
   Idx raw_mbs_idx ;
   Idx valid_len ;
   Idx valid_raw_len ;
   Idx bufs_len ;
   Idx cur_idx ;
   Idx raw_len ;
   Idx len ;
   Idx raw_stop ;
   Idx stop ;
   unsigned int tip_context ;
   unsigned char *trans ;
   re_const_bitset_ptr_t word_char ;
   unsigned char icase ;
   unsigned char is_utf8 ;
   unsigned char map_notascii ;
   unsigned char mbs_allocated ;
   unsigned char offsets_needed ;
   unsigned char newline_anchor ;
   unsigned char word_ops_used ;
   int mb_cur_max ;
};
#line 419 "regex_internal.h"
typedef struct re_string_t re_string_t;
#line 422
struct re_dfa_t;
#line 423 "regex_internal.h"
typedef struct re_dfa_t re_dfa_t;
#line 486 "regex_internal.h"
struct bin_tree_t {
   struct bin_tree_t *parent ;
   struct bin_tree_t *left ;
   struct bin_tree_t *right ;
   struct bin_tree_t *first ;
   struct bin_tree_t *next ;
   re_token_t token ;
   Idx node_idx ;
};
#line 500 "regex_internal.h"
typedef struct bin_tree_t bin_tree_t;
#line 505 "regex_internal.h"
struct bin_tree_storage_t {
   struct bin_tree_storage_t *next ;
   bin_tree_t data[(1024U - sizeof(void *)) / sizeof(bin_tree_t )] ;
};
#line 510 "regex_internal.h"
typedef struct bin_tree_storage_t bin_tree_storage_t;
#line 540 "regex_internal.h"
struct re_dfastate_t {
   re_hashval_t hash ;
   re_node_set nodes ;
   re_node_set non_eps_nodes ;
   re_node_set inveclosure ;
   re_node_set *entrance_nodes ;
   struct re_dfastate_t **trtable ;
   struct re_dfastate_t **word_trtable ;
   unsigned int context : 4 ;
   unsigned int halt : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int has_backref : 1 ;
   unsigned int has_constraint : 1 ;
};
#line 558 "regex_internal.h"
typedef struct re_dfastate_t re_dfastate_t;
#line 560 "regex_internal.h"
struct re_state_table_entry {
   Idx num ;
   Idx alloc ;
   re_dfastate_t **array ;
};
#line 569 "regex_internal.h"
struct __anonstruct_state_array_t_19 {
   Idx next_idx ;
   Idx alloc ;
   re_dfastate_t **array ;
};
#line 569 "regex_internal.h"
typedef struct __anonstruct_state_array_t_19 state_array_t;
#line 578 "regex_internal.h"
struct __anonstruct_re_sub_match_last_t_20 {
   Idx node ;
   Idx str_idx ;
   state_array_t path ;
};
#line 578 "regex_internal.h"
typedef struct __anonstruct_re_sub_match_last_t_20 re_sub_match_last_t;
#line 589 "regex_internal.h"
struct __anonstruct_re_sub_match_top_t_21 {
   Idx str_idx ;
   Idx node ;
   state_array_t *path ;
   Idx alasts ;
   Idx nlasts ;
   re_sub_match_last_t **lasts ;
};
#line 589 "regex_internal.h"
typedef struct __anonstruct_re_sub_match_top_t_21 re_sub_match_top_t;
#line 599 "regex_internal.h"
struct re_backref_cache_entry {
   Idx node ;
   Idx str_idx ;
   Idx subexp_from ;
   Idx subexp_to ;
   char more ;
   char unused ;
   unsigned short eps_reachable_subexps_map ;
};
#line 610 "regex_internal.h"
struct __anonstruct_re_match_context_t_22 {
   re_string_t input ;
   re_dfa_t const   *dfa ;
   int eflags ;
   Idx match_last ;
   Idx last_node ;
   re_dfastate_t **state_log ;
   Idx state_log_top ;
   Idx nbkref_ents ;
   Idx abkref_ents ;
   struct re_backref_cache_entry *bkref_ents ;
   int max_mb_elem_len ;
   Idx nsub_tops ;
   Idx asub_tops ;
   re_sub_match_top_t **sub_tops ;
};
#line 610 "regex_internal.h"
typedef struct __anonstruct_re_match_context_t_22 re_match_context_t;
#line 637 "regex_internal.h"
struct __anonstruct_re_sift_context_t_23 {
   re_dfastate_t **sifted_states ;
   re_dfastate_t **limited_states ;
   Idx last_node ;
   Idx last_str_idx ;
   re_node_set limits ;
};
#line 637 "regex_internal.h"
typedef struct __anonstruct_re_sift_context_t_23 re_sift_context_t;
#line 646 "regex_internal.h"
struct re_fail_stack_ent_t {
   Idx idx ;
   Idx node ;
   regmatch_t *regs ;
   re_node_set eps_via_nodes ;
};
#line 654 "regex_internal.h"
struct re_fail_stack_t {
   Idx num ;
   Idx alloc ;
   struct re_fail_stack_ent_t *stack ;
};
#line 661 "regex_internal.h"
struct re_dfa_t {
   re_token_t *nodes ;
   size_t nodes_alloc ;
   size_t nodes_len ;
   Idx *nexts ;
   Idx *org_indices ;
   re_node_set *edests ;
   re_node_set *eclosures ;
   re_node_set *inveclosures ;
   struct re_state_table_entry *state_table ;
   re_dfastate_t *init_state ;
   re_dfastate_t *init_state_word ;
   re_dfastate_t *init_state_nl ;
   re_dfastate_t *init_state_begbuf ;
   bin_tree_t *str_tree ;
   bin_tree_storage_t *str_tree_storage ;
   re_bitset_ptr_t sb_char ;
   int str_tree_storage_idx ;
   re_hashval_t state_hash_mask ;
   Idx init_node ;
   Idx nbackref ;
   bitset_word_t used_bkref_map ;
   bitset_word_t completed_bkref_map ;
   unsigned int has_plural_match : 1 ;
   unsigned int has_mb_node : 1 ;
   unsigned int is_utf8 : 1 ;
   unsigned int map_notascii : 1 ;
   unsigned int word_ops_used : 1 ;
   int mb_cur_max ;
   bitset_t word_char ;
   reg_syntax_t syntax ;
   Idx *subexp_map ;
};
#line 717
enum __anonenum_bracket_elem_type_24 {
    SB_CHAR = 0,
    MB_CHAR = 1,
    EQUIV_CLASS = 2,
    COLL_SYM = 3,
    CHAR_CLASS = 4
} ;
#line 717 "regex_internal.h"
typedef enum __anonenum_bracket_elem_type_24 bracket_elem_type;
#line 726 "regex_internal.h"
union __anonunion_opr_26 {
   unsigned char ch ;
   unsigned char *name ;
   wchar_t wch ;
};
#line 726 "regex_internal.h"
struct __anonstruct_bracket_elem_t_25 {
   bracket_elem_type type ;
   union __anonunion_opr_26 opr ;
};
#line 726 "regex_internal.h"
typedef struct __anonstruct_bracket_elem_t_25 bracket_elem_t;
#line 3359 "regexec.c"
struct dests_alloc {
   re_node_set dests_node[256] ;
   bitset_t dests_ch[256] ;
};
#line 28 "sha1.h"
struct sha1_ctx {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int E ;
   unsigned int total[2] ;
   unsigned int buflen ;
   unsigned int buffer[32] ;
};
#line 237 "sha1.c"
struct __anonstruct_9 {
   char c ;
   unsigned int x ;
};
#line 41 "sig2str.c"
struct numname {
   int num ;
   char const   name[8] ;
};
#line 6 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/utime.h"
struct utimbuf {
   time_t actime ;
   time_t modtime ;
};
#line 57 "utimecmp.c"
struct fs_res {
   dev_t dev ;
   int resolution ;
   _Bool exact ;
};
#line 263 "vasnprintf.c"
typedef unsigned int mp_limb_t;
#line 267 "vasnprintf.c"
typedef unsigned long long mp_twolimb_t;
#line 272 "vasnprintf.c"
struct __anonstruct_mpn_t_17 {
   size_t nlimbs ;
   mp_limb_t *limbs ;
};
#line 272 "vasnprintf.c"
typedef struct __anonstruct_mpn_t_17 mpn_t;
#line 25 "sha256.h"
struct sha256_ctx {
   unsigned int state[8] ;
   unsigned int total[2] ;
   unsigned int buflen ;
   unsigned int buffer[32] ;
};
#line 354 "sha256.c"
struct __anonstruct_9___0 {
   char c ;
   unsigned int x ;
};
#line 30 "u64.h"
typedef unsigned long long u64;
#line 26 "sha512.h"
struct sha512_ctx {
   u64 state[8] ;
   u64 total[2] ;
   size_t buflen ;
   u64 buffer[32] ;
};
#line 362 "sha512.c"
struct __anonstruct_9___1 {
   char c ;
   u64 x ;
};
#line 1 "mknod.o"
#pragma merger(0,"/tmp/cil-wdPbj1Eu.i","-g,-O2")
#line 818 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/reent.h"
extern struct _reent *_impure_ptr ;
#line 178 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int ( /* format attribute */  fprintf)(FILE * , char const   *  , ...) ;
#line 182
extern int ( /* format attribute */  printf)(char const   *  , ...) ;
#line 197
extern int fputs(char const   * , FILE * ) ;
#line 64 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern int atexit(void (*__func)(void) ) ;
#line 80
extern void exit(int __status ) ;
#line 81
extern void free(void * ) ;
#line 114 "../lib/getopt.h"
char *rpl_optarg ;
#line 128
int rpl_optind ;
#line 208
int rpl_getopt_long(int argc , char **argv , char const   *options , struct option  const  *long_options___0 ,
                    int *opt_index ) ;
#line 15 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/errno.h"
extern int *__errno(void) ;
#line 26 "../lib/selinux/selinux.h"
__inline static int setfscreatecon(char *con ) 
{ int *__cil_tmp ;

  {
#line 27
  __cil_tmp = __errno();
#line 27
  *__cil_tmp = 134;
#line 27
  return (-1);
}
}
#line 124 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/socket.h"
unsigned short __otter_sock_free_port  ;
#line 91 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dnode *__otter_fs_root  ;
#line 92 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_dnode *__otter_fs_pwd  ;
#line 114 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
int *__otter_fs_fd_table  ;
#line 115 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
struct __otter_fs_open_file_table_entry *__otter_fs_open_file_table  ;
#line 140 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/otter/otter_fs.h"
int __otter_fs_umask  ;
#line 87 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/stat.h"
extern int mkfifo(char const   *name , mode_t mode ) ;
#line 88
extern int mknod(char const   *name , mode_t mode , dev_t  ) ;
#line 90
extern mode_t umask(mode_t mode ) ;
#line 55 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/locale.h"
extern char *setlocale(int category , char const   *locale ) ;
#line 26 "../lib/closeout.h"
void close_stdout(void) ;
#line 31 "../lib/version-etc.h"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) ;
#line 573 "system.h"
__inline static void emit_bug_reporting_address(void) 
{ 

  {
#line 580
  printf("\nReport bugs to <%s>.\n", "bug-coreutils@gnu.org");
#line 581
  return;
}
}
#line 42 "../lib/error.h"
void error(int status , int errnum , char const   *message  , ...) ;
#line 25 "../lib/modechange.h"
struct mode_change *mode_compile(char const   *mode_string ) ;
#line 27
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) ;
#line 21 "../lib/quote.h"
char const   *quote(char const   *name ) ;
#line 47 "../lib/xstrtol.h"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , unsigned long long *val ,
                        char const   *valid_suffixes ) ;
#line 37 "mknod.c"
char *program_name  ;
#line 39 "mknod.c"
static struct option  const  longopts[5]  = {      {"context", 1, (int *)((void *)0), 'Z'}, 
        {"mode", 1, (int *)((void *)0), 'm'}, 
        {"help", 0, (int *)((void *)0), -130}, 
        {"version", 0, (int *)((void *)0), -131}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 48 "mknod.c"
void usage(int status ) 
{ 

  {
#line 51
  if (status != 0) {
#line 52
    fprintf(_impure_ptr->_stderr, "Try `%s --help\' for more information.\n", program_name);
  } else {
#line 56
    printf("Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n", program_name);
#line 58
    fputs("Create the special file NAME of the given TYPE.\n\n", _impure_ptr->_stdout);
#line 62
    fputs("  -Z, --context=CTX  set the SELinux security context of NAME to CTX\n",
          _impure_ptr->_stdout);
#line 65
    fputs("Mandatory arguments to long options are mandatory for short options too.\n",
          _impure_ptr->_stdout);
#line 68
    fputs("  -m, --mode=MODE   set file permission bits to MODE, not a=rw - umask\n",
          _impure_ptr->_stdout);
#line 71
    fputs("      --help     display this help and exit\n", _impure_ptr->_stdout);
#line 72
    fputs("      --version  output version information and exit\n", _impure_ptr->_stdout);
#line 73
    fputs("\nBoth MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\nmust be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\nit is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\notherwise, as decimal.  TYPE may be:\n",
          _impure_ptr->_stdout);
#line 80
    fputs("\n  b      create a block (buffered) special file\n  c, u   create a character (unbuffered) special file\n  p      create a FIFO\n",
          _impure_ptr->_stdout);
#line 86
    emit_bug_reporting_address();
  }
#line 88
  exit(status);
}
}
#line 91 "mknod.c"
int main(int argc , char **argv ) 
{ mode_t newmode ;
  char const   *specified_mode ;
  int optc ;
  int expected_operands ;
  mode_t node_type ;
  char *scontext ;
  struct mode_change *change ;
  struct mode_change *__cil_tmp ;
  mode_t __cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  char const   *__cil_tmp___2 ;
  char const   *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int __cil_tmp___5 ;
  char const   *s_major ;
  char const   *s_minor ;
  unsigned long long i_major ;
  unsigned long long i_minor ;
  dev_t device ;
  char const   *__cil_tmp___6 ;
  strtol_error __cil_tmp___7 ;
  char const   *__cil_tmp___8 ;
  strtol_error __cil_tmp___9 ;
  char const   *__cil_tmp___10 ;
  int *__cil_tmp___11 ;
  int __cil_tmp___12 ;
  char const   *__cil_tmp___13 ;
  int *__cil_tmp___14 ;
  int __cil_tmp___15 ;
  char const   *__cil_tmp___16 ;

  {
#line 95
  specified_mode = (char const   *)((void *)0);
#line 99
  scontext = (char *)((void *)0);
#line 102
  program_name = *(argv + 0);
#line 103
  setlocale(0, "");
#line 107
  atexit(& close_stdout);
#line 109
  while (1) {
#line 109
    optc = rpl_getopt_long(argc, argv, "m:Z:", longopts, (int *)((void *)0));
#line 109
    if (! (optc != -1)) {
#line 109
      break;
    }
#line 111
    switch (optc) {
    case 109: 
#line 114
    specified_mode = (char const   *)rpl_optarg;
#line 115
    break;
    case 90: 
#line 117
    scontext = rpl_optarg;
#line 118
    break;
    case -130: 
#line 119
    usage(0);
#line 119
    break;
    case -131: 
#line 120
    version_etc(_impure_ptr->_stdout, "mknod", "GNU coreutils", "6.10", "David MacKenzie",
                (char *)((void *)0));
#line 120
    exit(0);
#line 120
    break;
    default: 
#line 122
    usage(1);
    }
  }
#line 126
  newmode = 438U;
#line 127
  if (specified_mode) {
#line 129
    __cil_tmp = mode_compile(specified_mode);
#line 129
    change = __cil_tmp;
#line 130
    if (! change) {
#line 131
      error(1, 0, "invalid mode");
    }
#line 132
    __cil_tmp___0 = umask(0U);
#line 132
    newmode = mode_adjust(newmode, (_Bool)0, __cil_tmp___0, (struct mode_change  const  *)change,
                          (mode_t *)((void *)0));
#line 133
    free((void *)change);
#line 134
    if (newmode & 4294966784U) {
#line 135
      error(1, 0, "mode must specify only file permission bits");
    }
  }
#line 142
  expected_operands = argc <= rpl_optind || (rpl_optind + 1 < argc && (int )*(*(argv + (rpl_optind + 1)) + 0) == 112) ? 2 : 4;
#line 146
  if (argc - rpl_optind < expected_operands) {
#line 148
    if (argc <= rpl_optind) {
#line 149
      error(0, 0, "missing operand");
    } else {
#line 151
      __cil_tmp___1 = quote((char const   *)*(argv + (argc - 1)));
#line 151
      error(0, 0, "missing operand after %s", __cil_tmp___1);
    }
#line 152
    if (expected_operands == 4 && argc - rpl_optind == 2) {
#line 153
      fprintf(_impure_ptr->_stderr, "%s\n", "Special files require major and minor device numbers.");
    }
#line 155
    usage(1);
  }
#line 158
  if (expected_operands < argc - rpl_optind) {
#line 160
    __cil_tmp___2 = quote((char const   *)*(argv + (rpl_optind + expected_operands)));
#line 160
    error(0, 0, "extra operand %s", __cil_tmp___2);
#line 162
    if (expected_operands == 2 && argc - rpl_optind == 4) {
#line 163
      fprintf(_impure_ptr->_stderr, "%s\n", "Fifos do not have major and minor device numbers.");
    }
#line 165
    usage(1);
  }
#line 168
  if (scontext) {
#line 168
    __cil_tmp___5 = setfscreatecon(scontext);
#line 168
    if (__cil_tmp___5 < 0) {
#line 169
      __cil_tmp___3 = quote((char const   *)rpl_optarg);
#line 169
      __cil_tmp___4 = __errno();
#line 169
      error(1, *__cil_tmp___4, "failed to set default file creation context to %s",
            __cil_tmp___3);
    }
  }
#line 176
  switch ((int )*(*(argv + (rpl_optind + 1)) + 0)) {
  case 98: 
#line 182
  node_type = 65536U;
#line 184
  goto block_or_character;
  case 99: 
  case 117: 
#line 191
  node_type = 131072U;
#line 193
  goto block_or_character;
  block_or_character: 
#line 197
  s_major = (char const   *)*(argv + (rpl_optind + 2));
#line 198
  s_minor = (char const   *)*(argv + (rpl_optind + 3));
#line 202
  __cil_tmp___7 = xstrtoumax(s_major, (char **)((void *)0), 0, & i_major, (char const   *)((void *)0));
#line 202
  if ((unsigned int )__cil_tmp___7 != 0U || i_major != (unsigned long long )((unsigned int )i_major)) {
#line 204
    __cil_tmp___6 = quote(s_major);
#line 204
    error(1, 0, "invalid major device number %s", __cil_tmp___6);
  }
#line 207
  __cil_tmp___9 = xstrtoumax(s_minor, (char **)((void *)0), 0, & i_minor, (char const   *)((void *)0));
#line 207
  if ((unsigned int )__cil_tmp___9 != 0U || i_minor != (unsigned long long )((unsigned int )i_minor)) {
#line 209
    __cil_tmp___8 = quote(s_minor);
#line 209
    error(1, 0, "invalid minor device number %s", __cil_tmp___8);
  }
#line 212
  device = (short )((i_major << 8) | i_minor);
#line 218
  __cil_tmp___12 = mknod((char const   *)*(argv + rpl_optind), newmode | node_type,
                         device);
#line 218
  if (__cil_tmp___12 != 0) {
#line 219
    __cil_tmp___10 = quote((char const   *)*(argv + rpl_optind));
#line 219
    __cil_tmp___11 = __errno();
#line 219
    error(1, *__cil_tmp___11, "%s", __cil_tmp___10);
  }
#line 221
  break;
  case 112: 
#line 224
  __cil_tmp___15 = mkfifo((char const   *)*(argv + rpl_optind), newmode);
#line 224
  if (__cil_tmp___15 != 0) {
#line 225
    __cil_tmp___13 = quote((char const   *)*(argv + rpl_optind));
#line 225
    __cil_tmp___14 = __errno();
#line 225
    error(1, *__cil_tmp___14, "%s", __cil_tmp___13);
  }
#line 226
  break;
  default: 
#line 229
  __cil_tmp___16 = quote((char const   *)*(argv + (rpl_optind + 1)));
#line 229
  error(0, 0, "invalid device type %s", __cil_tmp___16);
#line 230
  usage(1);
  }
#line 233
  exit(0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "areadlink-with-size.o"
#pragma merger(0,"/tmp/cil-B1kPxD4Z.i","-g,-O2")
#line 23 "areadlink.h"
char *areadlink_with_size(char const   *file , size_t size ) ;
#line 92 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
void *rpl_malloc(size_t n ) ;
#line 241 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern ssize_t readlink(char const   *__path , char *__buf , size_t __buflen ) ;
#line 55 "areadlink-with-size.c"
char *areadlink_with_size(char const   *file , size_t size ) 
{ size_t symlink_max ;
  size_t INITIAL_LIMIT_BOUND ;
  size_t initial_limit ;
  size_t buf_size ;
  ssize_t r ;
  size_t link_length ;
  char *buffer ;
  void *__cil_tmp ;
  int saved_errno ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;

  {
#line 61
  symlink_max = 1024U;
#line 62
  INITIAL_LIMIT_BOUND = 8192U;
#line 63
  initial_limit = symlink_max < INITIAL_LIMIT_BOUND ? symlink_max + 1U : INITIAL_LIMIT_BOUND;
#line 68
  buf_size = size < initial_limit ? size + 1U : initial_limit;
#line 70
  while (1) {
#line 74
    __cil_tmp = rpl_malloc(buf_size);
#line 74
    buffer = (char *)__cil_tmp;
#line 76
    if ((unsigned int )buffer == (unsigned int )((void *)0)) {
#line 77
      return ((char *)((void *)0));
    }
#line 78
    r = readlink(file, buffer, buf_size);
#line 79
    link_length = (unsigned int )r;
#line 83
    if (r < 0) {
#line 83
      __cil_tmp___2 = __errno();
#line 83
      if (*__cil_tmp___2 != 34) {
#line 85
        __cil_tmp___0 = __errno();
#line 85
        saved_errno = *__cil_tmp___0;
#line 86
        free((void *)buffer);
#line 87
        __cil_tmp___1 = __errno();
#line 87
        *__cil_tmp___1 = saved_errno;
#line 88
        return ((char *)((void *)0));
      }
    }
#line 91
    if (link_length < buf_size) {
#line 93
      *(buffer + link_length) = (char)0;
#line 94
      return (buffer);
    }
#line 97
    free((void *)buffer);
#line 98
    if (buf_size <= 1073741823U) {
#line 99
      buf_size *= 2U;
    } else
#line 100
    if (buf_size < 2147483647U) {
#line 101
      buf_size = 2147483647U;
    } else {
#line 104
      __cil_tmp___3 = __errno();
#line 104
      *__cil_tmp___3 = 12;
#line 105
      return ((char *)((void *)0));
    }
  }
}
}
#line 1 "base64.o"
#pragma merger(0,"/tmp/cil-j7gMs7Ne.i","-g,-O2")
#line 37 "base64.h"
_Bool isbase64(char ch ) ;
#line 39
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) ;
#line 42
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) ;
#line 44
void base64_decode_ctx_init(struct base64_decode_context *ctx ) ;
#line 45
_Bool base64_decode(struct base64_decode_context *ctx , char const   * __restrict  in ,
                    size_t inlen , char * __restrict  out , size_t *outlen ) ;
#line 49
_Bool base64_decode_alloc(struct base64_decode_context *ctx , char const   *in , size_t inlen ,
                          char **out , size_t *outlen ) ;
#line 22 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern void *memchr(void const   * , int  , size_t  ) ;
#line 57 "base64.c"
__inline static unsigned char to_uchar(char ch ) 
{ 

  {
#line 60
  return ((unsigned char )ch);
}
}
#line 71 "base64.c"
static char const   b64str[64]  = 
#line 71
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 67 "base64.c"
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) 
{ char * __restrict  __cil_tmp ;
  unsigned char __cil_tmp___0 ;
  char * __restrict  __cil_tmp___1 ;
  unsigned char __cil_tmp___2 ;
  unsigned char __cil_tmp___3 ;
  int __cil_tmp___4 ;
  char * __restrict  __cil_tmp___5 ;
  unsigned char __cil_tmp___6 ;
  unsigned char __cil_tmp___7 ;
  int __cil_tmp___8 ;
  char * __restrict  __cil_tmp___9 ;
  unsigned char __cil_tmp___10 ;

  {
#line 74
  while (inlen && outlen) {
#line 76
    __cil_tmp = out;
#line 76
    out ++;
#line 76
    __cil_tmp___0 = to_uchar((char )*(in + 0));
#line 76
    *__cil_tmp = (char )b64str[((int )__cil_tmp___0 >> 2) & 63];
#line 77
    outlen --;
#line 77
    if (! outlen) {
#line 78
      break;
    }
#line 79
    __cil_tmp___1 = out;
#line 79
    out ++;
#line 79
    __cil_tmp___2 = to_uchar((char )*(in + 0));
#line 79
    inlen --;
#line 79
    if (inlen) {
#line 79
      __cil_tmp___3 = to_uchar((char )*(in + 1));
#line 79
      __cil_tmp___4 = (int )__cil_tmp___3 >> 4;
    } else {
#line 79
      __cil_tmp___4 = 0;
    }
#line 79
    *__cil_tmp___1 = (char )b64str[(((int )__cil_tmp___2 << 4) + __cil_tmp___4) & 63];
#line 82
    outlen --;
#line 82
    if (! outlen) {
#line 83
      break;
    }
#line 84
    __cil_tmp___5 = out;
#line 84
    out ++;
#line 84
    if (inlen) {
#line 84
      __cil_tmp___6 = to_uchar((char )*(in + 1));
#line 84
      inlen --;
#line 84
      if (inlen) {
#line 84
        __cil_tmp___7 = to_uchar((char )*(in + 2));
#line 84
        __cil_tmp___8 = (int )__cil_tmp___7 >> 6;
      } else {
#line 84
        __cil_tmp___8 = 0;
      }
#line 84
      *__cil_tmp___5 = (char )b64str[(((int )__cil_tmp___6 << 2) + __cil_tmp___8) & 63];
    } else {
#line 84
      *__cil_tmp___5 = (char )'=';
    }
#line 90
    outlen --;
#line 90
    if (! outlen) {
#line 91
      break;
    }
#line 92
    __cil_tmp___9 = out;
#line 92
    out ++;
#line 92
    if (inlen) {
#line 92
      __cil_tmp___10 = to_uchar((char )*(in + 2));
#line 92
      *__cil_tmp___9 = (char )b64str[(int )__cil_tmp___10 & 63];
    } else {
#line 92
      *__cil_tmp___9 = (char )'=';
    }
#line 93
    outlen --;
#line 93
    if (! outlen) {
#line 94
      break;
    }
#line 95
    if (inlen) {
#line 96
      inlen --;
    }
#line 97
    if (inlen) {
#line 98
      in += 3;
    }
  }
#line 101
  if (outlen) {
#line 102
    *out = (char )'\000';
  }
#line 103
  return;
}
}
#line 114 "base64.c"
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) 
{ size_t outlen ;
  void *__cil_tmp ;

  {
#line 117
  outlen = 1U + ((inlen + 2U) / 3U) * 4U;
#line 131
  if (inlen > outlen) {
#line 133
    *out = (char *)((void *)0);
#line 134
    return (0U);
  }
#line 137
  __cil_tmp = rpl_malloc(outlen);
#line 137
  *out = (char *)__cil_tmp;
#line 138
  if (! *out) {
#line 139
    return (outlen);
  }
#line 141
  base64_encode((char const   * __restrict  )in, inlen, (char * __restrict  )*out,
                outlen);
#line 143
  return (outlen - 1U);
}
}
#line 222 "base64.c"
static signed char const   b64[256]  = 
#line 222
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 298 "base64.c"
_Bool isbase64(char ch ) 
{ unsigned char __cil_tmp ;

  {
#line 301
  __cil_tmp = to_uchar(ch);
#line 301
  return ((_Bool )(0 <= (int )b64[__cil_tmp]));
}
}
#line 305 "base64.c"
void base64_decode_ctx_init(struct base64_decode_context *ctx ) 
{ 

  {
#line 308
  ctx->i = 0U;
#line 309
  return;
}
}
#line 318 "base64.c"
__inline static char *get_4(struct base64_decode_context *ctx , char const   * __restrict  *in ,
                            char const   * __restrict  in_end , size_t *n_non_newline ) 
{ char const   *t ;
  void *__cil_tmp ;
  char const   *p ;
  char c ;
  char const   *__cil_tmp___0 ;
  unsigned int __cil_tmp___1 ;

  {
#line 323
  if (ctx->i == 4U) {
#line 324
    ctx->i = 0U;
  }
#line 326
  if (ctx->i == 0U) {
#line 328
    t = (char const   *)*in;
#line 329
    if (4 <= in_end - *in) {
#line 329
      __cil_tmp = memchr((void const   *)t, '\n', 4U);
#line 329
      if ((unsigned int )__cil_tmp == (unsigned int )((void *)0)) {
#line 332
        *in += 4;
#line 333
        *n_non_newline = 4U;
#line 334
        return ((char *)t);
      }
    }
  }
#line 340
  p = (char const   *)*in;
#line 341
  while ((unsigned int )p < (unsigned int )in_end) {
#line 343
    __cil_tmp___0 = p;
#line 343
    p ++;
#line 343
    c = (char )*__cil_tmp___0;
#line 344
    if ((int )c != 10) {
#line 346
      __cil_tmp___1 = ctx->i;
#line 346
      (ctx->i) ++;
#line 346
      ctx->buf[__cil_tmp___1] = c;
#line 347
      if (ctx->i == 4U) {
#line 348
        break;
      }
    }
  }
#line 352
  *in = (char const   * __restrict  )p;
#line 353
  *n_non_newline = ctx->i;
#line 354
  return (ctx->buf);
}
}
#line 372 "base64.c"
__inline static _Bool decode_4(char const   * __restrict  in , size_t inlen , char * __restrict  *outp ,
                               size_t *outleft ) 
{ char *out ;
  _Bool __cil_tmp ;
  _Bool __cil_tmp___0 ;
  char *__cil_tmp___1 ;
  unsigned char __cil_tmp___2 ;
  unsigned char __cil_tmp___3 ;
  _Bool __cil_tmp___4 ;
  char *__cil_tmp___5 ;
  unsigned char __cil_tmp___6 ;
  unsigned char __cil_tmp___7 ;
  _Bool __cil_tmp___8 ;
  char *__cil_tmp___9 ;
  unsigned char __cil_tmp___10 ;
  unsigned char __cil_tmp___11 ;

  {
#line 376
  out = (char *)*outp;
#line 377
  if (inlen < 2U) {
#line 378
    return ((_Bool)0);
  }
#line 380
  __cil_tmp = isbase64((char )*(in + 0));
#line 380
  if (__cil_tmp) {
#line 380
    __cil_tmp___0 = isbase64((char )*(in + 1));
#line 380
    if (! __cil_tmp___0) {
#line 381
      return ((_Bool)0);
    }
  } else {
#line 381
    return ((_Bool)0);
  }
#line 383
  if (*outleft) {
#line 385
    __cil_tmp___1 = out;
#line 385
    out ++;
#line 385
    __cil_tmp___2 = to_uchar((char )*(in + 0));
#line 385
    __cil_tmp___3 = to_uchar((char )*(in + 1));
#line 385
    *__cil_tmp___1 = (char )(((int const   )b64[__cil_tmp___2] << 2) | ((int const   )b64[__cil_tmp___3] >> 4));
#line 387
    (*outleft) --;
  }
#line 390
  if (inlen == 2U) {
#line 391
    while (1) {
#line 391
      *outp = (char * __restrict  )out;
#line 391
      return ((_Bool)0);
#line 391
      break;
    }
  }
#line 393
  if ((int const   )*(in + 2) == 61) {
#line 395
    if (inlen != 4U) {
#line 396
      while (1) {
#line 396
        *outp = (char * __restrict  )out;
#line 396
        return ((_Bool)0);
#line 396
        break;
      }
    }
#line 398
    if ((int const   )*(in + 3) != 61) {
#line 399
      while (1) {
#line 399
        *outp = (char * __restrict  )out;
#line 399
        return ((_Bool)0);
#line 399
        break;
      }
    }
  } else {
#line 403
    __cil_tmp___4 = isbase64((char )*(in + 2));
#line 403
    if (! __cil_tmp___4) {
#line 404
      while (1) {
#line 404
        *outp = (char * __restrict  )out;
#line 404
        return ((_Bool)0);
#line 404
        break;
      }
    }
#line 406
    if (*outleft) {
#line 408
      __cil_tmp___5 = out;
#line 408
      out ++;
#line 408
      __cil_tmp___6 = to_uchar((char )*(in + 1));
#line 408
      __cil_tmp___7 = to_uchar((char )*(in + 2));
#line 408
      *__cil_tmp___5 = (char )((((int const   )b64[__cil_tmp___6] << 4) & 240) | ((int const   )b64[__cil_tmp___7] >> 2));
#line 410
      (*outleft) --;
    }
#line 413
    if (inlen == 3U) {
#line 414
      while (1) {
#line 414
        *outp = (char * __restrict  )out;
#line 414
        return ((_Bool)0);
#line 414
        break;
      }
    }
#line 416
    if ((int const   )*(in + 3) == 61) {
#line 418
      if (inlen != 4U) {
#line 419
        while (1) {
#line 419
          *outp = (char * __restrict  )out;
#line 419
          return ((_Bool)0);
#line 419
          break;
        }
      }
    } else {
#line 423
      __cil_tmp___8 = isbase64((char )*(in + 3));
#line 423
      if (! __cil_tmp___8) {
#line 424
        while (1) {
#line 424
          *outp = (char * __restrict  )out;
#line 424
          return ((_Bool)0);
#line 424
          break;
        }
      }
#line 426
      if (*outleft) {
#line 428
        __cil_tmp___9 = out;
#line 428
        out ++;
#line 428
        __cil_tmp___10 = to_uchar((char )*(in + 2));
#line 428
        __cil_tmp___11 = to_uchar((char )*(in + 3));
#line 428
        *__cil_tmp___9 = (char )((((int const   )b64[__cil_tmp___10] << 6) & 192) | (int const   )b64[__cil_tmp___11]);
#line 430
        (*outleft) --;
      }
    }
  }
#line 435
  *outp = (char * __restrict  )out;
#line 436
  return ((_Bool)1);
}
}
#line 454 "base64.c"
_Bool base64_decode(struct base64_decode_context *ctx , char const   * __restrict  in ,
                    size_t inlen , char * __restrict  out , size_t *outlen ) 
{ size_t outleft ;
  _Bool flush_ctx ;
  size_t outleft_save ;
  _Bool __cil_tmp ;
  char const   *in_end ;
  char const   *non_nl ;
  char *__cil_tmp___0 ;
  _Bool __cil_tmp___1 ;

  {
#line 459
  outleft = *outlen;
#line 460
  flush_ctx = (_Bool )(inlen == 0U);
#line 462
  while (1) {
#line 464
    outleft_save = outleft;
#line 465
    if (ctx->i == 0U && ! flush_ctx) {
#line 467
      while (1) {
#line 471
        outleft_save = outleft;
#line 472
        __cil_tmp = decode_4(in, inlen, & out, & outleft);
#line 472
        if (! __cil_tmp) {
#line 473
          break;
        }
#line 475
        in += 4;
#line 476
        inlen -= 4U;
      }
    }
#line 480
    if (inlen == 0U && ! flush_ctx) {
#line 481
      break;
    }
#line 485
    if (inlen && (int const   )*in == 10) {
#line 487
      in ++;
#line 488
      inlen --;
#line 489
      continue;
    }
#line 493
    out -= outleft_save - outleft;
#line 494
    outleft = outleft_save;
#line 497
    in_end = (char const   *)(in + inlen);
#line 498
    __cil_tmp___0 = get_4(ctx, & in, (char const   * __restrict  )in_end, & inlen);
#line 498
    non_nl = (char const   *)__cil_tmp___0;
#line 503
    if (inlen == 0U || (inlen < 4U && ! flush_ctx)) {
#line 505
      inlen = 0U;
#line 506
      break;
    }
#line 508
    __cil_tmp___1 = decode_4((char const   * __restrict  )non_nl, inlen, & out, & outleft);
#line 508
    if (! __cil_tmp___1) {
#line 509
      break;
    }
#line 511
    inlen = (unsigned int )(in_end - (char const   *)in);
  }
#line 515
  *outlen -= outleft;
#line 517
  return ((_Bool )(inlen == 0U));
}
}
#line 531 "base64.c"
_Bool base64_decode_alloc(struct base64_decode_context *ctx , char const   *in , size_t inlen ,
                          char **out , size_t *outlen ) 
{ size_t needlen ;
  void *__cil_tmp ;
  _Bool __cil_tmp___0 ;

  {
#line 541
  needlen = 3U * (inlen / 4U) + 2U;
#line 543
  __cil_tmp = rpl_malloc(needlen);
#line 543
  *out = (char *)__cil_tmp;
#line 544
  if (! *out) {
#line 545
    return ((_Bool)1);
  }
#line 547
  __cil_tmp___0 = base64_decode(ctx, (char const   * __restrict  )in, inlen, (char * __restrict  )*out,
                                & needlen);
#line 547
  if (! __cil_tmp___0) {
#line 549
    free((void *)*out);
#line 550
    *out = (char *)((void *)0);
#line 551
    return ((_Bool)0);
  }
#line 554
  if (outlen) {
#line 555
    *outlen = needlen;
  }
#line 557
  return ((_Bool)1);
}
}
#line 1 "c-ctype.o"
#pragma merger(0,"/tmp/cil-BEv1kbNg.i","-g,-O2")
#line 108 "c-ctype.h"
_Bool c_isascii(int c ) ;
#line 110
_Bool c_isalnum(int c ) ;
#line 111
_Bool c_isalpha(int c ) ;
#line 112
_Bool c_isblank(int c ) ;
#line 113
_Bool c_iscntrl(int c ) ;
#line 114
_Bool c_isdigit(int c ) ;
#line 115
_Bool c_islower(int c ) ;
#line 116
_Bool c_isgraph(int c ) ;
#line 117
_Bool c_isprint(int c ) ;
#line 118
_Bool c_ispunct(int c ) ;
#line 119
_Bool c_isspace(int c ) ;
#line 120
_Bool c_isupper(int c ) ;
#line 121
_Bool c_isxdigit(int c ) ;
#line 123
int c_tolower(int c ) ;
#line 124
int c_toupper(int c ) ;
#line 29 "c-ctype.c"
_Bool c_isascii(int c ) 
{ 

  {
#line 32
  return ((_Bool )(c >= 0 && c <= 127));
}
}
#line 35 "c-ctype.c"
_Bool c_isalnum(int c ) 
{ 

  {
#line 41
  return ((_Bool )((c >= 48 && c <= 57) || ((c & -33) >= 65 && (c & -33) <= 90)));
}
}
#line 70 "c-ctype.c"
_Bool c_isalpha(int c ) 
{ 

  {
#line 75
  return ((_Bool )((c & -33) >= 65 && (c & -33) <= 90));
}
}
#line 99 "c-ctype.c"
_Bool c_isblank(int c ) 
{ 

  {
#line 102
  return ((_Bool )(c == 32 || c == 9));
}
}
#line 105 "c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 

  {
#line 109
  return ((_Bool )((c & -32) == 0 || c == 127));
}
}
#line 139 "c-ctype.c"
_Bool c_isdigit(int c ) 
{ 

  {
#line 143
  return ((_Bool )(c >= 48 && c <= 57));
}
}
#line 156 "c-ctype.c"
_Bool c_islower(int c ) 
{ 

  {
#line 160
  return ((_Bool )(c >= 97 && c <= 122));
}
}
#line 176 "c-ctype.c"
_Bool c_isgraph(int c ) 
{ 

  {
#line 180
  return ((_Bool )(c >= 33 && c <= 126));
}
}
#line 210 "c-ctype.c"
_Bool c_isprint(int c ) 
{ 

  {
#line 214
  return ((_Bool )(c >= 32 && c <= 126));
}
}
#line 244 "c-ctype.c"
_Bool c_ispunct(int c ) 
{ 

  {
#line 248
  return ((_Bool )((c >= 33 && c <= 126) && ! ((c >= 48 && c <= 57) || ((c & -33) >= 65 && (c & -33) <= 90))));
}
}
#line 268 "c-ctype.c"
_Bool c_isspace(int c ) 
{ 

  {
#line 271
  return ((_Bool )(((((c == 32 || c == 9) || c == 10) || c == 11) || c == 12) || c == 13));
}
}
#line 275 "c-ctype.c"
_Bool c_isupper(int c ) 
{ 

  {
#line 279
  return ((_Bool )(c >= 65 && c <= 90));
}
}
#line 295 "c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 

  {
#line 301
  return ((_Bool )((c >= 48 && c <= 57) || ((c & -33) >= 65 && (c & -33) <= 70)));
}
}
#line 322 "c-ctype.c"
int c_tolower(int c ) 
{ 

  {
#line 326
  return (c >= 65 && c <= 90 ? (c - 65) + 97 : c);
}
}
#line 361 "c-ctype.c"
int c_toupper(int c ) 
{ 

  {
#line 365
  return (c >= 97 && c <= 122 ? (c - 97) + 65 : c);
}
}
#line 1 "c-strcasecmp.o"
#pragma merger(0,"/tmp/cil-oFkPjGbg.i","-g,-O2")
#line 44 "c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 29 "c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned int )p1 == (unsigned int )p2) {
#line 37
    return (0);
  }
#line 39
  while (1) {
#line 41
    __cil_tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )__cil_tmp;
#line 42
    __cil_tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )__cil_tmp___0;
#line 44
    if ((int )c1 == 0) {
#line 45
      break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      break;
    }
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 1 "c-strncasecmp.o"
#pragma merger(0,"/tmp/cil-ai8U5wjg.i","-g,-O2")
#line 49 "c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 29 "c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned int )p1 == (unsigned int )p2 || n == 0U) {
#line 37
    return (0);
  }
#line 39
  while (1) {
#line 41
    __cil_tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )__cil_tmp;
#line 42
    __cil_tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )__cil_tmp___0;
#line 44
    n --;
#line 44
    if (n == 0U || (int )c1 == 0) {
#line 45
      break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      break;
    }
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 1 "diacrit.o"
#pragma merger(0,"/tmp/cil-wxMCCOLi.i","-g,-O2")
#line 20 "diacrit.h"
char const   diacrit_base[256] ;
#line 21
char const   diacrit_diac[256] ;
#line 35 "diacrit.c"
char const   diacrit_base[256]  = 
#line 35 "diacrit.c"
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'A', 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'C', 
        (char const   )'E',      (char const   )'E',      (char const   )'E',      (char const   )'E', 
        (char const   )'I',      (char const   )'I',      (char const   )'I',      (char const   )'I', 
        (char const   )0,      (char const   )'N',      (char const   )'O',      (char const   )'O', 
        (char const   )'O',      (char const   )'O',      (char const   )'O',      (char const   )0, 
        (char const   )'O',      (char const   )'U',      (char const   )'U',      (char const   )'U', 
        (char const   )'U',      (char const   )'Y',      (char const   )0,      (char const   )0, 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'a', 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'e',      (char const   )'e',      (char const   )'e', 
        (char const   )'i',      (char const   )'i',      (char const   )'i',      (char const   )'i', 
        (char const   )0,      (char const   )'n',      (char const   )'o',      (char const   )'o', 
        (char const   )'o',      (char const   )'o',      (char const   )'o',      (char const   )0, 
        (char const   )'o',      (char const   )'u',      (char const   )'u',      (char const   )'u', 
        (char const   )'u',      (char const   )'y',      (char const   )0,      (char const   )'y'};
#line 103 "diacrit.c"
char const   diacrit_diac[256]  = 
#line 103
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )4,      (char const   )0, 
        (char const   )3,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )6,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0};
#line 1 "file-set.o"
#pragma merger(0,"/tmp/cil-idNM3E8C.i","-g,-O2")
#line 65 "hash.h"
void *hash_lookup(Hash_table const   *table___0 , void const   *entry ) ;
#line 84
void *hash_insert(Hash_table *table___0 , void const   *entry ) ;
#line 7 "file-set.h"
void record_file(Hash_table *ht___0 , char const   *file , struct stat  const  *stats ) ;
#line 11
_Bool seen_file(Hash_table const   *ht___0 , char const   *file , struct stat  const  *stats ) ;
#line 20 "hash-triple.h"
void triple_free(void *x ) ;
#line 45 "xalloc.h"
void xalloc_die(void) ;
#line 47
void *xmalloc(size_t n ) ;
#line 53
char *xstrdup(char const   *string ) ;
#line 28 "file-set.c"
void record_file(Hash_table *ht___0 , char const   *file , struct stat  const  *stats ) 
{ struct F_triple *ent ;
  void *__cil_tmp ;
  struct F_triple *ent_from_table ;
  void *__cil_tmp___0 ;

  {
#line 33
  if ((unsigned int )ht___0 == (unsigned int )((void *)0)) {
#line 34
    return;
  }
#line 36
  __cil_tmp = xmalloc(sizeof(*ent));
#line 36
  ent = (struct F_triple *)__cil_tmp;
#line 37
  ent->name = xstrdup(file);
#line 38
  ent->st_ino = (unsigned short )stats->st_ino;
#line 39
  ent->st_dev = (short )stats->st_dev;
#line 42
  __cil_tmp___0 = hash_insert(ht___0, (void const   *)ent);
#line 42
  ent_from_table = (struct F_triple *)__cil_tmp___0;
#line 43
  if ((unsigned int )ent_from_table == (unsigned int )((void *)0)) {
#line 46
    xalloc_die();
  }
#line 49
  if ((unsigned int )ent_from_table != (unsigned int )ent) {
#line 53
    triple_free((void *)ent);
  }
#line 56
  return;
}
}
#line 60 "file-set.c"
_Bool seen_file(Hash_table const   *ht___0 , char const   *file , struct stat  const  *stats ) 
{ struct F_triple new_ent ;
  void *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 66
  if ((unsigned int )ht___0 == (unsigned int )((void *)0)) {
#line 67
    return ((_Bool)0);
  }
#line 69
  new_ent.name = (char *)file;
#line 70
  new_ent.st_ino = (unsigned short )stats->st_ino;
#line 71
  new_ent.st_dev = (short )stats->st_dev;
#line 73
  __cil_tmp = hash_lookup(ht___0, (void const   *)(& new_ent));
#line 73
  if (__cil_tmp) {
#line 73
    __cil_tmp___0 = 1;
  } else {
#line 73
    __cil_tmp___0 = 0;
  }
#line 73
  return ((_Bool )__cil_tmp___0);
}
}
#line 1 "fpurge.o"
#pragma merger(0,"/tmp/cil-AaoOgeNn.i","-g,-O2")
#line 485 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int fpurge(FILE * ) ;
#line 32 "fpurge.h"
int rpl_fpurge(FILE *fp ) ;
#line 27 "fpurge.c"
int rpl_fpurge(FILE *fp ) 
{ int result ;
  int __cil_tmp ;

  {
#line 43
  __cil_tmp = fpurge(fp);
#line 43
  result = __cil_tmp;
#line 45
  if (result == 0) {
#line 52
    if (((int )fp->_flags & 4) != 0) {
#line 53
      fp->_w = 0;
    }
  }
#line 55
  return (result);
}
}
#line 1 "freadahead.o"
#pragma merger(0,"/tmp/cil-3GIHp3EE.i","-g,-O2")
#line 32 "freadahead.h"
size_t freadahead(FILE *fp ) ;
#line 22 "freadahead.c"
size_t freadahead(FILE *fp ) 
{ 

  {
#line 30
  if (((int )fp->_flags & 8) != 0 || fp->_r < 0) {
#line 31
    return (0U);
  }
#line 32
  return ((unsigned int )fp->_r);
}
}
#line 1 "freading.o"
#pragma merger(0,"/tmp/cil-yyAgfN8N.i","-g,-O2")
#line 47 "freading.h"
_Bool freading(FILE *fp ) ;
#line 26 "freading.c"
_Bool freading(FILE *fp ) 
{ 

  {
#line 37
  return ((_Bool )(((int )fp->_flags & 4) != 0));
}
}
#line 1 "fseterr.o"
#pragma merger(0,"/tmp/cil-jBb0eqiV.i","-g,-O2")
#line 30 "fseterr.h"
void fseterr(FILE *fp ) ;
#line 24 "fseterr.c"
void fseterr(FILE *fp ) 
{ 

  {
#line 33
  fp->_flags = (short )((int )fp->_flags | 64);
#line 79
  return;
}
}
#line 1 "full-read.o"
#pragma merger(0,"/tmp/cil-y9ZLyC4e.i","-g,-O2")
#line 24 "full-read.h"
size_t full_read(int fd , void *buf___0 , size_t count ) ;
#line 29 "safe-read.h"
size_t safe_read(int fd , void *buf___0 , size_t count ) ;
#line 58 "full-write.c"
size_t full_read(int fd , void *buf___0 , size_t count ) 
{ size_t total ;
  char *ptr ;
  size_t n_rw ;
  size_t __cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 61
  total = 0U;
#line 62
  ptr = (char *)buf___0;
#line 64
  while (count > 0U) {
#line 66
    __cil_tmp = safe_read(fd, (void *)ptr, count);
#line 66
    n_rw = __cil_tmp;
#line 67
    if (n_rw == 4294967295U) {
#line 68
      break;
    }
#line 69
    if (n_rw == 0U) {
#line 71
      __cil_tmp___0 = __errno();
#line 71
      *__cil_tmp___0 = 0;
#line 72
      break;
    }
#line 74
    total += n_rw;
#line 75
    ptr += n_rw;
#line 76
    count -= n_rw;
  }
#line 79
  return (total);
}
}
#line 1 "full-write.o"
#pragma merger(0,"/tmp/cil-mJYzuR2e.i","-g,-O2")
#line 29 "full-write.h"
size_t full_write(int fd , void const   *buf___0 , size_t count ) ;
#line 24 "safe-write.h"
size_t safe_write(int fd , void const   *buf___0 , size_t count ) ;
#line 58 "full-write.c"
size_t full_write(int fd , void const   *buf___0 , size_t count ) 
{ size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t __cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 61
  total = 0U;
#line 62
  ptr = (char const   *)buf___0;
#line 64
  while (count > 0U) {
#line 66
    __cil_tmp = safe_write(fd, (void const   *)ptr, count);
#line 66
    n_rw = __cil_tmp;
#line 67
    if (n_rw == 4294967295U) {
#line 68
      break;
    }
#line 69
    if (n_rw == 0U) {
#line 71
      __cil_tmp___0 = __errno();
#line 71
      *__cil_tmp___0 = 28;
#line 72
      break;
    }
#line 74
    total += n_rw;
#line 75
    ptr += n_rw;
#line 76
    count -= n_rw;
  }
#line 79
  return (total);
}
}
#line 1 "getdate.o"
#pragma merger(0,"/tmp/cil-mDz1yf7E.i","-g,-O2")
#line 48 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/time.h"
time_t rpl_mktime(struct tm *tp ) ;
#line 53
struct tm *rpl_gmtime(time_t const   *timep ) ;
#line 54
struct tm *rpl_localtime(time_t const   *timep ) ;
#line 120
extern char *_tzname[2] ;
#line 22 "getdate.h"
_Bool get_date(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
#line 33 "timespec.h"
void gettime(struct timespec *ts ) ;
#line 43 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/ctype.h"
extern char const   *__ctype_ptr__ ;
#line 226 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 82 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern char *getenv(char const   *__string ) ;
#line 151
int setenv(char const   *name , char const   *value , int replace ) ;
#line 196
extern int unsetenv(char const   *__string ) ;
#line 24 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 29
extern int strcmp(char const   * , char const   * ) ;
#line 34
extern size_t strlen(char const   * ) ;
#line 36
extern int strncmp(char const   * , char const   * , size_t  ) ;
#line 52 "xalloc.h"
void *xmemdup(void const   *p , size_t s ) ;
#line 156 "getdate.y"
static relative_time const   RELATIVE_TIME_0  ;
#line 206
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 207
static int yyerror(parser_control const   *pc , char const   *s ) ;
#line 208
static long time_zone_hhmm(textint s , long mm ) ;
#line 213 "getdate.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 

  {
#line 216
  if (((pc->dates_seen && ! pc->year.digits) && ! pc->rels_seen) && (pc->times_seen || 2U < text_int.digits)) {
#line 218
    pc->year = text_int;
  } else
#line 221
  if (4U < text_int.digits) {
#line 223
    (pc->dates_seen) ++;
#line 224
    pc->day = text_int.value % 100L;
#line 225
    pc->month = (text_int.value / 100L) % 100L;
#line 226
    pc->year.value = text_int.value / 10000L;
#line 227
    pc->year.digits = text_int.digits - 4U;
  } else {
#line 231
    (pc->times_seen) ++;
#line 232
    if (text_int.digits <= 2U) {
#line 234
      pc->hour = text_int.value;
#line 235
      pc->minutes = 0L;
    } else {
#line 239
      pc->hour = text_int.value / 100L;
#line 240
      pc->minutes = text_int.value % 100L;
    }
#line 242
    pc->seconds.tv_sec = 0L;
#line 243
    pc->seconds.tv_nsec = 0L;
#line 244
    pc->meridian = 2;
  }
#line 247
  return;
}
}
#line 644 "getdate.c"
static yytype_uint8 const   yytranslate[277]  = 
#line 644 "getdate.c"
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )24,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )25, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )23,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )22,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )16, 
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21};
#line 763 "getdate.c"
static yytype_uint8 const   yyr1[81]  = 
#line 763
  {      (unsigned char const   )0,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )29,      (unsigned char const   )30, 
        (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )30, 
        (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )35,      (unsigned char const   )35,      (unsigned char const   )35,      (unsigned char const   )35, 
        (unsigned char const   )35,      (unsigned char const   )35,      (unsigned char const   )35,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )37, 
        (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37, 
        (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37, 
        (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37, 
        (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37, 
        (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )37,      (unsigned char const   )38, 
        (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38,      (unsigned char const   )38, 
        (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )41,      (unsigned char const   )42, 
        (unsigned char const   )43,      (unsigned char const   )44,      (unsigned char const   )44,      (unsigned char const   )45, 
        (unsigned char const   )45};
#line 777 "getdate.c"
static yytype_uint8 const   yyr2[81]  = 
#line 777
  {      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )5,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )1};
#line 793 "getdate.c"
static yytype_uint8 const   yydefact[98]  = 
#line 793
  {      (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )72,      (unsigned char const   )74,      (unsigned char const   )71, 
        (unsigned char const   )73,      (unsigned char const   )4,      (unsigned char const   )69,      (unsigned char const   )70, 
        (unsigned char const   )1,      (unsigned char const   )44,      (unsigned char const   )47,      (unsigned char const   )53, 
        (unsigned char const   )56,      (unsigned char const   )61,      (unsigned char const   )50,      (unsigned char const   )27, 
        (unsigned char const   )25,      (unsigned char const   )20,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )22,      (unsigned char const   )0,      (unsigned char const   )75,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )11,      (unsigned char const   )10,      (unsigned char const   )12, 
        (unsigned char const   )41,      (unsigned char const   )62,      (unsigned char const   )13,      (unsigned char const   )14, 
        (unsigned char const   )28,      (unsigned char const   )21,      (unsigned char const   )0,      (unsigned char const   )36, 
        (unsigned char const   )42,      (unsigned char const   )45,      (unsigned char const   )51,      (unsigned char const   )54, 
        (unsigned char const   )57,      (unsigned char const   )48,      (unsigned char const   )29,      (unsigned char const   )26, 
        (unsigned char const   )77,      (unsigned char const   )23,      (unsigned char const   )63,      (unsigned char const   )64, 
        (unsigned char const   )66,      (unsigned char const   )67,      (unsigned char const   )68,      (unsigned char const   )65, 
        (unsigned char const   )43,      (unsigned char const   )46,      (unsigned char const   )52,      (unsigned char const   )55, 
        (unsigned char const   )58,      (unsigned char const   )49,      (unsigned char const   )30,      (unsigned char const   )15, 
        (unsigned char const   )38,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )76,      (unsigned char const   )59,      (unsigned char const   )60,      (unsigned char const   )40, 
        (unsigned char const   )35,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )24, 
        (unsigned char const   )34,      (unsigned char const   )39,      (unsigned char const   )33,      (unsigned char const   )79, 
        (unsigned char const   )31,      (unsigned char const   )37,      (unsigned char const   )78,      (unsigned char const   )80, 
        (unsigned char const   )77,      (unsigned char const   )0,      (unsigned char const   )16,      (unsigned char const   )0, 
        (unsigned char const   )17,      (unsigned char const   )79,      (unsigned char const   )32,      (unsigned char const   )77, 
        (unsigned char const   )18,      (unsigned char const   )19};
#line 808 "getdate.c"
static yytype_int8 const   yydefgoto[20]  = 
#line 808
  {      (signed char const   )-1,      (signed char const   )2,      (signed char const   )3,      (signed char const   )4, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )9,      (signed char const   )10,      (signed char const   )11, 
        (signed char const   )38,      (signed char const   )39,      (signed char const   )79,      (signed char const   )90};
#line 817 "getdate.c"
static yytype_int8 const   yypact[98]  = 
#line 817
  {      (signed char const   )-10,      (signed char const   )54,      (signed char const   )70,      (signed char const   )-81, 
        (signed char const   )25,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )55, 
        (signed char const   )-81,      (signed char const   )74,      (signed char const   )50,      (signed char const   )48, 
        (signed char const   )10,      (signed char const   )56,      (signed char const   )-5,      (signed char const   )71, 
        (signed char const   )72,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )79,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )65,      (signed char const   )60, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )16,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )58,      (signed char const   )42,      (signed char const   )66,      (signed char const   )67, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )68,      (signed char const   )69,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-7, 
        (signed char const   )64,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )73,      (signed char const   )-2,      (signed char const   )-81,      (signed char const   )75, 
        (signed char const   )-81,      (signed char const   )53,      (signed char const   )-81,      (signed char const   )73, 
        (signed char const   )-81,      (signed char const   )-81};
#line 832 "getdate.c"
static yytype_int8 const   yypgoto[20]  = 
#line 832
  {      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-81, 
        (signed char const   )3,      (signed char const   )-81,      (signed char const   )-81,      (signed char const   )1, 
        (signed char const   )-81,      (signed char const   )-81,      (signed char const   )-80,      (signed char const   )-1};
#line 843 "getdate.c"
static yytype_uint8 const   yytable[97]  = 
#line 843
  {      (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )87, 
        (unsigned char const   )92,      (unsigned char const   )67,      (unsigned char const   )68,      (unsigned char const   )88, 
        (unsigned char const   )1,      (unsigned char const   )69,      (unsigned char const   )51,      (unsigned char const   )97, 
        (unsigned char const   )89,      (unsigned char const   )6,      (unsigned char const   )70,      (unsigned char const   )8, 
        (unsigned char const   )71,      (unsigned char const   )54,      (unsigned char const   )55,      (unsigned char const   )56, 
        (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )53, 
        (unsigned char const   )52,      (unsigned char const   )72,      (unsigned char const   )13,      (unsigned char const   )14, 
        (unsigned char const   )15,      (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18, 
        (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )78, 
        (unsigned char const   )22,      (unsigned char const   )23,      (unsigned char const   )24,      (unsigned char const   )25, 
        (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28,      (unsigned char const   )54, 
        (unsigned char const   )55,      (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58, 
        (unsigned char const   )59,      (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46, 
        (unsigned char const   )47,      (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50, 
        (unsigned char const   )82,      (unsigned char const   )54,      (unsigned char const   )55,      (unsigned char const   )56, 
        (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59,      (unsigned char const   )87, 
        (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )12,      (unsigned char const   )95, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )80,      (unsigned char const   )81,      (unsigned char const   )41,      (unsigned char const   )40, 
        (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )75,      (unsigned char const   )76, 
        (unsigned char const   )77,      (unsigned char const   )83,      (unsigned char const   )84,      (unsigned char const   )85, 
        (unsigned char const   )86,      (unsigned char const   )91,      (unsigned char const   )93,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )94,      (unsigned char const   )0, 
        (unsigned char const   )78};
#line 857 "getdate.c"
static yytype_int8 const   yycheck[97]  = 
#line 857
  {      (signed char const   )5,      (signed char const   )6,      (signed char const   )7,      (signed char const   )8, 
        (signed char const   )9,      (signed char const   )10,      (signed char const   )11,      (signed char const   )14, 
        (signed char const   )88,      (signed char const   )14,      (signed char const   )15,      (signed char const   )18, 
        (signed char const   )22,      (signed char const   )18,      (signed char const   )4,      (signed char const   )95, 
        (signed char const   )23,      (signed char const   )19,      (signed char const   )23,      (signed char const   )21, 
        (signed char const   )25,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )10,      (signed char const   )24, 
        (signed char const   )18,      (signed char const   )26,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )23, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )5, 
        (signed char const   )6,      (signed char const   )7,      (signed char const   )8,      (signed char const   )9, 
        (signed char const   )10,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )10,      (signed char const   )11, 
        (signed char const   )18,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )10,      (signed char const   )14, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )0,      (signed char const   )18, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )20,      (signed char const   )21, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )4,      (signed char const   )24, 
        (signed char const   )9,      (signed char const   )9,      (signed char const   )3,      (signed char const   )18, 
        (signed char const   )24,      (signed char const   )19,      (signed char const   )19,      (signed char const   )19, 
        (signed char const   )19,      (signed char const   )25,      (signed char const   )89,      (signed char const   )-1, 
        (signed char const   )93,      (signed char const   )-1,      (signed char const   )19,      (signed char const   )-1, 
        (signed char const   )23};
#line 873 "getdate.c"
static yytype_uint8 const   yystos[98]  = 
#line 873
  {      (unsigned char const   )0,      (unsigned char const   )22,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21,      (unsigned char const   )39,      (unsigned char const   )40,      (unsigned char const   )41, 
        (unsigned char const   )0,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )15,      (unsigned char const   )16, 
        (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )20, 
        (unsigned char const   )21,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )24,      (unsigned char const   )4,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )4, 
        (unsigned char const   )18,      (unsigned char const   )38,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7,      (unsigned char const   )8, 
        (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )14, 
        (unsigned char const   )15,      (unsigned char const   )18,      (unsigned char const   )23,      (unsigned char const   )25, 
        (unsigned char const   )38,      (unsigned char const   )9,      (unsigned char const   )9,      (unsigned char const   )3, 
        (unsigned char const   )18,      (unsigned char const   )24,      (unsigned char const   )23,      (unsigned char const   )44, 
        (unsigned char const   )18,      (unsigned char const   )19,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )19,      (unsigned char const   )19,      (unsigned char const   )19,      (unsigned char const   )14, 
        (unsigned char const   )18,      (unsigned char const   )23,      (unsigned char const   )45,      (unsigned char const   )25, 
        (unsigned char const   )44,      (unsigned char const   )41,      (unsigned char const   )19,      (unsigned char const   )18, 
        (unsigned char const   )45,      (unsigned char const   )44};
#line 1381 "getdate.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 

  {
#line 1395
  if (! yymsg) {
#line 1396
    yymsg = "Deleting";
  }
#line 1399
  switch (yytype) {
  default: 
#line 1403
  break;
  }
#line 1405
  return;
}
}
#line 1418
int yyparse(parser_control *pc ) ;
#line 1446 "getdate.c"
int yyparse(parser_control *pc ) 
{ int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  size_t yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  size_t yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *__cil_tmp ;
  size_t yynewbytes ;
  size_t yyi ;
  size_t yynewbytes___0 ;
  size_t yyi___0 ;
  long __cil_tmp___0 ;

  {
#line 1470
  yytoken = 0;
#line 1488
  yyss = yyssa;
#line 1493
  yyvs = yyvsa;
#line 1500
  yystacksize = 20U;
#line 1509
  yylen = 0;
#line 1513
  yystate = 0;
#line 1514
  yyerrstatus = 0;
#line 1515
  yynerrs = 0;
#line 1516
  yychar = -2;
#line 1523
  yyssp = yyss;
#line 1524
  yyvsp = yyvs;
#line 1526
  goto yysetstate;
  yynewstate: 
#line 1534
  yyssp ++;
  yysetstate: 
#line 1537
  *yyssp = (short )yystate;
#line 1539
  if ((unsigned int )((yyss + yystacksize) - 1) <= (unsigned int )yyssp) {
#line 1542
    yysize = (unsigned int )((yyssp - yyss) + 1);
#line 1571
    if (20U <= yystacksize) {
#line 1572
      goto yyexhaustedlab;
    }
#line 1573
    yystacksize *= 2U;
#line 1574
    if (20U < yystacksize) {
#line 1575
      yystacksize = 20U;
    }
#line 1578
    yyss1 = yyss;
#line 1579
    __cil_tmp = rpl_malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1U));
#line 1579
    yyptr = (union yyalloc *)__cil_tmp;
#line 1581
    if (! yyptr) {
#line 1582
      goto yyexhaustedlab;
    }
#line 1583
    while (1) {
#line 1583
      while (1) {
#line 1583
        yyi = 0U;
#line 1583
        while (yyi < yysize) {
#line 1583
          *(& yyptr->yyss + yyi) = *(yyss + yyi);
#line 1583
          yyi ++;
        }
#line 1583
        break;
      }
#line 1583
      yyss = & yyptr->yyss;
#line 1583
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1U);
#line 1583
      yyptr += yynewbytes / sizeof(*yyptr);
#line 1583
      break;
    }
#line 1584
    while (1) {
#line 1584
      while (1) {
#line 1584
        yyi___0 = 0U;
#line 1584
        while (yyi___0 < yysize) {
#line 1584
          *(& yyptr->yyvs + yyi___0) = *(yyvs + yyi___0);
#line 1584
          yyi___0 ++;
        }
#line 1584
        break;
      }
#line 1584
      yyvs = & yyptr->yyvs;
#line 1584
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1U);
#line 1584
      yyptr += yynewbytes___0 / sizeof(*yyptr);
#line 1584
      break;
    }
#line 1587
    if ((unsigned int )yyss1 != (unsigned int )(yyssa)) {
#line 1588
      free((void *)yyss1);
    }
#line 1593
    yyssp = (yyss + yysize) - 1;
#line 1594
    yyvsp = (yyvs + yysize) - 1;
#line 1600
    if ((unsigned int )((yyss + yystacksize) - 1) <= (unsigned int )yyssp) {
#line 1601
      goto yyabortlab;
    }
  }
#line 1606
  if (yystate == 12) {
#line 1607
    goto yyacceptlab;
  }
#line 1609
  goto yybackup;
  yybackup: 
#line 1620
  yyn = (int )yypact[yystate];
#line 1621
  if (yyn == -81) {
#line 1622
    goto yydefault;
  }
#line 1627
  if (yychar == -2) {
#line 1630
    yychar = yylex(& yylval, pc);
  }
#line 1633
  if (yychar <= 0) {
#line 1635
    yytoken = 0;
#line 1635
    yychar = yytoken;
  } else {
#line 1640
    yytoken = (int )((unsigned int )yychar <= 276U ? (int const   )yytranslate[yychar] : (int const   )2);
  }
#line 1646
  yyn += yytoken;
#line 1647
  if ((yyn < 0 || 96 < yyn) || (int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1648
    goto yydefault;
  }
#line 1649
  yyn = (int )yytable[yyn];
#line 1650
  if (yyn <= 0) {
#line 1652
    if (yyn == 0 || yyn == -1) {
#line 1653
      goto yyerrlab;
    }
#line 1654
    yyn = - yyn;
#line 1655
    goto yyreduce;
  }
#line 1660
  if (yyerrstatus) {
#line 1661
    yyerrstatus --;
  }
#line 1667
  yychar = -2;
#line 1669
  yystate = yyn;
#line 1670
  yyvsp ++;
#line 1670
  *yyvsp = yylval;
#line 1672
  goto yynewstate;
  yydefault: 
#line 1679
  yyn = (int )yydefact[yystate];
#line 1680
  if (yyn == 0) {
#line 1681
    goto yyerrlab;
  }
#line 1682
  goto yyreduce;
  yyreduce: 
#line 1690
  yylen = (int )yyr2[yyn];
#line 1700
  yyval = *(yyvsp + (1 - yylen));
#line 1704
  switch (yyn) {
  case 4: 
#line 294 "getdate.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 295
  pc->timespec_seen = (_Bool)1;
#line 297
  break;
  case 7: 
#line 306
  (pc->times_seen) ++;
#line 307
  break;
  case 8: 
#line 308
  (pc->local_zones_seen) ++;
#line 309
  break;
  case 9: 
#line 310
  (pc->zones_seen) ++;
#line 311
  break;
  case 10: 
#line 312
  (pc->dates_seen) ++;
#line 313
  break;
  case 11: 
#line 314
  (pc->days_seen) ++;
#line 315
  break;
  case 12: 
#line 316
  pc->rels_seen = (_Bool)1;
#line 317
  break;
  case 15: 
#line 324
  pc->hour = (yyvsp + -1)->textintval.value;
#line 325
  pc->minutes = 0L;
#line 326
  pc->seconds.tv_sec = 0L;
#line 327
  pc->seconds.tv_nsec = 0L;
#line 328
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 330
  break;
  case 16: 
#line 332
  pc->hour = (yyvsp + -3)->textintval.value;
#line 333
  pc->minutes = (yyvsp + -1)->textintval.value;
#line 334
  pc->seconds.tv_sec = 0L;
#line 335
  pc->seconds.tv_nsec = 0L;
#line 336
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 338
  break;
  case 17: 
#line 340
  pc->hour = (yyvsp + -4)->textintval.value;
#line 341
  pc->minutes = (yyvsp + -2)->textintval.value;
#line 342
  pc->seconds.tv_sec = 0L;
#line 343
  pc->seconds.tv_nsec = 0L;
#line 344
  pc->meridian = 2;
#line 345
  (pc->zones_seen) ++;
#line 346
  pc->time_zone = time_zone_hhmm((yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 348
  break;
  case 18: 
#line 350
  pc->hour = (yyvsp + -5)->textintval.value;
#line 351
  pc->minutes = (yyvsp + -3)->textintval.value;
#line 352
  pc->seconds = (yyvsp + -1)->timespec;
#line 353
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 355
  break;
  case 19: 
#line 357
  pc->hour = (yyvsp + -6)->textintval.value;
#line 358
  pc->minutes = (yyvsp + -4)->textintval.value;
#line 359
  pc->seconds = (yyvsp + -2)->timespec;
#line 360
  pc->meridian = 2;
#line 361
  (pc->zones_seen) ++;
#line 362
  pc->time_zone = time_zone_hhmm((yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 364
  break;
  case 20: 
#line 369
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 370
  pc->dsts_seen += (unsigned int )(0L < (yyvsp + 0)->intval);
#line 372
  break;
  case 21: 
#line 374
  pc->local_isdst = 1;
#line 375
  pc->dsts_seen += (unsigned int )((0L < (yyvsp + -1)->intval) + 1);
#line 377
  break;
  case 22: 
#line 381
  pc->time_zone = (yyvsp + 0)->intval;
#line 382
  break;
  case 23: 
#line 383
  pc->time_zone = (yyvsp + -1)->intval;
#line 384
  pc->rel.ns += (yyvsp + 0)->rel.ns;
#line 385
  pc->rel.seconds += (yyvsp + 0)->rel.seconds;
#line 386
  pc->rel.minutes += (yyvsp + 0)->rel.minutes;
#line 387
  pc->rel.hour += (yyvsp + 0)->rel.hour;
#line 388
  pc->rel.day += (yyvsp + 0)->rel.day;
#line 389
  pc->rel.month += (yyvsp + 0)->rel.month;
#line 390
  pc->rel.year += (yyvsp + 0)->rel.year;
#line 391
  pc->rels_seen = (_Bool)1;
#line 392
  break;
  case 24: 
#line 393
  __cil_tmp___0 = time_zone_hhmm((yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 393
  pc->time_zone = (yyvsp + -2)->intval + __cil_tmp___0;
#line 394
  break;
  case 25: 
#line 395
  pc->time_zone = (yyvsp + 0)->intval + 60L;
#line 396
  break;
  case 26: 
#line 397
  pc->time_zone = (yyvsp + -1)->intval + 60L;
#line 398
  break;
  case 27: 
#line 403
  pc->day_ordinal = 1L;
#line 404
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 406
  break;
  case 28: 
#line 408
  pc->day_ordinal = 1L;
#line 409
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 411
  break;
  case 29: 
#line 413
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 414
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 416
  break;
  case 30: 
#line 418
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 419
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 421
  break;
  case 31: 
#line 426
  pc->month = (yyvsp + -2)->textintval.value;
#line 427
  pc->day = (yyvsp + 0)->textintval.value;
#line 429
  break;
  case 32: 
#line 436
  if (4U <= (yyvsp + -4)->textintval.digits) {
#line 438
    pc->year = (yyvsp + -4)->textintval;
#line 439
    pc->month = (yyvsp + -2)->textintval.value;
#line 440
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 444
    pc->month = (yyvsp + -4)->textintval.value;
#line 445
    pc->day = (yyvsp + -2)->textintval.value;
#line 446
    pc->year = (yyvsp + 0)->textintval;
  }
#line 449
  break;
  case 33: 
#line 452
  pc->year = (yyvsp + -2)->textintval;
#line 453
  pc->month = - (yyvsp + -1)->textintval.value;
#line 454
  pc->day = - (yyvsp + 0)->textintval.value;
#line 456
  break;
  case 34: 
#line 459
  pc->day = (yyvsp + -2)->textintval.value;
#line 460
  pc->month = (yyvsp + -1)->intval;
#line 461
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 462
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 464
  break;
  case 35: 
#line 467
  pc->month = (yyvsp + -2)->intval;
#line 468
  pc->day = - (yyvsp + -1)->textintval.value;
#line 469
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 470
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 472
  break;
  case 36: 
#line 474
  pc->month = (yyvsp + -1)->intval;
#line 475
  pc->day = (yyvsp + 0)->textintval.value;
#line 477
  break;
  case 37: 
#line 479
  pc->month = (yyvsp + -3)->intval;
#line 480
  pc->day = (yyvsp + -2)->textintval.value;
#line 481
  pc->year = (yyvsp + 0)->textintval;
#line 483
  break;
  case 38: 
#line 485
  pc->day = (yyvsp + -1)->textintval.value;
#line 486
  pc->month = (yyvsp + 0)->intval;
#line 488
  break;
  case 39: 
#line 490
  pc->day = (yyvsp + -2)->textintval.value;
#line 491
  pc->month = (yyvsp + -1)->intval;
#line 492
  pc->year = (yyvsp + 0)->textintval;
#line 494
  break;
  case 40: 
#line 499
  pc->rel.ns -= (yyvsp + -1)->rel.ns;
#line 500
  pc->rel.seconds -= (yyvsp + -1)->rel.seconds;
#line 501
  pc->rel.minutes -= (yyvsp + -1)->rel.minutes;
#line 502
  pc->rel.hour -= (yyvsp + -1)->rel.hour;
#line 503
  pc->rel.day -= (yyvsp + -1)->rel.day;
#line 504
  pc->rel.month -= (yyvsp + -1)->rel.month;
#line 505
  pc->rel.year -= (yyvsp + -1)->rel.year;
#line 507
  break;
  case 41: 
#line 509
  pc->rel.ns += (yyvsp + 0)->rel.ns;
#line 510
  pc->rel.seconds += (yyvsp + 0)->rel.seconds;
#line 511
  pc->rel.minutes += (yyvsp + 0)->rel.minutes;
#line 512
  pc->rel.hour += (yyvsp + 0)->rel.hour;
#line 513
  pc->rel.day += (yyvsp + 0)->rel.day;
#line 514
  pc->rel.month += (yyvsp + 0)->rel.month;
#line 515
  pc->rel.year += (yyvsp + 0)->rel.year;
#line 517
  break;
  case 42: 
#line 521
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 521
  yyval.rel.year = (yyvsp + -1)->intval;
#line 522
  break;
  case 43: 
#line 523
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 523
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 524
  break;
  case 44: 
#line 525
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 525
  yyval.rel.year = 1L;
#line 526
  break;
  case 45: 
#line 527
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 527
  yyval.rel.month = (yyvsp + -1)->intval;
#line 528
  break;
  case 46: 
#line 529
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 529
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 530
  break;
  case 47: 
#line 531
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 531
  yyval.rel.month = 1L;
#line 532
  break;
  case 48: 
#line 533
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 533
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
#line 534
  break;
  case 49: 
#line 535
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 535
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 536
  break;
  case 50: 
#line 537
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 537
  yyval.rel.day = (yyvsp + 0)->intval;
#line 538
  break;
  case 51: 
#line 539
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 539
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 540
  break;
  case 52: 
#line 541
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 541
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 542
  break;
  case 53: 
#line 543
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 543
  yyval.rel.hour = 1L;
#line 544
  break;
  case 54: 
#line 545
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 545
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 546
  break;
  case 55: 
#line 547
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 547
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 548
  break;
  case 56: 
#line 549
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 549
  yyval.rel.minutes = 1L;
#line 550
  break;
  case 57: 
#line 551
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 551
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 552
  break;
  case 58: 
#line 553
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 553
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 554
  break;
  case 59: 
#line 555
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 555
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 555
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 556
  break;
  case 60: 
#line 557
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 557
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 557
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 558
  break;
  case 61: 
#line 559
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 559
  yyval.rel.seconds = 1L;
#line 560
  break;
  case 63: 
#line 565
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 565
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 566
  break;
  case 64: 
#line 567
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 567
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 568
  break;
  case 65: 
#line 569
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 569
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 570
  break;
  case 66: 
#line 571
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 571
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 572
  break;
  case 67: 
#line 573
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 573
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 574
  break;
  case 68: 
#line 575
  yyval.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 575
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 576
  break;
  case 72: 
#line 583
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 583
  yyval.timespec.tv_nsec = 0L;
#line 584
  break;
  case 74: 
#line 589
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 589
  yyval.timespec.tv_nsec = 0L;
#line 590
  break;
  case 75: 
#line 594
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
#line 595
  break;
  case 76: 
#line 602
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 603
  pc->rel.ns += (yyvsp + 0)->rel.ns;
#line 604
  pc->rel.seconds += (yyvsp + 0)->rel.seconds;
#line 605
  pc->rel.minutes += (yyvsp + 0)->rel.minutes;
#line 606
  pc->rel.hour += (yyvsp + 0)->rel.hour;
#line 607
  pc->rel.day += (yyvsp + 0)->rel.day;
#line 608
  pc->rel.month += (yyvsp + 0)->rel.month;
#line 609
  pc->rel.year += (yyvsp + 0)->rel.year;
#line 610
  pc->rels_seen = (_Bool)1;
#line 612
  break;
  case 77: 
#line 616
  yyval.intval = -1L;
#line 617
  break;
  case 78: 
#line 618
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 619
  break;
  case 79: 
#line 623
  yyval.intval = 2L;
#line 624
  break;
  case 80: 
#line 625
  yyval.intval = (yyvsp + 0)->intval;
#line 626
  break;
  default: 
#line 2258 "getdate.c"
  break;
  }
#line 2262
  yyvsp -= yylen;
#line 2262
  yyssp -= yylen;
#line 2263
  yylen = 0;
#line 2266
  yyvsp ++;
#line 2266
  *yyvsp = yyval;
#line 2273
  yyn = (int )yyr1[yyn];
#line 2275
  yystate = (int )((int const   )yypgoto[yyn - 26] + (int const   )*yyssp);
#line 2276
  if ((0 <= yystate && yystate <= 96) && (int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2277
    yystate = (int )yytable[yystate];
  } else {
#line 2279
    yystate = (int )yydefgoto[yyn - 26];
  }
#line 2281
  goto yynewstate;
  yyerrlab: 
#line 2289
  if (! yyerrstatus) {
#line 2291
    yynerrs ++;
#line 2293
    yyerror((parser_control const   *)pc, "syntax error");
  }
#line 2331
  if (yyerrstatus == 3) {
#line 2336
    if (yychar <= 0) {
#line 2339
      if (yychar == 0) {
#line 2340
        goto yyabortlab;
      }
    } else {
#line 2344
      yydestruct("Error: discarding", yytoken, & yylval, pc);
#line 2346
      yychar = -2;
    }
  }
#line 2352
  goto yyerrlab1;
#line 2368
  yyvsp -= yylen;
#line 2368
  yyssp -= yylen;
#line 2369
  yylen = 0;
#line 2371
  yystate = (int )*yyssp;
#line 2372
  goto yyerrlab1;
  yyerrlab1: 
#line 2379
  yyerrstatus = 3;
#line 2381
  while (1) {
#line 2383
    yyn = (int )yypact[yystate];
#line 2384
    if (yyn != -81) {
#line 2386
      yyn ++;
#line 2387
      if ((0 <= yyn && yyn <= 96) && (int const   )yycheck[yyn] == 1) {
#line 2389
        yyn = (int )yytable[yyn];
#line 2390
        if (0 < yyn) {
#line 2391
          break;
        }
      }
    }
#line 2396
    if ((unsigned int )yyssp == (unsigned int )yyss) {
#line 2397
      goto yyabortlab;
    }
#line 2400
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
#line 2402
    yyvsp --;
#line 2402
    yyssp --;
#line 2403
    yystate = (int )*yyssp;
  }
#line 2407
  yyvsp ++;
#line 2407
  *yyvsp = yylval;
#line 2413
  yystate = yyn;
#line 2414
  goto yynewstate;
  yyacceptlab: 
#line 2421
  yyresult = 0;
#line 2422
  goto yyreturn;
  yyabortlab: 
#line 2428
  yyresult = 1;
#line 2429
  goto yyreturn;
  yyexhaustedlab: 
#line 2436
  yyerror((parser_control const   *)pc, "memory exhausted");
#line 2437
  yyresult = 2;
  yyreturn: 
#line 2442
  if (yychar != -2) {
#line 2443
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
  }
#line 2447
  yyvsp -= yylen;
#line 2447
  yyssp -= yylen;
#line 2449
  while ((unsigned int )yyssp != (unsigned int )yyss) {
#line 2451
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
#line 2453
    yyvsp --;
#line 2453
    yyssp --;
  }
#line 2456
  if ((unsigned int )yyss != (unsigned int )(yyssa)) {
#line 2457
    free((void *)yyss);
  }
#line 2464
  return (yyresult);
}
}
#line 630 "getdate.y"
static table const   meridian_table[5]  = {      {"AM", 269, 0}, 
        {"A.M.", 269, 0}, 
        {"PM", 269, 1}, 
        {"P.M.", 269, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 639 "getdate.y"
static table const   dst_table[1]  = {      {"DST", 259, 0}};
#line 644 "getdate.y"
static table const   month_and_day_table[25]  = 
#line 644
  {      {"JANUARY", 270, 1}, 
        {"FEBRUARY", 270, 2}, 
        {"MARCH", 270, 3}, 
        {"APRIL", 270, 4}, 
        {"MAY", 270, 5}, 
        {"JUNE", 270, 6}, 
        {"JULY", 270, 7}, 
        {"AUGUST", 270, 8}, 
        {"SEPTEMBER", 270, 9}, 
        {"SEPT", 270, 9}, 
        {"OCTOBER", 270, 10}, 
        {"NOVEMBER", 270, 11}, 
        {"DECEMBER", 270, 12}, 
        {"SUNDAY", 266, 0}, 
        {"MONDAY", 266, 1}, 
        {"TUESDAY", 266, 2}, 
        {"TUES", 266, 2}, 
        {"WEDNESDAY", 266, 3}, 
        {"WEDNES", 266, 3}, 
        {"THURSDAY", 266, 4}, 
        {"THUR", 266, 4}, 
        {"THURS", 266, 4}, 
        {"FRIDAY", 266, 5}, 
        {"SATURDAY", 266, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 673 "getdate.y"
static table const   time_units_table[11]  = 
#line 673
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 689 "getdate.y"
static table const   relative_time_table[20]  = 
#line 689
  {      {"TOMORROW", 265, 1}, 
        {"YESTERDAY", 265, -1}, 
        {"TODAY", 265, 0}, 
        {"NOW", 265, 0}, 
        {"LAST", 271, -1}, 
        {"THIS", 271, 0}, 
        {"NEXT", 271, 1}, 
        {"FIRST", 271, 1}, 
        {"THIRD", 271, 3}, 
        {"FOURTH", 271, 4}, 
        {"FIFTH", 271, 5}, 
        {"SIXTH", 271, 6}, 
        {"SEVENTH", 271, 7}, 
        {"EIGHTH", 271, 8}, 
        {"NINTH", 271, 9}, 
        {"TENTH", 271, 10}, 
        {"ELEVENTH", 271, 11}, 
        {"TWELFTH", 271, 12}, 
        {"AGO", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 717 "getdate.y"
static table const   universal_time_zone_table[4]  = {      {"GMT", 272, 0}, 
        {"UT", 272, 0}, 
        {"UTC", 272, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 730 "getdate.y"
static table const   time_zone_table[48]  = 
#line 730
  {      {"WET", 272, 0}, 
        {"WEST", 267, 0}, 
        {"BST", 267, 0}, 
        {"ART", 272, -180}, 
        {"BRT", 272, -180}, 
        {"BRST", 267, -180}, 
        {"NST", 272, -210}, 
        {"NDT", 267, -210}, 
        {"AST", 272, -240}, 
        {"ADT", 267, -240}, 
        {"CLT", 272, -240}, 
        {"CLST", 267, -240}, 
        {"EST", 272, -300}, 
        {"EDT", 267, -300}, 
        {"CST", 272, -360}, 
        {"CDT", 267, -360}, 
        {"MST", 272, -420}, 
        {"MDT", 267, -420}, 
        {"PST", 272, -480}, 
        {"PDT", 267, -480}, 
        {"AKST", 272, -540}, 
        {"AKDT", 267, -540}, 
        {"HST", 272, -600}, 
        {"HAST", 272, -600}, 
        {"HADT", 267, -600}, 
        {"SST", 272, -720}, 
        {"WAT", 272, 60}, 
        {"CET", 272, 60}, 
        {"CEST", 267, 60}, 
        {"MET", 272, 60}, 
        {"MEZ", 272, 60}, 
        {"MEST", 267, 60}, 
        {"MESZ", 267, 60}, 
        {"EET", 272, 120}, 
        {"EEST", 267, 120}, 
        {"CAT", 272, 120}, 
        {"SAST", 272, 120}, 
        {"EAT", 272, 180}, 
        {"MSK", 272, 180}, 
        {"MSD", 267, 180}, 
        {"IST", 272, 330}, 
        {"SGT", 272, 480}, 
        {"KST", 272, 540}, 
        {"JST", 272, 540}, 
        {"GST", 272, 600}, 
        {"NZST", 272, 720}, 
        {"NZDT", 267, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 783 "getdate.y"
static table const   military_table[26]  = 
#line 783
  {      {"A", 272, -60}, 
        {"B", 272, -120}, 
        {"C", 272, -180}, 
        {"D", 272, -240}, 
        {"E", 272, -300}, 
        {"F", 272, -360}, 
        {"G", 272, -420}, 
        {"H", 272, -480}, 
        {"I", 272, -540}, 
        {"K", 272, -600}, 
        {"L", 272, -660}, 
        {"M", 272, -720}, 
        {"N", 272, 60}, 
        {"O", 272, 120}, 
        {"P", 272, 180}, 
        {"Q", 272, 240}, 
        {"R", 272, 300}, 
        {"S", 272, 360}, 
        {"T", 272, 420}, 
        {"U", 272, 480}, 
        {"V", 272, 540}, 
        {"W", 272, 600}, 
        {"X", 272, 660}, 
        {"Y", 272, 720}, 
        {"Z", 272, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 819 "getdate.y"
static long time_zone_hhmm(textint s , long mm ) 
{ 

  {
#line 822
  if (mm < 0L) {
#line 823
    return ((s.value / 100L) * 60L + s.value % 100L);
  } else {
#line 825
    return (s.value * 60L + (s.negative ? - mm : mm));
  }
}
}
#line 828 "getdate.y"
static int to_hour(long hours , int meridian ) 
{ 

  {
#line 831
  switch (meridian) {
  default: 
#line 835
  return ((int )(0L <= hours && hours < 24L ? hours : -1L));
  case 0: 
#line 837
  return ((int )(0L < hours && hours < 12L ? hours : (long )(hours == 12L ? 0 : -1)));
  case 1: 
#line 839
  return ((int )(0L < hours && hours < 12L ? hours + 12L : (long )(hours == 12L ? 12 : -1)));
  }
}
}
#line 843 "getdate.y"
static long to_year(textint textyear ) 
{ long year___0 ;

  {
#line 846
  year___0 = textyear.value;
#line 848
  if (year___0 < 0L) {
#line 849
    year___0 = - year___0;
  } else
#line 853
  if (textyear.digits == 2U) {
#line 854
    year___0 += (long )(year___0 < 69L ? 2000 : 1900);
  }
#line 856
  return (year___0);
}
}
#line 859 "getdate.y"
static table const   *lookup_zone(parser_control const   *pc , char const   *name ) 
{ table const   *tp ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 864
  tp = universal_time_zone_table;
#line 864
  while (tp->name) {
#line 865
    __cil_tmp = strcmp(name, (char const   *)tp->name);
#line 865
    if (__cil_tmp == 0) {
#line 866
      return (tp);
    }
#line 864
    tp ++;
  }
#line 870
  tp = (table const   *)(pc->local_time_zone_table);
#line 870
  while (tp->name) {
#line 871
    __cil_tmp___0 = strcmp(name, (char const   *)tp->name);
#line 871
    if (__cil_tmp___0 == 0) {
#line 872
      return (tp);
    }
#line 870
    tp ++;
  }
#line 874
  tp = time_zone_table;
#line 874
  while (tp->name) {
#line 875
    __cil_tmp___1 = strcmp(name, (char const   *)tp->name);
#line 875
    if (__cil_tmp___1 == 0) {
#line 876
      return (tp);
    }
#line 874
    tp ++;
  }
#line 878
  return ((table const   *)((void *)0));
}
}
#line 886 "getdate.y"
static long tm_diff(struct tm  const  *a , struct tm  const  *b ) 
{ int a4 ;
  int b4 ;
  int a100 ;
  int b100 ;
  int a400 ;
  int b400 ;
  int intervening_leap_days ;
  long ayear ;
  long years ;
  long days ;

  {
#line 891
  a4 = (int )(((-1 >> 1 == -1 ? a->tm_year >> 2 : a->tm_year / (int const   )(1 << 2) - (int const   )(a->tm_year % (int const   )(1 << 2) < 0)) + (int const   )(-1 >> 1 == -1 ? 1900 >> 2 : 1900 / (1 << 2) - (1900 % (1 << 2) < 0))) - (int const   )(! (a->tm_year & 3)));
#line 892
  b4 = (int )(((-1 >> 1 == -1 ? b->tm_year >> 2 : b->tm_year / (int const   )(1 << 2) - (int const   )(b->tm_year % (int const   )(1 << 2) < 0)) + (int const   )(-1 >> 1 == -1 ? 1900 >> 2 : 1900 / (1 << 2) - (1900 % (1 << 2) < 0))) - (int const   )(! (b->tm_year & 3)));
#line 893
  a100 = a4 / 25 - (a4 % 25 < 0);
#line 894
  b100 = b4 / 25 - (b4 % 25 < 0);
#line 895
  a400 = -1 >> 1 == -1 ? a100 >> 2 : a100 / (1 << 2) - (a100 % (1 << 2) < 0);
#line 896
  b400 = -1 >> 1 == -1 ? b100 >> 2 : b100 / (1 << 2) - (b100 % (1 << 2) < 0);
#line 897
  intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
#line 898
  ayear = (long )a->tm_year;
#line 899
  years = ayear - (long )b->tm_year;
#line 900
  days = (365L * years + (long )intervening_leap_days) + (long )(a->tm_yday - b->tm_yday);
#line 902
  return (60L * (60L * (24L * days + (long )(a->tm_hour - b->tm_hour)) + (long )(a->tm_min - b->tm_min)) + (long )(a->tm_sec - b->tm_sec));
}
}
#line 908 "getdate.y"
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  unsigned char __x ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  char __cil_tmp___7 ;

  {
#line 919
  p = word;
#line 919
  while (*p) {
#line 921
    ch = (unsigned char )*p;
#line 922
    __x = ch;
#line 922
    *p = (char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 2 ? ((int )__x - 97) + 65 : (int )__x);
#line 919
    p ++;
  }
#line 925
  tp = meridian_table;
#line 925
  while (tp->name) {
#line 926
    __cil_tmp = strcmp((char const   *)word, (char const   *)tp->name);
#line 926
    if (__cil_tmp == 0) {
#line 927
      return (tp);
    }
#line 925
    tp ++;
  }
#line 930
  wordlen = strlen((char const   *)word);
#line 931
  abbrev = (_Bool )(wordlen == 3U || (wordlen == 4U && (int )*(word + 3) == 46));
#line 933
  tp = month_and_day_table;
#line 933
  while (tp->name) {
#line 934
    if (abbrev) {
#line 934
      __cil_tmp___0 = strncmp((char const   *)word, (char const   *)tp->name, 3U);
#line 934
      __cil_tmp___2 = __cil_tmp___0;
    } else {
#line 934
      __cil_tmp___1 = strcmp((char const   *)word, (char const   *)tp->name);
#line 934
      __cil_tmp___2 = __cil_tmp___1;
    }
#line 934
    if (__cil_tmp___2 == 0) {
#line 935
      return (tp);
    }
#line 933
    tp ++;
  }
#line 937
  tp = lookup_zone(pc, (char const   *)word);
#line 937
  if (tp) {
#line 938
    return (tp);
  }
#line 940
  __cil_tmp___3 = strcmp((char const   *)word, (char const   *)dst_table[0].name);
#line 940
  if (__cil_tmp___3 == 0) {
#line 941
    return (dst_table);
  }
#line 943
  tp = time_units_table;
#line 943
  while (tp->name) {
#line 944
    __cil_tmp___4 = strcmp((char const   *)word, (char const   *)tp->name);
#line 944
    if (__cil_tmp___4 == 0) {
#line 945
      return (tp);
    }
#line 943
    tp ++;
  }
#line 948
  if ((int )*(word + (wordlen - 1U)) == 83) {
#line 950
    *(word + (wordlen - 1U)) = (char )'\000';
#line 951
    tp = time_units_table;
#line 951
    while (tp->name) {
#line 952
      __cil_tmp___5 = strcmp((char const   *)word, (char const   *)tp->name);
#line 952
      if (__cil_tmp___5 == 0) {
#line 953
        return (tp);
      }
#line 951
      tp ++;
    }
#line 954
    *(word + (wordlen - 1U)) = (char )'S';
  }
#line 957
  tp = relative_time_table;
#line 957
  while (tp->name) {
#line 958
    __cil_tmp___6 = strcmp((char const   *)word, (char const   *)tp->name);
#line 958
    if (__cil_tmp___6 == 0) {
#line 959
      return (tp);
    }
#line 957
    tp ++;
  }
#line 962
  if (wordlen == 1U) {
#line 963
    tp = military_table;
#line 963
    while (tp->name) {
#line 964
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 965
        return (tp);
      }
#line 963
      tp ++;
    }
  }
#line 968
  period_found = (_Bool)0;
#line 968
  q = word;
#line 968
  p = q;
#line 968
  while (1) {
#line 968
    __cil_tmp___7 = *q;
#line 968
    *p = __cil_tmp___7;
#line 968
    if (! __cil_tmp___7) {
#line 968
      break;
    }
#line 969
    if ((int )*q == 46) {
#line 970
      period_found = (_Bool)1;
    } else {
#line 972
      p ++;
    }
#line 968
    q ++;
  }
#line 973
  if (period_found) {
#line 973
    tp = lookup_zone(pc, (char const   *)word);
#line 973
    if (tp) {
#line 974
      return (tp);
    }
  }
#line 976
  return ((table const   *)((void *)0));
}
}
#line 979 "getdate.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ unsigned char c ;
  size_t count ;
  char const   *p ;
  int sign ;
  unsigned long value ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *__cil_tmp___1 ;
  char const   *__cil_tmp___2 ;
  char const   *__cil_tmp___3 ;

  {
#line 985
  while (1) {
#line 987
    while (1) {
#line 987
      c = (unsigned char )*(pc->input);
#line 987
      if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 8)) {
#line 987
        break;
      }
#line 988
      (pc->input) ++;
    }
#line 990
    if (((unsigned int )c - 48U <= 9U || (int )c == 45) || (int )c == 43) {
#line 995
      if ((int )c == 45 || (int )c == 43) {
#line 997
        sign = (int )c == 45 ? -1 : 1;
#line 998
        while (1) {
#line 998
          (pc->input) ++;
#line 998
          c = (unsigned char )*(pc->input);
#line 998
          if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 8)) {
#line 998
            break;
          }
#line 999
          continue;
        }
#line 1000
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1002
          goto __Cont;
        }
      } else {
#line 1005
        sign = 0;
      }
#line 1006
      p = pc->input;
#line 1007
      value = 0UL;
#line 1007
      while (1) {
#line 1009
        value1 = value + (unsigned long )((int )c - 48);
#line 1010
        if (value1 < value) {
#line 1011
          return ('?');
        }
#line 1012
        value = value1;
#line 1013
        p ++;
#line 1013
        c = (unsigned char )*p;
#line 1014
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1015
          break;
        }
#line 1016
        if (429496729UL < value) {
#line 1017
          return ('?');
        }
#line 1007
        value *= 10UL;
      }
#line 1019
      if (((int )c == 46 || (int )c == 44) && (unsigned int )*(p + 1) - 48U <= 9U) {
#line 1027
        if (sign < 0) {
#line 1029
          s = (long )(- value);
#line 1030
          if (0L < s) {
#line 1031
            return ('?');
          }
#line 1032
          value1___0 = (unsigned long )(- s);
        } else {
#line 1036
          s = (long )value;
#line 1037
          if (s < 0L) {
#line 1038
            return ('?');
          }
#line 1039
          value1___0 = (unsigned long )s;
        }
#line 1041
        if (value != value1___0) {
#line 1042
          return ('?');
        }
#line 1045
        p ++;
#line 1046
        __cil_tmp = p;
#line 1046
        p ++;
#line 1046
        ns = (int )((int const   )*__cil_tmp - 48);
#line 1047
        digits = 2;
#line 1047
        while (digits <= 9) {
#line 1049
          ns *= 10;
#line 1050
          if ((unsigned int )*p - 48U <= 9U) {
#line 1051
            __cil_tmp___0 = p;
#line 1051
            p ++;
#line 1051
            ns += (int )((int const   )*__cil_tmp___0 - 48);
          }
#line 1047
          digits ++;
        }
#line 1055
        if (sign < 0) {
#line 1056
          while ((unsigned int )*p - 48U <= 9U) {
#line 1057
            if ((int const   )*p != 48) {
#line 1059
              ns ++;
#line 1060
              break;
            }
#line 1056
            p ++;
          }
        }
#line 1062
        while ((unsigned int )*p - 48U <= 9U) {
#line 1063
          p ++;
        }
#line 1068
        if (sign < 0 && ns) {
#line 1070
          s --;
#line 1071
          if (! (s < 0L)) {
#line 1072
            return ('?');
          }
#line 1073
          ns = 1000000000 - ns;
        }
#line 1076
        lvalp->timespec.tv_sec = s;
#line 1077
        lvalp->timespec.tv_nsec = (long )ns;
#line 1078
        pc->input = p;
#line 1079
        return (sign ? 275 : 276);
      } else {
#line 1083
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1084
        if (sign < 0) {
#line 1086
          lvalp->textintval.value = (long )(- value);
#line 1087
          if (0L < lvalp->textintval.value) {
#line 1088
            return ('?');
          }
        } else {
#line 1092
          lvalp->textintval.value = (long )value;
#line 1093
          if (lvalp->textintval.value < 0L) {
#line 1094
            return ('?');
          }
        }
#line 1096
        lvalp->textintval.digits = (unsigned int )(p - pc->input);
#line 1097
        pc->input = p;
#line 1098
        return (sign ? 273 : 274);
      }
    }
#line 1102
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 3) {
#line 1105
      p___0 = buff;
#line 1108
      while (1) {
#line 1110
        if ((unsigned int )p___0 < (unsigned int )((buff + sizeof(buff)) - 1)) {
#line 1111
          __cil_tmp___1 = p___0;
#line 1111
          p___0 ++;
#line 1111
          *__cil_tmp___1 = (char )c;
        }
#line 1112
        (pc->input) ++;
#line 1112
        c = (unsigned char )*(pc->input);
#line 1108
        if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 3 || (int )c == 46)) {
#line 1108
          break;
        }
      }
#line 1116
      *p___0 = (char )'\000';
#line 1117
      tp = lookup_word((parser_control const   *)pc, buff);
#line 1118
      if (! tp) {
#line 1119
        return ('?');
      }
#line 1120
      lvalp->intval = (long )tp->value;
#line 1121
      return ((int )tp->type);
    }
#line 1124
    if ((int )c != 40) {
#line 1125
      __cil_tmp___2 = pc->input;
#line 1125
      (pc->input) ++;
#line 1125
      return ((int )*__cil_tmp___2);
    }
#line 1126
    count = 0U;
#line 1127
    while (1) {
#line 1129
      __cil_tmp___3 = pc->input;
#line 1129
      (pc->input) ++;
#line 1129
      c = (unsigned char )*__cil_tmp___3;
#line 1130
      if ((int )c == 0) {
#line 1131
        return ((int )c);
      }
#line 1132
      if ((int )c == 40) {
#line 1133
        count ++;
      } else
#line 1134
      if ((int )c == 41) {
#line 1135
        count --;
      }
#line 1127
      if (! (count != 0U)) {
#line 1127
        break;
      }
    }
    __Cont: ;
  }
}
}
#line 1142 "getdate.y"
static int yyerror(parser_control const   *pc , char const   *s ) 
{ 

  {
#line 1146
  return (0);
}
}
#line 1153 "getdate.y"
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ struct tm *__cil_tmp ;

  {
#line 1156
  if (t == -1L) {
#line 1161
    __cil_tmp = rpl_localtime((time_t const   *)(& t));
#line 1161
    tm1 = (struct tm  const  *)__cil_tmp;
#line 1162
    if (! tm1) {
#line 1163
      return ((_Bool)0);
    }
  }
#line 1166
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1180 "getdate.y"
static char *get_tz(char *tzbuf ) 
{ char *tz ;
  char *__cil_tmp ;
  size_t tzsize ;
  size_t __cil_tmp___0 ;
  void *__cil_tmp___1 ;
  void *__cil_tmp___2 ;

  {
#line 1183
  __cil_tmp = getenv("TZ");
#line 1183
  tz = __cil_tmp;
#line 1184
  if (tz) {
#line 1186
    __cil_tmp___0 = strlen((char const   *)tz);
#line 1186
    tzsize = __cil_tmp___0 + 1U;
#line 1187
    if (tzsize <= 100U) {
#line 1187
      __cil_tmp___1 = memcpy((void *)tzbuf, (void const   *)tz, tzsize);
#line 1187
      tz = (char *)__cil_tmp___1;
    } else {
#line 1187
      __cil_tmp___2 = xmemdup((void const   *)tz, tzsize);
#line 1187
      tz = (char *)__cil_tmp___2;
    }
  }
#line 1191
  return (tz);
}
}
#line 1198 "getdate.y"
_Bool get_date(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ time_t Start ;
  long Start_ns ;
  struct tm  const  *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *__cil_tmp ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int i ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  long __cil_tmp___6 ;
  long time_zone ;
  long abs_time_zone ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8U) / 3U] ;
  int __cil_tmp___7 ;
  _Bool __cil_tmp___8 ;
  _Bool __cil_tmp___9 ;
  long delta ;
  time_t t1 ;
  time_t t ;
  struct tm  const  *gmt ;
  struct tm *__cil_tmp___10 ;
  long __cil_tmp___11 ;
  int year___0 ;
  int month ;
  int day ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long d3 ;
  time_t t3 ;
  long d4 ;
  time_t t4 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;

  {
#line 1209
  tz_was_altered = (_Bool)0;
#line 1210
  tz0 = (char *)((void *)0);
#line 1212
  ok = (_Bool)1;
#line 1214
  if (! now) {
#line 1216
    gettime(& gettime_buffer);
#line 1217
    now = (struct timespec  const  *)(& gettime_buffer);
  }
#line 1220
  Start = (long )now->tv_sec;
#line 1221
  Start_ns = (long )now->tv_nsec;
#line 1223
  __cil_tmp = rpl_localtime(& now->tv_sec);
#line 1223
  tmp = (struct tm  const  *)__cil_tmp;
#line 1224
  if (! tmp) {
#line 1225
    return ((_Bool)0);
  }
#line 1227
  while (1) {
#line 1227
    c = (unsigned char )*p;
#line 1227
    if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 8)) {
#line 1227
      break;
    }
#line 1228
    p ++;
  }
#line 1230
  __cil_tmp___3 = strncmp(p, "TZ=\"", 4U);
#line 1230
  if (__cil_tmp___3 == 0) {
#line 1232
    tzbase = p + 4;
#line 1233
    tzsize = 1U;
#line 1236
    s = tzbase;
#line 1236
    while (*s) {
#line 1237
      if ((int const   )*s == 92) {
#line 1239
        s ++;
#line 1240
        if (! ((int const   )*s == 92 || (int const   )*s == 34)) {
#line 1241
          break;
        }
      } else
#line 1243
      if ((int const   )*s == 34) {
#line 1248
        large_tz = (_Bool )(100U < tzsize);
#line 1250
        tz0 = get_tz(tz0buf);
#line 1251
        if (large_tz) {
#line 1251
          __cil_tmp___0 = xmalloc(tzsize);
#line 1251
          tz1 = (char *)__cil_tmp___0;
        } else {
#line 1251
          tz1 = tz1buf;
        }
#line 1251
        z = tz1;
#line 1252
        s = tzbase;
#line 1252
        while ((int const   )*s != 34) {
#line 1253
          __cil_tmp___1 = z;
#line 1253
          z ++;
#line 1253
          s += (int const   )*s == 92;
#line 1253
          *__cil_tmp___1 = (char )*s;
#line 1252
          s ++;
        }
#line 1254
        *z = (char )'\000';
#line 1255
        __cil_tmp___2 = setenv("TZ", (char const   *)tz1, 1);
#line 1255
        setenv_ok = (_Bool )(__cil_tmp___2 == 0);
#line 1256
        if (large_tz) {
#line 1257
          free((void *)tz1);
        }
#line 1258
        if (! setenv_ok) {
#line 1259
          goto fail;
        }
#line 1260
        tz_was_altered = (_Bool)1;
#line 1261
        p = s + 1;
      }
#line 1236
      s ++;
#line 1236
      tzsize ++;
    }
  }
#line 1268
  if ((int const   )*p == 0) {
#line 1269
    p = "0";
  }
#line 1271
  pc.input = p;
#line 1272
  pc.year.value = (long )tmp->tm_year;
#line 1273
  pc.year.value += 1900L;
#line 1274
  pc.year.digits = 0U;
#line 1275
  pc.month = (long )(tmp->tm_mon + 1);
#line 1276
  pc.day = (long )tmp->tm_mday;
#line 1277
  pc.hour = (long )tmp->tm_hour;
#line 1278
  pc.minutes = (long )tmp->tm_min;
#line 1279
  pc.seconds.tv_sec = (long )tmp->tm_sec;
#line 1280
  pc.seconds.tv_nsec = Start_ns;
#line 1281
  tm.tm_isdst = (int )tmp->tm_isdst;
#line 1283
  pc.meridian = 2;
#line 1284
  pc.rel = (struct __anonstruct_relative_time_20 )RELATIVE_TIME_0;
#line 1285
  pc.timespec_seen = (_Bool)0;
#line 1286
  pc.rels_seen = (_Bool)0;
#line 1287
  pc.dates_seen = 0U;
#line 1288
  pc.days_seen = 0U;
#line 1289
  pc.times_seen = 0U;
#line 1290
  pc.local_zones_seen = 0U;
#line 1291
  pc.dsts_seen = 0U;
#line 1292
  pc.zones_seen = 0U;
#line 1328
  i = 0;
#line 1328
  while (i < 2) {
#line 1330
    pc.local_time_zone_table[i].name = (char const   *)_tzname[i];
#line 1331
    pc.local_time_zone_table[i].type = 268;
#line 1332
    pc.local_time_zone_table[i].value = i;
#line 1328
    i ++;
  }
#line 1334
  pc.local_time_zone_table[i].name = (char const   *)((void *)0);
#line 1341
  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name) {
#line 1341
    __cil_tmp___4 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
#line 1341
    if (! __cil_tmp___4) {
#line 1348
      pc.local_time_zone_table[0].value = -1;
#line 1349
      pc.local_time_zone_table[1].name = (char const   *)((void *)0);
    }
  }
#line 1352
  __cil_tmp___5 = yyparse(& pc);
#line 1352
  if (__cil_tmp___5 != 0) {
#line 1353
    goto fail;
  }
#line 1355
  if (pc.timespec_seen) {
#line 1356
    *result = pc.seconds;
  } else {
#line 1359
    if (1U < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1361
      goto fail;
    }
#line 1363
    __cil_tmp___6 = to_year(pc.year);
#line 1363
    tm.tm_year = (int )(__cil_tmp___6 - 1900L);
#line 1364
    tm.tm_mon = (int )(pc.month - 1L);
#line 1365
    tm.tm_mday = (int )pc.day;
#line 1366
    if (pc.times_seen || ((pc.rels_seen && ! pc.dates_seen) && ! pc.days_seen)) {
#line 1368
      tm.tm_hour = to_hour(pc.hour, pc.meridian);
#line 1369
      if (tm.tm_hour < 0) {
#line 1370
        goto fail;
      }
#line 1371
      tm.tm_min = (int )pc.minutes;
#line 1372
      tm.tm_sec = (int )pc.seconds.tv_sec;
    } else {
#line 1376
      tm.tm_sec = 0;
#line 1376
      tm.tm_min = tm.tm_sec;
#line 1376
      tm.tm_hour = tm.tm_min;
#line 1377
      pc.seconds.tv_nsec = 0L;
    }
#line 1381
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 1382
      tm.tm_isdst = -1;
    }
#line 1386
    if (pc.local_zones_seen) {
#line 1387
      tm.tm_isdst = pc.local_isdst;
    }
#line 1389
    tm0 = tm;
#line 1391
    Start = rpl_mktime(& tm);
#line 1393
    __cil_tmp___9 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                              Start);
#line 1393
    if (! __cil_tmp___9) {
#line 1395
      if (! pc.zones_seen) {
#line 1396
        goto fail;
      } else {
#line 1409
        time_zone = pc.time_zone;
#line 1410
        abs_time_zone = time_zone < 0L ? - time_zone : time_zone;
#line 1411
        abs_time_zone_hour = abs_time_zone / 60L;
#line 1412
        abs_time_zone_min = (int )(abs_time_zone % 60L);
#line 1415
        if (! tz_was_altered) {
#line 1416
          tz0 = get_tz(tz0buf);
        }
#line 1417
        sprintf(tz1buf___0, "XXX%s%ld:%02d", "-" + (time_zone < 0L), abs_time_zone_hour,
                abs_time_zone_min);
#line 1419
        __cil_tmp___7 = setenv("TZ", (char const   *)(tz1buf___0), 1);
#line 1419
        if (__cil_tmp___7 != 0) {
#line 1420
          goto fail;
        }
#line 1421
        tz_was_altered = (_Bool)1;
#line 1422
        tm = tm0;
#line 1423
        Start = rpl_mktime(& tm);
#line 1424
        __cil_tmp___8 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                                  Start);
#line 1424
        if (! __cil_tmp___8) {
#line 1425
          goto fail;
        }
      }
    }
#line 1429
    if (pc.days_seen && ! pc.dates_seen) {
#line 1431
      tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )(0L < pc.day_ordinal))));
#line 1433
      tm.tm_isdst = -1;
#line 1434
      Start = rpl_mktime(& tm);
#line 1435
      if (Start == -1L) {
#line 1436
        goto fail;
      }
    }
#line 1439
    if (pc.zones_seen) {
#line 1441
      delta = pc.time_zone * 60L;
#line 1446
      t = Start;
#line 1447
      __cil_tmp___10 = rpl_gmtime((time_t const   *)(& t));
#line 1447
      gmt = (struct tm  const  *)__cil_tmp___10;
#line 1448
      if (! gmt) {
#line 1449
        goto fail;
      }
#line 1450
      __cil_tmp___11 = tm_diff((struct tm  const  *)(& tm), gmt);
#line 1450
      delta -= __cil_tmp___11;
#line 1452
      t1 = Start - delta;
#line 1453
      if ((Start < t1) != (delta < 0L)) {
#line 1454
        goto fail;
      }
#line 1455
      Start = t1;
    }
#line 1459
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 1461
      year___0 = (int )((long )tm.tm_year + pc.rel.year);
#line 1462
      month = (int )((long )tm.tm_mon + pc.rel.month);
#line 1463
      day = (int )((long )tm.tm_mday + pc.rel.day);
#line 1464
      if ((((year___0 < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
#line 1467
        goto fail;
      }
#line 1468
      tm.tm_year = year___0;
#line 1469
      tm.tm_mon = month;
#line 1470
      tm.tm_mday = day;
#line 1471
      tm.tm_hour = tm0.tm_hour;
#line 1472
      tm.tm_min = tm0.tm_min;
#line 1473
      tm.tm_sec = tm0.tm_sec;
#line 1474
      tm.tm_isdst = tm0.tm_isdst;
#line 1475
      Start = rpl_mktime(& tm);
#line 1476
      if (Start == -1L) {
#line 1477
        goto fail;
      }
    }
#line 1488
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
#line 1489
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
#line 1490
    t0 = Start;
#line 1491
    d1 = 3600L * pc.rel.hour;
#line 1492
    t1___0 = t0 + d1;
#line 1493
    d2 = 60L * pc.rel.minutes;
#line 1494
    t2 = t1___0 + d2;
#line 1495
    d3 = pc.rel.seconds;
#line 1496
    t3 = t2 + d3;
#line 1497
    d4 = (sum_ns - normalized_ns) / 1000000000L;
#line 1498
    t4 = t3 + d4;
#line 1500
    if ((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) {
#line 1506
      goto fail;
    }
#line 1508
    result->tv_sec = t4;
#line 1509
    result->tv_nsec = normalized_ns;
  }
#line 1513
  goto done;
  fail: 
#line 1516
  ok = (_Bool)0;
  done: 
#line 1518
  if (tz_was_altered) {
#line 1519
    if (tz0) {
#line 1519
      __cil_tmp___12 = setenv("TZ", (char const   *)tz0, 1);
#line 1519
      __cil_tmp___14 = __cil_tmp___12;
    } else {
#line 1519
      __cil_tmp___13 = unsetenv("TZ");
#line 1519
      __cil_tmp___14 = __cil_tmp___13;
    }
#line 1519
    ok = (_Bool )((int )ok & (__cil_tmp___14 == 0));
  }
#line 1520
  if ((unsigned int )tz0 != (unsigned int )(tz0buf)) {
#line 1521
    free((void *)tz0);
  }
#line 1522
  return (ok);
}
}
#line 1 "hash-pjw.o"
#pragma merger(0,"/tmp/cil-YK0QEBje.i","-g,-O2")
#line 23 "hash-pjw.h"
size_t hash_pjw(void const   *x , size_t tablesize ) ;
#line 30 "hash-pjw.c"
size_t hash_pjw(void const   *x , size_t tablesize ) 
{ char const   *s ;
  size_t h ;

  {
#line 34
  h = 0U;
#line 36
  s = (char const   *)x;
#line 36
  while (*s) {
#line 37
    h = (unsigned int )*s + ((h << 9) | (h >> (sizeof(size_t ) * 8U - 9U)));
#line 36
    s ++;
  }
#line 39
  return (h % tablesize);
}
}
#line 1 "hash-triple.o"
#pragma merger(0,"/tmp/cil-wm6PG0BB.i","-g,-O2")
#line 16 "hash-triple.h"
size_t triple_hash(void const   *x , size_t table_size ) ;
#line 17
size_t triple_hash_no_name(void const   *x , size_t table_size ) ;
#line 18
_Bool triple_compare(void const   *x , void const   *y ) ;
#line 19
_Bool triple_compare_ino_str(void const   *x , void const   *y ) ;
#line 24 "same.h"
_Bool same_name(char const   *source , char const   *dest ) ;
#line 33 "hash-triple.c"
size_t triple_hash(void const   *x , size_t table_size ) 
{ struct F_triple  const  *p ;
  size_t tmp ;
  size_t __cil_tmp ;

  {
#line 36
  p = (struct F_triple  const  *)x;
#line 37
  __cil_tmp = hash_pjw((void const   *)p->name, table_size);
#line 37
  tmp = __cil_tmp;
#line 40
  return ((tmp ^ (unsigned int )p->st_ino) % table_size);
}
}
#line 44 "hash-triple.c"
size_t triple_hash_no_name(void const   *x , size_t table_size ) 
{ struct F_triple  const  *p ;

  {
#line 47
  p = (struct F_triple  const  *)x;
#line 50
  return ((unsigned int )p->st_ino % table_size);
}
}
#line 54 "hash-triple.c"
_Bool triple_compare(void const   *x , void const   *y ) 
{ struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int __cil_tmp___0 ;
  _Bool __cil_tmp___1 ;

  {
#line 57
  a = (struct F_triple  const  *)x;
#line 58
  b = (struct F_triple  const  *)y;
#line 59
  if ((int const   )a->st_ino == (int const   )b->st_ino && (int const   )a->st_dev == (int const   )b->st_dev) {
#line 59
    __cil_tmp___1 = same_name((char const   *)a->name, (char const   *)b->name);
#line 59
    if (__cil_tmp___1) {
#line 59
      __cil_tmp___0 = 1;
    } else {
#line 59
      __cil_tmp___0 = 0;
    }
  } else {
#line 59
    __cil_tmp___0 = 0;
  }
#line 59
  return ((_Bool )__cil_tmp___0);
}
}
#line 62 "hash-triple.c"
_Bool triple_compare_ino_str(void const   *x , void const   *y ) 
{ struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 65
  a = (struct F_triple  const  *)x;
#line 66
  b = (struct F_triple  const  *)y;
#line 67
  if ((int const   )a->st_ino == (int const   )b->st_ino && (int const   )a->st_dev == (int const   )b->st_dev) {
#line 67
    __cil_tmp___1 = strcmp((char const   *)a->name, (char const   *)b->name);
#line 67
    if (__cil_tmp___1 == 0) {
#line 67
      __cil_tmp___0 = 1;
    } else {
#line 67
      __cil_tmp___0 = 0;
    }
  } else {
#line 67
    __cil_tmp___0 = 0;
  }
#line 67
  return ((_Bool )__cil_tmp___0);
}
}
#line 71 "hash-triple.c"
void triple_free(void *x ) 
{ struct F_triple *a ;

  {
#line 74
  a = (struct F_triple *)x;
#line 75
  free((void *)a->name);
#line 76
  free((void *)a);
#line 77
  return;
}
}
#line 1 "linebuffer.o"
#pragma merger(0,"/tmp/cil-hrDNxxsn.i","-g,-O2")
#line 221 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int feof(FILE * ) ;
#line 222
extern int ferror(FILE * ) ;
#line 322
extern int getc_unlocked(FILE * ) ;
#line 26 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern void *memset(void * , int  , size_t  ) ;
#line 34 "linebuffer.h"
void initbuffer(struct linebuffer *linebuffer ) ;
#line 41
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) ;
#line 48
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) ;
#line 51
void freebuffer(struct linebuffer *linebuffer ) ;
#line 51 "xalloc.h"
void *x2realloc(void *p , size_t *pn ) ;
#line 36 "linebuffer.c"
void initbuffer(struct linebuffer *linebuffer ) 
{ 

  {
#line 39
  memset((void *)linebuffer, 0, sizeof(*linebuffer));
#line 40
  return;
}
}
#line 42 "linebuffer.c"
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) 
{ struct linebuffer *__cil_tmp ;

  {
#line 45
  __cil_tmp = readlinebuffer_delim(linebuffer, stream, (char )'\n');
#line 45
  return (__cil_tmp);
}
}
#line 58 "linebuffer.c"
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) 
{ int c ;
  char *buffer ;
  char *p ;
  char *end ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  size_t oldsize ;
  void *__cil_tmp___1 ;
  char *__cil_tmp___2 ;

  {
#line 63
  buffer = linebuffer->buffer;
#line 64
  p = linebuffer->buffer;
#line 65
  end = buffer + linebuffer->size;
#line 67
  __cil_tmp = feof(stream);
#line 67
  if (__cil_tmp) {
#line 68
    return ((struct linebuffer *)((void *)0));
  }
#line 70
  while (1) {
#line 72
    c = getc_unlocked(stream);
#line 73
    if (c == -1) {
#line 75
      if ((unsigned int )p == (unsigned int )buffer) {
#line 76
        return ((struct linebuffer *)((void *)0));
      } else {
#line 75
        __cil_tmp___0 = ferror(stream);
#line 75
        if (__cil_tmp___0) {
#line 76
          return ((struct linebuffer *)((void *)0));
        }
      }
#line 77
      if ((int )*(p + -1) == (int )delimiter) {
#line 78
        break;
      }
#line 79
      c = (int )delimiter;
    }
#line 81
    if ((unsigned int )p == (unsigned int )end) {
#line 83
      oldsize = linebuffer->size;
#line 84
      __cil_tmp___1 = x2realloc((void *)buffer, & linebuffer->size);
#line 84
      buffer = (char *)__cil_tmp___1;
#line 85
      p = buffer + oldsize;
#line 86
      linebuffer->buffer = buffer;
#line 87
      end = buffer + linebuffer->size;
    }
#line 89
    __cil_tmp___2 = p;
#line 89
    p ++;
#line 89
    *__cil_tmp___2 = (char )c;
#line 70
    if (! (c != (int )delimiter)) {
#line 70
      break;
    }
  }
#line 93
  linebuffer->length = (unsigned int )(p - buffer);
#line 94
  return (linebuffer);
}
}
#line 99 "linebuffer.c"
void freebuffer(struct linebuffer *linebuffer ) 
{ 

  {
#line 102
  free((void *)linebuffer->buffer);
#line 103
  return;
}
}
#line 1 "localcharset.o"
#pragma merger(0,"/tmp/cil-kxTcIoDH.i","-g,-O2")
#line 35 "localcharset.h"
char const   *locale_charset(void) ;
#line 173 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int fclose(FILE * ) ;
#line 180
extern int fscanf(FILE * , char const   *  , ...) ;
#line 204
extern int ungetc(int  , FILE * ) ;
#line 225
extern FILE *fopen(char const   *_name , char const   *_type ) ;
#line 31 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strcpy(char * , char const   * ) ;
#line 121 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
void *rpl_realloc(void *p , size_t n ) ;
#line 313 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/langinfo.h"
extern char *nl_langinfo(nl_item  ) ;
#line 104 "localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 107 "localcharset.c"
static char const   *get_charset_aliases(void) 
{ char const   *cp ;
  FILE *fp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *__cil_tmp ;
  size_t dir_len___0 ;
  size_t __cil_tmp___0 ;
  size_t base_len___0 ;
  size_t __cil_tmp___1 ;
  int add_slash ;
  void *__cil_tmp___2 ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int __cil_tmp___3 ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;

  {
#line 112
  cp = (char const   *)charset_aliases;
#line 113
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 118
    base = "charset.alias";
#line 123
    __cil_tmp = getenv("CHARSETALIASDIR");
#line 123
    dir = (char const   *)__cil_tmp;
#line 124
    if ((unsigned int )dir == (unsigned int )((void *)0) || (int const   )*(dir + 0) == 0) {
#line 125
      dir = "/usr/local/lib";
    }
#line 129
    __cil_tmp___0 = strlen(dir);
#line 129
    dir_len___0 = __cil_tmp___0;
#line 130
    __cil_tmp___1 = strlen(base);
#line 130
    base_len___0 = __cil_tmp___1;
#line 131
    add_slash = dir_len___0 > 0U && ! ((int const   )*(dir + (dir_len___0 - 1U)) == 47);
#line 132
    __cil_tmp___2 = rpl_malloc(((dir_len___0 + (unsigned int )add_slash) + base_len___0) + 1U);
#line 132
    file_name___1 = (char *)__cil_tmp___2;
#line 133
    if ((unsigned int )file_name___1 != (unsigned int )((void *)0)) {
#line 135
      memcpy((void *)file_name___1, (void const   *)dir, dir_len___0);
#line 136
      if (add_slash) {
#line 137
        *(file_name___1 + dir_len___0) = (char )'/';
      }
#line 138
      memcpy((void *)((file_name___1 + dir_len___0) + add_slash), (void const   *)base,
             base_len___0 + 1U);
    }
#line 142
    if ((unsigned int )file_name___1 == (unsigned int )((void *)0)) {
#line 144
      cp = "";
    } else {
#line 142
      fp = fopen((char const   *)file_name___1, "r");
#line 142
      if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 144
        cp = "";
      } else {
#line 148
        res_ptr = (char *)((void *)0);
#line 149
        res_size = 0U;
#line 151
        while (1) {
#line 159
          c = getc_unlocked(fp);
#line 160
          if (c == -1) {
#line 161
            break;
          }
#line 162
          if ((c == 10 || c == 32) || c == 9) {
#line 163
            goto __Cont;
          }
#line 164
          if (c == 35) {
#line 167
            while (1) {
#line 168
              c = getc_unlocked(fp);
#line 167
              if (! (! (c == -1 || c == 10))) {
#line 167
                break;
              }
            }
#line 170
            if (c == -1) {
#line 171
              break;
            }
#line 172
            goto __Cont;
          }
#line 174
          ungetc(c, fp);
#line 175
          __cil_tmp___3 = fscanf(fp, "%50s %50s", buf1, buf2);
#line 175
          if (__cil_tmp___3 < 2) {
#line 176
            break;
          }
#line 177
          l1 = strlen((char const   *)(buf1));
#line 178
          l2 = strlen((char const   *)(buf2));
#line 179
          old_res_ptr = res_ptr;
#line 180
          if (res_size == 0U) {
#line 182
            res_size = ((l1 + 1U) + l2) + 1U;
#line 183
            __cil_tmp___4 = rpl_malloc(res_size + 1U);
#line 183
            res_ptr = (char *)__cil_tmp___4;
          } else {
#line 187
            res_size += ((l1 + 1U) + l2) + 1U;
#line 188
            __cil_tmp___5 = rpl_realloc((void *)res_ptr, res_size + 1U);
#line 188
            res_ptr = (char *)__cil_tmp___5;
          }
#line 190
          if ((unsigned int )res_ptr == (unsigned int )((void *)0)) {
#line 193
            res_size = 0U;
#line 194
            if ((unsigned int )old_res_ptr != (unsigned int )((void *)0)) {
#line 195
              free((void *)old_res_ptr);
            }
#line 196
            break;
          }
#line 198
          strcpy(((res_ptr + res_size) - (l2 + 1U)) - (l1 + 1U), (char const   *)(buf1));
#line 199
          strcpy((res_ptr + res_size) - (l2 + 1U), (char const   *)(buf2));
          __Cont: ;
        }
#line 201
        fclose(fp);
#line 202
        if (res_size == 0U) {
#line 203
          cp = "";
        } else {
#line 206
          *(res_ptr + res_size) = (char )'\000';
#line 207
          cp = (char const   *)res_ptr;
        }
      }
    }
#line 211
    if ((unsigned int )file_name___1 != (unsigned int )((void *)0)) {
#line 212
      free((void *)file_name___1);
    }
#line 272
    charset_aliases = (char const   * volatile  )cp;
  }
#line 275
  return (cp);
}
}
#line 287 "localcharset.c"
char const   *locale_charset(void) 
{ char const   *codeset ;
  char const   *aliases ;
  char *__cil_tmp ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 298
  __cil_tmp = nl_langinfo(0);
#line 298
  codeset = (char const   *)__cil_tmp;
#line 440
  if ((unsigned int )codeset == (unsigned int )((void *)0)) {
#line 442
    codeset = "";
  }
#line 445
  aliases = get_charset_aliases();
#line 445
  while ((int const   )*aliases != 0) {
#line 448
    __cil_tmp___3 = strcmp(codeset, aliases);
#line 448
    if (__cil_tmp___3 == 0 || ((int const   )*(aliases + 0) == 42 && (int const   )*(aliases + 1) == 0)) {
#line 451
      __cil_tmp___2 = strlen(aliases);
#line 451
      codeset = (aliases + __cil_tmp___2) + 1;
#line 452
      break;
    }
#line 445
    __cil_tmp___0 = strlen(aliases);
#line 445
    aliases += __cil_tmp___0 + 1U;
#line 445
    __cil_tmp___1 = strlen(aliases);
#line 445
    aliases += __cil_tmp___1 + 1U;
  }
#line 458
  if ((int const   )*(codeset + 0) == 0) {
#line 459
    codeset = "ASCII";
  }
#line 461
  return (codeset);
}
}
#line 1 "malloca.o"
#pragma merger(0,"/tmp/cil-olHgXg9w.i","-g,-O2")
#line 66 "malloca.h"
void *mmalloca(size_t n ) ;
#line 70
void freea(void *p ) ;
#line 62 "malloca.c"
static void *mmalloca_results[257]  ;
#line 66 "malloca.c"
void *mmalloca(size_t n ) 
{ size_t nplus ;
  char *p ;
  void *__cil_tmp ;
  size_t slot ;

  {
#line 72
  nplus = n + (((sizeof(struct preliminary_header ) + 4U) - 1U) / 4U) * 4U;
#line 74
  if (nplus >= n) {
#line 76
    __cil_tmp = rpl_malloc(nplus);
#line 76
    p = (char *)__cil_tmp;
#line 78
    if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 82
      p += (((sizeof(struct preliminary_header ) + 4U) - 1U) / 4U) * 4U;
#line 85
      *((int *)p + -1) = 336984906;
#line 88
      slot = (unsigned int )((unsigned long )p % 257UL);
#line 89
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 4U) - 1U) / 4U) * 4U))->next = mmalloca_results[slot];
#line 90
      mmalloca_results[slot] = (void *)p;
#line 92
      return ((void *)p);
    }
  }
#line 96
  return ((void *)0);
}
}
#line 107 "malloca.c"
void freea(void *p ) 
{ size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 111
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 117
    if (*((int *)p + -1) == 336984906) {
#line 121
      slot = (unsigned int )((unsigned long )p % 257UL);
#line 122
      chain = & mmalloca_results[slot];
#line 123
      while ((unsigned int )*chain != (unsigned int )((void *)0)) {
#line 125
        if ((unsigned int )*chain == (unsigned int )p) {
#line 128
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 4U) - 1U) / 4U) * 4U;
#line 129
          *chain = ((struct header *)p_begin)->next;
#line 130
          free((void *)p_begin);
#line 131
          return;
        }
#line 133
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 4U) - 1U) / 4U) * 4U))->next;
      }
    }
  }
#line 138
  return;
}
}
#line 1 "mbchar.o"
#pragma merger(0,"/tmp/cil-Q56vcXya.i","-g,-O2")
#line 305 "mbchar.h"
unsigned int const   is_basic_table[8] ;
#line 26 "mbchar.c"
unsigned int const   is_basic_table[8]  = 
#line 26 "mbchar.c"
  {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646, 
        (unsigned int const   )0U,      (unsigned int const   )0U,      (unsigned int const   )0U,      (unsigned int const   )0U};
#line 1 "mbscasecmp.o"
#pragma merger(0,"/tmp/cil-SSJtlykl.i","-g,-O2")
#line 23 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
int rpl_memcmp(void const   *s1 , void const   *s2 , size_t len ) ;
#line 461 "./string.h"
int mbscasecmp(char const   *s1 , char const   *s2 ) ;
#line 11 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/assert.h"
extern void __libc_failwith(char *msg ) ;
#line 58 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern int __locale_mb_cur_max(void) ;
#line 53 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wchar.h"
extern size_t mbrtowc(wchar_t * , char const   * , size_t  , mbstate_t * ) ;
#line 56
extern int mbsinit(mbstate_t const   * ) ;
#line 41 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wctype.h"
extern wint_t towlower(wint_t  ) ;
#line 307 "mbchar.h"
__inline static _Bool is_basic(char c ) 
{ 

  {
#line 310
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 31 "strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen ) ;
#line 123 "mbuiter.h"
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  _Bool __cil_tmp___3 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
#line 131
  __cil_tmp___3 = is_basic((char )*(iter->cur.ptr));
#line 131
  if (__cil_tmp___3) {
#line 136
    iter->cur.bytes = 1U;
#line 137
    iter->cur.wc = (short )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
#line 142
    __cil_tmp = mbsinit((mbstate_t const   *)(& iter->state));
#line 142
    if (__cil_tmp == 0) {
#line 142
      __libc_failwith((char *)"Assertion failed: mbsinit (&iter->state) at mbuiter.h:142");
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
#line 145
    __cil_tmp___0 = __locale_mb_cur_max();
#line 145
    __cil_tmp___1 = strnlen1(iter->cur.ptr, (unsigned int )__cil_tmp___0);
#line 145
    iter->cur.bytes = mbrtowc(& iter->cur.wc, iter->cur.ptr, __cil_tmp___1, & iter->state);
#line 148
    if (iter->cur.bytes == 4294967295U) {
#line 151
      iter->cur.bytes = 1U;
#line 152
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 156
    if (iter->cur.bytes == 4294967294U) {
#line 159
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 160
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 166
      if (iter->cur.bytes == 0U) {
#line 169
        iter->cur.bytes = 1U;
#line 170
        if (((int const   )*(iter->cur.ptr) == 0) == 0) {
#line 170
          __libc_failwith((char *)"Assertion failed: *iter->cur.ptr == \'\\0\' at mbuiter.h:170");
        }
#line 171
        if (((int )iter->cur.wc == 0) == 0) {
#line 171
          __libc_failwith((char *)"Assertion failed: iter->cur.wc == 0 at mbuiter.h:171");
        }
      }
#line 173
      iter->cur.wc_valid = (_Bool)1;
#line 177
      __cil_tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
#line 177
      if (__cil_tmp___2) {
#line 178
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 181
  iter->next_done = (_Bool)1;
#line 182
  return;
}
}
#line 38 "mbscasecmp.c"
int mbscasecmp(char const   *s1 , char const   *s2 ) 
{ mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t __cil_tmp ;
  wint_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char __x ;
  unsigned char __x___0 ;
  int __cil_tmp___9 ;

  {
#line 41
  if ((unsigned int )s1 == (unsigned int )s2) {
#line 42
    return (0);
  }
#line 48
  __cil_tmp___9 = __locale_mb_cur_max();
#line 48
  if (__cil_tmp___9 > 1) {
#line 53
    iter1.cur.ptr = s1;
#line 53
    iter1.in_shift = (_Bool)0;
#line 53
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 53
    iter1.next_done = (_Bool)0;
#line 54
    iter2.cur.ptr = s2;
#line 54
    iter2.in_shift = (_Bool)0;
#line 54
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 54
    iter2.next_done = (_Bool)0;
#line 56
    while (1) {
#line 56
      mbuiter_multi_next(& iter1);
#line 56
      if (! (iter1.cur.wc_valid && (int )iter1.cur.wc == 0)) {
#line 56
        mbuiter_multi_next(& iter2);
#line 56
        if (! (! (iter2.cur.wc_valid && (int )iter2.cur.wc == 0))) {
#line 56
          break;
        }
      } else {
#line 56
        break;
      }
#line 58
      if (iter1.cur.wc_valid) {
#line 58
        if (iter2.cur.wc_valid) {
#line 58
          __cil_tmp = towlower((int )iter1.cur.wc);
#line 58
          __cil_tmp___0 = towlower((int )iter2.cur.wc);
#line 58
          __cil_tmp___1 = __cil_tmp - __cil_tmp___0;
        } else {
#line 58
          __cil_tmp___1 = -1;
        }
#line 58
        __cil_tmp___8 = __cil_tmp___1;
      } else {
#line 58
        if (iter2.cur.wc_valid) {
#line 58
          __cil_tmp___7 = 1;
        } else {
#line 58
          if (iter1.cur.bytes == iter2.cur.bytes) {
#line 58
            __cil_tmp___2 = rpl_memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                                       iter1.cur.bytes);
#line 58
            __cil_tmp___6 = __cil_tmp___2;
          } else {
#line 58
            if (iter1.cur.bytes < iter2.cur.bytes) {
#line 58
              __cil_tmp___3 = rpl_memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                                         iter1.cur.bytes);
#line 58
              __cil_tmp___5 = __cil_tmp___3 > 0 ? 1 : -1;
            } else {
#line 58
              __cil_tmp___4 = rpl_memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                                         iter2.cur.bytes);
#line 58
              __cil_tmp___5 = __cil_tmp___4 >= 0 ? 1 : -1;
            }
#line 58
            __cil_tmp___6 = __cil_tmp___5;
          }
#line 58
          __cil_tmp___7 = __cil_tmp___6;
        }
#line 58
        __cil_tmp___8 = __cil_tmp___7;
      }
#line 58
      cmp = __cil_tmp___8;
#line 60
      if (cmp != 0) {
#line 61
        return (cmp);
      }
#line 63
      iter1.cur.ptr += iter1.cur.bytes;
#line 63
      iter1.next_done = (_Bool)0;
#line 64
      iter2.cur.ptr += iter2.cur.bytes;
#line 64
      iter2.next_done = (_Bool)0;
    }
#line 66
    mbuiter_multi_next(& iter1);
#line 66
    if (! (iter1.cur.wc_valid && (int )iter1.cur.wc == 0)) {
#line 68
      return (1);
    }
#line 69
    mbuiter_multi_next(& iter2);
#line 69
    if (! (iter2.cur.wc_valid && (int )iter2.cur.wc == 0)) {
#line 71
      return (-1);
    }
#line 72
    return (0);
  } else {
#line 77
    p1 = (unsigned char const   *)s1;
#line 78
    p2 = (unsigned char const   *)s2;
#line 81
    while (1) {
#line 83
      if (((int const   )*((__ctype_ptr__ + sizeof(*("" + (int const   )*p1))) + (int )*p1) & 3) == 1) {
#line 83
        __x = (unsigned char )*p1;
#line 83
        c1 = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 1 ? ((int )__x - 65) + 97 : (int )__x);
      } else {
#line 83
        c1 = (unsigned char )*p1;
      }
#line 84
      if (((int const   )*((__ctype_ptr__ + sizeof(*("" + (int const   )*p2))) + (int )*p2) & 3) == 1) {
#line 84
        __x___0 = (unsigned char )*p2;
#line 84
        c2 = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___0))) + (int )__x___0) & 3) == 1 ? ((int )__x___0 - 65) + 97 : (int )__x___0);
      } else {
#line 84
        c2 = (unsigned char )*p2;
      }
#line 86
      if ((int )c1 == 0) {
#line 87
        break;
      }
#line 89
      p1 ++;
#line 90
      p2 ++;
#line 81
      if (! ((int )c1 == (int )c2)) {
#line 81
        break;
      }
    }
#line 95
    return ((int )c1 - (int )c2);
  }
}
}
#line 1 "mbswidth.o"
#pragma merger(0,"/tmp/cil-ykZ07IW3.i","-g,-O2")
#line 51 "mbswidth.h"
int gnu_mbswidth(char const   *string , int flags ) ;
#line 55
int mbsnwidth(char const   *string , size_t nbytes , int flags ) ;
#line 92 "./wchar.h"
int rpl_wcwidth(wchar_t wc ) ;
#line 29 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wctype.h"
extern int iswcntrl(wint_t  ) ;
#line 50 "mbswidth.c"
int gnu_mbswidth(char const   *string , int flags ) 
{ size_t __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 53
  __cil_tmp = strlen(string);
#line 53
  __cil_tmp___0 = mbsnwidth(string, __cil_tmp, flags);
#line 53
  return (__cil_tmp___0);
}
}
#line 61 "mbswidth.c"
int mbsnwidth(char const   *string , size_t nbytes , int flags ) 
{ char const   *p ;
  char const   *plimit ;
  int width ;
  mbstate_t mbstate ;
  wchar_t wc ;
  size_t bytes ;
  int w ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  unsigned char c ;
  char const   *__cil_tmp___2 ;

  {
#line 64
  p = string;
#line 65
  plimit = p + nbytes;
#line 68
  width = 0;
#line 70
  __cil_tmp___1 = __locale_mb_cur_max();
#line 70
  if (__cil_tmp___1 > 1) {
#line 72
    while ((unsigned int )p < (unsigned int )plimit) {
#line 73
      switch ((int )*p) {
      case 32: 
      case 33: 
      case 34: 
      case 35: 
      case 37: 
      case 38: 
      case 39: 
      case 40: 
      case 41: 
      case 42: 
      case 43: 
      case 44: 
      case 45: 
      case 46: 
      case 47: 
      case 48: 
      case 49: 
      case 50: 
      case 51: 
      case 52: 
      case 53: 
      case 54: 
      case 55: 
      case 56: 
      case 57: 
      case 58: 
      case 59: 
      case 60: 
      case 61: 
      case 62: 
      case 63: 
      case 65: 
      case 66: 
      case 67: 
      case 68: 
      case 69: 
      case 70: 
      case 71: 
      case 72: 
      case 73: 
      case 74: 
      case 75: 
      case 76: 
      case 77: 
      case 78: 
      case 79: 
      case 80: 
      case 81: 
      case 82: 
      case 83: 
      case 84: 
      case 85: 
      case 86: 
      case 87: 
      case 88: 
      case 89: 
      case 90: 
      case 91: 
      case 92: 
      case 93: 
      case 94: 
      case 95: 
      case 97: 
      case 98: 
      case 99: 
      case 100: 
      case 101: 
      case 102: 
      case 103: 
      case 104: 
      case 105: 
      case 106: 
      case 107: 
      case 108: 
      case 109: 
      case 110: 
      case 111: 
      case 112: 
      case 113: 
      case 114: 
      case 115: 
      case 116: 
      case 117: 
      case 118: 
      case 119: 
      case 120: 
      case 121: 
      case 122: 
      case 123: 
      case 124: 
      case 125: 
      case 126: 
#line 96
      p ++;
#line 97
      width ++;
#line 98
      break;
      default: 
#line 103
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 104
      while (1) {
#line 110
        bytes = mbrtowc(& wc, p, (unsigned int )(plimit - p), & mbstate);
#line 112
        if (bytes == 4294967295U) {
#line 115
          if (! (flags & 1)) {
#line 117
            p ++;
#line 118
            width ++;
#line 119
            break;
          } else {
#line 122
            return (-1);
          }
        }
#line 125
        if (bytes == 4294967294U) {
#line 128
          if (! (flags & 1)) {
#line 130
            p = plimit;
#line 131
            width ++;
#line 132
            break;
          } else {
#line 135
            return (-1);
          }
        }
#line 138
        if (bytes == 0U) {
#line 140
          bytes = 1U;
        }
#line 142
        w = rpl_wcwidth(wc);
#line 143
        if (w >= 0) {
#line 145
          width += w;
        } else
#line 148
        if (! (flags & 2)) {
#line 149
          __cil_tmp = iswcntrl((int )wc);
#line 149
          width += __cil_tmp ? 0 : 1;
        } else {
#line 151
          return (-1);
        }
#line 153
        p += bytes;
#line 104
        __cil_tmp___0 = mbsinit((mbstate_t const   *)(& mbstate));
#line 104
        if (__cil_tmp___0) {
#line 104
          break;
        }
      }
#line 157
      break;
      }
    }
#line 159
    return (width);
  }
#line 163
  while ((unsigned int )p < (unsigned int )plimit) {
#line 165
    __cil_tmp___2 = p;
#line 165
    p ++;
#line 165
    c = (unsigned char )*__cil_tmp___2;
#line 167
    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 151) {
#line 168
      width ++;
    } else
#line 169
    if (! (flags & 2)) {
#line 170
      width += (int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 32 ? 0 : 1;
    } else {
#line 172
      return (-1);
    }
  }
#line 174
  return (width);
}
}
#line 1 "openat-die.o"
#pragma merger(0,"/tmp/cil-iEJdqFBf.i","-g,-O2")
#line 62 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern  __attribute__((__noreturn__)) void abort(void) ;
#line 18 "exitfail.h"
int volatile   exit_failure ;
#line 29 "openat-die.c"
void openat_save_fail(int errno ) 
{ 

  {
#line 32
  error((int )exit_failure, errno, "unable to record current working directory");
#line 39
  abort();
}
}
#line 42 "openat-die.c"
void openat_restore_fail(int errno ) 
{ 

  {
#line 45
  error((int )exit_failure, errno, "failed to return to initial working directory");
#line 49
  abort();
}
}
#line 1 "printf-frexp.o"
#pragma merger(0,"/tmp/cil-ehYw79PG.i","-g,-O2")
#line 23 "printf-frexp.h"
double printf_frexp(double x , int *expptr ) ;
#line 64 "printf-frexp.c"
double printf_frexp(double x , int *expptr ) 
{ int exponent ;
  double pow2[64] ;
  double powh[64] ;
  int i ;
  double pow2_i ;
  double powh_i ;
  double pow2_i___0 ;
  double powh_i___0 ;

  {
#line 92
  exponent = 0;
#line 93
  if (x >= 1.0) {
#line 102
    i = 0;
#line 102
    pow2_i = 2.0;
#line 102
    powh_i = 0.5;
#line 102
    while (1) {
#line 106
      if (x >= pow2_i) {
#line 108
        exponent += 1 << i;
#line 109
        x *= powh_i;
      } else {
#line 112
        break;
      }
#line 114
      pow2[i] = pow2_i;
#line 115
      powh[i] = powh_i;
#line 102
      i ++;
#line 102
      pow2_i *= pow2_i;
#line 102
      powh_i *= powh_i;
    }
  } else {
#line 129
    i = 0;
#line 129
    pow2_i___0 = 2.0;
#line 129
    powh_i___0 = 0.5;
#line 129
    while (! (exponent - (1 << i) < -1022)) {
#line 136
      exponent -= 1 << i;
#line 137
      x *= pow2_i___0;
#line 138
      if (x >= 1.0) {
#line 139
        break;
      }
#line 141
      pow2[i] = pow2_i___0;
#line 142
      powh[i] = powh_i___0;
#line 129
      i ++;
#line 129
      pow2_i___0 *= pow2_i___0;
#line 129
      powh_i___0 *= powh_i___0;
    }
#line 148
    if (x < 1.0) {
#line 151
      while (i > 0) {
#line 153
        i --;
#line 154
        if (exponent - (1 << i) >= -1022) {
#line 156
          exponent -= 1 << i;
#line 157
          x *= pow2[i];
#line 158
          if (x >= 1.0) {
#line 159
            break;
          }
        }
      }
    }
  }
#line 170
  while (i > 0) {
#line 172
    i --;
#line 173
    if (x >= pow2[i]) {
#line 175
      exponent += 1 << i;
#line 176
      x *= powh[i];
    }
  }
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 1 "printf-frexpl.o"
#pragma merger(0,"/tmp/cil-layHI6a5.i","-g,-O2")
#line 23 "printf-frexpl.h"
long double printf_frexpl(long double x , int *expptr ) ;
#line 64 "printf-frexp.c"
long double printf_frexpl(long double x , int *expptr ) 
{ int exponent ;
  long double pow2[64] ;
  long double powh[64] ;
  int i ;
  long double pow2_i ;
  long double powh_i ;
  long double pow2_i___0 ;
  long double powh_i___0 ;

  {
#line 92
  exponent = 0;
#line 93
  if (x >= 1.0L) {
#line 102
    i = 0;
#line 102
    pow2_i = 2.0L;
#line 102
    powh_i = 0.5L;
#line 102
    while (1) {
#line 106
      if (x >= pow2_i) {
#line 108
        exponent += 1 << i;
#line 109
        x *= powh_i;
      } else {
#line 112
        break;
      }
#line 114
      pow2[i] = pow2_i;
#line 115
      powh[i] = powh_i;
#line 102
      i ++;
#line 102
      pow2_i *= pow2_i;
#line 102
      powh_i *= powh_i;
    }
  } else {
#line 129
    i = 0;
#line 129
    pow2_i___0 = 2.0L;
#line 129
    powh_i___0 = 0.5L;
#line 129
    while (! (exponent - (1 << i) < -1022)) {
#line 136
      exponent -= 1 << i;
#line 137
      x *= pow2_i___0;
#line 138
      if (x >= 1.0L) {
#line 139
        break;
      }
#line 141
      pow2[i] = pow2_i___0;
#line 142
      powh[i] = powh_i___0;
#line 129
      i ++;
#line 129
      pow2_i___0 *= pow2_i___0;
#line 129
      powh_i___0 *= powh_i___0;
    }
#line 148
    if (x < 1.0L) {
#line 151
      while (i > 0) {
#line 153
        i --;
#line 154
        if (exponent - (1 << i) >= -1022) {
#line 156
          exponent -= 1 << i;
#line 157
          x *= pow2[i];
#line 158
          if (x >= 1.0L) {
#line 159
            break;
          }
        }
      }
    }
  }
#line 170
  while (i > 0) {
#line 172
    i --;
#line 173
    if (x >= pow2[i]) {
#line 175
      exponent += 1 << i;
#line 176
      x *= powh[i];
    }
  }
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 1 "randint.o"
#pragma merger(0,"/tmp/cil-rFxS1EDk.i","-g,-O2")
#line 27 "randread.h"
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) ;
#line 28
void randread(struct randread_source *s , void *buf___0 , size_t size ) ;
#line 31
int randread_free(struct randread_source *s ) ;
#line 35 "randint.h"
struct randint_source *randint_new(struct randread_source *source ) ;
#line 36
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) ;
#line 37
struct randread_source *randint_get_source(struct randint_source  const  *s ) ;
#line 38
randint randint_genmax(struct randint_source *s , randint genmax ) ;
#line 48
void randint_free(struct randint_source *s ) ;
#line 49
int randint_all_free(struct randint_source *s ) ;
#line 74 "randint.c"
struct randint_source *randint_new(struct randread_source *source ) 
{ struct randint_source *s ;
  void *__cil_tmp ;
  randint __cil_tmp___0 ;

  {
#line 77
  __cil_tmp = xmalloc(sizeof(*s));
#line 77
  s = (struct randint_source *)__cil_tmp;
#line 78
  s->source = source;
#line 79
  __cil_tmp___0 = 0ULL;
#line 79
  s->randmax = __cil_tmp___0;
#line 79
  s->randnum = __cil_tmp___0;
#line 80
  return (s);
}
}
#line 87 "randint.c"
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) 
{ struct randread_source *source ;
  struct randread_source *__cil_tmp ;
  struct randint_source *__cil_tmp___0 ;
  struct randint_source *__cil_tmp___1 ;

  {
#line 90
  __cil_tmp = randread_new(name, bytes_bound);
#line 90
  source = __cil_tmp;
#line 91
  if (source) {
#line 91
    __cil_tmp___0 = randint_new(source);
#line 91
    __cil_tmp___1 = __cil_tmp___0;
  } else {
#line 91
    __cil_tmp___1 = (struct randint_source *)((void *)0);
  }
#line 91
  return (__cil_tmp___1);
}
}
#line 96 "randint.c"
struct randread_source *randint_get_source(struct randint_source  const  *s ) 
{ 

  {
#line 99
  return ((struct randread_source *)s->source);
}
}
#line 108 "randint.c"
__inline static randint shift_left(randint x ) 
{ 

  {
#line 110
  return (x << 8);
}
}
#line 124 "randint.c"
randint randint_genmax(struct randint_source *s , randint genmax ) 
{ struct randread_source *source ;
  randint randnum ;
  randint randmax ;
  randint choices ;
  size_t i ;
  randint rmax ;
  unsigned char buf___0[sizeof(randnum)] ;
  randint __cil_tmp ;
  randint __cil_tmp___0 ;
  randint __cil_tmp___1 ;
  randint __cil_tmp___2 ;
  randint excess_choices ;
  randint unusable_choices ;
  randint last_usable_choice ;
  randint reduced_randnum ;

  {
#line 127
  source = s->source;
#line 128
  randnum = s->randnum;
#line 129
  randmax = s->randmax;
#line 130
  choices = genmax + 1ULL;
#line 132
  while (1) {
#line 134
    if (randmax < genmax) {
#line 139
      i = 0U;
#line 140
      rmax = randmax;
#line 143
      while (1) {
#line 145
        __cil_tmp = shift_left(rmax);
#line 145
        rmax = __cil_tmp + 255ULL;
#line 146
        i ++;
#line 143
        if (! (rmax < genmax)) {
#line 143
          break;
        }
      }
#line 150
      randread(source, (void *)(buf___0), i);
#line 159
      i = 0U;
#line 161
      while (1) {
#line 163
        __cil_tmp___0 = shift_left(randnum);
#line 163
        randnum = __cil_tmp___0 + (unsigned long long )buf___0[i];
#line 164
        __cil_tmp___1 = shift_left(randmax);
#line 164
        randmax = __cil_tmp___1 + 255ULL;
#line 165
        i ++;
#line 161
        if (! (randmax < genmax)) {
#line 161
          break;
        }
      }
    }
#line 170
    if (randmax == genmax) {
#line 172
      __cil_tmp___2 = 0ULL;
#line 172
      s->randmax = __cil_tmp___2;
#line 172
      s->randnum = __cil_tmp___2;
#line 173
      return (randnum);
    } else {
#line 187
      excess_choices = randmax - genmax;
#line 188
      unusable_choices = excess_choices % choices;
#line 189
      last_usable_choice = randmax - unusable_choices;
#line 190
      reduced_randnum = randnum % choices;
#line 192
      if (randnum <= last_usable_choice) {
#line 194
        s->randnum = randnum / choices;
#line 195
        s->randmax = excess_choices / choices;
#line 196
        return (reduced_randnum);
      }
#line 201
      randnum = reduced_randnum;
#line 202
      randmax = unusable_choices - 1ULL;
    }
  }
}
}
#line 209 "randint.c"
void randint_free(struct randint_source *s ) 
{ 

  {
#line 212
  memset((void *)s, 0, sizeof(*s));
#line 213
  free((void *)s);
#line 214
  return;
}
}
#line 219 "randint.c"
int randint_all_free(struct randint_source *s ) 
{ int r ;
  int __cil_tmp ;
  int e ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 222
  __cil_tmp = randread_free(s->source);
#line 222
  r = __cil_tmp;
#line 223
  __cil_tmp___0 = __errno();
#line 223
  e = *__cil_tmp___0;
#line 224
  randint_free(s);
#line 225
  __cil_tmp___1 = __errno();
#line 225
  *__cil_tmp___1 = e;
#line 226
  return (r);
}
}
#line 1 "randperm.o"
#pragma merger(0,"/tmp/cil-GXiRaTnq.i","-g,-O2")
#line 42 "randint.h"
__inline static randint randint_choose(struct randint_source *s , randint choices ) 
{ randint __cil_tmp ;

  {
#line 45
  __cil_tmp = randint_genmax(s, choices - 1ULL);
#line 45
  return (__cil_tmp);
}
}
#line 3 "randperm.h"
size_t randperm_bound(size_t h , size_t n ) ;
#line 4
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) ;
#line 50 "xalloc.h"
void *xrealloc(void *p , size_t n ) ;
#line 111 "xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ void *__cil_tmp ;

  {
#line 114
  if ((unsigned int )(sizeof(ptrdiff_t ) <= sizeof(size_t ) ? -1 : -2) / s < n) {
#line 115
    xalloc_die();
  }
#line 116
  __cil_tmp = xmalloc(n * s);
#line 116
  return (__cil_tmp);
}
}
#line 122 "xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ void *__cil_tmp ;

  {
#line 125
  if ((unsigned int )(sizeof(ptrdiff_t ) <= sizeof(size_t ) ? -1 : -2) / s < n) {
#line 126
    xalloc_die();
  }
#line 127
  __cil_tmp = xrealloc(p, n * s);
#line 127
  return (__cil_tmp);
}
}
#line 31 "randperm.c"
static size_t ceil_lg(size_t n ) 
{ size_t b ;

  {
#line 34
  b = 0U;
#line 35
  n --;
#line 35
  while (n != 0U) {
#line 36
    b ++;
#line 35
    n /= 2U;
  }
#line 37
  return (b);
}
}
#line 44 "randperm.c"
size_t randperm_bound(size_t h , size_t n ) 
{ size_t lg_n ;
  size_t __cil_tmp ;
  size_t ar ;
  size_t bound ;

  {
#line 49
  __cil_tmp = ceil_lg(n);
#line 49
  lg_n = __cil_tmp;
#line 52
  ar = lg_n * h;
#line 55
  bound = ((ar + 8U) - 1U) / 8U;
#line 57
  return (bound);
}
}
#line 64 "randperm.c"
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) 
{ size_t *v ;
  void *__cil_tmp ;
  randint __cil_tmp___0 ;
  size_t i ;
  void *__cil_tmp___1 ;
  size_t j ;
  randint __cil_tmp___2 ;
  size_t t ;
  void *__cil_tmp___3 ;

  {
#line 69
  switch ((int )h) {
  case 0: 
#line 72
  v = (size_t *)((void *)0);
#line 73
  break;
  case 1: 
#line 76
  __cil_tmp = xmalloc(sizeof(*v));
#line 76
  v = (size_t *)__cil_tmp;
#line 77
  __cil_tmp___0 = randint_choose(r, (unsigned long long )n);
#line 77
  *(v + 0) = (unsigned int )__cil_tmp___0;
#line 78
  break;
  default: 
#line 84
  __cil_tmp___1 = xnmalloc(n, sizeof(*v));
#line 84
  v = (size_t *)__cil_tmp___1;
#line 85
  i = 0U;
#line 85
  while (i < n) {
#line 86
    *(v + i) = i;
#line 85
    i ++;
  }
#line 88
  i = 0U;
#line 88
  while (i < h) {
#line 90
    __cil_tmp___2 = randint_choose(r, (unsigned long long )(n - i));
#line 90
    j = (unsigned int )((unsigned long long )i + __cil_tmp___2);
#line 91
    t = *(v + i);
#line 92
    *(v + i) = *(v + j);
#line 93
    *(v + j) = t;
#line 88
    i ++;
  }
#line 96
  __cil_tmp___3 = xnrealloc((void *)v, h, sizeof(*v));
#line 96
  v = (size_t *)__cil_tmp___3;
#line 98
  break;
  }
#line 101
  return (v);
}
}
#line 1 "randread.o"
#pragma merger(0,"/tmp/cil-LcQP2sRc.i","-g,-O2")
#line 29 "randread.h"
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) ;
#line 30
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) ;
#line 134 "./quotearg.h"
char *quotearg_colon(char const   *arg ) ;
#line 177 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int setvbuf(FILE * , char * , int  , size_t  ) ;
#line 205
extern size_t fread(void * , size_t _size , size_t _n , FILE * ) ;
#line 40 "rand-isaac.h"
void isaac_seed(struct isaac_state *s ) ;
#line 41
void isaac_refill(struct isaac_state *s , unsigned int *r ) ;
#line 22 "stdio-safer.h"
FILE *fopen_safer(char const   *file , char const   *mode ) ;
#line 119 "randread.c"
static void randread_error(void const   *file_name___1 ) 
{ char *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 122
  if (file_name___1) {
#line 123
    __cil_tmp = quotearg_colon((char const   *)file_name___1);
#line 123
    __cil_tmp___0 = __errno();
#line 123
    __cil_tmp___1 = __errno();
#line 123
    error((int )exit_failure, *__cil_tmp___1, *__cil_tmp___0 == 0 ? "%s: end of file" : "%s: read error",
          __cil_tmp);
  }
#line 126
  abort();
#line 127
  return;
}
}
#line 132 "randread.c"
static struct randread_source *simple_new(FILE *source , void const   *handler_arg ) 
{ struct randread_source *s ;
  void *__cil_tmp ;

  {
#line 135
  __cil_tmp = xmalloc(sizeof(*s));
#line 135
  s = (struct randread_source *)__cil_tmp;
#line 136
  s->source = source;
#line 137
  s->handler = & randread_error;
#line 138
  s->handler_arg = handler_arg;
#line 139
  return (s);
}
}
#line 153 "randread.c"
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) 
{ struct randread_source *__cil_tmp ;
  char const   *file_name___1 ;
  FILE *source ;
  FILE *__cil_tmp___0 ;
  struct randread_source *s ;

  {
#line 156
  if (bytes_bound == 0U) {
#line 157
    __cil_tmp = simple_new((FILE *)((void *)0), (void const   *)((void *)0));
#line 157
    return (__cil_tmp);
  } else {
#line 160
    file_name___1 = name ? name : "/dev/urandom";
#line 161
    __cil_tmp___0 = fopen_safer(file_name___1, "rb");
#line 161
    source = __cil_tmp___0;
#line 164
    if (! source) {
#line 166
      if (name) {
#line 167
        return ((struct randread_source *)((void *)0));
      }
#line 168
      file_name___1 = (char const   *)((void *)0);
    }
#line 171
    s = simple_new(source, (void const   *)file_name___1);
#line 173
    if (source) {
#line 174
      setvbuf(source, s->buf.c, 0, sizeof(s->buf.c) < bytes_bound ? sizeof(s->buf.c) : bytes_bound);
    } else {
#line 177
      s->buf.isaac.buffered = 0U;
#line 178
      isaac_seed(& s->buf.isaac.state);
    }
#line 181
    return (s);
  }
}
}
#line 193 "randread.c"
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) 
{ 

  {
#line 196
  s->handler = handler;
#line 197
  return;
}
}
#line 199 "randread.c"
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) 
{ 

  {
#line 202
  s->handler_arg = handler_arg;
#line 203
  return;
}
}
#line 209 "randread.c"
static void readsource(struct randread_source *s , unsigned char *p , size_t size ) 
{ size_t inbytes ;
  size_t __cil_tmp ;
  int fread_errno ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 212
  while (1) {
#line 214
    __cil_tmp = fread((void *)p, sizeof(*p), size, s->source);
#line 214
    inbytes = __cil_tmp;
#line 215
    __cil_tmp___0 = __errno();
#line 215
    fread_errno = *__cil_tmp___0;
#line 216
    p += inbytes;
#line 217
    size -= inbytes;
#line 218
    if (size == 0U) {
#line 219
      break;
    }
#line 220
    __cil_tmp___1 = __errno();
#line 220
    __cil_tmp___2 = ferror(s->source);
#line 220
    *__cil_tmp___1 = __cil_tmp___2 ? fread_errno : 0;
#line 221
    (*(s->handler))(s->handler_arg);
  }
#line 223
  return;
}
}
#line 229 "randread.c"
static void readisaac(struct isaac *isaac , unsigned char *p , size_t size ) 
{ size_t inbytes ;
  unsigned int *wp ;

  {
#line 232
  inbytes = isaac->buffered;
#line 234
  while (1) {
#line 236
    if (size <= inbytes) {
#line 238
      memcpy((void *)p, (void const   *)((isaac->data.b + (unsigned int )(1 << 8) * sizeof(unsigned int )) - inbytes),
             size);
#line 239
      isaac->buffered = inbytes - size;
#line 240
      return;
    }
#line 243
    memcpy((void *)p, (void const   *)((isaac->data.b + (unsigned int )(1 << 8) * sizeof(unsigned int )) - inbytes),
           inbytes);
#line 244
    p += inbytes;
#line 245
    size -= inbytes;
#line 249
    if ((unsigned int )p % (unsigned int )((char *)(& ((struct __anonstruct_15 *)0)->x)) == 0U) {
#line 251
      wp = (unsigned int *)p;
#line 252
      while ((unsigned int )(1 << 8) * sizeof(unsigned int ) <= size) {
#line 254
        isaac_refill(& isaac->state, wp);
#line 255
        wp += 1 << 8;
#line 256
        size -= (unsigned int )(1 << 8) * sizeof(unsigned int );
#line 257
        if (size == 0U) {
#line 259
          isaac->buffered = 0U;
#line 260
          return;
        }
      }
#line 263
      p = (unsigned char *)wp;
    }
#line 266
    isaac_refill(& isaac->state, isaac->data.w);
#line 267
    inbytes = (unsigned int )(1 << 8) * sizeof(unsigned int );
  }
}
}
#line 275 "randread.c"
void randread(struct randread_source *s , void *buf___0 , size_t size ) 
{ 

  {
#line 278
  if (s->source) {
#line 279
    readsource(s, (unsigned char *)buf___0, size);
  } else {
#line 281
    readisaac(& s->buf.isaac, (unsigned char *)buf___0, size);
  }
#line 282
  return;
}
}
#line 290 "randread.c"
int randread_free(struct randread_source *s ) 
{ FILE *source ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 293
  source = s->source;
#line 294
  memset((void *)s, 0, sizeof(*s));
#line 295
  free((void *)s);
#line 296
  if (source) {
#line 296
    __cil_tmp = fclose(source);
#line 296
    __cil_tmp___0 = __cil_tmp;
  } else {
#line 296
    __cil_tmp___0 = 0;
  }
#line 296
  return (__cil_tmp___0);
}
}
#line 1 "rand-isaac.o"
#pragma merger(0,"/tmp/cil-zf1VQzpC.i","-g,-O2")
#line 78 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern gid_t getgid(void) ;
#line 95
extern pid_t getpid(void) ;
#line 96
extern pid_t getppid(void) ;
#line 101
extern uid_t getuid(void) ;
#line 34 "gethrxtime.h"
xtime_t gethrxtime(void) ;
#line 63 "rand-isaac.c"
void isaac_refill(struct isaac_state *s , unsigned int *r ) 
{ unsigned int a ;
  unsigned int b ;
  unsigned int x ;
  unsigned int y ;
  unsigned int *m ;

  {
#line 68
  m = s->mm;
#line 70
  a = s->a;
#line 71
  (s->c) ++;
#line 71
  b = s->b + s->c;
#line 73
  while (1) {
#line 75
    a = (a ^ (a << 13)) + *(m + (1 << 8) / 2);
#line 75
    x = *m;
#line 75
    y = (*((unsigned int *)((char *)(s->mm) + (x & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + a) + b;
#line 75
    *m = y;
#line 75
    b = *((unsigned int *)((char *)(s->mm) + ((y >> 8) & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + x;
#line 75
    *r = b;
#line 76
    a = (a ^ (a >> 6)) + *((m + 1) + (1 << 8) / 2);
#line 76
    x = *(m + 1);
#line 76
    y = (*((unsigned int *)((char *)(s->mm) + (x & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + a) + b;
#line 76
    *(m + 1) = y;
#line 76
    b = *((unsigned int *)((char *)(s->mm) + ((y >> 8) & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + x;
#line 76
    *(r + 1) = b;
#line 77
    a = (a ^ (a << 2)) + *((m + 2) + (1 << 8) / 2);
#line 77
    x = *(m + 2);
#line 77
    y = (*((unsigned int *)((char *)(s->mm) + (x & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + a) + b;
#line 77
    *(m + 2) = y;
#line 77
    b = *((unsigned int *)((char *)(s->mm) + ((y >> 8) & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + x;
#line 77
    *(r + 2) = b;
#line 78
    a = (a ^ (a >> 16)) + *((m + 3) + (1 << 8) / 2);
#line 78
    x = *(m + 3);
#line 78
    y = (*((unsigned int *)((char *)(s->mm) + (x & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + a) + b;
#line 78
    *(m + 3) = y;
#line 78
    b = *((unsigned int *)((char *)(s->mm) + ((y >> 8) & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + x;
#line 78
    *(r + 3) = b;
#line 79
    r += 4;
#line 73
    m += 4;
#line 73
    if (! ((unsigned int )m < (unsigned int )(s->mm + (1 << 8) / 2))) {
#line 73
      break;
    }
  }
#line 82
  while (1) {
#line 84
    a = (a ^ (a << 13)) + *(m + - (1 << 8) / 2);
#line 84
    x = *m;
#line 84
    y = (*((unsigned int *)((char *)(s->mm) + (x & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + a) + b;
#line 84
    *m = y;
#line 84
    b = *((unsigned int *)((char *)(s->mm) + ((y >> 8) & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + x;
#line 84
    *r = b;
#line 85
    a = (a ^ (a >> 6)) + *((m + 1) + - (1 << 8) / 2);
#line 85
    x = *(m + 1);
#line 85
    y = (*((unsigned int *)((char *)(s->mm) + (x & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + a) + b;
#line 85
    *(m + 1) = y;
#line 85
    b = *((unsigned int *)((char *)(s->mm) + ((y >> 8) & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + x;
#line 85
    *(r + 1) = b;
#line 86
    a = (a ^ (a << 2)) + *((m + 2) + - (1 << 8) / 2);
#line 86
    x = *(m + 2);
#line 86
    y = (*((unsigned int *)((char *)(s->mm) + (x & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + a) + b;
#line 86
    *(m + 2) = y;
#line 86
    b = *((unsigned int *)((char *)(s->mm) + ((y >> 8) & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + x;
#line 86
    *(r + 2) = b;
#line 87
    a = (a ^ (a >> 16)) + *((m + 3) + - (1 << 8) / 2);
#line 87
    x = *(m + 3);
#line 87
    y = (*((unsigned int *)((char *)(s->mm) + (x & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + a) + b;
#line 87
    *(m + 3) = y;
#line 87
    b = *((unsigned int *)((char *)(s->mm) + ((y >> 8) & (unsigned int )((1 << 8) - 1) * sizeof(unsigned int )))) + x;
#line 87
    *(r + 3) = b;
#line 88
    r += 4;
#line 82
    m += 4;
#line 82
    if (! ((unsigned int )m < (unsigned int )(s->mm + (1 << 8)))) {
#line 82
      break;
    }
  }
#line 91
  s->a = a;
#line 92
  s->b = b;
#line 93
  return;
}
}
#line 111 "rand-isaac.c"
static void isaac_mix(struct isaac_state *s , unsigned int const   *seed ) 
{ int i ;
  unsigned int a ;
  unsigned int b ;
  unsigned int c ;
  unsigned int d ;
  unsigned int e ;
  unsigned int f ;
  unsigned int g ;
  unsigned int h ;

  {
#line 115
  a = s->iv[0];
#line 116
  b = s->iv[1];
#line 117
  c = s->iv[2];
#line 118
  d = s->iv[3];
#line 119
  e = s->iv[4];
#line 120
  f = s->iv[5];
#line 121
  g = s->iv[6];
#line 122
  h = s->iv[7];
#line 124
  i = 0;
#line 124
  while (i < 1 << 8) {
#line 126
    a += (unsigned int )*(seed + i);
#line 127
    b += (unsigned int )*(seed + (i + 1));
#line 128
    c += (unsigned int )*(seed + (i + 2));
#line 129
    d += (unsigned int )*(seed + (i + 3));
#line 130
    e += (unsigned int )*(seed + (i + 4));
#line 131
    f += (unsigned int )*(seed + (i + 5));
#line 132
    g += (unsigned int )*(seed + (i + 6));
#line 133
    h += (unsigned int )*(seed + (i + 7));
#line 135
    a ^= b << 11;
#line 135
    d += a;
#line 135
    b += c;
#line 135
    b ^= c >> 2;
#line 135
    e += b;
#line 135
    c += d;
#line 135
    c ^= d << 8;
#line 135
    f += c;
#line 135
    d += e;
#line 135
    d ^= e >> 16;
#line 135
    g += d;
#line 135
    e += f;
#line 135
    e ^= f << 10;
#line 135
    h += e;
#line 135
    f += g;
#line 135
    f ^= g >> 4;
#line 135
    a += f;
#line 135
    g += h;
#line 135
    g ^= h << 8;
#line 135
    b += g;
#line 135
    h += a;
#line 135
    h ^= a >> 9;
#line 135
    c += h;
#line 135
    a += b;
#line 137
    s->mm[i] = a;
#line 138
    s->mm[i + 1] = b;
#line 139
    s->mm[i + 2] = c;
#line 140
    s->mm[i + 3] = d;
#line 141
    s->mm[i + 4] = e;
#line 142
    s->mm[i + 5] = f;
#line 143
    s->mm[i + 6] = g;
#line 144
    s->mm[i + 7] = h;
#line 124
    i += 8;
  }
#line 147
  s->iv[0] = a;
#line 148
  s->iv[1] = b;
#line 149
  s->iv[2] = c;
#line 150
  s->iv[3] = d;
#line 151
  s->iv[4] = e;
#line 152
  s->iv[5] = f;
#line 153
  s->iv[6] = g;
#line 154
  s->iv[7] = h;
#line 155
  return;
}
}
#line 217
static void isaac_seed_start(struct isaac_state *s ) ;
#line 217 "rand-isaac.c"
static unsigned int const   iv[8]  = 
#line 217
  {      (unsigned int const   )325574490,      (unsigned int const   )2514026585U,      (unsigned int const   )3273014859U,      (unsigned int const   )255990488, 
        (unsigned int const   )3643427448U,      (unsigned int const   )2769960009U,      (unsigned int const   )3304057371U,      (unsigned int const   )811634969};
#line 214 "rand-isaac.c"
static void isaac_seed_start(struct isaac_state *s ) 
{ unsigned int __cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 232
  memset((void *)(s->mm), 0, sizeof(s->mm));
#line 233
  memcpy((void *)(s->iv), (void const   *)(iv), sizeof(s->iv));
#line 236
  __cil_tmp___0 = 0U;
#line 236
  s->c = __cil_tmp___0;
#line 236
  __cil_tmp = __cil_tmp___0;
#line 236
  s->b = __cil_tmp;
#line 236
  s->a = __cil_tmp;
#line 237
  return;
}
}
#line 240 "rand-isaac.c"
static void isaac_seed_data(struct isaac_state *s , void const   *buffer , size_t size ) 
{ unsigned char const   *buf___0 ;
  unsigned char *p ;
  size_t avail ;
  size_t i ;

  {
#line 243
  buf___0 = (unsigned char const   *)buffer;
#line 248
  avail = sizeof(s->mm) - s->c;
#line 251
  while (size > avail) {
#line 253
    p = (unsigned char *)(s->mm) + s->c;
#line 254
    i = 0U;
#line 254
    while (i < avail) {
#line 255
      *(p + i) = (unsigned char )((int )*(p + i) ^ (int )*(buf___0 + i));
#line 254
      i ++;
    }
#line 256
    buf___0 += avail;
#line 257
    size -= avail;
#line 258
    isaac_mix(s, (unsigned int const   *)(s->mm));
#line 259
    s->c = 0U;
#line 260
    avail = sizeof(s->mm);
  }
#line 264
  p = (unsigned char *)(s->mm) + s->c;
#line 265
  i = 0U;
#line 265
  while (i < size) {
#line 266
    *(p + i) = (unsigned char )((int )*(p + i) ^ (int )*(buf___0 + i));
#line 265
    i ++;
  }
#line 267
  s->c = size;
#line 268
  return;
}
}
#line 272 "rand-isaac.c"
static void isaac_seed_finish(struct isaac_state *s ) 
{ 

  {
#line 275
  isaac_mix(s, (unsigned int const   *)(s->mm));
#line 276
  isaac_mix(s, (unsigned int const   *)(s->mm));
#line 278
  s->c = 0U;
#line 279
  return;
}
}
#line 284 "rand-isaac.c"
void isaac_seed(struct isaac_state *s ) 
{ pid_t t ;
  pid_t __cil_tmp ;
  pid_t t___0 ;
  pid_t __cil_tmp___0 ;
  uid_t t___1 ;
  uid_t __cil_tmp___1 ;
  gid_t t___2 ;
  gid_t __cil_tmp___2 ;
  xtime_t t___3 ;
  xtime_t __cil_tmp___3 ;

  {
#line 287
  isaac_seed_start(s);
#line 289
  __cil_tmp = getpid();
#line 289
  t = __cil_tmp;
#line 289
  isaac_seed_data(s, (void const   *)(& t), sizeof(t));
#line 290
  __cil_tmp___0 = getppid();
#line 290
  t___0 = __cil_tmp___0;
#line 290
  isaac_seed_data(s, (void const   *)(& t___0), sizeof(t___0));
#line 291
  __cil_tmp___1 = getuid();
#line 291
  t___1 = __cil_tmp___1;
#line 291
  isaac_seed_data(s, (void const   *)(& t___1), sizeof(t___1));
#line 292
  __cil_tmp___2 = getgid();
#line 292
  t___2 = __cil_tmp___2;
#line 292
  isaac_seed_data(s, (void const   *)(& t___2), sizeof(t___2));
#line 295
  __cil_tmp___3 = gethrxtime();
#line 295
  t___3 = __cil_tmp___3;
#line 296
  isaac_seed_data(s, (void const   *)(& t___3), sizeof(t___3));
#line 299
  isaac_seed_finish(s);
#line 300
  return;
}
}
#line 1 "readtokens0.o"
#pragma merger(0,"/tmp/cil-05uUxTIX.i","-g,-O2")
#line 194 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int fgetc(FILE * ) ;
#line 180 "obstack.h"
void _obstack_newchunk(struct obstack *h , int length ) ;
#line 181
int _obstack_begin(struct obstack *h , int size , int alignment , void *(*chunkfun)(long  ) ,
                   void (*freefun)(void * ) ) ;
#line 193
void obstack_free(struct obstack *h , void *obj ) ;
#line 38 "readtokens0.h"
void readtokens0_init(struct Tokens *t ) ;
#line 39
void readtokens0_free(struct Tokens *t ) ;
#line 40
_Bool readtokens0(FILE *in , struct Tokens *t ) ;
#line 29 "readtokens0.c"
void readtokens0_init(struct Tokens *t ) 
{ 

  {
#line 32
  t->n_tok = 0U;
#line 33
  t->tok = (char **)((void *)0);
#line 34
  t->tok_len = (size_t *)((void *)0);
#line 35
  _obstack_begin(& t->o_data, 0, 0, (void *(*)(long  ))(& rpl_malloc), & free);
#line 36
  _obstack_begin(& t->o_tok, 0, 0, (void *(*)(long  ))(& rpl_malloc), & free);
#line 37
  _obstack_begin(& t->o_tok_len, 0, 0, (void *(*)(long  ))(& rpl_malloc), & free);
#line 38
  return;
}
}
#line 40 "readtokens0.c"
void readtokens0_free(struct Tokens *t ) 
{ struct obstack *__o ;
  void *__obj ;
  char *__cil_tmp ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *__cil_tmp___0 ;
  struct obstack *__o___1 ;
  void *__obj___1 ;
  char *__cil_tmp___1 ;

  {
#line 43
  __o = & t->o_data;
#line 43
  __obj = (void *)0;
#line 43
  if ((unsigned int )__obj > (unsigned int )((void *)__o->chunk) && (unsigned int )__obj < (unsigned int )((void *)__o->chunk_limit)) {
#line 43
    __cil_tmp = (char *)__obj;
#line 43
    __o->object_base = __cil_tmp;
#line 43
    __o->next_free = __cil_tmp;
  } else {
#line 43
    obstack_free(__o, __obj);
  }
#line 44
  __o___0 = & t->o_tok;
#line 44
  __obj___0 = (void *)0;
#line 44
  if ((unsigned int )__obj___0 > (unsigned int )((void *)__o___0->chunk) && (unsigned int )__obj___0 < (unsigned int )((void *)__o___0->chunk_limit)) {
#line 44
    __cil_tmp___0 = (char *)__obj___0;
#line 44
    __o___0->object_base = __cil_tmp___0;
#line 44
    __o___0->next_free = __cil_tmp___0;
  } else {
#line 44
    obstack_free(__o___0, __obj___0);
  }
#line 45
  __o___1 = & t->o_tok_len;
#line 45
  __obj___1 = (void *)0;
#line 45
  if ((unsigned int )__obj___1 > (unsigned int )((void *)__o___1->chunk) && (unsigned int )__obj___1 < (unsigned int )((void *)__o___1->chunk_limit)) {
#line 45
    __cil_tmp___1 = (char *)__obj___1;
#line 45
    __o___1->object_base = __cil_tmp___1;
#line 45
    __o___1->next_free = __cil_tmp___1;
  } else {
#line 45
    obstack_free(__o___1, __obj___1);
  }
#line 46
  return;
}
}
#line 50 "readtokens0.c"
static void save_token(struct Tokens *t ) 
{ size_t len ;
  struct obstack  const  *__o ;
  char const   *s ;
  struct obstack *__o1 ;
  void *__value ;
  struct obstack *__o___0 ;
  struct obstack *__o1___0 ;
  struct obstack *__o___1 ;
  int __len ;

  {
#line 54
  __o = (struct obstack  const  *)(& t->o_data);
#line 54
  len = (unsigned int )(__o->next_free - __o->object_base) - 1U;
#line 55
  __o1 = & t->o_data;
#line 55
  __value = (void *)__o1->object_base;
#line 55
  if ((unsigned int )__o1->next_free == (unsigned int )__value) {
#line 55
    __o1->maybe_empty_object = 1U;
  }
#line 55
  __o1->next_free = (sizeof(ptrdiff_t ) < sizeof(void *) ? __o1->object_base : (char *)0) + (((__o1->next_free - (sizeof(ptrdiff_t ) < sizeof(void *) ? __o1->object_base : (char *)0)) + __o1->alignment_mask) & ~ __o1->alignment_mask);
#line 55
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 55
    __o1->next_free = __o1->chunk_limit;
  }
#line 55
  __o1->object_base = __o1->next_free;
#line 55
  s = (char const   *)__value;
#line 56
  __o___0 = & t->o_tok;
#line 56
  if ((unsigned int )(__o___0->next_free + sizeof(void *)) > (unsigned int )__o___0->chunk_limit) {
#line 56
    _obstack_newchunk(__o___0, (int )sizeof(void *));
  }
#line 56
  __o1___0 = __o___0;
#line 56
  *((void const   **)__o1___0->next_free) = (void const   *)s;
#line 56
  __o1___0->next_free += sizeof(void const   *);
#line 57
  __o___1 = & t->o_tok_len;
#line 57
  __len = (int )sizeof(len);
#line 57
  if ((unsigned int )(__o___1->next_free + __len) > (unsigned int )__o___1->chunk_limit) {
#line 57
    _obstack_newchunk(__o___1, __len);
  }
#line 57
  memcpy((void *)__o___1->next_free, (void const   *)(& len), (unsigned int )__len);
#line 57
  __o___1->next_free += __len;
#line 58
  (t->n_tok) ++;
#line 59
  return;
}
}
#line 65 "readtokens0.c"
_Bool readtokens0(FILE *in , struct Tokens *t ) 
{ int c ;
  int __cil_tmp ;
  size_t len ;
  struct obstack  const  *__o ;
  struct obstack *__o___0 ;
  char *__cil_tmp___0 ;
  struct obstack *__o___1 ;
  char *__cil_tmp___1 ;
  struct obstack *__o___2 ;
  struct obstack *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  struct obstack *__o1___1 ;
  void *__value___0 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 69
  while (1) {
#line 71
    __cil_tmp = fgetc(in);
#line 71
    c = __cil_tmp;
#line 72
    if (c == -1) {
#line 74
      __o = (struct obstack  const  *)(& t->o_data);
#line 74
      len = (unsigned int )(__o->next_free - __o->object_base);
#line 78
      if (len) {
#line 80
        __o___0 = & t->o_data;
#line 80
        if ((unsigned int )(__o___0->next_free + 1) > (unsigned int )__o___0->chunk_limit) {
#line 80
          _obstack_newchunk(__o___0, 1);
        }
#line 80
        __cil_tmp___0 = __o___0->next_free;
#line 80
        (__o___0->next_free) ++;
#line 80
        *__cil_tmp___0 = (char )'\000';
#line 81
        save_token(t);
      }
#line 84
      break;
    }
#line 87
    __o___1 = & t->o_data;
#line 87
    if ((unsigned int )(__o___1->next_free + 1) > (unsigned int )__o___1->chunk_limit) {
#line 87
      _obstack_newchunk(__o___1, 1);
    }
#line 87
    __cil_tmp___1 = __o___1->next_free;
#line 87
    (__o___1->next_free) ++;
#line 87
    *__cil_tmp___1 = (char )c;
#line 88
    if (c == 0) {
#line 89
      save_token(t);
    }
  }
#line 94
  __o___2 = & t->o_tok;
#line 94
  if ((unsigned int )(__o___2->next_free + sizeof(void *)) > (unsigned int )__o___2->chunk_limit) {
#line 94
    _obstack_newchunk(__o___2, (int )sizeof(void *));
  }
#line 94
  __o1 = __o___2;
#line 94
  *((void const   **)__o1->next_free) = (void const   *)((void *)0);
#line 94
  __o1->next_free += sizeof(void const   *);
#line 96
  __o1___0 = & t->o_tok;
#line 96
  __value = (void *)__o1___0->object_base;
#line 96
  if ((unsigned int )__o1___0->next_free == (unsigned int )__value) {
#line 96
    __o1___0->maybe_empty_object = 1U;
  }
#line 96
  __o1___0->next_free = (sizeof(ptrdiff_t ) < sizeof(void *) ? __o1___0->object_base : (char *)0) + (((__o1___0->next_free - (sizeof(ptrdiff_t ) < sizeof(void *) ? __o1___0->object_base : (char *)0)) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 96
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 96
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 96
  __o1___0->object_base = __o1___0->next_free;
#line 96
  t->tok = (char **)__value;
#line 97
  __o1___1 = & t->o_tok_len;
#line 97
  __value___0 = (void *)__o1___1->object_base;
#line 97
  if ((unsigned int )__o1___1->next_free == (unsigned int )__value___0) {
#line 97
    __o1___1->maybe_empty_object = 1U;
  }
#line 97
  __o1___1->next_free = (sizeof(ptrdiff_t ) < sizeof(void *) ? __o1___1->object_base : (char *)0) + (((__o1___1->next_free - (sizeof(ptrdiff_t ) < sizeof(void *) ? __o1___1->object_base : (char *)0)) + __o1___1->alignment_mask) & ~ __o1___1->alignment_mask);
#line 97
  if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 97
    __o1___1->next_free = __o1___1->chunk_limit;
  }
#line 97
  __o1___1->object_base = __o1___1->next_free;
#line 97
  t->tok_len = (size_t *)__value___0;
#line 98
  __cil_tmp___2 = ferror(in);
#line 98
  if (__cil_tmp___2) {
#line 98
    __cil_tmp___3 = 0;
  } else {
#line 98
    __cil_tmp___3 = 1;
  }
#line 98
  return ((_Bool )__cil_tmp___3);
}
}
#line 1 "savewd.o"
#pragma merger(0,"/tmp/cil-tOnb4HN2.i","-g,-O2")
#line 70 "savewd.h"
__inline static void savewd_init(struct savewd *wd ) 
{ 

  {
#line 73
  wd->state = (enum __anonenum_state_8 )0;
#line 74
  return;
}
}
#line 108
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) ;
#line 117
int savewd_restore(struct savewd *wd , int status ) ;
#line 128
void savewd_finish(struct savewd *wd ) ;
#line 144
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) ;
#line 25 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/signal.h"
extern int raise(int  ) ;
#line 17 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 21
extern int chdir(char const   *__path ) ;
#line 29
extern int close(int __fildes ) ;
#line 67
extern pid_t fork(void) ;
#line 49 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/fcntl.h"
extern int open(char const   *name , int oflag  , ...) ;
#line 31 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/wait.h"
extern pid_t waitpid(pid_t pid , int *stat_loc , int options ) ;
#line 22 "fcntl-safer.h"
int open_safer(char const   *file , int flags  , ...) ;
#line 44 "savewd.c"
static _Bool savewd_save(struct savewd *wd ) 
{ int fd ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;

  {
#line 47
  switch ((int )wd->state) {
  case 0: 
#line 52
  __cil_tmp = open_safer(".", 1);
#line 52
  fd = __cil_tmp;
#line 53
  if (0 <= fd) {
#line 55
    wd->state = (enum __anonenum_state_8 )1;
#line 56
    wd->val.fd = fd;
#line 57
    break;
  }
#line 59
  __cil_tmp___1 = __errno();
#line 59
  if (*__cil_tmp___1 != 13) {
#line 59
    __cil_tmp___2 = __errno();
#line 59
    if (*__cil_tmp___2 != 133) {
#line 61
      wd->state = (enum __anonenum_state_8 )4;
#line 62
      __cil_tmp___0 = __errno();
#line 62
      wd->val.errnum = *__cil_tmp___0;
#line 63
      break;
    }
  }
#line 66
  wd->state = (enum __anonenum_state_8 )3;
#line 67
  wd->val.child = -1;
  case 3: 
#line 70
  if (wd->val.child < 0) {
#line 75
    wd->val.child = fork();
#line 76
    if (wd->val.child != 0) {
#line 78
      if (0 < wd->val.child) {
#line 79
        return ((_Bool)1);
      }
#line 80
      wd->state = (enum __anonenum_state_8 )4;
#line 81
      __cil_tmp___3 = __errno();
#line 81
      wd->val.errnum = *__cil_tmp___3;
    }
  }
#line 84
  break;
  case 1: 
  case 2: 
  case 4: 
  case 5: 
#line 90
  break;
  default: 
#line 93
  __libc_failwith((char *)"Assertion failed: false at savewd.c:93");
  }
#line 96
  return ((_Bool)0);
}
}
#line 134
extern int fchdir() ;
#line 99 "savewd.c"
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) 
{ int fd ;
  int result ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  _Bool __cil_tmp___3 ;
  int e ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;

  {
#line 103
  fd = -1;
#line 104
  result = 0;
#line 108
  if (open_result) {
#line 111
    fd = open(dir, 145 | (options & 1 ? 0 : 0));
#line 115
    if (open_result) {
#line 117
      *(open_result + 0) = fd;
#line 118
      __cil_tmp = __errno();
#line 118
      *(open_result + 1) = *__cil_tmp;
    }
#line 121
    if (fd < 0) {
#line 121
      __cil_tmp___0 = __errno();
#line 121
      if (*__cil_tmp___0 != 13 || options & 2) {
#line 122
        result = -1;
      }
    }
  }
#line 125
  if (result == 0 && ! (0 <= fd && options & 4)) {
#line 127
    __cil_tmp___3 = savewd_save(wd);
#line 127
    if (__cil_tmp___3) {
#line 129
      open_result = (int *)((void *)0);
#line 130
      result = -2;
    } else {
#line 134
      if (fd < 0) {
#line 134
        __cil_tmp___1 = chdir(dir);
#line 134
        result = __cil_tmp___1;
      } else {
#line 134
        __cil_tmp___2 = fchdir(fd);
#line 134
        result = __cil_tmp___2;
      }
#line 136
      if (result == 0) {
#line 137
        switch ((int )wd->state) {
        case 1: 
#line 140
        wd->state = (enum __anonenum_state_8 )2;
#line 141
        break;
        case 4: 
        case 2: 
        case 5: 
#line 146
        break;
        case 3: 
#line 149
        if ((wd->val.child == 0) == 0) {
#line 149
          __libc_failwith((char *)"Assertion failed: wd->val.child == 0 at savewd.c:149");
        }
#line 150
        break;
        default: 
#line 153
        __libc_failwith((char *)"Assertion failed: false at savewd.c:153");
        }
      }
    }
  }
#line 158
  if (0 <= fd && ! open_result) {
#line 160
    __cil_tmp___4 = __errno();
#line 160
    e = *__cil_tmp___4;
#line 161
    close(fd);
#line 162
    __cil_tmp___5 = __errno();
#line 162
    *__cil_tmp___5 = e;
  }
#line 165
  return (result);
}
}
#line 168 "savewd.c"
int savewd_restore(struct savewd *wd , int status ) 
{ int chdir_errno ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  pid_t child ;
  int child_status ;
  int *__cil_tmp___2 ;
  pid_t __cil_tmp___3 ;

  {
#line 171
  switch ((int )wd->state) {
  case 0: 
  case 1: 
#line 177
  break;
  case 2: 
#line 181
  __cil_tmp___0 = fchdir(wd->val.fd);
#line 181
  if (__cil_tmp___0 == 0) {
#line 183
    wd->state = (enum __anonenum_state_8 )1;
#line 184
    break;
  } else {
#line 188
    __cil_tmp = __errno();
#line 188
    chdir_errno = *__cil_tmp;
#line 189
    close(wd->val.fd);
#line 190
    wd->state = (enum __anonenum_state_8 )4;
#line 191
    wd->val.errnum = chdir_errno;
  }
  case 4: 
#line 196
  __cil_tmp___1 = __errno();
#line 196
  *__cil_tmp___1 = wd->val.errnum;
#line 197
  return (-1);
  case 3: 
#line 203
  child = wd->val.child;
#line 204
  if (child == 0) {
#line 205
    _exit(status);
  }
#line 206
  if (0 < child) {
#line 209
    while (1) {
#line 209
      __cil_tmp___3 = waitpid(child, & child_status, 0);
#line 209
      if (! (__cil_tmp___3 < 0)) {
#line 209
        break;
      }
#line 210
      __cil_tmp___2 = __errno();
#line 210
      if ((*__cil_tmp___2 == 4) == 0) {
#line 210
        __libc_failwith((char *)"Assertion failed: errno == EINTR at savewd.c:210");
      }
    }
#line 211
    wd->val.child = -1;
#line 212
    if (! (child_status & 4)) {
#line 213
      raise(child_status & 64);
    }
#line 214
    return (child_status & 1);
  }
#line 217
  break;
  default: 
#line 220
  __libc_failwith((char *)"Assertion failed: false at savewd.c:220");
  }
#line 223
  return (0);
}
}
#line 226 "savewd.c"
void savewd_finish(struct savewd *wd ) 
{ 

  {
#line 229
  switch ((int )wd->state) {
  case 0: 
  case 4: 
#line 233
  break;
  case 1: 
  case 2: 
#line 237
  close(wd->val.fd);
#line 238
  break;
  case 3: 
#line 241
  if ((wd->val.child < 0) == 0) {
#line 241
    __libc_failwith((char *)"Assertion failed: wd->val.child < 0 at savewd.c:241");
  }
#line 242
  break;
  default: 
#line 245
  __libc_failwith((char *)"Assertion failed: false at savewd.c:245");
  }
#line 248
  wd->state = (enum __anonenum_state_8 )5;
#line 249
  return;
}
}
#line 261 "savewd.c"
__inline static _Bool savewd_delegating(struct savewd  const  *wd ) 
{ 

  {
#line 264
  return ((_Bool )((unsigned int const   )wd->state == 3U && 0 < (int )wd->val.child));
}
}
#line 267 "savewd.c"
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) 
{ int i ;
  int last_relative ;
  int exit_status ;
  struct savewd wd ;
  int s ;
  int __cil_tmp ;
  _Bool __cil_tmp___0 ;
  int r ;
  int __cil_tmp___1 ;
  int s___0 ;
  int __cil_tmp___2 ;

  {
#line 272
  i = 0;
#line 274
  exit_status = 0;
#line 276
  savewd_init(& wd);
#line 278
  last_relative = n_files - 1;
#line 278
  while (0 <= last_relative) {
#line 279
    if (! ((int )*(*(file + last_relative) + 0) == 47)) {
#line 280
      break;
    }
#line 278
    last_relative --;
  }
#line 282
  while (i < last_relative) {
#line 284
    __cil_tmp___0 = savewd_delegating((struct savewd  const  *)(& wd));
#line 284
    if (! __cil_tmp___0) {
#line 286
      __cil_tmp = (*act)(*(file + i), & wd, options);
#line 286
      s = __cil_tmp;
#line 287
      if (exit_status < s) {
#line 288
        exit_status = s;
      }
    }
#line 291
    if (! ((int )*(*(file + (i + 1)) + 0) == 47)) {
#line 293
      __cil_tmp___1 = savewd_restore(& wd, exit_status);
#line 293
      r = __cil_tmp___1;
#line 294
      if (exit_status < r) {
#line 295
        exit_status = r;
      }
    }
#line 282
    i ++;
  }
#line 299
  savewd_finish(& wd);
#line 301
  while (i < n_files) {
#line 303
    __cil_tmp___2 = (*act)(*(file + i), & wd, options);
#line 303
    s___0 = __cil_tmp___2;
#line 304
    if (exit_status < s___0) {
#line 305
      exit_status = s___0;
    }
#line 301
    i ++;
  }
#line 308
  return (exit_status);
}
}
#line 1 "strnlen1.o"
#pragma merger(0,"/tmp/cil-EBQ7HAOU.i","-g,-O2")
#line 27 "strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ char const   *end ;
  void *__cil_tmp ;

  {
#line 30
  __cil_tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)__cil_tmp;
#line 31
  if ((unsigned int )end != (unsigned int )((void *)0)) {
#line 32
    return ((unsigned int )((end - string) + 1));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 1 "unicodeio.o"
#pragma merger(0,"/tmp/cil-ul8tjS81.i","-g,-O2")
#line 206 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern size_t fwrite(void const   * , size_t _size , size_t _n , FILE * ) ;
#line 30 "unicodeio.h"
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) ;
#line 40
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) ;
#line 45
long fwrite_success_callback(char const   *buf___0 , size_t buflen , void *callback_arg ) ;
#line 58 "unicodeio.c"
static int utf8_wctomb(unsigned char *r , unsigned int wc ) 
{ int count ;

  {
#line 63
  if (wc < 128U) {
#line 64
    count = 1;
  } else
#line 65
  if (wc < 2048U) {
#line 66
    count = 2;
  } else
#line 67
  if (wc < 65536U) {
#line 68
    count = 3;
  } else
#line 69
  if (wc < 2097152U) {
#line 70
    count = 4;
  } else
#line 71
  if (wc < 67108864U) {
#line 72
    count = 5;
  } else
#line 73
  if (wc <= 2147483647U) {
#line 74
    count = 6;
  } else {
#line 76
    return (-1);
  }
#line 78
  switch (count) {
  case 6: 
#line 81
  *(r + 5) = (unsigned char )(128U | (wc & 63U));
#line 81
  wc >>= 6;
#line 81
  wc |= 67108864U;
  case 5: 
#line 82
  *(r + 4) = (unsigned char )(128U | (wc & 63U));
#line 82
  wc >>= 6;
#line 82
  wc |= 2097152U;
  case 4: 
#line 83
  *(r + 3) = (unsigned char )(128U | (wc & 63U));
#line 83
  wc >>= 6;
#line 83
  wc |= 65536U;
  case 3: 
#line 84
  *(r + 2) = (unsigned char )(128U | (wc & 63U));
#line 84
  wc >>= 6;
#line 84
  wc |= 2048U;
  case 2: 
#line 85
  *(r + 1) = (unsigned char )(128U | (wc & 63U));
#line 85
  wc >>= 6;
#line 85
  wc |= 192U;
  case 1: 
#line 86
  *(r + 0) = (unsigned char )wc;
  }
#line 89
  return (count);
}
}
#line 109 "unicodeio.c"
static int initialized  ;
#line 110 "unicodeio.c"
static int is_utf8  ;
#line 101 "unicodeio.c"
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) 
{ char inbuf[6] ;
  int count ;
  char const   *charset ;
  char const   *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  long __cil_tmp___2 ;
  long __cil_tmp___3 ;
  long __cil_tmp___4 ;

  {
#line 118
  if (! initialized) {
#line 120
    __cil_tmp = locale_charset();
#line 120
    charset = __cil_tmp;
#line 122
    __cil_tmp___0 = strcmp(charset, "UTF-8");
#line 122
    if (__cil_tmp___0) {
#line 122
      __cil_tmp___1 = 0;
    } else {
#line 122
      __cil_tmp___1 = 1;
    }
#line 122
    is_utf8 = __cil_tmp___1;
#line 132
    initialized = 1;
  }
#line 136
  if (! is_utf8) {
#line 142
    __cil_tmp___2 = (*failure)(code, "iconv function not available", callback_arg);
#line 142
    return (__cil_tmp___2);
  }
#line 147
  count = utf8_wctomb((unsigned char *)(inbuf), code);
#line 148
  if (count < 0) {
#line 149
    __cil_tmp___3 = (*failure)(code, "character out of range", callback_arg);
#line 149
    return (__cil_tmp___3);
  }
#line 193
  __cil_tmp___4 = (*success)((char const   *)(inbuf), (unsigned int )count, callback_arg);
#line 193
  return (__cil_tmp___4);
}
}
#line 198 "unicodeio.c"
long fwrite_success_callback(char const   *buf___0 , size_t buflen , void *callback_arg ) 
{ FILE *stream ;

  {
#line 201
  stream = (FILE *)callback_arg;
#line 203
  fwrite((void const   *)buf___0, 1U, buflen, stream);
#line 204
  return (0L);
}
}
#line 208 "unicodeio.c"
static long exit_failure_callback(unsigned int code , char const   *msg , void *callback_arg ) 
{ 

  {
#line 211
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 212
    error(1, 0, "cannot convert U+%04X to local character set", code);
  } else {
#line 214
    error(1, 0, "cannot convert U+%04X to local character set: %s", code, msg);
  }
#line 216
  return (-1L);
}
}
#line 221 "unicodeio.c"
static long fallback_failure_callback(unsigned int code , char const   *msg , void *callback_arg ) 
{ FILE *stream ;

  {
#line 224
  stream = (FILE *)callback_arg;
#line 226
  if (code < 65536U) {
#line 227
    fprintf(stream, "\\u%04X", code);
  } else {
#line 229
    fprintf(stream, "\\U%08X", code);
  }
#line 230
  return (-1L);
}
}
#line 236 "unicodeio.c"
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) 
{ 

  {
#line 239
  unicode_to_mb(code, & fwrite_success_callback, exit_on_error ? & exit_failure_callback : & fallback_failure_callback,
                (void *)stream);
#line 244
  return;
}
}
#line 1 "width.o"
#pragma merger(0,"/tmp/cil-KxGvLjgp.i","-g,-O2")
#line 41 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding ) ;
#line 22 "uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;

  {
#line 25
  __cil_tmp = strcmp(encoding, "EUC-JP");
#line 25
  if (__cil_tmp == 0) {
#line 37
    return (1);
  } else {
#line 25
    __cil_tmp___0 = strcmp(encoding, "GB2312");
#line 25
    if (__cil_tmp___0 == 0) {
#line 37
      return (1);
    } else {
#line 25
      __cil_tmp___1 = strcmp(encoding, "GBK");
#line 25
      if (__cil_tmp___1 == 0) {
#line 37
        return (1);
      } else {
#line 25
        __cil_tmp___2 = strcmp(encoding, "EUC-TW");
#line 25
        if (__cil_tmp___2 == 0) {
#line 37
          return (1);
        } else {
#line 25
          __cil_tmp___3 = strcmp(encoding, "BIG5");
#line 25
          if (__cil_tmp___3 == 0) {
#line 37
            return (1);
          } else {
#line 25
            __cil_tmp___4 = strcmp(encoding, "EUC-KR");
#line 25
            if (__cil_tmp___4 == 0) {
#line 37
              return (1);
            } else {
#line 25
              __cil_tmp___5 = strcmp(encoding, "CP949");
#line 25
              if (__cil_tmp___5 == 0) {
#line 37
                return (1);
              } else {
#line 25
                __cil_tmp___6 = strcmp(encoding, "JOHAB");
#line 25
                if (__cil_tmp___6 == 0) {
#line 37
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 38
  return (0);
}
}
#line 37 "uniwidth/width.c"
static unsigned char const   nonspacing_table_data[1408]  = 
#line 37 "uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )120,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )255, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )14,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )14,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )197,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )56,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )15,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )252,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 237 "uniwidth/width.c"
static signed char const   nonspacing_table_ind[240]  = 
#line 237
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )15,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )17,      (signed char const   )-1,      (signed char const   )18, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )20,      (signed char const   )21,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 271 "uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ int ind ;
  int __cil_tmp ;

  {
#line 275
  if (uc >> 9 < 240U) {
#line 277
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 278
    if (ind >= 0) {
#line 279
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 281
        if (uc > 0U && uc < 160U) {
#line 282
          return (-1);
        } else {
#line 284
          return (0);
        }
      }
    }
  } else
#line 287
  if (uc >> 9 == (unsigned int )(917504 >> 9)) {
#line 289
    if (uc >= 917760U) {
#line 291
      if (uc <= 917999U) {
#line 292
        return (0);
      }
    } else
#line 296
    if (uc >= 917536U ? uc <= 917631U : uc == 917505U) {
#line 297
      return (0);
    }
  }
#line 304
  if (uc >= 4352U && ((((((((((uc < 4448U || (uc >= 9001U && uc < 9003U)) || (((uc >= 11904U && uc < 42192U) && ! (uc == 12351U)) && ! (uc >= 19904U && uc < 19968U))) || (uc >= 44032U && uc < 55204U)) || (uc >= 63744U && uc < 64256U)) || (uc >= 65040U && uc < 65056U)) || (uc >= 65072U && uc < 65136U)) || (uc >= 65280U && uc < 65377U)) || (uc >= 65504U && uc < 65511U)) || (uc >= 131072U && uc <= 173782U)) || (uc >= 194560U && uc <= 195101U))) {
#line 318
    return (2);
  }
#line 321
  if ((uc >= 161U && uc < 65377U) && uc != 8361U) {
#line 321
    __cil_tmp = is_cjk_encoding(encoding);
#line 321
    if (__cil_tmp) {
#line 323
      return (2);
    }
  }
#line 324
  return (1);
}
}
#line 1 "version-etc.o"
#pragma merger(0,"/tmp/cil-C4xHszTf.i","-g,-O2")
#line 117 "./stdio.h"
int rpl_vfprintf(FILE *fp , char const   *format , va_list args ) ;
#line 25 "version-etc.h"
char const   version_etc_copyright[47] ;
#line 27
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 39 "version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ size_t n_authors ;
  va_list tmp_authors ;
  char const   *__cil_tmp ;

  {
#line 50
  __builtin_va_copy(tmp_authors, authors);
#line 52
  n_authors = 0U;
#line 53
  while (1) {
#line 53
    __cil_tmp = __builtin_va_arg(tmp_authors, char const   *);
#line 53
    if (! ((unsigned int )__cil_tmp != (unsigned int )((void *)0))) {
#line 53
      break;
    }
#line 54
    n_authors ++;
  }
#line 57
  if (command_name) {
#line 58
    fprintf(stream, "%s (%s) %s\n", command_name, package, version);
  } else {
#line 60
    fprintf(stream, "%s %s\n", package, version);
  }
#line 65
  fprintf(stream, version_etc_copyright, "(C)", 2008);
#line 67
  fputs("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n",
        stream);
#line 76
  switch ((int )n_authors) {
  case 0: 
#line 80
  abort();
  case 1: 
#line 83
  rpl_vfprintf(stream, "Written by %s.\n", authors);
#line 84
  break;
  case 2: 
#line 87
  rpl_vfprintf(stream, "Written by %s and %s.\n", authors);
#line 88
  break;
  case 3: 
#line 91
  rpl_vfprintf(stream, "Written by %s, %s, and %s.\n", authors);
#line 92
  break;
  case 4: 
#line 97
  rpl_vfprintf(stream, "Written by %s, %s, %s,\nand %s.\n", authors);
#line 98
  break;
  case 5: 
#line 103
  rpl_vfprintf(stream, "Written by %s, %s, %s,\n%s, and %s.\n", authors);
#line 104
  break;
  case 6: 
#line 109
  rpl_vfprintf(stream, "Written by %s, %s, %s,\n%s, %s, and %s.\n", authors);
#line 111
  break;
  case 7: 
#line 116
  rpl_vfprintf(stream, "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n", authors);
#line 118
  break;
  case 8: 
#line 123
  rpl_vfprintf(stream, "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n", authors);
#line 126
  break;
  case 9: 
#line 131
  rpl_vfprintf(stream, "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n", authors);
#line 134
  break;
  default: 
#line 141
  rpl_vfprintf(stream, "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n",
               authors);
#line 144
  break;
  }
#line 146
  __builtin_va_end(authors);
#line 147
  return;
}
}
#line 163 "version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ va_list authors ;

  {
#line 170
  __builtin_va_start(authors, version);
#line 171
  version_etc_va(stream, command_name, package, version, authors);
#line 172
  return;
}
}
#line 1 "version-etc-fsf.o"
#pragma merger(0,"/tmp/cil-MScU3ZyB.i","-g,-O2")
#line 26 "version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 1 "xalloc-die.o"
#pragma merger(0,"/tmp/cil-tdzGgsNe.i","-g,-O2")
#line 30 "xalloc-die.c"
extern void __otter_xalloc_die_failure(void) ;
#line 31 "xalloc-die.c"
void xalloc_die(void) 
{ 

  {
#line 34
  __otter_xalloc_die_failure();
#line 34
  error((int )exit_failure, 0, "%s", "memory exhausted");
#line 40
  abort();
#line 41
  return;
}
}
#line 1 "xgethostname.o"
#pragma merger(0,"/tmp/cil-uTDdQDeF.i","-g,-O2")
#line 1 "xgethostname.h"
char *xgethostname(void) ;
#line 61 "xgethostname.c"
int gethostname(char *name , size_t len ) ;
#line 43 "xgethostname.c"
char *xgethostname(void) 
{ char *hostname ;
  size_t size ;
  size_t size_1 ;
  void *__cil_tmp ;
  int *__cil_tmp___0 ;
  int saved_errno ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int __cil_tmp___7 ;

  {
#line 46
  hostname = (char *)((void *)0);
#line 47
  size = 34U;
#line 49
  while (1) {
#line 56
    __cil_tmp = x2realloc((void *)hostname, & size);
#line 56
    hostname = (char *)__cil_tmp;
#line 57
    size_1 = size - 1U;
#line 58
    *(hostname + (size_1 - 1U)) = (char )'\000';
#line 59
    __cil_tmp___0 = __errno();
#line 59
    *__cil_tmp___0 = 0;
#line 61
    __cil_tmp___7 = gethostname(hostname, size_1);
#line 61
    if (__cil_tmp___7 == 0) {
#line 63
      if (! *(hostname + (size_1 - 1U))) {
#line 64
        break;
      }
    } else {
#line 66
      __cil_tmp___3 = __errno();
#line 66
      if (*__cil_tmp___3 != 0) {
#line 66
        __cil_tmp___4 = __errno();
#line 66
        if (*__cil_tmp___4 != 91) {
#line 66
          __cil_tmp___5 = __errno();
#line 66
          if (*__cil_tmp___5 != 22) {
#line 66
            __cil_tmp___6 = __errno();
#line 66
            if (*__cil_tmp___6 != 12) {
#line 70
              __cil_tmp___1 = __errno();
#line 70
              saved_errno = *__cil_tmp___1;
#line 71
              free((void *)hostname);
#line 72
              __cil_tmp___2 = __errno();
#line 72
              *__cil_tmp___2 = saved_errno;
#line 73
              return ((char *)((void *)0));
            }
          }
        }
      }
    }
  }
#line 77
  return (hostname);
}
}
#line 1 "xmemcoll.o"
#pragma merger(0,"/tmp/cil-B11AOC9Y.i","-g,-O2")
#line 25 "memcoll.h"
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
#line 124 "quotearg.h"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 2 "xmemcoll.h"
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
#line 40 "xmemcoll.c"
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ int diff ;
  int __cil_tmp ;
  int collation_errno ;
  int *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;

  {
#line 43
  __cil_tmp = memcoll(s1, s1len, s2, s2len);
#line 43
  diff = __cil_tmp;
#line 44
  __cil_tmp___0 = __errno();
#line 44
  collation_errno = *__cil_tmp___0;
#line 46
  if (collation_errno) {
#line 48
    error(0, collation_errno, "string comparison failed");
#line 49
    error(0, 0, "Set LC_ALL=\'C\' to work around the problem.");
#line 50
    __cil_tmp___1 = quotearg_n_style_mem(1, (enum quoting_style )5, (char const   *)s2,
                                         s2len);
#line 50
    __cil_tmp___2 = quotearg_n_style_mem(0, (enum quoting_style )5, (char const   *)s1,
                                         s1len);
#line 50
    error((int )exit_failure, 0, "The strings compared were %s and %s.", __cil_tmp___2,
          __cil_tmp___1);
  }
#line 56
  return (diff);
}
}
#line 1 "xprintf.o"
#pragma merger(0,"/tmp/cil-KCCeePJ6.i","-g,-O2")
#line 155 "./stdio.h"
int rpl_vprintf(char const   *format , va_list args ) ;
#line 36 "xprintf.h"
int xprintf(char const   * __restrict  format  , ...) ;
#line 38
int xvprintf(char const   * __restrict  format , va_list args ) ;
#line 40
int xfprintf(FILE * __restrict  stream , char const   * __restrict  format  , ...) ;
#line 42
int xvfprintf(FILE * __restrict  stream , char const   * __restrict  format , va_list args ) ;
#line 31 "xprintf.c"
int xprintf(char const   * __restrict  format  , ...) 
{ va_list args ;
  int retval ;

  {
#line 36
  __builtin_va_start(args, format);
#line 37
  retval = xvprintf(format, args);
#line 38
  __builtin_va_end(args);
#line 40
  return (retval);
}
}
#line 45 "xprintf.c"
int xvprintf(char const   * __restrict  format , va_list args ) 
{ int retval ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 48
  __cil_tmp = rpl_vprintf((char const   *)format, args);
#line 48
  retval = __cil_tmp;
#line 49
  if (retval < 0) {
#line 49
    __cil_tmp___1 = ferror(_impure_ptr->_stdout);
#line 49
    if (! __cil_tmp___1) {
#line 50
      __cil_tmp___0 = __errno();
#line 50
      error((int )exit_failure, *__cil_tmp___0, "cannot perform formatted output");
    }
  }
#line 52
  return (retval);
}
}
#line 57 "xprintf.c"
int xfprintf(FILE * __restrict  stream , char const   * __restrict  format  , ...) 
{ va_list args ;
  int retval ;

  {
#line 62
  __builtin_va_start(args, format);
#line 63
  retval = xvfprintf(stream, format, args);
#line 64
  __builtin_va_end(args);
#line 66
  return (retval);
}
}
#line 71 "xprintf.c"
int xvfprintf(FILE * __restrict  stream , char const   * __restrict  format , va_list args ) 
{ int retval ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 74
  __cil_tmp = rpl_vfprintf((FILE *)stream, (char const   *)format, args);
#line 74
  retval = __cil_tmp;
#line 75
  if (retval < 0) {
#line 75
    __cil_tmp___1 = ferror((FILE *)stream);
#line 75
    if (! __cil_tmp___1) {
#line 76
      __cil_tmp___0 = __errno();
#line 76
      error((int )exit_failure, *__cil_tmp___0, "cannot perform formatted output");
    }
  }
#line 78
  return (retval);
}
}
#line 1 "xstrndup.o"
#pragma merger(0,"/tmp/cil-RaPCszGK.i","-g,-O2")
#line 23 "xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 67 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strndup(char const   * , size_t  ) ;
#line 29 "xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ char *s ;
  char *__cil_tmp ;

  {
#line 32
  __cil_tmp = strndup(string, n);
#line 32
  s = __cil_tmp;
#line 33
  if (! s) {
#line 34
    xalloc_die();
  }
#line 35
  return (s);
}
}
#line 1 "xstrtoimax.o"
#pragma merger(0,"/tmp/cil-sNs3zINp.i","-g,-O2")
#line 6 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/inttypes.h"
extern long long strtoimax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                           int base ) ;
#line 46 "xstrtol.h"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , long long *val ,
                        char const   *valid_suffixes ) ;
#line 28 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strchr(char const   * , int  ) ;
#line 46 "xstrtol.c"
static strtol_error bkm_scale(long long *x , int scale_factor ) 
{ 

  {
#line 49
  if (*x < (-1LL << 63) / (long long )scale_factor) {
#line 51
    *x = -1LL << 63;
#line 52
    return ((enum strtol_error )1);
  }
#line 54
  if (9223372036854775807LL / (long long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807LL;
#line 57
    return ((enum strtol_error )1);
  }
#line 59
  *x *= (long long )scale_factor;
#line 60
  return ((enum strtol_error )0);
}
}
#line 63 "xstrtol.c"
static strtol_error bkm_scale_by_power(long long *x , int base , int power ) 
{ strtol_error err ;
  strtol_error __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 66
  err = (enum strtol_error )0;
#line 67
  while (1) {
#line 67
    __cil_tmp___0 = power;
#line 67
    power --;
#line 67
    if (! __cil_tmp___0) {
#line 67
      break;
    }
#line 68
    __cil_tmp = bkm_scale(x, base);
#line 68
    err = (enum strtol_error )((unsigned int )err | (unsigned int )__cil_tmp);
  }
#line 69
  return (err);
}
}
#line 74 "xstrtol.c"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , long long *val ,
                        char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  long long tmp ;
  strtol_error err ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;

  {
#line 81
  err = (enum strtol_error )0;
#line 83
  if ((0 <= strtol_base && strtol_base <= 36) == 0) {
#line 83
    __libc_failwith((char *)"Assertion failed: 0 <= strtol_base && strtol_base <= 36 at xstrtol.c:83");
  }
#line 85
  p = ptr ? ptr : & t_ptr;
#line 97
  __cil_tmp = __errno();
#line 97
  *__cil_tmp = 0;
#line 98
  tmp = strtoimax((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned int )*p == (unsigned int )s) {
#line 104
    if (valid_suffixes && *(*p)) {
#line 104
      __cil_tmp___0 = strchr(valid_suffixes, (int )*(*p));
#line 104
      if (__cil_tmp___0) {
#line 105
        tmp = 1LL;
      } else {
#line 107
        return ((enum strtol_error )4);
      }
    } else {
#line 107
      return ((enum strtol_error )4);
    }
  } else {
#line 109
    __cil_tmp___2 = __errno();
#line 109
    if (*__cil_tmp___2 != 0) {
#line 111
      __cil_tmp___1 = __errno();
#line 111
      if (*__cil_tmp___1 != 34) {
#line 112
        return ((enum strtol_error )4);
      }
#line 113
      err = (enum strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    __cil_tmp___3 = strchr(valid_suffixes, (int )*(*p));
#line 131
    if (! __cil_tmp___3) {
#line 133
      *val = tmp;
#line 134
      return ((enum strtol_error )((unsigned int )err | 2U));
    }
#line 137
    __cil_tmp___4 = strchr(valid_suffixes, '0');
#line 137
    if (__cil_tmp___4) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 66: 
      case 68: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (enum strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power(& tmp, base, 6);
#line 177
    break;
    case 71: 
    case 103: 
#line 181
    overflow = bkm_scale_by_power(& tmp, base, 3);
#line 182
    break;
    case 107: 
    case 75: 
#line 186
    overflow = bkm_scale_by_power(& tmp, base, 1);
#line 187
    break;
    case 77: 
    case 109: 
#line 191
    overflow = bkm_scale_by_power(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power(& tmp, base, 5);
#line 196
    break;
    case 84: 
    case 116: 
#line 200
    overflow = bkm_scale_by_power(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((enum strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (enum strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (enum strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "xstrtoumax.o"
#pragma merger(0,"/tmp/cil-4tlF4jdD.i","-g,-O2")
#line 7 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/inttypes.h"
extern unsigned long long strtoumax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                    int base ) ;
#line 46 "xstrtol.c"
static strtol_error bkm_scale___0(unsigned long long *x , int scale_factor ) 
{ 

  {
#line 54
  if (0xffffffffffffffffULL / (unsigned long long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffULL;
#line 57
    return ((enum strtol_error )1);
  }
#line 59
  *x *= (unsigned long long )scale_factor;
#line 60
  return ((enum strtol_error )0);
}
}
#line 63 "xstrtol.c"
static strtol_error bkm_scale_by_power___0(unsigned long long *x , int base , int power ) 
{ strtol_error err ;
  strtol_error __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 66
  err = (enum strtol_error )0;
#line 67
  while (1) {
#line 67
    __cil_tmp___0 = power;
#line 67
    power --;
#line 67
    if (! __cil_tmp___0) {
#line 67
      break;
    }
#line 68
    __cil_tmp = bkm_scale___0(x, base);
#line 68
    err = (enum strtol_error )((unsigned int )err | (unsigned int )__cil_tmp);
  }
#line 69
  return (err);
}
}
#line 74 "xstrtol.c"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , unsigned long long *val ,
                        char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  unsigned long long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;

  {
#line 81
  err = (enum strtol_error )0;
#line 83
  if ((0 <= strtol_base && strtol_base <= 36) == 0) {
#line 83
    __libc_failwith((char *)"Assertion failed: 0 <= strtol_base && strtol_base <= 36 at xstrtol.c:83");
  }
#line 85
  p = ptr ? ptr : & t_ptr;
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
#line 91
  while ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )ch))) + (int )ch) & 8) {
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((enum strtol_error )4);
  }
#line 97
  __cil_tmp = __errno();
#line 97
  *__cil_tmp = 0;
#line 98
  tmp = strtoumax((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned int )*p == (unsigned int )s) {
#line 104
    if (valid_suffixes && *(*p)) {
#line 104
      __cil_tmp___0 = strchr(valid_suffixes, (int )*(*p));
#line 104
      if (__cil_tmp___0) {
#line 105
        tmp = 1ULL;
      } else {
#line 107
        return ((enum strtol_error )4);
      }
    } else {
#line 107
      return ((enum strtol_error )4);
    }
  } else {
#line 109
    __cil_tmp___2 = __errno();
#line 109
    if (*__cil_tmp___2 != 0) {
#line 111
      __cil_tmp___1 = __errno();
#line 111
      if (*__cil_tmp___1 != 34) {
#line 112
        return ((enum strtol_error )4);
      }
#line 113
      err = (enum strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    __cil_tmp___3 = strchr(valid_suffixes, (int )*(*p));
#line 131
    if (! __cil_tmp___3) {
#line 133
      *val = tmp;
#line 134
      return ((enum strtol_error )((unsigned int )err | 2U));
    }
#line 137
    __cil_tmp___4 = strchr(valid_suffixes, '0');
#line 137
    if (__cil_tmp___4) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 66: 
      case 68: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___0(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___0(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (enum strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
#line 177
    break;
    case 71: 
    case 103: 
#line 181
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
#line 182
    break;
    case 107: 
    case 75: 
#line 186
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
#line 187
    break;
    case 77: 
    case 109: 
#line 191
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
#line 196
    break;
    case 84: 
    case 116: 
#line 200
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___0(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((enum strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (enum strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (enum strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "buffer-lcm.o"
#pragma merger(0,"/tmp/cil-EmXNnhHM.i","-g,-O2")
#line 2 "buffer-lcm.h"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) ;
#line 26 "buffer-lcm.c"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) 
{ size_t size ;
  size_t lcm ;
  size_t m ;
  size_t n ;
  size_t q ;
  size_t r ;

  {
#line 32
  if (! a) {
#line 33
    size = b ? b : 8192U;
  } else {
#line 36
    if (b) {
#line 44
      m = a;
#line 44
      n = b;
#line 44
      while (1) {
#line 44
        r = m % n;
#line 44
        if (! (r != 0U)) {
#line 44
          break;
        }
#line 45
        goto __Cont;
        __Cont: 
#line 44
        m = n;
#line 44
        n = r;
      }
#line 48
      q = a / n;
#line 49
      lcm = q * b;
#line 50
      if (lcm <= lcm_max && lcm / b == q) {
#line 51
        return (lcm);
      }
    }
#line 54
    size = a;
  }
#line 57
  return (size <= lcm_max ? size : lcm_max);
}
}
#line 1 "xmemxfrm.o"
#pragma merger(0,"/tmp/cil-OArZe6hP.i","-g,-O2")
#line 2 "xmemxfrm.h"
size_t xmemxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
                size_t srcsize ) ;
#line 2 "memxfrm.h"
size_t memxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
               size_t srcsize ) ;
#line 46 "xmemxfrm.c"
size_t xmemxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
                size_t srcsize ) 
{ size_t translated_size ;
  size_t __cil_tmp ;
  int *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 50
  __cil_tmp = memxfrm(dest, destsize, src, srcsize);
#line 50
  translated_size = __cil_tmp;
#line 52
  __cil_tmp___2 = __errno();
#line 52
  if (*__cil_tmp___2) {
#line 54
    __cil_tmp___0 = __errno();
#line 54
    error(0, *__cil_tmp___0, "string transformation failed");
#line 55
    error(0, 0, "Set LC_ALL=\'C\' to work around the problem.");
#line 56
    __cil_tmp___1 = quotearg_n_style_mem(0, (enum quoting_style )5, (char const   *)src,
                                         srcsize);
#line 56
    error((int )exit_failure, 0, "The untransformed string was %s.", __cil_tmp___1);
  }
#line 61
  return (translated_size);
}
}
#line 1 "acl.o"
#pragma merger(0,"/tmp/cil-xKs7o8Qu.i","-g,-O2")
#line 82 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/stat.h"
extern int chmod(char const   *__path , mode_t __mode ) ;
#line 83
extern int fchmod(int __fildes , mode_t __mode ) ;
#line 32 "acl.h"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
#line 33
int set_acl(char const   *name , int desc , mode_t mode ) ;
#line 34
int qset_acl(char const   *name , int desc , mode_t mode ) ;
#line 35
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 31 "acl.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 34
  if (desc != -1) {
#line 35
    __cil_tmp = fchmod(desc, mode);
#line 35
    return (__cil_tmp);
  } else {
#line 37
    __cil_tmp___0 = chmod(name, mode);
#line 37
    return (__cil_tmp___0);
  }
}
}
#line 49 "acl.c"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ int ret ;
  char const   *__cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 163
  ret = qset_acl(dst_name, dest_desc, mode);
#line 164
  if (ret != 0) {
#line 165
    __cil_tmp = quote(dst_name);
#line 165
    __cil_tmp___0 = __errno();
#line 165
    error(0, *__cil_tmp___0, "preserving permissions for %s", __cil_tmp);
  }
#line 179
  return (ret);
}
}
#line 191 "acl.c"
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ int __cil_tmp ;

  {
#line 306
  __cil_tmp = chmod_or_fchmod(name, desc, mode);
#line 306
  return (__cil_tmp);
}
}
#line 313 "acl.c"
int set_acl(char const   *name , int desc , mode_t mode ) 
{ int r ;
  int __cil_tmp ;
  char const   *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 316
  __cil_tmp = qset_acl(name, desc, mode);
#line 316
  r = __cil_tmp;
#line 317
  if (r != 0) {
#line 318
    __cil_tmp___0 = quote(name);
#line 318
    __cil_tmp___1 = __errno();
#line 318
    error(0, *__cil_tmp___1, "setting permissions for %s", __cil_tmp___0);
  }
#line 319
  return (r);
}
}
#line 1 "argmatch.o"
#pragma merger(0,"/tmp/cil-U6kNQ1YA.i","-g,-O2")
#line 42 "argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
#line 52
void (*argmatch_die)(void) ;
#line 56
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 68
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 79
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 94
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 327 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int putc_unlocked(int  , FILE * ) ;
#line 119 "quotearg.h"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 20 "quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 60 "argmatch.c"
static void __argmatch_die(void) 
{ 

  {
#line 63
  usage(1);
#line 64
  return;
}
}
#line 68 "argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82 "argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int __cil_tmp ;
  size_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 88
  matchind = -1LL;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = 0U;
#line 94
  while (*(arglist + i)) {
#line 96
    __cil_tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
#line 96
    if (! __cil_tmp___1) {
#line 98
      __cil_tmp___0 = strlen((char const   *)*(arglist + i));
#line 98
      if (__cil_tmp___0 == arglen) {
#line 100
        return ((long long )i);
      } else
#line 101
      if (matchind == -1LL) {
#line 103
        matchind = (long long )i;
      } else
#line 107
      if ((unsigned int )vallist == (unsigned int )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
#line 107
        __cil_tmp = rpl_memcmp((void const   *)(vallist + (long long )valsize * matchind),
                               (void const   *)(vallist + valsize * i), valsize);
#line 107
        if (__cil_tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
#line 118
  if (ambiguous) {
#line 119
    return (-2LL);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ char const   *format ;
  char const   *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 132
  format = problem == -1LL ? "invalid argument %s for %s" : "ambiguous argument %s for %s";
#line 136
  __cil_tmp = quote_n(1, context);
#line 136
  __cil_tmp___0 = quotearg_n_style(0, (enum quoting_style )5, value);
#line 136
  error(0, 0, format, __cil_tmp___0, __cil_tmp);
#line 138
  return;
}
}
#line 144 "argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ size_t i ;
  char const   *last_val ;
  int __cil_tmp ;

  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  fprintf(_impure_ptr->_stderr, "Valid arguments are:");
#line 154
  i = 0U;
#line 154
  while (*(arglist + i)) {
#line 155
    if (i == 0U) {
#line 158
      fprintf(_impure_ptr->_stderr, "\n  - `%s\'", *(arglist + i));
#line 159
      last_val = vallist + valsize * i;
    } else {
#line 155
      __cil_tmp = rpl_memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                             valsize);
#line 155
      if (__cil_tmp) {
#line 158
        fprintf(_impure_ptr->_stderr, "\n  - `%s\'", *(arglist + i));
#line 159
        last_val = vallist + valsize * i;
      } else {
#line 163
        fprintf(_impure_ptr->_stderr, ", `%s\'", *(arglist + i));
      }
    }
#line 154
    i ++;
  }
#line 165
  putc_unlocked('\n', _impure_ptr->_stderr);
#line 166
  return;
}
}
#line 174 "argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ ptrdiff_t res ;
  ptrdiff_t __cil_tmp ;

  {
#line 180
  __cil_tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = __cil_tmp;
#line 181
  if (res >= 0LL) {
#line 183
    return (res);
  }
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
#line 190
  return (-1LL);
}
}
#line 195 "argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ size_t i ;
  int __cil_tmp ;

  {
#line 202
  i = 0U;
#line 202
  while (*(arglist + i)) {
#line 203
    __cil_tmp = rpl_memcmp((void const   *)value, (void const   *)(vallist + valsize * i),
                           valsize);
#line 203
    if (! __cil_tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 1 "asnprintf.o"
#pragma merger(0,"/tmp/cil-sEwRsUam.i","-g,-O2")
#line 74 "vasnprintf.h"
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) ;
#line 76
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) ;
#line 27 "asnprintf.c"
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) 
{ va_list args ;
  char *result ;

  {
#line 33
  __builtin_va_start(args, format);
#line 34
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 35
  __builtin_va_end(args);
#line 36
  return (result);
}
}
#line 1 "asprintf.o"
#pragma merger(0,"/tmp/cil-3KMy6p6g.i","-g,-O2")
#line 248 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
int asprintf(char **resultp , char const   *format  , ...) ;
#line 278
int vasprintf(char **resultp , char const   *format , va_list args ) ;
#line 31 "asprintf.c"
int asprintf(char **resultp , char const   *format  , ...) 
{ va_list args ;
  int result ;

  {
#line 37
  __builtin_va_start(args, format);
#line 38
  result = vasprintf(resultp, format, args);
#line 39
  __builtin_va_end(args);
#line 40
  return (result);
}
}
#line 1 "backupfile.o"
#pragma merger(0,"/tmp/cil-MgsAd2RB.i","-g,-O2")
#line 47 "backupfile.h"
char const   *simple_backup_suffix ;
#line 49
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) ;
#line 50
enum backup_type get_version(char const   *context , char const   *version ) ;
#line 51
enum backup_type xget_version(char const   *context , char const   *version ) ;
#line 63 "dirname.h"
size_t base_len(char const   *name ) ;
#line 65
char *last_component(char const   *name ) ;
#line 22 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/dirent.h"
extern DIR *opendir(char const   * ) ;
#line 23
extern struct dirent *readdir(DIR * ) ;
#line 25
extern int closedir(DIR * ) ;
#line 90 "backupfile.c"
char const   *simple_backup_suffix  =    "~";
#line 98 "backupfile.c"
static void check_extension(char *file , size_t filelen , char e ) 
{ char *base ;
  char *__cil_tmp ;
  size_t baselen ;
  size_t __cil_tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp[sizeof(".")] ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  long size ;
  int *__cil_tmp___4 ;

  {
#line 101
  __cil_tmp = last_component((char const   *)file);
#line 101
  base = __cil_tmp;
#line 102
  __cil_tmp___0 = base_len((char const   *)base);
#line 102
  baselen = __cil_tmp___0;
#line 103
  baselen_max = 255U;
#line 105
  if (14U < baselen) {
#line 113
    memcpy((void *)(tmp), (void const   *)base, sizeof("."));
#line 114
    strcpy(base, ".");
#line 115
    __cil_tmp___1 = __errno();
#line 115
    *__cil_tmp___1 = 0;
#line 116
    __cil_tmp___2 = __errno();
#line 116
    __cil_tmp___3 = -1;
#line 116
    *__cil_tmp___2 = __cil_tmp___3;
#line 116
    name_max = (long )__cil_tmp___3;
#line 117
    if (0L <= name_max) {
#line 117
      goto _L;
    } else {
#line 117
      __cil_tmp___4 = __errno();
#line 117
      if (*__cil_tmp___4 == 0) {
        _L: 
#line 119
        baselen_max = (unsigned int )name_max;
#line 119
        size = (long )baselen_max;
#line 120
        if (name_max != size) {
#line 121
          baselen_max = 4294967295U;
        }
      }
    }
#line 123
    memcpy((void *)base, (void const   *)(tmp), sizeof("."));
  }
#line 141
  if (baselen_max < baselen) {
#line 143
    baselen = (unsigned int )((file + filelen) - base);
#line 144
    if (baselen_max <= baselen) {
#line 145
      baselen = baselen_max - 1U;
    }
#line 146
    *(base + baselen) = e;
#line 147
    *(base + (baselen + 1U)) = (char )'\000';
  }
#line 149
  return;
}
}
#line 178 "backupfile.c"
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen ) 
{ enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___0 ;
  size_t versionlenmax ;
  char *base ;
  char *__cil_tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t __cil_tmp___0 ;
  char tmp[sizeof(".")] ;
  char const   *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  void *__cil_tmp___4 ;
  char *__cil_tmp___5 ;
  char *__cil_tmp___6 ;

  {
#line 181
  result = (enum numbered_backup_result )2;
#line 184
  buf___0 = *buffer;
#line 185
  versionlenmax = 1U;
#line 186
  __cil_tmp = last_component((char const   *)buf___0);
#line 186
  base = __cil_tmp;
#line 187
  base_offset = (unsigned int )(base - buf___0);
#line 188
  __cil_tmp___0 = base_len((char const   *)base);
#line 188
  baselen = __cil_tmp___0;
#line 193
  memcpy((void *)(tmp), (void const   *)base, sizeof("."));
#line 194
  strcpy(base, ".");
#line 195
  dirp = opendir((char const   *)buf___0);
#line 196
  memcpy((void *)base, (void const   *)(tmp), sizeof("."));
#line 197
  strcpy(base + baselen, ".~1~");
#line 199
  if (! dirp) {
#line 200
    return (result);
  }
#line 202
  while (1) {
#line 202
    dp = readdir(dirp);
#line 202
    if (! ((unsigned int )dp != (unsigned int )((void *)0))) {
#line 202
      break;
    }
#line 210
    __cil_tmp___1 = strlen((char const   *)(dp->d_name));
#line 210
    if (__cil_tmp___1 < baselen + 4U) {
#line 211
      continue;
    }
#line 213
    __cil_tmp___2 = rpl_memcmp((void const   *)(buf___0 + base_offset), (void const   *)(dp->d_name),
                               baselen + 2U);
#line 213
    if (__cil_tmp___2 != 0) {
#line 214
      continue;
    }
#line 216
    p = (char const   *)((dp->d_name + baselen) + 2);
#line 222
    if (! (49 <= (int )*p && (int const   )*p <= 57)) {
#line 223
      continue;
    }
#line 224
    all_9s = (_Bool )((int const   )*p == 57);
#line 225
    versionlen = 1U;
#line 225
    while ((unsigned int )*(p + versionlen) - 48U <= 9U) {
#line 226
      all_9s = (_Bool )((int )all_9s & ((int const   )*(p + versionlen) == 57));
#line 225
      versionlen ++;
    }
#line 228
    if ((int const   )*(p + versionlen) == 126 && ! *(p + (versionlen + 1U))) {
#line 228
      if (! (versionlenmax < versionlen)) {
#line 228
        if (versionlenmax == versionlen) {
#line 228
          __cil_tmp___3 = rpl_memcmp((void const   *)((buf___0 + filelen) + 2), (void const   *)p,
                                     versionlen);
#line 228
          if (! (__cil_tmp___3 <= 0)) {
#line 232
            continue;
          }
        } else {
#line 232
          continue;
        }
      }
    } else {
#line 232
      continue;
    }
#line 238
    versionlenmax = (unsigned int )all_9s + versionlen;
#line 239
    result = (enum numbered_backup_result )(all_9s ? 1 : 0);
#line 240
    new_buflen = ((filelen + 2U) + versionlenmax) + 1U;
#line 241
    if (buffer_size <= new_buflen) {
#line 243
      __cil_tmp___4 = xnrealloc((void *)buf___0, 2U, new_buflen);
#line 243
      buf___0 = (char *)__cil_tmp___4;
#line 244
      buffer_size = new_buflen * 2U;
    }
#line 246
    q = buf___0 + filelen;
#line 247
    __cil_tmp___5 = q;
#line 247
    q ++;
#line 247
    *__cil_tmp___5 = (char )'.';
#line 248
    __cil_tmp___6 = q;
#line 248
    q ++;
#line 248
    *__cil_tmp___6 = (char )'~';
#line 249
    *q = (char )'0';
#line 250
    q += (int )all_9s;
#line 251
    memcpy((void *)q, (void const   *)p, versionlen + 2U);
#line 255
    q += versionlen;
#line 256
    while (1) {
#line 256
      q --;
#line 256
      if (! ((int )*q == 57)) {
#line 256
        break;
      }
#line 257
      *q = (char )'0';
    }
#line 258
    *q = (char )((int )*q + 1);
  }
#line 261
  closedir(dirp);
#line 262
  *buffer = buf___0;
#line 263
  return (result);
}
}
#line 270 "backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) 
{ size_t filelen ;
  size_t __cil_tmp ;
  char *s ;
  size_t ssize ;
  _Bool simple ;
  size_t simple_backup_suffix_size ;
  size_t __cil_tmp___0 ;
  size_t backup_suffix_size_guess ;
  void *__cil_tmp___1 ;
  enum numbered_backup_result __cil_tmp___2 ;

  {
#line 273
  __cil_tmp = strlen(file);
#line 273
  filelen = __cil_tmp;
#line 276
  simple = (_Bool)1;
#line 280
  __cil_tmp___0 = strlen(simple_backup_suffix);
#line 280
  simple_backup_suffix_size = __cil_tmp___0 + 1U;
#line 281
  backup_suffix_size_guess = simple_backup_suffix_size;
#line 283
  if (backup_suffix_size_guess < 9U) {
#line 284
    backup_suffix_size_guess = 9U;
  }
#line 286
  ssize = (filelen + backup_suffix_size_guess) + 1U;
#line 287
  __cil_tmp___1 = xmalloc(ssize);
#line 287
  s = (char *)__cil_tmp___1;
#line 288
  memcpy((void *)s, (void const   *)file, filelen + 1U);
#line 290
  if ((unsigned int )backup_type != 1U) {
#line 291
    __cil_tmp___2 = numbered_backup(& s, ssize, filelen);
#line 291
    switch ((int )__cil_tmp___2) {
    case 0: 
#line 294
    return (s);
    case 1: 
#line 297
    simple = (_Bool)0;
#line 298
    break;
    case 2: 
#line 301
    simple = (_Bool )((unsigned int )backup_type == 2U);
#line 302
    break;
    }
  }
#line 305
  if (simple) {
#line 306
    memcpy((void *)(s + filelen), (void const   *)simple_backup_suffix, simple_backup_suffix_size);
  }
#line 307
  check_extension(s, filelen, (char )'~');
#line 308
  return (s);
}
}
#line 311 "backupfile.c"
static char const   * const  backup_args[9]  = 
#line 311
  {      (char const   * const  )"none",      (char const   * const  )"off",      (char const   * const  )"simple",      (char const   * const  )"never", 
        (char const   * const  )"existing",      (char const   * const  )"nil",      (char const   * const  )"numbered",      (char const   * const  )"t", 
        (char const   * const  )((void *)0)};
#line 322 "backupfile.c"
static enum backup_type  const  backup_types[8]  = 
#line 322
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 339 "backupfile.c"
enum backup_type get_version(char const   *context , char const   *version ) 
{ ptrdiff_t __cil_tmp ;

  {
#line 342
  if ((unsigned int )version == (unsigned int )((char const   *)0) || (int const   )*version == 0) {
#line 343
    return ((enum backup_type )2);
  } else {
#line 345
    __cil_tmp = __xargmatch_internal(context, version, backup_args, (char const   *)(backup_types),
                                     sizeof(backup_types[0]), argmatch_die);
#line 345
    return ((enum backup_type )backup_types[__cil_tmp]);
  }
}
}
#line 355 "backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version ) 
{ enum backup_type __cil_tmp ;
  char *__cil_tmp___0 ;
  enum backup_type __cil_tmp___1 ;

  {
#line 358
  if (version && *version) {
#line 359
    __cil_tmp = get_version(context, version);
#line 359
    return (__cil_tmp);
  } else {
#line 361
    __cil_tmp___0 = getenv("VERSION_CONTROL");
#line 361
    __cil_tmp___1 = get_version("$VERSION_CONTROL", (char const   *)__cil_tmp___0);
#line 361
    return (__cil_tmp___1);
  }
}
}
#line 1 "basename.o"
#pragma merger(0,"/tmp/cil-5yrB6gNj.i","-g,-O2")
#line 61 "dirname.h"
char *base_name(char const   *name ) ;
#line 31 "basename.c"
char *last_component(char const   *name ) 
{ char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 34
  base = name + 0;
#line 36
  saw_slash = (_Bool)0;
#line 38
  while ((int const   )*base == 47) {
#line 39
    base ++;
  }
#line 41
  p = base;
#line 41
  while (*p) {
#line 43
    if ((int const   )*p == 47) {
#line 44
      saw_slash = (_Bool)1;
    } else
#line 45
    if (saw_slash) {
#line 47
      base = p;
#line 48
      saw_slash = (_Bool)0;
    }
#line 41
    p ++;
  }
#line 52
  return ((char *)base);
}
}
#line 73 "basename.c"
char *base_name(char const   *name ) 
{ char const   *base ;
  char *__cil_tmp ;
  size_t length ;
  size_t __cil_tmp___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___3 ;

  {
#line 76
  __cil_tmp = last_component(name);
#line 76
  base = (char const   *)__cil_tmp;
#line 81
  if (! *base) {
#line 82
    __cil_tmp___0 = base_len(name);
#line 82
    __cil_tmp___1 = xstrndup(name, __cil_tmp___0);
#line 82
    return (__cil_tmp___1);
  }
#line 85
  length = base_len(base);
#line 86
  if ((int const   )*(base + length) == 47) {
#line 87
    length ++;
  }
#line 103
  __cil_tmp___3 = xstrndup(base, length);
#line 103
  return (__cil_tmp___3);
}
}
#line 110 "basename.c"
size_t base_len(char const   *name ) 
{ size_t len ;
  size_t prefix_len ;

  {
#line 114
  prefix_len = 0U;
#line 116
  len = strlen(name);
#line 116
  while (1U < len && (int const   )*(name + (len - 1U)) == 47) {
#line 117
    goto __Cont;
    __Cont: 
#line 116
    len --;
  }
#line 127
  return (len);
}
}
#line 1 "c-strtod.o"
#pragma merger(0,"/tmp/cil-67o6Sh2e.i","-g,-O2")
#line 1 "c-strtod.h"
double c_strtod(char const   *nptr , char **endptr ) ;
#line 126 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
double rpl_strtod(char const   *nptr , char **endptr ) ;
#line 46 "c-strtod.c"
double c_strtod(char const   *nptr , char **endptr ) 
{ double r ;
  char *saved_locale ;
  char *__cil_tmp ;

  {
#line 59
  __cil_tmp = setlocale(4, (char const   *)((void *)0));
#line 59
  saved_locale = __cil_tmp;
#line 61
  if (saved_locale) {
#line 63
    saved_locale = xstrdup((char const   *)saved_locale);
#line 64
    setlocale(4, "C");
  }
#line 67
  r = rpl_strtod(nptr, endptr);
#line 69
  if (saved_locale) {
#line 71
    setlocale(4, (char const   *)saved_locale);
#line 72
    free((void *)saved_locale);
  }
#line 77
  return (r);
}
}
#line 1 "c-strtold.o"
#pragma merger(0,"/tmp/cil-4TLxzGrV.i","-g,-O2")
#line 2 "c-strtod.h"
long double c_strtold(char const   *nptr , char **endptr ) ;
#line 46 "c-strtod.c"
long double c_strtold(char const   *nptr , char **endptr ) 
{ long double r ;
  char *saved_locale ;
  char *__cil_tmp ;
  double __cil_tmp___0 ;

  {
#line 59
  __cil_tmp = setlocale(4, (char const   *)((void *)0));
#line 59
  saved_locale = __cil_tmp;
#line 61
  if (saved_locale) {
#line 63
    saved_locale = xstrdup((char const   *)saved_locale);
#line 64
    setlocale(4, "C");
  }
#line 67
  __cil_tmp___0 = rpl_strtod(nptr, endptr);
#line 67
  r = (long double )__cil_tmp___0;
#line 69
  if (saved_locale) {
#line 71
    setlocale(4, (char const   *)saved_locale);
#line 72
    free((void *)saved_locale);
  }
#line 77
  return (r);
}
}
#line 1 "calloc.o"
#pragma merger(0,"/tmp/cil-7tmXvUN7.i","-g,-O2")
#line 78 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern void *calloc(size_t __nmemb , size_t __size ) ;
#line 38 "calloc.c"
void *rpl_calloc(size_t n , size_t s ) 
{ void *result ;
  size_t bytes ;
  int *__cil_tmp ;

  {
#line 44
  if (n == 0U || s == 0U) {
#line 46
    n = 1U;
#line 47
    s = 1U;
  } else {
#line 53
    bytes = n * s;
#line 54
    if (bytes / s != n) {
#line 56
      __cil_tmp = __errno();
#line 56
      *__cil_tmp = 12;
#line 57
      return ((void *)0);
    }
  }
#line 62
  result = calloc(n, s);
#line 69
  return (result);
}
}
#line 1 "canon-host.o"
#pragma merger(0,"/tmp/cil-19IHkznY.i","-g,-O2")
#line 23 "canon-host.h"
char *canon_host(char const   *host ) ;
#line 24
char *canon_host_r(char const   *host , int *cherror ) ;
#line 26
char const   *ch_strerror(void) ;
#line 65 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strdup(char const   * ) ;
#line 41 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netdb.h"
int h_errno  ;
#line 118 "getaddrinfo.h"
int getaddrinfo(char const   * __restrict  nodename , char const   * __restrict  servname ,
                struct addrinfo  const  * __restrict  hints___0 , struct addrinfo ** __restrict  res ) ;
#line 128
void freeaddrinfo(struct addrinfo *ai ) ;
#line 135
char const   *gai_strerror(int code ) ;
#line 29 "canon-host.c"
static int last_cherror  ;
#line 33 "canon-host.c"
char *canon_host(char const   *host ) 
{ char *__cil_tmp ;

  {
#line 36
  __cil_tmp = canon_host_r(host, & last_cherror);
#line 36
  return (__cil_tmp);
}
}
#line 64 "canon-host.c"
static struct addrinfo hints  ;
#line 60 "canon-host.c"
char *canon_host_r(char const   *host , int *cherror ) 
{ char *retval ;
  struct addrinfo *res ;
  int status ;

  {
#line 63
  retval = (char *)((void *)0);
#line 65
  res = (struct addrinfo *)((void *)0);
#line 68
  hints.ai_flags = 2;
#line 69
  status = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )((void *)0),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& res));
#line 70
  if (! status) {
#line 75
    retval = strdup(res->ai_canonname ? (char const   *)res->ai_canonname : host);
#line 76
    if (! retval && cherror) {
#line 77
      *cherror = -10;
    }
#line 78
    freeaddrinfo(res);
  } else
#line 80
  if (cherror) {
#line 81
    *cherror = status;
  }
#line 83
  return (retval);
}
}
#line 87 "canon-host.c"
char const   *ch_strerror(void) 
{ char const   *__cil_tmp ;

  {
#line 90
  __cil_tmp = gai_strerror(last_cherror);
#line 90
  return (__cil_tmp);
}
}
#line 1 "canonicalize.o"
#pragma merger(0,"/tmp/cil-whTzjk5d.i","-g,-O2")
#line 38 "canonicalize.h"
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) ;
#line 49
char *canonicalize_file_name(char const   *name ) ;
#line 25 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern void *memmove(void * , void const   * , size_t  ) ;
#line 85 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/stat.h"
extern int lstat(char const   *name , struct stat *s ) ;
#line 76 "hash.h"
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) ;
#line 80
void hash_free(Hash_table *table___0 ) ;
#line 17 "xgetcwd.h"
char *xgetcwd(void) ;
#line 57 "canonicalize.c"
char *canonicalize_file_name(char const   *name ) 
{ char *__cil_tmp ;

  {
#line 119
  __cil_tmp = canonicalize_filename_mode(name, (enum canonicalize_mode_t )0);
#line 119
  return (__cil_tmp);
}
}
#line 127 "canonicalize.c"
static _Bool seen_triple(Hash_table **ht___0 , char const   *filename , struct stat  const  *st ) 
{ size_t initial_capacity ;
  _Bool __cil_tmp ;

  {
#line 130
  if ((unsigned int )*ht___0 == (unsigned int )((void *)0)) {
#line 132
    initial_capacity = 7U;
#line 133
    *ht___0 = hash_initialize(initial_capacity, (Hash_tuning const   *)((void *)0),
                              & triple_hash, & triple_compare_ino_str, & triple_free);
#line 138
    if ((unsigned int )*ht___0 == (unsigned int )((void *)0)) {
#line 139
      xalloc_die();
    }
  }
#line 142
  __cil_tmp = seen_file((Hash_table const   *)*ht___0, filename, st);
#line 142
  if (__cil_tmp) {
#line 143
    return ((_Bool)1);
  }
#line 145
  record_file(*ht___0, filename, st);
#line 146
  return ((_Bool)0);
}
}
#line 154 "canonicalize.c"
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) 
{ char *rname ;
  char *dest ;
  char *extra_buf ;
  char const   *start ;
  char const   *end ;
  char const   *rname_limit ;
  size_t extra_len ;
  Hash_table *ht___0 ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  char *p ;
  void *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  struct stat st ;
  char *__cil_tmp___3 ;
  ptrdiff_t dest_offset ;
  size_t new_size ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  char *buf___0 ;
  size_t n ;
  size_t len ;
  int *__cil_tmp___7 ;
  _Bool __cil_tmp___8 ;
  int *__cil_tmp___9 ;
  void *__cil_tmp___10 ;
  void *__cil_tmp___11 ;
  void *__cil_tmp___12 ;
  int *__cil_tmp___13 ;

  {
#line 157
  extra_buf = (char *)((void *)0);
#line 161
  extra_len = 0U;
#line 162
  ht___0 = (Hash_table *)((void *)0);
#line 164
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 166
    __cil_tmp = __errno();
#line 166
    *__cil_tmp = 22;
#line 167
    return ((char *)((void *)0));
  }
#line 170
  if ((int const   )*(name + 0) == 0) {
#line 172
    __cil_tmp___0 = __errno();
#line 172
    *__cil_tmp___0 = 2;
#line 173
    return ((char *)((void *)0));
  }
#line 176
  if ((int const   )*(name + 0) != 47) {
#line 178
    rname = xgetcwd();
#line 179
    if (! rname) {
#line 180
      return ((char *)((void *)0));
    }
#line 181
    dest = strchr((char const   *)rname, '\000');
#line 182
    if (dest - rname < 4096) {
#line 184
      __cil_tmp___1 = xrealloc((void *)rname, 4096U);
#line 184
      p = (char *)__cil_tmp___1;
#line 185
      dest = p + (dest - rname);
#line 186
      rname = p;
#line 187
      rname_limit = (char const   *)(rname + 4096);
    } else {
#line 191
      rname_limit = (char const   *)dest;
    }
  } else {
#line 196
    __cil_tmp___2 = xmalloc(4096U);
#line 196
    rname = (char *)__cil_tmp___2;
#line 197
    rname_limit = (char const   *)(rname + 4096);
#line 198
    *(rname + 0) = (char )'/';
#line 199
    dest = rname + 1;
  }
#line 202
  end = name;
#line 202
  start = end;
#line 202
  while (*start) {
#line 205
    while ((int const   )*start == 47) {
#line 206
      start ++;
    }
#line 209
    end = start;
#line 209
    while (*end && (int const   )*end != 47) {
#line 209
      end ++;
    }
#line 212
    if (end - start == 0) {
#line 213
      break;
    } else
#line 214
    if (! (end - start == 1 && (int const   )*(start + 0) == 46)) {
#line 216
      if ((end - start == 2 && (int const   )*(start + 0) == 46) && (int const   )*(start + 1) == 46) {
#line 219
        if ((unsigned int )dest > (unsigned int )(rname + 1)) {
#line 220
          while (1) {
#line 220
            dest --;
#line 220
            if (! ((int )*(dest + -1) != 47)) {
#line 220
              break;
            }
          }
        }
      } else {
#line 226
        if ((int )*(dest + -1) != 47) {
#line 227
          __cil_tmp___3 = dest;
#line 227
          dest ++;
#line 227
          *__cil_tmp___3 = (char )'/';
        }
#line 229
        if ((unsigned int )(dest + (end - start)) >= (unsigned int )rname_limit) {
#line 231
          dest_offset = (long long )(dest - rname);
#line 232
          new_size = (unsigned int )(rname_limit - (char const   *)rname);
#line 234
          if ((end - start) + 1 > 4096) {
#line 235
            new_size += (unsigned int )((end - start) + 1);
          } else {
#line 237
            new_size += 4096U;
          }
#line 238
          __cil_tmp___4 = xrealloc((void *)rname, new_size);
#line 238
          rname = (char *)__cil_tmp___4;
#line 239
          rname_limit = (char const   *)(rname + new_size);
#line 241
          dest = rname + dest_offset;
        }
#line 244
        __cil_tmp___5 = memcpy((void *)dest, (void const   *)start, (unsigned int )(end - start));
#line 244
        dest = (char *)__cil_tmp___5;
#line 245
        dest += end - start;
#line 246
        *dest = (char )'\000';
#line 248
        __cil_tmp___6 = lstat((char const   *)rname, & st);
#line 248
        if (__cil_tmp___6 != 0) {
#line 250
          if ((unsigned int )can_mode == 0U) {
#line 251
            goto error;
          }
#line 252
          if ((unsigned int )can_mode == 1U && *end) {
#line 253
            goto error;
          }
#line 254
          st.st_mode = 0U;
        }
#line 257
        if ((st.st_mode & 8323072U) == 2097152U) {
#line 266
          __cil_tmp___8 = seen_triple(& ht___0, name, (struct stat  const  *)(& st));
#line 266
          if (__cil_tmp___8) {
#line 268
            __cil_tmp___7 = __errno();
#line 268
            *__cil_tmp___7 = 92;
#line 269
            if ((unsigned int )can_mode == 2U) {
#line 270
              goto __Cont;
            } else {
#line 272
              goto error;
            }
          }
#line 275
          buf___0 = areadlink_with_size((char const   *)rname, (unsigned int )st.st_size);
#line 276
          if (! buf___0) {
#line 278
            if ((unsigned int )can_mode == 2U) {
#line 278
              __cil_tmp___9 = __errno();
#line 278
              if (*__cil_tmp___9 != 12) {
#line 279
                goto __Cont;
              } else {
#line 281
                goto error;
              }
            } else {
#line 281
              goto error;
            }
          }
#line 284
          n = strlen((char const   *)buf___0);
#line 285
          len = strlen(end);
#line 287
          if (! extra_len) {
#line 289
            extra_len = (n + len) + 1U > 4096U ? (n + len) + 1U : 4096U;
#line 291
            __cil_tmp___10 = xmalloc(extra_len);
#line 291
            extra_buf = (char *)__cil_tmp___10;
          } else
#line 293
          if ((n + len) + 1U > extra_len) {
#line 295
            extra_len = (n + len) + 1U;
#line 296
            __cil_tmp___11 = xrealloc((void *)extra_buf, extra_len);
#line 296
            extra_buf = (char *)__cil_tmp___11;
          }
#line 300
          memmove((void *)(extra_buf + n), (void const   *)end, len + 1U);
#line 301
          __cil_tmp___12 = memcpy((void *)extra_buf, (void const   *)buf___0, n);
#line 301
          end = (char const   *)__cil_tmp___12;
#line 301
          name = end;
#line 303
          if ((int )*(buf___0 + 0) == 47) {
#line 304
            dest = rname + 1;
          } else
#line 307
          if ((unsigned int )dest > (unsigned int )(rname + 1)) {
#line 308
            while (1) {
#line 308
              dest --;
#line 308
              if (! ((int )*(dest + -1) != 47)) {
#line 308
                break;
              }
            }
          }
#line 310
          free((void *)buf___0);
        } else
#line 314
        if ((! ((st.st_mode & 8323072U) == 1048576U) && *end) && (unsigned int )can_mode != 2U) {
#line 316
          __cil_tmp___13 = __errno();
#line 316
          *__cil_tmp___13 = 20;
#line 317
          goto error;
        }
      }
    }
    __Cont: 
#line 202
    start = end;
  }
#line 322
  if ((unsigned int )dest > (unsigned int )(rname + 1) && (int )*(dest + -1) == 47) {
#line 323
    dest --;
  }
#line 324
  *dest = (char )'\000';
#line 326
  free((void *)extra_buf);
#line 327
  if (ht___0) {
#line 328
    hash_free(ht___0);
  }
#line 329
  return (rname);
  error: 
#line 332
  free((void *)extra_buf);
#line 333
  free((void *)rname);
#line 334
  if (ht___0) {
#line 335
    hash_free(ht___0);
  }
#line 336
  return ((char *)((void *)0));
}
}
#line 1 "chdir-long.o"
#pragma merger(0,"/tmp/cil-OBbIN84n.i","-g,-O2")
#line 33 "chdir-long.h"
int chdir_long(char *dir ) ;
#line 40 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern size_t strspn(char const   * , char const   * ) ;
#line 116 "./string.h"
void *memrchr(void const   *s , int c_in , size_t n ) ;
#line 66 "openat.h"
int rpl_openat(int fd , char const   *file , int flags  , ...) ;
#line 42 "chdir-long.c"
__inline static void cdb_init(struct cd_buf *cdb ) 
{ 

  {
#line 45
  cdb->fd = -3041965;
#line 46
  return;
}
}
#line 48 "chdir-long.c"
__inline static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ int __cil_tmp ;

  {
#line 51
  __cil_tmp = fchdir(cdb->fd);
#line 51
  return (__cil_tmp);
}
}
#line 54 "chdir-long.c"
__inline static void cdb_free(struct cd_buf  const  *cdb ) 
{ _Bool close_fail ;
  int __cil_tmp ;

  {
#line 57
  if (0 <= (int )cdb->fd) {
#line 59
    __cil_tmp = close((int )cdb->fd);
#line 59
    close_fail = (_Bool )__cil_tmp;
#line 60
    if (! close_fail == 0) {
#line 60
      __libc_failwith((char *)"Assertion failed: ! close_fail at chdir-long.c:60");
    }
  }
#line 62
  return;
}
}
#line 68 "chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ int new_fd ;
  int __cil_tmp ;

  {
#line 71
  __cil_tmp = rpl_openat(cdb->fd, dir, 145);
#line 71
  new_fd = __cil_tmp;
#line 73
  if (new_fd < 0) {
#line 74
    return (-1);
  }
#line 76
  cdb_free((struct cd_buf  const  *)cdb);
#line 77
  cdb->fd = new_fd;
#line 79
  return (0);
}
}
#line 83 "chdir-long.c"
__inline static char *find_non_slash(char const   *s ) 
{ size_t n_slash ;
  size_t __cil_tmp ;

  {
#line 86
  __cil_tmp = strspn(s, "/");
#line 86
  n_slash = __cil_tmp;
#line 87
  return ((char *)s + n_slash);
}
}
#line 105 "chdir-long.c"
int chdir_long(char *dir ) 
{ int e ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  size_t len ;
  size_t __cil_tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  int err___0 ;
  char *slash___0 ;
  void *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int saved_errno ;
  int *__cil_tmp___9 ;
  int *__cil_tmp___10 ;

  {
#line 108
  __cil_tmp = chdir((char const   *)dir);
#line 108
  e = __cil_tmp;
#line 109
  if (e == 0) {
#line 110
    return (e);
  } else {
#line 109
    __cil_tmp___0 = __errno();
#line 109
    if (*__cil_tmp___0 != 91) {
#line 110
      return (e);
    }
  }
#line 113
  __cil_tmp___1 = strlen((char const   *)dir);
#line 113
  len = __cil_tmp___1;
#line 114
  dir_end = dir + len;
#line 118
  cdb_init(& cdb);
#line 122
  if ((0U < len) == 0) {
#line 122
    __libc_failwith((char *)"Assertion failed: 0 < len at chdir-long.c:122");
  }
#line 123
  if ((4096U <= len) == 0) {
#line 123
    __libc_failwith((char *)"Assertion failed: PATH_MAX <= len at chdir-long.c:123");
  }
#line 126
  n_leading_slash = strspn((char const   *)dir, "/");
#line 133
  if (n_leading_slash == 2U) {
#line 138
    __cil_tmp___2 = memchr((void const   *)(dir + 3), '/', (unsigned int )(dir_end - (dir + 3)));
#line 138
    slash = (char *)__cil_tmp___2;
#line 139
    if ((unsigned int )slash == (unsigned int )((void *)0)) {
#line 141
      __cil_tmp___3 = __errno();
#line 141
      *__cil_tmp___3 = 91;
#line 142
      return (-1);
    }
#line 144
    *slash = (char )'\000';
#line 145
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 146
    *slash = (char )'/';
#line 147
    if (err != 0) {
#line 148
      goto Fail;
    }
#line 149
    dir = find_non_slash((char const   *)(slash + 1));
  } else
#line 151
  if (n_leading_slash) {
#line 153
    __cil_tmp___4 = cdb_advance_fd(& cdb, "/");
#line 153
    if (__cil_tmp___4 != 0) {
#line 154
      goto Fail;
    }
#line 155
    dir += n_leading_slash;
  }
#line 158
  if (((int )*dir != 47) == 0) {
#line 158
    __libc_failwith((char *)"Assertion failed: *dir != \'/\' at chdir-long.c:158");
  }
#line 159
  if (((unsigned int )dir <= (unsigned int )dir_end) == 0) {
#line 159
    __libc_failwith((char *)"Assertion failed: dir <= dir_end at chdir-long.c:159");
  }
#line 161
  while (4096 <= dir_end - dir) {
#line 167
    __cil_tmp___5 = memrchr((void const   *)dir, '/', 4096U);
#line 167
    slash___0 = (char *)__cil_tmp___5;
#line 168
    if ((unsigned int )slash___0 == (unsigned int )((void *)0)) {
#line 170
      __cil_tmp___6 = __errno();
#line 170
      *__cil_tmp___6 = 91;
#line 171
      return (-1);
    }
#line 174
    *slash___0 = (char )'\000';
#line 175
    if ((slash___0 - dir < 4096) == 0) {
#line 175
      __libc_failwith((char *)"Assertion failed: slash - dir < PATH_MAX at chdir-long.c:175");
    }
#line 176
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 177
    *slash___0 = (char )'/';
#line 178
    if (err___0 != 0) {
#line 179
      goto Fail;
    }
#line 181
    dir = find_non_slash((char const   *)(slash___0 + 1));
  }
#line 184
  if ((unsigned int )dir < (unsigned int )dir_end) {
#line 186
    __cil_tmp___7 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 186
    if (__cil_tmp___7 != 0) {
#line 187
      goto Fail;
    }
  }
#line 190
  __cil_tmp___8 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
#line 190
  if (__cil_tmp___8 != 0) {
#line 191
    goto Fail;
  }
#line 193
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 194
  return (0);
  Fail: 
#line 198
  __cil_tmp___9 = __errno();
#line 198
  saved_errno = *__cil_tmp___9;
#line 199
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 200
  __cil_tmp___10 = __errno();
#line 200
  *__cil_tmp___10 = saved_errno;
#line 201
  return (-1);
}
}
#line 1 "chown.o"
#pragma merger(0,"/tmp/cil-q1bSOa3x.i","-g,-O2")
#line 24 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern int chown(char const   *__path , uid_t __owner , gid_t __group ) ;
#line 61 "./unistd.h"
int rpl_chown(char const   *file , uid_t uid , gid_t gid ) ;
#line 89 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/stat.h"
extern int stat(char const   *name , struct stat *s ) ;
#line 46 "chown.c"
int rpl_chown(char const   *file , uid_t uid , gid_t gid ) 
{ struct stat file_stats ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 50
  if ((int )gid == 65535 || (int )uid == 65535) {
#line 55
    __cil_tmp = stat(file, & file_stats);
#line 55
    if (__cil_tmp) {
#line 56
      return (-1);
    }
#line 58
    if ((int )gid == 65535) {
#line 59
      gid = file_stats.st_gid;
    }
#line 61
    if ((int )uid == 65535) {
#line 62
      uid = file_stats.st_uid;
    }
  }
#line 102
  __cil_tmp___0 = chown(file, uid, gid);
#line 102
  return (__cil_tmp___0);
}
}
#line 1 "cloexec.o"
#pragma merger(0,"/tmp/cil-A1gQ8uev.i","-g,-O2")
#line 2 "cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 48 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/fcntl.h"
extern int fcntl(int fd , int cmd  , ...) ;
#line 35 "cloexec.c"
int set_cloexec_flag(int desc , _Bool value ) 
{ int flags ;
  int __cil_tmp ;
  int newflags ;
  int __cil_tmp___0 ;

  {
#line 40
  __cil_tmp = fcntl(desc, 2, 0);
#line 40
  flags = __cil_tmp;
#line 42
  if (0 <= flags) {
#line 44
    newflags = value ? flags | 8 : flags & -9;
#line 46
    if (flags == newflags) {
#line 48
      return (0);
    } else {
#line 46
      __cil_tmp___0 = fcntl(desc, 3, newflags);
#line 46
      if (__cil_tmp___0 != -1) {
#line 48
        return (0);
      }
    }
  }
#line 51
  return (-1);
}
}
#line 1 "close-stream.o"
#pragma merger(0,"/tmp/cil-4f9qrTdd.i","-g,-O2")
#line 2 "close-stream.h"
int close_stream(FILE *stream ) ;
#line 32 "fpending.h"
size_t __fpending(FILE *fp ) ;
#line 52 "close-stream.c"
int close_stream(FILE *stream ) 
{ _Bool some_pending ;
  size_t __cil_tmp ;
  _Bool prev_fail ;
  int __cil_tmp___0 ;
  _Bool fclose_fail ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;

  {
#line 55
  __cil_tmp = __fpending(stream);
#line 55
  some_pending = (_Bool )(__cil_tmp != 0U);
#line 56
  __cil_tmp___0 = ferror(stream);
#line 56
  prev_fail = (_Bool )(__cil_tmp___0 != 0);
#line 57
  __cil_tmp___1 = fclose(stream);
#line 57
  fclose_fail = (_Bool )(__cil_tmp___1 != 0);
#line 67
  if (prev_fail) {
#line 67
    goto _L___0;
  } else
#line 67
  if (fclose_fail) {
#line 67
    if (some_pending) {
#line 67
      goto _L___0;
    } else {
#line 67
      __cil_tmp___3 = __errno();
#line 67
      if (*__cil_tmp___3 != 9) {
        _L___0: 
#line 69
        if (! fclose_fail) {
#line 70
          __cil_tmp___2 = __errno();
#line 70
          *__cil_tmp___2 = 0;
        }
#line 71
        return (-1);
      }
    }
  }
#line 74
  return (0);
}
}
#line 1 "closein.o"
#pragma merger(0,"/tmp/cil-yxtP5mLh.i","-g,-O2")
#line 25 "closein.h"
void close_stdin_set_file_name(char const   *file ) ;
#line 26
void close_stdin(void) ;
#line 277 "./stdio.h"
int rpl_fseeko(FILE *fp , off_t offset , int whence ) ;
#line 355
int rpl_fflush(FILE *stream ) ;
#line 37 "closein.c"
static char const   *file_name  ;
#line 42 "closein.c"
void close_stdin_set_file_name(char const   *file ) 
{ 

  {
#line 45
  file_name = file;
#line 46
  return;
}
}
#line 78 "closein.c"
void close_stdin(void) 
{ _Bool fail ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  char const   *close_error ;
  char *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;

  {
#line 81
  fail = (_Bool)0;
#line 86
  __cil_tmp___1 = freadahead(_impure_ptr->_stdin);
#line 86
  if (__cil_tmp___1 > 0U) {
#line 90
    __cil_tmp = rpl_fseeko(_impure_ptr->_stdin, 0L, 1);
#line 90
    if (__cil_tmp == 0) {
#line 90
      __cil_tmp___0 = rpl_fflush(_impure_ptr->_stdin);
#line 90
      if (__cil_tmp___0 != 0) {
#line 91
        fail = (_Bool)1;
      }
    }
  }
#line 93
  __cil_tmp___2 = close_stream(_impure_ptr->_stdin);
#line 93
  if (__cil_tmp___2 != 0) {
#line 94
    fail = (_Bool)1;
  }
#line 95
  if (fail) {
#line 99
    close_error = "error closing file";
#line 100
    if (file_name) {
#line 101
      __cil_tmp___3 = quotearg_colon(file_name);
#line 101
      __cil_tmp___4 = __errno();
#line 101
      error(0, *__cil_tmp___4, "%s: %s", __cil_tmp___3, close_error);
    } else {
#line 104
      __cil_tmp___5 = __errno();
#line 104
      error(0, *__cil_tmp___5, "%s", close_error);
    }
  }
#line 107
  close_stdout();
#line 109
  if (fail) {
#line 110
    _exit((int )exit_failure);
  }
#line 111
  return;
}
}
#line 1 "closeout.o"
#pragma merger(0,"/tmp/cil-OzQXXrZt.i","-g,-O2")
#line 25 "closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 35 "closeout.c"
static char const   *file_name___0  ;
#line 39 "closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 

  {
#line 42
  file_name___0 = file;
#line 43
  return;
}
}
#line 68 "closeout.c"
void close_stdout(void) 
{ char const   *write_error ;
  char *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 71
  __cil_tmp___2 = close_stream(_impure_ptr->_stdout);
#line 71
  if (__cil_tmp___2 != 0) {
#line 73
    write_error = "write error";
#line 74
    if (file_name___0) {
#line 75
      __cil_tmp = quotearg_colon(file_name___0);
#line 75
      __cil_tmp___0 = __errno();
#line 75
      error(0, *__cil_tmp___0, "%s: %s", __cil_tmp, write_error);
    } else {
#line 78
      __cil_tmp___1 = __errno();
#line 78
      error(0, *__cil_tmp___1, "%s", write_error);
    }
#line 80
    _exit((int )exit_failure);
  }
#line 83
  __cil_tmp___3 = close_stream(_impure_ptr->_stderr);
#line 83
  if (__cil_tmp___3 != 0) {
#line 84
    _exit((int )exit_failure);
  }
#line 85
  return;
}
}
#line 1 "creat-safer.o"
#pragma merger(0,"/tmp/cil-y7mKMfVK.i","-g,-O2")
#line 23 "fcntl-safer.h"
int creat_safer(char const   *file , mode_t mode ) ;
#line 47 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/fcntl.h"
extern int creat(char const   *name , mode_t mode ) ;
#line 21 "unistd-safer.h"
int fd_safer(int fd ) ;
#line 27 "creat-safer.c"
int creat_safer(char const   *file , mode_t mode ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 30
  __cil_tmp = creat(file, mode);
#line 30
  __cil_tmp___0 = fd_safer(__cil_tmp);
#line 30
  return (__cil_tmp___0);
}
}
#line 1 "cycle-check.o"
#pragma merger(0,"/tmp/cil-uMZuVcIj.i","-g,-O2")
#line 35 "cycle-check.h"
void cycle_check_init(struct cycle_check_state *state ) ;
#line 36
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) ;
#line 36 "cycle-check.c"
__inline static _Bool is_zero_or_power_of_two(unsigned long long i ) 
{ 

  {
#line 39
  return ((_Bool )((i & (i - 1ULL)) == 0ULL));
}
}
#line 42 "cycle-check.c"
void cycle_check_init(struct cycle_check_state *state ) 
{ 

  {
#line 45
  state->chdir_counter = 0ULL;
#line 46
  state->magic = 9827862;
#line 47
  return;
}
}
#line 57 "cycle-check.c"
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) 
{ _Bool __cil_tmp ;

  {
#line 60
  if ((state->magic == 9827862) == 0) {
#line 60
    __libc_failwith((char *)"Assertion failed: state->magic == CC_MAGIC at cycle-check.c:60");
  }
#line 65
  if (state->chdir_counter && ((int const   )sb->st_ino == (int const   )state->dev_ino.st_ino && (int const   )sb->st_dev == (int const   )state->dev_ino.st_dev)) {
#line 66
    return ((_Bool)1);
  }
#line 70
  (state->chdir_counter) ++;
#line 70
  __cil_tmp = is_zero_or_power_of_two(state->chdir_counter);
#line 70
  if (__cil_tmp) {
#line 77
    if (state->chdir_counter == 0ULL) {
#line 78
      return ((_Bool)1);
    }
#line 80
    state->dev_ino.st_dev = (short )sb->st_dev;
#line 81
    state->dev_ino.st_ino = (unsigned short )sb->st_ino;
  }
#line 84
  return ((_Bool)0);
}
}
#line 1 "dirchownmod.o"
#pragma merger(0,"/tmp/cil-LpDM6FdX.i","-g,-O2")
#line 2 "dirchownmod.h"
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) ;
#line 84 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/stat.h"
extern int fstat(int file , struct stat *s ) ;
#line 61 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
int fchown(int fd , uid_t uid , gid_t gid ) ;
#line 252 "./unistd.h"
int rpl_lchown(char const   *file , uid_t uid , gid_t gid ) ;
#line 61 "dirchownmod.c"
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) 
{ struct stat st ;
  int result ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  mode_t dir_mode ;
  int *__cil_tmp___2 ;
  mode_t indeterminate ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  mode_t chmod_mode ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int e ;
  int *__cil_tmp___11 ;
  int *__cil_tmp___12 ;

  {
#line 67
  if (fd < 0) {
#line 67
    __cil_tmp = stat(dir, & st);
#line 67
    __cil_tmp___1 = __cil_tmp;
  } else {
#line 67
    __cil_tmp___0 = fstat(fd, & st);
#line 67
    __cil_tmp___1 = __cil_tmp___0;
  }
#line 67
  result = __cil_tmp___1;
#line 69
  if (result == 0) {
#line 71
    dir_mode = st.st_mode;
#line 77
    if (! ((dir_mode & 8323072U) == 1048576U)) {
#line 79
      __cil_tmp___2 = __errno();
#line 79
      *__cil_tmp___2 = 20;
#line 80
      result = -1;
    } else {
#line 88
      indeterminate = 0U;
#line 95
      if (((int )owner != 65535 && (int )owner != (int )st.st_uid) || ((int )group != 65535 && (int )group != (int )st.st_gid)) {
#line 98
        if (0 <= fd) {
#line 98
          __cil_tmp___3 = fchown(fd, owner, group);
#line 98
          result = __cil_tmp___3;
        } else {
#line 98
          if (mkdir_mode != 4294967295U) {
#line 98
            __cil_tmp___4 = rpl_lchown(dir, owner, group);
#line 98
            __cil_tmp___6 = __cil_tmp___4;
          } else {
#line 98
            __cil_tmp___5 = rpl_chown(dir, owner, group);
#line 98
            __cil_tmp___6 = __cil_tmp___5;
          }
#line 98
          result = __cil_tmp___6;
        }
#line 109
        if (result == 0 && dir_mode & 73U) {
#line 110
          indeterminate = dir_mode & 3072U;
        }
      }
#line 116
      if (result == 0 && ((dir_mode ^ mode) | indeterminate) & mode_bits) {
#line 118
        chmod_mode = mode | ((dir_mode & 4095U) & ~ mode_bits);
#line 120
        if (0 <= fd) {
#line 120
          __cil_tmp___7 = fchmod(fd, chmod_mode);
#line 120
          result = __cil_tmp___7;
        } else {
#line 120
          if (mkdir_mode != 4294967295U) {
#line 120
            __cil_tmp___8 = chmod(dir, chmod_mode);
#line 120
            __cil_tmp___10 = __cil_tmp___8;
          } else {
#line 120
            __cil_tmp___9 = chmod(dir, chmod_mode);
#line 120
            __cil_tmp___10 = __cil_tmp___9;
          }
#line 120
          result = __cil_tmp___10;
        }
      }
    }
  }
#line 129
  if (0 <= fd) {
#line 131
    if (result == 0) {
#line 132
      result = close(fd);
    } else {
#line 135
      __cil_tmp___11 = __errno();
#line 135
      e = *__cil_tmp___11;
#line 136
      close(fd);
#line 137
      __cil_tmp___12 = __errno();
#line 137
      *__cil_tmp___12 = e;
    }
  }
#line 141
  return (result);
}
}
#line 1 "dirfd.o"
#pragma merger(0,"/tmp/cil-ElhaadHx.i","-g,-O2")
#line 27 "dirfd.h"
int dirfd(DIR const   *dir_p ) ;
#line 24 "dirfd.c"
int dirfd(DIR const   *dir_p ) 
{ 

  {
#line 27
  return ((int )dir_p->dd_fd);
}
}
#line 1 "dirname.o"
#pragma merger(0,"/tmp/cil-4d2paS97.i","-g,-O2")
#line 62 "dirname.h"
char *dir_name(char const   *file ) ;
#line 64
size_t dir_len(char const   *file ) ;
#line 31 "dirname.c"
size_t dir_len(char const   *file ) 
{ size_t prefix_length ;
  size_t length ;
  char *__cil_tmp ;

  {
#line 34
  prefix_length = 0U;
#line 38
  prefix_length += (unsigned int )(prefix_length != 0U ? 0 : ((int const   )*(file + 0) == 47 ? 1 : 0));
#line 48
  __cil_tmp = last_component(file);
#line 48
  length = (unsigned int )(__cil_tmp - (char *)file);
#line 48
  while (prefix_length < length) {
#line 50
    if (! ((int const   )*(file + (length - 1U)) == 47)) {
#line 51
      break;
    }
#line 48
    length --;
  }
#line 52
  return (length);
}
}
#line 70 "dirname.c"
char *dir_name(char const   *file ) 
{ size_t length ;
  size_t __cil_tmp ;
  _Bool append_dot ;
  char *dir ;
  void *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 73
  __cil_tmp = dir_len(file);
#line 73
  length = __cil_tmp;
#line 74
  append_dot = (_Bool )(length == 0U);
#line 78
  __cil_tmp___0 = xmalloc((length + (unsigned int )append_dot) + 1U);
#line 78
  dir = (char *)__cil_tmp___0;
#line 79
  memcpy((void *)dir, (void const   *)file, length);
#line 80
  if (append_dot) {
#line 81
    __cil_tmp___1 = length;
#line 81
    length ++;
#line 81
    *(dir + __cil_tmp___1) = (char )'.';
  }
#line 82
  *(dir + length) = (char )'\000';
#line 83
  return (dir);
}
}
#line 1 "dup-safer.o"
#pragma merger(0,"/tmp/cil-7y2p8C6Y.i","-g,-O2")
#line 20 "unistd-safer.h"
int dup_safer(int fd ) ;
#line 34 "dup-safer.c"
int dup_safer(int fd ) 
{ int __cil_tmp ;

  {
#line 38
  __cil_tmp = fcntl(fd, 1, 3);
#line 38
  return (__cil_tmp);
}
}
#line 1 "error.o"
#pragma merger(0,"/tmp/cil-y5o6DP2t.i","-g,-O2")
#line 45 "error.h"
void error_at_line(int status , int errnum , char const   *file_name___1 , unsigned int line_number ,
                   char const   *message  , ...) ;
#line 52 "error.h"
void (*error_print_progname)(void)  ;
#line 55 "error.h"
unsigned int error_message_count  ;
#line 59 "error.h"
int error_one_per_line  ;
#line 69 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strerror_r(int  , char * , size_t  ) ;
#line 104 "error.c"
static void print_errno_message(int errnum ) 
{ char const   *s ;
  char errbuf[1024] ;
  char *__cil_tmp ;

  {
#line 112
  __cil_tmp = strerror_r(errnum, errbuf, sizeof(errbuf));
#line 112
  s = (char const   *)__cil_tmp;
#line 124
  if (! s) {
#line 125
    s = "Unknown system error";
  }
#line 131
  fprintf(_impure_ptr->_stderr, ": %s", s);
#line 133
  return;
}
}
#line 135 "error.c"
static void error_tail(int status , int errnum , char const   *message , va_list args ) 
{ 

  {
#line 205
  rpl_vfprintf(_impure_ptr->_stderr, message, args);
#line 206
  __builtin_va_end(args);
#line 208
  error_message_count ++;
#line 209
  if (errnum) {
#line 210
    print_errno_message(errnum);
  }
#line 214
  putc_unlocked('\n', _impure_ptr->_stderr);
#line 216
  rpl_fflush(_impure_ptr->_stderr);
#line 217
  if (status) {
#line 218
    exit(status);
  }
#line 219
  return;
}
}
#line 226 "error.c"
void error(int status , int errnum , char const   *message  , ...) 
{ va_list args ;

  {
#line 239
  rpl_fflush(_impure_ptr->_stdout);
#line 243
  if (error_print_progname) {
#line 244
    (*error_print_progname)();
  } else {
#line 250
    fprintf(_impure_ptr->_stderr, "%s: ", program_name);
  }
#line 254
  __builtin_va_start(args, message);
#line 255
  error_tail(status, errnum, message, args);
#line 263
  return;
}
}
#line 277 "error.c"
static char const   *old_file_name  ;
#line 278 "error.c"
static unsigned int old_line_number  ;
#line 269 "error.c"
void error_at_line(int status , int errnum , char const   *file_name___1 , unsigned int line_number ,
                   char const   *message  , ...) 
{ va_list args ;
  int __cil_tmp ;

  {
#line 275
  if (error_one_per_line) {
#line 280
    if (old_line_number == line_number) {
#line 280
      if ((unsigned int )file_name___1 == (unsigned int )old_file_name) {
#line 284
        return;
      } else {
#line 280
        __cil_tmp = strcmp(old_file_name, file_name___1);
#line 280
        if (__cil_tmp == 0) {
#line 284
          return;
        }
      }
    }
#line 286
    old_file_name = file_name___1;
#line 287
    old_line_number = line_number;
  }
#line 298
  rpl_fflush(_impure_ptr->_stdout);
#line 302
  if (error_print_progname) {
#line 303
    (*error_print_progname)();
  } else {
#line 309
    fprintf(_impure_ptr->_stderr, "%s:", program_name);
  }
#line 317
  fprintf(_impure_ptr->_stderr, (unsigned int )file_name___1 != (unsigned int )((void *)0) ? "%s:%d: " : " ",
          file_name___1, line_number);
#line 321
  __builtin_va_start(args, message);
#line 322
  error_tail(status, errnum, message, args);
#line 330
  return;
}
}
#line 1 "euidaccess.o"
#pragma merger(0,"/tmp/cil-PIsRO0cx.i","-g,-O2")
#line 2 "euidaccess.h"
int euidaccess(char const   *file , int mode ) ;
#line 19 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern int access(char const   *__path , int __amode ) ;
#line 76
extern gid_t getegid(void) ;
#line 77
extern uid_t geteuid(void) ;
#line 23 "group-member.h"
int group_member(gid_t gid ) ;
#line 78 "euidaccess.c"
int euidaccess(char const   *file , int mode ) 
{ uid_t uid ;
  uid_t __cil_tmp ;
  gid_t gid ;
  gid_t __cil_tmp___0 ;
  uid_t euid ;
  uid_t __cil_tmp___1 ;
  gid_t egid ;
  gid_t __cil_tmp___2 ;
  struct stat stats ;
  unsigned int granted ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int *__cil_tmp___6 ;

  {
#line 89
  __cil_tmp = getuid();
#line 89
  uid = __cil_tmp;
#line 90
  __cil_tmp___0 = getgid();
#line 90
  gid = __cil_tmp___0;
#line 91
  __cil_tmp___1 = geteuid();
#line 91
  euid = __cil_tmp___1;
#line 92
  __cil_tmp___2 = getegid();
#line 92
  egid = __cil_tmp___2;
#line 136
  if ((int )uid == (int )euid && (int )gid == (int )egid) {
#line 138
    __cil_tmp___3 = access(file, mode);
#line 138
    return (__cil_tmp___3);
  }
#line 140
  __cil_tmp___4 = stat(file, & stats);
#line 140
  if (__cil_tmp___4 != 0) {
#line 141
    return (-1);
  }
#line 145
  if ((int )euid == 0 && ((mode & 1) == 0 || stats.st_mode & 73U)) {
#line 147
    return (0);
  }
#line 151
  mode &= 7;
#line 157
  if (mode == 0) {
#line 158
    return (0);
  }
#line 161
  if (((((256 == 4 << 6 && 128 == 2 << 6) && 64 == 1 << 6) && 32 == 4 << 3) && 16 == 2 << 3) && 8 == 1 << 3) {
#line 164
    granted = stats.st_mode;
  } else {
#line 166
    granted = (unsigned int )(((((((((stats.st_mode & 256U ? 4 << 6 : 0) + (stats.st_mode & 128U ? 2 << 6 : 0)) + (stats.st_mode & 64U ? 1 << 6 : 0)) + (stats.st_mode & 32U ? 4 << 3 : 0)) + (stats.st_mode & 16U ? 2 << 3 : 0)) + (stats.st_mode & 8U ? 1 << 3 : 0)) + (stats.st_mode & 4U ? 4 : 0)) + (stats.st_mode & 2U ? 2 : 0)) + (stats.st_mode & 1U ? 1 : 0));
  }
#line 176
  if ((int )euid == (int )stats.st_uid) {
#line 177
    granted >>= 6;
  } else
#line 178
  if ((int )egid == (int )stats.st_gid) {
#line 179
    granted >>= 3;
  } else {
#line 178
    __cil_tmp___5 = group_member(stats.st_gid);
#line 178
    if (__cil_tmp___5) {
#line 179
      granted >>= 3;
    }
  }
#line 181
  if (((unsigned int )mode & ~ granted) == 0U) {
#line 182
    return (0);
  }
#line 183
  __cil_tmp___6 = __errno();
#line 183
  *__cil_tmp___6 = 13;
#line 184
  return (-1);
}
}
#line 1 "exclude.o"
#pragma merger(0,"/tmp/cil-JSjlgc3R.i","-g,-O2")
#line 36 "exclude.h"
struct exclude *new_exclude(void) ;
#line 37
void free_exclude(struct exclude *ex ) ;
#line 38
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 39
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) ;
#line 41
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 42
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 61 "fnmatch.h"
int gnu_fnmatch(char const   *pattern , char const   *string , int flags ) ;
#line 48 "xalloc.h"
void *xzalloc(size_t s ) ;
#line 185 "xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ size_t n ;
  void *__cil_tmp ;

  {
#line 188
  n = *pn;
#line 190
  if (! p) {
#line 192
    if (! n) {
#line 200
      n = 64U / s;
#line 201
      n += (unsigned int )(! n);
    }
  } else {
#line 210
    if (2863311530U / s <= n) {
#line 211
      xalloc_die();
    }
#line 212
    n += (n + 1U) / 2U;
  }
#line 215
  *pn = n;
#line 216
  __cil_tmp = xrealloc(p, n * s);
#line 216
  return (__cil_tmp);
}
}
#line 77 "exclude.c"
struct exclude *new_exclude(void) 
{ struct exclude *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 80
  __cil_tmp___0 = xzalloc(sizeof(*__cil_tmp));
#line 80
  return ((struct exclude *)__cil_tmp___0);
}
}
#line 85 "exclude.c"
void free_exclude(struct exclude *ex ) 
{ 

  {
#line 88
  free((void *)ex->exclude);
#line 89
  free((void *)ex);
#line 90
  return;
}
}
#line 95 "exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  size_t patlen ;
  size_t __cil_tmp___2 ;
  int r ;
  int __cil_tmp___3 ;
  char *fcopy ;
  char *__cil_tmp___4 ;
  char *p ;
  int r___0 ;
  char *__cil_tmp___5 ;

  {
#line 98
  if (! (options & (1 << 3))) {
#line 99
    if (options & (1 << 4)) {
#line 99
      __cil_tmp = mbscasecmp(pattern, f);
#line 99
      __cil_tmp___1 = __cil_tmp;
    } else {
#line 99
      __cil_tmp___0 = strcmp(pattern, f);
#line 99
      __cil_tmp___1 = __cil_tmp___0;
    }
#line 99
    return (__cil_tmp___1);
  } else
#line 102
  if (! (options & (1 << 4))) {
#line 104
    __cil_tmp___2 = strlen(pattern);
#line 104
    patlen = __cil_tmp___2;
#line 105
    __cil_tmp___3 = strncmp(pattern, f, patlen);
#line 105
    r = __cil_tmp___3;
#line 106
    if (! r) {
#line 108
      r = (int )*(f + patlen);
#line 109
      if (r == 47) {
#line 110
        r = 0;
      }
    }
#line 112
    return (r);
  } else {
#line 123
    __cil_tmp___4 = xstrdup(f);
#line 123
    fcopy = __cil_tmp___4;
#line 126
    p = fcopy;
#line 126
    while (1) {
#line 128
      p = strchr((char const   *)p, '/');
#line 129
      if (p) {
#line 130
        *p = (char )'\000';
      }
#line 131
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
#line 132
      if (! p || r___0 <= 0) {
#line 133
        break;
      }
#line 126
      __cil_tmp___5 = p;
#line 126
      p ++;
#line 126
      *__cil_tmp___5 = (char )'/';
    }
#line 135
    free((void *)fcopy);
#line 136
    return (r___0);
  }
}
}
#line 140 "exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ int (*matcher)(char const   * , char const   * , int  ) ;
  _Bool matched ;
  int __cil_tmp ;
  char const   *p ;
  int __cil_tmp___0 ;

  {
#line 143
  matcher = options & (1 << 28) ? & gnu_fnmatch : & fnmatch_no_wildcards;
#line 147
  __cil_tmp = (*matcher)(pattern, f, options);
#line 147
  matched = (_Bool )(__cil_tmp == 0);
#line 150
  if (! (options & (1 << 30))) {
#line 151
    p = f;
#line 151
    while (*p && ! matched) {
#line 152
      if ((int const   )*p == 47 && (int const   )*(p + 1) != 47) {
#line 153
        __cil_tmp___0 = (*matcher)(pattern, p + 1, options);
#line 153
        matched = (_Bool )(__cil_tmp___0 == 0);
      }
#line 151
      p ++;
    }
  }
#line 155
  return (matched);
}
}
#line 160 "exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool excluded ;
  char const   *pattern ;
  int options ;
  _Bool __cil_tmp ;

  {
#line 163
  exclude_count = (unsigned int )ex->exclude_count;
#line 166
  if (exclude_count == 0U) {
#line 167
    return ((_Bool)0);
  } else {
#line 170
    exclude = (struct patopts  const  *)ex->exclude;
#line 174
    excluded = (_Bool )(! (! ((exclude + 0)->options & (int const   )(1 << 29))));
#line 178
    i = 0U;
#line 178
    while (i < exclude_count) {
#line 180
      pattern = (char const   *)(exclude + i)->pattern;
#line 181
      options = (int )(exclude + i)->options;
#line 182
      if ((int )excluded == ! (! (options & (1 << 29)))) {
#line 183
        __cil_tmp = exclude_fnmatch(pattern, f, options);
#line 183
        excluded = (_Bool )((int )excluded ^ (int )__cil_tmp);
      }
#line 178
      i ++;
    }
#line 186
    return (excluded);
  }
}
}
#line 192 "exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ struct patopts *patopts ;
  void *__cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 197
  if (ex->exclude_count == ex->exclude_alloc) {
#line 198
    __cil_tmp = x2nrealloc((void *)ex->exclude, & ex->exclude_alloc, sizeof(*(ex->exclude)));
#line 198
    ex->exclude = (struct patopts *)__cil_tmp;
  }
#line 201
  __cil_tmp___0 = ex->exclude_count;
#line 201
  (ex->exclude_count) ++;
#line 201
  patopts = ex->exclude + __cil_tmp___0;
#line 202
  patopts->pattern = pattern;
#line 203
  patopts->options = options;
#line 204
  return;
}
}
#line 211 "exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) 
{ _Bool use_stdin ;
  FILE *in ;
  char *buf___0 ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *__cil_tmp ;
  size_t __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  void *__cil_tmp___5 ;
  char *pattern_end ;
  int *__cil_tmp___6 ;

  {
#line 216
  use_stdin = (_Bool )((int const   )*(file_name___1 + 0) == 45 && ! *(file_name___1 + 1));
#line 218
  buf___0 = (char *)((void *)0);
#line 222
  buf_alloc = 0U;
#line 223
  buf_count = 0U;
#line 225
  e = 0;
#line 227
  if (use_stdin) {
#line 228
    in = _impure_ptr->_stdin;
  } else {
#line 229
    in = fopen(file_name___1, "r");
#line 229
    if (! in) {
#line 230
      return (-1);
    }
  }
#line 232
  while (1) {
#line 232
    c = getc_unlocked(in);
#line 232
    if (! (c != -1)) {
#line 232
      break;
    }
#line 234
    if (buf_count == buf_alloc) {
#line 235
      __cil_tmp = x2realloc((void *)buf___0, & buf_alloc);
#line 235
      buf___0 = (char *)__cil_tmp;
    }
#line 236
    __cil_tmp___0 = buf_count;
#line 236
    buf_count ++;
#line 236
    *(buf___0 + __cil_tmp___0) = (char )c;
  }
#line 239
  __cil_tmp___2 = ferror(in);
#line 239
  if (__cil_tmp___2) {
#line 240
    __cil_tmp___1 = __errno();
#line 240
    e = *__cil_tmp___1;
  }
#line 242
  if (! use_stdin) {
#line 242
    __cil_tmp___4 = fclose(in);
#line 242
    if (__cil_tmp___4 != 0) {
#line 243
      __cil_tmp___3 = __errno();
#line 243
      e = *__cil_tmp___3;
    }
  }
#line 245
  __cil_tmp___5 = xrealloc((void *)buf___0, buf_count + 1U);
#line 245
  buf___0 = (char *)__cil_tmp___5;
#line 246
  *(buf___0 + buf_count) = line_end;
#line 247
  lim = (char const   *)((buf___0 + buf_count) + ! (buf_count == 0U || (int )*(buf___0 + (buf_count - 1U)) == (int )line_end));
#line 248
  pattern = (char const   *)buf___0;
#line 250
  p = buf___0;
#line 250
  while ((unsigned int )p < (unsigned int )lim) {
#line 251
    if ((int )*p == (int )line_end) {
#line 253
      pattern_end = p;
#line 255
      if ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )((unsigned char )line_end)))) + (int )((unsigned char )line_end)) & 8) {
#line 257
        while (1) {
#line 258
          if ((unsigned int )pattern_end == (unsigned int )pattern) {
#line 259
            goto next_pattern;
          } else
#line 260
          if (! ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )((unsigned char )*(pattern_end + -1))))) + (int )((unsigned char )*(pattern_end + -1))) & 8)) {
#line 261
            break;
          }
#line 257
          pattern_end --;
        }
      }
#line 264
      *pattern_end = (char )'\000';
#line 265
      (*add_func)(ex, pattern, options);
      next_pattern: 
#line 268
      pattern = (char const   *)(p + 1);
    }
#line 250
    p ++;
  }
#line 271
  __cil_tmp___6 = __errno();
#line 271
  *__cil_tmp___6 = e;
#line 272
  return (e ? -1 : 0);
}
}
#line 1 "exitfail.o"
#pragma merger(0,"/tmp/cil-HGBnCNrg.i","-g,-O2")
#line 24 "exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 1 "fchmodat.o"
#pragma merger(0,"/tmp/cil-n4bacmQX.i","-g,-O2")
#line 98 "openat.h"
int fchmodat(int fd , char const   *file , mode_t mode , int flag ) ;
#line 29 "save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 30
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 31
void free_cwd(struct saved_cwd *cwd ) ;
#line 24 "openat-priv.h"
char *openat_proc_name(char *buf___0 , int fd , char const   *file ) ;
#line 31 "fchmodat.c"
static int lchmod_rpl(char const   *f , mode_t m ) 
{ int *__cil_tmp ;

  {
#line 31
  __cil_tmp = __errno();
#line 31
  *__cil_tmp = 88;
#line 31
  return (-1);
}
}
#line 30 "at-func.c"
int fchmodat(int fd , char const   *file , mode_t mode , int flag ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___2 ;
  int proc_result ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int proc_errno ;
  int *__cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int __cil_tmp___9 ;
  int *__cil_tmp___10 ;
  int *__cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int *__cil_tmp___15 ;
  int *__cil_tmp___16 ;
  int __cil_tmp___17 ;
  int *__cil_tmp___18 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    if (flag == 4096) {
#line 38
      __cil_tmp = lchmod_rpl(file, mode);
#line 38
      __cil_tmp___1 = __cil_tmp;
    } else {
#line 38
      __cil_tmp___0 = chmod(file, mode);
#line 38
      __cil_tmp___1 = __cil_tmp___0;
    }
#line 38
    return (__cil_tmp___1);
  }
#line 42
  __cil_tmp___2 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___2;
#line 43
  if (proc_file) {
#line 45
    if (flag == 4096) {
#line 45
      __cil_tmp___3 = lchmod_rpl((char const   *)proc_file, mode);
#line 45
      __cil_tmp___5 = __cil_tmp___3;
    } else {
#line 45
      __cil_tmp___4 = chmod((char const   *)proc_file, mode);
#line 45
      __cil_tmp___5 = __cil_tmp___4;
    }
#line 45
    proc_result = __cil_tmp___5;
#line 46
    __cil_tmp___6 = __errno();
#line 46
    proc_errno = *__cil_tmp___6;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___7 = __errno();
#line 56
      *__cil_tmp___7 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___9 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___9 != 0) {
#line 63
    __cil_tmp___8 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___8);
  }
#line 65
  __cil_tmp___12 = fchdir(fd);
#line 65
  if (__cil_tmp___12 != 0) {
#line 67
    __cil_tmp___10 = __errno();
#line 67
    saved_errno = *__cil_tmp___10;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___11 = __errno();
#line 69
    *__cil_tmp___11 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  if (flag == 4096) {
#line 73
    __cil_tmp___13 = lchmod_rpl(file, mode);
#line 73
    err = __cil_tmp___13;
  } else {
#line 73
    __cil_tmp___14 = chmod(file, mode);
#line 73
    err = __cil_tmp___14;
  }
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___15 = __errno();
#line 74
    saved_errno = *__cil_tmp___15;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___17 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___17 != 0) {
#line 77
    __cil_tmp___16 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___16);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___18 = __errno();
#line 82
    *__cil_tmp___18 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 1 "fchown-stub.o"
#pragma merger(0,"/tmp/cil-wwIPvkIt.i","-g,-O2")
#line 11 "fchown-stub.c"
int fchown(int fd , uid_t uid , gid_t gid ) 
{ int *__cil_tmp ;

  {
#line 14
  __cil_tmp = __errno();
#line 14
  *__cil_tmp = 1;
#line 15
  return (-1);
}
}
#line 1 "fchownat.o"
#pragma merger(0,"/tmp/cil-aUMfX1mY.i","-g,-O2")
#line 99 "openat.h"
int rpl_fchownat(int fd , char const   *file , uid_t owner , gid_t group , int flag ) ;
#line 30 "at-func.c"
int rpl_fchownat(int fd , char const   *file , uid_t owner , gid_t group , int flag ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___2 ;
  int proc_result ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int proc_errno ;
  int *__cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int __cil_tmp___9 ;
  int *__cil_tmp___10 ;
  int *__cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int *__cil_tmp___15 ;
  int *__cil_tmp___16 ;
  int __cil_tmp___17 ;
  int *__cil_tmp___18 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    if (flag == 4096) {
#line 38
      __cil_tmp = rpl_lchown(file, owner, group);
#line 38
      __cil_tmp___1 = __cil_tmp;
    } else {
#line 38
      __cil_tmp___0 = rpl_chown(file, owner, group);
#line 38
      __cil_tmp___1 = __cil_tmp___0;
    }
#line 38
    return (__cil_tmp___1);
  }
#line 42
  __cil_tmp___2 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___2;
#line 43
  if (proc_file) {
#line 45
    if (flag == 4096) {
#line 45
      __cil_tmp___3 = rpl_lchown((char const   *)proc_file, owner, group);
#line 45
      __cil_tmp___5 = __cil_tmp___3;
    } else {
#line 45
      __cil_tmp___4 = rpl_chown((char const   *)proc_file, owner, group);
#line 45
      __cil_tmp___5 = __cil_tmp___4;
    }
#line 45
    proc_result = __cil_tmp___5;
#line 46
    __cil_tmp___6 = __errno();
#line 46
    proc_errno = *__cil_tmp___6;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___7 = __errno();
#line 56
      *__cil_tmp___7 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___9 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___9 != 0) {
#line 63
    __cil_tmp___8 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___8);
  }
#line 65
  __cil_tmp___12 = fchdir(fd);
#line 65
  if (__cil_tmp___12 != 0) {
#line 67
    __cil_tmp___10 = __errno();
#line 67
    saved_errno = *__cil_tmp___10;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___11 = __errno();
#line 69
    *__cil_tmp___11 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  if (flag == 4096) {
#line 73
    __cil_tmp___13 = rpl_lchown(file, owner, group);
#line 73
    err = __cil_tmp___13;
  } else {
#line 73
    __cil_tmp___14 = rpl_chown(file, owner, group);
#line 73
    err = __cil_tmp___14;
  }
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___15 = __errno();
#line 74
    saved_errno = *__cil_tmp___15;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___17 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___17 != 0) {
#line 77
    __cil_tmp___16 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___16);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___18 = __errno();
#line 82
    *__cil_tmp___18 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 1 "fd-safer.o"
#pragma merger(0,"/tmp/cil-UWhKJyXS.i","-g,-O2")
#line 43 "fd-safer.c"
int fd_safer(int fd ) 
{ int f ;
  int __cil_tmp ;
  int e ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 46
  if (0 <= fd && fd <= 2) {
#line 48
    __cil_tmp = dup_safer(fd);
#line 48
    f = __cil_tmp;
#line 49
    __cil_tmp___0 = __errno();
#line 49
    e = *__cil_tmp___0;
#line 50
    close(fd);
#line 51
    __cil_tmp___1 = __errno();
#line 51
    *__cil_tmp___1 = e;
#line 52
    fd = f;
  }
#line 55
  return (fd);
}
}
#line 1 "fflush.o"
#pragma merger(0,"/tmp/cil-hN9AWJ5n.i","-g,-O2")
#line 174 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int fflush(FILE * ) ;
#line 237
extern off_t ftello(FILE * ) ;
#line 34 "fflush.c"
int rpl_fflush(FILE *stream ) 
{ int result ;
  off_t pos ;
  int __cil_tmp ;
  _Bool __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int saved_flags ;

  {
#line 59
  if ((unsigned int )stream == (unsigned int )((void *)0)) {
#line 60
    __cil_tmp = fflush(stream);
#line 60
    return (__cil_tmp);
  } else {
#line 59
    __cil_tmp___0 = freading(stream);
#line 59
    if (! __cil_tmp___0) {
#line 60
      __cil_tmp = fflush(stream);
#line 60
      return (__cil_tmp);
    }
  }
#line 65
  pos = ftello(stream);
#line 66
  if (pos == -1L) {
#line 68
    __cil_tmp___1 = __errno();
#line 68
    *__cil_tmp___1 = 9;
#line 69
    return (-1);
  }
#line 75
  result = rpl_fpurge(stream);
#line 76
  if (result != 0) {
#line 77
    return (result);
  }
#line 85
  saved_flags = (int )stream->_flags & 3072;
#line 86
  stream->_flags = (short )(((int )stream->_flags & -1025) | 2048);
#line 88
  result = rpl_fseeko(stream, pos, 0);
#line 90
  stream->_flags = (short )(((int )stream->_flags & -3073) | saved_flags);
#line 92
  return (result);
}
}
#line 1 "file-has-acl.o"
#pragma merger(0,"/tmp/cil-4b3hLctg.i","-g,-O2")
#line 31 "acl.h"
int file_has_acl(char const   *name , struct stat  const  *sb ) ;
#line 30 "file-has-acl.c"
int file_has_acl(char const   *name , struct stat  const  *sb ) 
{ 

  {
#line 33
  if (! ((sb->st_mode & 8323072U) == 2097152U)) {

  }
#line 85
  return (0);
}
}
#line 1 "file-type.o"
#pragma merger(0,"/tmp/cil-opTFBR0p.i","-g,-O2")
#line 27 "file-type.h"
char const   *file_type(struct stat  const  *st ) ;
#line 28 "file-type.c"
char const   *file_type(struct stat  const  *st ) 
{ 

  {
#line 37
  if ((st->st_mode & 8323072U) == 524288U) {
#line 38
    return (st->st_size == 0L ? "regular empty file" : "regular file");
  }
#line 40
  if ((st->st_mode & 8323072U) == 1048576U) {
#line 41
    return ("directory");
  }
#line 43
  if ((st->st_mode & 8323072U) == 65536U) {
#line 44
    return ("block special file");
  }
#line 46
  if ((st->st_mode & 8323072U) == 131072U) {
#line 47
    return ("character special file");
  }
#line 49
  if ((st->st_mode & 8323072U) == 262144U) {
#line 50
    return ("fifo");
  }
#line 52
  if ((st->st_mode & 8323072U) == 2097152U) {
#line 53
    return ("symbolic link");
  }
#line 55
  if ((st->st_mode & 8323072U) == 4194304U) {
#line 56
    return ("socket");
  }
#line 70
  return ("weird file");
}
}
#line 1 "filemode.o"
#pragma merger(0,"/tmp/cil-FZsgnZvU.i","-g,-O2")
#line 27 "filemode.h"
void strmode(mode_t mode , char *str ) ;
#line 30
void filemodestring(struct stat  const  *statp , char *str ) ;
#line 53 "filemode.c"
static char ftypelet(mode_t bits ) 
{ 

  {
#line 57
  if ((bits & 8323072U) == 524288U) {
#line 58
    return ((char )'-');
  }
#line 59
  if ((bits & 8323072U) == 1048576U) {
#line 60
    return ((char )'d');
  }
#line 63
  if ((bits & 8323072U) == 65536U) {
#line 64
    return ((char )'b');
  }
#line 65
  if ((bits & 8323072U) == 131072U) {
#line 66
    return ((char )'c');
  }
#line 67
  if ((bits & 8323072U) == 2097152U) {
#line 68
    return ((char )'l');
  }
#line 69
  if ((bits & 8323072U) == 262144U) {
#line 70
    return ((char )'p');
  }
#line 73
  if ((bits & 8323072U) == 4194304U) {
#line 74
    return ((char )'s');
  }
#line 90
  return ((char )'?');
}
}
#line 95 "filemode.c"
void strmode(mode_t mode , char *str ) 
{ 

  {
#line 98
  *(str + 0) = ftypelet(mode);
#line 99
  *(str + 1) = (char )(mode & 256U ? 'r' : '-');
#line 100
  *(str + 2) = (char )(mode & 128U ? 'w' : '-');
#line 101
  *(str + 3) = (char )(mode & 2048U ? (mode & 64U ? 's' : 'S') : (mode & 64U ? 'x' : '-'));
#line 104
  *(str + 4) = (char )(mode & 32U ? 'r' : '-');
#line 105
  *(str + 5) = (char )(mode & 16U ? 'w' : '-');
#line 106
  *(str + 6) = (char )(mode & 1024U ? (mode & 8U ? 's' : 'S') : (mode & 8U ? 'x' : '-'));
#line 109
  *(str + 7) = (char )(mode & 4U ? 'r' : '-');
#line 110
  *(str + 8) = (char )(mode & 2U ? 'w' : '-');
#line 111
  *(str + 9) = (char )(mode & 512U ? (mode & 1U ? 't' : 'T') : (mode & 1U ? 'x' : '-'));
#line 114
  *(str + 10) = (char )' ';
#line 115
  *(str + 11) = (char )'\000';
#line 116
  return;
}
}
#line 165 "filemode.c"
void filemodestring(struct stat  const  *statp , char *str ) 
{ 

  {
#line 168
  strmode((unsigned int )statp->st_mode, str);
#line 180
  return;
}
}
#line 1 "filenamecat.o"
#pragma merger(0,"/tmp/cil-XcRtbUhD.i","-g,-O2")
#line 20 "filenamecat.h"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 23
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 58 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern void *mempcpy(void * , void const   * , size_t  ) ;
#line 38 "filenamecat.c"
static char const   *longest_relative_suffix(char const   *f ) 
{ 

  {
#line 41
  f += 0;
#line 41
  while ((int const   )*f == 47) {
#line 42
    goto __Cont;
    __Cont: 
#line 41
    f ++;
  }
#line 43
  return (f);
}
}
#line 61 "filenamecat.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ char const   *dirbase ;
  char *__cil_tmp ;
  size_t dirbaselen ;
  size_t __cil_tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  char const   *base ;
  char const   *__cil_tmp___1 ;
  size_t baselen ;
  size_t __cil_tmp___2 ;
  char *p_concat ;
  void *__cil_tmp___3 ;
  char *p ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;

  {
#line 64
  __cil_tmp = last_component(dir);
#line 64
  dirbase = (char const   *)__cil_tmp;
#line 65
  __cil_tmp___0 = base_len(dirbase);
#line 65
  dirbaselen = __cil_tmp___0;
#line 66
  dirlen = (unsigned int )(dirbase - dir) + dirbaselen;
#line 67
  needs_separator = (unsigned int )(dirbaselen && ! ((int const   )*(dirbase + (dirbaselen - 1U)) == 47));
#line 69
  __cil_tmp___1 = longest_relative_suffix(abase);
#line 69
  base = __cil_tmp___1;
#line 70
  __cil_tmp___2 = strlen(base);
#line 70
  baselen = __cil_tmp___2;
#line 72
  __cil_tmp___3 = rpl_malloc(((dirlen + needs_separator) + baselen) + 1U);
#line 72
  p_concat = (char *)__cil_tmp___3;
#line 75
  if ((unsigned int )p_concat == (unsigned int )((void *)0)) {
#line 76
    return ((char *)((void *)0));
  }
#line 78
  __cil_tmp___4 = mempcpy((void *)p_concat, (void const   *)dir, dirlen);
#line 78
  p = (char *)__cil_tmp___4;
#line 79
  *p = (char )'/';
#line 80
  p += needs_separator;
#line 82
  if (base_in_result) {
#line 83
    *base_in_result = p - ((int const   )*(abase + 0) == 47);
  }
#line 85
  __cil_tmp___5 = mempcpy((void *)p, (void const   *)base, baselen);
#line 85
  p = (char *)__cil_tmp___5;
#line 86
  *p = (char )'\000';
#line 88
  return (p_concat);
}
}
#line 95 "filenamecat.c"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ char *p ;
  char *__cil_tmp ;

  {
#line 98
  __cil_tmp = mfile_name_concat(dir, abase, base_in_result);
#line 98
  p = __cil_tmp;
#line 99
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 100
    xalloc_die();
  }
#line 101
  return (p);
}
}
#line 1 "fnmatch.o"
#pragma merger(0,"/tmp/cil-YlNZ04k4.i","-g,-O2")
#line 27 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strcat(char * , char const   * ) ;
#line 30 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wctype.h"
extern int iswctype(wint_t  , wctype_t  ) ;
#line 43
extern wctype_t wctype(char const   * ) ;
#line 50 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wchar.h"
extern wint_t btowc(int  ) ;
#line 61
extern size_t mbsrtowcs(wchar_t * , char const   ** , size_t  , mbstate_t * ) ;
#line 73
extern wchar_t *wcscat(wchar_t * , wchar_t const   * ) ;
#line 85
extern size_t wcslen(wchar_t const   * ) ;
#line 104
extern wchar_t *wmemchr(wchar_t const   * , wchar_t  , size_t  ) ;
#line 106
extern wchar_t *wmemcpy(wchar_t * , wchar_t const   * , size_t  ) ;
#line 140 "fnmatch.c"
static int posixly_correct  ;
#line 23 "fnmatch_loop.c"
static int ext_match(int opt , char const   *pattern , char const   *string , char const   *string_end ,
                     _Bool no_leading_period , int flags ) ;
#line 26
static char const   *end_pattern(char const   *pattern ) ;
#line 28 "fnmatch_loop.c"
static int internal_fnmatch(char const   *pattern , char const   *string , char const   *string_end ,
                            _Bool no_leading_period , int flags ) 
{ register char const   *p ;
  register char const   *n ;
  register unsigned char c ;
  _Bool new_no_leading_period ;
  unsigned char __x ;
  int res ;
  char const   *__cil_tmp ;
  unsigned char __x___0 ;
  unsigned char __x___1 ;
  int __cil_tmp___0 ;
  int res___0 ;
  char const   *__cil_tmp___1 ;
  char const   *__cil_tmp___2 ;
  char const   *endp ;
  char const   *__cil_tmp___3 ;
  int result ;
  void *__cil_tmp___4 ;
  char const   *endp___0 ;
  void *__cil_tmp___5 ;
  int flags2 ;
  _Bool no_leading_period2 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int flags2___0 ;
  int no_leading_period2___0 ;
  unsigned char __x___2 ;
  unsigned char __x___3 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  register _Bool not ;
  char cold ;
  unsigned char fn ;
  char *__cil_tmp___10 ;
  unsigned char __x___4 ;
  char const   *__cil_tmp___11 ;
  unsigned char __x___5 ;
  char str[257] ;
  size_t c1 ;
  wctype_t wt ;
  char const   *startp ;
  size_t __cil_tmp___12 ;
  wint_t __cil_tmp___13 ;
  int __cil_tmp___14 ;
  char const   *__cil_tmp___15 ;
  _Bool is_range ;
  unsigned char __x___6 ;
  char const   *__cil_tmp___16 ;
  unsigned char cend ;
  char const   *__cil_tmp___17 ;
  char const   *__cil_tmp___18 ;
  char const   *__cil_tmp___19 ;
  char const   *__cil_tmp___20 ;
  int c1___0 ;
  char const   *startp___0 ;
  char const   *__cil_tmp___21 ;
  char const   *__cil_tmp___22 ;
  char const   *__cil_tmp___23 ;
  int res___1 ;
  unsigned char __x___7 ;
  int __cil_tmp___24 ;
  char const   *__cil_tmp___25 ;

  {
#line 33
  p = pattern;
#line 33
  n = string;
#line 45
  while (1) {
#line 45
    __cil_tmp___25 = p;
#line 45
    p ++;
#line 45
    c = (unsigned char )*__cil_tmp___25;
#line 45
    if (! ((int )c != 0)) {
#line 45
      break;
    }
#line 47
    new_no_leading_period = (_Bool)0;
#line 48
    if (flags & (1 << 4)) {
#line 48
      __x = c;
#line 48
      c = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 1 ? ((int )__x - 65) + 97 : (int )__x);
    } else {
#line 48
      c = c;
    }
#line 50
    switch ((int )c) {
    case 63: 
#line 53
    if (flags & (1 << 5) && (int const   )*p == 40) {
#line 57
      res = ext_match((int )c, p, n, string_end, no_leading_period, flags);
#line 59
      if (res != -1) {
#line 60
        return (res);
      }
    }
#line 63
    if ((unsigned int )n == (unsigned int )string_end) {
#line 64
      return (1);
    } else
#line 65
    if ((int const   )*n == 47 && flags & 1) {
#line 66
      return (1);
    } else
#line 67
    if ((int const   )*n == 46 && no_leading_period) {
#line 68
      return (1);
    }
#line 69
    break;
    case 92: 
#line 72
    if (! (flags & (1 << 1))) {
#line 74
      __cil_tmp = p;
#line 74
      p ++;
#line 74
      c = (unsigned char )*__cil_tmp;
#line 75
      if ((int )c == 0) {
#line 77
        return (1);
      }
#line 78
      if (flags & (1 << 4)) {
#line 78
        __x___0 = c;
#line 78
        c = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___0))) + (int )__x___0) & 3) == 1 ? ((int )__x___0 - 65) + 97 : (int )__x___0);
      } else {
#line 78
        c = c;
      }
    }
#line 80
    if ((unsigned int )n == (unsigned int )string_end) {
#line 81
      return (1);
    } else {
#line 80
      if (flags & (1 << 4)) {
#line 80
        __x___1 = (unsigned char )*n;
#line 80
        __cil_tmp___0 = ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___1))) + (int )__x___1) & 3) == 1 ? ((int )__x___1 - 65) + 97 : (int )__x___1;
      } else {
#line 80
        __cil_tmp___0 = (int )((unsigned char )*n);
      }
#line 80
      if (__cil_tmp___0 != (int )c) {
#line 81
        return (1);
      }
    }
#line 82
    break;
    case 42: 
#line 85
    if (flags & (1 << 5) && (int const   )*p == 40) {
#line 89
      res___0 = ext_match((int )c, p, n, string_end, no_leading_period, flags);
#line 91
      if (res___0 != -1) {
#line 92
        return (res___0);
      }
    }
#line 95
    if (((unsigned int )n != (unsigned int )string_end && (int const   )*n == 46) && no_leading_period) {
#line 96
      return (1);
    }
#line 98
    __cil_tmp___1 = p;
#line 98
    p ++;
#line 98
    c = (unsigned char )*__cil_tmp___1;
#line 98
    while ((int )c == 63 || (int )c == 42) {
#line 100
      if ((int const   )*p == 40 && (flags & (1 << 5)) != 0) {
#line 102
        __cil_tmp___3 = end_pattern(p);
#line 102
        endp = __cil_tmp___3;
#line 103
        if ((unsigned int )endp != (unsigned int )p) {
#line 106
          p = endp;
#line 107
          goto __Cont;
        }
      }
#line 111
      if ((int )c == 63) {
#line 114
        if ((unsigned int )n == (unsigned int )string_end) {
#line 116
          return (1);
        } else
#line 117
        if ((int const   )*n == 47 && flags & 1) {
#line 121
          return (1);
        } else {
#line 126
          n ++;
        }
      }
      __Cont: 
#line 98
      __cil_tmp___2 = p;
#line 98
      p ++;
#line 98
      c = (unsigned char )*__cil_tmp___2;
    }
#line 130
    if ((int )c == 0) {
#line 136
      result = (flags & 1) == 0 ? 0 : 1;
#line 138
      if (flags & 1) {
#line 140
        if (flags & (1 << 3)) {
#line 141
          result = 0;
        } else {
#line 144
          __cil_tmp___4 = memchr((void const   *)n, '/', (unsigned int )(string_end - n));
#line 144
          if ((unsigned int )__cil_tmp___4 == (unsigned int )((void *)0)) {
#line 145
            result = 0;
          }
        }
      }
#line 149
      return (result);
    } else {
#line 155
      __cil_tmp___5 = memchr((void const   *)n, flags & 1 ? '/' : '\000', (unsigned int )(string_end - n));
#line 155
      endp___0 = (char const   *)__cil_tmp___5;
#line 157
      if ((unsigned int )endp___0 == (unsigned int )((void *)0)) {
#line 158
        endp___0 = string_end;
      }
#line 160
      if ((int )c == 91 || (((flags & (1 << 5)) != 0 && (((int )c == 64 || (int )c == 43) || (int )c == 33)) && (int const   )*p == 40)) {
#line 165
        flags2 = flags & 1 ? flags : flags & ~ (1 << 2);
#line 167
        no_leading_period2 = no_leading_period;
#line 169
        p --;
#line 169
        while ((unsigned int )n < (unsigned int )endp___0) {
#line 170
          __cil_tmp___6 = internal_fnmatch(p, n, string_end, no_leading_period2, flags2);
#line 170
          if (__cil_tmp___6 == 0) {
#line 172
            return (0);
          }
#line 169
          n ++;
#line 169
          no_leading_period2 = (_Bool)0;
        }
      } else
#line 174
      if ((int )c == 47 && flags & 1) {
#line 176
        while ((unsigned int )n < (unsigned int )string_end && (int const   )*n != 47) {
#line 177
          n ++;
        }
#line 178
        if ((unsigned int )n < (unsigned int )string_end && (int const   )*n == 47) {
#line 178
          __cil_tmp___7 = internal_fnmatch(p, n + 1, string_end, (_Bool )(flags & (1 << 2)),
                                           flags);
#line 178
          if (__cil_tmp___7 == 0) {
#line 181
            return (0);
          }
        }
      } else {
#line 185
        flags2___0 = flags & 1 ? flags : flags & ~ (1 << 2);
#line 187
        no_leading_period2___0 = (int )no_leading_period;
#line 189
        if ((int )c == 92 && ! (flags & (1 << 1))) {
#line 190
          c = (unsigned char )*p;
        }
#line 191
        if (flags & (1 << 4)) {
#line 191
          __x___2 = c;
#line 191
          c = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___2))) + (int )__x___2) & 3) == 1 ? ((int )__x___2 - 65) + 97 : (int )__x___2);
        } else {
#line 191
          c = c;
        }
#line 192
        p --;
#line 192
        while ((unsigned int )n < (unsigned int )endp___0) {
#line 193
          if (flags & (1 << 4)) {
#line 193
            __x___3 = (unsigned char )*n;
#line 193
            __cil_tmp___8 = ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___3))) + (int )__x___3) & 3) == 1 ? ((int )__x___3 - 65) + 97 : (int )__x___3;
          } else {
#line 193
            __cil_tmp___8 = (int )((unsigned char )*n);
          }
#line 193
          if (__cil_tmp___8 == (int )c) {
#line 193
            __cil_tmp___9 = internal_fnmatch(p, n, string_end, (_Bool )no_leading_period2___0,
                                             flags2___0);
#line 193
            if (__cil_tmp___9 == 0) {
#line 196
              return (0);
            }
          }
#line 192
          n ++;
#line 192
          no_leading_period2___0 = 0;
        }
      }
    }
#line 201
    return (1);
    case 91: 
#line 210
    if (posixly_correct == 0) {
#line 211
      __cil_tmp___10 = getenv("POSIXLY_CORRECT");
#line 211
      posixly_correct = (unsigned int )__cil_tmp___10 != (unsigned int )((void *)0) ? 1 : -1;
    }
#line 213
    if ((unsigned int )n == (unsigned int )string_end) {
#line 214
      return (1);
    }
#line 216
    if ((int const   )*n == 46 && no_leading_period) {
#line 217
      return (1);
    }
#line 219
    if ((int const   )*n == 47 && flags & 1) {
#line 221
      return (1);
    }
#line 223
    not = (_Bool )((int const   )*p == 33 || (posixly_correct < 0 && (int const   )*p == 94));
#line 224
    if (not) {
#line 225
      p ++;
    }
#line 227
    if (flags & (1 << 4)) {
#line 227
      __x___4 = (unsigned char )*n;
#line 227
      fn = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___4))) + (int )__x___4) & 3) == 1 ? ((int )__x___4 - 65) + 97 : (int )__x___4);
    } else {
#line 227
      fn = (unsigned char )*n;
    }
#line 229
    __cil_tmp___11 = p;
#line 229
    p ++;
#line 229
    c = (unsigned char )*__cil_tmp___11;
#line 230
    while (1) {
#line 232
      if (! (flags & (1 << 1)) && (int )c == 92) {
#line 234
        if ((int const   )*p == 0) {
#line 235
          return (1);
        }
#line 236
        if (flags & (1 << 4)) {
#line 236
          __x___5 = (unsigned char )*p;
#line 236
          c = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___5))) + (int )__x___5) & 3) == 1 ? ((int )__x___5 - 65) + 97 : (int )__x___5);
        } else {
#line 236
          c = (unsigned char )*p;
        }
#line 237
        p ++;
#line 239
        goto normal_bracket;
      } else
#line 241
      if ((int )c == 91 && (int const   )*p == 58) {
#line 245
        c1 = 0U;
#line 249
        startp = p;
#line 251
        while (1) {
#line 253
          if (c1 == 256U) {
#line 256
            return (1);
          }
#line 258
          p ++;
#line 258
          c = (unsigned char )*p;
#line 259
          if ((int )c == 58 && (int const   )*(p + 1) == 93) {
#line 261
            p += 2;
#line 262
            break;
          }
#line 264
          if ((int )c < 97 || (int )c >= 122) {
#line 268
            p = startp;
#line 269
            c = (unsigned char )'[';
#line 270
            goto normal_bracket;
          }
#line 272
          __cil_tmp___12 = c1;
#line 272
          c1 ++;
#line 272
          str[__cil_tmp___12] = (char )c;
        }
#line 274
        str[c1] = (char )'\000';
#line 277
        wt = wctype((char const   *)(str));
#line 278
        if (wt == 0) {
#line 280
          return (1);
        }
#line 289
        __cil_tmp___13 = btowc((int )((unsigned char )*n));
#line 289
        __cil_tmp___14 = iswctype(__cil_tmp___13, wt);
#line 289
        if (__cil_tmp___14) {
#line 290
          goto matched;
        }
#line 307
        __cil_tmp___15 = p;
#line 307
        p ++;
#line 307
        c = (unsigned char )*__cil_tmp___15;
      } else
#line 410
      if ((int )c == 0) {
#line 412
        return (1);
      } else {
#line 415
        is_range = (_Bool)0;
#line 592
        if (flags & (1 << 4)) {
#line 592
          __x___6 = c;
#line 592
          c = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___6))) + (int )__x___6) & 3) == 1 ? ((int )__x___6 - 65) + 97 : (int )__x___6);
        } else {
#line 592
          c = c;
        }
        normal_bracket: 
#line 598
        is_range = (_Bool )(((int const   )*p == 45 && (int const   )*(p + 1) != 0) && (int const   )*(p + 1) != 93);
#line 601
        if (! is_range && (int )c == (int )fn) {
#line 602
          goto matched;
        }
#line 610
        cold = (char )c;
#line 611
        __cil_tmp___16 = p;
#line 611
        p ++;
#line 611
        c = (unsigned char )*__cil_tmp___16;
#line 614
        if ((int )c == 45 && (int const   )*p != 93) {
#line 835
          __cil_tmp___17 = p;
#line 835
          p ++;
#line 835
          cend = (unsigned char )*__cil_tmp___17;
#line 837
          if (! (flags & (1 << 1)) && (int )cend == 92) {
#line 838
            __cil_tmp___18 = p;
#line 838
            p ++;
#line 838
            cend = (unsigned char )*__cil_tmp___18;
          }
#line 839
          if ((int )cend == 0) {
#line 840
            return (1);
          }
#line 843
          if ((int )cold <= (int )fn && (int )fn <= (int )cend) {
#line 844
            goto matched;
          }
#line 847
          __cil_tmp___19 = p;
#line 847
          p ++;
#line 847
          c = (unsigned char )*__cil_tmp___19;
        }
      }
#line 851
      if ((int )c == 93) {
#line 852
        break;
      }
    }
#line 855
    if (! not) {
#line 856
      return (1);
    }
#line 857
    break;
    matched: 
#line 861
    while (1) {
      ignore_next: 
#line 864
      __cil_tmp___20 = p;
#line 864
      p ++;
#line 864
      c = (unsigned char )*__cil_tmp___20;
#line 866
      if ((int )c == 0) {
#line 868
        return (1);
      }
#line 870
      if (! (flags & (1 << 1)) && (int )c == 92) {
#line 872
        if ((int const   )*p == 0) {
#line 873
          return (1);
        }
#line 875
        p ++;
      } else
#line 877
      if ((int )c == 91 && (int const   )*p == 58) {
#line 879
        c1___0 = 0;
#line 880
        startp___0 = p;
#line 882
        while (1) {
#line 884
          p ++;
#line 884
          c = (unsigned char )*p;
#line 885
          c1___0 ++;
#line 885
          if (c1___0 == 256) {
#line 886
            return (1);
          }
#line 888
          if ((int const   )*p == 58 && (int const   )*(p + 1) == 93) {
#line 889
            break;
          }
#line 891
          if ((int )c < 97 || (int )c >= 122) {
#line 893
            p = startp___0;
#line 894
            goto ignore_next;
          }
        }
#line 897
        p += 2;
#line 898
        __cil_tmp___21 = p;
#line 898
        p ++;
#line 898
        c = (unsigned char )*__cil_tmp___21;
      } else
#line 900
      if ((int )c == 91 && (int const   )*p == 61) {
#line 902
        p ++;
#line 902
        c = (unsigned char )*p;
#line 903
        if ((int )c == 0) {
#line 904
          return (1);
        }
#line 905
        p ++;
#line 905
        c = (unsigned char )*p;
#line 906
        if ((int )c != 61 || (int const   )*(p + 1) != 93) {
#line 907
          return (1);
        }
#line 908
        p += 2;
#line 909
        __cil_tmp___22 = p;
#line 909
        p ++;
#line 909
        c = (unsigned char )*__cil_tmp___22;
      } else
#line 911
      if ((int )c == 91 && (int const   )*p == 46) {
#line 913
        p ++;
#line 914
        while (1) {
#line 916
          p ++;
#line 916
          c = (unsigned char )*p;
#line 917
          if ((int )c == 0) {
#line 918
            return (1);
          }
#line 920
          if ((int const   )*p == 46 && (int const   )*(p + 1) == 93) {
#line 921
            break;
          }
        }
#line 923
        p += 2;
#line 924
        __cil_tmp___23 = p;
#line 924
        p ++;
#line 924
        c = (unsigned char )*__cil_tmp___23;
      }
#line 861
      if (! ((int )c != 93)) {
#line 861
        break;
      }
    }
#line 928
    if (not) {
#line 929
      return (1);
    }
#line 931
    break;
    case 43: 
    case 64: 
    case 33: 
#line 936
    if (flags & (1 << 5) && (int const   )*p == 40) {
#line 940
      res___1 = ext_match((int )c, p, n, string_end, no_leading_period, flags);
#line 941
      if (res___1 != -1) {
#line 942
        return (res___1);
      }
    }
#line 944
    goto normal_match;
    case 47: 
#line 947
    if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 949
      if ((unsigned int )n == (unsigned int )string_end || (int )c != (int )((unsigned char )*n)) {
#line 950
        return (1);
      }
#line 952
      new_no_leading_period = (_Bool)1;
#line 953
      break;
    }
    normal_match: 
    default: 
#line 958
    if ((unsigned int )n == (unsigned int )string_end) {
#line 959
      return (1);
    } else {
#line 958
      if (flags & (1 << 4)) {
#line 958
        __x___7 = (unsigned char )*n;
#line 958
        __cil_tmp___24 = ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___7))) + (int )__x___7) & 3) == 1 ? ((int )__x___7 - 65) + 97 : (int )__x___7;
      } else {
#line 958
        __cil_tmp___24 = (int )((unsigned char )*n);
      }
#line 958
      if ((int )c != __cil_tmp___24) {
#line 959
        return (1);
      }
    }
    }
#line 962
    no_leading_period = new_no_leading_period;
#line 963
    n ++;
  }
#line 966
  if ((unsigned int )n == (unsigned int )string_end) {
#line 967
    return (0);
  }
#line 969
  if ((flags & (1 << 3) && (unsigned int )n != (unsigned int )string_end) && (int const   )*n == 47) {
#line 971
    return (0);
  }
#line 973
  return (1);
}
}
#line 977 "fnmatch_loop.c"
static char const   *end_pattern(char const   *pattern ) 
{ char const   *p ;
  char *__cil_tmp ;
  char const   *__cil_tmp___0 ;

  {
#line 981
  p = pattern;
#line 983
  while (1) {
#line 984
    p ++;
#line 984
    if ((int const   )*p == 0) {
#line 986
      return (pattern);
    } else
#line 987
    if ((int const   )*p == 91) {
#line 990
      if (posixly_correct == 0) {
#line 991
        __cil_tmp = getenv("POSIXLY_CORRECT");
#line 991
        posixly_correct = (unsigned int )__cil_tmp != (unsigned int )((void *)0) ? 1 : -1;
      }
#line 995
      p ++;
#line 995
      if ((int const   )*p == 33 || (posixly_correct < 0 && (int const   )*p == 94)) {
#line 996
        p ++;
      }
#line 998
      if ((int const   )*p == 93) {
#line 999
        p ++;
      }
#line 1001
      while ((int const   )*p != 93) {
#line 1002
        __cil_tmp___0 = p;
#line 1002
        p ++;
#line 1002
        if ((int const   )*__cil_tmp___0 == 0) {
#line 1004
          return (pattern);
        }
      }
    } else
#line 1006
    if ((((((int const   )*p == 63 || (int const   )*p == 42) || (int const   )*p == 43) || (int const   )*p == 64) || (int const   )*p == 33) && (int const   )*(p + 1) == 40) {
#line 1008
      p = end_pattern(p + 1);
    } else
#line 1009
    if ((int const   )*p == 41) {
#line 1010
      break;
    }
  }
#line 1012
  return (p + 1);
}
}
#line 1016 "fnmatch_loop.c"
static int ext_match(int opt , char const   *pattern , char const   *string , char const   *string_end ,
                     _Bool no_leading_period , int flags ) 
{ char const   *startp ;
  size_t level ;
  struct patternlist *list ;
  struct patternlist **lastp ;
  size_t pattern_len ;
  size_t __cil_tmp ;
  char const   *p ;
  char const   *rs ;
  char *__cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  struct patternlist *newp ;
  size_t plen ;
  size_t plensize ;
  size_t newpsize ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  struct patternlist *newp___0 ;
  size_t plen___0 ;
  size_t plensize___0 ;
  size_t newpsize___0 ;
  void *__cil_tmp___5 ;
  void *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  char *__cil_tmp___12 ;
  int __cil_tmp___13 ;
  struct patternlist *runp ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;

  {
#line 1023
  list = (struct patternlist *)((void *)0);
#line 1028
  lastp = & list;
#line 1029
  __cil_tmp = strlen(pattern);
#line 1029
  pattern_len = __cil_tmp;
#line 1035
  level = 0U;
#line 1036
  p = pattern + 1;
#line 1036
  startp = p;
#line 1036
  while (1) {
#line 1037
    if ((int const   )*p == 0) {
#line 1039
      return (-1);
    } else
#line 1040
    if ((int const   )*p == 91) {
#line 1043
      if (posixly_correct == 0) {
#line 1044
        __cil_tmp___0 = getenv("POSIXLY_CORRECT");
#line 1044
        posixly_correct = (unsigned int )__cil_tmp___0 != (unsigned int )((void *)0) ? 1 : -1;
      }
#line 1048
      p ++;
#line 1048
      if ((int const   )*p == 33 || (posixly_correct < 0 && (int const   )*p == 94)) {
#line 1049
        p ++;
      }
#line 1051
      if ((int const   )*p == 93) {
#line 1052
        p ++;
      }
#line 1054
      while ((int const   )*p != 93) {
#line 1055
        __cil_tmp___1 = p;
#line 1055
        p ++;
#line 1055
        if ((int const   )*__cil_tmp___1 == 0) {
#line 1057
          return (-1);
        }
      }
    } else
#line 1059
    if ((((((int const   )*p == 63 || (int const   )*p == 42) || (int const   )*p == 43) || (int const   )*p == 64) || (int const   )*p == 33) && (int const   )*(p + 1) == 40) {
#line 1062
      level ++;
    } else
#line 1063
    if ((int const   )*p == 41) {
#line 1065
      __cil_tmp___4 = level;
#line 1065
      level --;
#line 1065
      if (__cil_tmp___4 == 0U) {
#line 1088
        plen = opt == 63 || opt == 64 ? pattern_len : (unsigned int )((p - startp) + 1);
#line 1088
        plensize = plen * sizeof(char );
#line 1088
        newpsize = (unsigned int )((char *)(& ((struct patternlist *)0)->str)) + plensize;
#line 1088
        if ((4294967295U / sizeof(char ) < plen || newpsize < (unsigned int )((char *)(& ((struct patternlist *)0)->str))) || 8000U <= newpsize) {
#line 1088
          return (-1);
        }
#line 1088
        __cil_tmp___2 = __builtin_alloca(newpsize);
#line 1088
        newp = (struct patternlist *)__cil_tmp___2;
#line 1088
        __cil_tmp___3 = mempcpy((void *)(newp->str), (void const   *)startp, (unsigned int )(p - startp));
#line 1088
        *((char *)__cil_tmp___3) = (char )'\000';
#line 1088
        newp->next = (struct patternlist *)((void *)0);
#line 1088
        *lastp = newp;
#line 1088
        lastp = & newp->next;
#line 1089
        break;
      }
    } else
#line 1092
    if ((int const   )*p == 124) {
#line 1094
      if (level == 0U) {
#line 1096
        plen___0 = opt == 63 || opt == 64 ? pattern_len : (unsigned int )((p - startp) + 1);
#line 1096
        plensize___0 = plen___0 * sizeof(char );
#line 1096
        newpsize___0 = (unsigned int )((char *)(& ((struct patternlist *)0)->str)) + plensize___0;
#line 1096
        if ((4294967295U / sizeof(char ) < plen___0 || newpsize___0 < (unsigned int )((char *)(& ((struct patternlist *)0)->str))) || 8000U <= newpsize___0) {
#line 1096
          return (-1);
        }
#line 1096
        __cil_tmp___5 = __builtin_alloca(newpsize___0);
#line 1096
        newp___0 = (struct patternlist *)__cil_tmp___5;
#line 1096
        __cil_tmp___6 = mempcpy((void *)(newp___0->str), (void const   *)startp, (unsigned int )(p - startp));
#line 1096
        *((char *)__cil_tmp___6) = (char )'\000';
#line 1096
        newp___0->next = (struct patternlist *)((void *)0);
#line 1096
        *lastp = newp___0;
#line 1096
        lastp = & newp___0->next;
#line 1097
        startp = p + 1;
      }
    }
#line 1036
    p ++;
  }
#line 1100
  if (((unsigned int )list != (unsigned int )((void *)0)) == 0) {
#line 1100
    __libc_failwith((char *)"Assertion failed: list != NULL at fnmatch_loop.c:1100");
  }
#line 1101
  if (((int const   )*(p + -1) == 41) == 0) {
#line 1101
    __libc_failwith((char *)"Assertion failed: p[-1] == L_(\')\') at fnmatch_loop.c:1101");
  }
#line 1104
  switch (opt) {
  case 42: 
#line 1107
  __cil_tmp___7 = internal_fnmatch(p, string, string_end, no_leading_period, flags);
#line 1107
  if (__cil_tmp___7 == 0) {
#line 1108
    return (0);
  }
  case 43: 
#line 1112
  while (1) {
#line 1114
    rs = string;
#line 1114
    while ((unsigned int )rs <= (unsigned int )string_end) {
#line 1117
      __cil_tmp___8 = internal_fnmatch((char const   *)(list->str), string, rs, no_leading_period,
                                       flags & 1 ? flags : flags & ~ (1 << 2));
#line 1117
      if (__cil_tmp___8 == 0) {
#line 1117
        __cil_tmp___9 = internal_fnmatch(p, rs, string_end, (_Bool )((unsigned int )rs == (unsigned int )string ? (int )no_leading_period : (int const   )*(rs + -1) == 47 && (flags & (1 | (1 << 2))) == (1 | (1 << 2))),
                                         flags & 1 ? flags : flags & ~ (1 << 2));
#line 1117
        if (__cil_tmp___9 == 0) {
#line 1136
          return (0);
        } else
#line 1117
        if ((unsigned int )rs != (unsigned int )string) {
#line 1117
          __cil_tmp___10 = internal_fnmatch(pattern - 1, rs, string_end, (_Bool )((unsigned int )rs == (unsigned int )string ? (int )no_leading_period : (int const   )*(rs + -1) == 47 && (flags & (1 | (1 << 2))) == (1 | (1 << 2))),
                                            flags & 1 ? flags : flags & ~ (1 << 2));
#line 1117
          if (__cil_tmp___10 == 0) {
#line 1136
            return (0);
          }
        }
      }
#line 1114
      rs ++;
    }
#line 1112
    list = list->next;
#line 1112
    if (! ((unsigned int )list != (unsigned int )((void *)0))) {
#line 1112
      break;
    }
  }
#line 1141
  return (1);
  case 63: 
#line 1144
  __cil_tmp___11 = internal_fnmatch(p, string, string_end, no_leading_period, flags);
#line 1144
  if (__cil_tmp___11 == 0) {
#line 1145
    return (0);
  }
  case 64: 
#line 1149
  while (1) {
#line 1154
    __cil_tmp___12 = strcat(list->str, p);
#line 1154
    __cil_tmp___13 = internal_fnmatch((char const   *)__cil_tmp___12, string, string_end,
                                      no_leading_period, flags & 1 ? flags : flags & ~ (1 << 2));
#line 1154
    if (__cil_tmp___13 == 0) {
#line 1158
      return (0);
    }
#line 1149
    list = list->next;
#line 1149
    if (! ((unsigned int )list != (unsigned int )((void *)0))) {
#line 1149
      break;
    }
  }
#line 1162
  return (1);
  case 33: 
#line 1165
  rs = string;
#line 1165
  while ((unsigned int )rs <= (unsigned int )string_end) {
#line 1169
    runp = list;
#line 1169
    while ((unsigned int )runp != (unsigned int )((void *)0)) {
#line 1170
      __cil_tmp___14 = internal_fnmatch((char const   *)(runp->str), string, rs, no_leading_period,
                                        flags & 1 ? flags : flags & ~ (1 << 2));
#line 1170
      if (__cil_tmp___14 == 0) {
#line 1172
        break;
      }
#line 1169
      runp = runp->next;
    }
#line 1175
    if ((unsigned int )runp == (unsigned int )((void *)0)) {
#line 1175
      __cil_tmp___15 = internal_fnmatch(p, rs, string_end, (_Bool )((unsigned int )rs == (unsigned int )string ? (int )no_leading_period : (int const   )*(rs + -1) == 47 && (flags & (1 | (1 << 2))) == (1 | (1 << 2))),
                                        flags & 1 ? flags : flags & ~ (1 << 2));
#line 1175
      if (__cil_tmp___15 == 0) {
#line 1183
        return (0);
      }
    }
#line 1165
    rs ++;
  }
#line 1188
  return (1);
  default: 
#line 1191
  __libc_failwith((char *)"Assertion failed: ! \"Invalid extended matching operator\" at fnmatch_loop.c:1191");
#line 1192
  break;
  }
#line 1195
  return (-1);
}
}
#line 212 "fnmatch.c"
static wctype_t is_char_class(wchar_t const   *wcs ) 
{ char s[257] ;
  char *cp ;
  char *__cil_tmp ;
  wchar_t const   *__cil_tmp___0 ;
  wctype_t __cil_tmp___1 ;

  {
#line 216
  cp = s;
#line 218
  while (1) {
#line 226
    switch ((int )*wcs) {
    case 32: 
    case 33: 
    case 34: 
    case 35: 
    case 37: 
    case 38: 
    case 39: 
    case 40: 
    case 41: 
    case 42: 
    case 43: 
    case 44: 
    case 45: 
    case 46: 
    case 47: 
    case 48: 
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    case 58: 
    case 59: 
    case 60: 
    case 61: 
    case 62: 
    case 63: 
    case 65: 
    case 66: 
    case 67: 
    case 68: 
    case 69: 
    case 70: 
    case 71: 
    case 72: 
    case 73: 
    case 74: 
    case 75: 
    case 76: 
    case 77: 
    case 78: 
    case 79: 
    case 80: 
    case 81: 
    case 82: 
    case 83: 
    case 84: 
    case 85: 
    case 86: 
    case 87: 
    case 88: 
    case 89: 
    case 90: 
    case 91: 
    case 92: 
    case 93: 
    case 94: 
    case 95: 
    case 97: 
    case 98: 
    case 99: 
    case 100: 
    case 101: 
    case 102: 
    case 103: 
    case 104: 
    case 105: 
    case 106: 
    case 107: 
    case 108: 
    case 109: 
    case 110: 
    case 111: 
    case 112: 
    case 113: 
    case 114: 
    case 115: 
    case 116: 
    case 117: 
    case 118: 
    case 119: 
    case 120: 
    case 121: 
    case 122: 
    case 123: 
    case 124: 
    case 125: 
    case 126: 
#line 248
    break;
    default: 
#line 250
    return (0);
    }
#line 255
    if ((unsigned int )cp == (unsigned int )(s + 256)) {
#line 256
      return (0);
    }
#line 258
    __cil_tmp = cp;
#line 258
    cp ++;
#line 258
    __cil_tmp___0 = wcs;
#line 258
    wcs ++;
#line 258
    *__cil_tmp = (char )*__cil_tmp___0;
#line 218
    if (! ((int const   )*wcs != 0)) {
#line 218
      break;
    }
  }
#line 262
  *cp = (char )'\000';
#line 267
  __cil_tmp___1 = wctype((char const   *)(s));
#line 267
  return (__cil_tmp___1);
}
}
#line 23 "fnmatch_loop.c"
static int ext_wmatch(wint_t opt , wchar_t const   *pattern , wchar_t const   *string ,
                      wchar_t const   *string_end , _Bool no_leading_period , int flags ) ;
#line 26
static wchar_t const   *end_wpattern(wchar_t const   *pattern ) ;
#line 28 "fnmatch_loop.c"
static int internal_fnwmatch(wchar_t const   *pattern , wchar_t const   *string ,
                             wchar_t const   *string_end , _Bool no_leading_period ,
                             int flags ) 
{ register wchar_t const   *p ;
  register wchar_t const   *n ;
  register wint_t c ;
  _Bool new_no_leading_period ;
  wint_t __cil_tmp ;
  int res ;
  wchar_t const   *__cil_tmp___0 ;
  wint_t __cil_tmp___1 ;
  wint_t __cil_tmp___2 ;
  wint_t __cil_tmp___3 ;
  int res___0 ;
  wchar_t const   *__cil_tmp___4 ;
  wchar_t const   *__cil_tmp___5 ;
  wchar_t const   *endp ;
  wchar_t const   *__cil_tmp___6 ;
  int result ;
  wchar_t *__cil_tmp___7 ;
  wchar_t const   *endp___0 ;
  wchar_t *__cil_tmp___8 ;
  int flags2 ;
  _Bool no_leading_period2 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int flags2___0 ;
  int no_leading_period2___0 ;
  wint_t __cil_tmp___11 ;
  wint_t __cil_tmp___12 ;
  wint_t __cil_tmp___13 ;
  int __cil_tmp___14 ;
  register _Bool not ;
  wchar_t cold ;
  wint_t fn ;
  char *__cil_tmp___15 ;
  wint_t __cil_tmp___16 ;
  wchar_t const   *__cil_tmp___17 ;
  wint_t __cil_tmp___18 ;
  wchar_t str[257] ;
  size_t c1 ;
  wctype_t wt ;
  wchar_t const   *startp ;
  size_t __cil_tmp___19 ;
  int __cil_tmp___20 ;
  wchar_t const   *__cil_tmp___21 ;
  _Bool is_range ;
  wint_t __cil_tmp___22 ;
  wchar_t const   *__cil_tmp___23 ;
  wint_t cend ;
  wchar_t const   *__cil_tmp___24 ;
  wchar_t const   *__cil_tmp___25 ;
  wchar_t const   *__cil_tmp___26 ;
  wchar_t const   *__cil_tmp___27 ;
  int c1___0 ;
  wchar_t const   *startp___0 ;
  wchar_t const   *__cil_tmp___28 ;
  wchar_t const   *__cil_tmp___29 ;
  wchar_t const   *__cil_tmp___30 ;
  int res___1 ;
  wint_t __cil_tmp___31 ;
  wint_t __cil_tmp___32 ;
  wchar_t const   *__cil_tmp___33 ;

  {
#line 33
  p = pattern;
#line 33
  n = string;
#line 45
  while (1) {
#line 45
    __cil_tmp___33 = p;
#line 45
    p ++;
#line 45
    c = (int )*__cil_tmp___33;
#line 45
    if (! (c != 0)) {
#line 45
      break;
    }
#line 47
    new_no_leading_period = (_Bool)0;
#line 48
    if (flags & (1 << 4)) {
#line 48
      __cil_tmp = towlower(c);
#line 48
      c = __cil_tmp;
    } else {
#line 48
      c = c;
    }
#line 50
    switch (c) {
    case 63: 
#line 53
    if (flags & (1 << 5) && (int const   )*p == 40) {
#line 57
      res = ext_wmatch(c, p, n, string_end, no_leading_period, flags);
#line 59
      if (res != -1) {
#line 60
        return (res);
      }
    }
#line 63
    if ((unsigned int )n == (unsigned int )string_end) {
#line 64
      return (1);
    } else
#line 65
    if ((int const   )*n == 47 && flags & 1) {
#line 66
      return (1);
    } else
#line 67
    if ((int const   )*n == 46 && no_leading_period) {
#line 68
      return (1);
    }
#line 69
    break;
    case 92: 
#line 72
    if (! (flags & (1 << 1))) {
#line 74
      __cil_tmp___0 = p;
#line 74
      p ++;
#line 74
      c = (int )*__cil_tmp___0;
#line 75
      if (c == 0) {
#line 77
        return (1);
      }
#line 78
      if (flags & (1 << 4)) {
#line 78
        __cil_tmp___1 = towlower(c);
#line 78
        c = __cil_tmp___1;
      } else {
#line 78
        c = c;
      }
    }
#line 80
    if ((unsigned int )n == (unsigned int )string_end) {
#line 81
      return (1);
    } else {
#line 80
      if (flags & (1 << 4)) {
#line 80
        __cil_tmp___2 = towlower((int )*n);
#line 80
        __cil_tmp___3 = __cil_tmp___2;
      } else {
#line 80
        __cil_tmp___3 = (int )*n;
      }
#line 80
      if (__cil_tmp___3 != c) {
#line 81
        return (1);
      }
    }
#line 82
    break;
    case 42: 
#line 85
    if (flags & (1 << 5) && (int const   )*p == 40) {
#line 89
      res___0 = ext_wmatch(c, p, n, string_end, no_leading_period, flags);
#line 91
      if (res___0 != -1) {
#line 92
        return (res___0);
      }
    }
#line 95
    if (((unsigned int )n != (unsigned int )string_end && (int const   )*n == 46) && no_leading_period) {
#line 96
      return (1);
    }
#line 98
    __cil_tmp___4 = p;
#line 98
    p ++;
#line 98
    c = (int )*__cil_tmp___4;
#line 98
    while (c == 63 || c == 42) {
#line 100
      if ((int const   )*p == 40 && (flags & (1 << 5)) != 0) {
#line 102
        __cil_tmp___6 = end_wpattern(p);
#line 102
        endp = __cil_tmp___6;
#line 103
        if ((unsigned int )endp != (unsigned int )p) {
#line 106
          p = endp;
#line 107
          goto __Cont;
        }
      }
#line 111
      if (c == 63) {
#line 114
        if ((unsigned int )n == (unsigned int )string_end) {
#line 116
          return (1);
        } else
#line 117
        if ((int const   )*n == 47 && flags & 1) {
#line 121
          return (1);
        } else {
#line 126
          n ++;
        }
      }
      __Cont: 
#line 98
      __cil_tmp___5 = p;
#line 98
      p ++;
#line 98
      c = (int )*__cil_tmp___5;
    }
#line 130
    if (c == 0) {
#line 136
      result = (flags & 1) == 0 ? 0 : 1;
#line 138
      if (flags & 1) {
#line 140
        if (flags & (1 << 3)) {
#line 141
          result = 0;
        } else {
#line 144
          __cil_tmp___7 = wmemchr(n, (short)47, (unsigned int )(string_end - n));
#line 144
          if ((unsigned int )__cil_tmp___7 == (unsigned int )((void *)0)) {
#line 145
            result = 0;
          }
        }
      }
#line 149
      return (result);
    } else {
#line 155
      __cil_tmp___8 = wmemchr(n, (short )(flags & 1 ? 47 : 0), (unsigned int )(string_end - n));
#line 155
      endp___0 = (wchar_t const   *)__cil_tmp___8;
#line 157
      if ((unsigned int )endp___0 == (unsigned int )((void *)0)) {
#line 158
        endp___0 = string_end;
      }
#line 160
      if (c == 91 || (((flags & (1 << 5)) != 0 && ((c == 64 || c == 43) || c == 33)) && (int const   )*p == 40)) {
#line 165
        flags2 = flags & 1 ? flags : flags & ~ (1 << 2);
#line 167
        no_leading_period2 = no_leading_period;
#line 169
        p --;
#line 169
        while ((unsigned int )n < (unsigned int )endp___0) {
#line 170
          __cil_tmp___9 = internal_fnwmatch(p, n, string_end, no_leading_period2,
                                            flags2);
#line 170
          if (__cil_tmp___9 == 0) {
#line 172
            return (0);
          }
#line 169
          n ++;
#line 169
          no_leading_period2 = (_Bool)0;
        }
      } else
#line 174
      if (c == 47 && flags & 1) {
#line 176
        while ((unsigned int )n < (unsigned int )string_end && (int const   )*n != 47) {
#line 177
          n ++;
        }
#line 178
        if ((unsigned int )n < (unsigned int )string_end && (int const   )*n == 47) {
#line 178
          __cil_tmp___10 = internal_fnwmatch(p, n + 1, string_end, (_Bool )(flags & (1 << 2)),
                                             flags);
#line 178
          if (__cil_tmp___10 == 0) {
#line 181
            return (0);
          }
        }
      } else {
#line 185
        flags2___0 = flags & 1 ? flags : flags & ~ (1 << 2);
#line 187
        no_leading_period2___0 = (int )no_leading_period;
#line 189
        if (c == 92 && ! (flags & (1 << 1))) {
#line 190
          c = (int )*p;
        }
#line 191
        if (flags & (1 << 4)) {
#line 191
          __cil_tmp___11 = towlower(c);
#line 191
          c = __cil_tmp___11;
        } else {
#line 191
          c = c;
        }
#line 192
        p --;
#line 192
        while ((unsigned int )n < (unsigned int )endp___0) {
#line 193
          if (flags & (1 << 4)) {
#line 193
            __cil_tmp___12 = towlower((int )*n);
#line 193
            __cil_tmp___13 = __cil_tmp___12;
          } else {
#line 193
            __cil_tmp___13 = (int )*n;
          }
#line 193
          if (__cil_tmp___13 == c) {
#line 193
            __cil_tmp___14 = internal_fnwmatch(p, n, string_end, (_Bool )no_leading_period2___0,
                                               flags2___0);
#line 193
            if (__cil_tmp___14 == 0) {
#line 196
              return (0);
            }
          }
#line 192
          n ++;
#line 192
          no_leading_period2___0 = 0;
        }
      }
    }
#line 201
    return (1);
    case 91: 
#line 210
    if (posixly_correct == 0) {
#line 211
      __cil_tmp___15 = getenv("POSIXLY_CORRECT");
#line 211
      posixly_correct = (unsigned int )__cil_tmp___15 != (unsigned int )((void *)0) ? 1 : -1;
    }
#line 213
    if ((unsigned int )n == (unsigned int )string_end) {
#line 214
      return (1);
    }
#line 216
    if ((int const   )*n == 46 && no_leading_period) {
#line 217
      return (1);
    }
#line 219
    if ((int const   )*n == 47 && flags & 1) {
#line 221
      return (1);
    }
#line 223
    not = (_Bool )((int const   )*p == 33 || (posixly_correct < 0 && (int const   )*p == 94));
#line 224
    if (not) {
#line 225
      p ++;
    }
#line 227
    if (flags & (1 << 4)) {
#line 227
      __cil_tmp___16 = towlower((int )*n);
#line 227
      fn = __cil_tmp___16;
    } else {
#line 227
      fn = (int )*n;
    }
#line 229
    __cil_tmp___17 = p;
#line 229
    p ++;
#line 229
    c = (int )*__cil_tmp___17;
#line 230
    while (1) {
#line 232
      if (! (flags & (1 << 1)) && c == 92) {
#line 234
        if ((int const   )*p == 0) {
#line 235
          return (1);
        }
#line 236
        if (flags & (1 << 4)) {
#line 236
          __cil_tmp___18 = towlower((int )*p);
#line 236
          c = __cil_tmp___18;
        } else {
#line 236
          c = (int )*p;
        }
#line 237
        p ++;
#line 239
        goto normal_bracket;
      } else
#line 241
      if (c == 91 && (int const   )*p == 58) {
#line 245
        c1 = 0U;
#line 249
        startp = p;
#line 251
        while (1) {
#line 253
          if (c1 == 256U) {
#line 256
            return (1);
          }
#line 258
          p ++;
#line 258
          c = (int )*p;
#line 259
          if (c == 58 && (int const   )*(p + 1) == 93) {
#line 261
            p += 2;
#line 262
            break;
          }
#line 264
          if (c < 97 || c >= 122) {
#line 268
            p = startp;
#line 269
            c = 91;
#line 270
            goto normal_bracket;
          }
#line 272
          __cil_tmp___19 = c1;
#line 272
          c1 ++;
#line 272
          str[__cil_tmp___19] = (short )c;
        }
#line 274
        str[c1] = (short)0;
#line 277
        wt = is_char_class((wchar_t const   *)(str));
#line 278
        if (wt == 0) {
#line 280
          return (1);
        }
#line 289
        __cil_tmp___20 = iswctype((int )*n, wt);
#line 289
        if (__cil_tmp___20) {
#line 290
          goto matched;
        }
#line 307
        __cil_tmp___21 = p;
#line 307
        p ++;
#line 307
        c = (int )*__cil_tmp___21;
      } else
#line 410
      if (c == 0) {
#line 412
        return (1);
      } else {
#line 415
        is_range = (_Bool)0;
#line 592
        if (flags & (1 << 4)) {
#line 592
          __cil_tmp___22 = towlower(c);
#line 592
          c = __cil_tmp___22;
        } else {
#line 592
          c = c;
        }
        normal_bracket: 
#line 598
        is_range = (_Bool )(((int const   )*p == 45 && (int const   )*(p + 1) != 0) && (int const   )*(p + 1) != 93);
#line 601
        if (! is_range && c == fn) {
#line 602
          goto matched;
        }
#line 610
        cold = (short )c;
#line 611
        __cil_tmp___23 = p;
#line 611
        p ++;
#line 611
        c = (int )*__cil_tmp___23;
#line 614
        if (c == 45 && (int const   )*p != 93) {
#line 835
          __cil_tmp___24 = p;
#line 835
          p ++;
#line 835
          cend = (int )*__cil_tmp___24;
#line 837
          if (! (flags & (1 << 1)) && cend == 92) {
#line 838
            __cil_tmp___25 = p;
#line 838
            p ++;
#line 838
            cend = (int )*__cil_tmp___25;
          }
#line 839
          if (cend == 0) {
#line 840
            return (1);
          }
#line 843
          if ((int )cold <= fn && fn <= cend) {
#line 844
            goto matched;
          }
#line 847
          __cil_tmp___26 = p;
#line 847
          p ++;
#line 847
          c = (int )*__cil_tmp___26;
        }
      }
#line 851
      if (c == 93) {
#line 852
        break;
      }
    }
#line 855
    if (! not) {
#line 856
      return (1);
    }
#line 857
    break;
    matched: 
#line 861
    while (1) {
      ignore_next: 
#line 864
      __cil_tmp___27 = p;
#line 864
      p ++;
#line 864
      c = (int )*__cil_tmp___27;
#line 866
      if (c == 0) {
#line 868
        return (1);
      }
#line 870
      if (! (flags & (1 << 1)) && c == 92) {
#line 872
        if ((int const   )*p == 0) {
#line 873
          return (1);
        }
#line 875
        p ++;
      } else
#line 877
      if (c == 91 && (int const   )*p == 58) {
#line 879
        c1___0 = 0;
#line 880
        startp___0 = p;
#line 882
        while (1) {
#line 884
          p ++;
#line 884
          c = (int )*p;
#line 885
          c1___0 ++;
#line 885
          if (c1___0 == 256) {
#line 886
            return (1);
          }
#line 888
          if ((int const   )*p == 58 && (int const   )*(p + 1) == 93) {
#line 889
            break;
          }
#line 891
          if (c < 97 || c >= 122) {
#line 893
            p = startp___0;
#line 894
            goto ignore_next;
          }
        }
#line 897
        p += 2;
#line 898
        __cil_tmp___28 = p;
#line 898
        p ++;
#line 898
        c = (int )*__cil_tmp___28;
      } else
#line 900
      if (c == 91 && (int const   )*p == 61) {
#line 902
        p ++;
#line 902
        c = (int )*p;
#line 903
        if (c == 0) {
#line 904
          return (1);
        }
#line 905
        p ++;
#line 905
        c = (int )*p;
#line 906
        if (c != 61 || (int const   )*(p + 1) != 93) {
#line 907
          return (1);
        }
#line 908
        p += 2;
#line 909
        __cil_tmp___29 = p;
#line 909
        p ++;
#line 909
        c = (int )*__cil_tmp___29;
      } else
#line 911
      if (c == 91 && (int const   )*p == 46) {
#line 913
        p ++;
#line 914
        while (1) {
#line 916
          p ++;
#line 916
          c = (int )*p;
#line 917
          if (c == 0) {
#line 918
            return (1);
          }
#line 920
          if ((int const   )*p == 46 && (int const   )*(p + 1) == 93) {
#line 921
            break;
          }
        }
#line 923
        p += 2;
#line 924
        __cil_tmp___30 = p;
#line 924
        p ++;
#line 924
        c = (int )*__cil_tmp___30;
      }
#line 861
      if (! (c != 93)) {
#line 861
        break;
      }
    }
#line 928
    if (not) {
#line 929
      return (1);
    }
#line 931
    break;
    case 43: 
    case 64: 
    case 33: 
#line 936
    if (flags & (1 << 5) && (int const   )*p == 40) {
#line 940
      res___1 = ext_wmatch(c, p, n, string_end, no_leading_period, flags);
#line 941
      if (res___1 != -1) {
#line 942
        return (res___1);
      }
    }
#line 944
    goto normal_match;
    case 47: 
#line 947
    if ((flags & (1 | (1 << 2))) == (1 | (1 << 2))) {
#line 949
      if ((unsigned int )n == (unsigned int )string_end || c != (int )*n) {
#line 950
        return (1);
      }
#line 952
      new_no_leading_period = (_Bool)1;
#line 953
      break;
    }
    normal_match: 
    default: 
#line 958
    if ((unsigned int )n == (unsigned int )string_end) {
#line 959
      return (1);
    } else {
#line 958
      if (flags & (1 << 4)) {
#line 958
        __cil_tmp___31 = towlower((int )*n);
#line 958
        __cil_tmp___32 = __cil_tmp___31;
      } else {
#line 958
        __cil_tmp___32 = (int )*n;
      }
#line 958
      if (c != __cil_tmp___32) {
#line 959
        return (1);
      }
    }
    }
#line 962
    no_leading_period = new_no_leading_period;
#line 963
    n ++;
  }
#line 966
  if ((unsigned int )n == (unsigned int )string_end) {
#line 967
    return (0);
  }
#line 969
  if ((flags & (1 << 3) && (unsigned int )n != (unsigned int )string_end) && (int const   )*n == 47) {
#line 971
    return (0);
  }
#line 973
  return (1);
}
}
#line 977 "fnmatch_loop.c"
static wchar_t const   *end_wpattern(wchar_t const   *pattern ) 
{ wchar_t const   *p ;
  char *__cil_tmp ;
  wchar_t const   *__cil_tmp___0 ;

  {
#line 981
  p = pattern;
#line 983
  while (1) {
#line 984
    p ++;
#line 984
    if ((int const   )*p == 0) {
#line 986
      return (pattern);
    } else
#line 987
    if ((int const   )*p == 91) {
#line 990
      if (posixly_correct == 0) {
#line 991
        __cil_tmp = getenv("POSIXLY_CORRECT");
#line 991
        posixly_correct = (unsigned int )__cil_tmp != (unsigned int )((void *)0) ? 1 : -1;
      }
#line 995
      p ++;
#line 995
      if ((int const   )*p == 33 || (posixly_correct < 0 && (int const   )*p == 94)) {
#line 996
        p ++;
      }
#line 998
      if ((int const   )*p == 93) {
#line 999
        p ++;
      }
#line 1001
      while ((int const   )*p != 93) {
#line 1002
        __cil_tmp___0 = p;
#line 1002
        p ++;
#line 1002
        if ((int const   )*__cil_tmp___0 == 0) {
#line 1004
          return (pattern);
        }
      }
    } else
#line 1006
    if ((((((int const   )*p == 63 || (int const   )*p == 42) || (int const   )*p == 43) || (int const   )*p == 64) || (int const   )*p == 33) && (int const   )*(p + 1) == 40) {
#line 1008
      p = end_wpattern(p + 1);
    } else
#line 1009
    if ((int const   )*p == 41) {
#line 1010
      break;
    }
  }
#line 1012
  return (p + 1);
}
}
#line 1016 "fnmatch_loop.c"
static int ext_wmatch(wint_t opt , wchar_t const   *pattern , wchar_t const   *string ,
                      wchar_t const   *string_end , _Bool no_leading_period , int flags ) 
{ wchar_t const   *startp ;
  size_t level ;
  struct patternlist___0 *list ;
  struct patternlist___0 **lastp ;
  size_t pattern_len ;
  size_t __cil_tmp ;
  wchar_t const   *p ;
  wchar_t const   *rs ;
  char *__cil_tmp___0 ;
  wchar_t const   *__cil_tmp___1 ;
  struct patternlist___0 *newp ;
  size_t plen ;
  size_t plensize ;
  size_t newpsize ;
  void *__cil_tmp___2 ;
  wchar_t *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  struct patternlist___0 *newp___0 ;
  size_t plen___0 ;
  size_t plensize___0 ;
  size_t newpsize___0 ;
  void *__cil_tmp___5 ;
  wchar_t *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  wchar_t *__cil_tmp___12 ;
  int __cil_tmp___13 ;
  struct patternlist___0 *runp ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;

  {
#line 1023
  list = (struct patternlist___0 *)((void *)0);
#line 1028
  lastp = & list;
#line 1029
  __cil_tmp = wcslen(pattern);
#line 1029
  pattern_len = __cil_tmp;
#line 1035
  level = 0U;
#line 1036
  p = pattern + 1;
#line 1036
  startp = p;
#line 1036
  while (1) {
#line 1037
    if ((int const   )*p == 0) {
#line 1039
      return (-1);
    } else
#line 1040
    if ((int const   )*p == 91) {
#line 1043
      if (posixly_correct == 0) {
#line 1044
        __cil_tmp___0 = getenv("POSIXLY_CORRECT");
#line 1044
        posixly_correct = (unsigned int )__cil_tmp___0 != (unsigned int )((void *)0) ? 1 : -1;
      }
#line 1048
      p ++;
#line 1048
      if ((int const   )*p == 33 || (posixly_correct < 0 && (int const   )*p == 94)) {
#line 1049
        p ++;
      }
#line 1051
      if ((int const   )*p == 93) {
#line 1052
        p ++;
      }
#line 1054
      while ((int const   )*p != 93) {
#line 1055
        __cil_tmp___1 = p;
#line 1055
        p ++;
#line 1055
        if ((int const   )*__cil_tmp___1 == 0) {
#line 1057
          return (-1);
        }
      }
    } else
#line 1059
    if ((((((int const   )*p == 63 || (int const   )*p == 42) || (int const   )*p == 43) || (int const   )*p == 64) || (int const   )*p == 33) && (int const   )*(p + 1) == 40) {
#line 1062
      level ++;
    } else
#line 1063
    if ((int const   )*p == 41) {
#line 1065
      __cil_tmp___4 = level;
#line 1065
      level --;
#line 1065
      if (__cil_tmp___4 == 0U) {
#line 1088
        plen = opt == 63 || opt == 64 ? pattern_len : (unsigned int )((p - startp) + 1);
#line 1088
        plensize = plen * sizeof(wchar_t );
#line 1088
        newpsize = (unsigned int )((char *)(& ((struct patternlist___0 *)0)->str)) + plensize;
#line 1088
        if ((4294967295U / sizeof(wchar_t ) < plen || newpsize < (unsigned int )((char *)(& ((struct patternlist___0 *)0)->str))) || 8000U <= newpsize) {
#line 1088
          return (-1);
        }
#line 1088
        __cil_tmp___2 = __builtin_alloca(newpsize);
#line 1088
        newp = (struct patternlist___0 *)__cil_tmp___2;
#line 1088
        __cil_tmp___3 = wmemcpy(newp->str, startp, (unsigned int )(p - startp));
#line 1088
        *(__cil_tmp___3 + (p - startp)) = (short)0;
#line 1088
        newp->next = (struct patternlist *)((void *)0);
#line 1088
        *lastp = newp;
#line 1088
        lastp = (struct patternlist___0 **)(& newp->next);
#line 1089
        break;
      }
    } else
#line 1092
    if ((int const   )*p == 124) {
#line 1094
      if (level == 0U) {
#line 1096
        plen___0 = opt == 63 || opt == 64 ? pattern_len : (unsigned int )((p - startp) + 1);
#line 1096
        plensize___0 = plen___0 * sizeof(wchar_t );
#line 1096
        newpsize___0 = (unsigned int )((char *)(& ((struct patternlist___0 *)0)->str)) + plensize___0;
#line 1096
        if ((4294967295U / sizeof(wchar_t ) < plen___0 || newpsize___0 < (unsigned int )((char *)(& ((struct patternlist___0 *)0)->str))) || 8000U <= newpsize___0) {
#line 1096
          return (-1);
        }
#line 1096
        __cil_tmp___5 = __builtin_alloca(newpsize___0);
#line 1096
        newp___0 = (struct patternlist___0 *)__cil_tmp___5;
#line 1096
        __cil_tmp___6 = wmemcpy(newp___0->str, startp, (unsigned int )(p - startp));
#line 1096
        *(__cil_tmp___6 + (p - startp)) = (short)0;
#line 1096
        newp___0->next = (struct patternlist *)((void *)0);
#line 1096
        *lastp = newp___0;
#line 1096
        lastp = (struct patternlist___0 **)(& newp___0->next);
#line 1097
        startp = p + 1;
      }
    }
#line 1036
    p ++;
  }
#line 1100
  if (((unsigned int )list != (unsigned int )((void *)0)) == 0) {
#line 1100
    __libc_failwith((char *)"Assertion failed: list != NULL at fnmatch_loop.c:1100");
  }
#line 1101
  if (((int const   )*(p + -1) == 41) == 0) {
#line 1101
    __libc_failwith((char *)"Assertion failed: p[-1] == L_(\')\') at fnmatch_loop.c:1101");
  }
#line 1104
  switch (opt) {
  case 42: 
#line 1107
  __cil_tmp___7 = internal_fnwmatch(p, string, string_end, no_leading_period, flags);
#line 1107
  if (__cil_tmp___7 == 0) {
#line 1108
    return (0);
  }
  case 43: 
#line 1112
  while (1) {
#line 1114
    rs = string;
#line 1114
    while ((unsigned int )rs <= (unsigned int )string_end) {
#line 1117
      __cil_tmp___8 = internal_fnwmatch((wchar_t const   *)(list->str), string, rs,
                                        no_leading_period, flags & 1 ? flags : flags & ~ (1 << 2));
#line 1117
      if (__cil_tmp___8 == 0) {
#line 1117
        __cil_tmp___9 = internal_fnwmatch(p, rs, string_end, (_Bool )((unsigned int )rs == (unsigned int )string ? (int )no_leading_period : (int const   )*(rs + -1) == 47 && (flags & (1 | (1 << 2))) == (1 | (1 << 2))),
                                          flags & 1 ? flags : flags & ~ (1 << 2));
#line 1117
        if (__cil_tmp___9 == 0) {
#line 1136
          return (0);
        } else
#line 1117
        if ((unsigned int )rs != (unsigned int )string) {
#line 1117
          __cil_tmp___10 = internal_fnwmatch(pattern - 1, rs, string_end, (_Bool )((unsigned int )rs == (unsigned int )string ? (int )no_leading_period : (int const   )*(rs + -1) == 47 && (flags & (1 | (1 << 2))) == (1 | (1 << 2))),
                                             flags & 1 ? flags : flags & ~ (1 << 2));
#line 1117
          if (__cil_tmp___10 == 0) {
#line 1136
            return (0);
          }
        }
      }
#line 1114
      rs ++;
    }
#line 1112
    list = (struct patternlist___0 *)list->next;
#line 1112
    if (! ((unsigned int )list != (unsigned int )((void *)0))) {
#line 1112
      break;
    }
  }
#line 1141
  return (1);
  case 63: 
#line 1144
  __cil_tmp___11 = internal_fnwmatch(p, string, string_end, no_leading_period, flags);
#line 1144
  if (__cil_tmp___11 == 0) {
#line 1145
    return (0);
  }
  case 64: 
#line 1149
  while (1) {
#line 1154
    __cil_tmp___12 = wcscat(list->str, p);
#line 1154
    __cil_tmp___13 = internal_fnwmatch((wchar_t const   *)__cil_tmp___12, string,
                                       string_end, no_leading_period, flags & 1 ? flags : flags & ~ (1 << 2));
#line 1154
    if (__cil_tmp___13 == 0) {
#line 1158
      return (0);
    }
#line 1149
    list = (struct patternlist___0 *)list->next;
#line 1149
    if (! ((unsigned int )list != (unsigned int )((void *)0))) {
#line 1149
      break;
    }
  }
#line 1162
  return (1);
  case 33: 
#line 1165
  rs = string;
#line 1165
  while ((unsigned int )rs <= (unsigned int )string_end) {
#line 1169
    runp = list;
#line 1169
    while ((unsigned int )runp != (unsigned int )((void *)0)) {
#line 1170
      __cil_tmp___14 = internal_fnwmatch((wchar_t const   *)(runp->str), string, rs,
                                         no_leading_period, flags & 1 ? flags : flags & ~ (1 << 2));
#line 1170
      if (__cil_tmp___14 == 0) {
#line 1172
        break;
      }
#line 1169
      runp = (struct patternlist___0 *)runp->next;
    }
#line 1175
    if ((unsigned int )runp == (unsigned int )((void *)0)) {
#line 1175
      __cil_tmp___15 = internal_fnwmatch(p, rs, string_end, (_Bool )((unsigned int )rs == (unsigned int )string ? (int )no_leading_period : (int const   )*(rs + -1) == 47 && (flags & (1 | (1 << 2))) == (1 | (1 << 2))),
                                         flags & 1 ? flags : flags & ~ (1 << 2));
#line 1175
      if (__cil_tmp___15 == 0) {
#line 1183
        return (0);
      }
    }
#line 1165
    rs ++;
  }
#line 1188
  return (1);
  default: 
#line 1191
  __libc_failwith((char *)"Assertion failed: ! \"Invalid extended matching operator\" at fnmatch_loop.c:1191");
#line 1192
  break;
  }
#line 1195
  return (-1);
}
}
#line 276 "fnmatch.c"
int gnu_fnmatch(char const   *pattern , char const   *string , int flags ) 
{ mbstate_t ps ;
  size_t patsize ;
  size_t strsize ;
  size_t totsize ;
  wchar_t *wpattern ;
  wchar_t *wstring ;
  int res ;
  size_t __cil_tmp ;
  int __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  size_t __cil_tmp___9 ;
  int __cil_tmp___10 ;

  {
#line 281
  __cil_tmp___8 = __locale_mb_cur_max();
#line 281
  if (__cil_tmp___8 != 1) {
#line 293
    memset((void *)(& ps), '\000', sizeof(ps));
#line 294
    __cil_tmp = mbsrtowcs((wchar_t *)((void *)0), & pattern, 0U, & ps);
#line 294
    patsize = __cil_tmp + 1U;
#line 295
    if (patsize != 0U) {
#line 297
      __cil_tmp___0 = mbsinit((mbstate_t const   *)(& ps));
#line 297
      if (__cil_tmp___0 == 0) {
#line 297
        __libc_failwith((char *)"Assertion failed: mbsinit (&ps) at fnmatch.c:297");
      }
#line 298
      __cil_tmp___1 = mbsrtowcs((wchar_t *)((void *)0), & string, 0U, & ps);
#line 298
      strsize = __cil_tmp___1 + 1U;
#line 299
      if (strsize != 0U) {
#line 301
        __cil_tmp___2 = mbsinit((mbstate_t const   *)(& ps));
#line 301
        if (__cil_tmp___2 == 0) {
#line 301
          __libc_failwith((char *)"Assertion failed: mbsinit (&ps) at fnmatch.c:301");
        }
#line 302
        totsize = patsize + strsize;
#line 303
        if (! (patsize <= totsize && totsize <= 4294967295U / sizeof(wchar_t ))) {
#line 307
          __cil_tmp___3 = __errno();
#line 307
          *__cil_tmp___3 = 12;
#line 308
          return (-1);
        }
#line 312
        if (totsize < 2000U) {
#line 313
          __cil_tmp___4 = __builtin_alloca(totsize * sizeof(wchar_t ));
#line 313
          wpattern = (wchar_t *)__cil_tmp___4;
        } else {
#line 316
          __cil_tmp___5 = rpl_malloc(totsize * sizeof(wchar_t ));
#line 316
          wpattern = (wchar_t *)__cil_tmp___5;
#line 317
          if (! wpattern) {
#line 319
            __cil_tmp___6 = __errno();
#line 319
            *__cil_tmp___6 = 12;
#line 320
            return (-1);
          }
        }
#line 323
        wstring = wpattern + patsize;
#line 326
        mbsrtowcs(wpattern, & pattern, patsize, & ps);
#line 327
        __cil_tmp___7 = mbsinit((mbstate_t const   *)(& ps));
#line 327
        if (__cil_tmp___7 == 0) {
#line 327
          __libc_failwith((char *)"Assertion failed: mbsinit (&ps) at fnmatch.c:327");
        }
#line 328
        mbsrtowcs(wstring, & string, strsize, & ps);
#line 330
        res = internal_fnwmatch((wchar_t const   *)wpattern, (wchar_t const   *)wstring,
                                (wchar_t const   *)((wstring + strsize) - 1), (_Bool )(flags & (1 << 2)),
                                flags);
#line 333
        if (! (totsize < 2000U)) {
#line 334
          free((void *)wpattern);
        }
#line 335
        return (res);
      }
    }
  }
#line 342
  __cil_tmp___9 = strlen(string);
#line 342
  __cil_tmp___10 = internal_fnmatch(pattern, string, string + __cil_tmp___9, (_Bool )(flags & (1 << 2)),
                                    flags);
#line 342
  return (__cil_tmp___10);
}
}
#line 1 "fopen-safer.o"
#pragma merger(0,"/tmp/cil-tQ5p8GWp.i","-g,-O2")
#line 313 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern FILE *fdopen(int  , char const   * ) ;
#line 315
extern int fileno(FILE * ) ;
#line 34 "fopen-safer.c"
FILE *fopen_safer(char const   *file , char const   *mode ) 
{ FILE *fp ;
  FILE *__cil_tmp ;
  int fd ;
  int __cil_tmp___0 ;
  int f ;
  int __cil_tmp___1 ;
  int e ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int e___0 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int __cil_tmp___6 ;

  {
#line 37
  __cil_tmp = fopen(file, mode);
#line 37
  fp = __cil_tmp;
#line 39
  if (fp) {
#line 41
    __cil_tmp___0 = fileno(fp);
#line 41
    fd = __cil_tmp___0;
#line 43
    if (0 <= fd && fd <= 2) {
#line 45
      __cil_tmp___1 = dup_safer(fd);
#line 45
      f = __cil_tmp___1;
#line 47
      if (f < 0) {
#line 49
        __cil_tmp___2 = __errno();
#line 49
        e = *__cil_tmp___2;
#line 50
        fclose(fp);
#line 51
        __cil_tmp___3 = __errno();
#line 51
        *__cil_tmp___3 = e;
#line 52
        return ((FILE *)((void *)0));
      }
#line 55
      __cil_tmp___6 = fclose(fp);
#line 55
      if (__cil_tmp___6 != 0) {
#line 55
        goto _L;
      } else {
#line 55
        fp = fdopen(f, mode);
#line 55
        if (! fp) {
          _L: 
#line 58
          __cil_tmp___4 = __errno();
#line 58
          e___0 = *__cil_tmp___4;
#line 59
          close(f);
#line 60
          __cil_tmp___5 = __errno();
#line 60
          *__cil_tmp___5 = e___0;
#line 61
          return ((FILE *)((void *)0));
        }
      }
    }
  }
#line 66
  return (fp);
}
}
#line 1 "fpending.o"
#pragma merger(0,"/tmp/cil-l7LPMBAU.i","-g,-O2")
#line 25 "fpending.c"
size_t __fpending(FILE *fp ) 
{ 

  {
#line 28
  return ((unsigned int )(fp->_p - fp->_bf._base));
}
}
#line 1 "fprintftime.o"
#pragma merger(0,"/tmp/cil-hua1ewib.i","-g,-O2")
#line 196 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int fputc(int  , FILE * ) ;
#line 56 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/time.h"
extern size_t strftime(char *_s , size_t _maxsize , char const   *_fmt , struct tm  const  *_t ) ;
#line 60
extern struct tm *gmtime_r(time_t const   * , struct tm * ) ;
#line 61
extern struct tm *localtime_r(time_t const   * , struct tm * ) ;
#line 28 "fprintftime.h"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) ;
#line 52 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wchar.h"
extern size_t mbrlen(char const   * , size_t  , mbstate_t * ) ;
#line 61 "strftime.c"
static mbstate_t const   mbstate_zero  ;
#line 291 "strftime.c"
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len ) 
{ unsigned char __x ;
  size_t __cil_tmp ;

  {
#line 294
  while (1) {
#line 294
    __cil_tmp = len;
#line 294
    len --;
#line 294
    if (! (__cil_tmp > 0U)) {
#line 294
      break;
    }
#line 296
    __x = (unsigned char )*src;
#line 296
    fputc(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 1 ? ((int )__x - 65) + 97 : (int )__x,
          fp);
#line 297
    src ++;
  }
#line 299
  return;
}
}
#line 301 "strftime.c"
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len ) 
{ unsigned char __x ;
  size_t __cil_tmp ;

  {
#line 304
  while (1) {
#line 304
    __cil_tmp = len;
#line 304
    len --;
#line 304
    if (! (__cil_tmp > 0U)) {
#line 304
      break;
    }
#line 306
    __x = (unsigned char )*src;
#line 306
    fputc(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 2 ? ((int )__x - 97) + 65 : (int )__x,
          fp);
#line 307
    src ++;
  }
#line 309
  return;
}
}
#line 335 "strftime.c"
static int ftime_tm_diff(struct tm  const  *a , struct tm  const  *b ) 
{ int a4 ;
  int b4 ;
  int a100 ;
  int b100 ;
  int a400 ;
  int b400 ;
  int intervening_leap_days ;
  int years ;
  int days ;

  {
#line 341
  a4 = (int )(((-1 >> 1 == -1 ? a->tm_year >> 2 : a->tm_year / (int const   )(1 << 2) - (int const   )(a->tm_year % (int const   )(1 << 2) < 0)) + (int const   )(-1 >> 1 == -1 ? 1900 >> 2 : 1900 / (1 << 2) - (1900 % (1 << 2) < 0))) - (int const   )(! (a->tm_year & 3)));
#line 342
  b4 = (int )(((-1 >> 1 == -1 ? b->tm_year >> 2 : b->tm_year / (int const   )(1 << 2) - (int const   )(b->tm_year % (int const   )(1 << 2) < 0)) + (int const   )(-1 >> 1 == -1 ? 1900 >> 2 : 1900 / (1 << 2) - (1900 % (1 << 2) < 0))) - (int const   )(! (b->tm_year & 3)));
#line 343
  a100 = a4 / 25 - (a4 % 25 < 0);
#line 344
  b100 = b4 / 25 - (b4 % 25 < 0);
#line 345
  a400 = -1 >> 1 == -1 ? a100 >> 2 : a100 / (1 << 2) - (a100 % (1 << 2) < 0);
#line 346
  b400 = -1 >> 1 == -1 ? b100 >> 2 : b100 / (1 << 2) - (b100 % (1 << 2) < 0);
#line 347
  intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
#line 348
  years = (int )(a->tm_year - b->tm_year);
#line 349
  days = (365 * years + intervening_leap_days) + (int )(a->tm_yday - b->tm_yday);
#line 351
  return (60 * (60 * (24 * days + (int )(a->tm_hour - b->tm_hour)) + (int )(a->tm_min - b->tm_min)) + (int )(a->tm_sec - b->tm_sec));
}
}
#line 367 "strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ int big_enough_multiple_of_7 ;

  {
#line 373
  big_enough_multiple_of_7 = 378;
#line 374
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 415 "strftime.c"
static size_t strftime_case_(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                             int ut , int ns ) 
{ size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  char const   *format_end ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___0[3U + (((sizeof(int ) * 8U - 1U) * 146U) / 485U + 2U)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  size_t _i ;
  size_t _i___0 ;
  mbstate_t mbstate ;
  size_t len ;
  size_t fsize ;
  size_t __cil_tmp ;
  size_t bytes ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  size_t _i___1 ;
  size_t _i___2 ;
  char const   *__cil_tmp___3 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  size_t _i___3 ;
  size_t _i___4 ;
  size_t len___0 ;
  size_t __cil_tmp___4 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  size_t _i___5 ;
  size_t _i___6 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___1 ;
  char *__cil_tmp___5 ;
  char *__cil_tmp___6 ;
  char *__cil_tmp___7 ;
  char *__cil_tmp___8 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int century ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  size_t _i___9 ;
  size_t _i___10 ;
  int padding ;
  size_t _i___11 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  size_t _i___12 ;
  size_t _i___13 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  size_t _i___14 ;
  size_t _i___15 ;
  size_t _i___16 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  size_t _i___17 ;
  size_t _i___18 ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  size_t _i___19 ;
  size_t _i___20 ;
  int j ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  size_t _i___21 ;
  size_t _i___22 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int _n___10 ;
  int _delta___10 ;
  int _incr___10 ;
  size_t _i___23 ;
  size_t _i___24 ;
  int year___0 ;
  int year_adjust ;
  int days ;
  int __cil_tmp___9 ;
  int d___0 ;
  int __cil_tmp___10 ;
  int yy ;
  int yy___0 ;
  int _n___11 ;
  size_t __cil_tmp___11 ;
  int _delta___11 ;
  int _incr___11 ;
  size_t _i___25 ;
  size_t _i___26 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  struct tm gtm ;
  struct tm ltm___0 ;
  time_t lt ;
  struct tm tm ;
  struct tm *__cil_tmp___12 ;
  struct tm *__cil_tmp___13 ;
  int flen ;
  int _n___12 ;
  int _delta___12 ;
  int _incr___12 ;
  size_t _i___27 ;
  size_t _i___28 ;

  {
#line 425
  maxsize = 4294967295U;
#line 428
  hour12 = (int )tp->tm_hour;
#line 453
  i = 0U;
#line 454
  p = s;
#line 457
  format_end = (char const   *)((void *)0);
#line 469
  zone = (char const   *)((void *)0);
#line 480
  if (ut) {
#line 482
    if (! (zone && *zone)) {
#line 483
      zone = "GMT";
    }
  }
#line 495
  if (hour12 > 12) {
#line 496
    hour12 -= 12;
  } else
#line 498
  if (hour12 == 0) {
#line 499
    hour12 = 12;
  }
#line 501
  f = format;
#line 501
  while ((int const   )*f != 0) {
#line 503
    pad = 0;
#line 505
    digits = 0;
#line 519
    width = -1;
#line 520
    to_lowcase = (_Bool)0;
#line 521
    to_uppcase = upcase;
#line 523
    change_case = (_Bool)0;
#line 527
    switch ((int )*f) {
    case 37: 
#line 530
    break;
    case 8: 
    case 9: 
    case 10: 
    case 11: 
    case 12: 
    case 13: 
    case 32: 
    case 33: 
    case 34: 
    case 35: 
    case 38: 
    case 39: 
    case 40: 
    case 41: 
    case 42: 
    case 43: 
    case 44: 
    case 45: 
    case 46: 
    case 47: 
    case 48: 
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    case 58: 
    case 59: 
    case 60: 
    case 61: 
    case 62: 
    case 63: 
    case 65: 
    case 66: 
    case 67: 
    case 68: 
    case 69: 
    case 70: 
    case 71: 
    case 72: 
    case 73: 
    case 74: 
    case 75: 
    case 76: 
    case 77: 
    case 78: 
    case 79: 
    case 80: 
    case 81: 
    case 82: 
    case 83: 
    case 84: 
    case 85: 
    case 86: 
    case 87: 
    case 88: 
    case 89: 
    case 90: 
    case 91: 
    case 92: 
    case 93: 
    case 94: 
    case 95: 
    case 97: 
    case 98: 
    case 99: 
    case 100: 
    case 101: 
    case 102: 
    case 103: 
    case 104: 
    case 105: 
    case 106: 
    case 107: 
    case 108: 
    case 109: 
    case 110: 
    case 111: 
    case 112: 
    case 113: 
    case 114: 
    case 115: 
    case 116: 
    case 117: 
    case 118: 
    case 119: 
    case 120: 
    case 121: 
    case 122: 
    case 123: 
    case 124: 
    case 125: 
    case 126: 
#line 557
    while (1) {
#line 557
      _n = 1;
#line 557
      _delta = width - _n;
#line 557
      _incr = _n + (_delta > 0 ? _delta : 0);
#line 557
      if ((unsigned int )_incr >= maxsize - i) {
#line 557
        return (0U);
      }
#line 557
      if (p) {
#line 557
        if (digits == 0 && _delta > 0) {
#line 557
          if (pad == 48) {
#line 557
            while (1) {
#line 557
              _i = 0U;
#line 557
              while (_i < (unsigned int )_delta) {
#line 557
                fputc('0', p);
#line 557
                _i ++;
              }
#line 557
              break;
            }
          } else {
#line 557
            while (1) {
#line 557
              _i___0 = 0U;
#line 557
              while (_i___0 < (unsigned int )_delta) {
#line 557
                fputc(' ', p);
#line 557
                _i___0 ++;
              }
#line 557
              break;
            }
          }
        }
#line 557
        fputc((int )*f, p);
      }
#line 557
      i += (unsigned int )_incr;
#line 557
      break;
    }
#line 558
    goto __Cont;
    default: 
#line 564
    mbstate = (struct __anonstruct__mbstate_t_1 )mbstate_zero;
#line 565
    len = 0U;
#line 568
    if (! format_end) {
#line 569
      __cil_tmp = strlen(f);
#line 569
      format_end = (f + __cil_tmp) + 1;
    }
#line 570
    fsize = (unsigned int )(format_end - f);
#line 572
    while (1) {
#line 574
      __cil_tmp___0 = mbrlen(f + len, fsize - len, & mbstate);
#line 574
      bytes = __cil_tmp___0;
#line 576
      if (bytes == 0U) {
#line 577
        break;
      }
#line 579
      if (bytes == 4294967294U) {
#line 581
        __cil_tmp___1 = strlen(f + len);
#line 581
        len += __cil_tmp___1;
#line 582
        break;
      }
#line 585
      if (bytes == 4294967295U) {
#line 587
        len ++;
#line 588
        break;
      }
#line 591
      len += bytes;
#line 572
      __cil_tmp___2 = mbsinit((mbstate_t const   *)(& mbstate));
#line 572
      if (__cil_tmp___2) {
#line 572
        break;
      }
    }
#line 595
    while (1) {
#line 595
      _n___0 = (int )len;
#line 595
      _delta___0 = width - _n___0;
#line 595
      _incr___0 = _n___0 + (_delta___0 > 0 ? _delta___0 : 0);
#line 595
      if ((unsigned int )_incr___0 >= maxsize - i) {
#line 595
        return (0U);
      }
#line 595
      if (p) {
#line 595
        if (digits == 0 && _delta___0 > 0) {
#line 595
          if (pad == 48) {
#line 595
            while (1) {
#line 595
              _i___1 = 0U;
#line 595
              while (_i___1 < (unsigned int )_delta___0) {
#line 595
                fputc('0', p);
#line 595
                _i___1 ++;
              }
#line 595
              break;
            }
          } else {
#line 595
            while (1) {
#line 595
              _i___2 = 0U;
#line 595
              while (_i___2 < (unsigned int )_delta___0) {
#line 595
                fputc(' ', p);
#line 595
                _i___2 ++;
              }
#line 595
              break;
            }
          }
        }
#line 595
        if (to_lowcase) {
#line 595
          fwrite_lowcase(p, f, (unsigned int )_n___0);
        } else
#line 595
        if (to_uppcase) {
#line 595
          fwrite_uppcase(p, f, (unsigned int )_n___0);
        } else {
#line 595
          fwrite((void const   *)f, (unsigned int )_n___0, 1U, p);
        }
      }
#line 595
      i += (unsigned int )_incr___0;
#line 595
      break;
    }
#line 596
    f += len - 1U;
#line 597
    goto __Cont;
    }
#line 615
    while (1) {
#line 617
      f ++;
#line 617
      switch ((int )*f) {
      case 95: 
      case 45: 
      case 48: 
#line 623
      pad = (int )*f;
#line 624
      continue;
      case 94: 
#line 628
      to_uppcase = (_Bool)1;
#line 629
      continue;
      case 35: 
#line 631
      change_case = (_Bool)1;
#line 632
      continue;
      default: 
#line 635
      break;
      }
#line 637
      break;
    }
#line 641
    if ((unsigned int )*f - 48U <= 9U) {
#line 643
      width = 0;
#line 644
      while (1) {
#line 646
        if (width > 214748364 || (width == 214748364 && (int const   )*f - 48 > 7)) {
#line 649
          width = 2147483647;
        } else {
#line 652
          width *= 10;
#line 653
          width += (int )((int const   )*f - 48);
        }
#line 655
        f ++;
#line 644
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 644
          break;
        }
      }
    }
#line 661
    switch ((int )*f) {
    case 69: 
    case 79: 
#line 665
    __cil_tmp___3 = f;
#line 665
    f ++;
#line 665
    modifier = (int )*__cil_tmp___3;
#line 666
    break;
    default: 
#line 669
    modifier = 0;
#line 670
    break;
    }
#line 674
    format_char = (int )*f;
#line 675
    switch (format_char) {
    case 37: 
#line 698
    if (modifier != 0) {
#line 699
      goto bad_format;
    }
#line 700
    while (1) {
#line 700
      _n___1 = 1;
#line 700
      _delta___1 = width - _n___1;
#line 700
      _incr___1 = _n___1 + (_delta___1 > 0 ? _delta___1 : 0);
#line 700
      if ((unsigned int )_incr___1 >= maxsize - i) {
#line 700
        return (0U);
      }
#line 700
      if (p) {
#line 700
        if (digits == 0 && _delta___1 > 0) {
#line 700
          if (pad == 48) {
#line 700
            while (1) {
#line 700
              _i___3 = 0U;
#line 700
              while (_i___3 < (unsigned int )_delta___1) {
#line 700
                fputc('0', p);
#line 700
                _i___3 ++;
              }
#line 700
              break;
            }
          } else {
#line 700
            while (1) {
#line 700
              _i___4 = 0U;
#line 700
              while (_i___4 < (unsigned int )_delta___1) {
#line 700
                fputc(' ', p);
#line 700
                _i___4 ++;
              }
#line 700
              break;
            }
          }
        }
#line 700
        fputc((int )*f, p);
      }
#line 700
      i += (unsigned int )_incr___1;
#line 700
      break;
    }
#line 701
    break;
    case 97: 
#line 704
    if (modifier != 0) {
#line 705
      goto bad_format;
    }
#line 706
    if (change_case) {
#line 708
      to_uppcase = (_Bool)1;
#line 709
      to_lowcase = (_Bool)0;
    }
#line 715
    goto underlying_strftime;
    case 65: 
#line 719
    if (modifier != 0) {
#line 720
      goto bad_format;
    }
#line 721
    if (change_case) {
#line 723
      to_uppcase = (_Bool)1;
#line 724
      to_lowcase = (_Bool)0;
    }
#line 730
    goto underlying_strftime;
    case 98: 
    case 104: 
#line 735
    if (change_case) {
#line 737
      to_uppcase = (_Bool)1;
#line 738
      to_lowcase = (_Bool)0;
    }
#line 740
    if (modifier != 0) {
#line 741
      goto bad_format;
    }
#line 746
    goto underlying_strftime;
    case 66: 
#line 750
    if (modifier != 0) {
#line 751
      goto bad_format;
    }
#line 752
    if (change_case) {
#line 754
      to_uppcase = (_Bool)1;
#line 755
      to_lowcase = (_Bool)0;
    }
#line 761
    goto underlying_strftime;
    case 99: 
#line 765
    if (modifier == 79) {
#line 766
      goto bad_format;
    }
#line 775
    goto underlying_strftime;
    subformat: 
#line 780
    __cil_tmp___4 = strftime_case_(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut,
                                   ns);
#line 780
    len___0 = __cil_tmp___4;
#line 784
    while (1) {
#line 784
      _n___2 = (int )len___0;
#line 784
      _delta___2 = width - _n___2;
#line 784
      _incr___2 = _n___2 + (_delta___2 > 0 ? _delta___2 : 0);
#line 784
      if ((unsigned int )_incr___2 >= maxsize - i) {
#line 784
        return (0U);
      }
#line 784
      if (p) {
#line 784
        if (digits == 0 && _delta___2 > 0) {
#line 784
          if (pad == 48) {
#line 784
            while (1) {
#line 784
              _i___5 = 0U;
#line 784
              while (_i___5 < (unsigned int )_delta___2) {
#line 784
                fputc('0', p);
#line 784
                _i___5 ++;
              }
#line 784
              break;
            }
          } else {
#line 784
            while (1) {
#line 784
              _i___6 = 0U;
#line 784
              while (_i___6 < (unsigned int )_delta___2) {
#line 784
                fputc(' ', p);
#line 784
                _i___6 ++;
              }
#line 784
              break;
            }
          }
        }
#line 784
        strftime_case_(to_uppcase, p, subfmt, tp, ut, ns);
      }
#line 784
      i += (unsigned int )_incr___2;
#line 784
      break;
    }
#line 789
    break;
    underlying_strftime: 
#line 797
    u = ufmt;
#line 810
    __cil_tmp___5 = u;
#line 810
    u ++;
#line 810
    *__cil_tmp___5 = (char )' ';
#line 811
    __cil_tmp___6 = u;
#line 811
    u ++;
#line 811
    *__cil_tmp___6 = (char )'%';
#line 812
    if (modifier != 0) {
#line 813
      __cil_tmp___7 = u;
#line 813
      u ++;
#line 813
      *__cil_tmp___7 = (char )modifier;
    }
#line 814
    __cil_tmp___8 = u;
#line 814
    u ++;
#line 814
    *__cil_tmp___8 = (char )format_char;
#line 815
    *u = (char )'\000';
#line 816
    len___1 = strftime(ubuf, sizeof(ubuf), (char const   *)(ufmt), tp);
#line 817
    if (len___1 != 0U) {
#line 818
      while (1) {
#line 818
        _n___3 = (int )(len___1 - 1U);
#line 818
        _delta___3 = width - _n___3;
#line 818
        _incr___3 = _n___3 + (_delta___3 > 0 ? _delta___3 : 0);
#line 818
        if ((unsigned int )_incr___3 >= maxsize - i) {
#line 818
          return (0U);
        }
#line 818
        if (p) {
#line 818
          if (digits == 0 && _delta___3 > 0) {
#line 818
            if (pad == 48) {
#line 818
              while (1) {
#line 818
                _i___7 = 0U;
#line 818
                while (_i___7 < (unsigned int )_delta___3) {
#line 818
                  fputc('0', p);
#line 818
                  _i___7 ++;
                }
#line 818
                break;
              }
            } else {
#line 818
              while (1) {
#line 818
                _i___8 = 0U;
#line 818
                while (_i___8 < (unsigned int )_delta___3) {
#line 818
                  fputc(' ', p);
#line 818
                  _i___8 ++;
                }
#line 818
                break;
              }
            }
          }
#line 818
          if (to_lowcase) {
#line 818
            fwrite_lowcase(p, (char const   *)(ubuf + 1), (unsigned int )_n___3);
          } else
#line 818
          if (to_uppcase) {
#line 818
            fwrite_uppcase(p, (char const   *)(ubuf + 1), (unsigned int )_n___3);
          } else {
#line 818
            fwrite((void const   *)(ubuf + 1), (unsigned int )_n___3, 1U, p);
          }
        }
#line 818
        i += (unsigned int )_incr___3;
#line 818
        break;
      }
    }
#line 820
    break;
    case 67: 
#line 824
    if (modifier == 79) {
#line 825
      goto bad_format;
    }
#line 826
    if (modifier == 69) {
#line 842
      goto underlying_strftime;
    }
#line 847
    century = (int )(tp->tm_year / 100 + 19);
#line 848
    century -= tp->tm_year % 100 < 0 && 0 < century;
#line 849
    digits = 2;
#line 849
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 849
    u_number_value = (unsigned int )century;
#line 849
    goto do_signed_number;
    case 120: 
#line 853
    if (modifier == 79) {
#line 854
      goto bad_format;
    }
#line 863
    goto underlying_strftime;
    case 68: 
#line 866
    if (modifier != 0) {
#line 867
      goto bad_format;
    }
#line 868
    subfmt = "%m/%d/%y";
#line 869
    goto subformat;
    case 100: 
#line 872
    if (modifier == 69) {
#line 873
      goto bad_format;
    }
#line 875
    digits = 2;
#line 875
    number_value = (int )tp->tm_mday;
#line 875
    goto do_number;
    case 101: 
#line 878
    if (modifier == 69) {
#line 879
      goto bad_format;
    }
#line 881
    digits = 2;
#line 881
    number_value = (int )tp->tm_mday;
#line 881
    goto do_number_spacepad;
    do_tz_offset: 
#line 887
    always_output_a_sign = (_Bool)1;
#line 888
    goto do_number_body;
    do_number_spacepad: 
#line 892
    if (pad != 48 && pad != 45) {
#line 893
      pad = '_';
    }
    do_number: 
#line 897
    negative_number = (_Bool )(number_value < 0);
#line 898
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 901
    always_output_a_sign = (_Bool)0;
#line 902
    tz_colon_mask = 0;
    do_number_body: 
#line 910
    if (modifier == 79 && ! negative_number) {
#line 928
      goto underlying_strftime;
    }
#line 932
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 934
    if (negative_number) {
#line 935
      u_number_value = - u_number_value;
    }
#line 937
    while (1) {
#line 939
      if (tz_colon_mask & 1) {
#line 940
        bufp --;
#line 940
        *bufp = (char )':';
      }
#line 941
      tz_colon_mask >>= 1;
#line 942
      bufp --;
#line 942
      *bufp = (char )(u_number_value % 10U + 48U);
#line 943
      u_number_value /= 10U;
#line 937
      if (! (u_number_value != 0U || tz_colon_mask != 0)) {
#line 937
        break;
      }
    }
    do_number_sign_and_padding: 
#line 948
    if (digits < width) {
#line 949
      digits = width;
    }
#line 951
    sign_char = (char )(negative_number ? '-' : (always_output_a_sign ? '+' : 0));
#line 955
    if (pad == 45) {
#line 957
      if (sign_char) {
#line 958
        while (1) {
#line 958
          _n___4 = 1;
#line 958
          _delta___4 = width - _n___4;
#line 958
          _incr___4 = _n___4 + (_delta___4 > 0 ? _delta___4 : 0);
#line 958
          if ((unsigned int )_incr___4 >= maxsize - i) {
#line 958
            return (0U);
          }
#line 958
          if (p) {
#line 958
            if (digits == 0 && _delta___4 > 0) {
#line 958
              if (pad == 48) {
#line 958
                while (1) {
#line 958
                  _i___9 = 0U;
#line 958
                  while (_i___9 < (unsigned int )_delta___4) {
#line 958
                    fputc('0', p);
#line 958
                    _i___9 ++;
                  }
#line 958
                  break;
                }
              } else {
#line 958
                while (1) {
#line 958
                  _i___10 = 0U;
#line 958
                  while (_i___10 < (unsigned int )_delta___4) {
#line 958
                    fputc(' ', p);
#line 958
                    _i___10 ++;
                  }
#line 958
                  break;
                }
              }
            }
#line 958
            fputc((int )sign_char, p);
          }
#line 958
          i += (unsigned int )_incr___4;
#line 958
          break;
        }
      }
    } else {
#line 962
      padding = (digits - ((buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp)) - ! (! sign_char);
#line 965
      if (padding > 0) {
#line 967
        if (pad == 95) {
#line 969
          if ((unsigned int )padding >= maxsize - i) {
#line 970
            return (0U);
          }
#line 972
          if (p) {
#line 973
            while (1) {
#line 973
              _i___11 = 0U;
#line 973
              while (_i___11 < (unsigned int )padding) {
#line 973
                fputc(' ', p);
#line 973
                _i___11 ++;
              }
#line 973
              break;
            }
          }
#line 974
          i += (unsigned int )padding;
#line 975
          width = width > padding ? width - padding : 0;
#line 976
          if (sign_char) {
#line 977
            while (1) {
#line 977
              _n___5 = 1;
#line 977
              _delta___5 = width - _n___5;
#line 977
              _incr___5 = _n___5 + (_delta___5 > 0 ? _delta___5 : 0);
#line 977
              if ((unsigned int )_incr___5 >= maxsize - i) {
#line 977
                return (0U);
              }
#line 977
              if (p) {
#line 977
                if (digits == 0 && _delta___5 > 0) {
#line 977
                  if (pad == 48) {
#line 977
                    while (1) {
#line 977
                      _i___12 = 0U;
#line 977
                      while (_i___12 < (unsigned int )_delta___5) {
#line 977
                        fputc('0', p);
#line 977
                        _i___12 ++;
                      }
#line 977
                      break;
                    }
                  } else {
#line 977
                    while (1) {
#line 977
                      _i___13 = 0U;
#line 977
                      while (_i___13 < (unsigned int )_delta___5) {
#line 977
                        fputc(' ', p);
#line 977
                        _i___13 ++;
                      }
#line 977
                      break;
                    }
                  }
                }
#line 977
                fputc((int )sign_char, p);
              }
#line 977
              i += (unsigned int )_incr___5;
#line 977
              break;
            }
          }
        } else {
#line 981
          if ((unsigned int )digits >= maxsize - i) {
#line 982
            return (0U);
          }
#line 984
          if (sign_char) {
#line 985
            while (1) {
#line 985
              _n___6 = 1;
#line 985
              _delta___6 = width - _n___6;
#line 985
              _incr___6 = _n___6 + (_delta___6 > 0 ? _delta___6 : 0);
#line 985
              if ((unsigned int )_incr___6 >= maxsize - i) {
#line 985
                return (0U);
              }
#line 985
              if (p) {
#line 985
                if (digits == 0 && _delta___6 > 0) {
#line 985
                  if (pad == 48) {
#line 985
                    while (1) {
#line 985
                      _i___14 = 0U;
#line 985
                      while (_i___14 < (unsigned int )_delta___6) {
#line 985
                        fputc('0', p);
#line 985
                        _i___14 ++;
                      }
#line 985
                      break;
                    }
                  } else {
#line 985
                    while (1) {
#line 985
                      _i___15 = 0U;
#line 985
                      while (_i___15 < (unsigned int )_delta___6) {
#line 985
                        fputc(' ', p);
#line 985
                        _i___15 ++;
                      }
#line 985
                      break;
                    }
                  }
                }
#line 985
                fputc((int )sign_char, p);
              }
#line 985
              i += (unsigned int )_incr___6;
#line 985
              break;
            }
          }
#line 987
          if (p) {
#line 988
            while (1) {
#line 988
              _i___16 = 0U;
#line 988
              while (_i___16 < (unsigned int )padding) {
#line 988
                fputc('0', p);
#line 988
                _i___16 ++;
              }
#line 988
              break;
            }
          }
#line 989
          i += (unsigned int )padding;
#line 990
          width = 0;
        }
      } else
#line 995
      if (sign_char) {
#line 996
        while (1) {
#line 996
          _n___7 = 1;
#line 996
          _delta___7 = width - _n___7;
#line 996
          _incr___7 = _n___7 + (_delta___7 > 0 ? _delta___7 : 0);
#line 996
          if ((unsigned int )_incr___7 >= maxsize - i) {
#line 996
            return (0U);
          }
#line 996
          if (p) {
#line 996
            if (digits == 0 && _delta___7 > 0) {
#line 996
              if (pad == 48) {
#line 996
                while (1) {
#line 996
                  _i___17 = 0U;
#line 996
                  while (_i___17 < (unsigned int )_delta___7) {
#line 996
                    fputc('0', p);
#line 996
                    _i___17 ++;
                  }
#line 996
                  break;
                }
              } else {
#line 996
                while (1) {
#line 996
                  _i___18 = 0U;
#line 996
                  while (_i___18 < (unsigned int )_delta___7) {
#line 996
                    fputc(' ', p);
#line 996
                    _i___18 ++;
                  }
#line 996
                  break;
                }
              }
            }
#line 996
            fputc((int )sign_char, p);
          }
#line 996
          i += (unsigned int )_incr___7;
#line 996
          break;
        }
      }
    }
#line 1000
    while (1) {
#line 1000
      _n___8 = (buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp;
#line 1000
      _delta___8 = width - _n___8;
#line 1000
      _incr___8 = _n___8 + (_delta___8 > 0 ? _delta___8 : 0);
#line 1000
      if ((unsigned int )_incr___8 >= maxsize - i) {
#line 1000
        return (0U);
      }
#line 1000
      if (p) {
#line 1000
        if (digits == 0 && _delta___8 > 0) {
#line 1000
          if (pad == 48) {
#line 1000
            while (1) {
#line 1000
              _i___19 = 0U;
#line 1000
              while (_i___19 < (unsigned int )_delta___8) {
#line 1000
                fputc('0', p);
#line 1000
                _i___19 ++;
              }
#line 1000
              break;
            }
          } else {
#line 1000
            while (1) {
#line 1000
              _i___20 = 0U;
#line 1000
              while (_i___20 < (unsigned int )_delta___8) {
#line 1000
                fputc(' ', p);
#line 1000
                _i___20 ++;
              }
#line 1000
              break;
            }
          }
        }
#line 1000
        if (to_lowcase) {
#line 1000
          fwrite_lowcase(p, (char const   *)bufp, (unsigned int )_n___8);
        } else
#line 1000
        if (to_uppcase) {
#line 1000
          fwrite_uppcase(p, (char const   *)bufp, (unsigned int )_n___8);
        } else {
#line 1000
          fwrite((void const   *)bufp, (unsigned int )_n___8, 1U, p);
        }
      }
#line 1000
      i += (unsigned int )_incr___8;
#line 1000
      break;
    }
#line 1001
    break;
    case 70: 
#line 1004
    if (modifier != 0) {
#line 1005
      goto bad_format;
    }
#line 1006
    subfmt = "%Y-%m-%d";
#line 1007
    goto subformat;
    case 72: 
#line 1010
    if (modifier == 69) {
#line 1011
      goto bad_format;
    }
#line 1013
    digits = 2;
#line 1013
    number_value = (int )tp->tm_hour;
#line 1013
    goto do_number;
    case 73: 
#line 1016
    if (modifier == 69) {
#line 1017
      goto bad_format;
    }
#line 1019
    digits = 2;
#line 1019
    number_value = hour12;
#line 1019
    goto do_number;
    case 107: 
#line 1022
    if (modifier == 69) {
#line 1023
      goto bad_format;
    }
#line 1025
    digits = 2;
#line 1025
    number_value = (int )tp->tm_hour;
#line 1025
    goto do_number_spacepad;
    case 108: 
#line 1028
    if (modifier == 69) {
#line 1029
      goto bad_format;
    }
#line 1031
    digits = 2;
#line 1031
    number_value = hour12;
#line 1031
    goto do_number_spacepad;
    case 106: 
#line 1034
    if (modifier == 69) {
#line 1035
      goto bad_format;
    }
#line 1037
    digits = 3;
#line 1037
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1037
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1037
    goto do_signed_number;
    case 77: 
#line 1040
    if (modifier == 69) {
#line 1041
      goto bad_format;
    }
#line 1043
    digits = 2;
#line 1043
    number_value = (int )tp->tm_min;
#line 1043
    goto do_number;
    case 109: 
#line 1046
    if (modifier == 69) {
#line 1047
      goto bad_format;
    }
#line 1049
    digits = 2;
#line 1049
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1049
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1049
    goto do_signed_number;
    case 78: 
#line 1053
    if (modifier == 69) {
#line 1054
      goto bad_format;
    }
#line 1056
    number_value = ns;
#line 1057
    if (width == -1) {
#line 1058
      width = 9;
    } else {
#line 1063
      j = width;
#line 1063
      while (j < 9) {
#line 1064
        number_value /= 10;
#line 1063
        j ++;
      }
    }
#line 1067
    digits = width;
#line 1067
    number_value = number_value;
#line 1067
    goto do_number;
    case 110: 
#line 1071
    while (1) {
#line 1071
      _n___9 = 1;
#line 1071
      _delta___9 = width - _n___9;
#line 1071
      _incr___9 = _n___9 + (_delta___9 > 0 ? _delta___9 : 0);
#line 1071
      if ((unsigned int )_incr___9 >= maxsize - i) {
#line 1071
        return (0U);
      }
#line 1071
      if (p) {
#line 1071
        if (digits == 0 && _delta___9 > 0) {
#line 1071
          if (pad == 48) {
#line 1071
            while (1) {
#line 1071
              _i___21 = 0U;
#line 1071
              while (_i___21 < (unsigned int )_delta___9) {
#line 1071
                fputc('0', p);
#line 1071
                _i___21 ++;
              }
#line 1071
              break;
            }
          } else {
#line 1071
            while (1) {
#line 1071
              _i___22 = 0U;
#line 1071
              while (_i___22 < (unsigned int )_delta___9) {
#line 1071
                fputc(' ', p);
#line 1071
                _i___22 ++;
              }
#line 1071
              break;
            }
          }
        }
#line 1071
        fputc('\n', p);
      }
#line 1071
      i += (unsigned int )_incr___9;
#line 1071
      break;
    }
#line 1072
    break;
    case 80: 
#line 1075
    to_lowcase = (_Bool)1;
#line 1077
    format_char = 'p';
    case 112: 
#line 1082
    if (change_case) {
#line 1084
      to_uppcase = (_Bool)0;
#line 1085
      to_lowcase = (_Bool)1;
    }
#line 1091
    goto underlying_strftime;
    case 82: 
#line 1095
    subfmt = "%H:%M";
#line 1096
    goto subformat;
    case 114: 
#line 1106
    goto underlying_strftime;
    case 83: 
#line 1110
    if (modifier == 69) {
#line 1111
      goto bad_format;
    }
#line 1113
    digits = 2;
#line 1113
    number_value = (int )tp->tm_sec;
#line 1113
    goto do_number;
    case 115: 
#line 1120
    ltm = (struct tm )*tp;
#line 1121
    t = rpl_mktime(& ltm);
#line 1126
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 1127
    negative_number = (_Bool )(t < 0L);
#line 1129
    while (1) {
#line 1131
      d = (int )(t % 10L);
#line 1132
      t /= 10L;
#line 1133
      bufp --;
#line 1133
      *bufp = (char )((negative_number ? - d : d) + 48);
#line 1129
      if (! (t != 0L)) {
#line 1129
        break;
      }
    }
#line 1137
    digits = 1;
#line 1138
    always_output_a_sign = (_Bool)0;
#line 1139
    goto do_number_sign_and_padding;
    case 88: 
#line 1143
    if (modifier == 79) {
#line 1144
      goto bad_format;
    }
#line 1153
    goto underlying_strftime;
    case 84: 
#line 1156
    subfmt = "%H:%M:%S";
#line 1157
    goto subformat;
    case 116: 
#line 1160
    while (1) {
#line 1160
      _n___10 = 1;
#line 1160
      _delta___10 = width - _n___10;
#line 1160
      _incr___10 = _n___10 + (_delta___10 > 0 ? _delta___10 : 0);
#line 1160
      if ((unsigned int )_incr___10 >= maxsize - i) {
#line 1160
        return (0U);
      }
#line 1160
      if (p) {
#line 1160
        if (digits == 0 && _delta___10 > 0) {
#line 1160
          if (pad == 48) {
#line 1160
            while (1) {
#line 1160
              _i___23 = 0U;
#line 1160
              while (_i___23 < (unsigned int )_delta___10) {
#line 1160
                fputc('0', p);
#line 1160
                _i___23 ++;
              }
#line 1160
              break;
            }
          } else {
#line 1160
            while (1) {
#line 1160
              _i___24 = 0U;
#line 1160
              while (_i___24 < (unsigned int )_delta___10) {
#line 1160
                fputc(' ', p);
#line 1160
                _i___24 ++;
              }
#line 1160
              break;
            }
          }
        }
#line 1160
        fputc('\t', p);
      }
#line 1160
      i += (unsigned int )_incr___10;
#line 1160
      break;
    }
#line 1161
    break;
    case 117: 
#line 1164
    digits = 1;
#line 1164
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1164
    goto do_number;
    case 85: 
#line 1167
    if (modifier == 69) {
#line 1168
      goto bad_format;
    }
#line 1170
    digits = 2;
#line 1170
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1170
    goto do_number;
    case 86: 
    case 103: 
    case 71: 
#line 1175
    if (modifier == 69) {
#line 1176
      goto bad_format;
    }
#line 1182
    year___0 = (int )(tp->tm_year + (int const   )(tp->tm_year < 0 ? 300 : -100));
#line 1186
    year_adjust = 0;
#line 1187
    __cil_tmp___9 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1187
    days = __cil_tmp___9;
#line 1189
    if (days < 0) {
#line 1192
      year_adjust = -1;
#line 1193
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + ((year___0 - 1) % 4 == 0 && ((year___0 - 1) % 100 != 0 || (year___0 - 1) % 400 == 0)))),
                           (int )tp->tm_wday);
    } else {
#line 1198
      __cil_tmp___10 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + (year___0 % 4 == 0 && (year___0 % 100 != 0 || year___0 % 400 == 0)))),
                                     (int )tp->tm_wday);
#line 1198
      d___0 = __cil_tmp___10;
#line 1200
      if (0 <= d___0) {
#line 1203
        year_adjust = 1;
#line 1204
        days = d___0;
      }
    }
#line 1208
    switch ((int )*f) {
    case 103: 
#line 1212
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1213
    digits = 2;
#line 1213
    number_value = 0 <= yy ? yy : (tp->tm_year < (int const   )(-1900 - year_adjust) ? - yy : yy + 100);
#line 1213
    goto do_number;
    case 71: 
#line 1221
    digits = 4;
#line 1221
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1221
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1221
    goto do_signed_number;
    default: 
#line 1226
    digits = 2;
#line 1226
    number_value = days / 7 + 1;
#line 1226
    goto do_number;
    }
    case 87: 
#line 1231
    if (modifier == 69) {
#line 1232
      goto bad_format;
    }
#line 1234
    digits = 2;
#line 1234
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1234
    goto do_number;
    case 119: 
#line 1237
    if (modifier == 69) {
#line 1238
      goto bad_format;
    }
#line 1240
    digits = 1;
#line 1240
    number_value = (int )tp->tm_wday;
#line 1240
    goto do_number;
    case 89: 
#line 1243
    if (modifier == 69) {
#line 1257
      goto underlying_strftime;
    }
#line 1260
    if (modifier == 79) {
#line 1261
      goto bad_format;
    } else {
#line 1263
      digits = 4;
    }
#line 1263
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1263
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1263
    goto do_signed_number;
    case 121: 
#line 1267
    if (modifier == 69) {
#line 1278
      goto underlying_strftime;
    }
#line 1283
    yy___0 = (int )(tp->tm_year % 100);
#line 1284
    if (yy___0 < 0) {
#line 1285
      yy___0 = tp->tm_year < -1900 ? - yy___0 : yy___0 + 100;
    }
#line 1286
    digits = 2;
#line 1286
    number_value = yy___0;
#line 1286
    goto do_number;
    case 90: 
#line 1290
    if (change_case) {
#line 1292
      to_uppcase = (_Bool)0;
#line 1293
      to_lowcase = (_Bool)1;
    }
#line 1298
    if (! (zone && *zone) && tp->tm_isdst >= 0) {
#line 1299
      zone = (char const   *)_tzname[tp->tm_isdst != 0];
    }
#line 1301
    if (! zone) {
#line 1302
      zone = "";
    }
#line 1314
    while (1) {
#line 1314
      __cil_tmp___11 = strlen(zone);
#line 1314
      _n___11 = (int )__cil_tmp___11;
#line 1314
      _delta___11 = width - _n___11;
#line 1314
      _incr___11 = _n___11 + (_delta___11 > 0 ? _delta___11 : 0);
#line 1314
      if ((unsigned int )_incr___11 >= maxsize - i) {
#line 1314
        return (0U);
      }
#line 1314
      if (p) {
#line 1314
        if (digits == 0 && _delta___11 > 0) {
#line 1314
          if (pad == 48) {
#line 1314
            while (1) {
#line 1314
              _i___25 = 0U;
#line 1314
              while (_i___25 < (unsigned int )_delta___11) {
#line 1314
                fputc('0', p);
#line 1314
                _i___25 ++;
              }
#line 1314
              break;
            }
          } else {
#line 1314
            while (1) {
#line 1314
              _i___26 = 0U;
#line 1314
              while (_i___26 < (unsigned int )_delta___11) {
#line 1314
                fputc(' ', p);
#line 1314
                _i___26 ++;
              }
#line 1314
              break;
            }
          }
        }
#line 1314
        if (to_lowcase) {
#line 1314
          fwrite_lowcase(p, zone, (unsigned int )_n___11);
        } else
#line 1314
        if (to_uppcase) {
#line 1314
          fwrite_uppcase(p, zone, (unsigned int )_n___11);
        } else {
#line 1314
          fwrite((void const   *)zone, (unsigned int )_n___11, 1U, p);
        }
      }
#line 1314
      i += (unsigned int )_incr___11;
#line 1314
      break;
    }
#line 1316
    break;
    case 58: 
#line 1321
    colons = 1U;
#line 1321
    while ((int const   )*(f + colons) == 58) {
#line 1322
      goto __Cont___0;
      __Cont___0: 
#line 1321
      colons ++;
    }
#line 1323
    if ((int const   )*(f + colons) != 122) {
#line 1324
      goto bad_format;
    }
#line 1325
    f += colons;
#line 1326
    goto do_z_conversion;
    case 122: 
#line 1329
    colons = 0U;
    do_z_conversion: 
#line 1332
    if (tp->tm_isdst < 0) {
#line 1333
      break;
    }
#line 1343
    if (ut) {
#line 1344
      diff = 0;
    } else {
#line 1351
      ltm___0 = (struct tm )*tp;
#line 1352
      lt = rpl_mktime(& ltm___0);
#line 1354
      if (lt == -1L) {
#line 1361
        __cil_tmp___12 = localtime_r((time_t const   *)(& lt), & tm);
#line 1361
        if (__cil_tmp___12) {
#line 1361
          if ((((((ltm___0.tm_sec ^ tm.tm_sec) | (ltm___0.tm_min ^ tm.tm_min)) | (ltm___0.tm_hour ^ tm.tm_hour)) | (ltm___0.tm_mday ^ tm.tm_mday)) | (ltm___0.tm_mon ^ tm.tm_mon)) | (ltm___0.tm_year ^ tm.tm_year)) {
#line 1368
            break;
          }
        } else {
#line 1368
          break;
        }
      }
#line 1371
      __cil_tmp___13 = gmtime_r((time_t const   *)(& lt), & gtm);
#line 1371
      if (! __cil_tmp___13) {
#line 1372
        break;
      }
#line 1374
      diff = ftime_tm_diff((struct tm  const  *)(& ltm___0), (struct tm  const  *)(& gtm));
    }
#line 1378
    hour_diff = (diff / 60) / 60;
#line 1379
    min_diff = (diff / 60) % 60;
#line 1380
    sec_diff = diff % 60;
#line 1382
    switch ((int )colons) {
    case 0: 
#line 1385
    digits = 5;
#line 1385
    negative_number = (_Bool )(diff < 0);
#line 1385
    tz_colon_mask = 0;
#line 1385
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1385
    goto do_tz_offset;
    tz_hh_mm: 
    case 1: 
#line 1388
    digits = 6;
#line 1388
    negative_number = (_Bool )(diff < 0);
#line 1388
    tz_colon_mask = 4;
#line 1388
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1388
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case 2: 
#line 1391
    digits = 9;
#line 1391
    negative_number = (_Bool )(diff < 0);
#line 1391
    tz_colon_mask = 20;
#line 1391
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1391
    goto do_tz_offset;
    case 3: 
#line 1395
    if (sec_diff != 0) {
#line 1396
      goto tz_hh_mm_ss;
    }
#line 1397
    if (min_diff != 0) {
#line 1398
      goto tz_hh_mm;
    }
#line 1399
    digits = 3;
#line 1399
    negative_number = (_Bool )(diff < 0);
#line 1399
    tz_colon_mask = 0;
#line 1399
    u_number_value = (unsigned int )hour_diff;
#line 1399
    goto do_tz_offset;
    default: 
#line 1402
    goto bad_format;
    }
    case 0: 
#line 1407
    f --;
    bad_format: 
    default: 
#line 1416
    flen = 1;
#line 1416
    while ((int const   )*(f + (1 - flen)) != 37) {
#line 1417
      goto __Cont___1;
      __Cont___1: 
#line 1416
      flen ++;
    }
#line 1418
    while (1) {
#line 1418
      _n___12 = flen;
#line 1418
      _delta___12 = width - _n___12;
#line 1418
      _incr___12 = _n___12 + (_delta___12 > 0 ? _delta___12 : 0);
#line 1418
      if ((unsigned int )_incr___12 >= maxsize - i) {
#line 1418
        return (0U);
      }
#line 1418
      if (p) {
#line 1418
        if (digits == 0 && _delta___12 > 0) {
#line 1418
          if (pad == 48) {
#line 1418
            while (1) {
#line 1418
              _i___27 = 0U;
#line 1418
              while (_i___27 < (unsigned int )_delta___12) {
#line 1418
                fputc('0', p);
#line 1418
                _i___27 ++;
              }
#line 1418
              break;
            }
          } else {
#line 1418
            while (1) {
#line 1418
              _i___28 = 0U;
#line 1418
              while (_i___28 < (unsigned int )_delta___12) {
#line 1418
                fputc(' ', p);
#line 1418
                _i___28 ++;
              }
#line 1418
              break;
            }
          }
        }
#line 1418
        if (to_lowcase) {
#line 1418
          fwrite_lowcase(p, f + (1 - flen), (unsigned int )_n___12);
        } else
#line 1418
        if (to_uppcase) {
#line 1418
          fwrite_uppcase(p, f + (1 - flen), (unsigned int )_n___12);
        } else {
#line 1418
          fwrite((void const   *)(f + (1 - flen)), (unsigned int )_n___12, 1U, p);
        }
      }
#line 1418
      i += (unsigned int )_incr___12;
#line 1418
      break;
    }
#line 1420
    break;
    }
    __Cont: 
#line 501
    f ++;
  }
#line 1429
  return (i);
}
}
#line 1438 "strftime.c"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) 
{ size_t __cil_tmp ;

  {
#line 1443
  __cil_tmp = strftime_case_((_Bool)0, s, format, tp, ut, ns);
#line 1443
  return (__cil_tmp);
}
}
#line 1 "frexp.o"
#pragma merger(0,"/tmp/cil-XNkWCo4b.i","-g,-O2")
#line 74 "./math.h"
double rpl_frexp(double x , int *expptr ) ;
#line 24 "isnan.h"
int rpl_isnan(double x ) ;
#line 55 "frexp.c"
double rpl_frexp(double x , int *expptr ) 
{ int sign ;
  int exponent ;
  int __cil_tmp ;
  double pow2[64] ;
  double powh[64] ;
  int i ;
  double pow2_i ;
  double powh_i ;
  double pow2_i___0 ;
  double powh_i___0 ;

  {
#line 63
  __cil_tmp = rpl_isnan(x);
#line 63
  if (__cil_tmp || x + x == x) {
#line 65
    *expptr = 0;
#line 66
    return (x);
  }
#line 69
  sign = 0;
#line 70
  if (x < (double )0) {
#line 72
    x = - x;
#line 73
    sign = -1;
  }
#line 85
  exponent = 0;
#line 86
  if (x >= 1.0) {
#line 94
    i = 0;
#line 94
    pow2_i = 2.0;
#line 94
    powh_i = 0.5;
#line 94
    while (1) {
#line 98
      if (x >= pow2_i) {
#line 100
        exponent += 1 << i;
#line 101
        x *= powh_i;
      } else {
#line 104
        break;
      }
#line 106
      pow2[i] = pow2_i;
#line 107
      powh[i] = powh_i;
#line 94
      i ++;
#line 94
      pow2_i *= pow2_i;
#line 94
      powh_i *= powh_i;
    }
#line 111
    while (i > 0 && x < pow2[i - 1]) {
#line 113
      i --;
#line 114
      powh_i = powh[i];
    }
#line 116
    exponent += 1 << i;
#line 117
    x *= powh_i;
  } else {
#line 128
    i = 0;
#line 128
    pow2_i___0 = 2.0;
#line 128
    powh_i___0 = 0.5;
#line 128
    while (1) {
#line 132
      if (x < powh_i___0) {
#line 134
        exponent -= 1 << i;
#line 135
        x *= pow2_i___0;
      } else {
#line 138
        break;
      }
#line 140
      pow2[i] = pow2_i___0;
#line 141
      powh[i] = powh_i___0;
#line 128
      i ++;
#line 128
      pow2_i___0 *= pow2_i___0;
#line 128
      powh_i___0 *= powh_i___0;
    }
  }
#line 147
  while (i > 0) {
#line 149
    i --;
#line 150
    if (x < powh[i]) {
#line 152
      exponent -= 1 << i;
#line 153
      x *= pow2[i];
    }
  }
#line 159
  if (sign < 0) {
#line 160
    x = - x;
  }
#line 164
  *expptr = exponent;
#line 165
  return (x);
}
}
#line 1 "frexpl.o"
#pragma merger(0,"/tmp/cil-sLpe247p.i","-g,-O2")
#line 210 "./math.h"
long double rpl_frexpl(long double x , int *expptr ) ;
#line 28 "isnanl-nolibm.h"
int rpl_isnanl(long double x ) ;
#line 55 "frexp.c"
long double rpl_frexpl(long double x , int *expptr ) 
{ int sign ;
  int exponent ;
  int __cil_tmp ;
  long double pow2[64] ;
  long double powh[64] ;
  int i ;
  long double pow2_i ;
  long double powh_i ;
  long double pow2_i___0 ;
  long double powh_i___0 ;

  {
#line 63
  __cil_tmp = rpl_isnanl(x);
#line 63
  if (__cil_tmp || x + x == x) {
#line 65
    *expptr = 0;
#line 66
    return (x);
  }
#line 69
  sign = 0;
#line 70
  if (x < (long double )0) {
#line 72
    x = - x;
#line 73
    sign = -1;
  }
#line 85
  exponent = 0;
#line 86
  if (x >= 1.0L) {
#line 94
    i = 0;
#line 94
    pow2_i = 2.0L;
#line 94
    powh_i = 0.5L;
#line 94
    while (1) {
#line 98
      if (x >= pow2_i) {
#line 100
        exponent += 1 << i;
#line 101
        x *= powh_i;
      } else {
#line 104
        break;
      }
#line 106
      pow2[i] = pow2_i;
#line 107
      powh[i] = powh_i;
#line 94
      i ++;
#line 94
      pow2_i *= pow2_i;
#line 94
      powh_i *= powh_i;
    }
#line 111
    while (i > 0 && x < pow2[i - 1]) {
#line 113
      i --;
#line 114
      powh_i = powh[i];
    }
#line 116
    exponent += 1 << i;
#line 117
    x *= powh_i;
  } else {
#line 128
    i = 0;
#line 128
    pow2_i___0 = 2.0L;
#line 128
    powh_i___0 = 0.5L;
#line 128
    while (1) {
#line 132
      if (x < powh_i___0) {
#line 134
        exponent -= 1 << i;
#line 135
        x *= pow2_i___0;
      } else {
#line 138
        break;
      }
#line 140
      pow2[i] = pow2_i___0;
#line 141
      powh[i] = powh_i___0;
#line 128
      i ++;
#line 128
      pow2_i___0 *= pow2_i___0;
#line 128
      powh_i___0 *= powh_i___0;
    }
  }
#line 147
  while (i > 0) {
#line 149
    i --;
#line 150
    if (x < powh[i]) {
#line 152
      exponent -= 1 << i;
#line 153
      x *= pow2[i];
    }
  }
#line 159
  if (sign < 0) {
#line 160
    x = - x;
  }
#line 164
  *expptr = exponent;
#line 165
  return (x);
}
}
#line 1 "fseeko.o"
#pragma merger(0,"/tmp/cil-CteahUr2.i","-g,-O2")
#line 236 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int fseeko(FILE * , off_t  , int  ) ;
#line 118 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern off_t lseek(int __fildes , off_t __offset , int __whence ) ;
#line 34 "fseeko.c"
int rpl_fseeko(FILE *fp , off_t offset , int whence ) 
{ off_t pos ;
  int __cil_tmp ;
  off_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 69
  if ((((unsigned int )fp->_p == (unsigned int )fp->_bf._base && fp->_r == 0) && fp->_w == (((int )fp->_flags & 7) == 0 ? fp->_bf._size : 0)) && (unsigned int )fp->_ub._base == (unsigned int )((void *)0)) {
#line 103
    __cil_tmp = fileno(fp);
#line 103
    __cil_tmp___0 = lseek(__cil_tmp, offset, whence);
#line 103
    pos = __cil_tmp___0;
#line 104
    if (pos == -1L) {
#line 107
      fp->_flags = (short )((int )fp->_flags & -4097);
#line 109
      return (-1);
    } else {
#line 114
      fp->_offset = (int )pos;
#line 115
      fp->_flags = (short )((int )fp->_flags | 4096);
#line 116
      fp->_flags = (short )((int )fp->_flags & -33);
#line 120
      return (0);
    }
  } else {
#line 124
    __cil_tmp___1 = fseeko(fp, offset, whence);
#line 124
    return (__cil_tmp___1);
  }
}
}
#line 1 "ftruncate.o"
#pragma merger(0,"/tmp/cil-StQuMNya.i","-g,-O2")
#line 125 "./unistd.h"
int ftruncate(int fd , off_t length ) ;
#line 81 "ftruncate.c"
int ftruncate(int fd , off_t length ) 
{ int *__cil_tmp ;

  {
#line 84
  __cil_tmp = __errno();
#line 84
  *__cil_tmp = 5;
#line 85
  return (-1);
}
}
#line 1 "fts.o"
#pragma merger(0,"/tmp/cil-EKe80KZ9.i","-g,-O2")
#line 41 "i-ring.h"
void i_ring_init(I_ring *ir , int default_val ) ;
#line 42
int i_ring_push(I_ring *ir , int val ) ;
#line 43
int i_ring_pop(I_ring *ir ) ;
#line 44
_Bool i_ring_empty(I_ring const   *ir ) ;
#line 224 "fts_.h"
FTSENT *fts_children(FTS *sp , int instr ) ;
#line 225
int fts_close(FTS *sp ) ;
#line 226
FTS *fts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                FTSENT const   ** ) ) ;
#line 228
FTSENT *fts_read(FTS *sp ) ;
#line 229
int fts_set(FTS *sp , FTSENT *p , int instr ) ;
#line 119 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*_compar)(void const   * ,
                                                                                 void const   * ) ) ;
#line 39 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strrchr(char const   * , int  ) ;
#line 20 "lstat.h"
int rpl_lstat(char const   *file , struct stat *sbuf ) ;
#line 72 "openat.h"
DIR *rpl_fdopendir(int fd ) ;
#line 74
int rpl_fstatat(int fd , char const   *file , struct stat *st , int flag ) ;
#line 77
_Bool openat_needs_fchdir(void) ;
#line 152 "fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
#line 153
static FTSENT *fts_build(FTS *sp , int type ) ;
#line 154
static void fts_lfree(FTSENT *head ) ;
#line 155
static void fts_load(FTS *sp , FTSENT *p ) ;
#line 156
static size_t fts_maxarglen(char * const  *argv ) ;
#line 157
static void fts_padjust(FTS *sp , FTSENT *head ) ;
#line 158
static _Bool fts_palloc(FTS *sp , size_t more ) ;
#line 159
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 160
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 161
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 85 "hash.h"
void *hash_delete(Hash_table *table___0 , void const   *entry ) ;
#line 31 "fts-cycle.c"
static _Bool AD_compare(void const   *x , void const   *y ) 
{ struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  return ((_Bool )((int const   )ax->ino == (int const   )ay->ino && (int const   )ax->dev == (int const   )ay->dev));
}
}
#line 40 "fts-cycle.c"
static size_t AD_hash(void const   *x , size_t table_size ) 
{ struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((unsigned int )((unsigned long long )ax->ino % (unsigned long long )table_size));
}
}
#line 49 "fts-cycle.c"
static _Bool setup_dir(FTS *fts ) 
{ void *__cil_tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
#line 55
    fts->fts_cycle.ht = hash_initialize(31U, (Hash_tuning const   *)((void *)0), & AD_hash,
                                        & AD_compare, & free);
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
#line 62
    __cil_tmp = rpl_malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)__cil_tmp;
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
#line 65
    cycle_check_init(fts->fts_cycle.state);
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "fts-cycle.c"
static _Bool enter_dir(FTS *fts , FTSENT *ent ) 
{ struct stat  const  *st ;
  struct Active_dir *ad ;
  void *__cil_tmp ;
  struct Active_dir *ad_from_table ;
  void *__cil_tmp___0 ;
  _Bool __cil_tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    __cil_tmp = rpl_malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)__cil_tmp;
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
#line 85
    ad->dev = (short )st->st_dev;
#line 86
    ad->ino = (unsigned short )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    __cil_tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)__cil_tmp___0;
#line 94
    if ((unsigned int )ad_from_table != (unsigned int )ad) {
#line 96
      free((void *)ad);
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
#line 108
    __cil_tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
#line 108
    if (__cil_tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "fts-cycle.c"
static void leave_dir(FTS *fts , FTSENT *ent ) 
{ struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
#line 132
    obj.dev = (short )st->st_dev;
#line 133
    obj.ino = (unsigned short )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
#line 135
    if (! found) {
#line 136
      abort();
    }
#line 137
    free(found);
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned int )parent != (unsigned int )((void *)0) && 0LL <= parent->fts_level) {
#line 143
      while (1) {
#line 143
        if ((fts->fts_cycle.state)->chdir_counter == 0ULL) {
#line 143
          abort();
        }
#line 143
        if ((int )(fts->fts_cycle.state)->dev_ino.st_ino == (int )st->st_ino && (int )(fts->fts_cycle.state)->dev_ino.st_dev == (int )st->st_dev) {
#line 143
          (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
          (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
        }
#line 143
        break;
      }
    }
  }
#line 146
  return;
}
}
#line 150 "fts-cycle.c"
static void free_dir(FTS *sp ) 
{ 

  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
#line 156
      hash_free(sp->fts_cycle.ht);
    }
  } else {
#line 159
    free((void *)sp->fts_cycle.state);
  }
#line 160
  return;
}
}
#line 233 "fts.c"
static void fd_ring_clear(I_ring *fd_ring ) 
{ int fd ;
  int __cil_tmp ;
  _Bool __cil_tmp___0 ;

  {
#line 236
  while (1) {
#line 236
    __cil_tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
#line 236
    if (__cil_tmp___0) {
#line 236
      break;
    }
#line 238
    __cil_tmp = i_ring_pop(fd_ring);
#line 238
    fd = __cil_tmp;
#line 239
    if (0 <= fd) {
#line 240
      close(fd);
    }
  }
#line 242
  return;
}
}
#line 247 "fts.c"
static void fts_set_stat_required(FTSENT *p , _Bool required ) 
{ 

  {
#line 250
  while (1) {
#line 250
    if (! ((int )p->fts_info == 11)) {
#line 250
      abort();
    }
#line 250
    break;
  }
#line 251
  p->fts_statp[0].st_size = (long )(required ? 2 : 1);
#line 254
  return;
}
}
#line 258 "fts.c"
__inline static DIR *opendirat(int fd , char const   *dir ) 
{ int new_fd ;
  int __cil_tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 262
  __cil_tmp = rpl_openat(fd, dir, 1);
#line 262
  new_fd = __cil_tmp;
#line 265
  if (new_fd < 0) {
#line 266
    return ((DIR *)((void *)0));
  }
#line 267
  dirp = rpl_fdopendir(new_fd);
#line 268
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 270
    __cil_tmp___0 = __errno();
#line 270
    saved_errno = *__cil_tmp___0;
#line 271
    close(new_fd);
#line 272
    __cil_tmp___1 = __errno();
#line 272
    *__cil_tmp___1 = saved_errno;
  }
#line 274
  return (dirp);
}
}
#line 282 "fts.c"
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) 
{ int old ;
  int prev_fd_in_slot ;
  int __cil_tmp ;

  {
#line 286
  old = sp->fts_cwd_fd;
#line 287
  while (1) {
#line 287
    if (! (old != fd || old == -3041965)) {
#line 287
      abort();
    }
#line 287
    break;
  }
#line 289
  if (chdir_down_one) {
#line 293
    __cil_tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 293
    prev_fd_in_slot = __cil_tmp;
#line 295
    if (0 <= prev_fd_in_slot) {
#line 296
      close(prev_fd_in_slot);
    }
  } else
#line 298
  if (! (sp->fts_options & 4)) {
#line 300
    if (0 <= old) {
#line 301
      close(old);
    }
  }
#line 304
  sp->fts_cwd_fd = fd;
#line 305
  return;
}
}
#line 311 "fts.c"
__inline static int diropen(FTS const   *sp , char const   *dir ) 
{ int open_flags ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 315
  open_flags = 145 | (sp->fts_options & 16 ? 0 : 0);
#line 318
  if (sp->fts_options & 512) {
#line 318
    __cil_tmp = rpl_openat((int )sp->fts_cwd_fd, dir, open_flags);
#line 318
    __cil_tmp___1 = __cil_tmp;
  } else {
#line 318
    __cil_tmp___0 = open_safer(dir, open_flags);
#line 318
    __cil_tmp___1 = __cil_tmp___0;
  }
#line 318
  return (__cil_tmp___1);
}
}
#line 323 "fts.c"
FTS *fts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                FTSENT const   ** ) ) 
{ register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  size_t len ;
  _Bool defer_stat ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  int fd ;
  int __cil_tmp___3 ;
  _Bool __cil_tmp___4 ;
  size_t maxarglen ;
  size_t __cil_tmp___5 ;
  _Bool __cil_tmp___6 ;
  int *__cil_tmp___7 ;
  struct _ftsent *__cil_tmp___8 ;
  _Bool __cil_tmp___9 ;
  int __cil_tmp___10 ;

  {
#line 331
  parent = (FTSENT *)((void *)0);
#line 332
  tmp = (FTSENT *)((void *)0);
#line 337
  if (options & -2048) {
#line 338
    __cil_tmp = __errno();
#line 338
    *__cil_tmp = 22;
#line 339
    return ((FTS *)((void *)0));
  }
#line 341
  if (options & 4 && options & 512) {
#line 342
    __cil_tmp___0 = __errno();
#line 342
    *__cil_tmp___0 = 22;
#line 343
    return ((FTS *)((void *)0));
  }
#line 345
  if (! (options & 18)) {
#line 346
    __cil_tmp___1 = __errno();
#line 346
    *__cil_tmp___1 = 22;
#line 347
    return ((FTS *)((void *)0));
  }
#line 351
  __cil_tmp___2 = rpl_malloc(sizeof(FTS ));
#line 351
  sp = (FTS *)__cil_tmp___2;
#line 351
  if ((unsigned int )sp == (unsigned int )((void *)0)) {
#line 352
    return ((FTS *)((void *)0));
  }
#line 353
  memset((void *)sp, 0, sizeof(FTS ));
#line 354
  sp->fts_compar = compar;
#line 355
  sp->fts_options = options;
#line 358
  if (sp->fts_options & 2) {
#line 359
    sp->fts_options |= 4;
#line 360
    sp->fts_options &= -513;
  }
#line 364
  sp->fts_cwd_fd = -3041965;
#line 365
  if (sp->fts_options & 512) {
#line 371
    __cil_tmp___3 = open_safer(".", 1);
#line 371
    fd = __cil_tmp___3;
#line 372
    if (fd < 0) {
#line 385
      __cil_tmp___4 = openat_needs_fchdir();
#line 385
      if (__cil_tmp___4) {
#line 387
        sp->fts_options |= 4;
#line 388
        sp->fts_options &= -513;
      }
    } else {
#line 393
      close(fd);
    }
  }
#line 405
  __cil_tmp___5 = fts_maxarglen(argv);
#line 405
  maxarglen = __cil_tmp___5;
#line 406
  __cil_tmp___6 = fts_palloc(sp, maxarglen > 1024U ? maxarglen : 1024U);
#line 406
  if (! __cil_tmp___6) {
#line 407
    goto mem1;
  }
#line 411
  if ((unsigned int )*argv != (unsigned int )((void *)0)) {
#line 412
    parent = fts_alloc(sp, "", 0U);
#line 412
    if ((unsigned int )parent == (unsigned int )((void *)0)) {
#line 413
      goto mem2;
    }
#line 414
    parent->fts_level = -1LL;
  }
#line 428
  defer_stat = (_Bool )((unsigned int )compar == (unsigned int )((void *)0) || sp->fts_options & 1024);
#line 431
  root = (FTSENT *)((void *)0);
#line 431
  nitems = 0U;
#line 431
  while ((unsigned int )*argv != (unsigned int )((void *)0)) {
#line 433
    len = strlen((char const   *)*argv);
#line 433
    if (len == 0U) {
#line 434
      __cil_tmp___7 = __errno();
#line 434
      *__cil_tmp___7 = 2;
#line 435
      goto mem3;
    }
#line 438
    p = fts_alloc(sp, (char const   *)*argv, len);
#line 438
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 439
      goto mem3;
    }
#line 440
    p->fts_level = 0LL;
#line 441
    p->fts_parent = parent;
#line 442
    p->fts_accpath = p->fts_name;
#line 446
    if (defer_stat && (unsigned int )root != (unsigned int )((void *)0)) {
#line 447
      p->fts_info = (unsigned short)11;
#line 448
      fts_set_stat_required(p, (_Bool)1);
    } else {
#line 450
      p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
#line 457
    if (compar) {
#line 458
      p->fts_link = root;
#line 459
      root = p;
    } else {
#line 461
      p->fts_link = (struct _ftsent *)((void *)0);
#line 462
      if ((unsigned int )root == (unsigned int )((void *)0)) {
#line 463
        root = p;
#line 463
        tmp = root;
      } else {
#line 465
        tmp->fts_link = p;
#line 466
        tmp = p;
      }
    }
#line 431
    argv ++;
#line 431
    nitems ++;
  }
#line 470
  if (compar && nitems > 1U) {
#line 471
    root = fts_sort(sp, root, nitems);
  }
#line 478
  __cil_tmp___8 = fts_alloc(sp, "", 0U);
#line 478
  sp->fts_cur = __cil_tmp___8;
#line 478
  if ((unsigned int )__cil_tmp___8 == (unsigned int )((void *)0)) {
#line 479
    goto mem3;
  }
#line 480
  (sp->fts_cur)->fts_link = root;
#line 481
  (sp->fts_cur)->fts_info = (unsigned short)9;
#line 482
  __cil_tmp___9 = setup_dir(sp);
#line 482
  if (! __cil_tmp___9) {
#line 483
    goto mem3;
  }
#line 492
  if (! (sp->fts_options & 4) && ! (sp->fts_options & 512)) {
#line 492
    __cil_tmp___10 = diropen((FTS const   *)sp, ".");
#line 492
    sp->fts_rfd = __cil_tmp___10;
#line 492
    if (__cil_tmp___10 < 0) {
#line 494
      sp->fts_options |= 4;
    }
  }
#line 496
  i_ring_init(& sp->fts_fd_ring, -1);
#line 497
  return (sp);
  mem3: 
#line 499
  fts_lfree(root);
#line 500
  free((void *)parent);
  mem2: 
#line 501
  free((void *)sp->fts_path);
  mem1: 
#line 502
  free((void *)sp);
#line 503
  return ((FTS *)((void *)0));
}
}
#line 506 "fts.c"
static void fts_load(FTS *sp , FTSENT *p ) 
{ register size_t len ;
  register char *cp ;
  size_t __cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 520
  __cil_tmp = p->fts_namelen;
#line 520
  p->fts_pathlen = __cil_tmp;
#line 520
  len = __cil_tmp;
#line 521
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1U);
#line 522
  cp = strrchr((char const   *)(p->fts_name), '/');
#line 522
  if (cp && ((unsigned int )cp != (unsigned int )(p->fts_name) || *(cp + 1))) {
#line 523
    cp ++;
#line 523
    len = strlen((char const   *)cp);
#line 524
    memmove((void *)(p->fts_name), (void const   *)cp, len + 1U);
#line 525
    p->fts_namelen = len;
  }
#line 527
  __cil_tmp___0 = sp->fts_path;
#line 527
  p->fts_path = __cil_tmp___0;
#line 527
  p->fts_accpath = __cil_tmp___0;
#line 528
  return;
}
}
#line 530 "fts.c"
int fts_close(FTS *sp ) 
{ register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 534
  saved_errno = 0;
#line 541
  if (sp->fts_cur) {
#line 542
    p = sp->fts_cur;
#line 542
    while (p->fts_level >= 0LL) {
#line 543
      freep = p;
#line 544
      p = (unsigned int )p->fts_link != (unsigned int )((void *)0) ? p->fts_link : p->fts_parent;
#line 545
      free((void *)freep);
    }
#line 547
    free((void *)p);
  }
#line 551
  if (sp->fts_child) {
#line 552
    fts_lfree(sp->fts_child);
  }
#line 553
  free((void *)sp->fts_array);
#line 554
  free((void *)sp->fts_path);
#line 556
  if (sp->fts_options & 512) {
#line 558
    if (0 <= sp->fts_cwd_fd) {
#line 559
      close(sp->fts_cwd_fd);
    }
  } else
#line 561
  if (! (sp->fts_options & 4)) {
#line 564
    __cil_tmp___0 = fchdir(sp->fts_rfd);
#line 564
    if (__cil_tmp___0) {
#line 565
      __cil_tmp = __errno();
#line 565
      saved_errno = *__cil_tmp;
    }
#line 566
    close(sp->fts_rfd);
  }
#line 569
  fd_ring_clear(& sp->fts_fd_ring);
#line 570
  free_dir(sp);
#line 573
  free((void *)sp);
#line 576
  if (saved_errno) {
#line 577
    __cil_tmp___1 = __errno();
#line 577
    *__cil_tmp___1 = saved_errno;
#line 578
    return (-1);
  }
#line 581
  return (0);
}
}
#line 592 "fts.c"
FTSENT *fts_read(FTS *sp ) 
{ register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  struct _ftsent *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int __cil_tmp___8 ;
  char *__cil_tmp___9 ;
  int *__cil_tmp___10 ;
  _Bool __cil_tmp___11 ;
  int *__cil_tmp___12 ;
  struct _ftsent *__cil_tmp___13 ;
  int *__cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  int __cil_tmp___17 ;
  int saved_errno ;
  int *__cil_tmp___18 ;
  int *__cil_tmp___19 ;
  int *__cil_tmp___20 ;
  int __cil_tmp___21 ;
  int __cil_tmp___22 ;
  int *__cil_tmp___23 ;
  int __cil_tmp___24 ;

  {
#line 600
  if ((unsigned int )sp->fts_cur == (unsigned int )((void *)0) || sp->fts_options & 8192) {
#line 601
    return ((FTSENT *)((void *)0));
  }
#line 604
  p = sp->fts_cur;
#line 607
  instr = p->fts_instr;
#line 608
  p->fts_instr = (unsigned short)3;
#line 611
  if ((int )instr == 1) {
#line 612
    p->fts_info = fts_stat(sp, p, (_Bool)0);
#line 613
    return (p);
  }
#line 624
  if ((int )instr == 2 && ((int )p->fts_info == 12 || (int )p->fts_info == 13)) {
#line 626
    p->fts_info = fts_stat(sp, p, (_Bool)1);
#line 627
    if ((int )p->fts_info == 1 && ! (sp->fts_options & 4)) {
#line 628
      __cil_tmp___0 = diropen((FTS const   *)sp, ".");
#line 628
      p->fts_symfd = __cil_tmp___0;
#line 628
      if (__cil_tmp___0 < 0) {
#line 629
        __cil_tmp = __errno();
#line 629
        p->fts_errno = *__cil_tmp;
#line 630
        p->fts_info = (unsigned short)7;
      } else {
#line 632
        p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
      }
    }
#line 634
    goto check_for_dir;
  }
#line 638
  if ((int )p->fts_info == 1) {
#line 640
    if ((int )instr == 4 || (sp->fts_options & 64 && (int )p->fts_statp[0].st_dev != (int )sp->fts_dev)) {
#line 642
      if ((int )p->fts_flags & 2) {
#line 643
        close(p->fts_symfd);
      }
#line 644
      if (sp->fts_child) {
#line 645
        fts_lfree(sp->fts_child);
#line 646
        sp->fts_child = (struct _ftsent *)((void *)0);
      }
#line 648
      p->fts_info = (unsigned short)6;
#line 649
      while (1) {
#line 649
        leave_dir(sp, p);
#line 649
        break;
      }
#line 650
      return (p);
    }
#line 654
    if ((unsigned int )sp->fts_child != (unsigned int )((void *)0) && sp->fts_options & 4096) {
#line 655
      sp->fts_options &= -4097;
#line 656
      fts_lfree(sp->fts_child);
#line 657
      sp->fts_child = (struct _ftsent *)((void *)0);
    }
#line 672
    if ((unsigned int )sp->fts_child != (unsigned int )((void *)0)) {
#line 673
      __cil_tmp___2 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
#line 673
      if (__cil_tmp___2) {
#line 674
        __cil_tmp___1 = __errno();
#line 674
        p->fts_errno = *__cil_tmp___1;
#line 675
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
#line 676
        p = sp->fts_child;
#line 676
        while ((unsigned int )p != (unsigned int )((void *)0)) {
#line 678
          p->fts_accpath = (p->fts_parent)->fts_accpath;
#line 676
          p = p->fts_link;
        }
      }
    } else {
#line 681
      __cil_tmp___3 = fts_build(sp, 3);
#line 681
      sp->fts_child = __cil_tmp___3;
#line 681
      if ((unsigned int )__cil_tmp___3 == (unsigned int )((void *)0)) {
#line 682
        if (sp->fts_options & 8192) {
#line 683
          return ((FTSENT *)((void *)0));
        }
#line 687
        if (p->fts_errno && (int )p->fts_info != 4) {
#line 688
          p->fts_info = (unsigned short)7;
        }
#line 689
        while (1) {
#line 689
          leave_dir(sp, p);
#line 689
          break;
        }
#line 690
        return (p);
      }
    }
#line 692
    p = sp->fts_child;
#line 693
    sp->fts_child = (struct _ftsent *)((void *)0);
#line 694
    goto name;
  }
  next: 
#line 698
  tmp = p;
#line 699
  p = p->fts_link;
#line 699
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 700
    sp->fts_cur = p;
#line 701
    free((void *)tmp);
#line 708
    if (p->fts_level == 0LL) {
#line 709
      fd_ring_clear(& sp->fts_fd_ring);
#line 709
      if (! (sp->fts_options & 4)) {
#line 709
        if (sp->fts_options & 512) {
#line 709
          cwd_advance_fd(sp, sp->fts_options & 512 ? -3041965 : sp->fts_rfd, (_Bool)1);
#line 709
          __cil_tmp___5 = 0;
        } else {
#line 709
          __cil_tmp___4 = fchdir(sp->fts_options & 512 ? -3041965 : sp->fts_rfd);
#line 709
          __cil_tmp___5 = __cil_tmp___4;
        }
#line 709
        if (__cil_tmp___5) {
#line 709
          __cil_tmp___6 = 1;
        } else {
#line 709
          __cil_tmp___6 = 0;
        }
      } else {
#line 709
        __cil_tmp___6 = 0;
      }
#line 709
      if (__cil_tmp___6) {
#line 710
        sp->fts_options |= 8192;
#line 711
        return ((FTSENT *)((void *)0));
      }
#line 713
      fts_load(sp, p);
#line 714
      goto check_for_dir;
    }
#line 722
    if ((int )p->fts_instr == 4) {
#line 723
      goto next;
    }
#line 724
    if ((int )p->fts_instr == 2) {
#line 725
      p->fts_info = fts_stat(sp, p, (_Bool)1);
#line 726
      if ((int )p->fts_info == 1 && ! (sp->fts_options & 4)) {
#line 727
        __cil_tmp___8 = diropen((FTS const   *)sp, ".");
#line 727
        p->fts_symfd = __cil_tmp___8;
#line 727
        if (__cil_tmp___8 < 0) {
#line 728
          __cil_tmp___7 = __errno();
#line 728
          p->fts_errno = *__cil_tmp___7;
#line 729
          p->fts_info = (unsigned short)7;
        } else {
#line 731
          p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
        }
      }
#line 733
      p->fts_instr = (unsigned short)3;
    }
    name: 
#line 736
    t = sp->fts_path + ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1U)) == 47 ? (p->fts_parent)->fts_pathlen - 1U : (p->fts_parent)->fts_pathlen);
#line 737
    __cil_tmp___9 = t;
#line 737
    t ++;
#line 737
    *__cil_tmp___9 = (char )'/';
#line 738
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1U);
    check_for_dir: 
#line 740
    sp->fts_cur = p;
#line 741
    if ((int )p->fts_info == 11) {
#line 743
      if (p->fts_statp[0].st_size == 2L) {
#line 744
        p->fts_info = fts_stat(sp, p, (_Bool)0);
      } else {
#line 746
        while (1) {
#line 746
          if (! (p->fts_statp[0].st_size == 1L)) {
#line 746
            abort();
          }
#line 746
          break;
        }
      }
    }
#line 749
    if ((int )p->fts_info == 1) {
#line 754
      if (p->fts_level == 0LL) {
#line 755
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
#line 757
      __cil_tmp___11 = enter_dir(sp, p);
#line 757
      if (! __cil_tmp___11) {
#line 759
        __cil_tmp___10 = __errno();
#line 759
        *__cil_tmp___10 = 12;
#line 760
        return ((FTSENT *)((void *)0));
      }
    }
#line 763
    return (p);
  }
#line 767
  p = tmp->fts_parent;
#line 768
  sp->fts_cur = p;
#line 769
  free((void *)tmp);
#line 771
  if (p->fts_level == -1LL) {
#line 776
    free((void *)p);
#line 777
    __cil_tmp___12 = __errno();
#line 777
    *__cil_tmp___12 = 0;
#line 778
    __cil_tmp___13 = (struct _ftsent *)((void *)0);
#line 778
    sp->fts_cur = __cil_tmp___13;
#line 778
    return (__cil_tmp___13);
  }
#line 781
  while (1) {
#line 781
    if (! ((int )p->fts_info != 11)) {
#line 781
      abort();
    }
#line 781
    break;
  }
#line 784
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 792
  if (p->fts_level == 0LL) {
#line 793
    fd_ring_clear(& sp->fts_fd_ring);
#line 793
    if (! (sp->fts_options & 4)) {
#line 793
      if (sp->fts_options & 512) {
#line 793
        cwd_advance_fd(sp, sp->fts_options & 512 ? -3041965 : sp->fts_rfd, (_Bool)1);
#line 793
        __cil_tmp___16 = 0;
      } else {
#line 793
        __cil_tmp___15 = fchdir(sp->fts_options & 512 ? -3041965 : sp->fts_rfd);
#line 793
        __cil_tmp___16 = __cil_tmp___15;
      }
#line 793
      if (__cil_tmp___16) {
#line 793
        __cil_tmp___17 = 1;
      } else {
#line 793
        __cil_tmp___17 = 0;
      }
    } else {
#line 793
      __cil_tmp___17 = 0;
    }
#line 793
    if (__cil_tmp___17) {
#line 794
      __cil_tmp___14 = __errno();
#line 794
      p->fts_errno = *__cil_tmp___14;
#line 795
      sp->fts_options |= 8192;
    }
  } else
#line 797
  if ((int )p->fts_flags & 2) {
#line 798
    if (! (sp->fts_options & 4)) {
#line 798
      if (sp->fts_options & 512) {
#line 798
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
#line 798
        __cil_tmp___22 = 0;
      } else {
#line 798
        __cil_tmp___21 = fchdir(p->fts_symfd);
#line 798
        __cil_tmp___22 = __cil_tmp___21;
      }
#line 798
      if (__cil_tmp___22) {
#line 799
        __cil_tmp___18 = __errno();
#line 799
        saved_errno = *__cil_tmp___18;
#line 800
        close(p->fts_symfd);
#line 801
        __cil_tmp___19 = __errno();
#line 801
        *__cil_tmp___19 = saved_errno;
#line 802
        __cil_tmp___20 = __errno();
#line 802
        p->fts_errno = *__cil_tmp___20;
#line 803
        sp->fts_options |= 8192;
      }
    }
#line 805
    close(p->fts_symfd);
  } else
#line 806
  if (! ((int )p->fts_flags & 1)) {
#line 806
    __cil_tmp___24 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
#line 806
    if (__cil_tmp___24) {
#line 808
      __cil_tmp___23 = __errno();
#line 808
      p->fts_errno = *__cil_tmp___23;
#line 809
      sp->fts_options |= 8192;
    }
  }
#line 811
  p->fts_info = (unsigned short )(p->fts_errno ? 7 : 6);
#line 812
  if (p->fts_errno == 0) {
#line 813
    while (1) {
#line 813
      leave_dir(sp, p);
#line 813
      break;
    }
  }
#line 814
  return (sp->fts_options & 8192 ? (FTSENT *)((void *)0) : p);
}
}
#line 824 "fts.c"
int fts_set(FTS *sp , FTSENT *p , int instr ) 
{ int *__cil_tmp ;

  {
#line 827
  if ((((instr != 0 && instr != 1) && instr != 2) && instr != 3) && instr != 4) {
#line 829
    __cil_tmp = __errno();
#line 829
    *__cil_tmp = 22;
#line 830
    return (1);
  }
#line 832
  p->fts_instr = (unsigned short )instr;
#line 833
  return (0);
}
}
#line 836 "fts.c"
FTSENT *fts_children(FTS *sp , int instr ) 
{ register FTSENT *p ;
  int fd ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  struct _ftsent *__cil_tmp___1 ;
  struct _ftsent *__cil_tmp___2 ;
  int saved_errno ;
  int *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int __cil_tmp___5 ;

  {
#line 842
  if (instr != 0 && instr != 4096) {
#line 843
    __cil_tmp = __errno();
#line 843
    *__cil_tmp = 22;
#line 844
    return ((FTSENT *)((void *)0));
  }
#line 848
  p = sp->fts_cur;
#line 854
  __cil_tmp___0 = __errno();
#line 854
  *__cil_tmp___0 = 0;
#line 857
  if (sp->fts_options & 8192) {
#line 858
    return ((FTSENT *)((void *)0));
  }
#line 861
  if ((int )p->fts_info == 9) {
#line 862
    return (p->fts_link);
  }
#line 869
  if ((int )p->fts_info != 1) {
#line 870
    return ((FTSENT *)((void *)0));
  }
#line 873
  if ((unsigned int )sp->fts_child != (unsigned int )((void *)0)) {
#line 874
    fts_lfree(sp->fts_child);
  }
#line 876
  if (instr == 4096) {
#line 877
    sp->fts_options |= 4096;
#line 878
    instr = 2;
  } else {
#line 880
    instr = 1;
  }
#line 889
  if ((p->fts_level != 0LL || (int )*(p->fts_accpath + 0) == 47) || sp->fts_options & 4) {
#line 891
    __cil_tmp___1 = fts_build(sp, instr);
#line 891
    sp->fts_child = __cil_tmp___1;
#line 891
    return (__cil_tmp___1);
  }
#line 893
  fd = diropen((FTS const   *)sp, ".");
#line 893
  if (fd < 0) {
#line 894
    __cil_tmp___2 = (struct _ftsent *)((void *)0);
#line 894
    sp->fts_child = __cil_tmp___2;
#line 894
    return (__cil_tmp___2);
  }
#line 895
  sp->fts_child = fts_build(sp, instr);
#line 896
  if (sp->fts_options & 512) {
#line 898
    cwd_advance_fd(sp, fd, (_Bool)1);
  } else {
#line 902
    __cil_tmp___5 = fchdir(fd);
#line 902
    if (__cil_tmp___5) {
#line 904
      __cil_tmp___3 = __errno();
#line 904
      saved_errno = *__cil_tmp___3;
#line 905
      close(fd);
#line 906
      __cil_tmp___4 = __errno();
#line 906
      *__cil_tmp___4 = saved_errno;
#line 907
      return ((FTSENT *)((void *)0));
    }
#line 909
    close(fd);
  }
#line 911
  return (sp->fts_child);
}
}
#line 928 "fts.c"
static FTSENT *fts_build(FTS *sp , int type ) 
{ register struct dirent *dp ;
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *cur ;
  FTSENT *tail ;
  DIR *dirp ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int *__cil_tmp ;
  DIR *__cil_tmp___0 ;
  DIR *__cil_tmp___1 ;
  int dir_fd ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  char *__cil_tmp___5 ;
  _Bool is_dir ;
  size_t __cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  size_t __cil_tmp___9 ;
  _Bool __cil_tmp___10 ;
  size_t __cil_tmp___11 ;
  size_t __cil_tmp___12 ;
  int *__cil_tmp___13 ;
  _Bool skip_stat ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  int __cil_tmp___17 ;
  int __cil_tmp___18 ;

  {
#line 948
  cur = sp->fts_cur;
#line 965
  if (! (sp->fts_options & 4) && sp->fts_options & 512) {
#line 965
    __cil_tmp___0 = opendirat(sp->fts_cwd_fd, (char const   *)cur->fts_accpath);
#line 965
    dirp = __cil_tmp___0;
  } else {
#line 965
    __cil_tmp___1 = opendir((char const   *)cur->fts_accpath);
#line 965
    dirp = __cil_tmp___1;
  }
#line 965
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 966
    if (type == 3) {
#line 967
      cur->fts_info = (unsigned short)4;
#line 968
      __cil_tmp = __errno();
#line 968
      cur->fts_errno = *__cil_tmp;
    }
#line 970
    return ((FTSENT *)((void *)0));
  }
#line 975
  if ((int )cur->fts_info == 11) {
#line 976
    cur->fts_info = fts_stat(sp, cur, (_Bool)0);
  }
#line 983
  if (type == 2) {
#line 984
    nlinks = (unsigned short)0;
#line 986
    nostat = (_Bool)0;
  } else
#line 987
  if (sp->fts_options & 8 && sp->fts_options & 16) {
#line 988
    nlinks = (unsigned short )((int )cur->fts_statp[0].st_nlink - (sp->fts_options & 32 ? 0 : 2));
#line 990
    nostat = (_Bool)1;
  } else {
#line 992
    nlinks = (unsigned short)65535;
#line 993
    nostat = (_Bool)0;
  }
#line 1011
  if (nlinks || type == 3) {
#line 1012
    __cil_tmp___2 = dirfd((DIR const   *)dirp);
#line 1012
    dir_fd = __cil_tmp___2;
#line 1013
    if (sp->fts_options & 512 && 0 <= dir_fd) {
#line 1014
      dir_fd = dup_safer(dir_fd);
    }
#line 1015
    if (dir_fd < 0) {
#line 1015
      goto _L;
    } else {
#line 1015
      __cil_tmp___4 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
#line 1015
      if (__cil_tmp___4) {
        _L: 
#line 1016
        if (nlinks && type == 3) {
#line 1017
          __cil_tmp___3 = __errno();
#line 1017
          cur->fts_errno = *__cil_tmp___3;
        }
#line 1018
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1019
        descend = (_Bool)0;
#line 1020
        closedir(dirp);
#line 1021
        if (sp->fts_options & 512 && 0 <= dir_fd) {
#line 1022
          close(dir_fd);
        }
#line 1023
        dirp = (DIR *)((void *)0);
      } else {
#line 1025
        descend = (_Bool)1;
      }
    }
  } else {
#line 1027
    descend = (_Bool)0;
  }
#line 1039
  len = (int )*(cur->fts_path + (cur->fts_pathlen - 1U)) == 47 ? cur->fts_pathlen - 1U : cur->fts_pathlen;
#line 1040
  if (sp->fts_options & 4) {
#line 1041
    cp = sp->fts_path + len;
#line 1042
    __cil_tmp___5 = cp;
#line 1042
    cp ++;
#line 1042
    *__cil_tmp___5 = (char )'/';
  } else {
#line 1045
    cp = (char *)((void *)0);
  }
#line 1047
  len ++;
#line 1048
  maxlen = sp->fts_pathlen - len;
#line 1050
  level = cur->fts_level + 1LL;
#line 1053
  doadjust = (_Bool)0;
#line 1054
  tail = (FTSENT *)((void *)0);
#line 1054
  head = tail;
#line 1054
  nitems = 0U;
#line 1054
  while (1) {
#line 1054
    if (dirp) {
#line 1054
      dp = readdir(dirp);
#line 1054
      if (! dp) {
#line 1054
        break;
      }
    } else {
#line 1054
      break;
    }
#line 1057
    if (! (sp->fts_options & 32) && ((int )dp->d_name[0] == 46 && (! dp->d_name[1] || ((int )dp->d_name[1] == 46 && ! dp->d_name[2])))) {
#line 1058
      goto __Cont;
    }
#line 1060
    __cil_tmp___6 = strlen((char const   *)(dp->d_name));
#line 1060
    p = fts_alloc(sp, (char const   *)(dp->d_name), __cil_tmp___6);
#line 1060
    if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1062
      goto mem1;
    }
#line 1063
    __cil_tmp___11 = strlen((char const   *)(dp->d_name));
#line 1063
    if (__cil_tmp___11 >= maxlen) {
#line 1065
      oldaddr = (void *)sp->fts_path;
#line 1066
      __cil_tmp___9 = strlen((char const   *)(dp->d_name));
#line 1066
      __cil_tmp___10 = fts_palloc(sp, (__cil_tmp___9 + len) + 1U);
#line 1066
      if (! __cil_tmp___10) {
        mem1: 
#line 1072
        __cil_tmp___7 = __errno();
#line 1072
        saved_errno = *__cil_tmp___7;
#line 1073
        free((void *)p);
#line 1074
        fts_lfree(head);
#line 1075
        closedir(dirp);
#line 1076
        cur->fts_info = (unsigned short)7;
#line 1077
        sp->fts_options |= 8192;
#line 1078
        __cil_tmp___8 = __errno();
#line 1078
        *__cil_tmp___8 = saved_errno;
#line 1079
        return ((FTSENT *)((void *)0));
      }
#line 1082
      if ((unsigned int )oldaddr != (unsigned int )sp->fts_path) {
#line 1083
        doadjust = (_Bool)1;
#line 1084
        if (sp->fts_options & 4) {
#line 1085
          cp = sp->fts_path + len;
        }
      }
#line 1087
      maxlen = sp->fts_pathlen - len;
    }
#line 1090
    __cil_tmp___12 = strlen((char const   *)(dp->d_name));
#line 1090
    new_len = len + __cil_tmp___12;
#line 1091
    if (new_len < len) {
#line 1098
      free((void *)p);
#line 1099
      fts_lfree(head);
#line 1100
      closedir(dirp);
#line 1101
      cur->fts_info = (unsigned short)7;
#line 1102
      sp->fts_options |= 8192;
#line 1103
      __cil_tmp___13 = __errno();
#line 1103
      *__cil_tmp___13 = 91;
#line 1104
      return ((FTSENT *)((void *)0));
    }
#line 1106
    p->fts_level = level;
#line 1107
    p->fts_parent = sp->fts_cur;
#line 1108
    p->fts_pathlen = new_len;
#line 1116
    if (sp->fts_options & 4) {
#line 1117
      p->fts_accpath = p->fts_path;
#line 1118
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1U);
    } else {
#line 1120
      p->fts_accpath = p->fts_name;
    }
#line 1122
    if ((unsigned int )sp->fts_compar == (unsigned int )((void *)0) || sp->fts_options & 1024) {
#line 1135
      skip_stat = (_Bool)0;
#line 1139
      p->fts_info = (unsigned short)11;
#line 1140
      fts_set_stat_required(p, (_Bool )(! skip_stat));
#line 1141
      is_dir = (_Bool)0;
    } else {
#line 1144
      p->fts_info = fts_stat(sp, p, (_Bool)0);
#line 1145
      is_dir = (_Bool )(((int )p->fts_info == 1 || (int )p->fts_info == 2) || (int )p->fts_info == 5);
    }
#line 1151
    if ((int )nlinks > 0 && is_dir) {
#line 1152
      nlinks = (unsigned short )((int )nlinks - (int )nostat);
    }
#line 1155
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1156
    if ((unsigned int )head == (unsigned int )((void *)0)) {
#line 1157
      tail = p;
#line 1157
      head = tail;
    } else {
#line 1159
      tail->fts_link = p;
#line 1160
      tail = p;
    }
#line 1162
    nitems ++;
    __Cont: ;
  }
#line 1164
  if (dirp) {
#line 1165
    closedir(dirp);
  }
#line 1171
  if (doadjust) {
#line 1172
    fts_padjust(sp, head);
  }
#line 1178
  if (sp->fts_options & 4) {
#line 1179
    if (len == sp->fts_pathlen || nitems == 0U) {
#line 1180
      cp --;
    }
#line 1181
    *cp = (char )'\000';
  }
#line 1191
  if (descend && (type == 1 || ! nitems)) {
#line 1191
    if (cur->fts_level == 0LL) {
#line 1191
      fd_ring_clear(& sp->fts_fd_ring);
#line 1191
      if (! (sp->fts_options & 4)) {
#line 1191
        if (sp->fts_options & 512) {
#line 1191
          cwd_advance_fd(sp, sp->fts_options & 512 ? -3041965 : sp->fts_rfd, (_Bool)1);
#line 1191
          __cil_tmp___15 = 0;
        } else {
#line 1191
          __cil_tmp___14 = fchdir(sp->fts_options & 512 ? -3041965 : sp->fts_rfd);
#line 1191
          __cil_tmp___15 = __cil_tmp___14;
        }
#line 1191
        if (__cil_tmp___15) {
#line 1191
          __cil_tmp___16 = 1;
        } else {
#line 1191
          __cil_tmp___16 = 0;
        }
      } else {
#line 1191
        __cil_tmp___16 = 0;
      }
#line 1191
      __cil_tmp___18 = __cil_tmp___16;
    } else {
#line 1191
      __cil_tmp___17 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
#line 1191
      __cil_tmp___18 = __cil_tmp___17;
    }
#line 1191
    if (__cil_tmp___18) {
#line 1195
      cur->fts_info = (unsigned short)7;
#line 1196
      sp->fts_options |= 8192;
#line 1197
      fts_lfree(head);
#line 1198
      return ((FTSENT *)((void *)0));
    }
  }
#line 1202
  if (! nitems) {
#line 1203
    if (type == 3) {
#line 1204
      cur->fts_info = (unsigned short)6;
    }
#line 1205
    fts_lfree(head);
#line 1206
    return ((FTSENT *)((void *)0));
  }
#line 1210
  if (sp->fts_compar && nitems > 1U) {
#line 1211
    head = fts_sort(sp, head, nitems);
  }
#line 1212
  return (head);
}
}
#line 1359 "fts.c"
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) 
{ struct stat *sbp ;
  int saved_errno ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int __cil_tmp___5 ;

  {
#line 1363
  sbp = p->fts_statp;
#line 1366
  if (p->fts_level == 0LL && sp->fts_options & 1) {
#line 1367
    follow = (_Bool)1;
  }
#line 1383
  if (sp->fts_options & 2 || follow) {
#line 1384
    __cil_tmp___3 = stat((char const   *)p->fts_accpath, sbp);
#line 1384
    if (__cil_tmp___3) {
#line 1385
      __cil_tmp = __errno();
#line 1385
      saved_errno = *__cil_tmp;
#line 1386
      __cil_tmp___1 = __errno();
#line 1386
      if (*__cil_tmp___1 == 2) {
#line 1386
        __cil_tmp___2 = rpl_lstat((char const   *)p->fts_accpath, sbp);
#line 1386
        if (__cil_tmp___2 == 0) {
#line 1388
          __cil_tmp___0 = __errno();
#line 1388
          *__cil_tmp___0 = 0;
#line 1389
          return ((unsigned short)13);
        }
      }
#line 1391
      p->fts_errno = saved_errno;
#line 1392
      goto err;
    }
  } else {
#line 1394
    __cil_tmp___5 = rpl_fstatat(sp->fts_cwd_fd, (char const   *)p->fts_accpath, sbp,
                                4096);
#line 1394
    if (__cil_tmp___5) {
#line 1396
      __cil_tmp___4 = __errno();
#line 1396
      p->fts_errno = *__cil_tmp___4;
      err: 
#line 1397
      memset((void *)sbp, 0, sizeof(struct stat ));
#line 1398
      return ((unsigned short)10);
    }
  }
#line 1401
  if ((sbp->st_mode & 8323072U) == 1048576U) {
#line 1402
    if ((int )p->fts_name[0] == 46 && (! p->fts_name[1] || ((int )p->fts_name[1] == 46 && ! p->fts_name[2]))) {
#line 1404
      return ((unsigned short )(p->fts_level == 0LL ? 1 : 5));
    }
#line 1428
    return ((unsigned short)1);
  }
#line 1430
  if ((sbp->st_mode & 8323072U) == 2097152U) {
#line 1431
    return ((unsigned short)12);
  }
#line 1432
  if ((sbp->st_mode & 8323072U) == 524288U) {
#line 1433
    return ((unsigned short)8);
  }
#line 1434
  return ((unsigned short)3);
}
}
#line 1437 "fts.c"
static int fts_compar(void const   *a , void const   *b ) 
{ FTSENT const   **pa ;
  FTSENT const   **pb ;
  int __cil_tmp ;

  {
#line 1445
  pa = (FTSENT const   **)a;
#line 1446
  pb = (FTSENT const   **)b;
#line 1447
  __cil_tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
#line 1447
  return (__cil_tmp);
}
}
#line 1450 "fts.c"
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) 
{ register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *__cil_tmp ;
  FTSENT **__cil_tmp___0 ;

  {
#line 1464
  compare = sizeof(& dummy) == sizeof(void *) && (long )(& dummy) == (long )((void *)(& dummy)) ? (int (*)(void const   * ,
                                                                                                           void const   * ))sp->fts_compar : & fts_compar;
#line 1477
  if (nitems > sp->fts_nitems) {
#line 1480
    sp->fts_nitems = nitems + 40U;
#line 1481
    if ((((1U << 31) - 1U) * 2U + 1U) / sizeof(*a) < sp->fts_nitems) {
#line 1484
      free((void *)sp->fts_array);
#line 1485
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1486
      sp->fts_nitems = 0U;
#line 1487
      return (head);
    } else {
#line 1481
      __cil_tmp = rpl_realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1481
      a = (FTSENT **)__cil_tmp;
#line 1481
      if (! a) {
#line 1484
        free((void *)sp->fts_array);
#line 1485
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1486
        sp->fts_nitems = 0U;
#line 1487
        return (head);
      }
    }
#line 1489
    sp->fts_array = a;
  }
#line 1491
  ap = sp->fts_array;
#line 1491
  p = head;
#line 1491
  while (p) {
#line 1492
    __cil_tmp___0 = ap;
#line 1492
    ap ++;
#line 1492
    *__cil_tmp___0 = p;
#line 1491
    p = p->fts_link;
  }
#line 1493
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1494
  ap = sp->fts_array;
#line 1494
  head = *ap;
#line 1494
  while (1) {
#line 1494
    nitems --;
#line 1494
    if (! nitems) {
#line 1494
      break;
    }
#line 1495
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1494
    ap ++;
  }
#line 1496
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1497
  return (head);
}
}
#line 1500 "fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) 
{ register FTSENT *p ;
  size_t len ;
  void *__cil_tmp ;

  {
#line 1511
  len = sizeof(FTSENT ) + namelen;
#line 1512
  __cil_tmp = rpl_malloc(len);
#line 1512
  p = (FTSENT *)__cil_tmp;
#line 1512
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1513
    return ((FTSENT *)((void *)0));
  }
#line 1516
  memmove((void *)(p->fts_name), (void const   *)name, namelen);
#line 1517
  p->fts_name[namelen] = (char )'\000';
#line 1519
  p->fts_namelen = namelen;
#line 1520
  p->fts_fts = sp;
#line 1521
  p->fts_path = sp->fts_path;
#line 1522
  p->fts_errno = 0;
#line 1523
  p->fts_flags = (unsigned short)0;
#line 1524
  p->fts_instr = (unsigned short)3;
#line 1525
  p->fts_number = 0L;
#line 1526
  p->fts_pointer = (void *)0;
#line 1527
  return (p);
}
}
#line 1530 "fts.c"
static void fts_lfree(FTSENT *head ) 
{ register FTSENT *p ;

  {
#line 1537
  while (1) {
#line 1537
    p = head;
#line 1537
    if (! p) {
#line 1537
      break;
    }
#line 1538
    head = head->fts_link;
#line 1539
    free((void *)p);
  }
#line 1541
  return;
}
}
#line 1550 "fts.c"
static _Bool fts_palloc(FTS *sp , size_t more ) 
{ char *p ;
  size_t new_len ;
  int *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 1555
  new_len = (sp->fts_pathlen + more) + 256U;
#line 1560
  if (new_len < sp->fts_pathlen) {
#line 1561
    free((void *)sp->fts_path);
#line 1562
    sp->fts_path = (char *)((void *)0);
#line 1563
    __cil_tmp = __errno();
#line 1563
    *__cil_tmp = 91;
#line 1564
    return ((_Bool)0);
  }
#line 1566
  sp->fts_pathlen = new_len;
#line 1567
  __cil_tmp___0 = rpl_realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1567
  p = (char *)__cil_tmp___0;
#line 1568
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1569
    free((void *)sp->fts_path);
#line 1570
    sp->fts_path = (char *)((void *)0);
#line 1571
    return ((_Bool)0);
  }
#line 1573
  sp->fts_path = p;
#line 1574
  return ((_Bool)1);
}
}
#line 1581 "fts.c"
static void fts_padjust(FTS *sp , FTSENT *head ) 
{ FTSENT *p ;
  char *addr ;

  {
#line 1586
  addr = sp->fts_path;
#line 1596
  p = sp->fts_child;
#line 1596
  while (p) {
#line 1597
    while (1) {
#line 1597
      if ((unsigned int )p->fts_accpath != (unsigned int )(p->fts_name)) {
#line 1597
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1597
      p->fts_path = addr;
#line 1597
      break;
    }
#line 1596
    p = p->fts_link;
  }
#line 1600
  p = head;
#line 1600
  while (p->fts_level >= 0LL) {
#line 1601
    while (1) {
#line 1601
      if ((unsigned int )p->fts_accpath != (unsigned int )(p->fts_name)) {
#line 1601
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1601
      p->fts_path = addr;
#line 1601
      break;
    }
#line 1602
    p = p->fts_link ? p->fts_link : p->fts_parent;
  }
#line 1604
  return;
}
}
#line 1606 "fts.c"
static size_t fts_maxarglen(char * const  *argv ) 
{ size_t len ;
  size_t max ;

  {
#line 1612
  max = 0U;
#line 1612
  while (*argv) {
#line 1613
    len = strlen((char const   *)*argv);
#line 1613
    if (len > max) {
#line 1614
      max = len;
    }
#line 1612
    argv ++;
  }
#line 1615
  return (max + 1U);
}
}
#line 1627 "fts.c"
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ int ret ;
  _Bool is_dotdot ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool __cil_tmp___1 ;
  struct stat sb ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int oerrno ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;

  {
#line 1632
  if (dir) {
#line 1632
    __cil_tmp = strcmp(dir, "..");
#line 1632
    if (__cil_tmp == 0) {
#line 1632
      __cil_tmp___0 = 1;
    } else {
#line 1632
      __cil_tmp___0 = 0;
    }
  } else {
#line 1632
    __cil_tmp___0 = 0;
  }
#line 1632
  is_dotdot = (_Bool )__cil_tmp___0;
#line 1639
  if (sp->fts_options & 4) {
#line 1641
    if (sp->fts_options & 512 && 0 <= fd) {
#line 1642
      close(fd);
    }
#line 1643
    return (0);
  }
#line 1646
  if ((fd < 0 && is_dotdot) && sp->fts_options & 512) {
#line 1653
    __cil_tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
#line 1653
    if (! __cil_tmp___1) {
#line 1657
      parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 1658
      is_dotdot = (_Bool)1;
#line 1659
      if (0 <= parent_fd) {
#line 1661
        fd = parent_fd;
#line 1662
        dir = (char const   *)((void *)0);
      }
    }
  }
#line 1667
  newfd = fd;
#line 1668
  if (fd < 0) {
#line 1668
    newfd = diropen((FTS const   *)sp, dir);
#line 1668
    if (newfd < 0) {
#line 1669
      return (-1);
    }
  }
#line 1682
  __cil_tmp___2 = fstat(newfd, & sb);
#line 1682
  if (__cil_tmp___2) {
#line 1684
    ret = -1;
#line 1685
    goto bail;
  }
#line 1687
  if ((int )p->fts_statp[0].st_dev != (int )sb.st_dev || (int )p->fts_statp[0].st_ino != (int )sb.st_ino) {
#line 1690
    __cil_tmp___3 = __errno();
#line 1690
    *__cil_tmp___3 = 2;
#line 1691
    ret = -1;
#line 1692
    goto bail;
  }
#line 1696
  if (sp->fts_options & 512) {
#line 1698
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
#line 1699
    return (0);
  }
#line 1702
  ret = fchdir(newfd);
  bail: 
#line 1704
  if (fd < 0) {
#line 1706
    __cil_tmp___5 = __errno();
#line 1706
    oerrno = *__cil_tmp___5;
#line 1707
    close(newfd);
#line 1708
    __cil_tmp___6 = __errno();
#line 1708
    *__cil_tmp___6 = oerrno;
  }
#line 1710
  return (ret);
}
}
#line 1 "gai_strerror.o"
#pragma merger(0,"/tmp/cil-VlpXDnut.i","-g,-O2")
#line 39 "gai_strerror.c"
static struct __anonstruct_values_12 values[12]  = 
#line 39 "gai_strerror.c"
  {      {-9, "Address family for hostname not supported"}, 
        {-3, "Temporary failure in name resolution"}, 
        {-1, "Bad value for ai_flags"}, 
        {-4, "Non-recoverable failure in name resolution"}, 
        {-6, "ai_family not supported"}, 
        {-10, "Memory allocation failure"}, 
        {-5, "No address associated with hostname"}, 
        {-2, "Name or service not known"}, 
        {-8, "Servname not supported for ai_socktype"}, 
        {-7, "ai_socktype not supported"}, 
        {-11, "System error"}, 
        {-12, "Argument buffer too small"}};
#line 68 "gai_strerror.c"
char const   *gai_strerror(int code ) 
{ size_t i ;

  {
#line 72
  i = 0U;
#line 72
  while (i < sizeof(values) / sizeof(values[0])) {
#line 73
    if (values[i].code == code) {
#line 74
      return (values[i].msg);
    }
#line 72
    i ++;
  }
#line 76
  return ("Unknown error");
}
}
#line 1 "getaddrinfo.o"
#pragma merger(0,"/tmp/cil-rC2XZJVo.i","-g,-O2")
#line 53 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/netdb.h"
extern struct hostent *gethostbyname(char const   *name ) ;
#line 61
extern struct servent *getservbyname(char const   *name , char const   *proto ) ;
#line 142 "getaddrinfo.h"
int getnameinfo(struct sockaddr  const  * __restrict  sa , socklen_t salen , char * __restrict  node ,
                socklen_t nodelen , char * __restrict  service , socklen_t servicelen ,
                int flags ) ;
#line 137 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern unsigned long strtoul(char const   *__n , char **__end_PTR , int __base ) ;
#line 267 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
int snprintf(char *str , size_t size , char const   *format  , ...) ;
#line 42 "inet_ntop.h"
char const   *inet_ntop(int af , void const   * __restrict  src , char * __restrict  dst ,
                        socklen_t cnt ) ;
#line 106 "getaddrinfo.c"
__inline static _Bool validate_family(int family ) 
{ 

  {
#line 111
  if (family == 2) {
#line 112
    return ((_Bool)1);
  }
#line 115
  if (family == 3) {
#line 116
    return ((_Bool)1);
  }
#line 118
  if (family == 0) {
#line 119
    return ((_Bool)1);
  }
#line 120
  return ((_Bool)0);
}
}
#line 125 "getaddrinfo.c"
int getaddrinfo(char const   * __restrict  nodename , char const   * __restrict  servname ,
                struct addrinfo  const  * __restrict  hints___0 , struct addrinfo ** __restrict  res ) 
{ struct addrinfo *tmp ;
  int port ;
  struct hostent *he ;
  void *storage ;
  size_t size ;
  _Bool __cil_tmp ;
  struct servent *se ;
  char const   *proto ;
  char *c ;
  unsigned long __cil_tmp___0 ;
  struct v6_pair *p ;
  struct sockaddr_in6 *sinp ;
  struct v4_pair *p___0 ;
  struct sockaddr_in *sinp___0 ;
  char const   *cn ;

  {
#line 132
  port = 0;
#line 154
  if (hints___0 && hints___0->ai_flags & -4) {
#line 156
    return (-1);
  }
#line 158
  if (hints___0) {
#line 158
    __cil_tmp = validate_family((int )hints___0->ai_family);
#line 158
    if (! __cil_tmp) {
#line 159
      return (-6);
    }
  }
#line 161
  if ((hints___0 && hints___0->ai_socktype != 2) && hints___0->ai_socktype != 1) {
#line 164
    return (-7);
  }
#line 166
  if (! nodename) {
#line 168
    if (! (hints___0->ai_flags & 1)) {
#line 169
      return (-2);
    }
#line 172
    nodename = (char const   * __restrict  )(hints___0->ai_family == 3 ? "::" : "0.0.0.0");
  }
#line 178
  if (servname) {
#line 180
    se = (struct servent *)((void *)0);
#line 181
    proto = hints___0 && hints___0->ai_socktype == 1 ? "udp" : "tcp";
#line 184
    if ((unsigned int )hints___0 == (unsigned int )((void *)0) || ! (hints___0->ai_flags & 1024)) {
#line 186
      se = getservbyname((char const   *)servname, proto);
    }
#line 188
    if (! se) {
#line 191
      if (! ((int const   )*servname >= 48 && (int const   )*servname <= 57)) {
#line 192
        return (-2);
      }
#line 193
      __cil_tmp___0 = strtoul((char const   *)servname, & c, 10);
#line 193
      port = (int )__cil_tmp___0;
#line 194
      if (*c || port > 65535) {
#line 195
        return (-2);
      }
#line 196
      port = ((port & 65280) >> 8) | ((port & 255) << 8);
    } else {
#line 199
      port = se->s_port;
    }
  }
#line 203
  he = gethostbyname((char const   *)nodename);
#line 204
  if (! he || (unsigned int )*(he->h_addr_list + 0) == (unsigned int )((void *)0)) {
#line 205
    return (-2);
  }
#line 207
  switch (he->h_addrtype) {
  case 3: 
#line 211
  size = sizeof(struct v6_pair );
#line 212
  break;
  case 2: 
#line 217
  size = sizeof(struct v4_pair );
#line 218
  break;
  default: 
#line 222
  return (-5);
  }
#line 225
  storage = rpl_calloc(1U, size);
#line 226
  if (! storage) {
#line 227
    return (-10);
  }
#line 229
  switch (he->h_addrtype) {
  case 3: 
#line 234
  p = (struct v6_pair *)storage;
#line 235
  sinp = & p->sockaddr_in6;
#line 236
  tmp = & p->addrinfo;
#line 238
  if (port) {
#line 239
    sinp->sin6_port = (unsigned short )port;
  }
#line 241
  if ((unsigned int )he->h_length != sizeof(sinp->sin6_addr)) {
#line 243
    free(storage);
#line 244
    return (-11);
  }
#line 247
  memcpy((void *)(& sinp->sin6_addr), (void const   *)*(he->h_addr_list + 0), sizeof(sinp->sin6_addr));
#line 249
  tmp->ai_addr = (struct sockaddr *)sinp;
#line 250
  tmp->ai_addrlen = sizeof(*sinp);
#line 252
  break;
  case 2: 
#line 258
  p___0 = (struct v4_pair *)storage;
#line 259
  sinp___0 = & p___0->sockaddr_in;
#line 260
  tmp = & p___0->addrinfo;
#line 262
  if (port) {
#line 263
    sinp___0->sin_port = (unsigned short )port;
  }
#line 265
  if ((unsigned int )he->h_length != sizeof(sinp___0->sin_addr)) {
#line 267
    free(storage);
#line 268
    return (-11);
  }
#line 271
  memcpy((void *)(& sinp___0->sin_addr), (void const   *)*(he->h_addr_list + 0), sizeof(sinp___0->sin_addr));
#line 273
  tmp->ai_addr = (struct sockaddr *)sinp___0;
#line 274
  tmp->ai_addrlen = sizeof(*sinp___0);
#line 276
  break;
  default: 
#line 280
  free(storage);
#line 281
  return (-5);
  }
#line 284
  if (hints___0 && hints___0->ai_flags & 2) {
#line 287
    if (he->h_name) {
#line 288
      cn = (char const   *)he->h_name;
    } else {
#line 290
      cn = (char const   *)nodename;
    }
#line 292
    tmp->ai_canonname = strdup(cn);
#line 293
    if (! tmp->ai_canonname) {
#line 295
      free(storage);
#line 296
      return (-10);
    }
  }
#line 300
  tmp->ai_protocol = (int )(hints___0 ? hints___0->ai_protocol : (int const   )0);
#line 301
  tmp->ai_socktype = (int )(hints___0 ? hints___0->ai_socktype : (int const   )0);
#line 302
  (tmp->ai_addr)->sa_family = (unsigned short )he->h_addrtype;
#line 303
  tmp->ai_family = he->h_addrtype;
#line 307
  *res = tmp;
#line 309
  return (0);
}
}
#line 313 "getaddrinfo.c"
void freeaddrinfo(struct addrinfo *ai ) 
{ struct addrinfo *cur ;

  {
#line 324
  while (ai) {
#line 328
    cur = ai;
#line 329
    ai = ai->ai_next;
#line 331
    if (cur->ai_canonname) {
#line 331
      free((void *)cur->ai_canonname);
    }
#line 332
    free((void *)cur);
  }
#line 334
  return;
}
}
#line 336 "getaddrinfo.c"
int getnameinfo(struct sockaddr  const  * __restrict  sa , socklen_t salen , char * __restrict  node ,
                socklen_t nodelen , char * __restrict  service , socklen_t servicelen ,
                int flags ) 
{ char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  unsigned short port ;
  int __cil_tmp___1 ;

  {
#line 348
  if ((((node && nodelen > 0U) && ! (flags & 1)) || ((service && servicelen > 0U) && ! (flags & 1))) || flags & -4) {
#line 351
    return (-1);
  }
#line 353
  if ((unsigned int )sa == (unsigned int )((void *)0) || salen < sizeof(sa->sa_family)) {
#line 354
    return (-6);
  }
#line 356
  switch ((int )sa->sa_family) {
  case 2: 
#line 360
  if (salen < sizeof(struct sockaddr_in )) {
#line 361
    return (-6);
  }
#line 362
  break;
  case 3: 
#line 366
  if (salen < sizeof(struct sockaddr_in6 )) {
#line 367
    return (-6);
  }
#line 368
  break;
  default: 
#line 371
  return (-6);
  }
#line 374
  if ((node && nodelen > 0U) && flags & 1) {
#line 376
    switch ((int )sa->sa_family) {
    case 2: 
#line 380
    __cil_tmp = inet_ntop(2, (void const   * __restrict  )(& ((struct sockaddr_in  const  *)sa)->sin_addr),
                          node, nodelen);
#line 380
    if (! __cil_tmp) {
#line 383
      return (-11);
    }
#line 384
    break;
    case 3: 
#line 389
    __cil_tmp___0 = inet_ntop(3, (void const   * __restrict  )(& ((struct sockaddr_in6  const  *)sa)->sin6_addr),
                              node, nodelen);
#line 389
    if (! __cil_tmp___0) {
#line 392
      return (-11);
    }
#line 393
    break;
    default: 
#line 397
    return (-6);
    }
  }
#line 401
  if ((service && servicelen > 0U) && flags & 2) {
#line 402
    switch ((int )sa->sa_family) {
    case 2: 
    case 3: 
#line 411
    port = (unsigned short )((((int const   )((struct sockaddr_in  const  *)sa)->sin_port & 65280) >> 8) | (((int const   )((struct sockaddr_in  const  *)sa)->sin_port & 255) << 8));
#line 413
    __cil_tmp___1 = snprintf((char *)service, servicelen, "%u", (int )port);
#line 413
    if (servicelen <= (unsigned int )__cil_tmp___1) {
#line 414
      return (-12);
    }
#line 416
    break;
    }
  }
#line 419
  return (0);
}
}
#line 1 "getcwd.o"
#pragma merger(0,"/tmp/cil-T7r1kajq.i","-g,-O2")
#line 152 "./unistd.h"
char *rpl_getcwd(char *buf___0 , size_t size ) ;
#line 24 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/dirent.h"
extern void rewinddir(DIR * ) ;
#line 118 "getcwd.c"
char *rpl_getcwd(char *buf___0 , size_t size ) 
{ char dots[(100U * sizeof("..") + 255U) + 1U] ;
  char *dotlist ;
  size_t dotsize ;
  size_t dotlen ;
  DIR *dirstream ;
  dev_t rootdev ;
  dev_t thisdev ;
  ino_t rootino ;
  ino_t thisino ;
  char *dir ;
  register char *dirp ;
  struct stat st ;
  size_t allocated ;
  size_t used ;
  int *__cil_tmp ;
  void *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  struct dirent *d ;
  dev_t dotdev ;
  ino_t dotino ;
  _Bool mount_point ;
  int parent_status ;
  size_t dirroom ;
  size_t namlen ;
  _Bool use_d_ino ;
  size_t __cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  int __cil_tmp___5 ;
  size_t __cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  int *__cil_tmp___10 ;
  _Bool match ;
  int entry_status ;
  size_t name_alloc ;
  size_t __cil_tmp___11 ;
  size_t filesize ;
  size_t newsize ;
  size_t i ;
  void *__cil_tmp___12 ;
  size_t __cil_tmp___13 ;
  size_t __cil_tmp___14 ;
  size_t __cil_tmp___15 ;
  size_t __cil_tmp___16 ;
  int *__cil_tmp___17 ;
  char *tmp ;
  size_t oldsize ;
  void *__cil_tmp___18 ;
  void *__cil_tmp___19 ;
  int __cil_tmp___20 ;
  void *__cil_tmp___21 ;
  int *__cil_tmp___22 ;
  int save ;
  int *__cil_tmp___23 ;
  int *__cil_tmp___24 ;

  {
#line 138
  dotlist = dots;
#line 139
  dotsize = sizeof(dots);
#line 140
  dotlen = 0U;
#line 142
  dirstream = (DIR *)((void *)0);
#line 148
  allocated = size;
#line 169
  if (size == 0U) {
#line 171
    if ((unsigned int )buf___0 != (unsigned int )((void *)0)) {
#line 173
      __cil_tmp = __errno();
#line 173
      *__cil_tmp = 22;
#line 174
      return ((char *)((void *)0));
    }
#line 177
    allocated = 4096U;
  }
#line 180
  if ((unsigned int )buf___0 == (unsigned int )((void *)0)) {
#line 182
    __cil_tmp___0 = rpl_malloc(allocated);
#line 182
    dir = (char *)__cil_tmp___0;
#line 183
    if ((unsigned int )dir == (unsigned int )((void *)0)) {
#line 184
      return ((char *)((void *)0));
    }
  } else {
#line 187
    dir = buf___0;
  }
#line 189
  dirp = dir + allocated;
#line 190
  dirp --;
#line 190
  *dirp = (char )'\000';
#line 192
  __cil_tmp___1 = lstat(".", & st);
#line 192
  if (__cil_tmp___1 < 0) {
#line 193
    goto lose;
  }
#line 194
  thisdev = st.st_dev;
#line 195
  thisino = st.st_ino;
#line 197
  __cil_tmp___2 = lstat("/", & st);
#line 197
  if (__cil_tmp___2 < 0) {
#line 198
    goto lose;
  }
#line 199
  rootdev = st.st_dev;
#line 200
  rootino = st.st_ino;
#line 202
  while (! ((int )thisdev == (int )rootdev && (int )thisino == (int )rootino)) {
#line 211
    use_d_ino = (_Bool)1;
#line 221
    __cil_tmp___3 = dotlen;
#line 221
    dotlen ++;
#line 221
    *(dotlist + __cil_tmp___3) = (char )'.';
#line 222
    __cil_tmp___4 = dotlen;
#line 222
    dotlen ++;
#line 222
    *(dotlist + __cil_tmp___4) = (char )'.';
#line 223
    *(dotlist + dotlen) = (char )'\000';
#line 224
    parent_status = lstat((char const   *)dotlist, & st);
#line 226
    if (parent_status != 0) {
#line 227
      goto lose;
    }
#line 229
    if (dirstream) {
#line 229
      __cil_tmp___5 = closedir(dirstream);
#line 229
      if (__cil_tmp___5 != 0) {
#line 231
        dirstream = (DIR *)((void *)0);
#line 232
        goto lose;
      }
    }
#line 236
    dotdev = st.st_dev;
#line 237
    dotino = st.st_ino;
#line 238
    mount_point = (_Bool )((int )dotdev != (int )thisdev);
#line 249
    dirstream = opendir((char const   *)dotlist);
#line 250
    if ((unsigned int )dirstream == (unsigned int )((void *)0)) {
#line 251
      goto lose;
    }
#line 252
    __cil_tmp___6 = dotlen;
#line 252
    dotlen ++;
#line 252
    *(dotlist + __cil_tmp___6) = (char )'/';
#line 254
    while (1) {
#line 258
      __cil_tmp___7 = __errno();
#line 258
      *__cil_tmp___7 = 0;
#line 259
      d = readdir(dirstream);
#line 268
      if ((unsigned int )d == (unsigned int )((void *)0)) {
#line 268
        __cil_tmp___8 = __errno();
#line 268
        if (*__cil_tmp___8 == 0) {
#line 268
          if (use_d_ino) {
#line 270
            use_d_ino = (_Bool)0;
#line 271
            rewinddir(dirstream);
#line 272
            d = readdir(dirstream);
          }
        }
      }
#line 275
      if ((unsigned int )d == (unsigned int )((void *)0)) {
#line 277
        __cil_tmp___10 = __errno();
#line 277
        if (*__cil_tmp___10 == 0) {
#line 280
          __cil_tmp___9 = __errno();
#line 280
          *__cil_tmp___9 = 2;
        }
#line 281
        goto lose;
      }
#line 283
      if ((int )d->d_name[0] == 46 && ((int )d->d_name[1] == 0 || ((int )d->d_name[1] == 46 && (int )d->d_name[2] == 0))) {
#line 286
        goto __Cont;
      }
#line 288
      if (use_d_ino) {
#line 290
        match = (_Bool)1;
#line 291
        if (! match) {
#line 292
          goto __Cont;
        }
      }
#line 304
      __cil_tmp___11 = strlen((char const   *)(d->d_name));
#line 304
      name_alloc = __cil_tmp___11 + 1U;
#line 305
      filesize = dotlen + (sizeof("..") < name_alloc ? name_alloc : sizeof(".."));
#line 307
      if (filesize < dotlen) {
#line 308
        goto memory_exhausted;
      }
#line 310
      if (dotsize < filesize) {
#line 313
        newsize = filesize < dotsize * 2U ? dotsize * 2U : filesize;
#line 315
        if (newsize < dotsize) {
#line 316
          goto memory_exhausted;
        }
#line 317
        if ((unsigned int )dotlist != (unsigned int )(dots)) {
#line 318
          free((void *)dotlist);
        }
#line 319
        __cil_tmp___12 = rpl_malloc(newsize);
#line 319
        dotlist = (char *)__cil_tmp___12;
#line 320
        if ((unsigned int )dotlist == (unsigned int )((void *)0)) {
#line 321
          goto lose;
        }
#line 322
        dotsize = newsize;
#line 324
        i = 0U;
#line 325
        while (1) {
#line 327
          __cil_tmp___13 = i;
#line 327
          i ++;
#line 327
          *(dotlist + __cil_tmp___13) = (char )'.';
#line 328
          __cil_tmp___14 = i;
#line 328
          i ++;
#line 328
          *(dotlist + __cil_tmp___14) = (char )'.';
#line 329
          __cil_tmp___15 = i;
#line 329
          i ++;
#line 329
          *(dotlist + __cil_tmp___15) = (char )'/';
#line 325
          if (! (i < dotlen)) {
#line 325
            break;
          }
        }
      }
#line 334
      __cil_tmp___16 = strlen((char const   *)(d->d_name));
#line 334
      memcpy((void *)(dotlist + dotlen), (void const   *)(d->d_name), __cil_tmp___16 + 1U);
#line 335
      entry_status = lstat((char const   *)dotlist, & st);
#line 342
      if (((entry_status == 0 && (st.st_mode & 8323072U) == 1048576U) && (int )st.st_dev == (int )thisdev) && (int )st.st_ino == (int )thisino) {
#line 344
        break;
      }
      __Cont: ;
    }
#line 348
    dirroom = (unsigned int )(dirp - dir);
#line 349
    namlen = strlen((char const   *)(d->d_name));
#line 351
    if (dirroom <= namlen) {
#line 353
      if (size != 0U) {
#line 355
        __cil_tmp___17 = __errno();
#line 355
        *__cil_tmp___17 = 34;
#line 356
        goto lose;
      } else {
#line 361
        oldsize = allocated;
#line 363
        allocated += allocated < namlen ? namlen : allocated;
#line 364
        if (allocated < oldsize) {
#line 366
          goto memory_exhausted;
        } else {
#line 364
          __cil_tmp___18 = rpl_realloc((void *)dir, allocated);
#line 364
          tmp = (char *)__cil_tmp___18;
#line 364
          if (! tmp) {
#line 366
            goto memory_exhausted;
          }
        }
#line 370
        __cil_tmp___19 = memcpy((void *)((tmp + allocated) - (oldsize - dirroom)),
                                (void const   *)(tmp + dirroom), oldsize - dirroom);
#line 370
        dirp = (char *)__cil_tmp___19;
#line 373
        dir = tmp;
      }
    }
#line 376
    dirp -= namlen;
#line 377
    memcpy((void *)dirp, (void const   *)(d->d_name), namlen);
#line 378
    dirp --;
#line 378
    *dirp = (char )'/';
#line 380
    thisdev = dotdev;
#line 381
    thisino = dotino;
  }
#line 384
  if (dirstream) {
#line 384
    __cil_tmp___20 = closedir(dirstream);
#line 384
    if (__cil_tmp___20 != 0) {
#line 386
      dirstream = (DIR *)((void *)0);
#line 387
      goto lose;
    }
  }
#line 390
  if ((unsigned int )dirp == (unsigned int )(dir + (allocated - 1U))) {
#line 391
    dirp --;
#line 391
    *dirp = (char )'/';
  }
#line 394
  if ((unsigned int )dotlist != (unsigned int )(dots)) {
#line 395
    free((void *)dotlist);
  }
#line 398
  used = (unsigned int )((dir + allocated) - dirp);
#line 399
  memmove((void *)dir, (void const   *)dirp, used);
#line 401
  if (size == 0U) {
#line 403
    __cil_tmp___21 = rpl_realloc((void *)dir, used);
#line 403
    buf___0 = (char *)__cil_tmp___21;
  }
#line 405
  if ((unsigned int )buf___0 == (unsigned int )((void *)0)) {
#line 408
    buf___0 = dir;
  }
#line 410
  return (buf___0);
  memory_exhausted: 
#line 413
  __cil_tmp___22 = __errno();
#line 413
  *__cil_tmp___22 = 12;
  lose: 
#line 416
  __cil_tmp___23 = __errno();
#line 416
  save = *__cil_tmp___23;
#line 417
  if (dirstream) {
#line 418
    closedir(dirstream);
  }
#line 423
  if ((unsigned int )dotlist != (unsigned int )(dots)) {
#line 424
    free((void *)dotlist);
  }
#line 426
  if ((unsigned int )buf___0 == (unsigned int )((void *)0)) {
#line 427
    free((void *)dir);
  }
#line 428
  __cil_tmp___24 = __errno();
#line 428
  *__cil_tmp___24 = save;
#line 430
  return ((char *)((void *)0));
}
}
#line 1 "getdelim.o"
#pragma merger(0,"/tmp/cil-iQQVIiUq.i","-g,-O2")
#line 515 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int __srget_r(struct _reent * , FILE * ) ;
#line 374 "./stdio.h"
ssize_t getdelim(char **lineptr , size_t *n , int delimiter , FILE *fp ) ;
#line 58 "getdelim.c"
ssize_t getdelim(char **lineptr , size_t *n , int delimiter , FILE *fp ) 
{ ssize_t result ;
  size_t cur_len ;
  int *__cil_tmp ;
  void *__cil_tmp___0 ;
  int i ;
  int __cil_tmp___1 ;
  unsigned char *__cil_tmp___2 ;
  size_t needed_max ;
  size_t needed ;
  char *new_lineptr ;
  int *__cil_tmp___3 ;
  void *__cil_tmp___4 ;

  {
#line 62
  cur_len = 0U;
#line 64
  if (((unsigned int )lineptr == (unsigned int )((void *)0) || (unsigned int )n == (unsigned int )((void *)0)) || (unsigned int )fp == (unsigned int )((void *)0)) {
#line 66
    __cil_tmp = __errno();
#line 66
    *__cil_tmp = 22;
#line 67
    return (-1);
  }
#line 72
  if ((unsigned int )*lineptr == (unsigned int )((void *)0) || *n == 0U) {
#line 74
    *n = 120U;
#line 75
    __cil_tmp___0 = rpl_realloc((void *)*lineptr, *n);
#line 75
    *lineptr = (char *)__cil_tmp___0;
#line 76
    if ((unsigned int )*lineptr == (unsigned int )((void *)0)) {
#line 78
      result = -1;
#line 79
      goto unlock_return;
    }
  }
#line 83
  while (1) {
#line 87
    (fp->_r) --;
#line 87
    if (fp->_r < 0) {
#line 87
      __cil_tmp___1 = __srget_r(_impure_ptr, fp);
#line 87
      i = __cil_tmp___1;
    } else {
#line 87
      __cil_tmp___2 = fp->_p;
#line 87
      (fp->_p) ++;
#line 87
      i = (int )*__cil_tmp___2;
    }
#line 88
    if (i == -1) {
#line 90
      result = -1;
#line 91
      break;
    }
#line 95
    if (cur_len + 1U >= *n) {
#line 97
      needed_max = 2147483648U;
#line 99
      needed = 2U * *n + 1U;
#line 102
      if (needed_max < needed) {
#line 103
        needed = needed_max;
      }
#line 104
      if (cur_len + 1U >= needed) {
#line 106
        result = -1;
#line 107
        __cil_tmp___3 = __errno();
#line 107
        *__cil_tmp___3 = 139;
#line 108
        goto unlock_return;
      }
#line 111
      __cil_tmp___4 = rpl_realloc((void *)*lineptr, needed);
#line 111
      new_lineptr = (char *)__cil_tmp___4;
#line 112
      if ((unsigned int )new_lineptr == (unsigned int )((void *)0)) {
#line 114
        result = -1;
#line 115
        goto unlock_return;
      }
#line 118
      *lineptr = new_lineptr;
#line 119
      *n = needed;
    }
#line 122
    *(*lineptr + cur_len) = (char )i;
#line 123
    cur_len ++;
#line 125
    if (i == delimiter) {
#line 126
      break;
    }
  }
#line 128
  *(*lineptr + cur_len) = (char )'\000';
#line 129
  result = (int )(cur_len ? cur_len : (unsigned int )result);
  unlock_return: ;
#line 134
  return (result);
}
}
#line 1 "getgroups.o"
#pragma merger(0,"/tmp/cil-Ymdu90dj.i","-g,-O2")
#line 44 "getgroups.c"
extern int getgroups() ;
#line 34 "getgroups.c"
int rpl_getgroups(int n , gid_t *group ) 
{ int n_groups ;
  gid_t *gbuf ;
  int saved_errno ;
  int __cil_tmp ;
  void *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 43
  if (n != 0) {
#line 44
    __cil_tmp = getgroups(n, group);
#line 44
    return (__cil_tmp);
  }
#line 46
  n = 20;
#line 47
  while (1) {
#line 52
    __cil_tmp___0 = xmalloc((unsigned int )n * sizeof(*gbuf));
#line 52
    gbuf = (gid_t *)__cil_tmp___0;
#line 53
    n_groups = getgroups(n, gbuf);
#line 54
    if (n_groups < n) {
#line 55
      break;
    }
#line 56
    free((void *)gbuf);
#line 57
    n += 10;
  }
#line 60
  __cil_tmp___1 = __errno();
#line 60
  saved_errno = *__cil_tmp___1;
#line 61
  free((void *)gbuf);
#line 62
  __cil_tmp___2 = __errno();
#line 62
  *__cil_tmp___2 = saved_errno;
#line 64
  return (n_groups);
}
}
#line 1 "gethostname.o"
#pragma merger(0,"/tmp/cil-j2MYFQ6w.i","-g,-O2")
#line 21 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/utsname.h"
extern int uname(struct utsname *name ) ;
#line 37 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strncpy(char * , char const   * , size_t  ) ;
#line 34 "gethostname.c"
int gethostname(char *name , size_t len ) 
{ struct utsname uts ;
  int __cil_tmp ;

  {
#line 40
  __cil_tmp = uname(& uts);
#line 40
  if (__cil_tmp == -1) {
#line 41
    return (-1);
  }
#line 42
  if (len > sizeof(uts.nodename)) {
#line 45
    *(name + sizeof(uts.nodename)) = (char )'\000';
#line 46
    len = sizeof(uts.nodename);
  }
#line 48
  strncpy(name, (char const   *)(uts.nodename), len);
#line 52
  return (0);
}
}
#line 1 "gethrxtime.o"
#pragma merger(0,"/tmp/cil-XN0JPiLb.i","-g,-O2")
#line 42 "xtime.h"
__inline static xtime_t xtime_make(xtime_t s , long ns ) 
{ 

  {
#line 48
  return (1000000000LL * s + (long long )ns);
}
}
#line 32 "gethrxtime.c"
xtime_t gethrxtime(void) 
{ struct timespec ts ;
  xtime_t __cil_tmp ;

  {
#line 63
  gettime(& ts);
#line 64
  __cil_tmp = xtime_make((long long )ts.tv_sec, ts.tv_nsec);
#line 64
  return (__cil_tmp);
}
}
#line 1 "getline.o"
#pragma merger(0,"/tmp/cil-GvZtQKhK.i","-g,-O2")
#line 397 "./stdio.h"
ssize_t rpl_getline(char **lineptr , size_t *n , FILE *stream ) ;
#line 27 "getline.c"
ssize_t rpl_getline(char **lineptr , size_t *n , FILE *stream ) 
{ ssize_t __cil_tmp ;

  {
#line 30
  __cil_tmp = getdelim(lineptr, n, '\n', stream);
#line 30
  return (__cil_tmp);
}
}
#line 1 "getloadavg.o"
#pragma merger(0,"/tmp/cil-W6u8qwjp.i","-g,-O2")
#line 494 "getloadavg.c"
int getloadavg(double *loadavg , int nelem ) 
{ int elem ;
  int *__cil_tmp ;

  {
#line 497
  elem = 0;
#line 975
  __cil_tmp = __errno();
#line 975
  *__cil_tmp = 0;
#line 976
  elem = -1;
#line 978
  return (elem);
}
}
#line 1 "getndelim2.o"
#pragma merger(0,"/tmp/cil-oqWxFaW3.i","-g,-O2")
#line 38 "getndelim2.h"
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) ;
#line 49 "getndelim2.c"
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) 
{ size_t nbytes_avail ;
  char *read_pos ;
  ssize_t bytes_stored ;
  char *ptr ;
  size_t size ;
  void *__cil_tmp ;
  int c ;
  size_t newsize ;
  char *newptr ;
  size_t newsizemax ;
  void *__cil_tmp___0 ;
  char *__cil_tmp___1 ;

  {
#line 55
  bytes_stored = -1;
#line 56
  ptr = *lineptr;
#line 57
  size = *linesize;
#line 59
  if (! ptr) {
#line 61
    size = nmax < 64U ? nmax : 64U;
#line 62
    __cil_tmp = rpl_malloc(size);
#line 62
    ptr = (char *)__cil_tmp;
#line 63
    if (! ptr) {
#line 64
      return (-1);
    }
  }
#line 67
  if (size < offset) {
#line 68
    goto done;
  }
#line 70
  nbytes_avail = size - offset;
#line 71
  read_pos = ptr + offset;
#line 73
  if (nbytes_avail == 0U && nmax <= size) {
#line 74
    goto done;
  }
#line 76
  while (1) {
#line 86
    if (nbytes_avail < 2U && size < nmax) {
#line 88
      newsize = size < 64U ? size + 64U : 2U * size;
#line 91
      if (! (size < newsize && newsize <= nmax)) {
#line 92
        newsize = nmax;
      }
#line 94
      if ((~ (-1LL << 63) < (long long )((int )((((1U << 31) - 1U) * 2U + 1U) / 2U)) ? ~ (-1LL << 63) : (long long )((int )((((1U << 31) - 1U) * 2U + 1U) / 2U))) < (long long )(newsize - offset)) {
#line 96
        newsizemax = (unsigned int )(((long long )offset + (~ (-1LL << 63) < (long long )((int )((((1U << 31) - 1U) * 2U + 1U) / 2U)) ? ~ (-1LL << 63) : (long long )((int )((((1U << 31) - 1U) * 2U + 1U) / 2U)))) + 1LL);
#line 97
        if (size == newsizemax) {
#line 98
          goto done;
        }
#line 99
        newsize = newsizemax;
      }
#line 102
      nbytes_avail = newsize - (unsigned int )(read_pos - ptr);
#line 103
      __cil_tmp___0 = rpl_realloc((void *)ptr, newsize);
#line 103
      newptr = (char *)__cil_tmp___0;
#line 104
      if (! newptr) {
#line 105
        goto done;
      }
#line 106
      ptr = newptr;
#line 107
      size = newsize;
#line 108
      read_pos = ptr + (size - nbytes_avail);
    }
#line 111
    c = getc_unlocked(stream);
#line 112
    if (c == -1) {
#line 115
      if ((unsigned int )read_pos == (unsigned int )ptr) {
#line 116
        goto done;
      } else {
#line 118
        break;
      }
    }
#line 121
    if (nbytes_avail >= 2U) {
#line 123
      __cil_tmp___1 = read_pos;
#line 123
      read_pos ++;
#line 123
      *__cil_tmp___1 = (char )c;
#line 124
      nbytes_avail --;
    }
#line 127
    if (c == delim1 || c == delim2) {
#line 129
      break;
    }
  }
#line 134
  *read_pos = (char )'\000';
#line 136
  bytes_stored = read_pos - (ptr + offset);
  done: 
#line 139
  *lineptr = ptr;
#line 140
  *linesize = size;
#line 141
  return (bytes_stored);
}
}
#line 1 "getopt.o"
#pragma merger(0,"/tmp/cil-axy1sjGA.i","-g,-O2")
#line 114 "getopt.h"
char *rpl_optarg  ;
#line 133
int rpl_opterr ;
#line 137
int rpl_optopt ;
#line 204
int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 22 "getopt_int.h"
int _getopt_internal(int argc , char **argv , char const   *optstring , struct option  const  *longopts___0 ,
                     int *longind , int long_only , int posixly_correct___0 ) ;
#line 113
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct option  const  *longopts___0 ,
                       int *longind , int long_only , int posixly_correct___0 , struct _getopt_data *d ) ;
#line 89 "getopt.c"
int rpl_optind  =    1;
#line 94 "getopt.c"
int rpl_opterr  =    1;
#line 100 "getopt.c"
int rpl_optopt  =    '?';
#line 104 "getopt.c"
static struct _getopt_data getopt_data  ;
#line 150 "getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 153
  bottom = d->__first_nonopt;
#line 154
  middle = d->__last_nonopt;
#line 155
  top = d->rpl_optind;
#line 185
  while (top > middle && middle > bottom) {
#line 187
    if (top - middle > middle - bottom) {
#line 190
      len = middle - bottom;
#line 194
      i = 0;
#line 194
      while (i < len) {
#line 196
        tem = *(argv + (bottom + i));
#line 197
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
#line 198
        *(argv + ((top - (middle - bottom)) + i)) = tem;
#line 194
        i ++;
      }
#line 202
      top -= len;
    } else {
#line 207
      len___0 = top - middle;
#line 211
      i___0 = 0;
#line 211
      while (i___0 < len___0) {
#line 213
        tem = *(argv + (bottom + i___0));
#line 214
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 215
        *(argv + (middle + i___0)) = tem;
#line 211
        i___0 ++;
      }
#line 219
      bottom += len___0;
    }
  }
#line 225
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 226
  d->__last_nonopt = d->rpl_optind;
#line 227
  return;
}
}
#line 231 "getopt.c"
static char const   *_getopt_initialize(int argc , char **argv , char const   *optstring ,
                                        int posixly_correct___0 , struct _getopt_data *d ) 
{ int __cil_tmp ;
  char *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 239
  __cil_tmp = d->rpl_optind;
#line 239
  d->__last_nonopt = __cil_tmp;
#line 239
  d->__first_nonopt = __cil_tmp;
#line 241
  d->__nextchar = (char *)((void *)0);
#line 243
  if (posixly_correct___0) {
#line 243
    __cil_tmp___1 = 1;
  } else {
#line 243
    __cil_tmp___0 = getenv("POSIXLY_CORRECT");
#line 243
    if (__cil_tmp___0) {
#line 243
      __cil_tmp___1 = 1;
    } else {
#line 243
      __cil_tmp___1 = 0;
    }
  }
#line 243
  d->__posixly_correct = __cil_tmp___1;
#line 247
  if ((int const   )*(optstring + 0) == 45) {
#line 249
    d->__ordering = (enum __anonenum___ordering_11 )2;
#line 250
    optstring ++;
  } else
#line 252
  if ((int const   )*(optstring + 0) == 43) {
#line 254
    d->__ordering = (enum __anonenum___ordering_11 )0;
#line 255
    optstring ++;
  } else
#line 257
  if (d->__posixly_correct) {
#line 258
    d->__ordering = (enum __anonenum___ordering_11 )0;
  } else {
#line 260
    d->__ordering = (enum __anonenum___ordering_11 )1;
  }
#line 292
  return (optstring);
}
}
#line 350 "getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct option  const  *longopts___0 ,
                       int *longind , int long_only , int posixly_correct___0 , struct _getopt_data *d ) 
{ int print_errors ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  char *nameend ;
  struct option  const  *p ;
  struct option  const  *pfound ;
  int exact ;
  int ambig ;
  int indfound ;
  int option_index ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  size_t __cil_tmp___4 ;
  int __cil_tmp___5 ;
  size_t __cil_tmp___6 ;
  size_t __cil_tmp___7 ;
  char *__cil_tmp___8 ;
  char *__cil_tmp___9 ;
  char c ;
  char *__cil_tmp___10 ;
  char *temp ;
  char *__cil_tmp___11 ;
  char *nameend___0 ;
  struct option  const  *p___0 ;
  struct option  const  *pfound___0 ;
  int exact___0 ;
  int ambig___0 ;
  int indfound___0 ;
  int option_index___0 ;
  int __cil_tmp___12 ;
  size_t __cil_tmp___13 ;
  int __cil_tmp___14 ;
  size_t __cil_tmp___15 ;
  size_t __cil_tmp___16 ;
  int __cil_tmp___17 ;
  size_t __cil_tmp___18 ;
  size_t __cil_tmp___19 ;
  int __cil_tmp___20 ;

  {
#line 355
  print_errors = d->rpl_opterr;
#line 356
  if ((int const   )*(optstring + 0) == 58) {
#line 357
    print_errors = 0;
  }
#line 359
  if (argc < 1) {
#line 360
    return (-1);
  }
#line 362
  d->rpl_optarg = (char *)((void *)0);
#line 364
  if (d->rpl_optind == 0 || ! d->__initialized) {
#line 366
    if (d->rpl_optind == 0) {
#line 367
      d->rpl_optind = 1;
    }
#line 368
    optstring = _getopt_initialize(argc, argv, optstring, posixly_correct___0, d);
#line 370
    d->__initialized = 1;
  }
#line 385
  if ((unsigned int )d->__nextchar == (unsigned int )((void *)0) || (int )*(d->__nextchar) == 0) {
#line 391
    if (d->__last_nonopt > d->rpl_optind) {
#line 392
      d->__last_nonopt = d->rpl_optind;
    }
#line 393
    if (d->__first_nonopt > d->rpl_optind) {
#line 394
      d->__first_nonopt = d->rpl_optind;
    }
#line 396
    if ((unsigned int )d->__ordering == 1U) {
#line 401
      if (d->__first_nonopt != d->__last_nonopt && d->__last_nonopt != d->rpl_optind) {
#line 403
        exchange(argv, d);
      } else
#line 404
      if (d->__last_nonopt != d->rpl_optind) {
#line 405
        d->__first_nonopt = d->rpl_optind;
      }
#line 410
      while (d->rpl_optind < argc && ((int )*(*(argv + d->rpl_optind) + 0) != 45 || (int )*(*(argv + d->rpl_optind) + 1) == 0)) {
#line 411
        (d->rpl_optind) ++;
      }
#line 412
      d->__last_nonopt = d->rpl_optind;
    }
#line 420
    if (d->rpl_optind != argc) {
#line 420
      __cil_tmp = strcmp((char const   *)*(argv + d->rpl_optind), "--");
#line 420
      if (! __cil_tmp) {
#line 422
        (d->rpl_optind) ++;
#line 424
        if (d->__first_nonopt != d->__last_nonopt && d->__last_nonopt != d->rpl_optind) {
#line 426
          exchange(argv, d);
        } else
#line 427
        if (d->__first_nonopt == d->__last_nonopt) {
#line 428
          d->__first_nonopt = d->rpl_optind;
        }
#line 429
        d->__last_nonopt = argc;
#line 431
        d->rpl_optind = argc;
      }
    }
#line 437
    if (d->rpl_optind == argc) {
#line 441
      if (d->__first_nonopt != d->__last_nonopt) {
#line 442
        d->rpl_optind = d->__first_nonopt;
      }
#line 443
      return (-1);
    }
#line 449
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45 || (int )*(*(argv + d->rpl_optind) + 1) == 0) {
#line 451
      if ((unsigned int )d->__ordering == 0U) {
#line 452
        return (-1);
      }
#line 453
      __cil_tmp___0 = d->rpl_optind;
#line 453
      (d->rpl_optind) ++;
#line 453
      d->rpl_optarg = *(argv + __cil_tmp___0);
#line 454
      return (1);
    }
#line 460
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + ((unsigned int )longopts___0 != (unsigned int )((void *)0) && (int )*(*(argv + d->rpl_optind) + 1) == 45);
  }
#line 479
  if ((unsigned int )longopts___0 != (unsigned int )((void *)0)) {
#line 479
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 479
      goto _L___1;
    } else
#line 479
    if (long_only) {
#line 479
      if (*(*(argv + d->rpl_optind) + 2)) {
#line 479
        goto _L___1;
      } else {
#line 479
        __cil_tmp___9 = strchr(optstring, (int )*(*(argv + d->rpl_optind) + 1));
#line 479
        if (! __cil_tmp___9) {
          _L___1: 
#line 486
          pfound = (struct option  const  *)((void *)0);
#line 487
          exact = 0;
#line 488
          ambig = 0;
#line 489
          indfound = -1;
#line 492
          nameend = d->__nextchar;
#line 492
          while (*nameend && (int )*nameend != 61) {
#line 492
            nameend ++;
          }
#line 497
          p = longopts___0;
#line 497
          option_index = 0;
#line 497
          while (p->name) {
#line 498
            __cil_tmp___2 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                                    (unsigned int )(nameend - d->__nextchar));
#line 498
            if (! __cil_tmp___2) {
#line 500
              __cil_tmp___1 = strlen((char const   *)p->name);
#line 500
              if ((unsigned int )(nameend - d->__nextchar) == __cil_tmp___1) {
#line 504
                pfound = p;
#line 505
                indfound = option_index;
#line 506
                exact = 1;
#line 507
                break;
              } else
#line 509
              if ((unsigned int )pfound == (unsigned int )((void *)0)) {
#line 512
                pfound = p;
#line 513
                indfound = option_index;
              } else
#line 515
              if (((long_only || pfound->has_arg != p->has_arg) || (unsigned int )pfound->flag != (unsigned int )p->flag) || pfound->val != p->val) {
#line 520
                ambig = 1;
              }
            }
#line 497
            p ++;
#line 497
            option_index ++;
          }
#line 523
          if (ambig && ! exact) {
#line 525
            if (print_errors) {
#line 546
              fprintf(_impure_ptr->_stderr, "%s: option `%s\' is ambiguous\n", *(argv + 0),
                      *(argv + d->rpl_optind));
            }
#line 550
            __cil_tmp___3 = strlen((char const   *)d->__nextchar);
#line 550
            d->__nextchar += __cil_tmp___3;
#line 551
            (d->rpl_optind) ++;
#line 552
            d->rpl_optopt = 0;
#line 553
            return ('?');
          }
#line 556
          if ((unsigned int )pfound != (unsigned int )((void *)0)) {
#line 558
            option_index = indfound;
#line 559
            (d->rpl_optind) ++;
#line 560
            if (*nameend) {
#line 564
              if (pfound->has_arg) {
#line 565
                d->rpl_optarg = nameend + 1;
              } else {
#line 568
                if (print_errors) {
#line 575
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
#line 583
                    fprintf(_impure_ptr->_stderr, "%s: option `--%s\' doesn\'t allow an argument\n",
                            *(argv + 0), pfound->name);
                  } else {
#line 597
                    fprintf(_impure_ptr->_stderr, "%s: option `%c%s\' doesn\'t allow an argument\n",
                            *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                            pfound->name);
                  }
                }
#line 623
                __cil_tmp___4 = strlen((char const   *)d->__nextchar);
#line 623
                d->__nextchar += __cil_tmp___4;
#line 625
                d->rpl_optopt = (int )pfound->val;
#line 626
                return ('?');
              }
            } else
#line 629
            if (pfound->has_arg == 1) {
#line 631
              if (d->rpl_optind < argc) {
#line 632
                __cil_tmp___5 = d->rpl_optind;
#line 632
                (d->rpl_optind) ++;
#line 632
                d->rpl_optarg = *(argv + __cil_tmp___5);
              } else {
#line 635
                if (print_errors) {
#line 658
                  fprintf(_impure_ptr->_stderr, "%s: option `%s\' requires an argument\n",
                          *(argv + 0), *(argv + (d->rpl_optind - 1)));
                }
#line 663
                __cil_tmp___6 = strlen((char const   *)d->__nextchar);
#line 663
                d->__nextchar += __cil_tmp___6;
#line 664
                d->rpl_optopt = (int )pfound->val;
#line 665
                return ((int const   )*(optstring + 0) == 58 ? ':' : '?');
              }
            }
#line 668
            __cil_tmp___7 = strlen((char const   *)d->__nextchar);
#line 668
            d->__nextchar += __cil_tmp___7;
#line 669
            if ((unsigned int )longind != (unsigned int )((void *)0)) {
#line 670
              *longind = option_index;
            }
#line 671
            if (pfound->flag) {
#line 673
              *(pfound->flag) = (int )pfound->val;
#line 674
              return (0);
            }
#line 676
            return ((int )pfound->val);
          }
#line 683
          if (! long_only || (int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 683
            goto _L;
          } else {
#line 683
            __cil_tmp___8 = strchr(optstring, (int )*(d->__nextchar));
#line 683
            if ((unsigned int )__cil_tmp___8 == (unsigned int )((void *)0)) {
              _L: 
#line 686
              if (print_errors) {
#line 693
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 700
                  fprintf(_impure_ptr->_stderr, "%s: unrecognized option `--%s\'\n",
                          *(argv + 0), d->__nextchar);
                } else {
#line 711
                  fprintf(_impure_ptr->_stderr, "%s: unrecognized option `%c%s\'\n",
                          *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                }
              }
#line 733
              d->__nextchar = (char *)"";
#line 734
              (d->rpl_optind) ++;
#line 735
              d->rpl_optopt = 0;
#line 736
              return ('?');
            }
          }
        }
      }
    }
  }
#line 743
  __cil_tmp___10 = d->__nextchar;
#line 743
  (d->__nextchar) ++;
#line 743
  c = *__cil_tmp___10;
#line 744
  __cil_tmp___11 = strchr(optstring, (int )c);
#line 744
  temp = __cil_tmp___11;
#line 747
  if ((int )*(d->__nextchar) == 0) {
#line 748
    (d->rpl_optind) ++;
  }
#line 750
  if ((unsigned int )temp == (unsigned int )((void *)0) || (int )c == 58) {
#line 752
    if (print_errors) {
#line 759
      if (d->__posixly_correct) {
#line 766
        fprintf(_impure_ptr->_stderr, "%s: illegal option -- %c\n", *(argv + 0), (int )c);
      } else {
#line 775
        fprintf(_impure_ptr->_stderr, "%s: invalid option -- %c\n", *(argv + 0), (int )c);
      }
    }
#line 796
    d->rpl_optopt = (int )c;
#line 797
    return ('?');
  }
#line 800
  if ((int )*(temp + 0) == 87 && (int )*(temp + 1) == 59) {
#line 804
    pfound___0 = (struct option  const  *)((void *)0);
#line 805
    exact___0 = 0;
#line 806
    ambig___0 = 0;
#line 807
    indfound___0 = 0;
#line 811
    if ((int )*(d->__nextchar) != 0) {
#line 813
      d->rpl_optarg = d->__nextchar;
#line 816
      (d->rpl_optind) ++;
    } else
#line 818
    if (d->rpl_optind == argc) {
#line 820
      if (print_errors) {
#line 843
        fprintf(_impure_ptr->_stderr, "%s: option requires an argument -- %c\n", *(argv + 0),
                (int )c);
      }
#line 847
      d->rpl_optopt = (int )c;
#line 848
      if ((int const   )*(optstring + 0) == 58) {
#line 849
        c = (char )':';
      } else {
#line 851
        c = (char )'?';
      }
#line 852
      return ((int )c);
    } else {
#line 857
      __cil_tmp___12 = d->rpl_optind;
#line 857
      (d->rpl_optind) ++;
#line 857
      d->rpl_optarg = *(argv + __cil_tmp___12);
    }
#line 862
    nameend___0 = d->rpl_optarg;
#line 862
    d->__nextchar = nameend___0;
#line 862
    while (*nameend___0 && (int )*nameend___0 != 61) {
#line 862
      nameend___0 ++;
    }
#line 868
    p___0 = longopts___0;
#line 868
    option_index___0 = 0;
#line 868
    while (p___0->name) {
#line 869
      __cil_tmp___14 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                               (unsigned int )(nameend___0 - d->__nextchar));
#line 869
      if (! __cil_tmp___14) {
#line 871
        __cil_tmp___13 = strlen((char const   *)p___0->name);
#line 871
        if ((unsigned int )(nameend___0 - d->__nextchar) == __cil_tmp___13) {
#line 874
          pfound___0 = p___0;
#line 875
          indfound___0 = option_index___0;
#line 876
          exact___0 = 1;
#line 877
          break;
        } else
#line 879
        if ((unsigned int )pfound___0 == (unsigned int )((void *)0)) {
#line 882
          pfound___0 = p___0;
#line 883
          indfound___0 = option_index___0;
        } else {
#line 887
          ambig___0 = 1;
        }
      }
#line 868
      p___0 ++;
#line 868
      option_index___0 ++;
    }
#line 889
    if (ambig___0 && ! exact___0) {
#line 891
      if (print_errors) {
#line 912
        fprintf(_impure_ptr->_stderr, "%s: option `-W %s\' is ambiguous\n", *(argv + 0),
                *(argv + d->rpl_optind));
      }
#line 916
      __cil_tmp___15 = strlen((char const   *)d->__nextchar);
#line 916
      d->__nextchar += __cil_tmp___15;
#line 917
      (d->rpl_optind) ++;
#line 918
      return ('?');
    }
#line 920
    if ((unsigned int )pfound___0 != (unsigned int )((void *)0)) {
#line 922
      option_index___0 = indfound___0;
#line 923
      if (*nameend___0) {
#line 927
        if (pfound___0->has_arg) {
#line 928
          d->rpl_optarg = nameend___0 + 1;
        } else {
#line 931
          if (print_errors) {
#line 954
            fprintf(_impure_ptr->_stderr, "%s: option `-W %s\' doesn\'t allow an argument\n",
                    *(argv + 0), pfound___0->name);
          }
#line 960
          __cil_tmp___16 = strlen((char const   *)d->__nextchar);
#line 960
          d->__nextchar += __cil_tmp___16;
#line 961
          return ('?');
        }
      } else
#line 964
      if (pfound___0->has_arg == 1) {
#line 966
        if (d->rpl_optind < argc) {
#line 967
          __cil_tmp___17 = d->rpl_optind;
#line 967
          (d->rpl_optind) ++;
#line 967
          d->rpl_optarg = *(argv + __cil_tmp___17);
        } else {
#line 970
          if (print_errors) {
#line 993
            fprintf(_impure_ptr->_stderr, "%s: option `%s\' requires an argument\n",
                    *(argv + 0), *(argv + (d->rpl_optind - 1)));
          }
#line 998
          __cil_tmp___18 = strlen((char const   *)d->__nextchar);
#line 998
          d->__nextchar += __cil_tmp___18;
#line 999
          return ((int const   )*(optstring + 0) == 58 ? ':' : '?');
        }
      }
#line 1002
      __cil_tmp___19 = strlen((char const   *)d->__nextchar);
#line 1002
      d->__nextchar += __cil_tmp___19;
#line 1003
      if ((unsigned int )longind != (unsigned int )((void *)0)) {
#line 1004
        *longind = option_index___0;
      }
#line 1005
      if (pfound___0->flag) {
#line 1007
        *(pfound___0->flag) = (int )pfound___0->val;
#line 1008
        return (0);
      }
#line 1010
      return ((int )pfound___0->val);
    }
#line 1012
    d->__nextchar = (char *)((void *)0);
#line 1013
    return ('W');
  }
#line 1015
  if ((int )*(temp + 1) == 58) {
#line 1017
    if ((int )*(temp + 2) == 58) {
#line 1020
      if ((int )*(d->__nextchar) != 0) {
#line 1022
        d->rpl_optarg = d->__nextchar;
#line 1023
        (d->rpl_optind) ++;
      } else {
#line 1026
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1027
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1032
      if ((int )*(d->__nextchar) != 0) {
#line 1034
        d->rpl_optarg = d->__nextchar;
#line 1037
        (d->rpl_optind) ++;
      } else
#line 1039
      if (d->rpl_optind == argc) {
#line 1041
        if (print_errors) {
#line 1064
          fprintf(_impure_ptr->_stderr, "%s: option requires an argument -- %c\n",
                  *(argv + 0), (int )c);
        }
#line 1069
        d->rpl_optopt = (int )c;
#line 1070
        if ((int const   )*(optstring + 0) == 58) {
#line 1071
          c = (char )':';
        } else {
#line 1073
          c = (char )'?';
        }
      } else {
#line 1078
        __cil_tmp___20 = d->rpl_optind;
#line 1078
        (d->rpl_optind) ++;
#line 1078
        d->rpl_optarg = *(argv + __cil_tmp___20);
      }
#line 1079
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1082
  return ((int )c);
}
}
#line 1086 "getopt.c"
int _getopt_internal(int argc , char **argv , char const   *optstring , struct option  const  *longopts___0 ,
                     int *longind , int long_only , int posixly_correct___0 ) 
{ int result ;

  {
#line 1093
  getopt_data.rpl_optind = rpl_optind;
#line 1094
  getopt_data.rpl_opterr = rpl_opterr;
#line 1096
  result = _getopt_internal_r(argc, argv, optstring, longopts___0, longind, long_only,
                              posixly_correct___0, & getopt_data);
#line 1099
  rpl_optind = getopt_data.rpl_optind;
#line 1100
  rpl_optarg = getopt_data.rpl_optarg;
#line 1101
  rpl_optopt = getopt_data.rpl_optopt;
#line 1103
  return (result);
}
}
#line 1114 "getopt.c"
int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) 
{ int __cil_tmp ;

  {
#line 1117
  __cil_tmp = _getopt_internal(argc, (char **)argv, optstring, (struct option  const  *)((void *)0),
                               (int *)((void *)0), 0, 0);
#line 1117
  return (__cil_tmp);
}
}
#line 1 "getopt1.o"
#pragma merger(0,"/tmp/cil-o4rqBFx7.i","-g,-O2")
#line 212 "getopt.h"
int rpl_getopt_long_only(int argc , char **argv , char const   *options , struct option  const  *long_options___0 ,
                         int *opt_index ) ;
#line 119 "getopt_int.h"
int _getopt_long_r(int argc , char **argv , char const   *options , struct option  const  *long_options___0 ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 124
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct option  const  *long_options___0 ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 39 "getopt1.c"
int rpl_getopt_long(int argc , char **argv , char const   *options , struct option  const  *long_options___0 ,
                    int *opt_index ) 
{ int __cil_tmp ;

  {
#line 43
  __cil_tmp = _getopt_internal(argc, argv, options, long_options___0, opt_index, 0,
                               0);
#line 43
  return (__cil_tmp);
}
}
#line 47 "getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options , struct option  const  *long_options___0 ,
                   int *opt_index , struct _getopt_data *d ) 
{ int __cil_tmp ;

  {
#line 52
  __cil_tmp = _getopt_internal_r(argc, argv, options, long_options___0, opt_index,
                                 0, 0, d);
#line 52
  return (__cil_tmp);
}
}
#line 61 "getopt1.c"
int rpl_getopt_long_only(int argc , char **argv , char const   *options , struct option  const  *long_options___0 ,
                         int *opt_index ) 
{ int __cil_tmp ;

  {
#line 66
  __cil_tmp = _getopt_internal(argc, argv, options, long_options___0, opt_index, 1,
                               0);
#line 66
  return (__cil_tmp);
}
}
#line 70 "getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options , struct option  const  *long_options___0 ,
                        int *opt_index , struct _getopt_data *d ) 
{ int __cil_tmp ;

  {
#line 75
  __cil_tmp = _getopt_internal_r(argc, argv, options, long_options___0, opt_index,
                                 1, 0, d);
#line 75
  return (__cil_tmp);
}
}
#line 1 "getpass.o"
#pragma merger(0,"/tmp/cil-SIUcIRKf.i","-g,-O2")
#line 88 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
char *gnu_getpass(char const   *prompt ) ;
#line 8 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/termios.h"
struct __anonstruct__TERMIOS_TABLE_11 _TERMIOS_TABLE[2]  ;
#line 10
extern int tcgetattr(int fildes , struct termios *termios_p ) ;
#line 11
extern int tcsetattr(int fildes , int optional_actions , struct termios  const  *termios_p ) ;
#line 80 "getpass.c"
static void call_fclose(void *arg ) 
{ 

  {
#line 83
  if ((unsigned int )arg != (unsigned int )((void *)0)) {
#line 84
    fclose((FILE *)arg);
  }
#line 85
  return;
}
}
#line 94 "getpass.c"
static char *buf  ;
#line 95 "getpass.c"
static size_t bufsize  ;
#line 87 "getpass.c"
char *gnu_getpass(char const   *prompt ) 
{ FILE *tty ;
  FILE *in ;
  FILE *out ;
  struct termios s ;
  struct termios t ;
  _Bool tty_changed ;
  ssize_t nread ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 93
  tty_changed = (_Bool)0;
#line 101
  tty = fopen("/dev/tty", "w+");
#line 102
  if ((unsigned int )tty == (unsigned int )((void *)0)) {
#line 104
    in = _impure_ptr->_stdin;
#line 105
    out = _impure_ptr->_stderr;
  } else {
#line 112
    in = tty;
#line 112
    out = in;
  }
#line 119
  __cil_tmp___1 = fileno(in);
#line 119
  __cil_tmp___2 = tcgetattr(__cil_tmp___1, & t);
#line 119
  if (__cil_tmp___2 == 0) {
#line 122
    s = t;
#line 124
    t.c_lflag = (unsigned short )((int )t.c_lflag & -10);
#line 125
    __cil_tmp = fileno(in);
#line 125
    __cil_tmp___0 = tcsetattr(__cil_tmp, (120 << 8) | 4, (struct termios  const  *)(& t));
#line 125
    tty_changed = (_Bool )(__cil_tmp___0 == 0);
  }
#line 130
  fputs(prompt, out);
#line 131
  rpl_fflush(out);
#line 134
  nread = rpl_getline(& buf, & bufsize, in);
#line 145
  rpl_fseeko(out, 0L, 1);
#line 147
  if ((unsigned int )buf != (unsigned int )((void *)0)) {
#line 149
    if (nread < 0) {
#line 150
      *(buf + 0) = (char )'\000';
    } else
#line 151
    if ((int )*(buf + (nread - 1)) == 10) {
#line 154
      *(buf + (nread - 1)) = (char )'\000';
#line 155
      if (tty_changed) {
#line 158
        putc_unlocked('\n', out);
      }
    }
  }
#line 165
  if (tty_changed) {
#line 166
    __cil_tmp___3 = fileno(in);
#line 166
    tcsetattr(__cil_tmp___3, (120 << 8) | 4, (struct termios  const  *)(& s));
  }
#line 171
  call_fclose((void *)tty);
#line 173
  return (buf);
}
}
#line 1 "gettime.o"
#pragma merger(0,"/tmp/cil-XRz2zclH.i","-g,-O2")
#line 52 "./sys/time.h"
int rpl_gettimeofday(struct timeval * __restrict  tv , void * __restrict  tz ) ;
#line 28 "gettime.c"
void gettime(struct timespec *ts ) 
{ struct timeval tv ;

  {
#line 42
  rpl_gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
#line 43
  ts->tv_sec = tv.tv_sec;
#line 44
  ts->tv_nsec = tv.tv_usec * 1000L;
#line 48
  return;
}
}
#line 1 "gettimeofday.o"
#pragma merger(0,"/tmp/cil-4UOguYm0.i","-g,-O2")
#line 74 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/time.h"
extern int gettimeofday(struct timeval *__p , void *__tz ) ;
#line 71 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/time.h"
void rpl_tzset(void) ;
#line 43 "gettimeofday.c"
static struct tm tm_zero_buffer  ;
#line 44 "gettimeofday.c"
static struct tm *localtime_buffer_addr  =    & tm_zero_buffer;
#line 56
extern struct tm *localtime(time_t const   * ) ;
#line 52 "gettimeofday.c"
struct tm *rpl_localtime(time_t const   *timep ) 
{ struct tm *tm ;
  struct tm *__cil_tmp ;

  {
#line 57
  __cil_tmp = localtime(timep);
#line 57
  tm = __cil_tmp;
#line 59
  if ((unsigned int )localtime_buffer_addr == (unsigned int )(& tm_zero_buffer)) {
#line 60
    localtime_buffer_addr = tm;
  }
#line 62
  return (tm);
}
}
#line 70
extern struct tm *gmtime(time_t const   * ) ;
#line 66 "gettimeofday.c"
struct tm *rpl_gmtime(time_t const   *timep ) 
{ struct tm *tm ;
  struct tm *__cil_tmp ;

  {
#line 71
  __cil_tmp = gmtime(timep);
#line 71
  tm = __cil_tmp;
#line 73
  if ((unsigned int )localtime_buffer_addr == (unsigned int )(& tm_zero_buffer)) {
#line 74
    localtime_buffer_addr = tm;
  }
#line 76
  return (tm);
}
}
#line 88
extern void tzset(void) ;
#line 84 "gettimeofday.c"
void rpl_tzset(void) 
{ struct tm save ;

  {
#line 92
  save = *localtime_buffer_addr;
#line 93
  tzset();
#line 94
  *localtime_buffer_addr = save;
#line 95
  return;
}
}
#line 102 "gettimeofday.c"
int rpl_gettimeofday(struct timeval * __restrict  tv , void * __restrict  tz ) 
{ struct tm save ;
  int result ;
  int __cil_tmp ;

  {
#line 110
  save = *localtime_buffer_addr;
#line 113
  __cil_tmp = gettimeofday((struct timeval *)tv, (void *)tz);
#line 113
  result = __cil_tmp;
#line 116
  *localtime_buffer_addr = save;
#line 119
  return (result);
}
}
#line 1 "getugroups.o"
#pragma merger(0,"/tmp/cil-PPhWxJj0.i","-g,-O2")
#line 18 "getugroups.h"
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) ;
#line 17 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/grp.h"
extern struct group *getgrent(void) ;
#line 18
extern void endgrent(void) ;
#line 19
extern void setgrent(void) ;
#line 50 "getugroups.c"
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) 
{ int count ;
  char **cp ;
  struct group *grp ;
  int *__cil_tmp ;
  int n ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int saved_errno ;
  int *__cil_tmp___3 ;
  int *__cil_tmp___4 ;

  {
#line 54
  count = 0;
#line 56
  if ((int )gid != 65535) {
#line 58
    if (maxcount != 0) {
#line 59
      *(grouplist + count) = gid;
    }
#line 60
    count ++;
  }
#line 63
  setgrent();
#line 64
  while (1) {
#line 69
    __cil_tmp = __errno();
#line 69
    *__cil_tmp = 0;
#line 70
    grp = getgrent();
#line 71
    if ((unsigned int )grp == (unsigned int )((void *)0)) {
#line 72
      break;
    }
#line 74
    cp = grp->gr_mem;
#line 74
    while (*cp) {
#line 78
      __cil_tmp___0 = strcmp(username, (char const   *)*cp);
#line 78
      if (! (__cil_tmp___0 == 0)) {
#line 79
        goto __Cont;
      }
#line 82
      n = 0;
#line 82
      while (n < count) {
#line 83
        if (grouplist && (int )*(grouplist + n) == (int )grp->gr_gid) {
#line 84
          break;
        }
#line 82
        n ++;
      }
#line 87
      if (n == count) {
#line 89
        if (maxcount != 0) {
#line 91
          if (count >= maxcount) {
#line 92
            goto done;
          }
#line 93
          *(grouplist + count) = grp->gr_gid;
        }
#line 95
        count ++;
#line 96
        if (count < 0) {
#line 98
          __cil_tmp___1 = __errno();
#line 98
          *__cil_tmp___1 = 139;
#line 99
          goto done;
        }
      }
      __Cont: 
#line 74
      cp ++;
    }
  }
#line 105
  __cil_tmp___2 = __errno();
#line 105
  if (*__cil_tmp___2 != 0) {
#line 106
    count = -1;
  }
  done: 
#line 110
  __cil_tmp___3 = __errno();
#line 110
  saved_errno = *__cil_tmp___3;
#line 111
  endgrent();
#line 112
  __cil_tmp___4 = __errno();
#line 112
  *__cil_tmp___4 = saved_errno;
#line 115
  return (count);
}
}
#line 1 "getusershell.o"
#pragma merger(0,"/tmp/cil-893innvy.i","-g,-O2")
#line 219 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern void rewind(FILE * ) ;
#line 43 "getusershell.c"
static size_t readname(char **name , size_t *size , FILE *stream ) ;
#line 53 "getusershell.c"
static char const   * const  default_shells[5]  = {      (char const   * const  )"/bin/sh",      (char const   * const  )"/bin/csh",      (char const   * const  )"/usr/bin/sh",      (char const   * const  )"/usr/bin/csh", 
        (char const   * const  )((void *)0)};
#line 61 "getusershell.c"
static size_t default_index  =    0U;
#line 64 "getusershell.c"
static FILE *shellstream  =    (FILE *)((void *)0);
#line 67 "getusershell.c"
static char *line  =    (char *)((void *)0);
#line 70 "getusershell.c"
static size_t line_size  =    0U;
#line 77 "getusershell.c"
char *getusershell(void) 
{ size_t __cil_tmp ;
  char *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  size_t __cil_tmp___2 ;

  {
#line 80
  if (default_index > 0U) {
#line 82
    if (default_shells[default_index]) {
#line 84
      __cil_tmp = default_index;
#line 84
      default_index ++;
#line 84
      __cil_tmp___0 = xstrdup((char const   *)default_shells[__cil_tmp]);
#line 84
      return (__cil_tmp___0);
    }
#line 85
    return ((char *)((void *)0));
  }
#line 88
  if ((unsigned int )shellstream == (unsigned int )((void *)0)) {
#line 90
    shellstream = fopen_safer("/etc/shells", "r");
#line 91
    if ((unsigned int )shellstream == (unsigned int )((void *)0)) {
#line 94
      default_index = 1U;
#line 95
      __cil_tmp___1 = xstrdup((char const   *)default_shells[0]);
#line 95
      return (__cil_tmp___1);
    }
  }
#line 99
  while (1) {
#line 99
    __cil_tmp___2 = readname(& line, & line_size, shellstream);
#line 99
    if (! __cil_tmp___2) {
#line 99
      break;
    }
#line 101
    if ((int )*line != 35) {
#line 102
      return (line);
    }
  }
#line 104
  return ((char *)((void *)0));
}
}
#line 109 "getusershell.c"
void setusershell(void) 
{ 

  {
#line 112
  default_index = 0U;
#line 113
  if (shellstream) {
#line 114
    rewind(shellstream);
  }
#line 115
  return;
}
}
#line 119 "getusershell.c"
void endusershell(void) 
{ 

  {
#line 122
  if (shellstream) {
#line 124
    fclose(shellstream);
#line 125
    shellstream = (FILE *)((void *)0);
  }
#line 127
  return;
}
}
#line 137 "getusershell.c"
static size_t readname(char **name , size_t *size , FILE *stream ) 
{ int c ;
  size_t name_index ;
  void *__cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 141
  name_index = 0U;
#line 144
  while (1) {
#line 144
    c = getc_unlocked(stream);
#line 144
    if (! (c != -1 && (int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 8)) {
#line 144
      break;
    }
  }
#line 147
  while (1) {
#line 149
    if (*size <= name_index) {
#line 150
      __cil_tmp = x2nrealloc((void *)*name, size, sizeof(*(*name)));
#line 150
      *name = (char *)__cil_tmp;
    }
#line 151
    if (c == -1 || (int const   )*((__ctype_ptr__ + sizeof(*("" + c))) + c) & 8) {
#line 152
      break;
    }
#line 153
    __cil_tmp___0 = name_index;
#line 153
    name_index ++;
#line 153
    *(*name + __cil_tmp___0) = (char )c;
#line 154
    c = getc_unlocked(stream);
  }
#line 156
  *(*name + name_index) = (char )'\000';
#line 157
  return (name_index);
}
}
#line 1 "group-member.o"
#pragma merger(0,"/tmp/cil-pVnYN3n2.i","-g,-O2")
#line 81 "group-member.c"
int group_member(gid_t gid ) 
{ gid_t __cil_tmp ;
  gid_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 85
  __cil_tmp = getgid();
#line 85
  if ((int )gid == (int )__cil_tmp) {
#line 85
    __cil_tmp___1 = 1;
  } else {
#line 85
    __cil_tmp___0 = getegid();
#line 85
    if ((int )gid == (int )__cil_tmp___0) {
#line 85
      __cil_tmp___1 = 1;
    } else {
#line 85
      __cil_tmp___1 = 0;
    }
  }
#line 85
  return (__cil_tmp___1);
}
}
#line 1 "hard-locale.o"
#pragma merger(0,"/tmp/cil-l0uLS0XD.i","-g,-O2")
#line 23 "hard-locale.h"
_Bool hard_locale(int category ) ;
#line 35 "hard-locale.c"
_Bool hard_locale(int category ) 
{ _Bool hard ;
  char const   *p ;
  char *__cil_tmp ;
  char *locale ;
  char *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  char *__cil_tmp___5 ;
  int __cil_tmp___6 ;

  {
#line 38
  hard = (_Bool)1;
#line 39
  __cil_tmp = setlocale(category, (char const   *)((void *)0));
#line 39
  p = (char const   *)__cil_tmp;
#line 41
  if (p) {
#line 50
    __cil_tmp___2 = strdup(p);
#line 50
    locale = __cil_tmp___2;
#line 51
    if (locale) {
#line 56
      __cil_tmp___3 = setlocale(category, "C");
#line 56
      p = (char const   *)__cil_tmp___3;
#line 56
      if (p) {
#line 56
        __cil_tmp___4 = strcmp(p, (char const   *)locale);
#line 56
        if (__cil_tmp___4 == 0) {
#line 60
          hard = (_Bool)0;
        } else {
#line 56
          goto _L;
        }
      } else {
        _L: 
#line 56
        __cil_tmp___5 = setlocale(category, "POSIX");
#line 56
        p = (char const   *)__cil_tmp___5;
#line 56
        if (p) {
#line 56
          __cil_tmp___6 = strcmp(p, (char const   *)locale);
#line 56
          if (__cil_tmp___6 == 0) {
#line 60
            hard = (_Bool)0;
          }
        }
      }
#line 63
      setlocale(category, (char const   *)locale);
#line 64
      free((void *)locale);
    }
  }
#line 69
  return (hard);
}
}
#line 1 "hash.o"
#pragma merger(0,"/tmp/cil-cFIdsEec.i","-g,-O2")
#line 59 "hash.h"
size_t hash_get_n_buckets(Hash_table const   *table___0 ) ;
#line 60
size_t hash_get_n_buckets_used(Hash_table const   *table___0 ) ;
#line 61
size_t hash_get_n_entries(Hash_table const   *table___0 ) ;
#line 62
size_t hash_get_max_bucket_length(Hash_table const   *table___0 ) ;
#line 63
_Bool hash_table_ok(Hash_table const   *table___0 ) ;
#line 64
void hash_print_statistics(Hash_table const   *table___0 , FILE *stream ) ;
#line 68
void *hash_get_first(Hash_table const   *table___0 ) ;
#line 69
void *hash_get_next(Hash_table const   *table___0 , void const   *entry ) ;
#line 70
size_t hash_get_entries(Hash_table const   *table___0 , void **buffer , size_t buffer_size ) ;
#line 71
size_t hash_do_for_each(Hash_table const   *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) ;
#line 74
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 75
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 79
void hash_clear(Hash_table *table___0 ) ;
#line 83
_Bool hash_rehash(Hash_table *table___0 , size_t candidate ) ;
#line 127 "hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 146 "hash.c"
size_t hash_get_n_buckets(Hash_table const   *table___0 ) 
{ 

  {
#line 149
  return ((unsigned int )table___0->n_buckets);
}
}
#line 154 "hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table___0 ) 
{ 

  {
#line 157
  return ((unsigned int )table___0->n_buckets_used);
}
}
#line 162 "hash.c"
size_t hash_get_n_entries(Hash_table const   *table___0 ) 
{ 

  {
#line 165
  return ((unsigned int )table___0->n_entries);
}
}
#line 170 "hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table___0 ) 
{ struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 174
  max_bucket_length = 0U;
#line 176
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 176
  while ((unsigned int )bucket < (unsigned int )table___0->bucket_limit) {
#line 178
    if (bucket->data) {
#line 180
      cursor = bucket;
#line 181
      bucket_length = 1U;
#line 183
      while (1) {
#line 183
        cursor = (struct hash_entry  const  *)cursor->next;
#line 183
        if (! cursor) {
#line 183
          break;
        }
#line 184
        bucket_length ++;
      }
#line 186
      if (bucket_length > max_bucket_length) {
#line 187
        max_bucket_length = bucket_length;
      }
    }
#line 176
    bucket ++;
  }
#line 191
  return (max_bucket_length);
}
}
#line 197 "hash.c"
_Bool hash_table_ok(Hash_table const   *table___0 ) 
{ struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 201
  n_buckets_used = 0U;
#line 202
  n_entries = 0U;
#line 204
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 204
  while ((unsigned int )bucket < (unsigned int )table___0->bucket_limit) {
#line 206
    if (bucket->data) {
#line 208
      cursor = bucket;
#line 211
      n_buckets_used ++;
#line 212
      n_entries ++;
#line 215
      while (1) {
#line 215
        cursor = (struct hash_entry  const  *)cursor->next;
#line 215
        if (! cursor) {
#line 215
          break;
        }
#line 216
        n_entries ++;
      }
    }
#line 204
    bucket ++;
  }
#line 220
  if (n_buckets_used == (unsigned int )table___0->n_buckets_used && n_entries == (unsigned int )table___0->n_entries) {
#line 221
    return ((_Bool)1);
  }
#line 223
  return ((_Bool)0);
}
}
#line 226 "hash.c"
void hash_print_statistics(Hash_table const   *table___0 , FILE *stream ) 
{ size_t n_entries ;
  size_t __cil_tmp ;
  size_t n_buckets ;
  size_t __cil_tmp___0 ;
  size_t n_buckets_used ;
  size_t __cil_tmp___1 ;
  size_t max_bucket_length ;
  size_t __cil_tmp___2 ;

  {
#line 229
  __cil_tmp = hash_get_n_entries(table___0);
#line 229
  n_entries = __cil_tmp;
#line 230
  __cil_tmp___0 = hash_get_n_buckets(table___0);
#line 230
  n_buckets = __cil_tmp___0;
#line 231
  __cil_tmp___1 = hash_get_n_buckets_used(table___0);
#line 231
  n_buckets_used = __cil_tmp___1;
#line 232
  __cil_tmp___2 = hash_get_max_bucket_length(table___0);
#line 232
  max_bucket_length = __cil_tmp___2;
#line 234
  fprintf(stream, "# entries:         %lu\n", (unsigned long )n_entries);
#line 235
  fprintf(stream, "# buckets:         %lu\n", (unsigned long )n_buckets);
#line 236
  fprintf(stream, "# buckets used:    %lu (%.2f%%)\n", (unsigned long )n_buckets_used,
          (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 239
  fprintf(stream, "max bucket length: %lu\n", (unsigned long )max_bucket_length);
#line 241
  return;
}
}
#line 246 "hash.c"
void *hash_lookup(Hash_table const   *table___0 , void const   *entry ) 
{ struct hash_entry  const  *bucket ;
  size_t __cil_tmp ;
  struct hash_entry  const  *cursor ;
  _Bool __cil_tmp___0 ;

  {
#line 249
  __cil_tmp = (*(table___0->hasher))(entry, (unsigned int )table___0->n_buckets);
#line 249
  bucket = (struct hash_entry  const  *)(table___0->bucket + __cil_tmp);
#line 253
  if (! ((unsigned int )bucket < (unsigned int )table___0->bucket_limit)) {
#line 254
    abort();
  }
#line 256
  if ((unsigned int )bucket->data == (unsigned int )((void *)0)) {
#line 257
    return ((void *)0);
  }
#line 259
  cursor = bucket;
#line 259
  while (cursor) {
#line 260
    __cil_tmp___0 = (*(table___0->comparator))(entry, (void const   *)cursor->data);
#line 260
    if (__cil_tmp___0) {
#line 261
      return ((void *)cursor->data);
    }
#line 259
    cursor = (struct hash_entry  const  *)cursor->next;
  }
#line 263
  return ((void *)0);
}
}
#line 275 "hash.c"
void *hash_get_first(Hash_table const   *table___0 ) 
{ struct hash_entry  const  *bucket ;

  {
#line 280
  if (table___0->n_entries == 0U) {
#line 281
    return ((void *)0);
  }
#line 283
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 283
  while (1) {
#line 284
    if (! ((unsigned int )bucket < (unsigned int )table___0->bucket_limit)) {
#line 285
      abort();
    } else
#line 286
    if (bucket->data) {
#line 287
      return ((void *)bucket->data);
    }
#line 283
    bucket ++;
  }
}
}
#line 294 "hash.c"
void *hash_get_next(Hash_table const   *table___0 , void const   *entry ) 
{ struct hash_entry  const  *bucket ;
  size_t __cil_tmp ;
  struct hash_entry  const  *cursor ;

  {
#line 297
  __cil_tmp = (*(table___0->hasher))(entry, (unsigned int )table___0->n_buckets);
#line 297
  bucket = (struct hash_entry  const  *)(table___0->bucket + __cil_tmp);
#line 301
  if (! ((unsigned int )bucket < (unsigned int )table___0->bucket_limit)) {
#line 302
    abort();
  }
#line 305
  cursor = bucket;
#line 305
  while (cursor) {
#line 306
    if ((unsigned int )cursor->data == (unsigned int )entry && cursor->next) {
#line 307
      return ((cursor->next)->data);
    }
#line 305
    cursor = (struct hash_entry  const  *)cursor->next;
  }
#line 310
  while (1) {
#line 310
    bucket ++;
#line 310
    if (! ((unsigned int )bucket < (unsigned int )table___0->bucket_limit)) {
#line 310
      break;
    }
#line 311
    if (bucket->data) {
#line 312
      return ((void *)bucket->data);
    }
  }
#line 315
  return ((void *)0);
}
}
#line 322 "hash.c"
size_t hash_get_entries(Hash_table const   *table___0 , void **buffer , size_t buffer_size ) 
{ size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t __cil_tmp ;

  {
#line 326
  counter = 0U;
#line 330
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 330
  while ((unsigned int )bucket < (unsigned int )table___0->bucket_limit) {
#line 332
    if (bucket->data) {
#line 334
      cursor = bucket;
#line 334
      while (cursor) {
#line 336
        if (counter >= buffer_size) {
#line 337
          return (counter);
        }
#line 338
        __cil_tmp = counter;
#line 338
        counter ++;
#line 338
        *(buffer + __cil_tmp) = (void *)cursor->data;
#line 334
        cursor = (struct hash_entry  const  *)cursor->next;
      }
    }
#line 330
    bucket ++;
  }
#line 343
  return (counter);
}
}
#line 354 "hash.c"
size_t hash_do_for_each(Hash_table const   *table___0 , _Bool (*processor)(void * ,
                                                                           void * ) ,
                        void *processor_data ) 
{ size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool __cil_tmp ;

  {
#line 358
  counter = 0U;
#line 362
  bucket = (struct hash_entry  const  *)table___0->bucket;
#line 362
  while ((unsigned int )bucket < (unsigned int )table___0->bucket_limit) {
#line 364
    if (bucket->data) {
#line 366
      cursor = bucket;
#line 366
      while (cursor) {
#line 368
        __cil_tmp = (*processor)((void *)cursor->data, processor_data);
#line 368
        if (! __cil_tmp) {
#line 369
          return (counter);
        }
#line 370
        counter ++;
#line 366
        cursor = (struct hash_entry  const  *)cursor->next;
      }
    }
#line 362
    bucket ++;
  }
#line 375
  return (counter);
}
}
#line 417 "hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ size_t value ;
  unsigned char ch ;

  {
#line 420
  value = 0U;
#line 423
  while (1) {
#line 423
    ch = (unsigned char )*string;
#line 423
    if (! ch) {
#line 423
      break;
    }
#line 424
    value = (value * 31U + (unsigned int )ch) % n_buckets;
#line 423
    string ++;
  }
#line 425
  return (value);
}
}
#line 433 "hash.c"
static _Bool is_prime(size_t candidate ) 
{ size_t divisor ;
  size_t square ;

  {
#line 436
  divisor = 3U;
#line 437
  square = divisor * divisor;
#line 439
  while (square < candidate && candidate % divisor) {
#line 441
    divisor ++;
#line 442
    square += 4U * divisor;
#line 443
    divisor ++;
  }
#line 446
  return ((_Bool )(candidate % divisor ? 1 : 0));
}
}
#line 452 "hash.c"
static size_t next_prime(size_t candidate ) 
{ _Bool __cil_tmp ;

  {
#line 456
  if (candidate < 10U) {
#line 457
    candidate = 10U;
  }
#line 460
  candidate |= 1U;
#line 462
  while (1) {
#line 462
    __cil_tmp = is_prime(candidate);
#line 462
    if (__cil_tmp) {
#line 462
      break;
    }
#line 463
    candidate += 2U;
  }
#line 465
  return (candidate);
}
}
#line 468 "hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 

  {
#line 471
  *tuning = (struct hash_tuning )default_tuning;
#line 472
  return;
}
}
#line 480 "hash.c"
static _Bool check_tuning(Hash_table *table___0 ) 
{ Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 483
  tuning = table___0->tuning;
#line 490
  epsilon = 0.1f;
#line 492
  if ((((((epsilon < (float )tuning->growth_threshold && tuning->growth_threshold < (float const   )((float )1 - epsilon)) && (float )1 + epsilon < (float )tuning->growth_factor) && (float const   )0 <= tuning->shrink_threshold) && tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) && tuning->shrink_factor <= (float const   )1) && tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 499
    return ((_Bool)1);
  }
#line 501
  table___0->tuning = & default_tuning;
#line 502
  return ((_Bool)0);
}
}
#line 536 "hash.c"
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) 
{ Hash_table *table___0 ;
  void *__cil_tmp ;
  _Bool __cil_tmp___0 ;
  float new_candidate ;
  void *__cil_tmp___1 ;

  {
#line 543
  if ((unsigned int )hasher == (unsigned int )((void *)0) || (unsigned int )comparator == (unsigned int )((void *)0)) {
#line 544
    return ((Hash_table *)((void *)0));
  }
#line 546
  __cil_tmp = rpl_malloc(sizeof(*table___0));
#line 546
  table___0 = (Hash_table *)__cil_tmp;
#line 547
  if ((unsigned int )table___0 == (unsigned int )((void *)0)) {
#line 548
    return ((Hash_table *)((void *)0));
  }
#line 550
  if (! tuning) {
#line 551
    tuning = & default_tuning;
  }
#line 552
  table___0->tuning = tuning;
#line 553
  __cil_tmp___0 = check_tuning(table___0);
#line 553
  if (! __cil_tmp___0) {
#line 560
    goto fail;
  }
#line 563
  if (! tuning->is_n_buckets) {
#line 565
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 566
    if ((float )4294967295U <= new_candidate) {
#line 567
      goto fail;
    }
#line 568
    candidate = (unsigned int )new_candidate;
  }
#line 571
  if ((unsigned int )(sizeof(ptrdiff_t ) <= sizeof(size_t ) ? -1 : -2) / sizeof(*(table___0->bucket)) < candidate) {
#line 572
    goto fail;
  }
#line 573
  table___0->n_buckets = next_prime(candidate);
#line 574
  if ((unsigned int )(sizeof(ptrdiff_t ) <= sizeof(size_t ) ? -1 : -2) / sizeof(*(table___0->bucket)) < table___0->n_buckets) {
#line 575
    goto fail;
  }
#line 577
  __cil_tmp___1 = rpl_calloc(table___0->n_buckets, sizeof(*(table___0->bucket)));
#line 577
  table___0->bucket = (struct hash_entry *)__cil_tmp___1;
#line 578
  if ((unsigned int )table___0->bucket == (unsigned int )((void *)0)) {
#line 579
    goto fail;
  }
#line 580
  table___0->bucket_limit = (struct hash_entry  const  *)(table___0->bucket + table___0->n_buckets);
#line 581
  table___0->n_buckets_used = 0U;
#line 582
  table___0->n_entries = 0U;
#line 584
  table___0->hasher = hasher;
#line 585
  table___0->comparator = comparator;
#line 586
  table___0->data_freer = data_freer;
#line 588
  table___0->free_entry_list = (struct hash_entry *)((void *)0);
#line 592
  return (table___0);
  fail: 
#line 595
  free((void *)table___0);
#line 596
  return ((Hash_table *)((void *)0));
}
}
#line 603 "hash.c"
void hash_clear(Hash_table *table___0 ) 
{ struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 608
  bucket = table___0->bucket;
#line 608
  while ((unsigned int )bucket < (unsigned int )table___0->bucket_limit) {
#line 610
    if (bucket->data) {
#line 616
      cursor = bucket->next;
#line 616
      while (cursor) {
#line 618
        if (table___0->data_freer) {
#line 619
          (*(table___0->data_freer))(cursor->data);
        }
#line 620
        cursor->data = (void *)0;
#line 622
        next = cursor->next;
#line 625
        cursor->next = table___0->free_entry_list;
#line 626
        table___0->free_entry_list = cursor;
#line 616
        cursor = next;
      }
#line 630
      if (table___0->data_freer) {
#line 631
        (*(table___0->data_freer))(bucket->data);
      }
#line 632
      bucket->data = (void *)0;
#line 633
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 608
    bucket ++;
  }
#line 637
  table___0->n_buckets_used = 0U;
#line 638
  table___0->n_entries = 0U;
#line 639
  return;
}
}
#line 646 "hash.c"
void hash_free(Hash_table *table___0 ) 
{ struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 654
  if (table___0->data_freer && table___0->n_entries) {
#line 656
    bucket = table___0->bucket;
#line 656
    while ((unsigned int )bucket < (unsigned int )table___0->bucket_limit) {
#line 658
      if (bucket->data) {
#line 660
        cursor = bucket;
#line 660
        while (cursor) {
#line 662
          (*(table___0->data_freer))(cursor->data);
#line 660
          cursor = cursor->next;
        }
      }
#line 656
      bucket ++;
    }
  }
#line 675
  bucket = table___0->bucket;
#line 675
  while ((unsigned int )bucket < (unsigned int )table___0->bucket_limit) {
#line 677
    cursor = bucket->next;
#line 677
    while (cursor) {
#line 679
      next = cursor->next;
#line 680
      free((void *)cursor);
#line 677
      cursor = next;
    }
#line 675
    bucket ++;
  }
#line 685
  cursor = table___0->free_entry_list;
#line 685
  while (cursor) {
#line 687
    next = cursor->next;
#line 688
    free((void *)cursor);
#line 685
    cursor = next;
  }
#line 694
  free((void *)table___0->bucket);
#line 695
  free((void *)table___0);
#line 696
  return;
}
}
#line 703 "hash.c"
static struct hash_entry *allocate_entry(Hash_table *table___0 ) 
{ struct hash_entry *new ;
  void *__cil_tmp ;

  {
#line 708
  if (table___0->free_entry_list) {
#line 710
    new = table___0->free_entry_list;
#line 711
    table___0->free_entry_list = new->next;
  } else {
#line 718
    __cil_tmp = rpl_malloc(sizeof(*new));
#line 718
    new = (struct hash_entry *)__cil_tmp;
  }
#line 722
  return (new);
}
}
#line 728 "hash.c"
static void free_entry(Hash_table *table___0 , struct hash_entry *entry ) 
{ 

  {
#line 731
  entry->data = (void *)0;
#line 732
  entry->next = table___0->free_entry_list;
#line 733
  table___0->free_entry_list = entry;
#line 734
  return;
}
}
#line 742 "hash.c"
static void *hash_find_entry(Hash_table *table___0 , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ struct hash_entry *bucket ;
  size_t __cil_tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool __cil_tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool __cil_tmp___1 ;

  {
#line 746
  __cil_tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
#line 746
  bucket = table___0->bucket + __cil_tmp;
#line 750
  if (! ((unsigned int )bucket < (unsigned int )table___0->bucket_limit)) {
#line 751
    abort();
  }
#line 753
  *bucket_head = bucket;
#line 756
  if ((unsigned int )bucket->data == (unsigned int )((void *)0)) {
#line 757
    return ((void *)0);
  }
#line 760
  __cil_tmp___0 = (*(table___0->comparator))(entry, (void const   *)bucket->data);
#line 760
  if (__cil_tmp___0) {
#line 762
    data = bucket->data;
#line 764
    if (delete) {
#line 766
      if (bucket->next) {
#line 768
        next = bucket->next;
#line 772
        *bucket = *next;
#line 773
        free_entry(table___0, next);
      } else {
#line 777
        bucket->data = (void *)0;
      }
    }
#line 781
    return (data);
  }
#line 785
  cursor = bucket;
#line 785
  while (cursor->next) {
#line 787
    __cil_tmp___1 = (*(table___0->comparator))(entry, (void const   *)(cursor->next)->data);
#line 787
    if (__cil_tmp___1) {
#line 789
      data___0 = (cursor->next)->data;
#line 791
      if (delete) {
#line 793
        next___0 = cursor->next;
#line 797
        cursor->next = next___0->next;
#line 798
        free_entry(table___0, next___0);
      }
#line 801
      return (data___0);
    }
#line 785
    cursor = cursor->next;
  }
#line 806
  return ((void *)0);
}
}
#line 817 "hash.c"
_Bool hash_rehash(Hash_table *table___0 , size_t candidate ) 
{ Hash_table *new_table ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  size_t __cil_tmp ;
  struct hash_entry *new_entry ;
  struct hash_entry *__cil_tmp___0 ;

  {
#line 825
  new_table = hash_initialize(candidate, table___0->tuning, table___0->hasher, table___0->comparator,
                              table___0->data_freer);
#line 827
  if ((unsigned int )new_table == (unsigned int )((void *)0)) {
#line 828
    return ((_Bool)0);
  }
#line 835
  new_table->free_entry_list = table___0->free_entry_list;
#line 837
  bucket = table___0->bucket;
#line 837
  while ((unsigned int )bucket < (unsigned int )table___0->bucket_limit) {
#line 838
    if (bucket->data) {
#line 839
      cursor = bucket;
#line 839
      while (cursor) {
#line 841
        data = cursor->data;
#line 842
        __cil_tmp = (*(new_table->hasher))((void const   *)data, new_table->n_buckets);
#line 842
        new_bucket = new_table->bucket + __cil_tmp;
#line 846
        if (! ((unsigned int )new_bucket < (unsigned int )new_table->bucket_limit)) {
#line 847
          abort();
        }
#line 849
        next = cursor->next;
#line 851
        if (new_bucket->data) {
#line 853
          if ((unsigned int )cursor == (unsigned int )bucket) {
#line 857
            __cil_tmp___0 = allocate_entry(new_table);
#line 857
            new_entry = __cil_tmp___0;
#line 859
            if ((unsigned int )new_entry == (unsigned int )((void *)0)) {
#line 860
              return ((_Bool)0);
            }
#line 862
            new_entry->data = data;
#line 863
            new_entry->next = new_bucket->next;
#line 864
            new_bucket->next = new_entry;
          } else {
#line 870
            cursor->next = new_bucket->next;
#line 871
            new_bucket->next = cursor;
          }
        } else {
#line 880
          new_bucket->data = data;
#line 881
          (new_table->n_buckets_used) ++;
#line 882
          if ((unsigned int )cursor != (unsigned int )bucket) {
#line 883
            free_entry(new_table, cursor);
          }
        }
#line 839
        cursor = next;
      }
    }
#line 837
    bucket ++;
  }
#line 887
  free((void *)table___0->bucket);
#line 888
  table___0->bucket = new_table->bucket;
#line 889
  table___0->bucket_limit = new_table->bucket_limit;
#line 890
  table___0->n_buckets = new_table->n_buckets;
#line 891
  table___0->n_buckets_used = new_table->n_buckets_used;
#line 892
  table___0->free_entry_list = new_table->free_entry_list;
#line 897
  free((void *)new_table);
#line 899
  return ((_Bool)1);
}
}
#line 906 "hash.c"
void *hash_insert(Hash_table *table___0 , void const   *entry ) 
{ void *data ;
  struct hash_entry *bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *__cil_tmp ;
  Hash_tuning const   *tuning ;
  float candidate ;
  _Bool __cil_tmp___0 ;

  {
#line 913
  if (! entry) {
#line 914
    abort();
  }
#line 917
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)0);
#line 917
  if ((unsigned int )data != (unsigned int )((void *)0)) {
#line 918
    return (data);
  }
#line 922
  if (bucket->data) {
#line 924
    __cil_tmp = allocate_entry(table___0);
#line 924
    new_entry = __cil_tmp;
#line 926
    if ((unsigned int )new_entry == (unsigned int )((void *)0)) {
#line 927
      return ((void *)0);
    }
#line 931
    new_entry->data = (void *)entry;
#line 932
    new_entry->next = bucket->next;
#line 933
    bucket->next = new_entry;
#line 934
    (table___0->n_entries) ++;
#line 935
    return ((void *)entry);
  }
#line 940
  bucket->data = (void *)entry;
#line 941
  (table___0->n_entries) ++;
#line 942
  (table___0->n_buckets_used) ++;
#line 949
  if ((float const   )table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const   )table___0->n_buckets) {
#line 954
    check_tuning(table___0);
#line 955
    if ((float const   )table___0->n_buckets_used > (table___0->tuning)->growth_threshold * (float const   )table___0->n_buckets) {
#line 958
      tuning = table___0->tuning;
#line 959
      candidate = (float )(tuning->is_n_buckets ? (float const   )table___0->n_buckets * tuning->growth_factor : ((float const   )table___0->n_buckets * tuning->growth_factor) * tuning->growth_threshold);
#line 965
      if ((float )4294967295U <= candidate) {
#line 966
        return ((void *)0);
      }
#line 969
      __cil_tmp___0 = hash_rehash(table___0, (unsigned int )candidate);
#line 969
      if (! __cil_tmp___0) {
#line 970
        entry = (void const   *)((void *)0);
      }
    }
  }
#line 974
  return ((void *)entry);
}
}
#line 981 "hash.c"
void *hash_delete(Hash_table *table___0 , void const   *entry ) 
{ void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;

  {
#line 987
  data = hash_find_entry(table___0, entry, & bucket, (_Bool)1);
#line 988
  if (! data) {
#line 989
    return ((void *)0);
  }
#line 991
  (table___0->n_entries) --;
#line 992
  if (! bucket->data) {
#line 994
    (table___0->n_buckets_used) --;
#line 999
    if ((float const   )table___0->n_buckets_used < (table___0->tuning)->shrink_threshold * (float const   )table___0->n_buckets) {
#line 1004
      check_tuning(table___0);
#line 1005
      if ((float const   )table___0->n_buckets_used < (table___0->tuning)->shrink_threshold * (float const   )table___0->n_buckets) {
#line 1008
        tuning = table___0->tuning;
#line 1009
        candidate = (unsigned int )(tuning->is_n_buckets ? (float const   )table___0->n_buckets * tuning->shrink_factor : ((float const   )table___0->n_buckets * tuning->shrink_factor) * tuning->growth_threshold);
#line 1015
        hash_rehash(table___0, candidate);
      }
    }
  }
#line 1020
  return (data);
}
}
#line 1 "human.o"
#pragma merger(0,"/tmp/cil-WCCZoQ73.i","-g,-O2")
#line 80 "human.h"
char *human_readable(unsigned long long n , char *buf___0 , int opts , unsigned long long from_block_size ,
                     unsigned long long to_block_size ) ;
#line 82
enum strtol_error human_options(char const   *spec , int *opts , unsigned long long *block_size ) ;
#line 56 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/locale.h"
extern struct lconv *localeconv(void) ;
#line 37 "human.c"
static char const   power_letter[9]  = 
#line 37 "human.c"
  {      (char const   )0,      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'P',      (char const   )'E',      (char const   )'Z', 
        (char const   )'Y'};
#line 54 "human.c"
static long double adjust_value(int inexact_style , long double value ) 
{ unsigned long long u ;

  {
#line 61
  if (inexact_style != 1 && value < (long double )0xffffffffffffffffULL) {
#line 63
    u = (unsigned long long )value;
#line 64
    value = (long double )(u + (unsigned long long )(inexact_style == 0 && (long double )u != value));
  }
#line 67
  return (value);
}
}
#line 79 "human.c"
static char *group_number(char *number , size_t numberlen , char const   *grouping ,
                          char const   *thousands_sep ) 
{ register char *d ;
  size_t grouplen ;
  size_t thousands_seplen ;
  size_t __cil_tmp ;
  size_t i ;
  char buf___0[2U * ((((sizeof(unsigned long long ) * 8U - 1U) * 146U) / 485U + 1U) + 1U) + 1U] ;
  unsigned char g ;

  {
#line 84
  grouplen = ((1U << 31) - 1U) * 2U + 1U;
#line 85
  __cil_tmp = strlen(thousands_sep);
#line 85
  thousands_seplen = __cil_tmp;
#line 86
  i = numberlen;
#line 92
  memcpy((void *)(buf___0), (void const   *)number, numberlen);
#line 93
  d = number + numberlen;
#line 95
  while (1) {
#line 97
    g = (unsigned char )*grouping;
#line 99
    if (g) {
#line 101
      grouplen = (int )g < 127 ? (unsigned int )g : i;
#line 102
      grouping ++;
    }
#line 105
    if (i < grouplen) {
#line 106
      grouplen = i;
    }
#line 108
    d -= grouplen;
#line 109
    i -= grouplen;
#line 110
    memcpy((void *)d, (void const   *)(buf___0 + i), grouplen);
#line 111
    if (i == 0U) {
#line 112
      return (d);
    }
#line 114
    d -= thousands_seplen;
#line 115
    memcpy((void *)d, (void const   *)thousands_sep, thousands_seplen);
  }
}
}
#line 153 "human.c"
char *human_readable(unsigned long long n , char *buf___0 , int opts , unsigned long long from_block_size ,
                     unsigned long long to_block_size ) 
{ int inexact_style ;
  unsigned int base ;
  unsigned long long amt ;
  int tenths ;
  int exponent ;
  int exponent_max ;
  char *p ;
  char *psuffix ;
  char const   *integerlim ;
  int rounding ;
  char const   *decimal_point ;
  size_t decimal_pointlen ;
  char const   *grouping ;
  char const   *thousands_sep ;
  struct lconv  const  *l ;
  struct lconv *__cil_tmp ;
  size_t pointlen ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  unsigned long long multiplier ;
  unsigned long long divisor ;
  unsigned long long r10 ;
  unsigned long long r2 ;
  long double dto_block_size ;
  long double damt ;
  size_t buflen ;
  size_t nonintegerlen ;
  long double __cil_tmp___2 ;
  long double e ;
  long double __cil_tmp___3 ;
  long double __cil_tmp___4 ;
  unsigned int r10___0 ;
  unsigned int r2___0 ;
  int digit ;
  unsigned long long power ;
  char *__cil_tmp___5 ;
  char *__cil_tmp___6 ;
  char *__cil_tmp___7 ;
  char *__cil_tmp___8 ;

  {
#line 157
  inexact_style = opts & 3;
#line 159
  base = (unsigned int )(opts & 32 ? 1024 : 1000);
#line 162
  exponent = -1;
#line 163
  exponent_max = (int )(sizeof(power_letter) - 1U);
#line 174
  decimal_point = ".";
#line 175
  decimal_pointlen = 1U;
#line 176
  grouping = "";
#line 177
  thousands_sep = "";
#line 178
  __cil_tmp = localeconv();
#line 178
  l = (struct lconv  const  *)__cil_tmp;
#line 179
  __cil_tmp___0 = strlen((char const   *)l->decimal_point);
#line 179
  pointlen = __cil_tmp___0;
#line 180
  if (0U < pointlen && pointlen <= 1U) {
#line 182
    decimal_point = (char const   *)l->decimal_point;
#line 183
    decimal_pointlen = pointlen;
  }
#line 185
  grouping = (char const   *)l->grouping;
#line 186
  __cil_tmp___1 = strlen((char const   *)l->thousands_sep);
#line 186
  if (__cil_tmp___1 <= 1U) {
#line 187
    thousands_sep = (char const   *)l->thousands_sep;
  }
#line 189
  psuffix = (buf___0 + (((((((2U * sizeof(unsigned long long )) * 8U) * 146U) / 485U + 1U) * 2U - 1U) + 1U) + 3U)) - 3;
#line 190
  p = psuffix;
#line 195
  if (to_block_size <= from_block_size) {
#line 197
    if (from_block_size % to_block_size == 0ULL) {
#line 199
      multiplier = from_block_size / to_block_size;
#line 200
      amt = n * multiplier;
#line 201
      if (amt / multiplier == n) {
#line 203
        tenths = 0;
#line 204
        rounding = 0;
#line 205
        goto use_integer_arithmetic;
      }
    }
  } else
#line 209
  if (from_block_size != 0ULL && to_block_size % from_block_size == 0ULL) {
#line 211
    divisor = to_block_size / from_block_size;
#line 212
    r10 = (n % divisor) * 10ULL;
#line 213
    r2 = (r10 % divisor) * 2ULL;
#line 214
    amt = n / divisor;
#line 215
    tenths = (int )(r10 / divisor);
#line 216
    rounding = r2 < divisor ? 0ULL < r2 : 2 + (divisor < r2);
#line 217
    goto use_integer_arithmetic;
  }
#line 225
  dto_block_size = (long double )to_block_size;
#line 226
  damt = (long double )n * ((long double )from_block_size / dto_block_size);
#line 230
  if (! (opts & 16)) {
#line 232
    __cil_tmp___2 = adjust_value(inexact_style, damt);
#line 232
    sprintf(buf___0, "%.0Lf", __cil_tmp___2);
#line 233
    buflen = strlen((char const   *)buf___0);
#line 234
    nonintegerlen = 0U;
  } else {
#line 238
    e = (long double )1;
#line 239
    exponent = 0;
#line 241
    while (1) {
#line 243
      e *= (long double )base;
#line 244
      exponent ++;
#line 241
      if (! (e * (long double )base <= damt && exponent < exponent_max)) {
#line 241
        break;
      }
    }
#line 248
    damt /= e;
#line 250
    __cil_tmp___3 = adjust_value(inexact_style, damt);
#line 250
    sprintf(buf___0, "%.1Lf", __cil_tmp___3);
#line 251
    buflen = strlen((char const   *)buf___0);
#line 252
    nonintegerlen = decimal_pointlen + 1U;
#line 254
    if ((1U + nonintegerlen) + (unsigned int )(! (opts & 32)) < buflen || (opts & 8 && (int )*(buf___0 + (buflen - 1U)) == 48)) {
#line 258
      __cil_tmp___4 = adjust_value(inexact_style, damt * (long double )10);
#line 258
      sprintf(buf___0, "%.0Lf", __cil_tmp___4 / (long double )10);
#line 260
      buflen = strlen((char const   *)buf___0);
#line 261
      nonintegerlen = 0U;
    }
  }
#line 265
  p = psuffix - buflen;
#line 266
  memmove((void *)p, (void const   *)buf___0, buflen);
#line 267
  integerlim = (char const   *)((p + buflen) - nonintegerlen);
#line 269
  goto do_grouping;
  use_integer_arithmetic: 
#line 278
  if (opts & 16) {
#line 280
    exponent = 0;
#line 282
    if ((unsigned long long )base <= amt) {
#line 284
      while (1) {
#line 286
        r10___0 = (unsigned int )((amt % (unsigned long long )base) * 10ULL + (unsigned long long )tenths);
#line 287
        r2___0 = (r10___0 % base) * 2U + (unsigned int )(rounding >> 1);
#line 288
        amt /= (unsigned long long )base;
#line 289
        tenths = (int )(r10___0 / base);
#line 290
        rounding = r2___0 < base ? r2___0 + (unsigned int )rounding != 0U : 2 + (base < r2___0 + (unsigned int )rounding);
#line 293
        exponent ++;
#line 284
        if (! ((unsigned long long )base <= amt && exponent < exponent_max)) {
#line 284
          break;
        }
      }
#line 297
      if (amt < 10ULL) {
#line 299
        if (inexact_style == 1 ? 2 < rounding + (tenths & 1) : inexact_style == 0 && 0 < rounding) {
#line 303
          tenths ++;
#line 304
          rounding = 0;
#line 306
          if (tenths == 10) {
#line 308
            amt ++;
#line 309
            tenths = 0;
          }
        }
#line 313
        if (amt < 10ULL && (tenths || ! (opts & 8))) {
#line 316
          p --;
#line 316
          *p = (char )(48 + tenths);
#line 317
          p -= decimal_pointlen;
#line 318
          memcpy((void *)p, (void const   *)decimal_point, decimal_pointlen);
#line 319
          rounding = 0;
#line 319
          tenths = rounding;
        }
      }
    }
  }
#line 325
  if (inexact_style == 1 ? 5 < tenths + (0ULL < (unsigned long long )rounding + (amt & 1ULL)) : inexact_style == 0 && 0 < tenths + rounding) {
#line 329
    amt ++;
#line 331
    if ((opts & 16 && amt == (unsigned long long )base) && exponent < exponent_max) {
#line 334
      exponent ++;
#line 335
      if (! (opts & 8)) {
#line 337
        p --;
#line 337
        *p = (char )'0';
#line 338
        p -= decimal_pointlen;
#line 339
        memcpy((void *)p, (void const   *)decimal_point, decimal_pointlen);
      }
#line 341
      amt = 1ULL;
    }
  }
#line 345
  integerlim = (char const   *)p;
#line 347
  while (1) {
#line 349
    digit = (int )(amt % 10ULL);
#line 350
    p --;
#line 350
    *p = (char )(digit + 48);
#line 347
    amt /= 10ULL;
#line 347
    if (! (amt != 0ULL)) {
#line 347
      break;
    }
  }
  do_grouping: 
#line 356
  if (opts & 4) {
#line 357
    p = group_number(p, (unsigned int )(integerlim - (char const   *)p), grouping,
                     thousands_sep);
  }
#line 359
  if (opts & 128) {
#line 361
    if (exponent < 0) {
#line 364
      exponent = 0;
#line 365
      power = 1ULL;
#line 365
      while (power < to_block_size) {
#line 366
        exponent ++;
#line 366
        if (exponent == exponent_max) {
#line 367
          break;
        }
#line 365
        power *= (unsigned long long )base;
      }
    }
#line 370
    if (exponent | (opts & 256) && opts & 64) {
#line 371
      __cil_tmp___5 = psuffix;
#line 371
      psuffix ++;
#line 371
      *__cil_tmp___5 = (char )' ';
    }
#line 373
    if (exponent) {
#line 374
      __cil_tmp___6 = psuffix;
#line 374
      psuffix ++;
#line 374
      *__cil_tmp___6 = (char )(! (opts & 32) && exponent == 1 ? 'k' : (int )power_letter[exponent]);
    }
#line 378
    if (opts & 256) {
#line 380
      if (opts & 32 && exponent) {
#line 381
        __cil_tmp___7 = psuffix;
#line 381
        psuffix ++;
#line 381
        *__cil_tmp___7 = (char )'i';
      }
#line 382
      __cil_tmp___8 = psuffix;
#line 382
      psuffix ++;
#line 382
      *__cil_tmp___8 = (char )'B';
    }
  }
#line 386
  *psuffix = (char )'\000';
#line 388
  return (p);
}
}
#line 398 "human.c"
static char const   * const  block_size_args[3]  = {      (char const   * const  )"human-readable",      (char const   * const  )"si",      (char const   * const  )0};
#line 399 "human.c"
static int const   block_size_opts[2]  = {      (int const   )176,      (int const   )144};
#line 405 "human.c"
static unsigned long long default_block_size(void) 
{ char *__cil_tmp ;

  {
#line 408
  __cil_tmp = getenv("POSIXLY_CORRECT");
#line 408
  return ((unsigned long long )(__cil_tmp ? 512 : 1024));
}
}
#line 411 "human.c"
static strtol_error humblock(char const   *spec , unsigned long long *block_size ,
                             int *options ) 
{ int i ;
  int opts ;
  char *ptr ;
  strtol_error e ;
  strtol_error __cil_tmp ;
  ptrdiff_t __cil_tmp___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;

  {
#line 415
  opts = 0;
#line 417
  if (! spec) {
#line 417
    __cil_tmp___1 = getenv("BLOCK_SIZE");
#line 417
    spec = (char const   *)__cil_tmp___1;
#line 417
    if (spec) {
#line 417
      goto _L___0;
    } else {
#line 417
      __cil_tmp___2 = getenv("BLOCKSIZE");
#line 417
      spec = (char const   *)__cil_tmp___2;
#line 417
      if (spec) {
#line 417
        goto _L___0;
      } else {
#line 420
        *block_size = default_block_size();
      }
    }
  } else {
    _L___0: 
#line 423
    if ((int const   )*spec == 39) {
#line 425
      opts |= 4;
#line 426
      spec ++;
    }
#line 429
    __cil_tmp___0 = argmatch(spec, block_size_args, (char const   *)(block_size_opts),
                             sizeof(block_size_opts[0]));
#line 429
    i = (int )__cil_tmp___0;
#line 429
    if (0 <= i) {
#line 431
      opts |= (int )block_size_opts[i];
#line 432
      *block_size = 1ULL;
    } else {
#line 437
      __cil_tmp = xstrtoumax(spec, & ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
#line 437
      e = __cil_tmp;
#line 439
      if ((unsigned int )e != 0U) {
#line 441
        *options = 0;
#line 442
        return (e);
      }
#line 444
      while (! (48 <= (int )*spec && (int const   )*spec <= 57)) {
#line 445
        if ((unsigned int )spec == (unsigned int )ptr) {
#line 447
          opts |= 128;
#line 448
          if ((int )*(ptr + -1) == 66) {
#line 449
            opts |= 256;
          }
#line 450
          if ((int )*(ptr + -1) != 66 || (int )*(ptr + -2) == 105) {
#line 451
            opts |= 32;
          }
#line 452
          break;
        }
#line 444
        spec ++;
      }
    }
  }
#line 457
  *options = opts;
#line 458
  return ((enum strtol_error )0);
}
}
#line 461 "human.c"
enum strtol_error human_options(char const   *spec , int *opts , unsigned long long *block_size ) 
{ strtol_error e ;
  strtol_error __cil_tmp ;

  {
#line 464
  __cil_tmp = humblock(spec, block_size, opts);
#line 464
  e = __cil_tmp;
#line 465
  if (*block_size == 0ULL) {
#line 467
    *block_size = default_block_size();
#line 468
    e = (enum strtol_error )4;
  }
#line 470
  return (e);
}
}
#line 1 "i-ring.o"
#pragma merger(0,"/tmp/cil-eqtdrCFc.i","-g,-O2")
#line 24 "i-ring.c"
void i_ring_init(I_ring *ir , int default_val ) 
{ int i ;

  {
#line 28
  ir->ir_empty = (_Bool)1;
#line 29
  ir->ir_front = 0U;
#line 30
  ir->ir_back = 0U;
#line 31
  i = 0;
#line 31
  while (i < 4) {
#line 32
    ir->ir_data[i] = default_val;
#line 31
    i ++;
  }
#line 33
  ir->ir_default_val = default_val;
#line 34
  return;
}
}
#line 36 "i-ring.c"
_Bool i_ring_empty(I_ring const   *ir ) 
{ 

  {
#line 39
  return ((_Bool )ir->ir_empty);
}
}
#line 42 "i-ring.c"
int i_ring_push(I_ring *ir , int val ) 
{ unsigned int dest_idx ;
  int old_val ;

  {
#line 45
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
#line 46
  old_val = ir->ir_data[dest_idx];
#line 47
  ir->ir_data[dest_idx] = val;
#line 48
  ir->ir_front = dest_idx;
#line 49
  if (dest_idx == ir->ir_back) {
#line 50
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
#line 51
  ir->ir_empty = (_Bool)0;
#line 52
  return (old_val);
}
}
#line 55 "i-ring.c"
int i_ring_pop(I_ring *ir ) 
{ int top_val ;
  _Bool __cil_tmp ;

  {
#line 59
  __cil_tmp = i_ring_empty((I_ring const   *)ir);
#line 59
  if (__cil_tmp) {
#line 60
    abort();
  }
#line 61
  top_val = ir->ir_data[ir->ir_front];
#line 62
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
#line 63
  if (ir->ir_front == ir->ir_back) {
#line 64
    ir->ir_empty = (_Bool)1;
  } else {
#line 66
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
#line 67
  return (top_val);
}
}
#line 1 "idcache.o"
#pragma merger(0,"/tmp/cil-CfaBERxp.i","-g,-O2")
#line 6 "idcache.h"
char *getuser(uid_t uid ) ;
#line 7
char *getgroup(gid_t gid ) ;
#line 8
uid_t *getuidbyname(char const   *user ) ;
#line 9
gid_t *getgidbyname(char const   *group ) ;
#line 16 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/pwd.h"
extern struct passwd *getpwnam(char const   *name ) ;
#line 17
extern struct passwd *getpwuid(uid_t uid ) ;
#line 13 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/grp.h"
extern struct group *getgrgid(gid_t  ) ;
#line 14
extern struct group *getgrnam(char const   * ) ;
#line 54 "idcache.c"
static struct userid *user_alist  ;
#line 57 "idcache.c"
static struct userid *nouser_alist  ;
#line 60 "idcache.c"
static struct userid *group_alist  ;
#line 63 "idcache.c"
static struct userid *nogroup_alist  ;
#line 67 "idcache.c"
char *getuser(uid_t uid ) 
{ struct userid *tail ;
  struct userid *match ;
  struct passwd *pwent ;
  struct passwd *__cil_tmp ;
  char const   *name ;
  size_t __cil_tmp___0 ;
  void *__cil_tmp___1 ;

  {
#line 71
  match = (struct userid *)((void *)0);
#line 73
  tail = user_alist;
#line 73
  while (tail) {
#line 75
    if ((int )tail->id.u == (int )uid) {
#line 77
      match = tail;
#line 78
      break;
    }
#line 73
    tail = tail->next;
  }
#line 82
  if ((unsigned int )match == (unsigned int )((void *)0)) {
#line 84
    __cil_tmp = getpwuid(uid);
#line 84
    pwent = __cil_tmp;
#line 85
    name = pwent ? (char const   *)pwent->pw_name : "";
#line 86
    __cil_tmp___0 = strlen(name);
#line 86
    __cil_tmp___1 = xmalloc(((unsigned int )((char *)(& ((struct userid *)0)->name)) + __cil_tmp___0) + 1U);
#line 86
    match = (struct userid *)__cil_tmp___1;
#line 87
    match->id.u = uid;
#line 88
    strcpy(match->name, name);
#line 91
    match->next = user_alist;
#line 92
    user_alist = match;
  }
#line 95
  return (match->name[0] ? match->name : (char *)((void *)0));
}
}
#line 103 "idcache.c"
uid_t *getuidbyname(char const   *user ) 
{ struct userid *tail ;
  struct passwd *pwent ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  void *__cil_tmp___2 ;

  {
#line 109
  tail = user_alist;
#line 109
  while (tail) {
#line 111
    if ((int )tail->name[0] == (int )*user) {
#line 111
      __cil_tmp = strcmp((char const   *)(tail->name), user);
#line 111
      if (! __cil_tmp) {
#line 112
        return (& tail->id.u);
      }
    }
#line 109
    tail = tail->next;
  }
#line 114
  tail = nouser_alist;
#line 114
  while (tail) {
#line 116
    if ((int )tail->name[0] == (int )*user) {
#line 116
      __cil_tmp___0 = strcmp((char const   *)(tail->name), user);
#line 116
      if (! __cil_tmp___0) {
#line 117
        return ((uid_t *)((void *)0));
      }
    }
#line 114
    tail = tail->next;
  }
#line 119
  pwent = getpwnam(user);
#line 130
  __cil_tmp___1 = strlen(user);
#line 130
  __cil_tmp___2 = xmalloc(((unsigned int )((char *)(& ((struct userid *)0)->name)) + __cil_tmp___1) + 1U);
#line 130
  tail = (struct userid *)__cil_tmp___2;
#line 131
  strcpy(tail->name, user);
#line 134
  if (pwent) {
#line 136
    tail->id.u = pwent->pw_uid;
#line 137
    tail->next = user_alist;
#line 138
    user_alist = tail;
#line 139
    return (& tail->id.u);
  }
#line 142
  tail->next = nouser_alist;
#line 143
  nouser_alist = tail;
#line 144
  return ((uid_t *)((void *)0));
}
}
#line 149 "idcache.c"
char *getgroup(gid_t gid ) 
{ struct userid *tail ;
  struct userid *match ;
  struct group *grent ;
  struct group *__cil_tmp ;
  char const   *name ;
  size_t __cil_tmp___0 ;
  void *__cil_tmp___1 ;

  {
#line 153
  match = (struct userid *)((void *)0);
#line 155
  tail = group_alist;
#line 155
  while (tail) {
#line 157
    if ((int )tail->id.g == (int )gid) {
#line 159
      match = tail;
#line 160
      break;
    }
#line 155
    tail = tail->next;
  }
#line 164
  if ((unsigned int )match == (unsigned int )((void *)0)) {
#line 166
    __cil_tmp = getgrgid(gid);
#line 166
    grent = __cil_tmp;
#line 167
    name = grent ? (char const   *)grent->gr_name : "";
#line 168
    __cil_tmp___0 = strlen(name);
#line 168
    __cil_tmp___1 = xmalloc(((unsigned int )((char *)(& ((struct userid *)0)->name)) + __cil_tmp___0) + 1U);
#line 168
    match = (struct userid *)__cil_tmp___1;
#line 169
    match->id.g = gid;
#line 170
    strcpy(match->name, name);
#line 173
    match->next = group_alist;
#line 174
    group_alist = match;
  }
#line 177
  return (match->name[0] ? match->name : (char *)((void *)0));
}
}
#line 185 "idcache.c"
gid_t *getgidbyname(char const   *group ) 
{ struct userid *tail ;
  struct group *grent ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  void *__cil_tmp___2 ;

  {
#line 191
  tail = group_alist;
#line 191
  while (tail) {
#line 193
    if ((int )tail->name[0] == (int )*group) {
#line 193
      __cil_tmp = strcmp((char const   *)(tail->name), group);
#line 193
      if (! __cil_tmp) {
#line 194
        return (& tail->id.g);
      }
    }
#line 191
    tail = tail->next;
  }
#line 196
  tail = nogroup_alist;
#line 196
  while (tail) {
#line 198
    if ((int )tail->name[0] == (int )*group) {
#line 198
      __cil_tmp___0 = strcmp((char const   *)(tail->name), group);
#line 198
      if (! __cil_tmp___0) {
#line 199
        return ((gid_t *)((void *)0));
      }
    }
#line 196
    tail = tail->next;
  }
#line 201
  grent = getgrnam(group);
#line 212
  __cil_tmp___1 = strlen(group);
#line 212
  __cil_tmp___2 = xmalloc(((unsigned int )((char *)(& ((struct userid *)0)->name)) + __cil_tmp___1) + 1U);
#line 212
  tail = (struct userid *)__cil_tmp___2;
#line 213
  strcpy(tail->name, group);
#line 216
  if (grent) {
#line 218
    tail->id.g = grent->gr_gid;
#line 219
    tail->next = group_alist;
#line 220
    group_alist = tail;
#line 221
    return (& tail->id.g);
  }
#line 224
  tail->next = nogroup_alist;
#line 225
  nogroup_alist = tail;
#line 226
  return ((gid_t *)((void *)0));
}
}
#line 1 "imaxtostr.o"
#pragma merger(0,"/tmp/cil-qEHdnDX3.i","-g,-O2")
#line 27 "inttostr.h"
char *imaxtostr(long long i , char *buf___0 ) ;
#line 28 "inttostr.c"
char *imaxtostr(long long i , char *buf___0 ) 
{ char *p ;

  {
#line 31
  p = buf___0 + ((((sizeof(long long ) * 8U - 1U) * 146U) / 485U + 1U) + 1U);
#line 32
  *p = (char)0;
#line 34
  if (i < 0LL) {
#line 36
    while (1) {
#line 37
      p --;
#line 37
      *p = (char )(48LL - i % 10LL);
#line 36
      i /= 10LL;
#line 36
      if (! (i != 0LL)) {
#line 36
        break;
      }
    }
#line 40
    p --;
#line 40
    *p = (char )'-';
  } else {
#line 44
    while (1) {
#line 45
      p --;
#line 45
      *p = (char )(48LL + i % 10LL);
#line 44
      i /= 10LL;
#line 44
      if (! (i != 0LL)) {
#line 44
        break;
      }
    }
  }
#line 49
  return (p);
}
}
#line 1 "inet_ntop.o"
#pragma merger(0,"/tmp/cil-MP0UdQXj.i","-g,-O2")
#line 60 "inet_ntop.c"
static char const   *inet_ntop4(unsigned char const   *src , char *dst , socklen_t size ) ;
#line 62
static char const   *inet_ntop6(unsigned char const   *src , char *dst , socklen_t size ) ;
#line 74 "inet_ntop.c"
char const   *inet_ntop(int af , void const   * __restrict  src , char * __restrict  dst ,
                        socklen_t cnt ) 
{ char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 78
  switch (af) {
  case 2: 
#line 82
  __cil_tmp = inet_ntop4((unsigned char const   *)src, (char *)dst, cnt);
#line 82
  return (__cil_tmp);
  case 3: 
#line 87
  __cil_tmp___0 = inet_ntop6((unsigned char const   *)src, (char *)dst, cnt);
#line 87
  return (__cil_tmp___0);
  default: 
#line 91
  __cil_tmp___1 = __errno();
#line 91
  *__cil_tmp___1 = 106;
#line 92
  return ((char const   *)((void *)0));
  }
}
}
#line 108 "inet_ntop.c"
static char const   *inet_ntop4(unsigned char const   *src , char *dst , socklen_t size ) 
{ char tmp[sizeof("255.255.255.255")] ;
  int len ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 114
  len = sprintf(tmp, "%u.%u.%u.%u", (int const   )*(src + 0), (int const   )*(src + 1),
                (int const   )*(src + 2), (int const   )*(src + 3));
#line 115
  if (len < 0) {
#line 116
    return ((char const   *)((void *)0));
  }
#line 118
  if ((unsigned int )len > size) {
#line 120
    __cil_tmp = __errno();
#line 120
    *__cil_tmp = 28;
#line 121
    return ((char const   *)((void *)0));
  }
#line 124
  __cil_tmp___0 = strcpy(dst, (char const   *)(tmp));
#line 124
  return ((char const   *)__cil_tmp___0);
}
}
#line 135 "inet_ntop.c"
static char const   *inet_ntop6(unsigned char const   *src , char *dst , socklen_t size ) 
{ char tmp[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")] ;
  char *tp ;
  struct __anonstruct_best_9 best ;
  struct __anonstruct_best_9 cur ;
  unsigned int words[8] ;
  int i ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  size_t __cil_tmp___2 ;
  int len ;
  int __cil_tmp___3 ;
  char *__cil_tmp___4 ;
  char *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  char *__cil_tmp___7 ;

  {
#line 158
  memset((void *)(words), '\000', sizeof(words));
#line 159
  i = 0;
#line 159
  while (i < 16) {
#line 160
    words[i / 2] = (unsigned int )(((int const   )*(src + i) << 8) | (int const   )*(src + (i + 1)));
#line 159
    i += 2;
  }
#line 161
  best.base = -1;
#line 162
  cur.base = -1;
#line 163
  i = 0;
#line 163
  while (i < 8) {
#line 165
    if (words[i] == 0U) {
#line 167
      if (cur.base == -1) {
#line 168
        cur.base = i;
#line 168
        cur.len = 1;
      } else {
#line 170
        (cur.len) ++;
      }
    } else
#line 174
    if (cur.base != -1) {
#line 176
      if (best.base == -1 || cur.len > best.len) {
#line 177
        best = cur;
      }
#line 178
      cur.base = -1;
    }
#line 163
    i ++;
  }
#line 182
  if (cur.base != -1) {
#line 184
    if (best.base == -1 || cur.len > best.len) {
#line 185
      best = cur;
    }
  }
#line 187
  if (best.base != -1 && best.len < 2) {
#line 188
    best.base = -1;
  }
#line 193
  tp = tmp;
#line 194
  i = 0;
#line 194
  while (i < 8) {
#line 197
    if ((best.base != -1 && i >= best.base) && i < best.base + best.len) {
#line 199
      if (i == best.base) {
#line 200
        __cil_tmp = tp;
#line 200
        tp ++;
#line 200
        *__cil_tmp = (char )':';
      }
#line 201
      goto __Cont;
    }
#line 204
    if (i != 0) {
#line 205
      __cil_tmp___0 = tp;
#line 205
      tp ++;
#line 205
      *__cil_tmp___0 = (char )':';
    }
#line 207
    if ((i == 6 && best.base == 0) && (best.len == 6 || (best.len == 5 && words[5] == 65535U))) {
#line 210
      __cil_tmp___1 = inet_ntop4(src + 12, tp, sizeof(tmp) - (unsigned int )(tp - tmp));
#line 210
      if (! __cil_tmp___1) {
#line 211
        return ((char const   *)((void *)0));
      }
#line 212
      __cil_tmp___2 = strlen((char const   *)tp);
#line 212
      tp += __cil_tmp___2;
#line 213
      break;
    }
#line 216
    __cil_tmp___3 = sprintf(tp, "%x", words[i]);
#line 216
    len = __cil_tmp___3;
#line 217
    if (len < 0) {
#line 218
      return ((char const   *)((void *)0));
    }
#line 219
    tp += len;
    __Cont: 
#line 194
    i ++;
  }
#line 223
  if (best.base != -1 && best.base + best.len == 8) {
#line 225
    __cil_tmp___4 = tp;
#line 225
    tp ++;
#line 225
    *__cil_tmp___4 = (char )':';
  }
#line 226
  __cil_tmp___5 = tp;
#line 226
  tp ++;
#line 226
  *__cil_tmp___5 = (char )'\000';
#line 231
  if ((unsigned int )(tp - tmp) > size) {
#line 233
    __cil_tmp___6 = __errno();
#line 233
    *__cil_tmp___6 = 28;
#line 234
    return ((char const   *)((void *)0));
  }
#line 237
  __cil_tmp___7 = strcpy(dst, (char const   *)(tmp));
#line 237
  return ((char const   *)__cil_tmp___7);
}
}
#line 1 "isapipe.o"
#pragma merger(0,"/tmp/cil-jIt8a6jD.i","-g,-O2")
#line 6 "isapipe.h"
int isapipe(int fd ) ;
#line 132 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern int pipe(int *__fildes ) ;
#line 41 "isapipe.c"
int isapipe(int fd ) 
{ nlink_t pipe_link_count_max ;
  _Bool check_for_fifo ;
  struct stat st ;
  int fstat_result ;
  int __cil_tmp ;
  int fd_pair[2] ;
  int pipe_result ;
  int __cil_tmp___0 ;
  struct stat pipe_st ;
  int fstat_pipe_result ;
  int __cil_tmp___1 ;
  int fstat_pipe_errno ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;

  {
#line 44
  pipe_link_count_max = (unsigned short)65535;
#line 45
  check_for_fifo = (_Bool)0;
#line 47
  __cil_tmp = fstat(fd, & st);
#line 47
  fstat_result = __cil_tmp;
#line 49
  if (fstat_result != 0) {
#line 50
    return (fstat_result);
  }
#line 62
  if (((st.st_mode & 8323072U) == 262144U) | ((st.st_mode & 8323072U) == 4194304U)) {
#line 67
    __cil_tmp___0 = pipe(fd_pair);
#line 67
    pipe_result = __cil_tmp___0;
#line 68
    if (pipe_result != 0) {
#line 69
      return (pipe_result);
    } else {
#line 73
      __cil_tmp___1 = fstat(fd_pair[0], & pipe_st);
#line 73
      fstat_pipe_result = __cil_tmp___1;
#line 74
      __cil_tmp___2 = __errno();
#line 74
      fstat_pipe_errno = *__cil_tmp___2;
#line 75
      close(fd_pair[0]);
#line 76
      close(fd_pair[1]);
#line 77
      if (fstat_pipe_result != 0) {
#line 79
        __cil_tmp___3 = __errno();
#line 79
        *__cil_tmp___3 = fstat_pipe_errno;
#line 80
        return (fstat_pipe_result);
      }
#line 82
      check_for_fifo = (_Bool )(((pipe_st.st_mode & 8323072U) == 262144U) != 0);
#line 83
      pipe_link_count_max = pipe_st.st_nlink;
    }
  }
#line 87
  return ((int )st.st_nlink <= (int )pipe_link_count_max && (check_for_fifo ? (st.st_mode & 8323072U) == 262144U : (st.st_mode & 8323072U) == 4194304U));
}
}
#line 1 "isnan.o"
#pragma merger(0,"/tmp/cil-lfqrbhZW.i","-g,-O2")
#line 120 "isnan.c"
static memory_double nan  =    {0.0 / 0.0};
#line 121 "isnan.c"
static double plus_inf  =    1.0 / 0.0;
#line 122 "isnan.c"
static double minus_inf  =    - 1.0 / 0.0;
#line 70 "isnan.c"
int rpl_isnan(double x ) 
{ memory_double m ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 129
  m.value = x;
#line 130
  if (((m.word[1] ^ nan.word[1]) & (unsigned int )(2047 << 20)) == 0U) {
#line 133
    __cil_tmp = rpl_memcmp((void const   *)(& m.value), (void const   *)(& plus_inf),
                           8U);
#line 133
    if (__cil_tmp != 0) {
#line 133
      __cil_tmp___0 = rpl_memcmp((void const   *)(& m.value), (void const   *)(& minus_inf),
                                 8U);
#line 133
      if (__cil_tmp___0 != 0) {
#line 133
        __cil_tmp___1 = 1;
      } else {
#line 133
        __cil_tmp___1 = 0;
      }
    } else {
#line 133
      __cil_tmp___1 = 0;
    }
#line 133
    return (__cil_tmp___1);
  } else {
#line 136
    return (0);
  }
}
}
#line 1 "isnanf.o"
#pragma merger(0,"/tmp/cil-1x1ogkQu.i","-g,-O2")
#line 120 "isnan.c"
int rpl_isnanf(float x ) ;
#line 120 "isnan.c"
static memory_double___0 nan___0  =    {0.0f / 0.0f};
#line 121 "isnan.c"
static float plus_inf___0  =    1.0f / 0.0f;
#line 122 "isnan.c"
static float minus_inf___0  =    - 1.0f / 0.0f;
#line 70 "isnan.c"
int rpl_isnanf(float x ) 
{ memory_double___0 m ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 129
  m.value = x;
#line 130
  if (((m.word[0] ^ nan___0.word[0]) & (unsigned int )(255 << 23)) == 0U) {
#line 133
    __cil_tmp = rpl_memcmp((void const   *)(& m.value), (void const   *)(& plus_inf___0),
                           4U);
#line 133
    if (__cil_tmp != 0) {
#line 133
      __cil_tmp___0 = rpl_memcmp((void const   *)(& m.value), (void const   *)(& minus_inf___0),
                                 4U);
#line 133
      if (__cil_tmp___0 != 0) {
#line 133
        __cil_tmp___1 = 1;
      } else {
#line 133
        __cil_tmp___1 = 0;
      }
    } else {
#line 133
      __cil_tmp___1 = 0;
    }
#line 133
    return (__cil_tmp___1);
  } else {
#line 136
    return (0);
  }
}
}
#line 1 "isnanl.o"
#pragma merger(0,"/tmp/cil-toS0Prh6.i","-g,-O2")
#line 70 "isnan.c"
int rpl_isnanl(long double x ) 
{ 

  {
#line 142
  if (x == x) {
#line 156
    return (0);
  } else {
#line 159
    return (1);
  }
}
}
#line 1 "lchown.o"
#pragma merger(0,"/tmp/cil-2W0ydsKQ.i","-g,-O2")
#line 48 "lchown.c"
int rpl_lchown(char const   *file , uid_t uid , gid_t gid ) 
{ struct stat stats ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 54
  __cil_tmp___0 = lstat(file, & stats);
#line 54
  if (__cil_tmp___0 == 0 && (stats.st_mode & 8323072U) == 2097152U) {
#line 56
    __cil_tmp = __errno();
#line 56
    *__cil_tmp = 95;
#line 57
    return (-1);
  }
#line 61
  __cil_tmp___1 = rpl_chown(file, uid, gid);
#line 61
  return (__cil_tmp___1);
}
}
#line 1 "long-options.o"
#pragma merger(0,"/tmp/cil-DMxEHmJR.i","-g,-O2")
#line 19 "long-options.h"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) ;
#line 33 "long-options.c"
static struct option  const  long_options[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 43 "long-options.c"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) 
{ int c ;
  int saved_opterr ;
  va_list authors ;

  {
#line 55
  saved_opterr = rpl_opterr;
#line 58
  rpl_opterr = 0;
#line 60
  if (argc == 2) {
#line 60
    c = rpl_getopt_long(argc, argv, "+", long_options, (int *)((void *)0));
#line 60
    if (c != -1) {
#line 63
      switch (c) {
      case 104: 
#line 66
      (*usage_func)(0);
      case 118: 
#line 71
      __builtin_va_start(authors, usage_func);
#line 72
      version_etc_va(_impure_ptr->_stdout, command_name, package, version, authors);
#line 73
      exit(0);
      default: 
#line 78
      break;
      }
    }
  }
#line 83
  rpl_opterr = saved_opterr;
#line 87
  rpl_optind = 0;
#line 88
  return;
}
}
#line 1 "lstat.o"
#pragma merger(0,"/tmp/cil-hZXx6ZdN.i","-g,-O2")
#line 46 "lstat.c"
int rpl_lstat(char const   *file , struct stat *sbuf ) 
{ size_t len ;
  int lstat_result ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 50
  __cil_tmp = lstat(file, sbuf);
#line 50
  lstat_result = __cil_tmp;
#line 52
  if (lstat_result != 0 || ! ((sbuf->st_mode & 8323072U) == 2097152U)) {
#line 53
    return (lstat_result);
  }
#line 55
  len = strlen(file);
#line 56
  if (len == 0U || (int const   )*(file + (len - 1U)) != 47) {
#line 57
    return (0);
  }
#line 63
  __cil_tmp___0 = stat(file, sbuf);
#line 63
  if (__cil_tmp___0 != 0) {
#line 64
    return (-1);
  }
#line 67
  if ((sbuf->st_mode & 8323072U) == 1048576U) {
#line 68
    return (0);
  }
#line 73
  __cil_tmp___1 = __errno();
#line 73
  *__cil_tmp___1 = 20;
#line 74
  return (-1);
}
}
#line 1 "malloc.o"
#pragma merger(0,"/tmp/cil-tpO3J8Qx.i","-g,-O2")
#line 92 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern void *malloc(size_t __size ) ;
#line 41 "malloc.c"
void *rpl_malloc(size_t n ) 
{ void *result ;

  {
#line 47
  if (n == 0U) {
#line 48
    n = 1U;
  }
#line 51
  result = malloc(n);
#line 58
  return (result);
}
}
#line 1 "md5.o"
#pragma merger(0,"/tmp/cil-tBEO9XOF.i","-g,-O2")
#line 79 "md5.h"
void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 85
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 92
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) ;
#line 102
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 111
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 117
int md5_stream(FILE *stream , void *resblock ) ;
#line 123
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 68 "md5.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 73 "md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ unsigned int __cil_tmp ;

  {
#line 76
  ctx->A = 1732584193U;
#line 77
  ctx->B = 4023233417U;
#line 78
  ctx->C = 2562383102U;
#line 79
  ctx->D = 271733878U;
#line 81
  __cil_tmp = 0U;
#line 81
  ctx->total[1] = __cil_tmp;
#line 81
  ctx->total[0] = __cil_tmp;
#line 82
  ctx->buflen = 0U;
#line 83
  return;
}
}
#line 90 "md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 

  {
#line 93
  *((unsigned int *)resbuf + 0) = (unsigned int )ctx->A;
#line 94
  *((unsigned int *)resbuf + 1) = (unsigned int )ctx->B;
#line 95
  *((unsigned int *)resbuf + 2) = (unsigned int )ctx->C;
#line 96
  *((unsigned int *)resbuf + 3) = (unsigned int )ctx->D;
#line 98
  return (resbuf);
}
}
#line 106 "md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ unsigned int bytes ;
  size_t size ;
  void *__cil_tmp ;

  {
#line 110
  bytes = ctx->buflen;
#line 111
  size = (unsigned int )(bytes < 56U ? 16 : 32);
#line 114
  ctx->total[0] += bytes;
#line 115
  if (ctx->total[0] < bytes) {
#line 116
    (ctx->total[1]) ++;
  }
#line 119
  ctx->buffer[size - 2U] = ctx->total[0] << 3;
#line 120
  ctx->buffer[size - 1U] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 122
  memcpy((void *)((char *)(ctx->buffer) + bytes), (void const   *)(fillbuf), (size - 2U) * 4U - bytes);
#line 125
  md5_process_block((void const   *)(ctx->buffer), size * 4U, ctx);
#line 127
  __cil_tmp = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
#line 127
  return (__cil_tmp);
}
}
#line 133 "md5.c"
int md5_stream(FILE *stream , void *resblock ) 
{ struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 141
  md5_init_ctx(& ctx);
#line 144
  while (1) {
#line 150
    sum = 0U;
#line 153
    while (1) {
#line 155
      n = fread((void *)(buffer + sum), 1U, 4096U - sum, stream);
#line 157
      sum += n;
#line 159
      if (sum == 4096U) {
#line 160
        break;
      }
#line 162
      if (n == 0U) {
#line 167
        __cil_tmp = ferror(stream);
#line 167
        if (__cil_tmp) {
#line 168
          return (1);
        }
#line 169
        goto process_partial_block;
      }
#line 175
      __cil_tmp___0 = feof(stream);
#line 175
      if (__cil_tmp___0) {
#line 176
        goto process_partial_block;
      }
    }
#line 182
    md5_process_block((void const   *)(buffer), 4096U, & ctx);
  }
  process_partial_block: 
#line 188
  if (sum > 0U) {
#line 189
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
  }
#line 192
  md5_finish_ctx(& ctx, resblock);
#line 193
  return (0);
}
}
#line 200 "md5.c"
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct md5_ctx ctx ;
  void *__cil_tmp ;

  {
#line 206
  md5_init_ctx(& ctx);
#line 209
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 212
  __cil_tmp = md5_finish_ctx(& ctx, resblock);
#line 212
  return (__cil_tmp);
}
}
#line 216 "md5.c"
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  void *__cil_tmp ;
  size_t left_over___0 ;

  {
#line 221
  if (ctx->buflen != 0U) {
#line 223
    left_over = ctx->buflen;
#line 224
    add = 128U - left_over > len ? len : 128U - left_over;
#line 226
    memcpy((void *)((char *)(ctx->buffer) + left_over), buffer, add);
#line 227
    ctx->buflen += add;
#line 229
    if (ctx->buflen > 64U) {
#line 231
      md5_process_block((void const   *)(ctx->buffer), ctx->buflen & 4294967232U,
                        ctx);
#line 233
      ctx->buflen &= 63U;
#line 235
      memcpy((void *)(ctx->buffer), (void const   *)((char *)(ctx->buffer) + ((left_over + add) & 4294967232U)),
             ctx->buflen);
    }
#line 240
    buffer = (void const   *)((char const   *)buffer + add);
#line 241
    len -= add;
  }
#line 245
  if (len >= 64U) {
#line 250
    if ((unsigned int )buffer % (unsigned int )((char *)(& ((struct __anonstruct_12 *)0)->x)) != 0U) {
#line 251
      while (len > 64U) {
#line 253
        __cil_tmp = memcpy((void *)(ctx->buffer), buffer, 64U);
#line 253
        md5_process_block((void const   *)__cil_tmp, 64U, ctx);
#line 254
        buffer = (void const   *)((char const   *)buffer + 64);
#line 255
        len -= 64U;
      }
    } else {
#line 260
      md5_process_block(buffer, len & 4294967232U, ctx);
#line 261
      buffer = (void const   *)((char const   *)buffer + (len & 4294967232U));
#line 262
      len &= 63U;
    }
  }
#line 267
  if (len > 0U) {
#line 269
    left_over___0 = ctx->buflen;
#line 271
    memcpy((void *)((char *)(ctx->buffer) + left_over___0), buffer, len);
#line 272
    left_over___0 += len;
#line 273
    if (left_over___0 >= 64U) {
#line 275
      md5_process_block((void const   *)(ctx->buffer), 64U, ctx);
#line 276
      left_over___0 -= 64U;
#line 277
      memcpy((void *)(ctx->buffer), (void const   *)(& ctx->buffer[16]), left_over___0);
    }
#line 279
    ctx->buflen = left_over___0;
  }
#line 281
  return;
}
}
#line 296 "md5.c"
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ unsigned int correct_words[16] ;
  unsigned int const   *words ;
  size_t nwords ;
  unsigned int const   *endp ;
  unsigned int A ;
  unsigned int B ;
  unsigned int C ;
  unsigned int D ;
  unsigned int *cwp ;
  unsigned int A_save ;
  unsigned int B_save ;
  unsigned int C_save ;
  unsigned int D_save ;
  unsigned int *__cil_tmp ;
  unsigned int __cil_tmp___0 ;
  unsigned int *__cil_tmp___1 ;
  unsigned int __cil_tmp___2 ;
  unsigned int *__cil_tmp___3 ;
  unsigned int __cil_tmp___4 ;
  unsigned int *__cil_tmp___5 ;
  unsigned int __cil_tmp___6 ;
  unsigned int *__cil_tmp___7 ;
  unsigned int __cil_tmp___8 ;
  unsigned int *__cil_tmp___9 ;
  unsigned int __cil_tmp___10 ;
  unsigned int *__cil_tmp___11 ;
  unsigned int __cil_tmp___12 ;
  unsigned int *__cil_tmp___13 ;
  unsigned int __cil_tmp___14 ;
  unsigned int *__cil_tmp___15 ;
  unsigned int __cil_tmp___16 ;
  unsigned int *__cil_tmp___17 ;
  unsigned int __cil_tmp___18 ;
  unsigned int *__cil_tmp___19 ;
  unsigned int __cil_tmp___20 ;
  unsigned int *__cil_tmp___21 ;
  unsigned int __cil_tmp___22 ;
  unsigned int *__cil_tmp___23 ;
  unsigned int __cil_tmp___24 ;
  unsigned int *__cil_tmp___25 ;
  unsigned int __cil_tmp___26 ;
  unsigned int *__cil_tmp___27 ;
  unsigned int __cil_tmp___28 ;
  unsigned int *__cil_tmp___29 ;
  unsigned int __cil_tmp___30 ;

  {
#line 300
  words = (unsigned int const   *)buffer;
#line 301
  nwords = len / sizeof(unsigned int );
#line 302
  endp = words + nwords;
#line 303
  A = ctx->A;
#line 304
  B = ctx->B;
#line 305
  C = ctx->C;
#line 306
  D = ctx->D;
#line 311
  ctx->total[0] += len;
#line 312
  if (ctx->total[0] < len) {
#line 313
    (ctx->total[1]) ++;
  }
#line 317
  while ((unsigned int )words < (unsigned int )endp) {
#line 319
    cwp = correct_words;
#line 320
    A_save = A;
#line 321
    B_save = B;
#line 322
    C_save = C;
#line 323
    D_save = D;
#line 357
    while (1) {
#line 357
      __cil_tmp = cwp;
#line 357
      cwp ++;
#line 357
      __cil_tmp___0 = (unsigned int )*words;
#line 357
      *__cil_tmp = __cil_tmp___0;
#line 357
      A += ((D ^ (B & (C ^ D))) + __cil_tmp___0) + 3614090360U;
#line 357
      words ++;
#line 357
      A = (A << 7) | (A >> 25);
#line 357
      A += B;
#line 357
      break;
    }
#line 358
    while (1) {
#line 358
      __cil_tmp___1 = cwp;
#line 358
      cwp ++;
#line 358
      __cil_tmp___2 = (unsigned int )*words;
#line 358
      *__cil_tmp___1 = __cil_tmp___2;
#line 358
      D += ((C ^ (A & (B ^ C))) + __cil_tmp___2) + 3905402710U;
#line 358
      words ++;
#line 358
      D = (D << 12) | (D >> 20);
#line 358
      D += A;
#line 358
      break;
    }
#line 359
    while (1) {
#line 359
      __cil_tmp___3 = cwp;
#line 359
      cwp ++;
#line 359
      __cil_tmp___4 = (unsigned int )*words;
#line 359
      *__cil_tmp___3 = __cil_tmp___4;
#line 359
      C += ((B ^ (D & (A ^ B))) + __cil_tmp___4) + 606105819U;
#line 359
      words ++;
#line 359
      C = (C << 17) | (C >> 15);
#line 359
      C += D;
#line 359
      break;
    }
#line 360
    while (1) {
#line 360
      __cil_tmp___5 = cwp;
#line 360
      cwp ++;
#line 360
      __cil_tmp___6 = (unsigned int )*words;
#line 360
      *__cil_tmp___5 = __cil_tmp___6;
#line 360
      B += ((A ^ (C & (D ^ A))) + __cil_tmp___6) + 3250441966U;
#line 360
      words ++;
#line 360
      B = (B << 22) | (B >> 10);
#line 360
      B += C;
#line 360
      break;
    }
#line 361
    while (1) {
#line 361
      __cil_tmp___7 = cwp;
#line 361
      cwp ++;
#line 361
      __cil_tmp___8 = (unsigned int )*words;
#line 361
      *__cil_tmp___7 = __cil_tmp___8;
#line 361
      A += ((D ^ (B & (C ^ D))) + __cil_tmp___8) + 4118548399U;
#line 361
      words ++;
#line 361
      A = (A << 7) | (A >> 25);
#line 361
      A += B;
#line 361
      break;
    }
#line 362
    while (1) {
#line 362
      __cil_tmp___9 = cwp;
#line 362
      cwp ++;
#line 362
      __cil_tmp___10 = (unsigned int )*words;
#line 362
      *__cil_tmp___9 = __cil_tmp___10;
#line 362
      D += ((C ^ (A & (B ^ C))) + __cil_tmp___10) + 1200080426U;
#line 362
      words ++;
#line 362
      D = (D << 12) | (D >> 20);
#line 362
      D += A;
#line 362
      break;
    }
#line 363
    while (1) {
#line 363
      __cil_tmp___11 = cwp;
#line 363
      cwp ++;
#line 363
      __cil_tmp___12 = (unsigned int )*words;
#line 363
      *__cil_tmp___11 = __cil_tmp___12;
#line 363
      C += ((B ^ (D & (A ^ B))) + __cil_tmp___12) + 2821735955U;
#line 363
      words ++;
#line 363
      C = (C << 17) | (C >> 15);
#line 363
      C += D;
#line 363
      break;
    }
#line 364
    while (1) {
#line 364
      __cil_tmp___13 = cwp;
#line 364
      cwp ++;
#line 364
      __cil_tmp___14 = (unsigned int )*words;
#line 364
      *__cil_tmp___13 = __cil_tmp___14;
#line 364
      B += ((A ^ (C & (D ^ A))) + __cil_tmp___14) + 4249261313U;
#line 364
      words ++;
#line 364
      B = (B << 22) | (B >> 10);
#line 364
      B += C;
#line 364
      break;
    }
#line 365
    while (1) {
#line 365
      __cil_tmp___15 = cwp;
#line 365
      cwp ++;
#line 365
      __cil_tmp___16 = (unsigned int )*words;
#line 365
      *__cil_tmp___15 = __cil_tmp___16;
#line 365
      A += ((D ^ (B & (C ^ D))) + __cil_tmp___16) + 1770035416U;
#line 365
      words ++;
#line 365
      A = (A << 7) | (A >> 25);
#line 365
      A += B;
#line 365
      break;
    }
#line 366
    while (1) {
#line 366
      __cil_tmp___17 = cwp;
#line 366
      cwp ++;
#line 366
      __cil_tmp___18 = (unsigned int )*words;
#line 366
      *__cil_tmp___17 = __cil_tmp___18;
#line 366
      D += ((C ^ (A & (B ^ C))) + __cil_tmp___18) + 2336552879U;
#line 366
      words ++;
#line 366
      D = (D << 12) | (D >> 20);
#line 366
      D += A;
#line 366
      break;
    }
#line 367
    while (1) {
#line 367
      __cil_tmp___19 = cwp;
#line 367
      cwp ++;
#line 367
      __cil_tmp___20 = (unsigned int )*words;
#line 367
      *__cil_tmp___19 = __cil_tmp___20;
#line 367
      C += ((B ^ (D & (A ^ B))) + __cil_tmp___20) + 4294925233U;
#line 367
      words ++;
#line 367
      C = (C << 17) | (C >> 15);
#line 367
      C += D;
#line 367
      break;
    }
#line 368
    while (1) {
#line 368
      __cil_tmp___21 = cwp;
#line 368
      cwp ++;
#line 368
      __cil_tmp___22 = (unsigned int )*words;
#line 368
      *__cil_tmp___21 = __cil_tmp___22;
#line 368
      B += ((A ^ (C & (D ^ A))) + __cil_tmp___22) + 2304563134U;
#line 368
      words ++;
#line 368
      B = (B << 22) | (B >> 10);
#line 368
      B += C;
#line 368
      break;
    }
#line 369
    while (1) {
#line 369
      __cil_tmp___23 = cwp;
#line 369
      cwp ++;
#line 369
      __cil_tmp___24 = (unsigned int )*words;
#line 369
      *__cil_tmp___23 = __cil_tmp___24;
#line 369
      A += ((D ^ (B & (C ^ D))) + __cil_tmp___24) + 1804603682U;
#line 369
      words ++;
#line 369
      A = (A << 7) | (A >> 25);
#line 369
      A += B;
#line 369
      break;
    }
#line 370
    while (1) {
#line 370
      __cil_tmp___25 = cwp;
#line 370
      cwp ++;
#line 370
      __cil_tmp___26 = (unsigned int )*words;
#line 370
      *__cil_tmp___25 = __cil_tmp___26;
#line 370
      D += ((C ^ (A & (B ^ C))) + __cil_tmp___26) + 4254626195U;
#line 370
      words ++;
#line 370
      D = (D << 12) | (D >> 20);
#line 370
      D += A;
#line 370
      break;
    }
#line 371
    while (1) {
#line 371
      __cil_tmp___27 = cwp;
#line 371
      cwp ++;
#line 371
      __cil_tmp___28 = (unsigned int )*words;
#line 371
      *__cil_tmp___27 = __cil_tmp___28;
#line 371
      C += ((B ^ (D & (A ^ B))) + __cil_tmp___28) + 2792965006U;
#line 371
      words ++;
#line 371
      C = (C << 17) | (C >> 15);
#line 371
      C += D;
#line 371
      break;
    }
#line 372
    while (1) {
#line 372
      __cil_tmp___29 = cwp;
#line 372
      cwp ++;
#line 372
      __cil_tmp___30 = (unsigned int )*words;
#line 372
      *__cil_tmp___29 = __cil_tmp___30;
#line 372
      B += ((A ^ (C & (D ^ A))) + __cil_tmp___30) + 1236535329U;
#line 372
      words ++;
#line 372
      B = (B << 22) | (B >> 10);
#line 372
      B += C;
#line 372
      break;
    }
#line 388
    while (1) {
#line 388
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 388
      A = (A << 5) | (A >> 27);
#line 388
      A += B;
#line 388
      break;
    }
#line 389
    while (1) {
#line 389
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 389
      D = (D << 9) | (D >> 23);
#line 389
      D += A;
#line 389
      break;
    }
#line 390
    while (1) {
#line 390
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 390
      C = (C << 14) | (C >> 18);
#line 390
      C += D;
#line 390
      break;
    }
#line 391
    while (1) {
#line 391
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 391
      B = (B << 20) | (B >> 12);
#line 391
      B += C;
#line 391
      break;
    }
#line 392
    while (1) {
#line 392
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 392
      A = (A << 5) | (A >> 27);
#line 392
      A += B;
#line 392
      break;
    }
#line 393
    while (1) {
#line 393
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 393
      D = (D << 9) | (D >> 23);
#line 393
      D += A;
#line 393
      break;
    }
#line 394
    while (1) {
#line 394
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 394
      C = (C << 14) | (C >> 18);
#line 394
      C += D;
#line 394
      break;
    }
#line 395
    while (1) {
#line 395
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 395
      B = (B << 20) | (B >> 12);
#line 395
      B += C;
#line 395
      break;
    }
#line 396
    while (1) {
#line 396
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 396
      A = (A << 5) | (A >> 27);
#line 396
      A += B;
#line 396
      break;
    }
#line 397
    while (1) {
#line 397
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 397
      D = (D << 9) | (D >> 23);
#line 397
      D += A;
#line 397
      break;
    }
#line 398
    while (1) {
#line 398
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 398
      C = (C << 14) | (C >> 18);
#line 398
      C += D;
#line 398
      break;
    }
#line 399
    while (1) {
#line 399
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 399
      B = (B << 20) | (B >> 12);
#line 399
      B += C;
#line 399
      break;
    }
#line 400
    while (1) {
#line 400
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 400
      A = (A << 5) | (A >> 27);
#line 400
      A += B;
#line 400
      break;
    }
#line 401
    while (1) {
#line 401
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 401
      D = (D << 9) | (D >> 23);
#line 401
      D += A;
#line 401
      break;
    }
#line 402
    while (1) {
#line 402
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 402
      C = (C << 14) | (C >> 18);
#line 402
      C += D;
#line 402
      break;
    }
#line 403
    while (1) {
#line 403
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 403
      B = (B << 20) | (B >> 12);
#line 403
      B += C;
#line 403
      break;
    }
#line 406
    while (1) {
#line 406
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 406
      A = (A << 4) | (A >> 28);
#line 406
      A += B;
#line 406
      break;
    }
#line 407
    while (1) {
#line 407
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 407
      D = (D << 11) | (D >> 21);
#line 407
      D += A;
#line 407
      break;
    }
#line 408
    while (1) {
#line 408
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 408
      C = (C << 16) | (C >> 16);
#line 408
      C += D;
#line 408
      break;
    }
#line 409
    while (1) {
#line 409
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 409
      B = (B << 23) | (B >> 9);
#line 409
      B += C;
#line 409
      break;
    }
#line 410
    while (1) {
#line 410
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 410
      A = (A << 4) | (A >> 28);
#line 410
      A += B;
#line 410
      break;
    }
#line 411
    while (1) {
#line 411
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 411
      D = (D << 11) | (D >> 21);
#line 411
      D += A;
#line 411
      break;
    }
#line 412
    while (1) {
#line 412
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 412
      C = (C << 16) | (C >> 16);
#line 412
      C += D;
#line 412
      break;
    }
#line 413
    while (1) {
#line 413
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 413
      B = (B << 23) | (B >> 9);
#line 413
      B += C;
#line 413
      break;
    }
#line 414
    while (1) {
#line 414
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 414
      A = (A << 4) | (A >> 28);
#line 414
      A += B;
#line 414
      break;
    }
#line 415
    while (1) {
#line 415
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 415
      D = (D << 11) | (D >> 21);
#line 415
      D += A;
#line 415
      break;
    }
#line 416
    while (1) {
#line 416
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 416
      C = (C << 16) | (C >> 16);
#line 416
      C += D;
#line 416
      break;
    }
#line 417
    while (1) {
#line 417
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 417
      B = (B << 23) | (B >> 9);
#line 417
      B += C;
#line 417
      break;
    }
#line 418
    while (1) {
#line 418
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 418
      A = (A << 4) | (A >> 28);
#line 418
      A += B;
#line 418
      break;
    }
#line 419
    while (1) {
#line 419
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 419
      D = (D << 11) | (D >> 21);
#line 419
      D += A;
#line 419
      break;
    }
#line 420
    while (1) {
#line 420
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 420
      C = (C << 16) | (C >> 16);
#line 420
      C += D;
#line 420
      break;
    }
#line 421
    while (1) {
#line 421
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 421
      B = (B << 23) | (B >> 9);
#line 421
      B += C;
#line 421
      break;
    }
#line 424
    while (1) {
#line 424
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 424
      A = (A << 6) | (A >> 26);
#line 424
      A += B;
#line 424
      break;
    }
#line 425
    while (1) {
#line 425
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 425
      D = (D << 10) | (D >> 22);
#line 425
      D += A;
#line 425
      break;
    }
#line 426
    while (1) {
#line 426
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 426
      C = (C << 15) | (C >> 17);
#line 426
      C += D;
#line 426
      break;
    }
#line 427
    while (1) {
#line 427
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 427
      B = (B << 21) | (B >> 11);
#line 427
      B += C;
#line 427
      break;
    }
#line 428
    while (1) {
#line 428
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 428
      A = (A << 6) | (A >> 26);
#line 428
      A += B;
#line 428
      break;
    }
#line 429
    while (1) {
#line 429
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 429
      D = (D << 10) | (D >> 22);
#line 429
      D += A;
#line 429
      break;
    }
#line 430
    while (1) {
#line 430
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 430
      C = (C << 15) | (C >> 17);
#line 430
      C += D;
#line 430
      break;
    }
#line 431
    while (1) {
#line 431
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 431
      B = (B << 21) | (B >> 11);
#line 431
      B += C;
#line 431
      break;
    }
#line 432
    while (1) {
#line 432
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 432
      A = (A << 6) | (A >> 26);
#line 432
      A += B;
#line 432
      break;
    }
#line 433
    while (1) {
#line 433
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 433
      D = (D << 10) | (D >> 22);
#line 433
      D += A;
#line 433
      break;
    }
#line 434
    while (1) {
#line 434
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 434
      C = (C << 15) | (C >> 17);
#line 434
      C += D;
#line 434
      break;
    }
#line 435
    while (1) {
#line 435
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 435
      B = (B << 21) | (B >> 11);
#line 435
      B += C;
#line 435
      break;
    }
#line 436
    while (1) {
#line 436
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 436
      A = (A << 6) | (A >> 26);
#line 436
      A += B;
#line 436
      break;
    }
#line 437
    while (1) {
#line 437
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 437
      D = (D << 10) | (D >> 22);
#line 437
      D += A;
#line 437
      break;
    }
#line 438
    while (1) {
#line 438
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 438
      C = (C << 15) | (C >> 17);
#line 438
      C += D;
#line 438
      break;
    }
#line 439
    while (1) {
#line 439
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 439
      B = (B << 21) | (B >> 11);
#line 439
      B += C;
#line 439
      break;
    }
#line 442
    A += A_save;
#line 443
    B += B_save;
#line 444
    C += C_save;
#line 445
    D += D_save;
  }
#line 449
  ctx->A = A;
#line 450
  ctx->B = B;
#line 451
  ctx->C = C;
#line 452
  ctx->D = D;
#line 453
  return;
}
}
#line 1 "memcasecmp.o"
#pragma merger(0,"/tmp/cil-rGaV8uk4.i","-g,-O2")
#line 22 "memcasecmp.h"
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) ;
#line 30 "memcasecmp.c"
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) 
{ size_t i ;
  char const   *s1 ;
  char const   *s2 ;
  unsigned char u1 ;
  unsigned char u2 ;
  int U1 ;
  unsigned char __x ;
  int U2 ;
  unsigned char __x___0 ;
  int diff ;

  {
#line 34
  s1 = (char const   *)vs1;
#line 35
  s2 = (char const   *)vs2;
#line 36
  i = 0U;
#line 36
  while (i < n) {
#line 38
    u1 = (unsigned char )*(s1 + i);
#line 39
    u2 = (unsigned char )*(s2 + i);
#line 40
    __x = u1;
#line 40
    U1 = ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 2 ? ((int )__x - 97) + 65 : (int )__x;
#line 41
    __x___0 = u2;
#line 41
    U2 = ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x___0))) + (int )__x___0) & 3) == 2 ? ((int )__x___0 - 97) + 65 : (int )__x___0;
#line 42
    diff = U1 - U2;
#line 44
    if (diff) {
#line 45
      return (diff);
    }
#line 36
    i ++;
  }
#line 47
  return (0);
}
}
#line 1 "memcmp.o"
#pragma merger(0,"/tmp/cil-K5pg5HRz.i","-g,-O2")
#line 88 "memcmp.c"
__inline static int memcmp_bytes(unsigned long a , unsigned long b ) 
{ long srcp1 ;
  long srcp2 ;
  unsigned long a0 ;
  unsigned long b0 ;

  {
#line 93
  srcp1 = (long )(& a);
#line 94
  srcp2 = (long )(& b);
#line 97
  while (1) {
#line 99
    a0 = (unsigned long )*((byte *)srcp1 + 0);
#line 100
    b0 = (unsigned long )*((byte *)srcp2 + 0);
#line 101
    srcp1 ++;
#line 102
    srcp2 ++;
#line 97
    if (! (a0 == b0)) {
#line 97
      break;
    }
  }
#line 105
  return ((int )(a0 - b0));
}
}
#line 113 "memcmp.c"
__inline static int memcmp_common_alignment(long srcp1 , long srcp2 , size_t len ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long b0 ;
  unsigned long b1 ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 121
  switch ((int )(len % 4U)) {
  default: 
#line 125
  a0 = *((unsigned long *)srcp1 + 0);
#line 126
  b0 = *((unsigned long *)srcp2 + 0);
#line 127
  srcp1 = (long )((unsigned long )srcp1 - (unsigned long )(2U * sizeof(unsigned long )));
#line 128
  srcp2 = (long )((unsigned long )srcp2 - (unsigned long )(2U * sizeof(unsigned long )));
#line 129
  len += 2U;
#line 130
  goto do1;
  case 3: 
#line 132
  a1 = *((unsigned long *)srcp1 + 0);
#line 133
  b1 = *((unsigned long *)srcp2 + 0);
#line 134
  srcp1 = (long )((unsigned long )srcp1 - (unsigned long )sizeof(unsigned long ));
#line 135
  srcp2 = (long )((unsigned long )srcp2 - (unsigned long )sizeof(unsigned long ));
#line 136
  len ++;
#line 137
  goto do2;
  case 0: 
#line 139
  if (16U <= 3U * sizeof(unsigned long ) && len == 0U) {
#line 140
    return (0);
  }
#line 141
  a0 = *((unsigned long *)srcp1 + 0);
#line 142
  b0 = *((unsigned long *)srcp2 + 0);
#line 143
  goto do3;
  case 1: 
#line 145
  a1 = *((unsigned long *)srcp1 + 0);
#line 146
  b1 = *((unsigned long *)srcp2 + 0);
#line 147
  srcp1 = (long )((unsigned long )srcp1 + (unsigned long )sizeof(unsigned long ));
#line 148
  srcp2 = (long )((unsigned long )srcp2 + (unsigned long )sizeof(unsigned long ));
#line 149
  len --;
#line 150
  if (16U <= 3U * sizeof(unsigned long ) && len == 0U) {
#line 151
    goto do0;
  }
  }
#line 155
  while (1) {
#line 157
    a0 = *((unsigned long *)srcp1 + 0);
#line 158
    b0 = *((unsigned long *)srcp2 + 0);
#line 159
    if (a1 != b1) {
#line 160
      __cil_tmp = memcmp_bytes(a1, b1);
#line 160
      return (__cil_tmp);
    }
    do3: 
#line 163
    a1 = *((unsigned long *)srcp1 + 1);
#line 164
    b1 = *((unsigned long *)srcp2 + 1);
#line 165
    if (a0 != b0) {
#line 166
      __cil_tmp___0 = memcmp_bytes(a0, b0);
#line 166
      return (__cil_tmp___0);
    }
    do2: 
#line 169
    a0 = *((unsigned long *)srcp1 + 2);
#line 170
    b0 = *((unsigned long *)srcp2 + 2);
#line 171
    if (a1 != b1) {
#line 172
      __cil_tmp___1 = memcmp_bytes(a1, b1);
#line 172
      return (__cil_tmp___1);
    }
    do1: 
#line 175
    a1 = *((unsigned long *)srcp1 + 3);
#line 176
    b1 = *((unsigned long *)srcp2 + 3);
#line 177
    if (a0 != b0) {
#line 178
      __cil_tmp___2 = memcmp_bytes(a0, b0);
#line 178
      return (__cil_tmp___2);
    }
#line 180
    srcp1 = (long )((unsigned long )srcp1 + (unsigned long )(4U * sizeof(unsigned long )));
#line 181
    srcp2 = (long )((unsigned long )srcp2 + (unsigned long )(4U * sizeof(unsigned long )));
#line 182
    len -= 4U;
#line 155
    if (! (len != 0U)) {
#line 155
      break;
    }
  }
  do0: 
#line 189
  if (a1 != b1) {
#line 190
    __cil_tmp___3 = memcmp_bytes(a1, b1);
#line 190
    return (__cil_tmp___3);
  }
#line 191
  return (0);
}
}
#line 198 "memcmp.c"
__inline static int memcmp_not_common_alignment(long srcp1 , long srcp2 , size_t len ) 
{ unsigned long a0 ;
  unsigned long a1 ;
  unsigned long a2 ;
  unsigned long a3 ;
  unsigned long b0 ;
  unsigned long b1 ;
  unsigned long b2 ;
  unsigned long b3 ;
  unsigned long x ;
  int shl ;
  int shr ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 211
  shl = (int )(8UL * ((unsigned long )srcp1 % (unsigned long )sizeof(unsigned long )));
#line 212
  shr = (int )(8U * sizeof(unsigned long ) - (unsigned int )shl);
#line 216
  srcp1 = (long )((unsigned long )srcp1 & (unsigned long )(- sizeof(unsigned long )));
#line 218
  switch ((int )(len % 4U)) {
  default: 
#line 222
  a1 = *((unsigned long *)srcp1 + 0);
#line 223
  a2 = *((unsigned long *)srcp1 + 1);
#line 224
  b2 = *((unsigned long *)srcp2 + 0);
#line 225
  srcp1 = (long )((unsigned long )srcp1 - (unsigned long )sizeof(unsigned long ));
#line 226
  srcp2 = (long )((unsigned long )srcp2 - (unsigned long )(2U * sizeof(unsigned long )));
#line 227
  len += 2U;
#line 228
  goto do1;
  case 3: 
#line 230
  a0 = *((unsigned long *)srcp1 + 0);
#line 231
  a1 = *((unsigned long *)srcp1 + 1);
#line 232
  b1 = *((unsigned long *)srcp2 + 0);
#line 233
  srcp2 = (long )((unsigned long )srcp2 - (unsigned long )sizeof(unsigned long ));
#line 234
  len ++;
#line 235
  goto do2;
  case 0: 
#line 237
  if (16U <= 3U * sizeof(unsigned long ) && len == 0U) {
#line 238
    return (0);
  }
#line 239
  a3 = *((unsigned long *)srcp1 + 0);
#line 240
  a0 = *((unsigned long *)srcp1 + 1);
#line 241
  b0 = *((unsigned long *)srcp2 + 0);
#line 242
  srcp1 = (long )((unsigned long )srcp1 + (unsigned long )sizeof(unsigned long ));
#line 243
  goto do3;
  case 1: 
#line 245
  a2 = *((unsigned long *)srcp1 + 0);
#line 246
  a3 = *((unsigned long *)srcp1 + 1);
#line 247
  b3 = *((unsigned long *)srcp2 + 0);
#line 248
  srcp1 = (long )((unsigned long )srcp1 + (unsigned long )(2U * sizeof(unsigned long )));
#line 249
  srcp2 = (long )((unsigned long )srcp2 + (unsigned long )sizeof(unsigned long ));
#line 250
  len --;
#line 251
  if (16U <= 3U * sizeof(unsigned long ) && len == 0U) {
#line 252
    goto do0;
  }
  }
#line 256
  while (1) {
#line 258
    a0 = *((unsigned long *)srcp1 + 0);
#line 259
    b0 = *((unsigned long *)srcp2 + 0);
#line 260
    x = (a2 >> shl) | (a3 << shr);
#line 261
    if (x != b3) {
#line 262
      __cil_tmp = memcmp_bytes(x, b3);
#line 262
      return (__cil_tmp);
    }
    do3: 
#line 265
    a1 = *((unsigned long *)srcp1 + 1);
#line 266
    b1 = *((unsigned long *)srcp2 + 1);
#line 267
    x = (a3 >> shl) | (a0 << shr);
#line 268
    if (x != b0) {
#line 269
      __cil_tmp___0 = memcmp_bytes(x, b0);
#line 269
      return (__cil_tmp___0);
    }
    do2: 
#line 272
    a2 = *((unsigned long *)srcp1 + 2);
#line 273
    b2 = *((unsigned long *)srcp2 + 2);
#line 274
    x = (a0 >> shl) | (a1 << shr);
#line 275
    if (x != b1) {
#line 276
      __cil_tmp___1 = memcmp_bytes(x, b1);
#line 276
      return (__cil_tmp___1);
    }
    do1: 
#line 279
    a3 = *((unsigned long *)srcp1 + 3);
#line 280
    b3 = *((unsigned long *)srcp2 + 3);
#line 281
    x = (a1 >> shl) | (a2 << shr);
#line 282
    if (x != b2) {
#line 283
      __cil_tmp___2 = memcmp_bytes(x, b2);
#line 283
      return (__cil_tmp___2);
    }
#line 285
    srcp1 = (long )((unsigned long )srcp1 + (unsigned long )(4U * sizeof(unsigned long )));
#line 286
    srcp2 = (long )((unsigned long )srcp2 + (unsigned long )(4U * sizeof(unsigned long )));
#line 287
    len -= 4U;
#line 256
    if (! (len != 0U)) {
#line 256
      break;
    }
  }
  do0: 
#line 294
  x = (a2 >> shl) | (a3 << shr);
#line 295
  if (x != b3) {
#line 296
    __cil_tmp___3 = memcmp_bytes(x, b3);
#line 296
    return (__cil_tmp___3);
  }
#line 297
  return (0);
}
}
#line 300 "memcmp.c"
int rpl_memcmp(void const   *s1 , void const   *s2 , size_t len ) 
{ unsigned long a0 ;
  unsigned long b0 ;
  long srcp1 ;
  long srcp2 ;
  unsigned long res ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 305
  srcp1 = (long )s1;
#line 306
  srcp2 = (long )s2;
#line 309
  if (len >= 16U) {
#line 313
    while ((unsigned long )srcp2 % (unsigned long )sizeof(unsigned long ) != 0UL) {
#line 315
      a0 = (unsigned long )*((byte *)srcp1 + 0);
#line 316
      b0 = (unsigned long )*((byte *)srcp2 + 0);
#line 317
      srcp1 ++;
#line 318
      srcp2 ++;
#line 319
      res = a0 - b0;
#line 320
      if (res != 0UL) {
#line 321
        return ((int )res);
      }
#line 322
      len --;
    }
#line 329
    if ((unsigned long )srcp1 % (unsigned long )sizeof(unsigned long ) == 0UL) {
#line 330
      __cil_tmp = memcmp_common_alignment(srcp1, srcp2, len / sizeof(unsigned long ));
#line 330
      res = (unsigned long )__cil_tmp;
    } else {
#line 332
      __cil_tmp___0 = memcmp_not_common_alignment(srcp1, srcp2, len / sizeof(unsigned long ));
#line 332
      res = (unsigned long )__cil_tmp___0;
    }
#line 333
    if (res != 0UL) {
#line 334
      return ((int )res);
    }
#line 337
    srcp1 = (long )((unsigned long )srcp1 + (unsigned long )(len & - sizeof(unsigned long )));
#line 338
    srcp2 = (long )((unsigned long )srcp2 + (unsigned long )(len & - sizeof(unsigned long )));
#line 339
    len %= sizeof(unsigned long );
  }
#line 343
  while (len != 0U) {
#line 345
    a0 = (unsigned long )*((byte *)srcp1 + 0);
#line 346
    b0 = (unsigned long )*((byte *)srcp2 + 0);
#line 347
    srcp1 ++;
#line 348
    srcp2 ++;
#line 349
    res = a0 - b0;
#line 350
    if (res != 0UL) {
#line 351
      return ((int )res);
    }
#line 352
    len --;
  }
#line 355
  return (0);
}
}
#line 1 "memcoll.o"
#pragma merger(0,"/tmp/cil-PJPc09EQ.i","-g,-O2")
#line 32 "memcoll.c"
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ int diff ;
  int *__cil_tmp ;

  {
#line 87
  diff = rpl_memcmp((void const   *)s1, (void const   *)s2, s1len < s2len ? s1len : s2len);
#line 88
  if (! diff) {
#line 89
    diff = s1len < s2len ? -1 : s1len != s2len;
  }
#line 90
  __cil_tmp = __errno();
#line 90
  *__cil_tmp = 0;
#line 94
  return (diff);
}
}
#line 1 "memrchr.o"
#pragma merger(0,"/tmp/cil-uTGz2Cuo.i","-g,-O2")
#line 43 "memrchr.c"
void *memrchr(void const   *s , int c_in , size_t n ) 
{ unsigned char const   *char_ptr ;
  unsigned long const   *longword_ptr ;
  unsigned long longword ;
  unsigned long magic_bits ;
  unsigned long charmask ;
  unsigned char c ;
  int i ;
  unsigned char const   *cp ;
  size_t __cil_tmp ;

  {
#line 52
  c = (unsigned char )c_in;
#line 56
  char_ptr = (unsigned char const   *)s + n;
#line 56
  while (n > 0U && (unsigned int )char_ptr % sizeof(longword) != 0U) {
#line 59
    char_ptr --;
#line 59
    if ((int const   )*char_ptr == (int const   )c) {
#line 60
      return ((void *)char_ptr);
    }
#line 56
    n --;
  }
#line 65
  longword_ptr = (unsigned long const   *)char_ptr;
#line 80
  magic_bits = 4278124286UL;
#line 81
  charmask = (unsigned long )((int )c | ((int )c << 8));
#line 82
  charmask |= charmask << 16;
#line 93
  magic_bits = (4294967295UL >> 1) & (magic_bits | 1UL);
#line 98
  while (n >= sizeof(longword)) {
#line 134
    longword_ptr --;
#line 134
    longword = (unsigned long )(*longword_ptr ^ (unsigned long const   )charmask);
#line 137
    if ((((longword + magic_bits) ^ ~ longword) & ~ magic_bits) != 0UL) {
#line 150
      cp = (unsigned char const   *)longword_ptr;
#line 152
      if (8U < sizeof(longword)) {
#line 153
        i = (int )(sizeof(longword) - 1U);
#line 153
        while (8 <= i) {
#line 154
          if ((int const   )*(cp + i) == (int const   )c) {
#line 155
            return ((void *)(cp + i));
          }
#line 153
          i --;
        }
      }
#line 156
      if (7U < sizeof(longword) && (int const   )*(cp + 7) == (int const   )c) {
#line 157
        return ((void *)(cp + 7));
      }
#line 158
      if (6U < sizeof(longword) && (int const   )*(cp + 6) == (int const   )c) {
#line 159
        return ((void *)(cp + 6));
      }
#line 160
      if (5U < sizeof(longword) && (int const   )*(cp + 5) == (int const   )c) {
#line 161
        return ((void *)(cp + 5));
      }
#line 162
      if (4U < sizeof(longword) && (int const   )*(cp + 4) == (int const   )c) {
#line 163
        return ((void *)(cp + 4));
      }
#line 164
      if ((int const   )*(cp + 3) == (int const   )c) {
#line 165
        return ((void *)(cp + 3));
      }
#line 166
      if ((int const   )*(cp + 2) == (int const   )c) {
#line 167
        return ((void *)(cp + 2));
      }
#line 168
      if ((int const   )*(cp + 1) == (int const   )c) {
#line 169
        return ((void *)(cp + 1));
      }
#line 170
      if ((int const   )*(cp + 0) == (int const   )c) {
#line 171
        return ((void *)cp);
      }
    }
#line 174
    n -= sizeof(longword);
  }
#line 177
  char_ptr = (unsigned char const   *)longword_ptr;
#line 179
  while (1) {
#line 179
    __cil_tmp = n;
#line 179
    n --;
#line 179
    if (! (__cil_tmp > 0U)) {
#line 179
      break;
    }
#line 181
    char_ptr --;
#line 181
    if ((int const   )*char_ptr == (int const   )c) {
#line 182
      return ((void *)char_ptr);
    }
  }
#line 185
  return ((void *)0);
}
}
#line 1 "mgetgroups.o"
#pragma merger(0,"/tmp/cil-jOUOnT8K.i","-g,-O2")
#line 19 "mgetgroups.h"
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) ;
#line 39 "mgetgroups.c"
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) 
{ int max_n_groups ;
  int ng ;
  gid_t *g ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int saved_errno ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;

  {
#line 46
  if (username) {
#line 46
    __cil_tmp = getugroups(0, (gid_t *)((void *)0), username, gid);
#line 46
    max_n_groups = __cil_tmp;
  } else {
#line 46
    __cil_tmp___0 = rpl_getgroups(0, (gid_t *)((void *)0));
#line 46
    max_n_groups = __cil_tmp___0;
  }
#line 52
  if (max_n_groups < 0) {
#line 53
    max_n_groups = 5;
  }
#line 55
  if ((unsigned int )(sizeof(ptrdiff_t ) <= sizeof(size_t ) ? -1 : -2) / sizeof(*g) < (unsigned int )max_n_groups) {
#line 57
    __cil_tmp___1 = __errno();
#line 57
    *__cil_tmp___1 = 12;
#line 58
    return (-1);
  }
#line 61
  __cil_tmp___2 = rpl_malloc((unsigned int )max_n_groups * sizeof(*g));
#line 61
  g = (gid_t *)__cil_tmp___2;
#line 62
  if ((unsigned int )g == (unsigned int )((void *)0)) {
#line 63
    return (-1);
  }
#line 65
  if (username) {
#line 65
    __cil_tmp___3 = getugroups(max_n_groups, g, username, gid);
#line 65
    ng = __cil_tmp___3;
  } else {
#line 65
    __cil_tmp___4 = rpl_getgroups(max_n_groups, g);
#line 65
    ng = __cil_tmp___4;
  }
#line 69
  if (ng < 0) {
#line 71
    __cil_tmp___5 = __errno();
#line 71
    saved_errno = *__cil_tmp___5;
#line 72
    free((void *)g);
#line 73
    __cil_tmp___6 = __errno();
#line 73
    *__cil_tmp___6 = saved_errno;
#line 74
    return (-1);
  }
#line 77
  *groups = g;
#line 78
  return (ng);
}
}
#line 1 "mkancesdirs.o"
#pragma merger(0,"/tmp/cil-SzKcuStM.i","-g,-O2")
#line 3 "mkancesdirs.h"
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) ;
#line 66 "mkancesdirs.c"
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) 
{ char *sep ;
  char *component ;
  char *p ;
  char c ;
  _Bool made_dir ;
  int make_dir_errno ;
  int savewd_chdir_options ;
  int chdir_result ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  char *__cil_tmp___3 ;

  {
#line 74
  sep = (char *)((void *)0);
#line 78
  component = file;
#line 80
  p = file + 0;
#line 82
  made_dir = (_Bool)0;
#line 90
  while (1) {
#line 90
    __cil_tmp___3 = p;
#line 90
    p ++;
#line 90
    c = *__cil_tmp___3;
#line 90
    if (! c) {
#line 90
      break;
    }
#line 91
    if ((int )*p == 47) {
#line 93
      if (! ((int )c == 47)) {
#line 94
        sep = p;
      }
    } else
#line 96
    if (((int )c == 47 && *p) && sep) {
#line 100
      if (! (sep - component == 1 && (int )*(component + 0) == 46)) {
#line 102
        make_dir_errno = 0;
#line 103
        savewd_chdir_options = 0;
#line 108
        *sep = (char )'\000';
#line 112
        if ((sep - component == 2 && (int )*(component + 0) == 46) && (int )*(component + 1) == 46) {
#line 114
          made_dir = (_Bool)0;
        } else {
#line 116
          __cil_tmp = (*make_dir)((char const   *)file, (char const   *)component,
                                  make_dir_arg);
#line 116
          switch (__cil_tmp) {
          case -1: 
#line 119
          __cil_tmp___0 = __errno();
#line 119
          make_dir_errno = *__cil_tmp___0;
#line 120
          break;
          case 0: 
#line 123
          savewd_chdir_options |= 2;
          case 1: 
#line 126
          made_dir = (_Bool)1;
#line 127
          break;
          }
        }
#line 130
        if (made_dir) {
#line 131
          savewd_chdir_options |= 1;
        }
#line 133
        chdir_result = savewd_chdir(wd, (char const   *)component, savewd_chdir_options,
                                    (int *)((void *)0));
#line 138
        if (chdir_result != -1) {
#line 139
          *sep = (char )'/';
        }
#line 141
        if (chdir_result != 0) {
#line 143
          if (make_dir_errno != 0) {
#line 143
            __cil_tmp___2 = __errno();
#line 143
            if (*__cil_tmp___2 == 2) {
#line 144
              __cil_tmp___1 = __errno();
#line 144
              *__cil_tmp___1 = make_dir_errno;
            }
          }
#line 145
          return ((long long )chdir_result);
        }
      }
#line 149
      component = p;
    }
  }
#line 152
  return ((long long )(component - file));
}
}
#line 1 "mkdir.o"
#pragma merger(0,"/tmp/cil-QxZRkxWj.i","-g,-O2")
#line 86 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/stat.h"
extern int mkdir(char const   *name , mode_t mode ) ;
#line 67 "dirname.h"
_Bool strip_trailing_slashes(char *file ) ;
#line 39 "mkdir.c"
int rpl_mkdir(char const   *dir , mode_t mode ) 
{ int ret_val ;
  char *tmp_dir ;
  size_t len ;
  size_t __cil_tmp ;

  {
#line 44
  __cil_tmp = strlen(dir);
#line 44
  len = __cil_tmp;
#line 46
  if (len && (int const   )*(dir + (len - 1U)) == 47) {
#line 48
    tmp_dir = xstrdup(dir);
#line 49
    strip_trailing_slashes(tmp_dir);
  } else {
#line 53
    tmp_dir = (char *)dir;
  }
#line 56
  ret_val = mkdir((char const   *)tmp_dir, mode);
#line 58
  if ((unsigned int )tmp_dir != (unsigned int )dir) {
#line 59
    free((void *)tmp_dir);
  }
#line 61
  return (ret_val);
}
}
#line 1 "mkdir-p.o"
#pragma merger(0,"/tmp/cil-6zU5oSxn.i","-g,-O2")
#line 25 "mkdir-p.h"
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) ;
#line 120 "savewd.h"
__inline static int savewd_errno(struct savewd  const  *wd ) 
{ 

  {
#line 123
  return ((int )((unsigned int const   )wd->state == 4U ? wd->val.errnum : (int const   )0));
}
}
#line 85 "mkdir-p.c"
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) 
{ int mkdir_errno ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  ptrdiff_t prefix_len ;
  int savewd_chdir_options ;
  int *__cil_tmp___1 ;
  _Bool keep_owner ;
  _Bool keep_special_mode_bits ;
  mode_t mkdir_mode ;
  int *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  struct stat st ;
  int __cil_tmp___4 ;
  int open_result[2] ;
  int chdir_result ;
  int __cil_tmp___5 ;
  _Bool chdir_ok ;
  int chdir_errno ;
  int *__cil_tmp___6 ;
  int fd ;
  _Bool chdir_failed_unexpectedly ;
  char const   *subdir ;
  int __cil_tmp___7 ;
  char const   *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int *__cil_tmp___11 ;
  char const   *__cil_tmp___12 ;

  {
#line 97
  if ((int )*(dir + 0) == 47) {
#line 97
    __cil_tmp___0 = 0;
  } else {
#line 97
    __cil_tmp = savewd_errno((struct savewd  const  *)wd);
#line 97
    __cil_tmp___0 = __cil_tmp;
  }
#line 97
  mkdir_errno = __cil_tmp___0;
#line 99
  if (mkdir_errno == 0) {
#line 101
    prefix_len = 0LL;
#line 102
    savewd_chdir_options = 4;
#line 104
    if (make_ancestor) {
#line 106
      prefix_len = mkancesdirs(dir, wd, make_ancestor, options);
#line 107
      if (prefix_len < 0LL) {
#line 109
        if (prefix_len < -1LL) {
#line 110
          return ((_Bool)1);
        }
#line 111
        __cil_tmp___1 = __errno();
#line 111
        mkdir_errno = *__cil_tmp___1;
      }
    }
#line 115
    if (0LL <= prefix_len) {
#line 122
      keep_owner = (_Bool )((int )owner == 65535 && (int )group == 65535);
#line 123
      keep_special_mode_bits = (_Bool )(((mode_bits & 3072U) | (mode & 512U)) == 0U);
#line 125
      mkdir_mode = mode;
#line 126
      if (! keep_owner) {
#line 127
        mkdir_mode &= 4294967232U;
      } else
#line 128
      if (! keep_special_mode_bits) {
#line 129
        mkdir_mode &= 4294967277U;
      }
#line 131
      __cil_tmp___3 = rpl_mkdir((char const   *)(dir + prefix_len), mkdir_mode);
#line 131
      if (__cil_tmp___3 == 0) {
#line 133
        (*announce)((char const   *)dir, options);
#line 134
        preserve_existing = (_Bool )((int )keep_owner & (int )keep_special_mode_bits);
#line 135
        savewd_chdir_options |= 1 | (mode & 256U ? 2 : 0);
      } else {
#line 141
        __cil_tmp___2 = __errno();
#line 141
        mkdir_errno = *__cil_tmp___2;
#line 142
        mkdir_mode = 4294967295U;
      }
#line 145
      if (preserve_existing) {
#line 148
        if (mkdir_errno == 0) {
#line 152
          return ((_Bool)1);
        } else
#line 148
        if (mkdir_errno != 2 && make_ancestor) {
#line 148
          __cil_tmp___4 = stat((char const   *)(dir + prefix_len), & st);
#line 148
          if (__cil_tmp___4 == 0) {
#line 148
            if ((st.st_mode & 8323072U) == 1048576U) {
#line 152
              return ((_Bool)1);
            }
          }
        }
      } else {
#line 157
        __cil_tmp___5 = savewd_chdir(wd, (char const   *)(dir + prefix_len), savewd_chdir_options,
                                     open_result);
#line 157
        chdir_result = __cil_tmp___5;
#line 160
        if (chdir_result < -1) {
#line 161
          return ((_Bool)1);
        } else {
#line 164
          chdir_ok = (_Bool )(chdir_result == 0);
#line 165
          __cil_tmp___6 = __errno();
#line 165
          chdir_errno = *__cil_tmp___6;
#line 166
          fd = open_result[0];
#line 167
          chdir_failed_unexpectedly = (_Bool )(mkdir_errno == 0 && ((! chdir_ok && mode & 64U) || (fd < 0 && mode & 256U)));
#line 172
          if (chdir_failed_unexpectedly) {
#line 175
            if (0 <= fd) {
#line 176
              close(fd);
            }
          } else {
#line 180
            subdir = chdir_ok ? "." : (char const   *)(dir + prefix_len);
#line 181
            __cil_tmp___7 = dirchownmod(fd, subdir, mkdir_mode, owner, group, mode,
                                        mode_bits);
#line 181
            if (__cil_tmp___7 == 0) {
#line 184
              return ((_Bool)1);
            }
          }
#line 187
          if (mkdir_errno == 0) {
#line 187
            goto _L;
          } else
#line 187
          if (mkdir_errno != 2 && make_ancestor) {
#line 187
            __cil_tmp___11 = __errno();
#line 187
            if (*__cil_tmp___11 != 20) {
              _L: 
#line 191
              __cil_tmp___8 = quote((char const   *)dir);
#line 191
              if (! chdir_failed_unexpectedly) {
#line 191
                __cil_tmp___9 = __errno();
#line 191
                __cil_tmp___10 = *__cil_tmp___9;
              } else {
#line 191
                __cil_tmp___10 = ! chdir_ok && mode & 64U ? chdir_errno : open_result[1];
              }
#line 191
              error(0, __cil_tmp___10, keep_owner ? "cannot change permissions of %s" : "cannot change owner and permissions of %s",
                    __cil_tmp___8);
#line 199
              return ((_Bool)0);
            }
          }
        }
      }
    }
  }
#line 206
  __cil_tmp___12 = quote((char const   *)dir);
#line 206
  error(0, mkdir_errno, "cannot create directory %s", __cil_tmp___12);
#line 207
  return ((_Bool)0);
}
}
#line 1 "mkdirat.o"
#pragma merger(0,"/tmp/cil-xUa7FuPw.i","-g,-O2")
#line 95 "openat.h"
int mkdirat(int fd , char const   *file , mode_t mode ) ;
#line 30 "at-func.c"
int mkdirat(int fd , char const   *file , mode_t mode ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___1 ;
  int proc_result ;
  int __cil_tmp___2 ;
  int proc_errno ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int *__cil_tmp___13 ;
  int *__cil_tmp___14 ;
  int __cil_tmp___15 ;
  int *__cil_tmp___16 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    __cil_tmp = rpl_mkdir(file, mode);
#line 38
    return (__cil_tmp);
  }
#line 42
  __cil_tmp___1 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___1;
#line 43
  if (proc_file) {
#line 45
    __cil_tmp___2 = rpl_mkdir((char const   *)proc_file, mode);
#line 45
    proc_result = __cil_tmp___2;
#line 46
    __cil_tmp___4 = __errno();
#line 46
    proc_errno = *__cil_tmp___4;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___5 = __errno();
#line 56
      *__cil_tmp___5 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___7 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___7 != 0) {
#line 63
    __cil_tmp___6 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___6);
  }
#line 65
  __cil_tmp___10 = fchdir(fd);
#line 65
  if (__cil_tmp___10 != 0) {
#line 67
    __cil_tmp___8 = __errno();
#line 67
    saved_errno = *__cil_tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___9 = __errno();
#line 69
    *__cil_tmp___9 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  __cil_tmp___11 = rpl_mkdir(file, mode);
#line 73
  err = __cil_tmp___11;
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___13 = __errno();
#line 74
    saved_errno = *__cil_tmp___13;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___15 != 0) {
#line 77
    __cil_tmp___14 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___14);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___16 = __errno();
#line 82
    *__cil_tmp___16 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 1 "mkstemp.o"
#pragma merger(0,"/tmp/cil-hS9qBhAg.i","-g,-O2")
#line 185 "./stdlib.h"
int rpl_mkstemp(char *template ) ;
#line 40 "tempname.h"
int gen_tempname(char *tmpl , int kind ) ;
#line 39 "mkstemp.c"
int rpl_mkstemp(char *template ) 
{ int __cil_tmp ;

  {
#line 43
  __cil_tmp = gen_tempname(template, 1);
#line 43
  return (__cil_tmp);
}
}
#line 1 "mkstemp-safer.o"
#pragma merger(0,"/tmp/cil-D4UheHjg.i","-g,-O2")
#line 20 "stdlib-safer.h"
int mkstemp_safer(char *templ ) ;
#line 30 "mkstemp-safer.c"
int mkstemp_safer(char *templ ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 33
  __cil_tmp = rpl_mkstemp(templ);
#line 33
  __cil_tmp___0 = fd_safer(__cil_tmp);
#line 33
  return (__cil_tmp___0);
}
}
#line 1 "mktime.o"
#pragma merger(0,"/tmp/cil-bvSwZPxD.i","-g,-O2")
#line 120 "mktime.c"
__inline static int leapyear(long year___0 ) 
{ 

  {
#line 125
  return ((year___0 & 3L) == 0L && (year___0 % 100L != 0L || (year___0 / 100L & 3L) == 1L));
}
}
#line 133 "mktime.c"
static unsigned short const   __mon_yday[2][13]  = { {        (unsigned short const   )0,        (unsigned short const   )31,        (unsigned short const   )59,        (unsigned short const   )90, 
            (unsigned short const   )120,        (unsigned short const   )151,        (unsigned short const   )181,        (unsigned short const   )212, 
            (unsigned short const   )243,        (unsigned short const   )273,        (unsigned short const   )304,        (unsigned short const   )334, 
            (unsigned short const   )365}, 
   {        (unsigned short const   )0,        (unsigned short const   )31,        (unsigned short const   )60,        (unsigned short const   )91, 
            (unsigned short const   )121,        (unsigned short const   )152,        (unsigned short const   )182,        (unsigned short const   )213, 
            (unsigned short const   )244,        (unsigned short const   )274,        (unsigned short const   )305,        (unsigned short const   )335, 
            (unsigned short const   )366}};
#line 165 "mktime.c"
__inline static time_t ydhms_diff(long year1 , long yday1 , int hour1 , int min1 ,
                                  int sec1 , int year0 , int yday0 , int hour0 , int min0 ,
                                  int sec0 ) 
{ int a4 ;
  int b4 ;
  int a100 ;
  int b100 ;
  int a400 ;
  int b400 ;
  int intervening_leap_days ;
  time_t tyear1 ;
  time_t years ;
  time_t days ;
  time_t hours ;
  time_t minutes ;
  time_t seconds ;

  {
#line 175
  a4 = (int )(((-1 >> 1 == -1 ? year1 >> 2 : year1 / (long )(1 << 2) - (long )(year1 % (long )(1 << 2) < 0L)) + (long )(-1 >> 1 == -1 ? 1900 >> 2 : 1900 / (1 << 2) - (1900 % (1 << 2) < 0))) - (long )(! (year1 & 3L)));
#line 176
  b4 = ((-1 >> 1 == -1 ? year0 >> 2 : year0 / (1 << 2) - (year0 % (1 << 2) < 0)) + (-1 >> 1 == -1 ? 1900 >> 2 : 1900 / (1 << 2) - (1900 % (1 << 2) < 0))) - ! (year0 & 3);
#line 177
  a100 = a4 / 25 - (a4 % 25 < 0);
#line 178
  b100 = b4 / 25 - (b4 % 25 < 0);
#line 179
  a400 = -1 >> 1 == -1 ? a100 >> 2 : a100 / (1 << 2) - (a100 % (1 << 2) < 0);
#line 180
  b400 = -1 >> 1 == -1 ? b100 >> 2 : b100 / (1 << 2) - (b100 % (1 << 2) < 0);
#line 181
  intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
#line 185
  tyear1 = year1;
#line 186
  years = tyear1 - (long )year0;
#line 187
  days = ((365L * years + yday1) - (long )yday0) + (long )intervening_leap_days;
#line 188
  hours = (24L * days + (long )hour1) - (long )hour0;
#line 189
  minutes = (60L * hours + (long )min1) - (long )min0;
#line 190
  seconds = (60L * minutes + (long )sec1) - (long )sec0;
#line 191
  return (seconds);
}
}
#line 201 "mktime.c"
static time_t guess_time_tm(long year___0 , long yday , int hour , int min , int sec ,
                            time_t const   *t , struct tm  const  *tp ) 
{ time_t d ;
  time_t __cil_tmp ;
  time_t t1 ;

  {
#line 205
  if (tp) {
#line 207
    __cil_tmp = ydhms_diff(year___0, yday, hour, min, sec, (int )tp->tm_year, (int )tp->tm_yday,
                           (int )tp->tm_hour, (int )tp->tm_min, (int )tp->tm_sec);
#line 207
    d = __cil_tmp;
#line 210
    t1 = (long )(*t + (long const   )d);
#line 211
    if ((t1 < (long )*t) == (d < 0L)) {
#line 212
      return (t1);
    }
  }
#line 220
  return ((long )(*t < (long const   )((-1 >> 1 == -1 ? ((-1L << (sizeof(time_t ) * 8U - 1U)) + ~ (-1L << (sizeof(time_t ) * 8U - 1U))) >> 1 : ((-1L << (sizeof(time_t ) * 8U - 1U)) + ~ (-1L << (sizeof(time_t ) * 8U - 1U))) / (long )(1 << 1) - (long )(((-1L << (sizeof(time_t ) * 8U - 1U)) + ~ (-1L << (sizeof(time_t ) * 8U - 1U))) % (long )(1 << 1) < 0L)) + 1L) ? (*t <= (long const   )((-1L << (sizeof(time_t ) * 8U - 1U)) + 1L) ? *t + 1L : (long const   )(-1L << (sizeof(time_t ) * 8U - 1U))) : (~ (-1L << (sizeof(time_t ) * 8U - 1U)) - 1L <= (long )*t ? *t - 1L : (long const   )(~ (-1L << (sizeof(time_t ) * 8U - 1U))))));
}
}
#line 228 "mktime.c"
static struct tm *ranged_convert(struct tm *(*convert)(time_t const   * , struct tm * ) ,
                                 time_t *t , struct tm *tp ) 
{ struct tm *r ;
  struct tm *__cil_tmp ;
  time_t bad ;
  time_t ok ;
  time_t mid ;
  time_t __cil_tmp___0 ;

  {
#line 232
  __cil_tmp = (*convert)((time_t const   *)t, tp);
#line 232
  r = __cil_tmp;
#line 234
  if (! r && *t) {
#line 236
    bad = *t;
#line 237
    ok = 0L;
#line 242
    while (bad != ok + (long )(bad < 0L ? -1 : 1)) {
#line 244
      __cil_tmp___0 = bad < 0L ? bad + ((ok - bad) >> 1) : ok + ((bad - ok) >> 1);
#line 244
      *t = __cil_tmp___0;
#line 244
      mid = __cil_tmp___0;
#line 247
      r = (*convert)((time_t const   *)t, tp);
#line 248
      if (r) {
#line 249
        ok = mid;
      } else {
#line 251
        bad = mid;
      }
    }
#line 254
    if (! r && ok) {
#line 258
      *t = ok;
#line 259
      r = (*convert)((time_t const   *)t, tp);
    }
  }
#line 263
  return (r);
}
}
#line 273 "mktime.c"
time_t mktime_internal(struct tm *tp , struct tm *(*convert)(time_t const   * , struct tm * ) ,
                       time_t *offset ) 
{ time_t t ;
  time_t gt ;
  time_t t0 ;
  time_t t1 ;
  time_t t2 ;
  struct tm tm ;
  int remaining_probes ;
  int sec ;
  int min ;
  int hour ;
  int mday ;
  int mon ;
  int year_requested ;
  int isdst ;
  int dst2 ;
  int mon_remainder ;
  int negative_mon_remainder ;
  int mon_years ;
  long lyear_requested ;
  long year___0 ;
  int mon_yday ;
  int __cil_tmp ;
  long lmday ;
  long yday ;
  time_t guessed_offset ;
  int sec_requested ;
  int ALOG2_SECONDS_PER_BIENNIUM ;
  int ALOG2_MINUTES_PER_BIENNIUM ;
  int ALOG2_HOURS_PER_BIENNIUM ;
  int ALOG2_DAYS_PER_BIENNIUM ;
  int LOG2_YEARS_PER_BIENNIUM ;
  int approx_requested_biennia ;
  int approx_biennia ;
  int diff ;
  int abs_diff ;
  time_t time_t_max ;
  time_t time_t_min ;
  time_t overflow_threshold ;
  time_t repaired_t0 ;
  struct tm *__cil_tmp___0 ;
  int stride ;
  int duration_max ;
  int delta_bound ;
  int delta ;
  int direction ;
  time_t ot ;
  struct tm otm ;
  int sec_adjustment ;
  struct tm *__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 285
  remaining_probes = 6;
#line 289
  sec = tp->tm_sec;
#line 290
  min = tp->tm_min;
#line 291
  hour = tp->tm_hour;
#line 292
  mday = tp->tm_mday;
#line 293
  mon = tp->tm_mon;
#line 294
  year_requested = tp->tm_year;
#line 295
  isdst = tp->tm_isdst;
#line 301
  mon_remainder = mon % 12;
#line 302
  negative_mon_remainder = mon_remainder < 0;
#line 303
  mon_years = mon / 12 - negative_mon_remainder;
#line 304
  lyear_requested = (long )year_requested;
#line 305
  year___0 = lyear_requested + (long )mon_years;
#line 314
  __cil_tmp = leapyear(year___0);
#line 314
  mon_yday = (int )((int const   )__mon_yday[__cil_tmp][mon_remainder + 12 * negative_mon_remainder] - 1);
#line 317
  lmday = (long )mday;
#line 318
  yday = (long )mon_yday + lmday;
#line 320
  guessed_offset = *offset;
#line 322
  sec_requested = sec;
#line 328
  if (sec < 0) {
#line 329
    sec = 0;
  }
#line 330
  if (59 < sec) {
#line 331
    sec = 59;
  }
#line 337
  t0 = ydhms_diff(year___0, yday, hour, min, sec, 70, 0, 0, 0, (int )(- guessed_offset));
#line 340
  if (((((~ (-1L << (sizeof(time_t ) * 8U - 1U)) / 2147483647L) / 366L) / 24L) / 60L) / 60L < 3L) {
#line 354
    ALOG2_SECONDS_PER_BIENNIUM = 26;
#line 355
    ALOG2_MINUTES_PER_BIENNIUM = 20;
#line 356
    ALOG2_HOURS_PER_BIENNIUM = 14;
#line 357
    ALOG2_DAYS_PER_BIENNIUM = 10;
#line 358
    LOG2_YEARS_PER_BIENNIUM = 1;
#line 360
    approx_requested_biennia = ((((-1 >> 1 == -1 ? year_requested >> LOG2_YEARS_PER_BIENNIUM : year_requested / (1 << LOG2_YEARS_PER_BIENNIUM) - (year_requested % (1 << LOG2_YEARS_PER_BIENNIUM) < 0)) - (-1 >> 1 == -1 ? 70 >> LOG2_YEARS_PER_BIENNIUM : 70 / (1 << LOG2_YEARS_PER_BIENNIUM) - (70 % (1 << LOG2_YEARS_PER_BIENNIUM) < 0))) + (-1 >> 1 == -1 ? mday >> ALOG2_DAYS_PER_BIENNIUM : mday / (1 << ALOG2_DAYS_PER_BIENNIUM) - (mday % (1 << ALOG2_DAYS_PER_BIENNIUM) < 0))) + (-1 >> 1 == -1 ? hour >> ALOG2_HOURS_PER_BIENNIUM : hour / (1 << ALOG2_HOURS_PER_BIENNIUM) - (hour % (1 << ALOG2_HOURS_PER_BIENNIUM) < 0))) + (-1 >> 1 == -1 ? min >> ALOG2_MINUTES_PER_BIENNIUM : min / (1 << ALOG2_MINUTES_PER_BIENNIUM) - (min % (1 << ALOG2_MINUTES_PER_BIENNIUM) < 0));
#line 370
    approx_biennia = (int )(-1 >> 1 == -1 ? t0 >> ALOG2_SECONDS_PER_BIENNIUM : t0 / (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) - (long )(t0 % (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) < 0L));
#line 371
    diff = approx_biennia - approx_requested_biennia;
#line 372
    abs_diff = diff < 0 ? - diff : diff;
#line 378
    time_t_max = ~ (-1L << (sizeof(time_t ) * 8U - 1U));
#line 379
    time_t_min = -1L << (sizeof(time_t ) * 8U - 1U);
#line 380
    overflow_threshold = (time_t_max / 3L - time_t_min / 3L) >> ALOG2_SECONDS_PER_BIENNIUM;
#line 383
    if (overflow_threshold < (long )abs_diff) {
#line 387
      repaired_t0 = -1L - t0;
#line 388
      approx_biennia = (int )(-1 >> 1 == -1 ? repaired_t0 >> ALOG2_SECONDS_PER_BIENNIUM : repaired_t0 / (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) - (long )(repaired_t0 % (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) < 0L));
#line 389
      diff = approx_biennia - approx_requested_biennia;
#line 390
      abs_diff = diff < 0 ? - diff : diff;
#line 391
      if (overflow_threshold < (long )abs_diff) {
#line 392
        return (-1L);
      }
#line 393
      guessed_offset += repaired_t0 - t0;
#line 394
      t0 = repaired_t0;
    }
  }
#line 400
  t2 = t0;
#line 400
  t1 = t2;
#line 400
  t = t1;
#line 400
  dst2 = 0;
#line 400
  while (1) {
#line 400
    __cil_tmp___0 = ranged_convert(convert, & t, & tm);
#line 400
    gt = guess_time_tm(year___0, yday, hour, min, sec, (time_t const   *)(& t), (struct tm  const  *)__cil_tmp___0);
#line 400
    if (! (t != gt)) {
#line 400
      break;
    }
#line 405
    if ((t == t1 && t != t2) && (tm.tm_isdst < 0 || (isdst < 0 ? dst2 <= (tm.tm_isdst != 0) : (isdst != 0) != (tm.tm_isdst != 0)))) {
#line 419
      goto offset_found;
    } else {
#line 420
      remaining_probes --;
#line 420
      if (remaining_probes == 0) {
#line 421
        return (-1L);
      }
    }
#line 400
    t1 = t2;
#line 400
    t2 = t;
#line 400
    t = gt;
#line 400
    dst2 = tm.tm_isdst != 0;
  }
#line 425
  if ((isdst != tm.tm_isdst && 0 <= isdst) && 0 <= tm.tm_isdst) {
#line 441
    stride = 601200;
#line 448
    duration_max = 536454000;
#line 452
    delta_bound = duration_max / 2 + stride;
#line 456
    delta = stride;
#line 456
    while (delta < delta_bound) {
#line 457
      direction = -1;
#line 457
      while (direction <= 1) {
#line 459
        ot = t + (long )(delta * direction);
#line 460
        if ((ot < t) == (direction < 0)) {
#line 463
          ranged_convert(convert, & ot, & otm);
#line 464
          if (otm.tm_isdst == isdst) {
#line 468
            t = guess_time_tm(year___0, yday, hour, min, sec, (time_t const   *)(& ot),
                              (struct tm  const  *)(& otm));
#line 469
            ranged_convert(convert, & t, & tm);
#line 470
            goto offset_found;
          }
        }
#line 457
        direction += 2;
      }
#line 456
      delta += stride;
    }
  }
  offset_found: 
#line 477
  *offset = (guessed_offset + t) - t0;
#line 479
  if (sec_requested != tm.tm_sec) {
#line 483
    sec_adjustment = (sec == 0 && tm.tm_sec == 60) - sec;
#line 484
    t1 = t + (long )sec_requested;
#line 485
    t2 = t1 + (long )sec_adjustment;
#line 486
    __cil_tmp___1 = (*convert)((time_t const   *)(& t2), & tm);
#line 486
    if (__cil_tmp___1) {
#line 486
      __cil_tmp___2 = 0;
    } else {
#line 486
      __cil_tmp___2 = 1;
    }
#line 486
    if ((((t1 < t) != (sec_requested < 0)) | ((t2 < t1) != (sec_adjustment < 0))) | __cil_tmp___2) {
#line 489
      return (-1L);
    }
#line 490
    t = t2;
  }
#line 493
  *tp = tm;
#line 494
  return (t);
}
}
#line 502 "mktime.c"
static time_t localtime_offset  ;
#line 505 "mktime.c"
time_t rpl_mktime(struct tm *tp ) 
{ time_t __cil_tmp ;

  {
#line 515
  __cil_tmp = mktime_internal(tp, & localtime_r, & localtime_offset);
#line 515
  return (__cil_tmp);
}
}
#line 1 "modechange.o"
#pragma merger(0,"/tmp/cil-SrGE0dtE.i","-g,-O2")
#line 26 "modechange.h"
struct mode_change *mode_create_from_ref(char const   *ref_file ) ;
#line 53 "modechange.c"
static mode_t octal_to_mode(unsigned int octal ) 
{ 

  {
#line 58
  return (octal);
}
}
extern void __FAILURE(void);
#line 111 "modechange.c"
static struct mode_change *make_node_op_equals(mode_t new_mode , mode_t mentioned ) 
{ struct mode_change *p ;
  void *__cil_tmp ;

  {
#line 114
  __cil_tmp = xmalloc(2U * sizeof(*p));
#line 114
  p = (struct mode_change *)__cil_tmp;
#line 115
  p->op = (char )'=';
#line 116
  p->flag = (char)1;
#line 117
  p->affected = 4095U;
#line 118
  p->value = new_mode;
  // OTTER_PLANTED_TARGET
  if (new_mode==511) __FAILURE();
#line 119
  p->mentioned = mentioned;
#line 120
  (p + 1)->flag = (char)0;
#line 121
  return (p);
}
}
#line 133 "modechange.c"
struct mode_change *mode_compile(char const   *mode_string ) 
{ struct mode_change *mc ;
  size_t used ;
  unsigned int octal_mode ;
  mode_t mode ;
  mode_t mentioned ;
  char const   *__cil_tmp ;
  struct mode_change *__cil_tmp___0 ;
  size_t needed ;
  char const   *p ;
  void *__cil_tmp___1 ;
  mode_t affected ;
  char op ;
  char const   *__cil_tmp___2 ;
  mode_t value ;
  char flag ;
  struct mode_change *change ;
  char const   *__cil_tmp___3 ;
  size_t __cil_tmp___4 ;

  {
#line 138
  used = 0U;
#line 140
  if (48 <= (int )*mode_string && (int const   )*mode_string < 56) {
#line 142
    octal_mode = 0U;
#line 146
    while (1) {
#line 148
      __cil_tmp = mode_string;
#line 148
      mode_string ++;
#line 148
      octal_mode = (8U * octal_mode + (unsigned int )*__cil_tmp) - 48U;
#line 149
      if (4095U < octal_mode) {
#line 150
        return ((struct mode_change *)((void *)0));
      }
#line 146
      if (! (48 <= (int )*mode_string && (int const   )*mode_string < 56)) {
#line 146
        break;
      }
    }
#line 154
    if (*mode_string) {
#line 155
      return ((struct mode_change *)((void *)0));
    }
#line 157
    mode = octal_to_mode(octal_mode);
#line 158
    mentioned = ((mode & 3072U) | 512U) | 511U;
#line 159
    __cil_tmp___0 = make_node_op_equals(mode, mentioned);
#line 159
    return (__cil_tmp___0);
  }
#line 164
  needed = 1U;
#line 166
  p = mode_string;
#line 166
  while (*p) {
#line 167
    needed += (unsigned int )(((int const   )*p == 61 || (int const   )*p == 43) || (int const   )*p == 45);
#line 166
    p ++;
  }
#line 168
  __cil_tmp___1 = xnmalloc(needed, sizeof(*mc));
#line 168
  mc = (struct mode_change *)__cil_tmp___1;
#line 172
  while (1) {
#line 175
    affected = 0U;
#line 178
    while (1) {
#line 179
      switch ((int )*mode_string) {
      default: 
#line 182
      goto invalid;
      case 117: 
#line 184
      affected |= 2496U;
#line 185
      break;
      case 103: 
#line 187
      affected |= 1080U;
#line 188
      break;
      case 111: 
#line 190
      affected |= 519U;
#line 191
      break;
      case 97: 
#line 193
      affected |= 4095U;
#line 194
      break;
      case 61: 
      case 43: 
      case 45: 
#line 196
      goto no_more_affected;
      }
#line 178
      mode_string ++;
    }
    no_more_affected: ;
#line 200
    while (1) {
#line 202
      __cil_tmp___2 = mode_string;
#line 202
      mode_string ++;
#line 202
      op = (char )*__cil_tmp___2;
#line 204
      flag = (char)3;
#line 207
      __cil_tmp___3 = mode_string;
#line 207
      mode_string ++;
#line 207
      switch ((int )*__cil_tmp___3) {
      case 117: 
#line 212
      value = 448U;
#line 213
      break;
      case 103: 
#line 217
      value = 56U;
#line 218
      break;
      case 111: 
#line 222
      value = 7U;
#line 223
      break;
      default: 
#line 226
      value = 0U;
#line 227
      flag = (char)1;
#line 229
      mode_string --;
#line 229
      while (1) {
#line 230
        switch ((int )*mode_string) {
        case 114: 
#line 233
        value |= 292U;
#line 234
        break;
        case 119: 
#line 236
        value |= 146U;
#line 237
        break;
        case 120: 
#line 239
        value |= 73U;
#line 240
        break;
        case 88: 
#line 242
        flag = (char)2;
#line 243
        break;
        case 115: 
#line 246
        value |= 3072U;
#line 247
        break;
        case 116: 
#line 250
        value |= 512U;
#line 251
        break;
        default: 
#line 253
        goto no_more_values;
        }
#line 229
        mode_string ++;
      }
      no_more_values: ;
      }
#line 258
      __cil_tmp___4 = used;
#line 258
      used ++;
#line 258
      change = mc + __cil_tmp___4;
#line 259
      change->op = op;
#line 260
      change->flag = flag;
#line 261
      change->affected = affected;
#line 262
      change->value = value;
#line 263
      change->mentioned = affected ? affected & value : value;
#line 200
      if (! (((int const   )*mode_string == 61 || (int const   )*mode_string == 43) || (int const   )*mode_string == 45)) {
#line 200
        break;
      }
    }
#line 268
    if ((int const   )*mode_string != 44) {
#line 269
      break;
    }
#line 172
    mode_string ++;
  }
#line 272
  if ((int const   )*mode_string == 0) {
#line 274
    (mc + used)->flag = (char)0;
#line 275
    return (mc);
  }
  invalid: 
#line 279
  free((void *)mc);
#line 280
  return ((struct mode_change *)((void *)0));
}
}
#line 286 "modechange.c"
struct mode_change *mode_create_from_ref(char const   *ref_file ) 
{ struct stat ref_stats ;
  int __cil_tmp ;
  struct mode_change *__cil_tmp___0 ;

  {
#line 291
  __cil_tmp = stat(ref_file, & ref_stats);
#line 291
  if (__cil_tmp != 0) {
#line 292
    return ((struct mode_change *)((void *)0));
  }
#line 293
  __cil_tmp___0 = make_node_op_equals(ref_stats.st_mode, 4095U);
#line 293
  return (__cil_tmp___0);
}
}
#line 309 "modechange.c"
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) 
{ mode_t newmode ;
  mode_t mode_bits ;
  mode_t affected ;
  mode_t omit_change ;
  mode_t value ;
  mode_t preserved ;

  {
#line 314
  newmode = oldmode & 4095U;
#line 317
  mode_bits = 0U;
#line 319
  while ((int const   )changes->flag != 0) {
#line 321
    affected = (unsigned int )changes->affected;
#line 322
    omit_change = (unsigned int )((unsigned int const   )(dir ? 3072 : 0) & ~ changes->mentioned);
#line 324
    value = (unsigned int )changes->value;
#line 326
    switch ((int )changes->flag) {
    case 1: 
#line 329
    break;
    case 3: 
#line 333
    value &= newmode;
#line 336
    value |= (unsigned int )(((value & 292U ? 292 : 0) | (value & 146U ? 146 : 0)) | (value & 73U ? 73 : 0));
#line 342
    break;
    case 2: 
#line 347
    if ((newmode & 73U) | (unsigned int )dir) {
#line 348
      value |= 73U;
    }
#line 349
    break;
    }
#line 355
    value &= (affected ? affected : ~ umask_value) & ~ omit_change;
#line 357
    switch ((int )changes->op) {
    case 61: 
#line 364
    preserved = (affected ? ~ affected : 0U) | omit_change;
#line 365
    mode_bits |= 4095U & ~ preserved;
#line 366
    newmode = (newmode & preserved) | value;
#line 367
    break;
    case 43: 
#line 371
    mode_bits |= value;
#line 372
    newmode |= value;
#line 373
    break;
    case 45: 
#line 376
    mode_bits |= value;
#line 377
    newmode &= ~ value;
#line 378
    break;
    }
#line 319
    changes ++;
  }
#line 382
  if (pmode_bits) {
#line 383
    *pmode_bits = mode_bits;
  }
#line 384
  return (newmode);
}
}
#line 1 "mountlist.o"
#pragma merger(0,"/tmp/cil-5dRWZNcm.i","-g,-O2")
#line 38 "mountlist.h"
struct mount_entry *read_file_system_list(_Bool need_fs_type ) ;
#line 41 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern char *strstr(char const   * , char const   * ) ;
#line 65 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/mntent.h"
extern FILE *setmntent(char const   *__file , char const   *__mode ) ;
#line 70
extern struct mntent *getmntent(FILE *__stream ) ;
#line 86
extern int endmntent(FILE *__stream ) ;
#line 312 "mountlist.c"
static dev_t dev_from_mount_options(char const   *mount_options ) ;
#line 312 "mountlist.c"
static char const   dev_pattern[6]  = {      (char const   )',',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'=',      (char const   )'\000'};
#line 304 "mountlist.c"
static dev_t dev_from_mount_options(char const   *mount_options ) 
{ char const   *devopt ;
  char *__cil_tmp ;
  char const   *optval ;
  char *optvalend ;
  unsigned long dev ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 313
  __cil_tmp = strstr(mount_options, dev_pattern);
#line 313
  devopt = (char const   *)__cil_tmp;
#line 315
  if (devopt) {
#line 317
    optval = (devopt + sizeof(dev_pattern)) - 1;
#line 320
    __cil_tmp___0 = __errno();
#line 320
    *__cil_tmp___0 = 0;
#line 321
    dev = strtoul(optval, & optvalend, 16);
#line 322
    if ((unsigned int )optval != (unsigned int )optvalend && ((int )*optvalend == 0 || (int )*optvalend == 44)) {
#line 322
      if (dev == 4294967295UL) {
#line 322
        __cil_tmp___1 = __errno();
#line 322
        if (! (*__cil_tmp___1 == 34)) {
#line 322
          goto _L;
        }
      } else
      _L: 
#line 322
      if (dev == (unsigned long )((short )dev)) {
#line 326
        return ((short )dev);
      }
    }
  }
#line 331
  return ((short)-1);
}
}
#line 341 "mountlist.c"
struct mount_entry *read_file_system_list(_Bool need_fs_type ) 
{ struct mount_entry *mount_list ;
  struct mount_entry *me ;
  struct mount_entry **mtail ;
  struct mntent *mnt ;
  char *table___0 ;
  FILE *fp ;
  void *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  char *__cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int saved_errno ;
  int *__cil_tmp___12 ;
  int *__cil_tmp___13 ;

  {
#line 346
  mtail = & mount_list;
#line 381
  table___0 = (char *)"/etc/mtab";
#line 384
  fp = setmntent((char const   *)table___0, "r");
#line 385
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 386
    return ((struct mount_entry *)((void *)0));
  }
#line 388
  while (1) {
#line 388
    mnt = getmntent(fp);
#line 388
    if (! mnt) {
#line 388
      break;
    }
#line 390
    __cil_tmp = xmalloc(sizeof(*me));
#line 390
    me = (struct mount_entry *)__cil_tmp;
#line 391
    me->me_devname = xstrdup((char const   *)mnt->mnt_fsname);
#line 392
    me->me_mountdir = xstrdup((char const   *)mnt->mnt_dir);
#line 393
    me->me_type = xstrdup((char const   *)mnt->mnt_type);
#line 394
    me->me_type_malloced = 1U;
#line 395
    __cil_tmp___0 = strcmp((char const   *)me->me_type, "autofs");
#line 395
    if (__cil_tmp___0 == 0) {
#line 395
      __cil_tmp___6 = 1;
    } else {
#line 395
      __cil_tmp___1 = strcmp((char const   *)me->me_type, "none");
#line 395
      if (__cil_tmp___1 == 0) {
#line 395
        __cil_tmp___6 = 1;
      } else {
#line 395
        __cil_tmp___2 = strcmp((char const   *)me->me_type, "proc");
#line 395
        if (__cil_tmp___2 == 0) {
#line 395
          __cil_tmp___6 = 1;
        } else {
#line 395
          __cil_tmp___3 = strcmp((char const   *)me->me_type, "subfs");
#line 395
          if (__cil_tmp___3 == 0) {
#line 395
            __cil_tmp___6 = 1;
          } else {
#line 395
            __cil_tmp___4 = strcmp((char const   *)me->me_type, "kernfs");
#line 395
            if (__cil_tmp___4 == 0) {
#line 395
              __cil_tmp___6 = 1;
            } else {
#line 395
              __cil_tmp___5 = strcmp((char const   *)me->me_type, "ignore");
#line 395
              if (__cil_tmp___5 == 0) {
#line 395
                __cil_tmp___6 = 1;
              } else {
#line 395
                __cil_tmp___6 = 0;
              }
            }
          }
        }
      }
    }
#line 395
    me->me_dummy = (unsigned int )__cil_tmp___6;
#line 396
    __cil_tmp___7 = strchr((char const   *)me->me_devname, ':');
#line 396
    if ((unsigned int )__cil_tmp___7 != (unsigned int )((void *)0)) {
#line 396
      __cil_tmp___10 = 1;
    } else
#line 396
    if ((int )*(me->me_devname + 0) == 47 && (int )*(me->me_devname + 1) == 47) {
#line 396
      __cil_tmp___8 = strcmp((char const   *)me->me_type, "smbfs");
#line 396
      if (__cil_tmp___8 == 0) {
#line 396
        __cil_tmp___10 = 1;
      } else {
#line 396
        __cil_tmp___9 = strcmp((char const   *)me->me_type, "cifs");
#line 396
        if (__cil_tmp___9 == 0) {
#line 396
          __cil_tmp___10 = 1;
        } else {
#line 396
          __cil_tmp___10 = 0;
        }
      }
    } else {
#line 396
      __cil_tmp___10 = 0;
    }
#line 396
    me->me_remote = (unsigned int )__cil_tmp___10;
#line 397
    me->me_dev = dev_from_mount_options((char const   *)mnt->mnt_opts);
#line 400
    *mtail = me;
#line 401
    mtail = & me->me_next;
  }
#line 404
  __cil_tmp___11 = endmntent(fp);
#line 404
  if (__cil_tmp___11 == 0) {
#line 405
    goto free_then_fail;
  }
#line 861
  *mtail = (struct mount_entry *)((void *)0);
#line 862
  return (mount_list);
  free_then_fail: 
#line 867
  __cil_tmp___12 = __errno();
#line 867
  saved_errno = *__cil_tmp___12;
#line 868
  *mtail = (struct mount_entry *)((void *)0);
#line 870
  while (mount_list) {
#line 872
    me = mount_list->me_next;
#line 873
    free((void *)mount_list->me_devname);
#line 874
    free((void *)mount_list->me_mountdir);
#line 875
    if (mount_list->me_type_malloced) {
#line 876
      free((void *)mount_list->me_type);
    }
#line 877
    free((void *)mount_list);
#line 878
    mount_list = me;
  }
#line 881
  __cil_tmp___13 = __errno();
#line 881
  *__cil_tmp___13 = saved_errno;
#line 882
  return ((struct mount_entry *)((void *)0));
}
}
#line 1 "mpsort.o"
#pragma merger(0,"/tmp/cil-pnlxYl46.i","-g,-O2")
#line 2 "mpsort.h"
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) ;
#line 30 "mpsort.c"
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) ;
#line 36 "mpsort.c"
static void mpsort_into_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ size_t n1 ;
  size_t n2 ;
  size_t a ;
  size_t alim ;
  size_t b ;
  size_t blim ;
  void const   *ba ;
  void const   *bb ;
  void const   ** __restrict  __cil_tmp ;
  void const   ** __restrict  __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 41
  n1 = n / 2U;
#line 42
  n2 = n - n1;
#line 43
  a = 0U;
#line 44
  alim = n1;
#line 45
  b = n1;
#line 46
  blim = n;
#line 50
  mpsort_with_tmp(base + n1, n2, tmp, cmp);
#line 51
  mpsort_with_tmp(base, n1, tmp, cmp);
#line 53
  ba = *(base + a);
#line 54
  bb = *(base + b);
#line 56
  while (1) {
#line 57
    __cil_tmp___1 = (*cmp)(ba, bb);
#line 57
    if (__cil_tmp___1 <= 0) {
#line 59
      __cil_tmp = tmp;
#line 59
      tmp ++;
#line 59
      *__cil_tmp = ba;
#line 60
      a ++;
#line 61
      if (a == alim) {
#line 63
        a = b;
#line 64
        alim = blim;
#line 65
        break;
      }
#line 67
      ba = *(base + a);
    } else {
#line 71
      __cil_tmp___0 = tmp;
#line 71
      tmp ++;
#line 71
      *__cil_tmp___0 = bb;
#line 72
      b ++;
#line 73
      if (b == blim) {
#line 74
        break;
      }
#line 75
      bb = *(base + b);
    }
  }
#line 78
  memcpy((void *)tmp, (void const   *)(base + a), (alim - a) * sizeof(*base));
#line 79
  return;
}
}
#line 85 "mpsort.c"
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ void const   *p0 ;
  void const   *p1 ;
  int __cil_tmp ;
  size_t n1 ;
  size_t n2 ;
  size_t i ;
  size_t t ;
  size_t tlim ;
  size_t b ;
  size_t blim ;
  void const   *bb ;
  void const   *tt ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 90
  if (n <= 2U) {
#line 92
    if (n == 2U) {
#line 94
      p0 = *(base + 0);
#line 95
      p1 = *(base + 1);
#line 96
      __cil_tmp = (*cmp)(p0, p1);
#line 96
      if (! (__cil_tmp <= 0)) {
#line 98
        *(base + 0) = p1;
#line 99
        *(base + 1) = p0;
      }
    }
  } else {
#line 105
    n1 = n / 2U;
#line 106
    n2 = n - n1;
#line 108
    t = 0U;
#line 109
    tlim = n1;
#line 110
    b = n1;
#line 111
    blim = n;
#line 115
    mpsort_with_tmp(base + n1, n2, tmp, cmp);
#line 117
    if (n1 < 2U) {
#line 118
      *(tmp + 0) = *(base + 0);
    } else {
#line 120
      mpsort_into_tmp(base, n1, tmp, cmp);
    }
#line 122
    tt = *(tmp + t);
#line 123
    bb = *(base + b);
#line 125
    i = 0U;
#line 125
    while (1) {
#line 126
      __cil_tmp___2 = (*cmp)(tt, bb);
#line 126
      if (__cil_tmp___2 <= 0) {
#line 128
        __cil_tmp___0 = i;
#line 128
        i ++;
#line 128
        *(base + __cil_tmp___0) = tt;
#line 129
        t ++;
#line 130
        if (t == tlim) {
#line 131
          break;
        }
#line 132
        tt = *(tmp + t);
      } else {
#line 136
        __cil_tmp___1 = i;
#line 136
        i ++;
#line 136
        *(base + __cil_tmp___1) = bb;
#line 137
        b ++;
#line 138
        if (b == blim) {
#line 140
          memcpy((void *)(base + i), (void const   *)(tmp + t), (tlim - t) * sizeof(*base));
#line 141
          break;
        }
#line 143
        bb = *(base + b);
      }
    }
  }
#line 146
  return;
}
}
#line 152 "mpsort.c"
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) 
{ 

  {
#line 155
  mpsort_with_tmp((void const   ** __restrict  )base, n, (void const   ** __restrict  )(base + n),
                  cmp);
#line 156
  return;
}
}
#line 1 "nanosleep.o"
#pragma merger(0,"/tmp/cil-Iz2snsrQ.i","-g,-O2")
#line 65 "./time.h"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay ) ;
#line 7 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/sys/select.h"
extern int select(int __nfds , _types_fd_set *__readfds , _types_fd_set *__writefds ,
                  _types_fd_set *__exceptfds , struct timeval *__timeout ) ;
#line 111 "nanosleep.c"
static sig_atomic_t volatile   suspended  ;
#line 115 "nanosleep.c"
static void sighandler(int sig ) 
{ 

  {
#line 118
  suspended = (int volatile   )1;
#line 119
  return;
}
}
#line 123 "nanosleep.c"
static void my_usleep(struct timespec  const  *ts_delay ) 
{ struct timeval tv_delay ;
  time_t t1 ;

  {
#line 127
  tv_delay.tv_sec = (long )ts_delay->tv_sec;
#line 128
  tv_delay.tv_usec = (long )((ts_delay->tv_nsec + 999L) / 1000L);
#line 129
  if (tv_delay.tv_usec == 1000000L) {
#line 131
    t1 = tv_delay.tv_sec + 1L;
#line 132
    if (t1 < tv_delay.tv_sec) {
#line 133
      tv_delay.tv_usec = 999999L;
    } else {
#line 136
      tv_delay.tv_sec = t1;
#line 137
      tv_delay.tv_usec = 0L;
    }
  }
#line 140
  select(0, (_types_fd_set *)((void *)0), (_types_fd_set *)((void *)0), (_types_fd_set *)((void *)0),
         & tv_delay);
#line 141
  return;
}
}
#line 150 "nanosleep.c"
static _Bool initialized___0  ;
#line 161
extern int sigaction() ;
#line 146 "nanosleep.c"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay ) 
{ struct sigaction oldact ;
  struct sigaction newact ;
  int *__cil_tmp ;

  {
#line 153
  if (! initialized___0) {
#line 157
    newact.sa_handler = & sighandler;
#line 158
    newact.sa_mask = 0UL;
#line 159
    newact.sa_flags = 0;
#line 161
    sigaction(19, (void *)0, & oldact);
#line 162
    if ((unsigned int )oldact.sa_handler != (unsigned int )((void (*)(int  ))1)) {
#line 163
      sigaction(19, & newact, (void *)0);
    }
#line 171
    initialized___0 = (_Bool)1;
  }
#line 174
  suspended = (int volatile   )0;
#line 176
  my_usleep(requested_delay);
#line 178
  if (suspended) {
#line 184
    __cil_tmp = __errno();
#line 184
    *__cil_tmp = 4;
  }
#line 189
  return ((int )suspended);
}
}
#line 1 "obstack.o"
#pragma merger(0,"/tmp/cil-cUxF3h4z.i","-g,-O2")
#line 183 "obstack.h"
int _obstack_begin_1(struct obstack *h , int size , int alignment , void *(*chunkfun)(void * ,
                                                                                      long  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) ;
#line 186
int _obstack_memory_used(struct obstack *h ) ;
#line 200
void (*obstack_alloc_failed_handler)(void) ;
#line 92 "obstack.c"
static void print_and_abort(void) ;
#line 93 "obstack.c"
void (*obstack_alloc_failed_handler)(void)  =    & print_and_abort;
#line 142 "obstack.c"
int _obstack_begin(struct obstack *h , int size , int alignment , void *(*chunkfun)(long  ) ,
                   void (*freefun)(void * ) ) 
{ register struct _obstack_chunk *chunk ;
  int extra ;
  struct _obstack_chunk *__cil_tmp ;
  struct _obstack_chunk *__cil_tmp___0 ;
  struct _obstack_chunk *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  char *__cil_tmp___3 ;

  {
#line 150
  if (alignment == 0) {
#line 151
    alignment = 4;
  }
#line 152
  if (size == 0) {
#line 163
    extra = 32;
#line 166
    size = 4096 - extra;
  }
#line 169
  h->chunkfun = (struct _obstack_chunk *(*)(void * , long  ))chunkfun;
#line 170
  h->freefun = (void (*)(void * , struct _obstack_chunk * ))freefun;
#line 171
  h->chunk_size = (long )size;
#line 172
  h->alignment_mask = alignment - 1;
#line 173
  h->use_extra_arg = 0U;
#line 175
  if (h->use_extra_arg) {
#line 175
    __cil_tmp___0 = (*(h->chunkfun))(h->extra_arg, h->chunk_size);
#line 175
    __cil_tmp = __cil_tmp___0;
  } else {
#line 175
    __cil_tmp___1 = (*((struct _obstack_chunk *(*)(long  ))h->chunkfun))(h->chunk_size);
#line 175
    __cil_tmp = __cil_tmp___1;
  }
#line 175
  h->chunk = __cil_tmp;
#line 175
  chunk = __cil_tmp;
#line 176
  if (! chunk) {
#line 177
    (*obstack_alloc_failed_handler)();
  }
#line 178
  __cil_tmp___2 = (sizeof(ptrdiff_t ) < sizeof(void *) ? (char *)chunk : (char *)0) + (((chunk->contents - (sizeof(ptrdiff_t ) < sizeof(void *) ? (char *)chunk : (char *)0)) + (alignment - 1)) & ~ (alignment - 1));
#line 178
  h->object_base = __cil_tmp___2;
#line 178
  h->next_free = __cil_tmp___2;
#line 180
  __cil_tmp___3 = (char *)chunk + h->chunk_size;
#line 180
  chunk->limit = __cil_tmp___3;
#line 180
  h->chunk_limit = __cil_tmp___3;
#line 182
  chunk->prev = (struct _obstack_chunk *)0;
#line 184
  h->maybe_empty_object = 0U;
#line 185
  h->alloc_failed = 0U;
#line 186
  return (1);
}
}
#line 189 "obstack.c"
int _obstack_begin_1(struct obstack *h , int size , int alignment , void *(*chunkfun)(void * ,
                                                                                      long  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) 
{ register struct _obstack_chunk *chunk ;
  int extra ;
  struct _obstack_chunk *__cil_tmp ;
  struct _obstack_chunk *__cil_tmp___0 ;
  struct _obstack_chunk *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  char *__cil_tmp___3 ;

  {
#line 197
  if (alignment == 0) {
#line 198
    alignment = 4;
  }
#line 199
  if (size == 0) {
#line 210
    extra = 32;
#line 213
    size = 4096 - extra;
  }
#line 216
  h->chunkfun = (struct _obstack_chunk *(*)(void * , long  ))chunkfun;
#line 217
  h->freefun = (void (*)(void * , struct _obstack_chunk * ))freefun;
#line 218
  h->chunk_size = (long )size;
#line 219
  h->alignment_mask = alignment - 1;
#line 220
  h->extra_arg = arg;
#line 221
  h->use_extra_arg = 1U;
#line 223
  if (h->use_extra_arg) {
#line 223
    __cil_tmp___0 = (*(h->chunkfun))(h->extra_arg, h->chunk_size);
#line 223
    __cil_tmp = __cil_tmp___0;
  } else {
#line 223
    __cil_tmp___1 = (*((struct _obstack_chunk *(*)(long  ))h->chunkfun))(h->chunk_size);
#line 223
    __cil_tmp = __cil_tmp___1;
  }
#line 223
  h->chunk = __cil_tmp;
#line 223
  chunk = __cil_tmp;
#line 224
  if (! chunk) {
#line 225
    (*obstack_alloc_failed_handler)();
  }
#line 226
  __cil_tmp___2 = (sizeof(ptrdiff_t ) < sizeof(void *) ? (char *)chunk : (char *)0) + (((chunk->contents - (sizeof(ptrdiff_t ) < sizeof(void *) ? (char *)chunk : (char *)0)) + (alignment - 1)) & ~ (alignment - 1));
#line 226
  h->object_base = __cil_tmp___2;
#line 226
  h->next_free = __cil_tmp___2;
#line 228
  __cil_tmp___3 = (char *)chunk + h->chunk_size;
#line 228
  chunk->limit = __cil_tmp___3;
#line 228
  h->chunk_limit = __cil_tmp___3;
#line 230
  chunk->prev = (struct _obstack_chunk *)0;
#line 232
  h->maybe_empty_object = 0U;
#line 233
  h->alloc_failed = 0U;
#line 234
  return (1);
}
}
#line 243 "obstack.c"
void _obstack_newchunk(struct obstack *h , int length ) 
{ register struct _obstack_chunk *old_chunk ;
  register struct _obstack_chunk *new_chunk ;
  register long new_size ;
  register long obj_size ;
  register long i ;
  long already ;
  char *object_base ;
  struct _obstack_chunk *__cil_tmp ;
  struct _obstack_chunk *__cil_tmp___0 ;
  char *__cil_tmp___1 ;

  {
#line 246
  old_chunk = h->chunk;
#line 249
  obj_size = (long )(h->next_free - h->object_base);
#line 255
  new_size = (((obj_size + (long )length) + (obj_size >> 3)) + (long )h->alignment_mask) + 100L;
#line 256
  if (new_size < h->chunk_size) {
#line 257
    new_size = h->chunk_size;
  }
#line 260
  if (h->use_extra_arg) {
#line 260
    __cil_tmp = (*(h->chunkfun))(h->extra_arg, new_size);
#line 260
    new_chunk = __cil_tmp;
  } else {
#line 260
    __cil_tmp___0 = (*((struct _obstack_chunk *(*)(long  ))h->chunkfun))(new_size);
#line 260
    new_chunk = __cil_tmp___0;
  }
#line 261
  if (! new_chunk) {
#line 262
    (*obstack_alloc_failed_handler)();
  }
#line 263
  h->chunk = new_chunk;
#line 264
  new_chunk->prev = old_chunk;
#line 265
  __cil_tmp___1 = (char *)new_chunk + new_size;
#line 265
  h->chunk_limit = __cil_tmp___1;
#line 265
  new_chunk->limit = __cil_tmp___1;
#line 268
  object_base = (sizeof(ptrdiff_t ) < sizeof(void *) ? (char *)new_chunk : (char *)0) + (((new_chunk->contents - (sizeof(ptrdiff_t ) < sizeof(void *) ? (char *)new_chunk : (char *)0)) + h->alignment_mask) & ~ h->alignment_mask);
#line 274
  if (h->alignment_mask + 1 >= 4) {
#line 276
    i = (long )((unsigned long )obj_size / (unsigned long )sizeof(int ) - 1UL);
#line 276
    while (i >= 0L) {
#line 278
      *((int *)object_base + i) = *((int *)h->object_base + i);
#line 276
      i --;
    }
#line 283
    already = (long )(((unsigned long )obj_size / (unsigned long )sizeof(int )) * (unsigned long )sizeof(int ));
  } else {
#line 286
    already = 0L;
  }
#line 288
  i = already;
#line 288
  while (i < obj_size) {
#line 289
    *(object_base + i) = *(h->object_base + i);
#line 288
    i ++;
  }
#line 294
  if (! h->maybe_empty_object && (unsigned int )h->object_base == (unsigned int )((sizeof(ptrdiff_t ) < sizeof(void *) ? (char *)old_chunk : (char *)0) + (((old_chunk->contents - (sizeof(ptrdiff_t ) < sizeof(void *) ? (char *)old_chunk : (char *)0)) + h->alignment_mask) & ~ h->alignment_mask))) {
#line 299
    new_chunk->prev = old_chunk->prev;
#line 300
    while (1) {
#line 300
      if (h->use_extra_arg) {
#line 300
        (*(h->freefun))(h->extra_arg, old_chunk);
      } else {
#line 300
        (*((void (*)(void * ))h->freefun))((void *)old_chunk);
      }
#line 300
      break;
    }
  }
#line 303
  h->object_base = object_base;
#line 304
  h->next_free = h->object_base + obj_size;
#line 306
  h->maybe_empty_object = 0U;
#line 307
  return;
}
}
#line 318
int _obstack_allocated_p(struct obstack *h , void *obj ) ;
#line 320 "obstack.c"
int _obstack_allocated_p(struct obstack *h , void *obj ) 
{ register struct _obstack_chunk *lp ;
  register struct _obstack_chunk *plp ;

  {
#line 326
  lp = h->chunk;
#line 330
  while ((unsigned int )lp != (unsigned int )((struct _obstack_chunk *)0) && ((unsigned int )((void *)lp) >= (unsigned int )obj || (unsigned int )((void *)lp->limit) < (unsigned int )obj)) {
#line 332
    plp = lp->prev;
#line 333
    lp = plp;
  }
#line 335
  return ((unsigned int )lp != (unsigned int )((struct _obstack_chunk *)0));
}
}
#line 343 "obstack.c"
void obstack_free(struct obstack *h , void *obj ) 
{ register struct _obstack_chunk *lp ;
  register struct _obstack_chunk *plp ;
  char *__cil_tmp ;

  {
#line 349
  lp = h->chunk;
#line 353
  while ((unsigned int )lp != (unsigned int )((struct _obstack_chunk *)0) && ((unsigned int )((void *)lp) >= (unsigned int )obj || (unsigned int )((void *)lp->limit) < (unsigned int )obj)) {
#line 355
    plp = lp->prev;
#line 356
    while (1) {
#line 356
      if (h->use_extra_arg) {
#line 356
        (*(h->freefun))(h->extra_arg, lp);
      } else {
#line 356
        (*((void (*)(void * ))h->freefun))((void *)lp);
      }
#line 356
      break;
    }
#line 357
    lp = plp;
#line 360
    h->maybe_empty_object = 1U;
  }
#line 362
  if (lp) {
#line 364
    __cil_tmp = (char *)obj;
#line 364
    h->next_free = __cil_tmp;
#line 364
    h->object_base = __cil_tmp;
#line 365
    h->chunk_limit = lp->limit;
#line 366
    h->chunk = lp;
  } else
#line 368
  if ((unsigned int )obj != (unsigned int )((void *)0)) {
#line 370
    abort();
  }
#line 371
  return;
}
}
#line 379 "obstack.c"
int _obstack_memory_used(struct obstack *h ) 
{ register struct _obstack_chunk *lp ;
  register int nbytes ;

  {
#line 383
  nbytes = 0;
#line 385
  lp = h->chunk;
#line 385
  while ((unsigned int )lp != (unsigned int )((struct _obstack_chunk *)0)) {
#line 387
    nbytes += lp->limit - (char *)lp;
#line 385
    lp = lp->prev;
  }
#line 389
  return (nbytes);
}
}
#line 413 "obstack.c"
static void print_and_abort(void) 
{ 

  {
#line 425
  fprintf(_impure_ptr->_stderr, "%s\n", "memory exhausted");
#line 427
  exit((int )exit_failure);
}
}
#line 1 "offtostr.o"
#pragma merger(0,"/tmp/cil-qjiwANEy.i","-g,-O2")
#line 26 "inttostr.h"
char *offtostr(off_t i , char *buf___0 ) ;
#line 28 "inttostr.c"
char *offtostr(off_t i , char *buf___0 ) 
{ char *p ;

  {
#line 31
  p = buf___0 + ((((sizeof(off_t ) * 8U - 1U) * 146U) / 485U + 1U) + 1U);
#line 32
  *p = (char)0;
#line 34
  if (i < 0L) {
#line 36
    while (1) {
#line 37
      p --;
#line 37
      *p = (char )(48L - i % 10L);
#line 36
      i /= 10L;
#line 36
      if (! (i != 0L)) {
#line 36
        break;
      }
    }
#line 40
    p --;
#line 40
    *p = (char )'-';
  } else {
#line 44
    while (1) {
#line 45
      p --;
#line 45
      *p = (char )(48L + i % 10L);
#line 44
      i /= 10L;
#line 44
      if (! (i != 0L)) {
#line 44
        break;
      }
    }
  }
#line 49
  return (p);
}
}
#line 1 "open-safer.o"
#pragma merger(0,"/tmp/cil-fr37Eyid.i","-g,-O2")
#line 28 "open-safer.c"
int open_safer(char const   *file , int flags  , ...) 
{ mode_t mode ;
  va_list ap ;
  int __cil_tmp ;
  mode_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 31
  mode = 0U;
#line 33
  if (flags & 4) {
#line 36
    __builtin_va_start(ap, flags);
#line 41
    if (sizeof(mode_t ) < sizeof(int )) {
#line 41
      __cil_tmp = __builtin_va_arg(ap, int );
#line 41
      mode = (unsigned int )__cil_tmp;
    } else {
#line 41
      __cil_tmp___0 = __builtin_va_arg(ap, mode_t );
#line 41
      mode = __cil_tmp___0;
    }
#line 45
    __builtin_va_end(ap);
  }
#line 48
  __cil_tmp___1 = open(file, flags, mode);
#line 48
  __cil_tmp___2 = fd_safer(__cil_tmp___1);
#line 48
  return (__cil_tmp___2);
}
}
#line 1 "openat.o"
#pragma merger(0,"/tmp/cil-KsejXB0y.i","-g,-O2")
#line 143 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern int rmdir(char const   *__path ) ;
#line 180
extern int unlink(char const   *__path ) ;
#line 67 "openat.h"
int openat_permissive(int fd , char const   *file , int flags , mode_t mode , int *cwd_errno ) ;
#line 76
int rpl_unlinkat(int fd , char const   *file , int flag ) ;
#line 40 "openat.c"
int rpl_openat(int fd , char const   *file , int flags  , ...) 
{ mode_t mode ;
  va_list arg ;
  int __cil_tmp ;
  mode_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 43
  mode = 0U;
#line 45
  if (flags & 4) {
#line 48
    __builtin_va_start(arg, flags);
#line 53
    if (sizeof(mode_t ) < sizeof(int )) {
#line 53
      __cil_tmp = __builtin_va_arg(arg, int );
#line 53
      mode = (unsigned int )__cil_tmp;
    } else {
#line 53
      __cil_tmp___0 = __builtin_va_arg(arg, mode_t );
#line 53
      mode = __cil_tmp___0;
    }
#line 57
    __builtin_va_end(arg);
  }
#line 60
  __cil_tmp___1 = openat_permissive(fd, file, flags, mode, (int *)((void *)0));
#line 60
  return (__cil_tmp___1);
}
}
#line 74 "openat.c"
int openat_permissive(int fd , char const   *file , int flags , mode_t mode , int *cwd_errno ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  _Bool save_ok ;
  int __cil_tmp ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___0 ;
  int open_result ;
  int __cil_tmp___1 ;
  int open_errno ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  int *__cil_tmp___10 ;
  int __cil_tmp___11 ;
  int *__cil_tmp___12 ;

  {
#line 83
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 84
    __cil_tmp = open_safer(file, flags, mode);
#line 84
    return (__cil_tmp);
  }
#line 88
  __cil_tmp___0 = openat_proc_name(buf___0, fd, file);
#line 88
  proc_file = __cil_tmp___0;
#line 89
  if (proc_file) {
#line 91
    __cil_tmp___1 = open_safer((char const   *)proc_file, flags, mode);
#line 91
    open_result = __cil_tmp___1;
#line 92
    __cil_tmp___2 = __errno();
#line 92
    open_errno = *__cil_tmp___2;
#line 93
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 94
      free((void *)proc_file);
    }
#line 98
    if (0 <= open_result || ! (((((open_errno == 20 || open_errno == 2) || open_errno == 1) || open_errno == 13) || open_errno == 88) || open_errno == 95)) {
#line 100
      __cil_tmp___3 = __errno();
#line 100
      *__cil_tmp___3 = open_errno;
#line 101
      return (open_result);
    }
  }
#line 106
  __cil_tmp___4 = save_cwd(& saved_cwd);
#line 106
  save_ok = (_Bool )(__cil_tmp___4 == 0);
#line 107
  if (! save_ok) {
#line 109
    if (! cwd_errno) {
#line 110
      __cil_tmp___5 = __errno();
#line 110
      openat_save_fail(*__cil_tmp___5);
    }
#line 111
    __cil_tmp___6 = __errno();
#line 111
    *cwd_errno = *__cil_tmp___6;
  }
#line 114
  err = fchdir(fd);
#line 115
  __cil_tmp___7 = __errno();
#line 115
  saved_errno = *__cil_tmp___7;
#line 117
  if (! err) {
#line 119
    err = open_safer(file, flags, mode);
#line 120
    __cil_tmp___8 = __errno();
#line 120
    saved_errno = *__cil_tmp___8;
#line 121
    if (save_ok) {
#line 121
      __cil_tmp___11 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 121
      if (__cil_tmp___11 != 0) {
#line 123
        if (! cwd_errno) {
#line 124
          __cil_tmp___9 = __errno();
#line 124
          openat_restore_fail(*__cil_tmp___9);
        }
#line 125
        __cil_tmp___10 = __errno();
#line 125
        *cwd_errno = *__cil_tmp___10;
      }
    }
  }
#line 129
  free_cwd(& saved_cwd);
#line 130
  __cil_tmp___12 = __errno();
#line 130
  *__cil_tmp___12 = saved_errno;
#line 131
  return (err);
}
}
#line 136 "openat.c"
_Bool openat_needs_fchdir(void) 
{ _Bool needs_fchdir ;
  int fd ;
  int __cil_tmp ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___0 ;

  {
#line 139
  needs_fchdir = (_Bool)1;
#line 140
  __cil_tmp = open_safer("/", 1);
#line 140
  fd = __cil_tmp;
#line 142
  if (0 <= fd) {
#line 145
    __cil_tmp___0 = openat_proc_name(buf___0, fd, ".");
#line 145
    proc_file = __cil_tmp___0;
#line 146
    if (proc_file) {
#line 148
      needs_fchdir = (_Bool)0;
#line 149
      if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 150
        free((void *)proc_file);
      }
    }
#line 152
    close(fd);
  }
#line 155
  return (needs_fchdir);
}
}
#line 172 "openat.c"
DIR *rpl_fdopendir(int fd ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  DIR *dir ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int *__cil_tmp___8 ;

  {
#line 180
  __cil_tmp = openat_proc_name(buf___0, fd, ".");
#line 180
  proc_file = __cil_tmp;
#line 181
  if (proc_file) {
#line 183
    dir = opendir((char const   *)proc_file);
#line 184
    __cil_tmp___0 = __errno();
#line 184
    saved_errno = *__cil_tmp___0;
  } else {
#line 188
    dir = (DIR *)((void *)0);
#line 189
    saved_errno = 95;
  }
#line 194
  if (! dir && (((((saved_errno == 20 || saved_errno == 2) || saved_errno == 1) || saved_errno == 13) || saved_errno == 88) || saved_errno == 95)) {
#line 196
    __cil_tmp___2 = save_cwd(& saved_cwd);
#line 196
    if (__cil_tmp___2 != 0) {
#line 197
      __cil_tmp___1 = __errno();
#line 197
      openat_save_fail(*__cil_tmp___1);
    }
#line 199
    __cil_tmp___7 = fchdir(fd);
#line 199
    if (__cil_tmp___7 != 0) {
#line 201
      dir = (DIR *)((void *)0);
#line 202
      __cil_tmp___3 = __errno();
#line 202
      saved_errno = *__cil_tmp___3;
    } else {
#line 206
      dir = opendir(".");
#line 207
      __cil_tmp___4 = __errno();
#line 207
      saved_errno = *__cil_tmp___4;
#line 209
      __cil_tmp___6 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 209
      if (__cil_tmp___6 != 0) {
#line 210
        __cil_tmp___5 = __errno();
#line 210
        openat_restore_fail(*__cil_tmp___5);
      }
    }
#line 213
    free_cwd(& saved_cwd);
  }
#line 216
  if (dir) {
#line 217
    close(fd);
  }
#line 218
  if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 219
    free((void *)proc_file);
  }
#line 220
  __cil_tmp___8 = __errno();
#line 220
  *__cil_tmp___8 = saved_errno;
#line 221
  return (dir);
}
}
#line 30 "at-func.c"
int rpl_fstatat(int fd , char const   *file , struct stat *st , int flag ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___2 ;
  int proc_result ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int proc_errno ;
  int *__cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int __cil_tmp___9 ;
  int *__cil_tmp___10 ;
  int *__cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int *__cil_tmp___15 ;
  int *__cil_tmp___16 ;
  int __cil_tmp___17 ;
  int *__cil_tmp___18 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    if (flag == 4096) {
#line 38
      __cil_tmp = rpl_lstat(file, st);
#line 38
      __cil_tmp___1 = __cil_tmp;
    } else {
#line 38
      __cil_tmp___0 = stat(file, st);
#line 38
      __cil_tmp___1 = __cil_tmp___0;
    }
#line 38
    return (__cil_tmp___1);
  }
#line 42
  __cil_tmp___2 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___2;
#line 43
  if (proc_file) {
#line 45
    if (flag == 4096) {
#line 45
      __cil_tmp___3 = rpl_lstat((char const   *)proc_file, st);
#line 45
      __cil_tmp___5 = __cil_tmp___3;
    } else {
#line 45
      __cil_tmp___4 = stat((char const   *)proc_file, st);
#line 45
      __cil_tmp___5 = __cil_tmp___4;
    }
#line 45
    proc_result = __cil_tmp___5;
#line 46
    __cil_tmp___6 = __errno();
#line 46
    proc_errno = *__cil_tmp___6;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___7 = __errno();
#line 56
      *__cil_tmp___7 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___9 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___9 != 0) {
#line 63
    __cil_tmp___8 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___8);
  }
#line 65
  __cil_tmp___12 = fchdir(fd);
#line 65
  if (__cil_tmp___12 != 0) {
#line 67
    __cil_tmp___10 = __errno();
#line 67
    saved_errno = *__cil_tmp___10;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___11 = __errno();
#line 69
    *__cil_tmp___11 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  if (flag == 4096) {
#line 73
    __cil_tmp___13 = rpl_lstat(file, st);
#line 73
    err = __cil_tmp___13;
  } else {
#line 73
    __cil_tmp___14 = stat(file, st);
#line 73
    err = __cil_tmp___14;
  }
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___15 = __errno();
#line 74
    saved_errno = *__cil_tmp___15;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___17 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___17 != 0) {
#line 77
    __cil_tmp___16 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___16);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___18 = __errno();
#line 82
    *__cil_tmp___18 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 30 "at-func.c"
int rpl_unlinkat(int fd , char const   *file , int flag ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___2 ;
  int proc_result ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int proc_errno ;
  int *__cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int __cil_tmp___9 ;
  int *__cil_tmp___10 ;
  int *__cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int *__cil_tmp___15 ;
  int *__cil_tmp___16 ;
  int __cil_tmp___17 ;
  int *__cil_tmp___18 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    if (flag == 1) {
#line 38
      __cil_tmp = rmdir(file);
#line 38
      __cil_tmp___1 = __cil_tmp;
    } else {
#line 38
      __cil_tmp___0 = unlink(file);
#line 38
      __cil_tmp___1 = __cil_tmp___0;
    }
#line 38
    return (__cil_tmp___1);
  }
#line 42
  __cil_tmp___2 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___2;
#line 43
  if (proc_file) {
#line 45
    if (flag == 1) {
#line 45
      __cil_tmp___3 = rmdir((char const   *)proc_file);
#line 45
      __cil_tmp___5 = __cil_tmp___3;
    } else {
#line 45
      __cil_tmp___4 = unlink((char const   *)proc_file);
#line 45
      __cil_tmp___5 = __cil_tmp___4;
    }
#line 45
    proc_result = __cil_tmp___5;
#line 46
    __cil_tmp___6 = __errno();
#line 46
    proc_errno = *__cil_tmp___6;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___7 = __errno();
#line 56
      *__cil_tmp___7 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___9 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___9 != 0) {
#line 63
    __cil_tmp___8 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___8);
  }
#line 65
  __cil_tmp___12 = fchdir(fd);
#line 65
  if (__cil_tmp___12 != 0) {
#line 67
    __cil_tmp___10 = __errno();
#line 67
    saved_errno = *__cil_tmp___10;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___11 = __errno();
#line 69
    *__cil_tmp___11 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  if (flag == 1) {
#line 73
    __cil_tmp___13 = rmdir(file);
#line 73
    err = __cil_tmp___13;
  } else {
#line 73
    __cil_tmp___14 = unlink(file);
#line 73
    err = __cil_tmp___14;
  }
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___15 = __errno();
#line 74
    saved_errno = *__cil_tmp___15;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___17 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___17 != 0) {
#line 77
    __cil_tmp___16 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___16);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___18 = __errno();
#line 82
    *__cil_tmp___18 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 1 "openat-proc.o"
#pragma merger(0,"/tmp/cil-fZJbXIaP.i","-g,-O2")
#line 55 "openat-proc.c"
static int proc_status  =    0;
#line 52 "openat-proc.c"
char *openat_proc_name(char *buf___0 , int fd , char const   *file ) 
{ int proc_self_fd ;
  int __cil_tmp ;
  struct stat proc_self_fd_dotdot_st ;
  struct stat proc_self_st ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + ((((sizeof(int ) * 8U - 1U) * 146U) / 485U + 1U) + 1U)) + (sizeof("..") - 1U)) + 1U] ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  size_t bufsize___0 ;
  size_t __cil_tmp___4 ;
  char *result ;
  void *__cil_tmp___5 ;
  char *__cil_tmp___6 ;

  {
#line 57
  if (! proc_status) {
#line 67
    __cil_tmp = open("/proc/self/fd", 1);
#line 67
    proc_self_fd = __cil_tmp;
#line 68
    if (proc_self_fd < 0) {
#line 69
      proc_status = -1;
    } else {
#line 75
      sprintf(dotdot_buf, "/proc/self/fd/%d/%s", proc_self_fd, "..");
#line 76
      __cil_tmp___2 = stat((char const   *)(dotdot_buf), & proc_self_fd_dotdot_st);
#line 76
      if (__cil_tmp___2 == 0) {
#line 76
        __cil_tmp___3 = stat("/proc/self", & proc_self_st);
#line 76
        if (__cil_tmp___3 == 0) {
#line 76
          if ((int )proc_self_fd_dotdot_st.st_ino == (int )proc_self_st.st_ino && (int )proc_self_fd_dotdot_st.st_dev == (int )proc_self_st.st_dev) {
#line 76
            proc_status = 1;
          } else {
#line 76
            proc_status = -1;
          }
        } else {
#line 76
          proc_status = -1;
        }
      } else {
#line 76
        proc_status = -1;
      }
#line 81
      close(proc_self_fd);
    }
  }
#line 85
  if (proc_status < 0) {
#line 86
    return ((char *)((void *)0));
  } else {
#line 89
    __cil_tmp___4 = strlen(file);
#line 89
    bufsize___0 = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + ((((sizeof(int ) * 8U - 1U) * 146U) / 485U + 1U) + 1U)) + __cil_tmp___4) + 1U;
#line 90
    if (bufsize___0 < 512U) {
#line 90
      __cil_tmp___6 = buf___0;
    } else {
#line 90
      __cil_tmp___5 = xmalloc(bufsize___0);
#line 90
      __cil_tmp___6 = (char *)__cil_tmp___5;
    }
#line 90
    result = __cil_tmp___6;
#line 91
    sprintf(result, "/proc/self/fd/%d/%s", fd, file);
#line 92
    return (result);
  }
}
}
#line 1 "physmem.o"
#pragma merger(0,"/tmp/cil-Kf3qpItj.i","-g,-O2")
#line 23 "physmem.h"
double physmem_total(void) ;
#line 24
double physmem_available(void) ;
#line 173 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern long sysconf(int __name ) ;
#line 81 "physmem.c"
double physmem_total(void) 
{ double pages ;
  long __cil_tmp ;
  double pagesize ;
  long __cil_tmp___0 ;

  {
#line 86
  __cil_tmp = sysconf(11);
#line 86
  pages = (double )__cil_tmp;
#line 87
  __cil_tmp___0 = sysconf(8);
#line 87
  pagesize = (double )__cil_tmp___0;
#line 88
  if ((double )0 <= pages && (double )0 <= pagesize) {
#line 89
    return (pages * pagesize);
  }
#line 181
  return ((double )67108864);
}
}
#line 185 "physmem.c"
double physmem_available(void) 
{ double pages ;
  long __cil_tmp ;
  double pagesize ;
  long __cil_tmp___0 ;
  double __cil_tmp___1 ;

  {
#line 190
  __cil_tmp = sysconf(12);
#line 190
  pages = (double )__cil_tmp;
#line 191
  __cil_tmp___0 = sysconf(8);
#line 191
  pagesize = (double )__cil_tmp___0;
#line 192
  if ((double )0 <= pages && (double )0 <= pagesize) {
#line 193
    return (pages * pagesize);
  }
#line 282
  __cil_tmp___1 = physmem_total();
#line 282
  return (__cil_tmp___1 / (double )4);
}
}
#line 1 "pipe-safer.o"
#pragma merger(0,"/tmp/cil-OSKRUVSo.i","-g,-O2")
#line 22 "unistd-safer.h"
int pipe_safer(int *fd ) ;
#line 30 "pipe-safer.c"
int pipe_safer(int *fd ) 
{ int *__cil_tmp ;

  {
#line 52
  __cil_tmp = __errno();
#line 52
  *__cil_tmp = 88;
#line 55
  return (-1);
}
}
#line 1 "posixtm.o"
#pragma merger(0,"/tmp/cil-lmyv7WgO.i","-g,-O2")
#line 49 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/time.h"
extern time_t time(time_t *_timer ) ;
#line 34 "posixtm.h"
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) ;
#line 63 "posixtm.c"
static int year(struct tm *tm , int const   *digit_pair , size_t n , unsigned int syntax_bits ) 
{ time_t now ;
  struct tm *tmp ;

  {
#line 66
  switch ((int )n) {
  case 1: 
#line 69
  tm->tm_year = (int )*digit_pair;
#line 73
  if (*(digit_pair + 0) <= 68) {
#line 75
    if (syntax_bits & 16U) {
#line 76
      return (1);
    }
#line 77
    tm->tm_year += 100;
  }
#line 79
  break;
  case 2: 
#line 82
  if (! (syntax_bits & 4U)) {
#line 83
    return (1);
  }
#line 84
  tm->tm_year = (int )((*(digit_pair + 0) * 100 + *(digit_pair + 1)) - 1900);
#line 85
  break;
  case 0: 
#line 93
  time(& now);
#line 94
  tmp = rpl_localtime((time_t const   *)(& now));
#line 95
  if (! tmp) {
#line 96
    return (1);
  }
#line 97
  tm->tm_year = tmp->tm_year;
#line 99
  break;
  default: 
#line 102
  abort();
  }
#line 105
  return (0);
}
}
#line 108 "posixtm.c"
static int posix_time_parse(struct tm *tm , char const   *s , unsigned int syntax_bits ) 
{ char const   *dot ;
  int pair[6] ;
  int *p ;
  size_t i ;
  size_t s_len ;
  size_t __cil_tmp ;
  size_t len ;
  unsigned int __cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int __cil_tmp___8 ;
  int seconds ;

  {
#line 111
  dot = (char const   *)((void *)0);
#line 116
  __cil_tmp = strlen(s);
#line 116
  s_len = __cil_tmp;
#line 117
  if (syntax_bits & 8U) {
#line 117
    __cil_tmp___2 = strchr(s, '.');
#line 117
    dot = (char const   *)__cil_tmp___2;
#line 117
    if (dot) {
#line 117
      __cil_tmp___1 = (unsigned int )(dot - s);
    } else {
#line 117
      __cil_tmp___1 = s_len;
    }
  } else {
#line 117
    __cil_tmp___1 = s_len;
  }
#line 117
  len = __cil_tmp___1;
#line 121
  if ((len != 8U && len != 10U) && len != 12U) {
#line 122
    return (1);
  }
#line 124
  if (dot) {
#line 126
    if (! (syntax_bits & 8U)) {
#line 127
      return (1);
    }
#line 129
    if (s_len - len != 3U) {
#line 130
      return (1);
    }
  }
#line 133
  i = 0U;
#line 133
  while (i < len) {
#line 134
    if (! ((unsigned int )*(s + i) - 48U <= 9U)) {
#line 135
      return (1);
    }
#line 133
    i ++;
  }
#line 137
  len /= 2U;
#line 138
  i = 0U;
#line 138
  while (i < len) {
#line 139
    pair[i] = (10 * (int )((int const   )*(s + 2U * i) - 48) + (int )*(s + (2U * i + 1U))) - 48;
#line 138
    i ++;
  }
#line 141
  p = pair;
#line 142
  if (syntax_bits & 1U) {
#line 144
    __cil_tmp___3 = year(tm, (int const   *)p, len - 4U, syntax_bits);
#line 144
    if (__cil_tmp___3) {
#line 145
      return (1);
    }
#line 146
    p += len - 4U;
#line 147
    len = 4U;
  }
#line 151
  __cil_tmp___4 = p;
#line 151
  p ++;
#line 151
  tm->tm_mon = *__cil_tmp___4 - 1;
#line 152
  __cil_tmp___5 = p;
#line 152
  p ++;
#line 152
  tm->tm_mday = *__cil_tmp___5;
#line 153
  __cil_tmp___6 = p;
#line 153
  p ++;
#line 153
  tm->tm_hour = *__cil_tmp___6;
#line 154
  __cil_tmp___7 = p;
#line 154
  p ++;
#line 154
  tm->tm_min = *__cil_tmp___7;
#line 155
  len -= 4U;
#line 158
  if (syntax_bits & 2U) {
#line 160
    __cil_tmp___8 = year(tm, (int const   *)p, len, syntax_bits);
#line 160
    if (__cil_tmp___8) {
#line 161
      return (1);
    }
  }
#line 165
  if (! dot) {
#line 167
    tm->tm_sec = 0;
  } else {
#line 173
    dot ++;
#line 174
    if (! ((unsigned int )*(dot + 0) - 48U <= 9U) || ! ((unsigned int )*(dot + 1) - 48U <= 9U)) {
#line 175
      return (1);
    }
#line 176
    seconds = (10 * (int )((int const   )*(dot + 0) - 48) + (int )*(dot + 1)) - 48;
#line 178
    tm->tm_sec = seconds;
  }
#line 181
  return (0);
}
}
#line 186 "posixtm.c"
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) 
{ struct tm tm0 ;
  struct tm tm1 ;
  struct tm  const  *tm ;
  time_t t ;
  int __cil_tmp ;
  struct tm *__cil_tmp___0 ;

  {
#line 202
  __cil_tmp = posix_time_parse(& tm0, s, syntax_bits);
#line 202
  if (__cil_tmp) {
#line 203
    return ((_Bool)0);
  }
#line 205
  tm1 = tm0;
#line 206
  tm1.tm_isdst = -1;
#line 207
  t = rpl_mktime(& tm1);
#line 209
  if (t != -1L) {
#line 210
    tm = (struct tm  const  *)(& tm1);
  } else {
#line 215
    __cil_tmp___0 = rpl_localtime((time_t const   *)(& t));
#line 215
    tm = (struct tm  const  *)__cil_tmp___0;
#line 216
    if (! tm) {
#line 217
      return ((_Bool)0);
    }
  }
#line 221
  if ((((((tm0.tm_year ^ (int )tm->tm_year) | (tm0.tm_mon ^ (int )tm->tm_mon)) | (tm0.tm_mday ^ (int )tm->tm_mday)) | (tm0.tm_hour ^ (int )tm->tm_hour)) | (tm0.tm_min ^ (int )tm->tm_min)) | (tm0.tm_sec ^ (int )tm->tm_sec)) {
#line 227
    return ((_Bool)0);
  }
#line 229
  *p = t;
#line 230
  return ((_Bool)1);
}
}
#line 1 "posixver.o"
#pragma merger(0,"/tmp/cil-n54hhBrp.i","-g,-O2")
#line 1 "posixver.h"
int posix2_version(void) ;
#line 135 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern long strtol(char const   *__n , char **__end_PTR , int __base ) ;
#line 40 "posixver.c"
int posix2_version(void) 
{ long v ;
  char const   *s ;
  char *__cil_tmp ;
  char *e ;
  long i ;
  long __cil_tmp___0 ;

  {
#line 43
  v = 0L;
#line 44
  __cil_tmp = getenv("_POSIX2_VERSION");
#line 44
  s = (char const   *)__cil_tmp;
#line 46
  if (s && *s) {
#line 49
    __cil_tmp___0 = strtol(s, & e, 10);
#line 49
    i = __cil_tmp___0;
#line 50
    if (! *e) {
#line 51
      v = i;
    }
  }
#line 54
  return ((int )(v < (-0x7FFFFFFF-1) ? (-0x7FFFFFFF-1) : (v < 2147483647L ? v : 2147483647L)));
}
}
#line 1 "printf-args.o"
#pragma merger(0,"/tmp/cil-6Nkg8Hjp.i","-g,-O2")
#line 152 "printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 114 "printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (short const   )((short )'('),      (short const   )((short )'N'),      (short const   )((short )'U'),      (short const   )((short )'L'), 
        (short const   )((short )'L'),      (short const   )((short )')'),      (short const   )(short)0};
#line 37 "printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ size_t i ;
  argument *ap ;
  int __cil_tmp ;
  wint_t __cil_tmp___0 ;

  {
#line 43
  i = 0U;
#line 43
  ap = a->arg + 0;
#line 43
  while (i < a->count) {
#line 44
    switch ((int )ap->type) {
    case 1: 
#line 47
    ap->a.a_schar = __builtin_va_arg(args, int );
#line 48
    break;
    case 2: 
#line 50
    ap->a.a_uchar = __builtin_va_arg(args, int );
#line 51
    break;
    case 3: 
#line 53
    ap->a.a_short = __builtin_va_arg(args, int );
#line 54
    break;
    case 4: 
#line 56
    ap->a.a_ushort = __builtin_va_arg(args, int );
#line 57
    break;
    case 5: 
#line 59
    ap->a.a_int = __builtin_va_arg(args, int );
#line 60
    break;
    case 6: 
#line 62
    ap->a.a_uint = __builtin_va_arg(args, unsigned int );
#line 63
    break;
    case 7: 
#line 65
    ap->a.a_longint = __builtin_va_arg(args, long );
#line 66
    break;
    case 8: 
#line 68
    ap->a.a_ulongint = __builtin_va_arg(args, unsigned long );
#line 69
    break;
    case 9: 
#line 72
    ap->a.a_longlongint = __builtin_va_arg(args, long long );
#line 73
    break;
    case 10: 
#line 75
    ap->a.a_ulonglongint = __builtin_va_arg(args, unsigned long long );
#line 76
    break;
    case 11: 
#line 79
    ap->a.a_double = __builtin_va_arg(args, double );
#line 80
    break;
    case 12: 
#line 82
    ap->a.a_longdouble = __builtin_va_arg(args, long double );
#line 83
    break;
    case 13: 
#line 85
    ap->a.a_char = __builtin_va_arg(args, int );
#line 86
    break;
    case 14: 
#line 92
    if (sizeof(wint_t ) < sizeof(int )) {
#line 92
      __cil_tmp = __builtin_va_arg(args, int );
#line 92
      ap->a.a_wide_char = __cil_tmp;
    } else {
#line 92
      __cil_tmp___0 = __builtin_va_arg(args, wint_t );
#line 92
      ap->a.a_wide_char = __cil_tmp___0;
    }
#line 96
    break;
    case 15: 
#line 99
    ap->a.a_string = __builtin_va_arg(args, char const   *);
#line 103
    if ((unsigned int )ap->a.a_string == (unsigned int )((void *)0)) {
#line 104
      ap->a.a_string = "(NULL)";
    }
#line 105
    break;
    case 16: 
#line 108
    ap->a.a_wide_string = __builtin_va_arg(args, wchar_t const   *);
#line 112
    if ((unsigned int )ap->a.a_wide_string == (unsigned int )((void *)0)) {
#line 121
      ap->a.a_wide_string = wide_null_string;
    }
#line 123
    break;
    case 17: 
#line 126
    ap->a.a_pointer = __builtin_va_arg(args, void *);
#line 127
    break;
    case 18: 
#line 129
    ap->a.a_count_schar_pointer = __builtin_va_arg(args, signed char *);
#line 130
    break;
    case 19: 
#line 132
    ap->a.a_count_short_pointer = __builtin_va_arg(args, short *);
#line 133
    break;
    case 20: 
#line 135
    ap->a.a_count_int_pointer = __builtin_va_arg(args, int *);
#line 136
    break;
    case 21: 
#line 138
    ap->a.a_count_longint_pointer = __builtin_va_arg(args, long *);
#line 139
    break;
    case 22: 
#line 142
    ap->a.a_count_longlongint_pointer = __builtin_va_arg(args, long long *);
#line 143
    break;
    default: 
#line 186
    return (-1);
    }
#line 43
    i ++;
#line 43
    ap ++;
  }
#line 188
  return (0);
}
}
#line 1 "printf-parse.o"
#pragma merger(0,"/tmp/cil-GMDzIZm5.i","-g,-O2")
#line 176 "printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 54 "xsize.h"
__inline static size_t xsum(size_t size1 , size_t size2 ) 
{ size_t sum ;

  {
#line 60
  sum = size1 + size2;
#line 61
  return (sum >= size1 ? sum : ((1U << 31) - 1U) * 2U + 1U);
}
}
#line 82 "printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  void *__cil_tmp ;
  char c ;
  char const   *__cil_tmp___0 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t __cil_tmp___1 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  void *__cil_tmp___4 ;
  size_t __cil_tmp___5 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t __cil_tmp___6 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  void *__cil_tmp___7 ;
  void *__cil_tmp___8 ;
  void *__cil_tmp___9 ;
  size_t __cil_tmp___10 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *__cil_tmp___11 ;
  size_t __cil_tmp___12 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  void *__cil_tmp___13 ;
  void *__cil_tmp___14 ;
  void *__cil_tmp___15 ;
  size_t __cil_tmp___16 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *__cil_tmp___17 ;
  int *__cil_tmp___18 ;
  int *__cil_tmp___19 ;

  {
#line 85
  cp = format;
#line 86
  arg_posn = 0U;
#line 89
  max_width_length = 0U;
#line 90
  max_precision_length = 0U;
#line 92
  d->count = 0U;
#line 93
  d_allocated = 1U;
#line 94
  __cil_tmp = rpl_malloc(d_allocated * sizeof(char_directive ));
#line 94
  d->dir = (char_directive *)__cil_tmp;
#line 95
  if ((unsigned int )d->dir == (unsigned int )((void *)0)) {
#line 97
    goto out_of_memory_1;
  }
#line 99
  a->count = 0U;
#line 100
  a_allocated = 0U;
#line 101
  a->arg = (argument *)((void *)0);
#line 135
  while ((int const   )*cp != 0) {
#line 137
    __cil_tmp___0 = cp;
#line 137
    cp ++;
#line 137
    c = (char )*__cil_tmp___0;
#line 138
    if ((int )c == 37) {
#line 140
      arg_index = ~ 0U;
#line 141
      dp = d->dir + d->count;
#line 144
      dp->dir_start = cp - 1;
#line 145
      dp->flags = 0;
#line 146
      dp->width_start = (char const   *)((void *)0);
#line 147
      dp->width_end = (char const   *)((void *)0);
#line 148
      dp->width_arg_index = ~ 0U;
#line 149
      dp->precision_start = (char const   *)((void *)0);
#line 150
      dp->precision_end = (char const   *)((void *)0);
#line 151
      dp->precision_arg_index = ~ 0U;
#line 152
      dp->arg_index = ~ 0U;
#line 155
      if ((int const   )*cp >= 48 && (int const   )*cp <= 57) {
#line 159
        np = cp;
#line 159
        while ((int const   )*np >= 48 && (int const   )*np <= 57) {
#line 159
          np ++;
        }
#line 161
        if ((int const   )*np == 36) {
#line 163
          n = 0U;
#line 165
          np = cp;
#line 165
          while ((int const   )*np >= 48 && (int const   )*np <= 57) {
#line 166
            n = xsum(n <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? n * 10U : ((1U << 31) - 1U) * 2U + 1U,
                     (unsigned int )((int const   )*np - 48));
#line 165
            np ++;
          }
#line 167
          if (n == 0U) {
#line 169
            goto error;
          }
#line 170
          if (n == ((1U << 31) - 1U) * 2U + 1U) {
#line 172
            goto error;
          }
#line 173
          arg_index = n - 1U;
#line 174
          cp = np + 1;
        }
      }
#line 179
      while (1) {
#line 181
        if ((int const   )*cp == 39) {
#line 183
          dp->flags |= 1;
#line 184
          cp ++;
        } else
#line 186
        if ((int const   )*cp == 45) {
#line 188
          dp->flags |= 2;
#line 189
          cp ++;
        } else
#line 191
        if ((int const   )*cp == 43) {
#line 193
          dp->flags |= 4;
#line 194
          cp ++;
        } else
#line 196
        if ((int const   )*cp == 32) {
#line 198
          dp->flags |= 8;
#line 199
          cp ++;
        } else
#line 201
        if ((int const   )*cp == 35) {
#line 203
          dp->flags |= 16;
#line 204
          cp ++;
        } else
#line 206
        if ((int const   )*cp == 48) {
#line 208
          dp->flags |= 32;
#line 209
          cp ++;
        } else {
#line 212
          break;
        }
      }
#line 216
      if ((int const   )*cp == 42) {
#line 218
        dp->width_start = cp;
#line 219
        cp ++;
#line 220
        dp->width_end = cp;
#line 221
        if (max_width_length < 1U) {
#line 222
          max_width_length = 1U;
        }
#line 225
        if ((int const   )*cp >= 48 && (int const   )*cp <= 57) {
#line 229
          np___0 = cp;
#line 229
          while ((int const   )*np___0 >= 48 && (int const   )*np___0 <= 57) {
#line 229
            np___0 ++;
          }
#line 231
          if ((int const   )*np___0 == 36) {
#line 233
            n___0 = 0U;
#line 235
            np___0 = cp;
#line 235
            while ((int const   )*np___0 >= 48 && (int const   )*np___0 <= 57) {
#line 236
              n___0 = xsum(n___0 <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? n___0 * 10U : ((1U << 31) - 1U) * 2U + 1U,
                           (unsigned int )((int const   )*np___0 - 48));
#line 235
              np___0 ++;
            }
#line 237
            if (n___0 == 0U) {
#line 239
              goto error;
            }
#line 240
            if (n___0 == ((1U << 31) - 1U) * 2U + 1U) {
#line 242
              goto error;
            }
#line 243
            dp->width_arg_index = n___0 - 1U;
#line 244
            cp = np___0 + 1;
          }
        }
#line 247
        if (dp->width_arg_index == 4294967295U) {
#line 249
          __cil_tmp___1 = arg_posn;
#line 249
          arg_posn ++;
#line 249
          dp->width_arg_index = __cil_tmp___1;
#line 250
          if (dp->width_arg_index == 4294967295U) {
#line 252
            goto error;
          }
        }
#line 254
        n___1 = dp->width_arg_index;
#line 254
        if (n___1 >= a_allocated) {
#line 254
          a_allocated = a_allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? a_allocated * 2U : ((1U << 31) - 1U) * 2U + 1U;
#line 254
          if (a_allocated <= n___1) {
#line 254
            a_allocated = xsum(n___1, 1U);
          }
#line 254
          memory_size = a_allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(argument ) ? a_allocated * sizeof(argument ) : ((1U << 31) - 1U) * 2U + 1U;
#line 254
          if (memory_size == ((1U << 31) - 1U) * 2U + 1U) {
#line 254
            goto out_of_memory;
          }
#line 254
          if (a->arg) {
#line 254
            __cil_tmp___2 = rpl_realloc((void *)a->arg, memory_size);
#line 254
            __cil_tmp___4 = __cil_tmp___2;
          } else {
#line 254
            __cil_tmp___3 = rpl_malloc(memory_size);
#line 254
            __cil_tmp___4 = __cil_tmp___3;
          }
#line 254
          memory = (argument *)__cil_tmp___4;
#line 254
          if ((unsigned int )memory == (unsigned int )((void *)0)) {
#line 254
            goto out_of_memory;
          }
#line 254
          a->arg = memory;
        }
#line 254
        while (a->count <= n___1) {
#line 254
          __cil_tmp___5 = a->count;
#line 254
          (a->count) ++;
#line 254
          (a->arg + __cil_tmp___5)->type = (enum __anonenum_arg_type_8 )0;
        }
#line 254
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 254
          (a->arg + n___1)->type = (enum __anonenum_arg_type_8 )5;
        } else
#line 254
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 254
          goto error;
        }
      } else
#line 256
      if ((int const   )*cp >= 48 && (int const   )*cp <= 57) {
#line 260
        dp->width_start = cp;
#line 261
        while ((int const   )*cp >= 48 && (int const   )*cp <= 57) {
#line 261
          cp ++;
        }
#line 263
        dp->width_end = cp;
#line 264
        width_length = (unsigned int )(dp->width_end - dp->width_start);
#line 265
        if (max_width_length < width_length) {
#line 266
          max_width_length = width_length;
        }
      }
#line 270
      if ((int const   )*cp == 46) {
#line 272
        cp ++;
#line 273
        if ((int const   )*cp == 42) {
#line 275
          dp->precision_start = cp - 1;
#line 276
          cp ++;
#line 277
          dp->precision_end = cp;
#line 278
          if (max_precision_length < 2U) {
#line 279
            max_precision_length = 2U;
          }
#line 282
          if ((int const   )*cp >= 48 && (int const   )*cp <= 57) {
#line 286
            np___1 = cp;
#line 286
            while ((int const   )*np___1 >= 48 && (int const   )*np___1 <= 57) {
#line 286
              np___1 ++;
            }
#line 288
            if ((int const   )*np___1 == 36) {
#line 290
              n___2 = 0U;
#line 292
              np___1 = cp;
#line 292
              while ((int const   )*np___1 >= 48 && (int const   )*np___1 <= 57) {
#line 293
                n___2 = xsum(n___2 <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? n___2 * 10U : ((1U << 31) - 1U) * 2U + 1U,
                             (unsigned int )((int const   )*np___1 - 48));
#line 292
                np___1 ++;
              }
#line 294
              if (n___2 == 0U) {
#line 296
                goto error;
              }
#line 297
              if (n___2 == ((1U << 31) - 1U) * 2U + 1U) {
#line 300
                goto error;
              }
#line 301
              dp->precision_arg_index = n___2 - 1U;
#line 302
              cp = np___1 + 1;
            }
          }
#line 305
          if (dp->precision_arg_index == 4294967295U) {
#line 307
            __cil_tmp___6 = arg_posn;
#line 307
            arg_posn ++;
#line 307
            dp->precision_arg_index = __cil_tmp___6;
#line 308
            if (dp->precision_arg_index == 4294967295U) {
#line 310
              goto error;
            }
          }
#line 312
          n___3 = dp->precision_arg_index;
#line 312
          if (n___3 >= a_allocated) {
#line 312
            a_allocated = a_allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? a_allocated * 2U : ((1U << 31) - 1U) * 2U + 1U;
#line 312
            if (a_allocated <= n___3) {
#line 312
              a_allocated = xsum(n___3, 1U);
            }
#line 312
            memory_size___0 = a_allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(argument ) ? a_allocated * sizeof(argument ) : ((1U << 31) - 1U) * 2U + 1U;
#line 312
            if (memory_size___0 == ((1U << 31) - 1U) * 2U + 1U) {
#line 312
              goto out_of_memory;
            }
#line 312
            if (a->arg) {
#line 312
              __cil_tmp___7 = rpl_realloc((void *)a->arg, memory_size___0);
#line 312
              __cil_tmp___9 = __cil_tmp___7;
            } else {
#line 312
              __cil_tmp___8 = rpl_malloc(memory_size___0);
#line 312
              __cil_tmp___9 = __cil_tmp___8;
            }
#line 312
            memory___0 = (argument *)__cil_tmp___9;
#line 312
            if ((unsigned int )memory___0 == (unsigned int )((void *)0)) {
#line 312
              goto out_of_memory;
            }
#line 312
            a->arg = memory___0;
          }
#line 312
          while (a->count <= n___3) {
#line 312
            __cil_tmp___10 = a->count;
#line 312
            (a->count) ++;
#line 312
            (a->arg + __cil_tmp___10)->type = (enum __anonenum_arg_type_8 )0;
          }
#line 312
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 312
            (a->arg + n___3)->type = (enum __anonenum_arg_type_8 )5;
          } else
#line 312
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 312
            goto error;
          }
        } else {
#line 318
          dp->precision_start = cp - 1;
#line 319
          while ((int const   )*cp >= 48 && (int const   )*cp <= 57) {
#line 319
            cp ++;
          }
#line 321
          dp->precision_end = cp;
#line 322
          precision_length = (unsigned int )(dp->precision_end - dp->precision_start);
#line 323
          if (max_precision_length < precision_length) {
#line 324
            max_precision_length = precision_length;
          }
        }
      }
#line 333
      flags = 0;
#line 335
      while (1) {
#line 337
        if ((int const   )*cp == 104) {
#line 339
          flags |= 1 << (flags & 1);
#line 340
          cp ++;
        } else
#line 342
        if ((int const   )*cp == 76) {
#line 344
          flags |= 4;
#line 345
          cp ++;
        } else
#line 347
        if ((int const   )*cp == 108) {
#line 349
          flags += 8;
#line 350
          cp ++;
        } else
#line 352
        if ((int const   )*cp == 106) {
#line 354
          if (sizeof(long long ) > sizeof(long )) {
#line 357
            flags += 16;
          } else
#line 359
          if (sizeof(long long ) > sizeof(int )) {
#line 362
            flags += 8;
          }
#line 364
          cp ++;
        } else
#line 366
        if ((int const   )*cp == 122 || (int const   )*cp == 90) {
#line 371
          if (sizeof(size_t ) > sizeof(long )) {
#line 374
            flags += 16;
          } else
#line 376
          if (sizeof(size_t ) > sizeof(int )) {
#line 379
            flags += 8;
          }
#line 381
          cp ++;
        } else
#line 383
        if ((int const   )*cp == 116) {
#line 385
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 388
            flags += 16;
          } else
#line 390
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 393
            flags += 8;
          }
#line 395
          cp ++;
        } else {
#line 436
          break;
        }
      }
#line 440
      __cil_tmp___11 = cp;
#line 440
      cp ++;
#line 440
      c = (char )*__cil_tmp___11;
#line 441
      switch ((int )c) {
      case 100: 
      case 105: 
#line 446
      if (flags >= 16 || flags & 4) {
#line 447
        type = (enum __anonenum_arg_type_8 )9;
      } else
#line 452
      if (flags >= 8) {
#line 453
        type = (enum __anonenum_arg_type_8 )7;
      } else
#line 454
      if (flags & 2) {
#line 455
        type = (enum __anonenum_arg_type_8 )1;
      } else
#line 456
      if (flags & 1) {
#line 457
        type = (enum __anonenum_arg_type_8 )3;
      } else {
#line 459
        type = (enum __anonenum_arg_type_8 )5;
      }
#line 460
      break;
      case 111: 
      case 117: 
      case 120: 
      case 88: 
#line 464
      if (flags >= 16 || flags & 4) {
#line 465
        type = (enum __anonenum_arg_type_8 )10;
      } else
#line 470
      if (flags >= 8) {
#line 471
        type = (enum __anonenum_arg_type_8 )8;
      } else
#line 472
      if (flags & 2) {
#line 473
        type = (enum __anonenum_arg_type_8 )2;
      } else
#line 474
      if (flags & 1) {
#line 475
        type = (enum __anonenum_arg_type_8 )4;
      } else {
#line 477
        type = (enum __anonenum_arg_type_8 )6;
      }
#line 478
      break;
      case 102: 
      case 70: 
      case 101: 
      case 69: 
      case 103: 
      case 71: 
      case 97: 
      case 65: 
#line 481
      if (flags >= 16 || flags & 4) {
#line 482
        type = (enum __anonenum_arg_type_8 )12;
      } else {
#line 484
        type = (enum __anonenum_arg_type_8 )11;
      }
#line 485
      break;
      case 99: 
#line 487
      if (flags >= 8) {
#line 489
        type = (enum __anonenum_arg_type_8 )14;
      } else {
#line 494
        type = (enum __anonenum_arg_type_8 )13;
      }
#line 495
      break;
      case 67: 
#line 498
      type = (enum __anonenum_arg_type_8 )14;
#line 499
      c = (char )'c';
#line 500
      break;
      case 115: 
#line 503
      if (flags >= 8) {
#line 505
        type = (enum __anonenum_arg_type_8 )16;
      } else {
#line 510
        type = (enum __anonenum_arg_type_8 )15;
      }
#line 511
      break;
      case 83: 
#line 514
      type = (enum __anonenum_arg_type_8 )16;
#line 515
      c = (char )'s';
#line 516
      break;
      case 112: 
#line 519
      type = (enum __anonenum_arg_type_8 )17;
#line 520
      break;
      case 110: 
#line 524
      if (flags >= 16 || flags & 4) {
#line 525
        type = (enum __anonenum_arg_type_8 )22;
      } else
#line 530
      if (flags >= 8) {
#line 531
        type = (enum __anonenum_arg_type_8 )21;
      } else
#line 532
      if (flags & 2) {
#line 533
        type = (enum __anonenum_arg_type_8 )18;
      } else
#line 534
      if (flags & 1) {
#line 535
        type = (enum __anonenum_arg_type_8 )19;
      } else {
#line 537
        type = (enum __anonenum_arg_type_8 )20;
      }
#line 538
      break;
      case 37: 
#line 551
      type = (enum __anonenum_arg_type_8 )0;
#line 552
      break;
      default: 
#line 555
      goto error;
      }
#line 559
      if ((unsigned int )type != 0U) {
#line 561
        dp->arg_index = arg_index;
#line 562
        if (dp->arg_index == 4294967295U) {
#line 564
          __cil_tmp___12 = arg_posn;
#line 564
          arg_posn ++;
#line 564
          dp->arg_index = __cil_tmp___12;
#line 565
          if (dp->arg_index == 4294967295U) {
#line 567
            goto error;
          }
        }
#line 569
        n___4 = dp->arg_index;
#line 569
        if (n___4 >= a_allocated) {
#line 569
          a_allocated = a_allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? a_allocated * 2U : ((1U << 31) - 1U) * 2U + 1U;
#line 569
          if (a_allocated <= n___4) {
#line 569
            a_allocated = xsum(n___4, 1U);
          }
#line 569
          memory_size___1 = a_allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(argument ) ? a_allocated * sizeof(argument ) : ((1U << 31) - 1U) * 2U + 1U;
#line 569
          if (memory_size___1 == ((1U << 31) - 1U) * 2U + 1U) {
#line 569
            goto out_of_memory;
          }
#line 569
          if (a->arg) {
#line 569
            __cil_tmp___13 = rpl_realloc((void *)a->arg, memory_size___1);
#line 569
            __cil_tmp___15 = __cil_tmp___13;
          } else {
#line 569
            __cil_tmp___14 = rpl_malloc(memory_size___1);
#line 569
            __cil_tmp___15 = __cil_tmp___14;
          }
#line 569
          memory___1 = (argument *)__cil_tmp___15;
#line 569
          if ((unsigned int )memory___1 == (unsigned int )((void *)0)) {
#line 569
            goto out_of_memory;
          }
#line 569
          a->arg = memory___1;
        }
#line 569
        while (a->count <= n___4) {
#line 569
          __cil_tmp___16 = a->count;
#line 569
          (a->count) ++;
#line 569
          (a->arg + __cil_tmp___16)->type = (enum __anonenum_arg_type_8 )0;
        }
#line 569
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 569
          (a->arg + n___4)->type = type;
        } else
#line 569
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 569
          goto error;
        }
      }
#line 571
      dp->conversion = c;
#line 572
      dp->dir_end = cp;
#line 575
      (d->count) ++;
#line 576
      if (d->count >= d_allocated) {
#line 581
        d_allocated = d_allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? d_allocated * 2U : ((1U << 31) - 1U) * 2U + 1U;
#line 582
        memory_size___2 = d_allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char_directive ) ? d_allocated * sizeof(char_directive ) : ((1U << 31) - 1U) * 2U + 1U;
#line 583
        if (memory_size___2 == ((1U << 31) - 1U) * 2U + 1U) {
#line 585
          goto out_of_memory;
        }
#line 586
        __cil_tmp___17 = rpl_realloc((void *)d->dir, memory_size___2);
#line 586
        memory___2 = (char_directive *)__cil_tmp___17;
#line 587
        if ((unsigned int )memory___2 == (unsigned int )((void *)0)) {
#line 589
          goto out_of_memory;
        }
#line 590
        d->dir = memory___2;
      }
    }
  }
#line 601
  (d->dir + d->count)->dir_start = cp;
#line 603
  d->max_width_length = max_width_length;
#line 604
  d->max_precision_length = max_precision_length;
#line 605
  return (0);
  error: 
#line 608
  if (a->arg) {
#line 609
    free((void *)a->arg);
  }
#line 610
  if (d->dir) {
#line 611
    free((void *)d->dir);
  }
#line 612
  __cil_tmp___18 = __errno();
#line 612
  *__cil_tmp___18 = 22;
#line 613
  return (-1);
  out_of_memory: 
#line 616
  if (a->arg) {
#line 617
    free((void *)a->arg);
  }
#line 618
  if (d->dir) {
#line 619
    free((void *)d->dir);
  }
  out_of_memory_1: 
#line 621
  __cil_tmp___19 = __errno();
#line 621
  *__cil_tmp___19 = 12;
#line 622
  return (-1);
}
}
#line 1 "putenv.o"
#pragma merger(0,"/tmp/cil-mpQQy2LX.i","-g,-O2")
#line 203 "./stdlib.h"
int rpl_putenv(char *string ) ;
#line 15 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern char **environ ;
#line 55 "putenv.c"
static int _unsetenv(char const   *name ) 
{ size_t len ;
  char **ep ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  char **dp ;
  char **__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 61
  if ((unsigned int )name == (unsigned int )((void *)0) || (int const   )*name == 0) {
#line 63
    __cil_tmp = __errno();
#line 63
    *__cil_tmp = 22;
#line 64
    return (-1);
  } else {
#line 61
    __cil_tmp___0 = strchr(name, '=');
#line 61
    if ((unsigned int )__cil_tmp___0 != (unsigned int )((void *)0)) {
#line 63
      __cil_tmp = __errno();
#line 63
      *__cil_tmp = 22;
#line 64
      return (-1);
    }
  }
#line 67
  len = strlen(name);
#line 71
  ep = environ;
#line 72
  while ((unsigned int )*ep != (unsigned int )((void *)0)) {
#line 73
    __cil_tmp___2 = strncmp((char const   *)*ep, name, len);
#line 73
    if (__cil_tmp___2) {
#line 84
      ep ++;
    } else
#line 73
    if ((int )*(*ep + len) == 61) {
#line 76
      dp = ep;
#line 78
      while (1) {
#line 79
        *(dp + 0) = *(dp + 1);
#line 78
        __cil_tmp___1 = dp;
#line 78
        dp ++;
#line 78
        if (! *__cil_tmp___1) {
#line 78
          break;
        }
      }
    } else {
#line 84
      ep ++;
    }
  }
#line 88
  return (0);
}
}
#line 117 "putenv.c"
static char **last_environ  =    (char **)((void *)0);
#line 94 "putenv.c"
int rpl_putenv(char *string ) 
{ char const   *name_end ;
  char *__cil_tmp ;
  register size_t size ;
  register char **ep ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  char **new_environ ;
  void *__cil_tmp___2 ;

  {
#line 97
  __cil_tmp = strchr((char const   *)string, '=');
#line 97
  name_end = (char const   *)__cil_tmp;
#line 101
  if ((unsigned int )name_end == (unsigned int )((void *)0)) {
#line 104
    __cil_tmp___0 = _unsetenv((char const   *)string);
#line 104
    return (__cil_tmp___0);
  }
#line 107
  size = 0U;
#line 108
  ep = environ;
#line 108
  while ((unsigned int )*ep != (unsigned int )((void *)0)) {
#line 109
    __cil_tmp___1 = strncmp((char const   *)*ep, (char const   *)string, (unsigned int )(name_end - (char const   *)string));
#line 109
    if (__cil_tmp___1) {
#line 113
      size ++;
    } else
#line 109
    if ((int )*(*ep + (name_end - (char const   *)string)) == 61) {
#line 111
      break;
    } else {
#line 113
      size ++;
    }
#line 108
    ep ++;
  }
#line 115
  if ((unsigned int )*ep == (unsigned int )((void *)0)) {
#line 118
    __cil_tmp___2 = rpl_malloc((size + 2U) * sizeof(char *));
#line 118
    new_environ = (char **)__cil_tmp___2;
#line 119
    if ((unsigned int )new_environ == (unsigned int )((void *)0)) {
#line 120
      return (-1);
    }
#line 121
    memcpy((void *)new_environ, (void const   *)((void *)environ), size * sizeof(char *));
#line 123
    *(new_environ + size) = string;
#line 124
    *(new_environ + (size + 1U)) = (char *)((void *)0);
#line 125
    if ((unsigned int )last_environ != (unsigned int )((void *)0)) {
#line 126
      free((void *)last_environ);
    }
#line 127
    last_environ = new_environ;
#line 128
    environ = new_environ;
  } else {
#line 131
    *ep = string;
  }
#line 133
  return (0);
}
}
#line 1 "quote.o"
#pragma merger(0,"/tmp/cil-n1492Frl.i","-g,-O2")
#line 28 "quote.c"
char const   *quote_n(int n , char const   *name ) 
{ char *__cil_tmp ;

  {
#line 31
  __cil_tmp = quotearg_n_style(n, (enum quoting_style )5, name);
#line 31
  return ((char const   *)__cil_tmp);
}
}
#line 36 "quote.c"
char const   *quote(char const   *name ) 
{ char const   *__cil_tmp ;

  {
#line 39
  __cil_tmp = quote_n(0, name);
#line 39
  return (__cil_tmp);
}
}
#line 1 "quotearg.o"
#pragma merger(0,"/tmp/cil-Uir0VLTi.i","-g,-O2")
#line 20 "quotearg.c"
extern void __otter_quotearg_buffer_restyled_assert(int  ) ;
#line 62 "quotearg.h"
char const   * const  quoting_style_args[8] ;
#line 63
enum quoting_style  const  quoting_style_vals[7] ;
#line 73
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 76
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 80
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 87
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 97
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 103
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 111
char *quotearg_n(int n , char const   *arg ) ;
#line 114
char *quotearg(char const   *arg ) ;
#line 128
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 131
char *quotearg_char(char const   *arg , char ch ) ;
#line 137
void quotearg_free(void) ;
#line 222 "xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ void *__cil_tmp ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;

  {
#line 225
  if (sizeof(char ) == 1U) {
#line 225
    __cil_tmp = xmalloc(n);
#line 225
    __cil_tmp___1 = __cil_tmp;
  } else {
#line 225
    __cil_tmp___0 = xnmalloc(n, sizeof(char ));
#line 225
    __cil_tmp___1 = __cil_tmp___0;
  }
#line 225
  return ((char *)__cil_tmp___1);
}
}
#line 34 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wctype.h"
extern int iswprint(wint_t  ) ;
#line 74 "quotearg.c"
char const   * const  quoting_style_args[8]  = 
#line 74 "quotearg.c"
  {      (char const   * const  )"literal",      (char const   * const  )"shell",      (char const   * const  )"shell-always",      (char const   * const  )"c", 
        (char const   * const  )"escape",      (char const   * const  )"locale",      (char const   * const  )"clocale",      (char const   * const  )0};
#line 87 "quotearg.c"
enum quoting_style  const  quoting_style_vals[7]  = {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6};
#line 99 "quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 104 "quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ int e ;
  int *__cil_tmp ;
  struct quoting_options *p ;
  void *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 107
  __cil_tmp = __errno();
#line 107
  e = *__cil_tmp;
#line 108
  __cil_tmp___0 = xmemdup((void const   *)(o ? o : & default_quoting_options), sizeof(*o));
#line 108
  p = (struct quoting_options *)__cil_tmp___0;
#line 110
  __cil_tmp___1 = __errno();
#line 110
  *__cil_tmp___1 = e;
#line 111
  return (p);
}
}
#line 115 "quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 

  {
#line 118
  return ((o ? o : & default_quoting_options)->style);
}
}
#line 123 "quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 

  {
#line 126
  (o ? o : & default_quoting_options)->style = s;
#line 127
  return;
}
}
#line 134 "quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ unsigned char uc ;
  unsigned int *p ;
  int shift ;
  int r ;

  {
#line 137
  uc = (unsigned char )c;
#line 138
  p = (o ? o : & default_quoting_options)->quote_these_too + (unsigned int )uc / (sizeof(int ) * 8U);
#line 140
  shift = (int )((unsigned int )uc % (sizeof(int ) * 8U));
#line 141
  r = (int )((*p >> shift) & 1U);
#line 142
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 143
  return (r);
}
}
#line 148 "quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ char const   *translation ;

  {
#line 151
  translation = msgid;
#line 152
  if ((unsigned int )translation == (unsigned int )msgid && (unsigned int )s == 6U) {
#line 153
    translation = "\"";
  }
#line 154
  return (translation);
}
}
#line 170 "quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       struct quoting_options  const  *o ) 
{ size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  int __cil_tmp ;
  char const   *left ;
  char const   *__cil_tmp___0 ;
  char const   *right ;
  char const   *__cil_tmp___1 ;
  unsigned char c ;
  unsigned char esc ;
  int __cil_tmp___2 ;
  size_t m ;
  _Bool printable ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t __cil_tmp___3 ;
  size_t j ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  size_t ilim ;
  int __cil_tmp___6 ;
  size_t __cil_tmp___7 ;

  {
#line 177
  len = 0U;
#line 178
  quote_string = (char const   *)0;
#line 179
  quote_string_len = 0U;
#line 180
  backslash_escapes = (_Bool)0;
#line 181
  __cil_tmp = __locale_mb_cur_max();
#line 181
  unibyte_locale = (_Bool )(__cil_tmp == 1);
#line 192
  switch ((int )quoting_style) {
  case 3: 
#line 195
  while (1) {
#line 195
    if (len < buffersize) {
#line 195
      *(buffer + len) = (char )'\"';
    }
#line 195
    len ++;
#line 195
    break;
  }
#line 196
  backslash_escapes = (_Bool)1;
#line 197
  quote_string = "\"";
#line 198
  quote_string_len = 1U;
#line 199
  break;
  case 4: 
#line 202
  backslash_escapes = (_Bool)1;
#line 203
  break;
  case 5: 
  case 6: 
#line 228
  __cil_tmp___0 = gettext_quote("`", quoting_style);
#line 228
  left = __cil_tmp___0;
#line 229
  __cil_tmp___1 = gettext_quote("\'", quoting_style);
#line 229
  right = __cil_tmp___1;
#line 230
  quote_string = left;
#line 230
  while (*quote_string) {
#line 231
    while (1) {
#line 231
      if (len < buffersize) {
#line 231
        *(buffer + len) = (char )*quote_string;
      }
#line 231
      len ++;
#line 231
      break;
    }
#line 230
    quote_string ++;
  }
#line 232
  backslash_escapes = (_Bool)1;
#line 233
  quote_string = right;
#line 234
  quote_string_len = strlen(quote_string);
#line 236
  break;
  case 2: 
#line 239
  while (1) {
#line 239
    if (len < buffersize) {
#line 239
      *(buffer + len) = (char )'\'';
    }
#line 239
    len ++;
#line 239
    break;
  }
#line 240
  quote_string = "\'";
#line 241
  quote_string_len = 1U;
#line 242
  break;
  default: 
#line 245
  break;
  }
#line 252
  i = 0U;
#line 252
  while (1) {
#line 252
    if (argsize == 4294967295U) {
#line 252
      __otter_quotearg_buffer_restyled_assert((unsigned int )arg != (unsigned int )((void *)0));
#line 252
      __cil_tmp___6 = (int const   )*(arg + i) == 0;
    } else {
#line 252
      __cil_tmp___6 = i == argsize;
    }
#line 252
    if (__cil_tmp___6) {
#line 252
      break;
    }
#line 257
    if ((backslash_escapes && quote_string_len) && i + quote_string_len <= argsize) {
#line 257
      __cil_tmp___2 = rpl_memcmp((void const   *)(arg + i), (void const   *)quote_string,
                                 quote_string_len);
#line 257
      if (__cil_tmp___2 == 0) {
#line 261
        while (1) {
#line 261
          if (len < buffersize) {
#line 261
            *(buffer + len) = (char )'\\';
          }
#line 261
          len ++;
#line 261
          break;
        }
      }
    }
#line 263
    c = (unsigned char )*(arg + i);
#line 264
    switch ((int )c) {
    case 0: 
#line 267
    if (backslash_escapes) {
#line 269
      while (1) {
#line 269
        if (len < buffersize) {
#line 269
          *(buffer + len) = (char )'\\';
        }
#line 269
        len ++;
#line 269
        break;
      }
#line 270
      while (1) {
#line 270
        if (len < buffersize) {
#line 270
          *(buffer + len) = (char )'0';
        }
#line 270
        len ++;
#line 270
        break;
      }
#line 271
      while (1) {
#line 271
        if (len < buffersize) {
#line 271
          *(buffer + len) = (char )'0';
        }
#line 271
        len ++;
#line 271
        break;
      }
#line 272
      c = (unsigned char )'0';
    }
#line 274
    break;
    case 63: 
#line 277
    switch ((int )quoting_style) {
    case 1: 
#line 280
    goto use_shell_always_quoting_style;
    case 3: 
#line 283
    if (i + 2U < argsize && (int const   )*(arg + (i + 1U)) == 63) {
#line 284
      switch ((int )*(arg + (i + 2U))) {
      case 33: 
      case 39: 
      case 40: 
      case 41: 
      case 45: 
      case 47: 
      case 60: 
      case 61: 
      case 62: 
#line 291
      c = (unsigned char )*(arg + (i + 2U));
#line 292
      i += 2U;
#line 293
      while (1) {
#line 293
        if (len < buffersize) {
#line 293
          *(buffer + len) = (char )'?';
        }
#line 293
        len ++;
#line 293
        break;
      }
#line 294
      while (1) {
#line 294
        if (len < buffersize) {
#line 294
          *(buffer + len) = (char )'\\';
        }
#line 294
        len ++;
#line 294
        break;
      }
#line 295
      while (1) {
#line 295
        if (len < buffersize) {
#line 295
          *(buffer + len) = (char )'?';
        }
#line 295
        len ++;
#line 295
        break;
      }
#line 296
      break;
      default: 
#line 299
      break;
      }
    }
#line 301
    break;
    default: 
#line 304
    break;
    }
#line 306
    break;
    case 7: 
#line 308
    esc = (unsigned char )'a';
#line 308
    goto c_escape;
    case 8: 
#line 309
    esc = (unsigned char )'b';
#line 309
    goto c_escape;
    case 12: 
#line 310
    esc = (unsigned char )'f';
#line 310
    goto c_escape;
    case 10: 
#line 311
    esc = (unsigned char )'n';
#line 311
    goto c_and_shell_escape;
    case 13: 
#line 312
    esc = (unsigned char )'r';
#line 312
    goto c_and_shell_escape;
    case 9: 
#line 313
    esc = (unsigned char )'t';
#line 313
    goto c_and_shell_escape;
    case 11: 
#line 314
    esc = (unsigned char )'v';
#line 314
    goto c_escape;
    case 92: 
#line 315
    esc = c;
#line 315
    goto c_and_shell_escape;
    c_and_shell_escape: 
#line 318
    if ((unsigned int )quoting_style == 1U) {
#line 319
      goto use_shell_always_quoting_style;
    }
    c_escape: 
#line 321
    if (backslash_escapes) {
#line 323
      c = esc;
#line 324
      goto store_escape;
    }
#line 326
    break;
    case 123: 
    case 125: 
#line 329
    if (! (argsize == 4294967295U ? (int const   )*(arg + 1) == 0 : argsize == 1U)) {
#line 330
      break;
    }
    case 35: 
    case 126: 
#line 333
    if (i != 0U) {
#line 334
      break;
    }
    case 32: 
    case 33: 
    case 34: 
    case 36: 
    case 38: 
    case 40: 
    case 41: 
    case 42: 
    case 59: 
    case 60: 
    case 61: 
    case 62: 
    case 91: 
    case 94: 
    case 96: 
    case 124: 
#line 349
    if ((unsigned int )quoting_style == 1U) {
#line 350
      goto use_shell_always_quoting_style;
    }
#line 351
    break;
    case 39: 
#line 354
    switch ((int )quoting_style) {
    case 1: 
#line 357
    goto use_shell_always_quoting_style;
    case 2: 
#line 360
    while (1) {
#line 360
      if (len < buffersize) {
#line 360
        *(buffer + len) = (char )'\'';
      }
#line 360
      len ++;
#line 360
      break;
    }
#line 361
    while (1) {
#line 361
      if (len < buffersize) {
#line 361
        *(buffer + len) = (char )'\\';
      }
#line 361
      len ++;
#line 361
      break;
    }
#line 362
    while (1) {
#line 362
      if (len < buffersize) {
#line 362
        *(buffer + len) = (char )'\'';
      }
#line 362
      len ++;
#line 362
      break;
    }
#line 363
    break;
    default: 
#line 366
    break;
    }
#line 368
    break;
    case 37: 
    case 43: 
    case 44: 
    case 45: 
    case 46: 
    case 47: 
    case 48: 
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    case 58: 
    case 65: 
    case 66: 
    case 67: 
    case 68: 
    case 69: 
    case 70: 
    case 71: 
    case 72: 
    case 73: 
    case 74: 
    case 75: 
    case 76: 
    case 77: 
    case 78: 
    case 79: 
    case 80: 
    case 81: 
    case 82: 
    case 83: 
    case 84: 
    case 85: 
    case 86: 
    case 87: 
    case 88: 
    case 89: 
    case 90: 
    case 93: 
    case 95: 
    case 97: 
    case 98: 
    case 99: 
    case 100: 
    case 101: 
    case 102: 
    case 103: 
    case 104: 
    case 105: 
    case 106: 
    case 107: 
    case 108: 
    case 109: 
    case 110: 
    case 111: 
    case 112: 
    case 113: 
    case 114: 
    case 115: 
    case 116: 
    case 117: 
    case 118: 
    case 119: 
    case 120: 
    case 121: 
    case 122: 
#line 384
    break;
    default: 
#line 398
    if (unibyte_locale) {
#line 400
      m = 1U;
#line 401
      printable = (_Bool )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c))) + (int )c) & 151) != 0);
    } else {
#line 406
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 408
      m = 0U;
#line 409
      printable = (_Bool)1;
#line 410
      if (argsize == 4294967295U) {
#line 411
        argsize = strlen(arg);
      }
#line 413
      while (1) {
#line 416
        __cil_tmp___3 = mbrtowc(& w, arg + (i + m), argsize - (i + m), & mbstate);
#line 416
        bytes = __cil_tmp___3;
#line 418
        if (bytes == 0U) {
#line 419
          break;
        } else
#line 420
        if (bytes == 4294967295U) {
#line 422
          printable = (_Bool)0;
#line 423
          break;
        } else
#line 425
        if (bytes == 4294967294U) {
#line 427
          printable = (_Bool)0;
#line 428
          while (i + m < argsize && *(arg + (i + m))) {
#line 429
            m ++;
          }
#line 430
          break;
        } else {
#line 438
          if ((unsigned int )quoting_style == 1U) {
#line 441
            j = 1U;
#line 441
            while (j < bytes) {
#line 442
              switch ((int )*(arg + ((i + m) + j))) {
              case 91: 
              case 92: 
              case 94: 
              case 96: 
              case 124: 
#line 446
              goto use_shell_always_quoting_style;
              default: 
#line 449
              break;
              }
#line 441
              j ++;
            }
          }
#line 453
          __cil_tmp___4 = iswprint((int )w);
#line 453
          if (! __cil_tmp___4) {
#line 454
            printable = (_Bool)0;
          }
#line 455
          m += bytes;
        }
#line 413
        __cil_tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
#line 413
        if (__cil_tmp___5) {
#line 413
          break;
        }
      }
    }
#line 461
    if (1U < m || (backslash_escapes && ! printable)) {
#line 465
      ilim = i + m;
#line 467
      while (1) {
#line 469
        if (backslash_escapes && ! printable) {
#line 471
          while (1) {
#line 471
            if (len < buffersize) {
#line 471
              *(buffer + len) = (char )'\\';
            }
#line 471
            len ++;
#line 471
            break;
          }
#line 472
          while (1) {
#line 472
            if (len < buffersize) {
#line 472
              *(buffer + len) = (char )(48 + ((int )c >> 6));
            }
#line 472
            len ++;
#line 472
            break;
          }
#line 473
          while (1) {
#line 473
            if (len < buffersize) {
#line 473
              *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
            }
#line 473
            len ++;
#line 473
            break;
          }
#line 474
          c = (unsigned char )(48 + ((int )c & 7));
        }
#line 476
        if (ilim <= i + 1U) {
#line 477
          break;
        }
#line 478
        while (1) {
#line 478
          if (len < buffersize) {
#line 478
            *(buffer + len) = (char )c;
          }
#line 478
          len ++;
#line 478
          break;
        }
#line 479
        i ++;
#line 479
        c = (unsigned char )*(arg + i);
      }
#line 482
      goto store_c;
    }
    }
#line 487
    if (! (backslash_escapes && o->quote_these_too[(unsigned int )c / (sizeof(int ) * 8U)] & (unsigned int )(1 << (unsigned int )c % (sizeof(int ) * 8U)))) {
#line 489
      goto store_c;
    }
    store_escape: 
#line 492
    while (1) {
#line 492
      if (len < buffersize) {
#line 492
        *(buffer + len) = (char )'\\';
      }
#line 492
      len ++;
#line 492
      break;
    }
    store_c: 
#line 495
    while (1) {
#line 495
      if (len < buffersize) {
#line 495
        *(buffer + len) = (char )c;
      }
#line 495
      len ++;
#line 495
      break;
    }
#line 252
    i ++;
  }
#line 498
  if (i == 0U && (unsigned int )quoting_style == 1U) {
#line 499
    goto use_shell_always_quoting_style;
  }
#line 501
  if (quote_string) {
#line 502
    while (*quote_string) {
#line 503
      while (1) {
#line 503
        if (len < buffersize) {
#line 503
          *(buffer + len) = (char )*quote_string;
        }
#line 503
        len ++;
#line 503
        break;
      }
#line 502
      quote_string ++;
    }
  }
#line 505
  if (len < buffersize) {
#line 506
    *(buffer + len) = (char )'\000';
  }
#line 507
  return (len);
  use_shell_always_quoting_style: 
#line 510
  __cil_tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )2,
                                           o);
#line 510
  return (__cil_tmp___7);
}
}
#line 523 "quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ struct quoting_options  const  *p ;
  int e ;
  int *__cil_tmp ;
  size_t r ;
  size_t __cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 528
  p = o ? o : (struct quoting_options  const  *)(& default_quoting_options);
#line 529
  __cil_tmp = __errno();
#line 529
  e = *__cil_tmp;
#line 530
  __cil_tmp___0 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                           p);
#line 530
  r = __cil_tmp___0;
#line 532
  __cil_tmp___1 = __errno();
#line 532
  *__cil_tmp___1 = e;
#line 533
  return (r);
}
}
#line 538 "quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ int e ;
  int *__cil_tmp ;
  size_t bufsize___0 ;
  size_t __cil_tmp___0 ;
  char *buf___0 ;
  char *__cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 542
  __cil_tmp = __errno();
#line 542
  e = *__cil_tmp;
#line 543
  __cil_tmp___0 = quotearg_buffer((char *)0, 0U, arg, argsize, o);
#line 543
  bufsize___0 = __cil_tmp___0 + 1U;
#line 544
  __cil_tmp___1 = xcharalloc(bufsize___0);
#line 544
  buf___0 = __cil_tmp___1;
#line 545
  quotearg_buffer(buf___0, bufsize___0, arg, argsize, o);
#line 546
  __cil_tmp___2 = __errno();
#line 546
  *__cil_tmp___2 = e;
#line 547
  return (buf___0);
}
}
#line 559 "quotearg.c"
static char slot0[256]  ;
#line 560 "quotearg.c"
static unsigned int nslots  =    1U;
#line 561 "quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 562 "quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 564 "quotearg.c"
void quotearg_free(void) 
{ struct slotvec *sv ;
  unsigned int i ;

  {
#line 567
  sv = slotvec;
#line 569
  i = 1U;
#line 569
  while (i < nslots) {
#line 570
    free((void *)(sv + i)->val);
#line 569
    i ++;
  }
#line 571
  if ((unsigned int )(sv + 0)->val != (unsigned int )(slot0)) {
#line 573
    free((void *)(sv + 0)->val);
#line 574
    slotvec0.size = sizeof(slot0);
#line 575
    slotvec0.val = slot0;
  }
#line 577
  if ((unsigned int )sv != (unsigned int )(& slotvec0)) {
#line 579
    free((void *)sv);
#line 580
    slotvec = & slotvec0;
  }
#line 582
  nslots = 1U;
#line 583
  return;
}
}
#line 593 "quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ int e ;
  int *__cil_tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  void *__cil_tmp___0 ;
  size_t size ;
  char *val ;
  size_t qsize ;
  size_t __cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 597
  __cil_tmp = __errno();
#line 597
  e = *__cil_tmp;
#line 599
  n0 = (unsigned int )n;
#line 600
  sv = slotvec;
#line 602
  if (n < 0) {
#line 603
    abort();
  }
#line 605
  if (nslots <= n0) {
#line 612
    n1 = n0 + 1U;
#line 613
    preallocated = (_Bool )((unsigned int )sv == (unsigned int )(& slotvec0));
#line 615
    if ((unsigned int )(sizeof(ptrdiff_t ) <= sizeof(size_t ) ? -1 : -2) / sizeof(*sv) < n1) {
#line 616
      xalloc_die();
    }
#line 618
    __cil_tmp___0 = xrealloc((void *)(preallocated ? (struct slotvec *)((void *)0) : sv),
                             n1 * sizeof(*sv));
#line 618
    sv = (struct slotvec *)__cil_tmp___0;
#line 618
    slotvec = sv;
#line 619
    if (preallocated) {
#line 620
      *sv = slotvec0;
    }
#line 621
    memset((void *)(sv + nslots), 0, (n1 - nslots) * sizeof(*sv));
#line 622
    nslots = n1;
  }
#line 626
  size = (sv + n)->size;
#line 627
  val = (sv + n)->val;
#line 628
  __cil_tmp___1 = quotearg_buffer(val, size, arg, argsize, options);
#line 628
  qsize = __cil_tmp___1;
#line 630
  if (size <= qsize) {
#line 632
    size = qsize + 1U;
#line 632
    (sv + n)->size = size;
#line 633
    if ((unsigned int )val != (unsigned int )(slot0)) {
#line 634
      free((void *)val);
    }
#line 635
    val = xcharalloc(size);
#line 635
    (sv + n)->val = val;
#line 636
    quotearg_buffer(val, size, arg, argsize, options);
  }
#line 639
  __cil_tmp___2 = __errno();
#line 639
  *__cil_tmp___2 = e;
#line 640
  return (val);
}
}
#line 644 "quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ char *__cil_tmp ;

  {
#line 647
  __cil_tmp = quotearg_n_options(n, arg, 4294967295U, (struct quoting_options  const  *)(& default_quoting_options));
#line 647
  return (__cil_tmp);
}
}
#line 650 "quotearg.c"
char *quotearg(char const   *arg ) 
{ char *__cil_tmp ;

  {
#line 653
  __cil_tmp = quotearg_n(0, arg);
#line 653
  return (__cil_tmp);
}
}
#line 657 "quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ struct quoting_options o ;

  {
#line 661
  o.style = style;
#line 662
  memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
#line 663
  return (o);
}
}
#line 666 "quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ struct quoting_options o ;
  struct quoting_options __cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 669
  __cil_tmp = quoting_options_from_style(s);
#line 669
  o = __cil_tmp;
#line 670
  __cil_tmp___0 = quotearg_n_options(n, arg, 4294967295U, (struct quoting_options  const  *)(& o));
#line 670
  return (__cil_tmp___0);
}
}
#line 673 "quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ struct quoting_options o ;
  struct quoting_options __cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 677
  __cil_tmp = quoting_options_from_style(s);
#line 677
  o = __cil_tmp;
#line 678
  __cil_tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
#line 678
  return (__cil_tmp___0);
}
}
#line 681 "quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ char *__cil_tmp ;

  {
#line 684
  __cil_tmp = quotearg_n_style(0, s, arg);
#line 684
  return (__cil_tmp);
}
}
#line 687 "quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ struct quoting_options options ;
  char *__cil_tmp ;

  {
#line 691
  options = default_quoting_options;
#line 692
  set_char_quoting(& options, ch, 1);
#line 693
  __cil_tmp = quotearg_n_options(0, arg, 4294967295U, (struct quoting_options  const  *)(& options));
#line 693
  return (__cil_tmp);
}
}
#line 696 "quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ char *__cil_tmp ;

  {
#line 699
  __cil_tmp = quotearg_char(arg, (char )':');
#line 699
  return (__cil_tmp);
}
}
#line 1 "readtokens.o"
#pragma merger(0,"/tmp/cil-KkvewSGw.i","-g,-O2")
#line 32 "readtokens.h"
void init_tokenbuffer(token_buffer *tokenbuffer ) ;
#line 34
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) ;
#line 37
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) ;
#line 44 "readtokens.c"
void init_tokenbuffer(token_buffer *tokenbuffer ) 
{ 

  {
#line 47
  tokenbuffer->size = 0U;
#line 48
  tokenbuffer->buffer = (char *)((void *)0);
#line 49
  return;
}
}
#line 73 "readtokens.c"
static char const   *saved_delim  =    (char const   *)((void *)0);
#line 74 "readtokens.c"
static char isdelim[256]  ;
#line 64 "readtokens.c"
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) 
{ char *p ;
  int c ;
  size_t i ;
  size_t n ;
  _Bool same_delimiters ;
  size_t j ;
  unsigned char ch ;
  void *__cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 77
  if ((unsigned int )delim == (unsigned int )((void *)0) && (unsigned int )saved_delim == (unsigned int )((void *)0)) {
#line 78
    abort();
  }
#line 80
  same_delimiters = (_Bool)0;
#line 81
  if ((unsigned int )delim != (unsigned int )saved_delim && (unsigned int )saved_delim != (unsigned int )((void *)0)) {
#line 83
    same_delimiters = (_Bool)1;
#line 84
    i = 0U;
#line 84
    while (i < n_delim) {
#line 86
      if ((int const   )*(delim + i) != (int const   )*(saved_delim + i)) {
#line 88
        same_delimiters = (_Bool)0;
#line 89
        break;
      }
#line 84
      i ++;
    }
  }
#line 94
  if (! same_delimiters) {
#line 97
    saved_delim = delim;
#line 98
    memset((void *)(isdelim), 0, sizeof(isdelim));
#line 99
    j = 0U;
#line 99
    while (j < n_delim) {
#line 101
      ch = (unsigned char )*(delim + j);
#line 102
      isdelim[ch] = (char)1;
#line 99
      j ++;
    }
  }
#line 108
  c = getc_unlocked(stream);
#line 108
  while (c >= 0 && isdelim[c]) {
#line 108
    c = getc_unlocked(stream);
  }
#line 113
  p = tokenbuffer->buffer;
#line 114
  n = tokenbuffer->size;
#line 115
  i = 0U;
#line 116
  while (1) {
#line 118
    if (c < 0 && i == 0U) {
#line 119
      return (4294967295U);
    }
#line 121
    if (i == n) {
#line 122
      __cil_tmp = x2nrealloc((void *)p, & n, sizeof(*p));
#line 122
      p = (char *)__cil_tmp;
    }
#line 124
    if (c < 0) {
#line 126
      *(p + i) = (char)0;
#line 127
      break;
    }
#line 129
    if (isdelim[c]) {
#line 131
      *(p + i) = (char)0;
#line 132
      break;
    }
#line 134
    __cil_tmp___0 = i;
#line 134
    i ++;
#line 134
    *(p + __cil_tmp___0) = (char )c;
#line 135
    c = getc_unlocked(stream);
  }
#line 138
  tokenbuffer->buffer = p;
#line 139
  tokenbuffer->size = n;
#line 140
  return (i);
}
}
#line 150 "readtokens.c"
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) 
{ token_buffer tb ;
  token_buffer *token ;
  char **tokens ;
  size_t *lengths ;
  size_t sz ;
  size_t n_tokens ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  char *tmp ;
  size_t token_length ;
  size_t __cil_tmp___1 ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;

  {
#line 158
  token = & tb;
#line 164
  if (projected_n_tokens == 0U) {
#line 165
    projected_n_tokens = 64U;
  } else {
#line 167
    projected_n_tokens ++;
  }
#line 169
  sz = projected_n_tokens;
#line 170
  __cil_tmp = xnmalloc(sz, sizeof(*tokens));
#line 170
  tokens = (char **)__cil_tmp;
#line 171
  __cil_tmp___0 = xnmalloc(sz, sizeof(*lengths));
#line 171
  lengths = (size_t *)__cil_tmp___0;
#line 173
  n_tokens = 0U;
#line 174
  init_tokenbuffer(token);
#line 175
  while (1) {
#line 178
    __cil_tmp___1 = readtoken(stream, delim, n_delim, token);
#line 178
    token_length = __cil_tmp___1;
#line 179
    if (n_tokens >= sz) {
#line 181
      __cil_tmp___2 = x2nrealloc((void *)tokens, & sz, sizeof(*tokens));
#line 181
      tokens = (char **)__cil_tmp___2;
#line 182
      __cil_tmp___3 = xnrealloc((void *)lengths, sz, sizeof(*lengths));
#line 182
      lengths = (size_t *)__cil_tmp___3;
    }
#line 185
    if (token_length == 4294967295U) {
#line 188
      *(tokens + n_tokens) = (char *)((void *)0);
#line 189
      *(lengths + n_tokens) = 0U;
#line 190
      break;
    }
#line 192
    __cil_tmp___4 = xnmalloc(token_length + 1U, sizeof(*tmp));
#line 192
    tmp = (char *)__cil_tmp___4;
#line 193
    *(lengths + n_tokens) = token_length;
#line 194
    __cil_tmp___5 = memcpy((void *)tmp, (void const   *)token->buffer, token_length + 1U);
#line 194
    *(tokens + n_tokens) = (char *)__cil_tmp___5;
#line 195
    n_tokens ++;
  }
#line 198
  free((void *)token->buffer);
#line 199
  *tokens_out = tokens;
#line 200
  if ((unsigned int )token_lengths != (unsigned int )((void *)0)) {
#line 201
    *token_lengths = lengths;
  }
#line 202
  return (n_tokens);
}
}
#line 1 "realloc.o"
#pragma merger(0,"/tmp/cil-hJbV9LzT.i","-g,-O2")
#line 121 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdlib.h"
extern void *realloc(void *__r , size_t __size ) ;
#line 54 "realloc.c"
void *rpl_realloc(void *p , size_t n ) 
{ void *result ;

  {
#line 60
  if (n == 0U) {
#line 62
    n = 1U;
#line 65
    free(p);
#line 66
    p = (void *)0;
  }
#line 70
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 76
    result = malloc(n);
  } else {
#line 79
    result = realloc(p, n);
  }
#line 86
  return (result);
}
}
#line 1 "regex.o"
#pragma merger(0,"/tmp/cil-3mt5Vgdd.i","-g,-O2")
#line 237 "./regex.h"
reg_syntax_t rpl_re_syntax_options  ;
#line 553
reg_syntax_t rpl_re_set_syntax(reg_syntax_t syntax ) ;
#line 558
char const   *rpl_re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 565
int rpl_re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 573
regoff_t rpl_re_search(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                       __re_idx_t start , regoff_t range , struct re_registers *regs ) ;
#line 581
regoff_t rpl_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                         __re_idx_t length1 , char const   *string2 , __re_idx_t length2 ,
                         __re_idx_t start , regoff_t range , struct re_registers *regs ,
                         __re_idx_t stop ) ;
#line 591
regoff_t rpl_re_match(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                      __re_idx_t start , struct re_registers *regs ) ;
#line 597
regoff_t rpl_re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , __re_idx_t length1 ,
                        char const   *string2 , __re_idx_t length2 , __re_idx_t start ,
                        struct re_registers *regs , __re_idx_t stop ) ;
#line 616
void rpl_re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                          __re_size_t num_regs , regoff_t *starts , regoff_t *ends ) ;
#line 658
int rpl_regcomp(regex_t *preg , char const   *pattern , int cflags ) ;
#line 662
int rpl_regexec(regex_t const   *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
                int eflags ) ;
#line 667
size_t rpl_regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) ;
#line 670
void rpl_regfree(regex_t *preg ) ;
#line 63 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wchar.h"
extern size_t wcrtomb(char * , wchar_t  , mbstate_t * ) ;
#line 76
extern int wcscoll(wchar_t const   * , wchar_t const   * ) ;
#line 27 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wctype.h"
extern int iswalnum(wint_t  ) ;
#line 33
extern int iswlower(wint_t  ) ;
#line 40
extern wint_t towupper(wint_t  ) ;
#line 433 "regex_internal.h"
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , Idx new_buf_len ) ;
#line 437
static void build_wcs_buffer(re_string_t *pstr ) ;
#line 438
static reg_errcode_t build_wcs_upper_buffer(re_string_t *pstr ) ;
#line 441
static void build_upper_buffer(re_string_t *pstr ) ;
#line 442
static void re_string_translate_buffer(re_string_t *pstr ) ;
#line 443
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags ) ;
#line 740 "regex_internal.h"
__inline static void bitset_set(bitset_word_t *set , Idx i ) 
{ 

  {
#line 743
  *(set + i / 32U) |= 1UL << i % 32U;
#line 744
  return;
}
}
#line 746 "regex_internal.h"
__inline static void bitset_clear(bitset_word_t *set , Idx i ) 
{ 

  {
#line 749
  *(set + i / 32U) &= ~ (1UL << i % 32U);
#line 750
  return;
}
}
#line 752 "regex_internal.h"
__inline static _Bool bitset_contain(bitset_word_t *set , Idx i ) 
{ 

  {
#line 755
  return ((_Bool )((*(set + i / 32U) >> i % 32U) & 1UL));
}
}
#line 758 "regex_internal.h"
__inline static void bitset_empty(bitset_word_t *set ) 
{ 

  {
#line 761
  memset((void *)set, '\000', sizeof(bitset_t ));
#line 762
  return;
}
}
#line 764 "regex_internal.h"
__inline static void bitset_set_all(bitset_word_t *set ) 
{ 

  {
#line 767
  memset((void *)set, -1, sizeof(bitset_word_t ) * 8U);
#line 771
  return;
}
}
#line 773 "regex_internal.h"
__inline static void bitset_copy(bitset_word_t *dest , bitset_word_t *src ) 
{ 

  {
#line 776
  memcpy((void *)dest, (void const   *)src, sizeof(bitset_t ));
#line 777
  return;
}
}
#line 779 "regex_internal.h"
__inline static void bitset_not(bitset_word_t *set ) 
{ int bitset_i ;

  {
#line 783
  bitset_i = 0;
#line 783
  while (bitset_i < 8) {
#line 784
    *(set + bitset_i) = ~ *(set + bitset_i);
#line 783
    bitset_i ++;
  }
#line 789
  return;
}
}
#line 791 "regex_internal.h"
__inline static void bitset_merge(bitset_word_t *dest , bitset_word_t *src ) 
{ int bitset_i ;

  {
#line 795
  bitset_i = 0;
#line 795
  while (bitset_i < 8) {
#line 796
    *(dest + bitset_i) |= *(src + bitset_i);
#line 795
    bitset_i ++;
  }
#line 797
  return;
}
}
#line 799 "regex_internal.h"
__inline static void bitset_mask(bitset_word_t *dest , bitset_word_t *src ) 
{ int bitset_i ;

  {
#line 803
  bitset_i = 0;
#line 803
  while (bitset_i < 8) {
#line 804
    *(dest + bitset_i) &= *(src + bitset_i);
#line 803
    bitset_i ++;
  }
#line 805
  return;
}
}
#line 809 "regex_internal.h"
__inline static int re_string_char_size_at(re_string_t const   *pstr , Idx idx ) 
{ int byte_idx ;

  {
#line 814
  if (pstr->mb_cur_max == 1) {
#line 815
    return (1);
  }
#line 816
  byte_idx = 1;
#line 816
  while (idx + (unsigned int )byte_idx < (unsigned int )pstr->valid_len) {
#line 817
    if (*(pstr->wcs + (idx + (unsigned int )byte_idx)) != -1) {
#line 818
      break;
    }
#line 816
    byte_idx ++;
  }
#line 819
  return (byte_idx);
}
}
#line 822 "regex_internal.h"
__inline static wint_t re_string_wchar_at(re_string_t const   *pstr , Idx idx ) 
{ 

  {
#line 826
  if (pstr->mb_cur_max == 1) {
#line 827
    return ((int )*(pstr->mbs + idx));
  }
#line 828
  return (*(pstr->wcs + idx));
}
}
#line 831 "regex_internal.h"
static int re_string_elem_size_at(re_string_t const   *pstr , Idx idx ) 
{ 

  {
#line 855
  return (1);
}
}
#line 23 "regex_internal.c"
static void re_string_construct_common(char const   *str , Idx len , re_string_t *pstr ,
                                       unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) ;
#line 27
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         re_hashval_t hash ) ;
#line 30
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int context , re_hashval_t hash ) ;
#line 40 "regex_internal.c"
static reg_errcode_t re_string_allocate(re_string_t *pstr , char const   *str , Idx len ,
                                        Idx init_len , unsigned char *trans , _Bool icase ,
                                        re_dfa_t const   *dfa ) 
{ reg_errcode_t ret ;
  Idx init_buf_len ;

  {
#line 49
  if (init_len < (unsigned int )dfa->mb_cur_max) {
#line 50
    init_len = (unsigned int )dfa->mb_cur_max;
  }
#line 51
  init_buf_len = len + 1U < init_len ? len + 1U : init_len;
#line 52
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
#line 54
  ret = re_string_realloc_buffers(pstr, init_buf_len);
#line 55
  if ((int )ret != 0) {
#line 56
    return (ret);
  }
#line 58
  pstr->word_char = (bitset_word_t const   *)(dfa->word_char);
#line 59
  pstr->word_ops_used = (unsigned char )dfa->word_ops_used;
#line 60
  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *)str;
#line 61
  pstr->valid_len = pstr->mbs_allocated || dfa->mb_cur_max > 1 ? 0U : len;
#line 62
  pstr->valid_raw_len = pstr->valid_len;
#line 63
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 68 "regex_internal.c"
static reg_errcode_t re_string_construct(re_string_t *pstr , char const   *str , Idx len ,
                                         unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) 
{ reg_errcode_t ret ;

  {
#line 74
  memset((void *)pstr, '\000', sizeof(re_string_t ));
#line 75
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
#line 77
  if (len > 0U) {
#line 79
    ret = re_string_realloc_buffers(pstr, len + 1U);
#line 80
    if ((int )ret != 0) {
#line 81
      return (ret);
    }
  }
#line 83
  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *)str;
#line 85
  if (icase) {
#line 88
    if (dfa->mb_cur_max > 1) {
#line 90
      while (1) {
#line 92
        ret = build_wcs_upper_buffer(pstr);
#line 93
        if ((int )ret != 0) {
#line 94
          return (ret);
        }
#line 95
        if (pstr->valid_raw_len >= len) {
#line 96
          break;
        }
#line 97
        if (pstr->bufs_len > pstr->valid_len + (unsigned int )dfa->mb_cur_max) {
#line 98
          break;
        }
#line 99
        ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2U);
#line 100
        if ((int )ret != 0) {
#line 101
          return (ret);
        }
      }
    } else {
#line 106
      build_upper_buffer(pstr);
    }
  } else
#line 111
  if (dfa->mb_cur_max > 1) {
#line 112
    build_wcs_buffer(pstr);
  } else
#line 116
  if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 117
    re_string_translate_buffer(pstr);
  } else {
#line 120
    pstr->valid_len = pstr->bufs_len;
#line 121
    pstr->valid_raw_len = pstr->bufs_len;
  }
#line 126
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 131 "regex_internal.c"
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , Idx new_buf_len ) 
{ wint_t *new_wcs ;
  size_t max_object_size ;
  void *__cil_tmp ;
  Idx *new_offsets ;
  void *__cil_tmp___0 ;
  unsigned char *new_mbs ;
  void *__cil_tmp___1 ;

  {
#line 136
  if (pstr->mb_cur_max > 1) {
#line 141
    max_object_size = sizeof(wint_t ) < sizeof(Idx ) ? sizeof(Idx ) : sizeof(wint_t );
#line 142
    if ((((1U << 31) - 1U) * 2U + 1U) / max_object_size < new_buf_len) {
#line 143
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 145
    __cil_tmp = rpl_realloc((void *)pstr->wcs, new_buf_len * sizeof(wint_t ));
#line 145
    new_wcs = (wint_t *)__cil_tmp;
#line 146
    if ((unsigned int )new_wcs == (unsigned int )((void *)0)) {
#line 147
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 148
    pstr->wcs = new_wcs;
#line 149
    if ((unsigned int )pstr->offsets != (unsigned int )((void *)0)) {
#line 151
      __cil_tmp___0 = rpl_realloc((void *)pstr->offsets, new_buf_len * sizeof(Idx ));
#line 151
      new_offsets = (Idx *)__cil_tmp___0;
#line 152
      if ((unsigned int )new_offsets == (unsigned int )((void *)0)) {
#line 153
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 154
      pstr->offsets = new_offsets;
    }
  }
#line 158
  if (pstr->mbs_allocated) {
#line 160
    __cil_tmp___1 = rpl_realloc((void *)pstr->mbs, new_buf_len * sizeof(unsigned char ));
#line 160
    new_mbs = (unsigned char *)__cil_tmp___1;
#line 162
    if ((unsigned int )new_mbs == (unsigned int )((void *)0)) {
#line 163
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 164
    pstr->mbs = new_mbs;
  }
#line 166
  pstr->bufs_len = new_buf_len;
#line 167
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 171 "regex_internal.c"
static void re_string_construct_common(char const   *str , Idx len , re_string_t *pstr ,
                                       unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) 
{ 

  {
#line 177
  pstr->raw_mbs = (unsigned char const   *)str;
#line 178
  pstr->len = len;
#line 179
  pstr->raw_len = len;
#line 180
  pstr->trans = trans;
#line 181
  pstr->icase = (unsigned char )icase;
#line 182
  pstr->mbs_allocated = (unsigned char )((unsigned int )trans != (unsigned int )((void *)0) || icase);
#line 183
  pstr->mb_cur_max = (int )dfa->mb_cur_max;
#line 184
  pstr->is_utf8 = (unsigned char )dfa->is_utf8;
#line 185
  pstr->map_notascii = (unsigned char )dfa->map_notascii;
#line 186
  pstr->stop = pstr->len;
#line 187
  pstr->raw_stop = pstr->stop;
#line 188
  return;
}
}
#line 203 "regex_internal.c"
static void build_wcs_buffer(re_string_t *pstr ) 
{ unsigned char buf___0[64] ;
  mbstate_t prev_st ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  wchar_t wc ;
  char const   *p ;
  int i ;
  int ch ;
  unsigned char __cil_tmp ;
  Idx __cil_tmp___0 ;
  Idx __cil_tmp___1 ;

  {
#line 219
  end_idx = pstr->bufs_len > pstr->len ? pstr->len : pstr->bufs_len;
#line 220
  byte_idx = pstr->valid_len;
#line 220
  while (byte_idx < end_idx) {
#line 225
    remain_len = end_idx - byte_idx;
#line 226
    prev_st = pstr->cur_state;
#line 228
    if ((unsigned int )pstr->trans != (unsigned int )((void *)0)) {
#line 232
      i = 0;
#line 232
      while (i < pstr->mb_cur_max && (unsigned int )i < remain_len) {
#line 234
        ch = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + byte_idx) + (unsigned int )i));
#line 235
        __cil_tmp = *(pstr->trans + ch);
#line 235
        *(pstr->mbs + (byte_idx + (unsigned int )i)) = __cil_tmp;
#line 235
        buf___0[i] = __cil_tmp;
#line 232
        i ++;
      }
#line 237
      p = (char const   *)(buf___0);
    } else {
#line 240
      p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx;
    }
#line 241
    mbclen = mbrtowc(& wc, p, remain_len, & pstr->cur_state);
#line 242
    if (mbclen == 4294967294U) {
#line 245
      pstr->cur_state = prev_st;
#line 246
      break;
    } else
#line 248
    if (mbclen == 4294967295U || mbclen == 0U) {
#line 251
      mbclen = 1U;
#line 252
      wc = (short )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 253
      if ((unsigned int )pstr->trans != (unsigned int )((void *)0)) {
#line 254
        wc = (short )*(pstr->trans + (int )wc);
      }
#line 255
      pstr->cur_state = prev_st;
    }
#line 259
    __cil_tmp___0 = byte_idx;
#line 259
    byte_idx ++;
#line 259
    *(pstr->wcs + __cil_tmp___0) = (int )wc;
#line 261
    remain_len = (byte_idx + mbclen) - 1U;
#line 261
    while (byte_idx < remain_len) {
#line 262
      __cil_tmp___1 = byte_idx;
#line 262
      byte_idx ++;
#line 262
      *(pstr->wcs + __cil_tmp___1) = -1;
    }
  }
#line 264
  pstr->valid_len = byte_idx;
#line 265
  pstr->valid_raw_len = byte_idx;
#line 266
  return;
}
}
#line 271 "regex_internal.c"
static reg_errcode_t build_wcs_upper_buffer(re_string_t *pstr ) 
{ mbstate_t prev_st ;
  Idx src_idx ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  char buf___0[64] ;
  wchar_t wc ;
  unsigned char __x ;
  int __cil_tmp ;
  wchar_t wcu ;
  size_t mbcdlen ;
  wint_t __cil_tmp___0 ;
  int __cil_tmp___1 ;
  Idx __cil_tmp___2 ;
  Idx __cil_tmp___3 ;
  int ch ;
  Idx __cil_tmp___4 ;
  wchar_t wc___0 ;
  char const   *p ;
  int i ;
  int ch___0 ;
  wchar_t wcu___0 ;
  size_t mbcdlen___0 ;
  wint_t __cil_tmp___5 ;
  size_t i___0 ;
  void *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  size_t i___1 ;
  Idx __cil_tmp___8 ;
  Idx __cil_tmp___9 ;
  int ch___1 ;
  Idx __cil_tmp___10 ;

  {
#line 285
  byte_idx = pstr->valid_len;
#line 286
  end_idx = pstr->bufs_len > pstr->len ? pstr->len : pstr->bufs_len;
#line 290
  if ((! pstr->map_notascii && (unsigned int )pstr->trans == (unsigned int )((void *)0)) && ! pstr->offsets_needed) {
#line 292
    while (byte_idx < end_idx) {
#line 296
      if ((unsigned int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)) <= 127U) {
#line 296
        __cil_tmp = mbsinit((mbstate_t const   *)(& pstr->cur_state));
#line 296
        if (__cil_tmp) {
#line 301
          __x = (unsigned char )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 301
          *(pstr->mbs + byte_idx) = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 2 ? ((int )__x - 97) + 65 : (int )__x);
#line 304
          *(pstr->wcs + byte_idx) = (int )((short )*(pstr->mbs + byte_idx));
#line 305
          byte_idx ++;
#line 306
          continue;
        }
      }
#line 309
      remain_len = end_idx - byte_idx;
#line 310
      prev_st = pstr->cur_state;
#line 311
      mbclen = mbrtowc(& wc, ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx,
                       remain_len, & pstr->cur_state);
#line 314
      if (mbclen < 4294967294U) {
#line 316
        wcu = wc;
#line 317
        __cil_tmp___1 = iswlower((int )wc);
#line 317
        if (__cil_tmp___1) {
#line 321
          __cil_tmp___0 = towupper((int )wc);
#line 321
          wcu = (short )__cil_tmp___0;
#line 322
          mbcdlen = wcrtomb(buf___0, wcu, & prev_st);
#line 323
          if (mbclen == mbcdlen) {
#line 324
            memcpy((void *)(pstr->mbs + byte_idx), (void const   *)(buf___0), mbclen);
          } else {
#line 327
            src_idx = byte_idx;
#line 328
            goto offsets_needed;
          }
        } else {
#line 332
          memcpy((void *)(pstr->mbs + byte_idx), (void const   *)((pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                 mbclen);
        }
#line 334
        __cil_tmp___2 = byte_idx;
#line 334
        byte_idx ++;
#line 334
        *(pstr->wcs + __cil_tmp___2) = (int )wcu;
#line 336
        remain_len = (byte_idx + mbclen) - 1U;
#line 336
        while (byte_idx < remain_len) {
#line 337
          __cil_tmp___3 = byte_idx;
#line 337
          byte_idx ++;
#line 337
          *(pstr->wcs + __cil_tmp___3) = -1;
        }
      } else
#line 339
      if (mbclen == 4294967295U || mbclen == 0U) {
#line 342
        ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 343
        *(pstr->mbs + byte_idx) = (unsigned char )ch;
#line 345
        __cil_tmp___4 = byte_idx;
#line 345
        byte_idx ++;
#line 345
        *(pstr->wcs + __cil_tmp___4) = (int )((short )ch);
#line 346
        if (mbclen == 4294967295U) {
#line 347
          pstr->cur_state = prev_st;
        }
      } else {
#line 352
        pstr->cur_state = prev_st;
#line 353
        break;
      }
    }
#line 356
    pstr->valid_len = byte_idx;
#line 357
    pstr->valid_raw_len = byte_idx;
#line 358
    return ((enum __anonenum_reg_errcode_t_7 )0);
  } else {
#line 361
    src_idx = pstr->valid_raw_len;
#line 361
    while (byte_idx < end_idx) {
      offsets_needed: 
#line 366
      remain_len = end_idx - byte_idx;
#line 367
      prev_st = pstr->cur_state;
#line 368
      if ((unsigned int )pstr->trans != (unsigned int )((void *)0)) {
#line 372
        i = 0;
#line 372
        while (i < pstr->mb_cur_max && (unsigned int )i < remain_len) {
#line 374
          ch___0 = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + src_idx) + (unsigned int )i));
#line 375
          buf___0[i] = (char )*(pstr->trans + ch___0);
#line 372
          i ++;
        }
#line 377
        p = (char const   *)(buf___0);
      } else {
#line 380
        p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + src_idx;
      }
#line 381
      mbclen = mbrtowc(& wc___0, p, remain_len, & pstr->cur_state);
#line 382
      if (mbclen < 4294967294U) {
#line 384
        wcu___0 = wc___0;
#line 385
        __cil_tmp___7 = iswlower((int )wc___0);
#line 385
        if (__cil_tmp___7) {
#line 389
          __cil_tmp___5 = towupper((int )wc___0);
#line 389
          wcu___0 = (short )__cil_tmp___5;
#line 390
          mbcdlen___0 = wcrtomb(buf___0, wcu___0, & prev_st);
#line 391
          if (mbclen == mbcdlen___0) {
#line 392
            memcpy((void *)(pstr->mbs + byte_idx), (void const   *)(buf___0), mbclen);
          } else
#line 393
          if (mbcdlen___0 != 4294967295U) {
#line 397
            if (byte_idx + mbcdlen___0 > pstr->bufs_len) {
#line 399
              pstr->cur_state = prev_st;
#line 400
              break;
            }
#line 403
            if ((unsigned int )pstr->offsets == (unsigned int )((void *)0)) {
#line 405
              __cil_tmp___6 = rpl_malloc(pstr->bufs_len * sizeof(Idx ));
#line 405
              pstr->offsets = (Idx *)__cil_tmp___6;
#line 407
              if ((unsigned int )pstr->offsets == (unsigned int )((void *)0)) {
#line 408
                return ((enum __anonenum_reg_errcode_t_7 )12);
              }
            }
#line 410
            if (! pstr->offsets_needed) {
#line 412
              i___0 = 0U;
#line 412
              while (i___0 < byte_idx) {
#line 413
                *(pstr->offsets + i___0) = i___0;
#line 412
                i___0 ++;
              }
#line 414
              pstr->offsets_needed = (unsigned char)1;
            }
#line 417
            memcpy((void *)(pstr->mbs + byte_idx), (void const   *)(buf___0), mbcdlen___0);
#line 418
            *(pstr->wcs + byte_idx) = (int )wcu___0;
#line 419
            *(pstr->offsets + byte_idx) = src_idx;
#line 420
            i___0 = 1U;
#line 420
            while (i___0 < mbcdlen___0) {
#line 422
              *(pstr->offsets + (byte_idx + i___0)) = src_idx + (i___0 < mbclen ? i___0 : mbclen - 1U);
#line 424
              *(pstr->wcs + (byte_idx + i___0)) = -1;
#line 420
              i___0 ++;
            }
#line 426
            pstr->len += mbcdlen___0 - mbclen;
#line 427
            if (pstr->raw_stop > src_idx) {
#line 428
              pstr->stop += mbcdlen___0 - mbclen;
            }
#line 429
            end_idx = pstr->bufs_len > pstr->len ? pstr->len : pstr->bufs_len;
#line 431
            byte_idx += mbcdlen___0;
#line 432
            src_idx += mbclen;
#line 433
            goto __Cont;
          } else {
#line 436
            memcpy((void *)(pstr->mbs + byte_idx), (void const   *)p, mbclen);
          }
        } else {
#line 439
          memcpy((void *)(pstr->mbs + byte_idx), (void const   *)p, mbclen);
        }
#line 441
        if ((int )pstr->offsets_needed != 0) {
#line 444
          i___1 = 0U;
#line 444
          while (i___1 < mbclen) {
#line 445
            *(pstr->offsets + (byte_idx + i___1)) = src_idx + i___1;
#line 444
            i___1 ++;
          }
        }
#line 447
        src_idx += mbclen;
#line 449
        __cil_tmp___8 = byte_idx;
#line 449
        byte_idx ++;
#line 449
        *(pstr->wcs + __cil_tmp___8) = (int )wcu___0;
#line 451
        remain_len = (byte_idx + mbclen) - 1U;
#line 451
        while (byte_idx < remain_len) {
#line 452
          __cil_tmp___9 = byte_idx;
#line 452
          byte_idx ++;
#line 452
          *(pstr->wcs + __cil_tmp___9) = -1;
        }
      } else
#line 454
      if (mbclen == 4294967295U || mbclen == 0U) {
#line 457
        ch___1 = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + src_idx));
#line 459
        if ((unsigned int )pstr->trans != (unsigned int )((void *)0)) {
#line 460
          ch___1 = (int )*(pstr->trans + ch___1);
        }
#line 461
        *(pstr->mbs + byte_idx) = (unsigned char )ch___1;
#line 463
        if ((int )pstr->offsets_needed != 0) {
#line 464
          *(pstr->offsets + byte_idx) = src_idx;
        }
#line 465
        src_idx ++;
#line 468
        __cil_tmp___10 = byte_idx;
#line 468
        byte_idx ++;
#line 468
        *(pstr->wcs + __cil_tmp___10) = (int )((short )ch___1);
#line 469
        if (mbclen == 4294967295U) {
#line 470
          pstr->cur_state = prev_st;
        }
      } else {
#line 475
        pstr->cur_state = prev_st;
#line 476
        break;
      }
      __Cont: ;
    }
  }
#line 479
  pstr->valid_len = byte_idx;
#line 480
  pstr->valid_raw_len = src_idx;
#line 481
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 487 "regex_internal.c"
static Idx re_string_skip_chars(re_string_t *pstr , Idx new_raw_idx , wint_t *last_wc ) 
{ mbstate_t prev_st ;
  Idx rawbuf_idx ;
  size_t mbclen ;
  wint_t wc ;
  wchar_t wc2 ;
  Idx remain_len ;

  {
#line 494
  wc = -1;
#line 497
  rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;
#line 497
  while (rawbuf_idx < new_raw_idx) {
#line 502
    remain_len = pstr->len - rawbuf_idx;
#line 503
    prev_st = pstr->cur_state;
#line 504
    mbclen = mbrtowc(& wc2, (char const   *)pstr->raw_mbs + rawbuf_idx, remain_len,
                     & pstr->cur_state);
#line 506
    if ((mbclen == 4294967294U || mbclen == 4294967295U) || mbclen == 0U) {
#line 509
      if (mbclen == 0U || remain_len == 0U) {
#line 510
        wc = 0;
      } else {
#line 512
        wc = (int )*((unsigned char *)(pstr->raw_mbs + rawbuf_idx));
      }
#line 513
      mbclen = 1U;
#line 514
      pstr->cur_state = prev_st;
    } else {
#line 517
      wc = (int )wc2;
    }
#line 519
    rawbuf_idx += mbclen;
  }
#line 521
  *last_wc = wc;
#line 522
  return (rawbuf_idx);
}
}
#line 529 "regex_internal.c"
static void build_upper_buffer(re_string_t *pstr ) 
{ Idx char_idx ;
  Idx end_idx ;
  int ch ;
  int __x ;

  {
#line 534
  end_idx = pstr->bufs_len > pstr->len ? pstr->len : pstr->bufs_len;
#line 536
  char_idx = pstr->valid_len;
#line 536
  while (char_idx < end_idx) {
#line 538
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + char_idx));
#line 539
    if ((unsigned int )pstr->trans != (unsigned int )((void *)0)) {
#line 540
      ch = (int )*(pstr->trans + ch);
    }
#line 541
    if (((int const   )*((__ctype_ptr__ + sizeof(*("" + ch))) + ch) & 3) == 2) {
#line 542
      __x = ch;
#line 542
      *(pstr->mbs + char_idx) = (unsigned char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + __x))) + __x) & 3) == 2 ? (__x - 97) + 65 : __x);
    } else {
#line 544
      *(pstr->mbs + char_idx) = (unsigned char )ch;
    }
#line 536
    char_idx ++;
  }
#line 546
  pstr->valid_len = char_idx;
#line 547
  pstr->valid_raw_len = char_idx;
#line 548
  return;
}
}
#line 552 "regex_internal.c"
static void re_string_translate_buffer(re_string_t *pstr ) 
{ Idx buf_idx ;
  Idx end_idx ;
  int ch ;

  {
#line 557
  end_idx = pstr->bufs_len > pstr->len ? pstr->len : pstr->bufs_len;
#line 559
  buf_idx = pstr->valid_len;
#line 559
  while (buf_idx < end_idx) {
#line 561
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + buf_idx));
#line 562
    *(pstr->mbs + buf_idx) = *(pstr->trans + ch);
#line 559
    buf_idx ++;
  }
#line 565
  pstr->valid_len = buf_idx;
#line 566
  pstr->valid_raw_len = buf_idx;
#line 567
  return;
}
}
#line 573 "regex_internal.c"
static reg_errcode_t re_string_reconstruct(re_string_t *pstr , Idx idx , int eflags ) 
{ Idx offset ;
  Idx low ;
  Idx high ;
  Idx mid ;
  Idx prev_valid_len ;
  Idx wcs_idx ;
  wint_t wc ;
  unsigned char const   *raw ;
  unsigned char const   *p ;
  unsigned char const   *end ;
  mbstate_t cur_state ;
  wchar_t wc2 ;
  Idx mlen ;
  unsigned char buf___0[6] ;
  size_t mbclen ;
  int i ;
  Idx __cil_tmp ;
  int __cil_tmp___1 ;
  int c ;
  _Bool __cil_tmp___2 ;
  reg_errcode_t ret ;
  reg_errcode_t __cil_tmp___3 ;

  {
#line 579
  if (pstr->raw_mbs_idx <= idx) {
#line 580
    offset = idx - pstr->raw_mbs_idx;
  } else {
#line 585
    if (pstr->mb_cur_max > 1) {
#line 586
      memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
    }
#line 588
    pstr->len = pstr->raw_len;
#line 589
    pstr->stop = pstr->raw_stop;
#line 590
    pstr->valid_len = 0U;
#line 591
    pstr->raw_mbs_idx = 0U;
#line 592
    pstr->valid_raw_len = 0U;
#line 593
    pstr->offsets_needed = (unsigned char)0;
#line 594
    pstr->tip_context = (unsigned int )(eflags & 1 ? (1 << 1) << 1 : (1 << 1) | ((1 << 1) << 1));
#line 596
    if (! pstr->mbs_allocated) {
#line 597
      pstr->mbs = (unsigned char *)pstr->raw_mbs;
    }
#line 598
    offset = idx;
  }
#line 601
  if (offset != 0U) {
#line 604
    if (offset < pstr->valid_raw_len) {
#line 608
      if (pstr->offsets_needed) {
#line 610
        low = 0U;
#line 610
        high = pstr->valid_len;
#line 611
        while (1) {
#line 613
          mid = (high + low) / 2U;
#line 614
          if (*(pstr->offsets + mid) > offset) {
#line 615
            high = mid;
          } else
#line 616
          if (*(pstr->offsets + mid) < offset) {
#line 617
            low = mid + 1U;
          } else {
#line 619
            break;
          }
#line 611
          if (! (low < high)) {
#line 611
            break;
          }
        }
#line 622
        if (*(pstr->offsets + mid) < offset) {
#line 623
          mid ++;
        }
#line 624
        pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, mid - 1U,
                                                 eflags);
#line 630
        if ((pstr->valid_len > offset && mid == offset) && *(pstr->offsets + mid) == offset) {
#line 633
          memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (pstr->valid_len - offset) * sizeof(wint_t ));
#line 635
          memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), pstr->valid_len - offset);
#line 636
          pstr->valid_len -= offset;
#line 637
          pstr->valid_raw_len -= offset;
#line 638
          low = 0U;
#line 638
          while (low < pstr->valid_len) {
#line 639
            *(pstr->offsets + low) = *(pstr->offsets + (low + offset)) - offset;
#line 638
            low ++;
          }
        } else {
#line 645
          pstr->len = (pstr->raw_len - idx) + offset;
#line 646
          pstr->stop = (pstr->raw_stop - idx) + offset;
#line 647
          pstr->offsets_needed = (unsigned char)0;
#line 648
          while (mid > 0U && *(pstr->offsets + (mid - 1U)) == offset) {
#line 649
            mid --;
          }
#line 650
          while (mid < pstr->valid_len) {
#line 651
            if (*(pstr->wcs + mid) != -1) {
#line 652
              break;
            } else {
#line 654
              mid ++;
            }
          }
#line 655
          if (mid == pstr->valid_len) {
#line 656
            pstr->valid_len = 0U;
          } else {
#line 659
            pstr->valid_len = *(pstr->offsets + mid) - offset;
#line 660
            if (pstr->valid_len) {
#line 662
              low = 0U;
#line 662
              while (low < pstr->valid_len) {
#line 663
                *(pstr->wcs + low) = -1;
#line 662
                low ++;
              }
#line 664
              memset((void *)pstr->mbs, 255, pstr->valid_len);
            }
          }
#line 667
          pstr->valid_raw_len = pstr->valid_len;
        }
      } else {
#line 673
        pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, offset - 1U,
                                                 eflags);
#line 676
        if (pstr->mb_cur_max > 1) {
#line 677
          memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (pstr->valid_len - offset) * sizeof(wint_t ));
        }
#line 680
        if (pstr->mbs_allocated) {
#line 681
          memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), pstr->valid_len - offset);
        }
#line 683
        pstr->valid_len -= offset;
#line 684
        pstr->valid_raw_len -= offset;
      }
    } else {
#line 693
      prev_valid_len = pstr->valid_len;
#line 696
      if (pstr->offsets_needed) {
#line 698
        pstr->len = (pstr->raw_len - idx) + offset;
#line 699
        pstr->stop = (pstr->raw_stop - idx) + offset;
#line 700
        pstr->offsets_needed = (unsigned char)0;
      }
#line 703
      pstr->valid_len = 0U;
#line 705
      if (pstr->mb_cur_max > 1) {
#line 708
        wc = -1;
#line 710
        if (pstr->is_utf8) {
#line 716
          raw = pstr->raw_mbs + pstr->raw_mbs_idx;
#line 717
          end = raw + (offset - (unsigned int )pstr->mb_cur_max);
#line 718
          if ((unsigned int )end < (unsigned int )pstr->raw_mbs) {
#line 719
            end = pstr->raw_mbs;
          }
#line 720
          p = (raw + offset) - 1;
#line 732
          while ((unsigned int )p >= (unsigned int )end) {
#line 733
            if (((int const   )*p & 192) != 128) {
#line 737
              mlen = (unsigned int )((raw + pstr->len) - p);
#line 741
              if ((unsigned int )pstr->trans != (unsigned int )((void *)0)) {
#line 743
                i = (int )(mlen < 6U ? mlen : 6U);
#line 744
                while (1) {
#line 744
                  i --;
#line 744
                  if (! (i >= 0)) {
#line 744
                    break;
                  }
#line 745
                  buf___0[i] = *(pstr->trans + (int const   )*(p + i));
                }
              }
#line 749
              memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 750
              mbclen = mbrtowc(& wc2, (char const   *)p, mlen, & cur_state);
#line 752
              if ((unsigned int )((raw + offset) - p) <= mbclen && mbclen < 4294967294U) {
#line 755
                memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
#line 757
                pstr->valid_len = mbclen - (unsigned int )((raw + offset) - p);
#line 758
                wc = (int )wc2;
              }
#line 760
              break;
            }
#line 732
            p --;
          }
        }
#line 764
        if (wc == -1) {
#line 765
          __cil_tmp = re_string_skip_chars(pstr, idx, & wc);
#line 765
          pstr->valid_len = __cil_tmp - idx;
        }
#line 766
        if (wc == -1) {
#line 767
          pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, prev_valid_len - 1U,
                                                   eflags);
        } else
#line 770
        if ((int )pstr->word_ops_used != 0) {
#line 770
          __cil_tmp___1 = iswalnum(wc);
#line 770
          if (__cil_tmp___1 || wc == 95) {
#line 770
            pstr->tip_context = 1U;
          } else {
#line 770
            pstr->tip_context = (unsigned int )(wc == 10 && pstr->newline_anchor ? 1 << 1 : 0);
          }
        } else {
#line 770
          pstr->tip_context = (unsigned int )(wc == 10 && pstr->newline_anchor ? 1 << 1 : 0);
        }
#line 776
        if (pstr->valid_len) {
#line 778
          wcs_idx = 0U;
#line 778
          while (wcs_idx < pstr->valid_len) {
#line 779
            *(pstr->wcs + wcs_idx) = -1;
#line 778
            wcs_idx ++;
          }
#line 780
          if (pstr->mbs_allocated) {
#line 781
            memset((void *)pstr->mbs, 255, pstr->valid_len);
          }
        }
#line 783
        pstr->valid_raw_len = pstr->valid_len;
      } else {
#line 788
        c = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + offset) - 1U));
#line 789
        pstr->valid_raw_len = 0U;
#line 790
        if (pstr->trans) {
#line 791
          c = (int )*(pstr->trans + c);
        }
#line 792
        __cil_tmp___2 = bitset_contain((bitset_word_t *)pstr->word_char, (unsigned int )c);
#line 792
        pstr->tip_context = (unsigned int )(__cil_tmp___2 ? 1 : (c == 10 && pstr->newline_anchor ? 1 << 1 : 0));
      }
    }
#line 798
    if (! pstr->mbs_allocated) {
#line 799
      pstr->mbs += offset;
    }
  }
#line 801
  pstr->raw_mbs_idx = idx;
#line 802
  pstr->len -= offset;
#line 803
  pstr->stop -= offset;
#line 807
  if (pstr->mb_cur_max > 1) {
#line 809
    if (pstr->icase) {
#line 811
      __cil_tmp___3 = build_wcs_upper_buffer(pstr);
#line 811
      ret = __cil_tmp___3;
#line 812
      if ((int )ret != 0) {
#line 813
        return (ret);
      }
    } else {
#line 816
      build_wcs_buffer(pstr);
    }
  } else
#line 820
  if (pstr->mbs_allocated) {
#line 822
    if (pstr->icase) {
#line 823
      build_upper_buffer(pstr);
    } else
#line 824
    if ((unsigned int )pstr->trans != (unsigned int )((void *)0)) {
#line 825
      re_string_translate_buffer(pstr);
    }
  } else {
#line 828
    pstr->valid_len = pstr->len;
  }
#line 830
  pstr->cur_idx = 0U;
#line 831
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 834 "regex_internal.c"
static unsigned char re_string_peek_byte_case(re_string_t const   *pstr , Idx idx ) 
{ int ch ;
  Idx off ;

  {
#line 842
  if (! pstr->mbs_allocated) {
#line 843
    return (*(pstr->mbs + (pstr->cur_idx + (unsigned int const   )idx)));
  }
#line 846
  if (pstr->mb_cur_max > 1 && ! (*(pstr->wcs + (pstr->cur_idx + (unsigned int const   )idx)) != -1 && (pstr->valid_len == (pstr->cur_idx + (unsigned int const   )idx) + 1U || *(pstr->wcs + ((pstr->cur_idx + (unsigned int const   )idx) + 1U)) != -1))) {
#line 848
    return (*(pstr->mbs + (pstr->cur_idx + (unsigned int const   )idx)));
  }
#line 851
  off = (unsigned int )(pstr->cur_idx + (unsigned int const   )idx);
#line 853
  if (pstr->offsets_needed) {
#line 854
    off = *(pstr->offsets + off);
  }
#line 857
  ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + (unsigned int const   )off));
#line 864
  if (pstr->offsets_needed && ! ((unsigned int )ch <= 127U)) {
#line 865
    return (*(pstr->mbs + (pstr->cur_idx + (unsigned int const   )idx)));
  }
#line 868
  return ((unsigned char )ch);
}
}
#line 871 "regex_internal.c"
static unsigned char re_string_fetch_byte_case(re_string_t *pstr ) 
{ Idx __cil_tmp ;
  Idx off ;
  int ch ;
  Idx __cil_tmp___0 ;
  Idx __cil_tmp___1 ;
  int __cil_tmp___2 ;
  Idx __cil_tmp___3 ;

  {
#line 875
  if (! pstr->mbs_allocated) {
#line 876
    __cil_tmp = pstr->cur_idx;
#line 876
    (pstr->cur_idx) ++;
#line 876
    return (*(pstr->mbs + __cil_tmp));
  }
#line 879
  if (pstr->offsets_needed) {
#line 891
    if (! (pstr->cur_idx == pstr->valid_len || *(pstr->wcs + pstr->cur_idx) != -1)) {
#line 892
      __cil_tmp___0 = pstr->cur_idx;
#line 892
      (pstr->cur_idx) ++;
#line 892
      return (*(pstr->mbs + __cil_tmp___0));
    }
#line 894
    off = *(pstr->offsets + pstr->cur_idx);
#line 895
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + off));
#line 897
    if (! ((unsigned int )ch <= 127U)) {
#line 898
      __cil_tmp___1 = pstr->cur_idx;
#line 898
      (pstr->cur_idx) ++;
#line 898
      return (*(pstr->mbs + __cil_tmp___1));
    }
#line 900
    __cil_tmp___2 = re_string_char_size_at((re_string_t const   *)pstr, pstr->cur_idx);
#line 900
    pstr->cur_idx += (unsigned int )__cil_tmp___2;
#line 902
    return ((unsigned char )ch);
  }
#line 906
  __cil_tmp___3 = pstr->cur_idx;
#line 906
  (pstr->cur_idx) ++;
#line 906
  return ((unsigned char )*(pstr->raw_mbs + (pstr->raw_mbs_idx + __cil_tmp___3)));
}
}
#line 909 "regex_internal.c"
static void re_string_destruct(re_string_t *pstr ) 
{ 

  {
#line 914
  free((void *)pstr->wcs);
#line 915
  free((void *)pstr->offsets);
#line 917
  if (pstr->mbs_allocated) {
#line 918
    free((void *)pstr->mbs);
  }
#line 919
  return;
}
}
#line 923 "regex_internal.c"
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags ) 
{ int c ;
  wint_t wc ;
  Idx wc_idx ;
  int __cil_tmp ;
  _Bool __cil_tmp___0 ;

  {
#line 928
  if (! (idx < 4294967294U)) {
#line 931
    return ((unsigned int )input->tip_context);
  }
#line 932
  if (idx == (unsigned int )input->len) {
#line 933
    return ((unsigned int )(eflags & (1 << 1) ? ((1 << 1) << 1) << 1 : (1 << 1) | (((1 << 1) << 1) << 1)));
  }
#line 936
  if (input->mb_cur_max > 1) {
#line 939
    wc_idx = idx;
#line 940
    while (*(input->wcs + wc_idx) == -1) {
#line 946
      wc_idx --;
#line 947
      if (! (wc_idx < 4294967294U)) {
#line 948
        return ((unsigned int )input->tip_context);
      }
    }
#line 950
    wc = *(input->wcs + wc_idx);
#line 951
    if ((int const   )input->word_ops_used != 0) {
#line 951
      __cil_tmp = iswalnum(wc);
#line 951
      if (__cil_tmp || wc == 95) {
#line 952
        return (1U);
      }
    }
#line 953
    return ((unsigned int )(wc == 10 && input->newline_anchor ? 1 << 1 : 0));
  } else {
#line 959
    c = (int )*(input->mbs + idx);
#line 960
    __cil_tmp___0 = bitset_contain((bitset_word_t *)input->word_char, (unsigned int )c);
#line 960
    if (__cil_tmp___0) {
#line 961
      return (1U);
    }
#line 962
    return ((unsigned int )(c == 10 && input->newline_anchor ? 1 << 1 : 0));
  }
}
}
#line 968 "regex_internal.c"
static reg_errcode_t re_node_set_alloc(re_node_set *set , Idx size ) 
{ void *__cil_tmp ;

  {
#line 972
  set->alloc = size;
#line 973
  set->nelem = 0U;
#line 974
  __cil_tmp = rpl_malloc(size * sizeof(Idx ));
#line 974
  set->elems = (Idx *)__cil_tmp;
#line 975
  if ((unsigned int )set->elems == (unsigned int )((void *)0)) {
#line 976
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 977
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 980 "regex_internal.c"
static reg_errcode_t re_node_set_init_1(re_node_set *set , Idx elem ) 
{ void *__cil_tmp ;
  Idx __cil_tmp___0 ;

  {
#line 984
  set->alloc = 1U;
#line 985
  set->nelem = 1U;
#line 986
  __cil_tmp = rpl_malloc(sizeof(Idx ));
#line 986
  set->elems = (Idx *)__cil_tmp;
#line 987
  if ((unsigned int )set->elems == (unsigned int )((void *)0)) {
#line 989
    __cil_tmp___0 = 0U;
#line 989
    set->nelem = __cil_tmp___0;
#line 989
    set->alloc = __cil_tmp___0;
#line 990
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 992
  *(set->elems + 0) = elem;
#line 993
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 996 "regex_internal.c"
static reg_errcode_t re_node_set_init_2(re_node_set *set , Idx elem1 , Idx elem2 ) 
{ void *__cil_tmp ;

  {
#line 1000
  set->alloc = 2U;
#line 1001
  __cil_tmp = rpl_malloc(2U * sizeof(Idx ));
#line 1001
  set->elems = (Idx *)__cil_tmp;
#line 1002
  if ((unsigned int )set->elems == (unsigned int )((void *)0)) {
#line 1003
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 1004
  if (elem1 == elem2) {
#line 1006
    set->nelem = 1U;
#line 1007
    *(set->elems + 0) = elem1;
  } else {
#line 1011
    set->nelem = 2U;
#line 1012
    if (elem1 < elem2) {
#line 1014
      *(set->elems + 0) = elem1;
#line 1015
      *(set->elems + 1) = elem2;
    } else {
#line 1019
      *(set->elems + 0) = elem2;
#line 1020
      *(set->elems + 1) = elem1;
    }
  }
#line 1023
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1026 "regex_internal.c"
static reg_errcode_t re_node_set_init_copy(re_node_set *dest , re_node_set const   *src ) 
{ void *__cil_tmp ;
  Idx __cil_tmp___0 ;

  {
#line 1030
  dest->nelem = (unsigned int )src->nelem;
#line 1031
  if (src->nelem > 0U) {
#line 1033
    dest->alloc = dest->nelem;
#line 1034
    __cil_tmp = rpl_malloc(dest->alloc * sizeof(Idx ));
#line 1034
    dest->elems = (Idx *)__cil_tmp;
#line 1035
    if ((unsigned int )dest->elems == (unsigned int )((void *)0)) {
#line 1037
      __cil_tmp___0 = 0U;
#line 1037
      dest->nelem = __cil_tmp___0;
#line 1037
      dest->alloc = __cil_tmp___0;
#line 1038
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 1040
    memcpy((void *)dest->elems, (void const   *)src->elems, (unsigned int )(src->nelem * (unsigned int const   )sizeof(Idx )));
  } else {
#line 1043
    memset((void *)dest, '\000', sizeof(re_node_set ));
  }
#line 1044
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1051 "regex_internal.c"
static reg_errcode_t re_node_set_add_intersect(re_node_set *dest , re_node_set const   *src1 ,
                                               re_node_set const   *src2 ) 
{ Idx i1 ;
  Idx i2 ;
  Idx is ;
  Idx id ;
  Idx delta ;
  Idx sbase ;
  Idx new_alloc ;
  Idx *new_elems ;
  void *__cil_tmp ;
  Idx __cil_tmp___0 ;
  Idx __cil_tmp___1 ;

  {
#line 1057
  if (src1->nelem == 0U || src2->nelem == 0U) {
#line 1058
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
#line 1062
  if ((src1->nelem + src2->nelem) + (unsigned int const   )dest->nelem > (unsigned int const   )dest->alloc) {
#line 1064
    new_alloc = (unsigned int )((src1->nelem + src2->nelem) + (unsigned int const   )dest->alloc);
#line 1065
    __cil_tmp = rpl_realloc((void *)dest->elems, new_alloc * sizeof(Idx ));
#line 1065
    new_elems = (Idx *)__cil_tmp;
#line 1066
    if ((unsigned int )new_elems == (unsigned int )((void *)0)) {
#line 1067
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 1068
    dest->elems = new_elems;
#line 1069
    dest->alloc = new_alloc;
  }
#line 1074
  sbase = (dest->nelem + (unsigned int )src1->nelem) + (unsigned int )src2->nelem;
#line 1075
  i1 = (unsigned int )(src1->nelem - 1U);
#line 1076
  i2 = (unsigned int )(src2->nelem - 1U);
#line 1077
  id = dest->nelem - 1U;
#line 1078
  while (1) {
#line 1080
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 1083
      while (id < 4294967294U && *(dest->elems + id) > *(src1->elems + i1)) {
#line 1084
        id --;
      }
#line 1086
      if (! (id < 4294967294U) || *(dest->elems + id) != *(src1->elems + i1)) {
#line 1087
        sbase --;
#line 1087
        *(dest->elems + sbase) = *(src1->elems + i1);
      }
#line 1089
      i1 --;
#line 1089
      if (i1 < 4294967294U) {
#line 1089
        i2 --;
#line 1089
        if (! (i2 < 4294967294U)) {
#line 1090
          break;
        }
      } else {
#line 1090
        break;
      }
    } else
#line 1094
    if (*(src1->elems + i1) < *(src2->elems + i2)) {
#line 1096
      i2 --;
#line 1096
      if (! (i2 < 4294967294U)) {
#line 1097
        break;
      }
    } else {
#line 1101
      i1 --;
#line 1101
      if (! (i1 < 4294967294U)) {
#line 1102
        break;
      }
    }
  }
#line 1106
  id = dest->nelem - 1U;
#line 1107
  is = ((dest->nelem + (unsigned int )src1->nelem) + (unsigned int )src2->nelem) - 1U;
#line 1108
  delta = (is - sbase) + 1U;
#line 1113
  dest->nelem += delta;
#line 1114
  if (delta > 0U && id < 4294967294U) {
#line 1115
    while (1) {
#line 1117
      if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1120
        __cil_tmp___0 = delta;
#line 1120
        delta --;
#line 1120
        __cil_tmp___1 = is;
#line 1120
        is --;
#line 1120
        *(dest->elems + (id + __cil_tmp___0)) = *(dest->elems + __cil_tmp___1);
#line 1121
        if (delta == 0U) {
#line 1122
          break;
        }
      } else {
#line 1127
        *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1128
        id --;
#line 1128
        if (! (id < 4294967294U)) {
#line 1129
          break;
        }
      }
    }
  }
#line 1134
  memcpy((void *)dest->elems, (void const   *)(dest->elems + sbase), delta * sizeof(Idx ));
#line 1136
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1142 "regex_internal.c"
static reg_errcode_t re_node_set_init_union(re_node_set *dest , re_node_set const   *src1 ,
                                            re_node_set const   *src2 ) 
{ Idx i1 ;
  Idx i2 ;
  Idx id ;
  void *__cil_tmp ;
  reg_errcode_t __cil_tmp___0 ;
  reg_errcode_t __cil_tmp___1 ;
  Idx __cil_tmp___2 ;
  Idx __cil_tmp___3 ;
  Idx __cil_tmp___4 ;
  Idx __cil_tmp___5 ;

  {
#line 1148
  if ((((unsigned int )src1 != (unsigned int )((void *)0) && src1->nelem > 0U) && (unsigned int )src2 != (unsigned int )((void *)0)) && src2->nelem > 0U) {
#line 1150
    dest->alloc = (unsigned int )(src1->nelem + src2->nelem);
#line 1151
    __cil_tmp = rpl_malloc(dest->alloc * sizeof(Idx ));
#line 1151
    dest->elems = (Idx *)__cil_tmp;
#line 1152
    if ((unsigned int )dest->elems == (unsigned int )((void *)0)) {
#line 1153
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
  } else {
#line 1157
    if ((unsigned int )src1 != (unsigned int )((void *)0) && src1->nelem > 0U) {
#line 1158
      __cil_tmp___0 = re_node_set_init_copy(dest, src1);
#line 1158
      return (__cil_tmp___0);
    } else
#line 1159
    if ((unsigned int )src2 != (unsigned int )((void *)0) && src2->nelem > 0U) {
#line 1160
      __cil_tmp___1 = re_node_set_init_copy(dest, src2);
#line 1160
      return (__cil_tmp___1);
    } else {
#line 1162
      memset((void *)dest, '\000', sizeof(re_node_set ));
    }
#line 1163
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
#line 1165
  id = 0U;
#line 1165
  i2 = id;
#line 1165
  i1 = i2;
#line 1165
  while (i1 < (unsigned int )src1->nelem && i2 < (unsigned int )src2->nelem) {
#line 1167
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
#line 1169
      __cil_tmp___2 = id;
#line 1169
      id ++;
#line 1169
      __cil_tmp___3 = i2;
#line 1169
      i2 ++;
#line 1169
      *(dest->elems + __cil_tmp___2) = *(src2->elems + __cil_tmp___3);
#line 1170
      goto __Cont;
    }
#line 1172
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 1173
      i2 ++;
    }
#line 1174
    __cil_tmp___4 = id;
#line 1174
    id ++;
#line 1174
    __cil_tmp___5 = i1;
#line 1174
    i1 ++;
#line 1174
    *(dest->elems + __cil_tmp___4) = *(src1->elems + __cil_tmp___5);
    __Cont: ;
  }
#line 1176
  if (i1 < (unsigned int )src1->nelem) {
#line 1178
    memcpy((void *)(dest->elems + id), (void const   *)(src1->elems + i1), (unsigned int )((src1->nelem - (unsigned int const   )i1) * (unsigned int const   )sizeof(Idx )));
#line 1180
    id += (unsigned int )(src1->nelem - (unsigned int const   )i1);
  } else
#line 1182
  if (i2 < (unsigned int )src2->nelem) {
#line 1184
    memcpy((void *)(dest->elems + id), (void const   *)(src2->elems + i2), (unsigned int )((src2->nelem - (unsigned int const   )i2) * (unsigned int const   )sizeof(Idx )));
#line 1186
    id += (unsigned int )(src2->nelem - (unsigned int const   )i2);
  }
#line 1188
  dest->nelem = id;
#line 1189
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1195 "regex_internal.c"
static reg_errcode_t re_node_set_merge(re_node_set *dest , re_node_set const   *src ) 
{ Idx is ;
  Idx id ;
  Idx sbase ;
  Idx delta ;
  Idx new_alloc ;
  Idx *new_buffer ;
  void *__cil_tmp ;
  Idx __cil_tmp___0 ;
  Idx __cil_tmp___1 ;
  Idx __cil_tmp___2 ;

  {
#line 1200
  if ((unsigned int )src == (unsigned int )((void *)0) || src->nelem == 0U) {
#line 1201
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
#line 1202
  if (dest->alloc < 2U * (unsigned int )src->nelem + (unsigned int )((unsigned int const   )dest->nelem)) {
#line 1204
    new_alloc = 2U * (unsigned int )(src->nelem + (unsigned int const   )dest->alloc);
#line 1205
    __cil_tmp = rpl_realloc((void *)dest->elems, new_alloc * sizeof(Idx ));
#line 1205
    new_buffer = (Idx *)__cil_tmp;
#line 1206
    if ((unsigned int )new_buffer == (unsigned int )((void *)0)) {
#line 1207
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 1208
    dest->elems = new_buffer;
#line 1209
    dest->alloc = new_alloc;
  }
#line 1212
  if (dest->nelem == 0U) {
#line 1214
    dest->nelem = (unsigned int )src->nelem;
#line 1215
    memcpy((void *)dest->elems, (void const   *)src->elems, (unsigned int )(src->nelem * (unsigned int const   )sizeof(Idx )));
#line 1216
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
#line 1221
  sbase = dest->nelem + 2U * (unsigned int )src->nelem;
#line 1221
  is = (unsigned int )(src->nelem - 1U);
#line 1221
  id = dest->nelem - 1U;
#line 1221
  while (is < 4294967294U && id < 4294967294U) {
#line 1225
    if (*(dest->elems + id) == *(src->elems + is)) {
#line 1226
      is --;
#line 1226
      id --;
    } else
#line 1227
    if (*(dest->elems + id) < *(src->elems + is)) {
#line 1228
      sbase --;
#line 1228
      __cil_tmp___0 = is;
#line 1228
      is --;
#line 1228
      *(dest->elems + sbase) = *(src->elems + __cil_tmp___0);
    } else {
#line 1230
      id --;
    }
  }
#line 1233
  if (is < 4294967294U) {
#line 1236
    sbase -= is + 1U;
#line 1237
    memcpy((void *)(dest->elems + sbase), (void const   *)src->elems, (is + 1U) * sizeof(Idx ));
  }
#line 1240
  id = dest->nelem - 1U;
#line 1241
  is = (dest->nelem + 2U * (unsigned int )src->nelem) - 1U;
#line 1242
  delta = (is - sbase) + 1U;
#line 1243
  if (delta == 0U) {
#line 1244
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
#line 1248
  dest->nelem += delta;
#line 1249
  while (1) {
#line 1251
    if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1254
      __cil_tmp___1 = delta;
#line 1254
      delta --;
#line 1254
      __cil_tmp___2 = is;
#line 1254
      is --;
#line 1254
      *(dest->elems + (id + __cil_tmp___1)) = *(dest->elems + __cil_tmp___2);
#line 1255
      if (delta == 0U) {
#line 1256
        break;
      }
    } else {
#line 1261
      *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1262
      id --;
#line 1262
      if (! (id < 4294967294U)) {
#line 1265
        memcpy((void *)dest->elems, (void const   *)(dest->elems + sbase), delta * sizeof(Idx ));
#line 1267
        break;
      }
    }
  }
#line 1272
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1279 "regex_internal.c"
static _Bool re_node_set_insert(re_node_set *set , Idx elem ) 
{ Idx idx ;
  reg_errcode_t __cil_tmp ;
  Idx *new_elems ;
  void *__cil_tmp___0 ;

  {
#line 1285
  if (set->alloc == 0U) {
#line 1286
    __cil_tmp = re_node_set_init_1(set, elem);
#line 1286
    return ((_Bool )((int )__cil_tmp == 0));
  }
#line 1288
  if (set->nelem == 0U) {
#line 1291
    *(set->elems + 0) = elem;
#line 1292
    (set->nelem) ++;
#line 1293
    return ((_Bool)1);
  }
#line 1297
  if (set->alloc == set->nelem) {
#line 1300
    set->alloc *= 2U;
#line 1301
    __cil_tmp___0 = rpl_realloc((void *)set->elems, set->alloc * sizeof(Idx ));
#line 1301
    new_elems = (Idx *)__cil_tmp___0;
#line 1302
    if ((unsigned int )new_elems == (unsigned int )((void *)0)) {
#line 1303
      return ((_Bool)0);
    }
#line 1304
    set->elems = new_elems;
  }
#line 1309
  if (elem < *(set->elems + 0)) {
#line 1311
    idx = 0U;
#line 1312
    idx = set->nelem;
#line 1312
    while (idx > 0U) {
#line 1313
      *(set->elems + idx) = *(set->elems + (idx - 1U));
#line 1312
      idx --;
    }
  } else {
#line 1317
    idx = set->nelem;
#line 1317
    while (*(set->elems + (idx - 1U)) > elem) {
#line 1318
      *(set->elems + idx) = *(set->elems + (idx - 1U));
#line 1317
      idx --;
    }
  }
#line 1322
  *(set->elems + idx) = elem;
#line 1323
  (set->nelem) ++;
#line 1324
  return ((_Bool)1);
}
}
#line 1331 "regex_internal.c"
static _Bool re_node_set_insert_last(re_node_set *set , Idx elem ) 
{ Idx *new_elems ;
  void *__cil_tmp ;
  Idx __cil_tmp___0 ;

  {
#line 1336
  if (set->alloc == set->nelem) {
#line 1339
    set->alloc = (set->alloc + 1U) * 2U;
#line 1340
    __cil_tmp = rpl_realloc((void *)set->elems, set->alloc * sizeof(Idx ));
#line 1340
    new_elems = (Idx *)__cil_tmp;
#line 1341
    if ((unsigned int )new_elems == (unsigned int )((void *)0)) {
#line 1342
      return ((_Bool)0);
    }
#line 1343
    set->elems = new_elems;
  }
#line 1347
  __cil_tmp___0 = set->nelem;
#line 1347
  (set->nelem) ++;
#line 1347
  *(set->elems + __cil_tmp___0) = elem;
#line 1348
  return ((_Bool)1);
}
}
#line 1354 "regex_internal.c"
static _Bool re_node_set_compare(re_node_set const   *set1 , re_node_set const   *set2 ) 
{ Idx i ;

  {
#line 1359
  if (((unsigned int )set1 == (unsigned int )((void *)0) || (unsigned int )set2 == (unsigned int )((void *)0)) || set1->nelem != set2->nelem) {
#line 1360
    return ((_Bool)0);
  }
#line 1361
  i = (unsigned int )set1->nelem;
#line 1361
  while (1) {
#line 1361
    i --;
#line 1361
    if (! (i < 4294967294U)) {
#line 1361
      break;
    }
#line 1362
    if (*(set1->elems + i) != *(set2->elems + i)) {
#line 1363
      return ((_Bool)0);
    }
  }
#line 1364
  return ((_Bool)1);
}
}
#line 1369 "regex_internal.c"
static Idx re_node_set_contains(re_node_set const   *set , Idx elem ) 
{ __re_size_t idx ;
  __re_size_t right ;
  __re_size_t mid ;

  {
#line 1374
  if (! ((unsigned int )(set->nelem - 1U) < 4294967293U)) {
#line 1375
    return (0U);
  }
#line 1378
  idx = 0U;
#line 1379
  right = (unsigned int )(set->nelem - 1U);
#line 1380
  while (idx < right) {
#line 1382
    mid = (idx + right) / 2U;
#line 1383
    if (*(set->elems + mid) < elem) {
#line 1384
      idx = mid + 1U;
    } else {
#line 1386
      right = mid;
    }
  }
#line 1388
  return (*(set->elems + idx) == elem ? idx + 1U : 0U);
}
}
#line 1391 "regex_internal.c"
static void re_node_set_remove_at(re_node_set *set , Idx idx ) 
{ 

  {
#line 1395
  if (idx < 0U || idx >= set->nelem) {
#line 1396
    return;
  }
#line 1397
  (set->nelem) --;
#line 1398
  while (idx < set->nelem) {
#line 1399
    *(set->elems + idx) = *(set->elems + (idx + 1U));
#line 1398
    idx ++;
  }
#line 1400
  return;
}
}
#line 1406 "regex_internal.c"
static Idx re_dfa_add_node(re_dfa_t *dfa , re_token_t token ) 
{ size_t new_nodes_alloc ;
  Idx *new_nexts ;
  Idx *new_indices ;
  re_node_set *new_edests ;
  re_node_set *new_eclosures ;
  re_token_t *new_nodes ;
  size_t max_object_size ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  int type ;
  size_t __cil_tmp___4 ;

  {
#line 1410
  if (dfa->nodes_len >= dfa->nodes_alloc) {
#line 1412
    new_nodes_alloc = dfa->nodes_alloc * 2U;
#line 1416
    max_object_size = sizeof(re_token_t ) < (sizeof(re_node_set ) < sizeof(Idx ) ? sizeof(Idx ) : sizeof(re_node_set )) ? (sizeof(re_node_set ) < sizeof(Idx ) ? sizeof(Idx ) : sizeof(re_node_set )) : sizeof(re_token_t );
#line 1422
    if (((((1U << 31) - 1U) * 2U + 1U) / 2U) / max_object_size < dfa->nodes_alloc) {
#line 1423
      return (4294967295U);
    }
#line 1425
    __cil_tmp = rpl_realloc((void *)dfa->nodes, new_nodes_alloc * sizeof(re_token_t ));
#line 1425
    new_nodes = (re_token_t *)__cil_tmp;
#line 1426
    if ((unsigned int )new_nodes == (unsigned int )((void *)0)) {
#line 1427
      return (4294967295U);
    }
#line 1428
    dfa->nodes = new_nodes;
#line 1429
    __cil_tmp___0 = rpl_realloc((void *)dfa->nexts, new_nodes_alloc * sizeof(Idx ));
#line 1429
    new_nexts = (Idx *)__cil_tmp___0;
#line 1430
    __cil_tmp___1 = rpl_realloc((void *)dfa->org_indices, new_nodes_alloc * sizeof(Idx ));
#line 1430
    new_indices = (Idx *)__cil_tmp___1;
#line 1431
    __cil_tmp___2 = rpl_realloc((void *)dfa->edests, new_nodes_alloc * sizeof(re_node_set ));
#line 1431
    new_edests = (re_node_set *)__cil_tmp___2;
#line 1432
    __cil_tmp___3 = rpl_realloc((void *)dfa->eclosures, new_nodes_alloc * sizeof(re_node_set ));
#line 1432
    new_eclosures = (re_node_set *)__cil_tmp___3;
#line 1433
    if ((((unsigned int )new_nexts == (unsigned int )((void *)0) || (unsigned int )new_indices == (unsigned int )((void *)0)) || (unsigned int )new_edests == (unsigned int )((void *)0)) || (unsigned int )new_eclosures == (unsigned int )((void *)0)) {
#line 1435
      return (4294967295U);
    }
#line 1436
    dfa->nexts = new_nexts;
#line 1437
    dfa->org_indices = new_indices;
#line 1438
    dfa->edests = new_edests;
#line 1439
    dfa->eclosures = new_eclosures;
#line 1440
    dfa->nodes_alloc = new_nodes_alloc;
  }
#line 1442
  *(dfa->nodes + dfa->nodes_len) = token;
#line 1443
  (dfa->nodes + dfa->nodes_len)->constraint = 0U;
#line 1446
  type = (int )token.type;
#line 1447
  (dfa->nodes + dfa->nodes_len)->accept_mb = (unsigned int )((type == 5 && dfa->mb_cur_max > 1) || type == 6);
#line 1451
  *(dfa->nexts + dfa->nodes_len) = 4294967295U;
#line 1452
  memset((void *)(dfa->edests + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1453
  memset((void *)(dfa->eclosures + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1454
  __cil_tmp___4 = dfa->nodes_len;
#line 1454
  (dfa->nodes_len) ++;
#line 1454
  return (__cil_tmp___4);
}
}
#line 1457 "regex_internal.c"
__inline static re_hashval_t calc_state_hash(re_node_set const   *nodes , unsigned int context ) 
{ re_hashval_t hash ;
  Idx i ;

  {
#line 1461
  hash = (unsigned int )(nodes->nelem + (unsigned int const   )context);
#line 1463
  i = 0U;
#line 1463
  while (i < (unsigned int )nodes->nelem) {
#line 1464
    hash += *(nodes->elems + i);
#line 1463
    i ++;
  }
#line 1465
  return (hash);
}
}
#line 1477 "regex_internal.c"
static re_dfastate_t *re_acquire_state(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                       re_node_set const   *nodes ) 
{ re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  re_dfastate_t *state ;
  _Bool __cil_tmp ;

  {
#line 1490
  if (nodes->nelem == 0U) {
#line 1492
    *err = (enum __anonenum_reg_errcode_t_7 )0;
#line 1493
    return ((re_dfastate_t *)((void *)0));
  }
#line 1495
  hash = calc_state_hash(nodes, 0U);
#line 1496
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned int )dfa->state_hash_mask));
#line 1498
  i = 0U;
#line 1498
  while (i < spot->num) {
#line 1500
    state = *(spot->array + i);
#line 1501
    if (hash != state->hash) {
#line 1502
      goto __Cont;
    }
#line 1503
    __cil_tmp = re_node_set_compare((re_node_set const   *)(& state->nodes), nodes);
#line 1503
    if (__cil_tmp) {
#line 1504
      return (state);
    }
    __Cont: 
#line 1498
    i ++;
  }
#line 1508
  new_state = create_ci_newstate(dfa, nodes, hash);
#line 1509
  if ((unsigned int )new_state == (unsigned int )((void *)0)) {
#line 1510
    *err = (enum __anonenum_reg_errcode_t_7 )12;
  }
#line 1512
  return (new_state);
}
}
#line 1525 "regex_internal.c"
static re_dfastate_t *re_acquire_state_context(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                               re_node_set const   *nodes , unsigned int context ) 
{ re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  re_dfastate_t *state ;
  _Bool __cil_tmp ;

  {
#line 1538
  if (nodes->nelem == 0U) {
#line 1540
    *err = (enum __anonenum_reg_errcode_t_7 )0;
#line 1541
    return ((re_dfastate_t *)((void *)0));
  }
#line 1543
  hash = calc_state_hash(nodes, context);
#line 1544
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned int )dfa->state_hash_mask));
#line 1546
  i = 0U;
#line 1546
  while (i < spot->num) {
#line 1548
    state = *(spot->array + i);
#line 1549
    if (state->hash == hash && state->context == context) {
#line 1549
      __cil_tmp = re_node_set_compare((re_node_set const   *)state->entrance_nodes,
                                      nodes);
#line 1549
      if (__cil_tmp) {
#line 1552
        return (state);
      }
    }
#line 1546
    i ++;
  }
#line 1555
  new_state = create_cd_newstate(dfa, nodes, context, hash);
#line 1556
  if ((unsigned int )new_state == (unsigned int )((void *)0)) {
#line 1557
    *err = (enum __anonenum_reg_errcode_t_7 )12;
  }
#line 1559
  return (new_state);
}
}
#line 1566 "regex_internal.c"
static reg_errcode_t register_state(re_dfa_t const   *dfa , re_dfastate_t *newstate ,
                                    re_hashval_t hash ) 
{ struct re_state_table_entry *spot ;
  reg_errcode_t err ;
  Idx i ;
  Idx elem ;
  _Bool __cil_tmp ;
  Idx new_alloc ;
  re_dfastate_t **new_array ;
  void *__cil_tmp___0 ;
  Idx __cil_tmp___1 ;

  {
#line 1574
  newstate->hash = hash;
#line 1575
  err = re_node_set_alloc(& newstate->non_eps_nodes, newstate->nodes.nelem);
#line 1576
  if ((int )err != 0) {
#line 1577
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 1578
  i = 0U;
#line 1578
  while (i < newstate->nodes.nelem) {
#line 1580
    elem = *(newstate->nodes.elems + i);
#line 1581
    if (! ((unsigned int )(dfa->nodes + elem)->type & 8U)) {
#line 1582
      __cil_tmp = re_node_set_insert_last(& newstate->non_eps_nodes, elem);
#line 1582
      if (! __cil_tmp) {
#line 1583
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
    }
#line 1578
    i ++;
  }
#line 1586
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned int )dfa->state_hash_mask));
#line 1587
  if (spot->alloc <= spot->num) {
#line 1589
    new_alloc = 2U * spot->num + 2U;
#line 1590
    __cil_tmp___0 = rpl_realloc((void *)spot->array, new_alloc * sizeof(re_dfastate_t *));
#line 1590
    new_array = (re_dfastate_t **)__cil_tmp___0;
#line 1592
    if ((unsigned int )new_array == (unsigned int )((void *)0)) {
#line 1593
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 1594
    spot->array = new_array;
#line 1595
    spot->alloc = new_alloc;
  }
#line 1597
  __cil_tmp___1 = spot->num;
#line 1597
  (spot->num) ++;
#line 1597
  *(spot->array + __cil_tmp___1) = newstate;
#line 1598
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1601 "regex_internal.c"
static void free_state(re_dfastate_t *state ) 
{ 

  {
#line 1604
  free((void *)state->non_eps_nodes.elems);
#line 1605
  free((void *)state->inveclosure.elems);
#line 1606
  if ((unsigned int )state->entrance_nodes != (unsigned int )(& state->nodes)) {
#line 1608
    free((void *)(state->entrance_nodes)->elems);
#line 1609
    free((void *)state->entrance_nodes);
  }
#line 1611
  free((void *)state->nodes.elems);
#line 1612
  free((void *)state->word_trtable);
#line 1613
  free((void *)state->trtable);
#line 1614
  free((void *)state);
#line 1615
  return;
}
}
#line 1620 "regex_internal.c"
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         re_hashval_t hash ) 
{ Idx i ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *__cil_tmp ;
  re_token_t *node ;
  re_token_type_t type ;

  {
#line 1629
  __cil_tmp = rpl_calloc(sizeof(re_dfastate_t ), 1U);
#line 1629
  newstate = (re_dfastate_t *)__cil_tmp;
#line 1630
  if ((unsigned int )newstate == (unsigned int )((void *)0)) {
#line 1631
    return ((re_dfastate_t *)((void *)0));
  }
#line 1632
  err = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1633
  if ((int )err != 0) {
#line 1635
    free((void *)newstate);
#line 1636
    return ((re_dfastate_t *)((void *)0));
  }
#line 1639
  newstate->entrance_nodes = & newstate->nodes;
#line 1640
  i = 0U;
#line 1640
  while (i < (unsigned int )nodes->nelem) {
#line 1642
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1643
    type = node->type;
#line 1644
    if ((unsigned int )type == 1U && ! node->constraint) {
#line 1645
      goto __Cont;
    }
#line 1647
    newstate->accept_mb |= node->accept_mb;
#line 1651
    if ((unsigned int )type == 2U) {
#line 1652
      newstate->halt = 1U;
    } else
#line 1653
    if ((unsigned int )type == 4U) {
#line 1654
      newstate->has_backref = 1U;
    } else
#line 1655
    if ((unsigned int )type == 12U || node->constraint) {
#line 1656
      newstate->has_constraint = 1U;
    }
    __Cont: 
#line 1640
    i ++;
  }
#line 1658
  err = register_state(dfa, newstate, hash);
#line 1659
  if ((int )err != 0) {
#line 1661
    free_state(newstate);
#line 1662
    newstate = (re_dfastate_t *)((void *)0);
  }
#line 1664
  return (newstate);
}
}
#line 1670 "regex_internal.c"
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int context , re_hashval_t hash ) 
{ Idx i ;
  Idx nctx_nodes ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *__cil_tmp ;
  unsigned int constraint ;
  re_token_t *node ;
  re_token_type_t type ;
  void *__cil_tmp___0 ;

  {
#line 1675
  nctx_nodes = 0U;
#line 1679
  __cil_tmp = rpl_calloc(sizeof(re_dfastate_t ), 1U);
#line 1679
  newstate = (re_dfastate_t *)__cil_tmp;
#line 1680
  if ((unsigned int )newstate == (unsigned int )((void *)0)) {
#line 1681
    return ((re_dfastate_t *)((void *)0));
  }
#line 1682
  err = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1683
  if ((int )err != 0) {
#line 1685
    free((void *)newstate);
#line 1686
    return ((re_dfastate_t *)((void *)0));
  }
#line 1689
  newstate->context = context;
#line 1690
  newstate->entrance_nodes = & newstate->nodes;
#line 1692
  i = 0U;
#line 1692
  while (i < (unsigned int )nodes->nelem) {
#line 1694
    constraint = 0U;
#line 1695
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1696
    type = node->type;
#line 1697
    if (node->constraint) {
#line 1698
      constraint = node->constraint;
    }
#line 1700
    if ((unsigned int )type == 1U && ! constraint) {
#line 1701
      goto __Cont;
    }
#line 1703
    newstate->accept_mb |= node->accept_mb;
#line 1707
    if ((unsigned int )type == 2U) {
#line 1708
      newstate->halt = 1U;
    } else
#line 1709
    if ((unsigned int )type == 4U) {
#line 1710
      newstate->has_backref = 1U;
    } else
#line 1711
    if ((unsigned int )type == 12U) {
#line 1712
      constraint = (unsigned int )node->opr.ctx_type;
    }
#line 1714
    if (constraint) {
#line 1716
      if ((unsigned int )newstate->entrance_nodes == (unsigned int )(& newstate->nodes)) {
#line 1718
        __cil_tmp___0 = rpl_malloc(sizeof(re_node_set ));
#line 1718
        newstate->entrance_nodes = (re_node_set *)__cil_tmp___0;
#line 1719
        if ((unsigned int )newstate->entrance_nodes == (unsigned int )((void *)0)) {
#line 1721
          free_state(newstate);
#line 1722
          return ((re_dfastate_t *)((void *)0));
        }
#line 1724
        re_node_set_init_copy(newstate->entrance_nodes, nodes);
#line 1725
        nctx_nodes = 0U;
#line 1726
        newstate->has_constraint = 1U;
      }
#line 1729
      if ((((constraint & 1U && ! (context & 1U)) || (constraint & 2U && context & 1U)) || (constraint & 16U && ! (context & (unsigned int )(1 << 1)))) || (constraint & 64U && ! (context & (unsigned int )((1 << 1) << 1)))) {
#line 1731
        re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1732
        nctx_nodes ++;
      }
    }
    __Cont: 
#line 1692
    i ++;
  }
#line 1736
  err = register_state(dfa, newstate, hash);
#line 1737
  if ((int )err != 0) {
#line 1739
    free_state(newstate);
#line 1740
    newstate = (re_dfastate_t *)((void *)0);
  }
#line 1742
  return (newstate);
}
}
#line 22 "regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) ;
#line 24
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) ;
#line 27
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) ;
#line 29
static void free_charset(re_charset_t *cset ) ;
#line 31
static void free_workarea_compile(regex_t *preg ) ;
#line 32
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) ;
#line 34
static void optimize_utf8(re_dfa_t *dfa ) ;
#line 36
static reg_errcode_t analyze(regex_t *preg ) ;
#line 37
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) ;
#line 40
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) ;
#line 43
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) ;
#line 44
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) ;
#line 45
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) ;
#line 47
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) ;
#line 48
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) ;
#line 49
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) ;
#line 50
static Idx duplicate_node(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) ;
#line 51
static Idx search_duplicated_node(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) ;
#line 53
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) ;
#line 54
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , Idx node ,
                                        _Bool root ) ;
#line 56
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) ;
#line 57
static Idx fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) ;
#line 59
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
#line 61
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) ;
#line 63
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 66
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 69
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 72
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 75
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 78
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 81
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax , _Bool accept_hyphen ) ;
#line 87
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) ;
#line 91
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                       Idx *equiv_class_alloc , unsigned char const   *name ) ;
#line 95
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *char_class_alloc ,
                                     unsigned char const   *class_name , reg_syntax_t syntax ) ;
#line 109
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , _Bool non_match ,
                                      reg_errcode_t *err ) ;
#line 114
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) ;
#line 117
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) ;
#line 120
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) ;
#line 121
static void free_token(re_token_t *node ) ;
#line 122
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) ;
#line 123
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) ;
#line 130 "regcomp.c"
static char const   __re_error_msgid[369]  = 
#line 130
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'[',      (char const   )'^', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'(', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )'{',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'\\', 
        (char const   )'{',      (char const   )'\\',      (char const   )'}',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'M',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'h', 
        (char const   )'a',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )'\000',      (char const   )'I', 
        (char const   )'n',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'R',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'g',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )')',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\\',      (char const   )')', 
        (char const   )'\000'};
#line 184 "regcomp.c"
static size_t const   __re_error_msgid_idx[17]  = 
#line 184
  {      (unsigned int const   )0,      (unsigned int const   )sizeof("Success"),      (unsigned int const   )(sizeof("Success") + sizeof("No match")),      (unsigned int const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (unsigned int const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (unsigned int const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (unsigned int const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (unsigned int const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (unsigned int const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")),      (unsigned int const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")),      (unsigned int const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (unsigned int const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (unsigned int const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (unsigned int const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (unsigned int const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (unsigned int const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (unsigned int const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
#line 221 "regcomp.c"
char const   *rpl_re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ reg_errcode_t ret ;

  {
#line 231
  bufp->no_sub = (unsigned int )(! (! (rpl_re_syntax_options & (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))));
#line 234
  bufp->newline_anchor = 1U;
#line 236
  ret = re_compile_internal(bufp, pattern, length, rpl_re_syntax_options);
#line 238
  if (! ret) {
#line 239
    return ((char const   *)((void *)0));
  }
#line 240
  return (__re_error_msgid + __re_error_msgid_idx[(int )ret]);
}
}
#line 261 "regcomp.c"
reg_syntax_t rpl_re_set_syntax(reg_syntax_t syntax ) 
{ reg_syntax_t ret ;

  {
#line 265
  ret = rpl_re_syntax_options;
#line 267
  rpl_re_syntax_options = syntax;
#line 268
  return (ret);
}
}
#line 274 "regcomp.c"
int rpl_re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ re_dfa_t *dfa ;
  char *fastmap ;

  {
#line 278
  dfa = (re_dfa_t *)bufp->buffer;
#line 279
  fastmap = bufp->fastmap;
#line 281
  memset((void *)fastmap, '\000', sizeof(char ) * 256U);
#line 282
  re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state, fastmap);
#line 283
  if ((unsigned int )dfa->init_state != (unsigned int )dfa->init_state_word) {
#line 284
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_word, fastmap);
  }
#line 285
  if ((unsigned int )dfa->init_state != (unsigned int )dfa->init_state_nl) {
#line 286
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_nl, fastmap);
  }
#line 287
  if ((unsigned int )dfa->init_state != (unsigned int )dfa->init_state_begbuf) {
#line 288
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_begbuf,
                            fastmap);
  }
#line 289
  bufp->fastmap_accurate = 1U;
#line 290
  return (0);
}
}
#line 296 "regcomp.c"
__inline static void re_set_fastmap(char *fastmap , _Bool icase , int ch ) 
{ int __x ;

  {
#line 300
  *(fastmap + ch) = (char)1;
#line 301
  if (icase) {
#line 302
    __x = ch;
#line 302
    *(fastmap + (((int const   )*((__ctype_ptr__ + sizeof(*("" + __x))) + __x) & 3) == 1 ? (__x - 65) + 97 : __x)) = (char)1;
  }
#line 303
  return;
}
}
#line 308 "regcomp.c"
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) 
{ re_dfa_t *dfa ;
  Idx node_cnt ;
  _Bool icase ;
  Idx node ;
  re_token_type_t type ;
  unsigned char buf___0[1] ;
  unsigned char *p ;
  wchar_t wc ;
  mbstate_t state ;
  unsigned char *__cil_tmp ;
  unsigned char *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  wint_t __cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  int i ;
  int ch ;
  int j ;
  bitset_word_t w ;
  Idx i___0 ;
  re_charset_t *cset ;
  wint_t __cil_tmp___4 ;
  char buf___1[256] ;
  mbstate_t state___0 ;
  size_t __cil_tmp___5 ;
  wint_t __cil_tmp___6 ;
  size_t __cil_tmp___7 ;

  {
#line 312
  dfa = (re_dfa_t *)bufp->buffer;
#line 314
  icase = (_Bool )(dfa->mb_cur_max == 1 && bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 315
  node_cnt = 0U;
#line 315
  while (node_cnt < (unsigned int )init_state->nodes.nelem) {
#line 317
    node = *(init_state->nodes.elems + node_cnt);
#line 318
    type = (dfa->nodes + node)->type;
#line 320
    if ((unsigned int )type == 1U) {
#line 322
      re_set_fastmap(fastmap, icase, (int )(dfa->nodes + node)->opr.c);
#line 324
      if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && dfa->mb_cur_max > 1) {
#line 331
        p = buf___0;
#line 332
        __cil_tmp = p;
#line 332
        p ++;
#line 332
        *__cil_tmp = (dfa->nodes + node)->opr.c;
#line 333
        while (1) {
#line 333
          node ++;
#line 333
          if (! ((node < dfa->nodes_len && (unsigned int )(dfa->nodes + node)->type == 1U) && (dfa->nodes + node)->mb_partial)) {
#line 333
            break;
          }
#line 336
          __cil_tmp___0 = p;
#line 336
          p ++;
#line 336
          *__cil_tmp___0 = (dfa->nodes + node)->opr.c;
        }
#line 337
        memset((void *)(& state), '\000', sizeof(state));
#line 338
        __cil_tmp___1 = mbrtowc(& wc, (char const   *)(buf___0), (unsigned int )(p - buf___0),
                                & state);
#line 338
        if (__cil_tmp___1 == (unsigned int )(p - buf___0)) {
#line 338
          __cil_tmp___2 = towlower((int )wc);
#line 338
          __cil_tmp___3 = wcrtomb((char *)(buf___0), (short )__cil_tmp___2, & state);
#line 338
          if (__cil_tmp___3 != 4294967295U) {
#line 342
            re_set_fastmap(fastmap, (_Bool)0, (int )buf___0[0]);
          }
        }
      }
    } else
#line 346
    if ((unsigned int )type == 3U) {
#line 349
      i = 0;
#line 349
      ch = 0;
#line 349
      while (i < 8) {
#line 352
        w = *((dfa->nodes + node)->opr.sbcset + i);
#line 353
        j = 0;
#line 353
        while (j < 32) {
#line 354
          if (w & (1UL << j)) {
#line 355
            re_set_fastmap(fastmap, icase, ch);
          }
#line 353
          j ++;
#line 353
          ch ++;
        }
#line 349
        i ++;
      }
    } else
#line 359
    if ((unsigned int )type == 6U) {
#line 362
      cset = (dfa->nodes + node)->opr.mbcset;
#line 363
      if ((((cset->non_match || cset->ncoll_syms) || cset->nequiv_classes) || cset->nranges) || cset->nchar_classes) {
#line 382
        if (dfa->mb_cur_max > 1) {
#line 383
          i___0 = 0U;
#line 383
          while (i___0 < 256U) {
#line 384
            __cil_tmp___4 = btowc((int )i___0);
#line 384
            if (__cil_tmp___4 == -1) {
#line 385
              re_set_fastmap(fastmap, icase, (int )i___0);
            }
#line 383
            i___0 ++;
          }
        }
      }
#line 388
      i___0 = 0U;
#line 388
      while (i___0 < cset->nmbchars) {
#line 392
        memset((void *)(& state___0), '\000', sizeof(state___0));
#line 393
        __cil_tmp___5 = wcrtomb(buf___1, *(cset->mbchars + i___0), & state___0);
#line 393
        if (__cil_tmp___5 != 4294967295U) {
#line 394
          re_set_fastmap(fastmap, icase, (int )*((unsigned char *)(buf___1)));
        }
#line 395
        if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && dfa->mb_cur_max > 1) {
#line 397
          __cil_tmp___6 = towlower((int )*(cset->mbchars + i___0));
#line 397
          __cil_tmp___7 = wcrtomb(buf___1, (short )__cil_tmp___6, & state___0);
#line 397
          if (__cil_tmp___7 != 4294967295U) {
#line 399
            re_set_fastmap(fastmap, (_Bool)0, (int )*((unsigned char *)(buf___1)));
          }
        }
#line 388
        i___0 ++;
      }
    } else
#line 404
    if (((unsigned int )type == 5U || (unsigned int )type == 7U) || (unsigned int )type == 2U) {
#line 410
      memset((void *)fastmap, '\001', sizeof(char ) * 256U);
#line 411
      if ((unsigned int )type == 2U) {
#line 412
        bufp->can_be_null = 1U;
      }
#line 413
      return;
    }
#line 315
    node_cnt ++;
  }
#line 416
  return;
}
}
#line 454 "regcomp.c"
int rpl_regcomp(regex_t *preg , char const   *pattern , int cflags ) 
{ reg_errcode_t ret ;
  reg_syntax_t syntax ;
  void *__cil_tmp ;
  size_t __cil_tmp___0 ;

  {
#line 461
  syntax = cflags & 1 ? ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) : (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
#line 464
  preg->buffer = (unsigned char *)((void *)0);
#line 465
  preg->allocated = 0U;
#line 466
  preg->used = 0U;
#line 469
  __cil_tmp = rpl_malloc(256U * sizeof(char ));
#line 469
  preg->fastmap = (char *)__cil_tmp;
#line 470
  if ((unsigned int )preg->fastmap == (unsigned int )((void *)0)) {
#line 471
    return (12);
  }
#line 473
  syntax |= cflags & (1 << 1) ? (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1 : 0UL;
#line 476
  if (cflags & (1 << 2)) {
#line 478
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 479
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 481
    preg->newline_anchor = 1U;
  } else {
#line 484
    preg->newline_anchor = 0U;
  }
#line 485
  preg->no_sub = (unsigned int )(! (! (cflags & (1 << 3))));
#line 486
  preg->translate = (unsigned char *)((void *)0);
#line 488
  __cil_tmp___0 = strlen(pattern);
#line 488
  ret = re_compile_internal(preg, pattern, __cil_tmp___0, syntax);
#line 492
  if ((int )ret == 16) {
#line 493
    ret = (enum __anonenum_reg_errcode_t_7 )8;
  }
#line 496
  if ((int )ret == 0) {
#line 499
    rpl_re_compile_fastmap(preg);
  } else {
#line 503
    free((void *)preg->fastmap);
#line 504
    preg->fastmap = (char *)((void *)0);
  }
#line 507
  return ((int )ret);
}
}
#line 524 "regcomp.c"
size_t rpl_regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) 
{ char const   *msg ;
  size_t msg_size ;
  size_t __cil_tmp ;
  size_t cpy_size ;

  {
#line 532
  if (errcode < 0 || errcode >= (int )(sizeof(__re_error_msgid_idx) / sizeof(__re_error_msgid_idx[0]))) {
#line 539
    abort();
  }
#line 541
  msg = __re_error_msgid + __re_error_msgid_idx[errcode];
#line 543
  __cil_tmp = strlen(msg);
#line 543
  msg_size = __cil_tmp + 1U;
#line 545
  if (errbuf_size != 0U) {
#line 547
    cpy_size = msg_size;
#line 548
    if (msg_size > errbuf_size) {
#line 550
      cpy_size = errbuf_size - 1U;
#line 551
      *(errbuf + cpy_size) = (char )'\000';
    }
#line 553
    memcpy((void *)errbuf, (void const   *)msg, cpy_size);
  }
#line 556
  return (msg_size);
}
}
#line 568 "regcomp.c"
static bitset_word_t utf8_sb_map[8]  = 
#line 568
  {      4294967295UL,      4294967295UL,      4294967295UL,      4294967295UL, 
        0UL,      0UL,      0UL,      0UL};
#line 588 "regcomp.c"
static void free_dfa_content(re_dfa_t *dfa ) 
{ Idx i ;
  Idx j ;
  struct re_state_table_entry *entry ;
  re_dfastate_t *state ;

  {
#line 593
  if (dfa->nodes) {
#line 594
    i = 0U;
#line 594
    while (i < dfa->nodes_len) {
#line 595
      free_token(dfa->nodes + i);
#line 594
      i ++;
    }
  }
#line 596
  free((void *)dfa->nexts);
#line 597
  i = 0U;
#line 597
  while (i < dfa->nodes_len) {
#line 599
    if ((unsigned int )dfa->eclosures != (unsigned int )((void *)0)) {
#line 600
      free((void *)(dfa->eclosures + i)->elems);
    }
#line 601
    if ((unsigned int )dfa->inveclosures != (unsigned int )((void *)0)) {
#line 602
      free((void *)(dfa->inveclosures + i)->elems);
    }
#line 603
    if ((unsigned int )dfa->edests != (unsigned int )((void *)0)) {
#line 604
      free((void *)(dfa->edests + i)->elems);
    }
#line 597
    i ++;
  }
#line 606
  free((void *)dfa->edests);
#line 607
  free((void *)dfa->eclosures);
#line 608
  free((void *)dfa->inveclosures);
#line 609
  free((void *)dfa->nodes);
#line 611
  if (dfa->state_table) {
#line 612
    i = 0U;
#line 612
    while (i <= dfa->state_hash_mask) {
#line 614
      entry = dfa->state_table + i;
#line 615
      j = 0U;
#line 615
      while (j < entry->num) {
#line 617
        state = *(entry->array + j);
#line 618
        free_state(state);
#line 615
        j ++;
      }
#line 620
      free((void *)entry->array);
#line 612
      i ++;
    }
  }
#line 622
  free((void *)dfa->state_table);
#line 624
  if ((unsigned int )dfa->sb_char != (unsigned int )(utf8_sb_map)) {
#line 625
    free((void *)dfa->sb_char);
  }
#line 627
  free((void *)dfa->subexp_map);
#line 632
  free((void *)dfa);
#line 633
  return;
}
}
#line 638 "regcomp.c"
void rpl_regfree(regex_t *preg ) 
{ re_dfa_t *dfa ;

  {
#line 642
  dfa = (re_dfa_t *)preg->buffer;
#line 643
  if ((unsigned int )dfa != (unsigned int )((void *)0)) {
#line 644
    free_dfa_content(dfa);
  }
#line 645
  preg->buffer = (unsigned char *)((void *)0);
#line 646
  preg->allocated = 0U;
#line 648
  free((void *)preg->fastmap);
#line 649
  preg->fastmap = (char *)((void *)0);
#line 651
  free((void *)preg->translate);
#line 652
  preg->translate = (unsigned char *)((void *)0);
#line 653
  return;
}
}
#line 731 "regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) 
{ reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_string_t regexp ;
  unsigned int __cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 735
  err = (enum __anonenum_reg_errcode_t_7 )0;
#line 740
  preg->fastmap_accurate = 0U;
#line 741
  preg->syntax = syntax;
#line 742
  __cil_tmp = 0U;
#line 742
  preg->not_eol = __cil_tmp;
#line 742
  preg->not_bol = __cil_tmp;
#line 743
  preg->used = 0U;
#line 744
  preg->re_nsub = 0U;
#line 745
  preg->can_be_null = 0U;
#line 746
  preg->regs_allocated = 0U;
#line 749
  dfa = (re_dfa_t *)preg->buffer;
#line 750
  if (preg->allocated < sizeof(re_dfa_t )) {
#line 756
    __cil_tmp___0 = rpl_realloc((void *)preg->buffer, sizeof(re_dfa_t ));
#line 756
    dfa = (re_dfa_t *)__cil_tmp___0;
#line 757
    if ((unsigned int )dfa == (unsigned int )((void *)0)) {
#line 758
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 759
    preg->allocated = sizeof(re_dfa_t );
#line 760
    preg->buffer = (unsigned char *)dfa;
  }
#line 762
  preg->used = sizeof(re_dfa_t );
#line 764
  err = init_dfa(dfa, length);
#line 765
  if ((int )err != 0) {
#line 767
    free_dfa_content(dfa);
#line 768
    preg->buffer = (unsigned char *)((void *)0);
#line 769
    preg->allocated = 0U;
#line 770
    return (err);
  }
#line 778
  while (1) {
#line 778
    break;
  }
#line 780
  err = re_string_construct(& regexp, pattern, length, preg->translate, (_Bool )(syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
                            (re_dfa_t const   *)dfa);
#line 782
  if ((int )err != 0) {
    re_compile_internal_free_return: 
#line 785
    free_workarea_compile(preg);
#line 786
    re_string_destruct(& regexp);
#line 787
    free_dfa_content(dfa);
#line 788
    preg->buffer = (unsigned char *)((void *)0);
#line 789
    preg->allocated = 0U;
#line 790
    return (err);
  }
#line 794
  preg->re_nsub = 0U;
#line 795
  dfa->str_tree = parse(& regexp, preg, syntax, & err);
#line 796
  if ((unsigned int )dfa->str_tree == (unsigned int )((void *)0)) {
#line 797
    goto re_compile_internal_free_return;
  }
#line 800
  err = analyze(preg);
#line 801
  if ((int )err != 0) {
#line 802
    goto re_compile_internal_free_return;
  }
#line 806
  if ((dfa->is_utf8 && ! (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && (unsigned int )preg->translate == (unsigned int )((void *)0)) {
#line 807
    optimize_utf8(dfa);
  }
#line 811
  err = create_initial_state(dfa);
#line 814
  free_workarea_compile(preg);
#line 815
  re_string_destruct(& regexp);
#line 817
  if ((int )err != 0) {
#line 819
    free_dfa_content(dfa);
#line 820
    preg->buffer = (unsigned char *)((void *)0);
#line 821
    preg->allocated = 0U;
  }
#line 824
  return (err);
}
}
#line 830 "regcomp.c"
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) 
{ __re_size_t table_size ;
  size_t max_i18n_object_size ;
  size_t max_object_size ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int i ;
  int j ;
  int ch ;
  void *__cil_tmp___3 ;
  wint_t wch ;
  wint_t __cil_tmp___4 ;

  {
#line 835
  max_i18n_object_size = sizeof(wchar_t ) < sizeof(wctype_t ) ? sizeof(wctype_t ) : sizeof(wchar_t );
#line 839
  max_object_size = sizeof(struct re_state_table_entry ) < (sizeof(re_token_t ) < (sizeof(re_node_set ) < (sizeof(regmatch_t ) < max_i18n_object_size ? max_i18n_object_size : sizeof(regmatch_t )) ? (sizeof(regmatch_t ) < max_i18n_object_size ? max_i18n_object_size : sizeof(regmatch_t )) : sizeof(re_node_set )) ? (sizeof(re_node_set ) < (sizeof(regmatch_t ) < max_i18n_object_size ? max_i18n_object_size : sizeof(regmatch_t )) ? (sizeof(regmatch_t ) < max_i18n_object_size ? max_i18n_object_size : sizeof(regmatch_t )) : sizeof(re_node_set )) : sizeof(re_token_t )) ? (sizeof(re_token_t ) < (sizeof(re_node_set ) < (sizeof(regmatch_t ) < max_i18n_object_size ? max_i18n_object_size : sizeof(regmatch_t )) ? (sizeof(regmatch_t ) < max_i18n_object_size ? max_i18n_object_size : sizeof(regmatch_t )) : sizeof(re_node_set )) ? (sizeof(re_node_set ) < (sizeof(regmatch_t ) < max_i18n_object_size ? max_i18n_object_size : sizeof(regmatch_t )) ? (sizeof(regmatch_t ) < max_i18n_object_size ? max_i18n_object_size : sizeof(regmatch_t )) : sizeof(re_node_set )) : sizeof(re_token_t )) : sizeof(struct re_state_table_entry );
#line 846
  memset((void *)dfa, '\000', sizeof(re_dfa_t ));
#line 849
  dfa->str_tree_storage_idx = (int )((1024U - sizeof(void *)) / sizeof(bin_tree_t ));
#line 855
  if (((((1U << 31) - 1U) * 2U + 1U) / max_object_size) / 2U <= pat_len) {
#line 856
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 858
  dfa->nodes_alloc = pat_len + 1U;
#line 859
  __cil_tmp = rpl_malloc(dfa->nodes_alloc * sizeof(re_token_t ));
#line 859
  dfa->nodes = (re_token_t *)__cil_tmp;
#line 862
  table_size = 1U;
#line 862
  while (! (table_size > pat_len)) {
#line 862
    table_size <<= 1;
  }
#line 866
  __cil_tmp___0 = rpl_calloc(sizeof(struct re_state_table_entry ), table_size);
#line 866
  dfa->state_table = (struct re_state_table_entry *)__cil_tmp___0;
#line 867
  dfa->state_hash_mask = table_size - 1U;
#line 869
  dfa->mb_cur_max = __locale_mb_cur_max();
#line 877
  __cil_tmp___1 = locale_charset();
#line 877
  __cil_tmp___2 = strcmp(__cil_tmp___1, "UTF-8");
#line 877
  if (__cil_tmp___2 == 0) {
#line 878
    dfa->is_utf8 = 1U;
  }
#line 882
  dfa->map_notascii = 0U;
#line 886
  if (dfa->mb_cur_max > 1) {
#line 888
    if (dfa->is_utf8) {
#line 889
      dfa->sb_char = utf8_sb_map;
    } else {
#line 894
      __cil_tmp___3 = rpl_calloc(sizeof(bitset_t ), 1U);
#line 894
      dfa->sb_char = (bitset_word_t *)__cil_tmp___3;
#line 895
      if ((unsigned int )dfa->sb_char == (unsigned int )((void *)0)) {
#line 896
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 899
      i = 0;
#line 899
      ch = 0;
#line 899
      while (i < 8) {
#line 900
        j = 0;
#line 900
        while (j < 32) {
#line 902
          __cil_tmp___4 = btowc(ch);
#line 902
          wch = __cil_tmp___4;
#line 903
          if (wch != -1) {
#line 904
            *(dfa->sb_char + i) |= 1UL << j;
          }
#line 906
          if ((unsigned int )ch <= 127U && wch != ch) {
#line 907
            dfa->map_notascii = 1U;
          }
#line 900
          j ++;
#line 900
          ch ++;
        }
#line 899
        i ++;
      }
    }
  }
#line 914
  if ((unsigned int )dfa->nodes == (unsigned int )((void *)0) || (unsigned int )dfa->state_table == (unsigned int )((void *)0)) {
#line 915
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 916
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 923 "regcomp.c"
static void init_word_char(re_dfa_t *dfa ) 
{ int i ;
  int j ;
  int ch ;

  {
#line 928
  dfa->word_ops_used = 1U;
#line 929
  i = 0;
#line 929
  ch = 0;
#line 929
  while (i < 8) {
#line 930
    j = 0;
#line 930
    while (j < 32) {
#line 931
      if ((int const   )*((__ctype_ptr__ + sizeof(*("" + ch))) + ch) & 7 || ch == 95) {
#line 932
        dfa->word_char[i] |= 1UL << j;
      }
#line 930
      j ++;
#line 930
      ch ++;
    }
#line 929
    i ++;
  }
#line 933
  return;
}
}
#line 937 "regcomp.c"
static void free_workarea_compile(regex_t *preg ) 
{ re_dfa_t *dfa ;
  bin_tree_storage_t *storage ;
  bin_tree_storage_t *next ;

  {
#line 940
  dfa = (re_dfa_t *)preg->buffer;
#line 942
  storage = dfa->str_tree_storage;
#line 942
  while (storage) {
#line 944
    next = storage->next;
#line 945
    free((void *)storage);
#line 942
    storage = next;
  }
#line 947
  dfa->str_tree_storage = (bin_tree_storage_t *)((void *)0);
#line 948
  dfa->str_tree_storage_idx = (int )((1024U - sizeof(void *)) / sizeof(bin_tree_t ));
#line 949
  dfa->str_tree = (bin_tree_t *)((void *)0);
#line 950
  free((void *)dfa->org_indices);
#line 951
  dfa->org_indices = (Idx *)((void *)0);
#line 952
  return;
}
}
#line 956 "regcomp.c"
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) 
{ Idx first ;
  Idx i ;
  reg_errcode_t err ;
  re_node_set init_nodes ;
  Idx node_idx ;
  re_token_type_t type ;
  Idx clexp_idx ;
  re_token_t *clexp_node ;
  Idx dest_idx ;
  Idx __cil_tmp ;
  re_dfastate_t *__cil_tmp___0 ;
  re_dfastate_t *__cil_tmp___1 ;

  {
#line 965
  first = ((dfa->str_tree)->first)->node_idx;
#line 966
  dfa->init_node = first;
#line 967
  err = re_node_set_init_copy(& init_nodes, (re_node_set const   *)(dfa->eclosures + first));
#line 968
  if ((int )err != 0) {
#line 969
    return (err);
  }
#line 975
  if (dfa->nbackref > 0U) {
#line 976
    i = 0U;
#line 976
    while (i < init_nodes.nelem) {
#line 978
      node_idx = *(init_nodes.elems + i);
#line 979
      type = (dfa->nodes + node_idx)->type;
#line 982
      if ((unsigned int )type != 4U) {
#line 983
        goto __Cont;
      }
#line 984
      clexp_idx = 0U;
#line 984
      while (clexp_idx < init_nodes.nelem) {
#line 987
        clexp_node = dfa->nodes + *(init_nodes.elems + clexp_idx);
#line 988
        if ((unsigned int )clexp_node->type == 9U && clexp_node->opr.idx == (dfa->nodes + node_idx)->opr.idx) {
#line 990
          break;
        }
#line 984
        clexp_idx ++;
      }
#line 992
      if (clexp_idx == init_nodes.nelem) {
#line 993
        goto __Cont;
      }
#line 995
      if ((unsigned int )type == 4U) {
#line 997
        dest_idx = *((dfa->edests + node_idx)->elems + 0);
#line 998
        __cil_tmp = re_node_set_contains((re_node_set const   *)(& init_nodes), dest_idx);
#line 998
        if (! __cil_tmp) {
#line 1000
          re_node_set_merge(& init_nodes, (re_node_set const   *)(dfa->eclosures + dest_idx));
#line 1001
          i = 0U;
        }
      }
      __Cont: 
#line 976
      i ++;
    }
  }
#line 1007
  dfa->init_state = re_acquire_state_context(& err, (re_dfa_t const   *)dfa, (re_node_set const   *)(& init_nodes),
                                             0U);
#line 1009
  if ((unsigned int )dfa->init_state == (unsigned int )((void *)0)) {
#line 1010
    return (err);
  }
#line 1011
  if ((dfa->init_state)->has_constraint) {
#line 1013
    dfa->init_state_word = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                    (re_node_set const   *)(& init_nodes),
                                                    1U);
#line 1015
    dfa->init_state_nl = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                  (re_node_set const   *)(& init_nodes),
                                                  (unsigned int )(1 << 1));
#line 1017
    dfa->init_state_begbuf = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                      (re_node_set const   *)(& init_nodes),
                                                      (unsigned int )((1 << 1) | ((1 << 1) << 1)));
#line 1021
    if (((unsigned int )dfa->init_state_word == (unsigned int )((void *)0) || (unsigned int )dfa->init_state_nl == (unsigned int )((void *)0)) || (unsigned int )dfa->init_state_begbuf == (unsigned int )((void *)0)) {
#line 1023
      return (err);
    }
  } else {
#line 1026
    __cil_tmp___1 = dfa->init_state;
#line 1026
    dfa->init_state_begbuf = __cil_tmp___1;
#line 1026
    __cil_tmp___0 = __cil_tmp___1;
#line 1026
    dfa->init_state_nl = __cil_tmp___0;
#line 1026
    dfa->init_state_word = __cil_tmp___0;
  }
#line 1029
  free((void *)init_nodes.elems);
#line 1030
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1038 "regcomp.c"
static void optimize_utf8(re_dfa_t *dfa ) 
{ Idx node ;
  int i ;
  _Bool mb_chars ;
  _Bool has_period ;
  int rshift ;

  {
#line 1043
  mb_chars = (_Bool)0;
#line 1044
  has_period = (_Bool)0;
#line 1046
  node = 0U;
#line 1046
  while (node < dfa->nodes_len) {
#line 1047
    switch ((int )(dfa->nodes + node)->type) {
    case 1: 
#line 1050
    if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1051
      mb_chars = (_Bool)1;
    }
#line 1052
    break;
    case 12: 
#line 1054
    switch ((int )(dfa->nodes + node)->opr.ctx_type) {
    case 16: 
    case 32: 
    case 64: 
    case 128: 
#line 1060
    break;
    default: 
#line 1063
    return;
    }
#line 1065
    break;
    case 5: 
#line 1067
    has_period = (_Bool)1;
#line 1068
    break;
    case 4: 
    case 10: 
    case 2: 
    case 11: 
    case 8: 
    case 9: 
#line 1075
    break;
    case 6: 
#line 1077
    return;
    case 3: 
#line 1081
    rshift = 0;
#line 1084
    i = 4;
#line 1084
    while (i < 8) {
#line 1086
      if (*((dfa->nodes + node)->opr.sbcset + i) >> rshift != 0UL) {
#line 1087
        return;
      }
#line 1088
      rshift = 0;
#line 1084
      i ++;
    }
#line 1091
    break;
    default: 
#line 1093
    abort();
    }
#line 1046
    node ++;
  }
#line 1096
  if (mb_chars || has_period) {
#line 1097
    node = 0U;
#line 1097
    while (node < dfa->nodes_len) {
#line 1099
      if ((unsigned int )(dfa->nodes + node)->type == 1U && (int )(dfa->nodes + node)->opr.c >= 128) {
#line 1101
        (dfa->nodes + node)->mb_partial = 0U;
      } else
#line 1102
      if ((unsigned int )(dfa->nodes + node)->type == 5U) {
#line 1103
        (dfa->nodes + node)->type = (enum __anonenum_re_token_type_t_15 )7;
      }
#line 1097
      node ++;
    }
  }
#line 1107
  dfa->mb_cur_max = 1;
#line 1108
  dfa->is_utf8 = 0U;
#line 1109
  dfa->has_mb_node = (unsigned int )(dfa->nbackref > 0U || has_period);
#line 1110
  return;
}
}
#line 1116 "regcomp.c"
static reg_errcode_t analyze(regex_t *preg ) 
{ re_dfa_t *dfa ;
  reg_errcode_t ret ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  Idx i ;
  void *__cil_tmp___4 ;

  {
#line 1119
  dfa = (re_dfa_t *)preg->buffer;
#line 1123
  __cil_tmp = rpl_malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1123
  dfa->nexts = (Idx *)__cil_tmp;
#line 1124
  __cil_tmp___0 = rpl_malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1124
  dfa->org_indices = (Idx *)__cil_tmp___0;
#line 1125
  __cil_tmp___1 = rpl_malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1125
  dfa->edests = (re_node_set *)__cil_tmp___1;
#line 1126
  __cil_tmp___2 = rpl_malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1126
  dfa->eclosures = (re_node_set *)__cil_tmp___2;
#line 1127
  if ((((unsigned int )dfa->nexts == (unsigned int )((void *)0) || (unsigned int )dfa->org_indices == (unsigned int )((void *)0)) || (unsigned int )dfa->edests == (unsigned int )((void *)0)) || (unsigned int )dfa->eclosures == (unsigned int )((void *)0)) {
#line 1129
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 1131
  __cil_tmp___3 = rpl_malloc(preg->re_nsub * sizeof(Idx ));
#line 1131
  dfa->subexp_map = (Idx *)__cil_tmp___3;
#line 1132
  if ((unsigned int )dfa->subexp_map != (unsigned int )((void *)0)) {
#line 1135
    i = 0U;
#line 1135
    while (i < preg->re_nsub) {
#line 1136
      *(dfa->subexp_map + i) = i;
#line 1135
      i ++;
    }
#line 1137
    preorder(dfa->str_tree, & optimize_subexps, (void *)dfa);
#line 1138
    i = 0U;
#line 1138
    while (i < preg->re_nsub) {
#line 1139
      if (*(dfa->subexp_map + i) != i) {
#line 1140
        break;
      }
#line 1138
      i ++;
    }
#line 1141
    if (i == preg->re_nsub) {
#line 1143
      free((void *)dfa->subexp_map);
#line 1144
      dfa->subexp_map = (Idx *)((void *)0);
    }
  }
#line 1148
  ret = postorder(dfa->str_tree, & lower_subexps, (void *)preg);
#line 1149
  if ((int )ret != 0) {
#line 1150
    return (ret);
  }
#line 1151
  ret = postorder(dfa->str_tree, & calc_first, (void *)dfa);
#line 1152
  if ((int )ret != 0) {
#line 1153
    return (ret);
  }
#line 1154
  preorder(dfa->str_tree, & calc_next, (void *)dfa);
#line 1155
  ret = preorder(dfa->str_tree, & link_nfa_nodes, (void *)dfa);
#line 1156
  if ((int )ret != 0) {
#line 1157
    return (ret);
  }
#line 1158
  ret = calc_eclosure(dfa);
#line 1159
  if ((int )ret != 0) {
#line 1160
    return (ret);
  }
#line 1164
  if (((! preg->no_sub && preg->re_nsub > 0U) && dfa->has_plural_match) || dfa->nbackref) {
#line 1167
    __cil_tmp___4 = rpl_malloc(dfa->nodes_len * sizeof(re_node_set ));
#line 1167
    dfa->inveclosures = (re_node_set *)__cil_tmp___4;
#line 1168
    if ((unsigned int )dfa->inveclosures == (unsigned int )((void *)0)) {
#line 1169
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 1170
    ret = calc_inveclosure(dfa);
  }
#line 1173
  return (ret);
}
}
#line 1179 "regcomp.c"
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) 
{ bin_tree_t *node ;
  bin_tree_t *prev ;
  reg_errcode_t err ;
  reg_errcode_t __cil_tmp ;

  {
#line 1185
  node = root;
#line 1185
  while (1) {
#line 1189
    while (node->left || node->right) {
#line 1190
      if (node->left) {
#line 1191
        node = node->left;
      } else {
#line 1193
        node = node->right;
      }
    }
#line 1195
    while (1) {
#line 1197
      __cil_tmp = (*fn)(extra, node);
#line 1197
      err = __cil_tmp;
#line 1198
      if ((int )err != 0) {
#line 1199
        return (err);
      }
#line 1200
      if ((unsigned int )node->parent == (unsigned int )((void *)0)) {
#line 1201
        return ((enum __anonenum_reg_errcode_t_7 )0);
      }
#line 1202
      prev = node;
#line 1203
      node = node->parent;
#line 1195
      if (! ((unsigned int )node->right == (unsigned int )prev || (unsigned int )node->right == (unsigned int )((void *)0))) {
#line 1195
        break;
      }
    }
#line 1207
    node = node->right;
  }
}
}
#line 1211 "regcomp.c"
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) 
{ bin_tree_t *node ;
  reg_errcode_t err ;
  reg_errcode_t __cil_tmp ;
  bin_tree_t *prev ;

  {
#line 1217
  node = root;
#line 1217
  while (1) {
#line 1219
    __cil_tmp = (*fn)(extra, node);
#line 1219
    err = __cil_tmp;
#line 1220
    if ((int )err != 0) {
#line 1221
      return (err);
    }
#line 1224
    if (node->left) {
#line 1225
      node = node->left;
    } else {
#line 1228
      prev = (bin_tree_t *)((void *)0);
#line 1229
      while ((unsigned int )node->right == (unsigned int )prev || (unsigned int )node->right == (unsigned int )((void *)0)) {
#line 1231
        prev = node;
#line 1232
        node = node->parent;
#line 1233
        if (! node) {
#line 1234
          return ((enum __anonenum_reg_errcode_t_7 )0);
        }
      }
#line 1236
      node = node->right;
    }
  }
}
}
#line 1244 "regcomp.c"
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) 
{ re_dfa_t *dfa ;
  int idx ;
  Idx other_idx ;

  {
#line 1247
  dfa = (re_dfa_t *)extra;
#line 1249
  if ((unsigned int )node->token.type == 4U && dfa->subexp_map) {
#line 1251
    idx = (int )node->token.opr.idx;
#line 1252
    node->token.opr.idx = *(dfa->subexp_map + idx);
#line 1253
    dfa->used_bkref_map |= (unsigned long )(1 << node->token.opr.idx);
  } else
#line 1256
  if (((unsigned int )node->token.type == 17U && node->left) && (unsigned int )(node->left)->token.type == 17U) {
#line 1259
    other_idx = (node->left)->token.opr.idx;
#line 1261
    node->left = (node->left)->left;
#line 1262
    if (node->left) {
#line 1263
      (node->left)->parent = node;
    }
#line 1265
    *(dfa->subexp_map + other_idx) = *(dfa->subexp_map + node->token.opr.idx);
#line 1266
    if (other_idx < 32U) {
#line 1267
      dfa->used_bkref_map &= ~ (1UL << other_idx);
    }
  }
#line 1270
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1275 "regcomp.c"
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) 
{ regex_t *preg ;
  reg_errcode_t err ;

  {
#line 1278
  preg = (regex_t *)extra;
#line 1279
  err = (enum __anonenum_reg_errcode_t_7 )0;
#line 1281
  if (node->left && (unsigned int )(node->left)->token.type == 17U) {
#line 1283
    node->left = lower_subexp(& err, preg, node->left);
#line 1284
    if (node->left) {
#line 1285
      (node->left)->parent = node;
    }
  }
#line 1287
  if (node->right && (unsigned int )(node->right)->token.type == 17U) {
#line 1289
    node->right = lower_subexp(& err, preg, node->right);
#line 1290
    if (node->right) {
#line 1291
      (node->right)->parent = node;
    }
  }
#line 1294
  return (err);
}
}
#line 1297 "regcomp.c"
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) 
{ re_dfa_t *dfa ;
  bin_tree_t *body ;
  bin_tree_t *op ;
  bin_tree_t *cls ;
  bin_tree_t *tree1 ;
  bin_tree_t *tree ;
  bin_tree_t *__cil_tmp ;
  Idx __cil_tmp___0 ;
  unsigned int __cil_tmp___1 ;

  {
#line 1300
  dfa = (re_dfa_t *)preg->buffer;
#line 1301
  body = node->left;
#line 1304
  if ((preg->no_sub && (unsigned int )node->left != (unsigned int )((void *)0)) && (node->token.opr.idx >= 32U || ! (dfa->used_bkref_map & (1UL << node->token.opr.idx)))) {
#line 1313
    return (node->left);
  }
#line 1317
  op = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (enum __anonenum_re_token_type_t_15 )8);
#line 1318
  cls = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (enum __anonenum_re_token_type_t_15 )9);
#line 1319
  if (body) {
#line 1319
    __cil_tmp = create_tree(dfa, body, cls, (enum __anonenum_re_token_type_t_15 )16);
#line 1319
    tree1 = __cil_tmp;
  } else {
#line 1319
    tree1 = cls;
  }
#line 1320
  tree = create_tree(dfa, op, tree1, (enum __anonenum_re_token_type_t_15 )16);
#line 1321
  if ((((unsigned int )tree == (unsigned int )((void *)0) || (unsigned int )tree1 == (unsigned int )((void *)0)) || (unsigned int )op == (unsigned int )((void *)0)) || (unsigned int )cls == (unsigned int )((void *)0)) {
#line 1323
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 1324
    return ((bin_tree_t *)((void *)0));
  }
#line 1327
  __cil_tmp___0 = node->token.opr.idx;
#line 1327
  cls->token.opr.idx = __cil_tmp___0;
#line 1327
  op->token.opr.idx = __cil_tmp___0;
#line 1328
  __cil_tmp___1 = node->token.opt_subexp;
#line 1328
  cls->token.opt_subexp = __cil_tmp___1;
#line 1328
  op->token.opt_subexp = __cil_tmp___1;
#line 1329
  return (tree);
}
}
#line 1334 "regcomp.c"
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) 
{ re_dfa_t *dfa ;

  {
#line 1337
  dfa = (re_dfa_t *)extra;
#line 1338
  if ((unsigned int )node->token.type == 16U) {
#line 1340
    node->first = (node->left)->first;
#line 1341
    node->node_idx = (node->left)->node_idx;
  } else {
#line 1345
    node->first = node;
#line 1346
    node->node_idx = re_dfa_add_node(dfa, node->token);
#line 1347
    if (node->node_idx == 4294967295U) {
#line 1348
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
  }
#line 1350
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1354 "regcomp.c"
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) 
{ 

  {
#line 1357
  switch ((int )node->token.type) {
  case 11: 
#line 1360
  (node->left)->next = node;
#line 1361
  break;
  case 16: 
#line 1363
  (node->left)->next = (node->right)->first;
#line 1364
  (node->right)->next = node->next;
#line 1365
  break;
  default: 
#line 1367
  if (node->left) {
#line 1368
    (node->left)->next = node->next;
  }
#line 1369
  if (node->right) {
#line 1370
    (node->right)->next = node->next;
  }
#line 1371
  break;
  }
#line 1373
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1377 "regcomp.c"
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) 
{ re_dfa_t *dfa ;
  Idx idx ;
  reg_errcode_t err ;
  Idx left ;
  Idx right ;

  {
#line 1380
  dfa = (re_dfa_t *)extra;
#line 1381
  idx = node->node_idx;
#line 1382
  err = (enum __anonenum_reg_errcode_t_7 )0;
#line 1384
  switch ((int )node->token.type) {
  case 16: 
#line 1387
  break;
  case 2: 
#line 1390
  if (((unsigned int )node->next == (unsigned int )((void *)0)) == 0) {
#line 1390
    __libc_failwith((char *)"Assertion failed: node->next == NULL at regcomp.c:1390");
  }
#line 1391
  break;
  case 11: 
  case 10: 
#line 1397
  dfa->has_plural_match = 1U;
#line 1398
  if ((unsigned int )node->left != (unsigned int )((void *)0)) {
#line 1399
    left = ((node->left)->first)->node_idx;
  } else {
#line 1401
    left = (node->next)->node_idx;
  }
#line 1402
  if ((unsigned int )node->right != (unsigned int )((void *)0)) {
#line 1403
    right = ((node->right)->first)->node_idx;
  } else {
#line 1405
    right = (node->next)->node_idx;
  }
#line 1406
  if ((left < 4294967294U) == 0) {
#line 1406
    __libc_failwith((char *)"Assertion failed: REG_VALID_INDEX (left) at regcomp.c:1406");
  }
#line 1407
  if ((right < 4294967294U) == 0) {
#line 1407
    __libc_failwith((char *)"Assertion failed: REG_VALID_INDEX (right) at regcomp.c:1407");
  }
#line 1408
  err = re_node_set_init_2(dfa->edests + idx, left, right);
#line 1410
  break;
  case 12: 
  case 8: 
  case 9: 
#line 1415
  err = re_node_set_init_1(dfa->edests + idx, (node->next)->node_idx);
#line 1416
  break;
  case 4: 
#line 1419
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1420
  if ((unsigned int )node->token.type == 4U) {
#line 1421
    re_node_set_init_1(dfa->edests + idx, *(dfa->nexts + idx));
  }
#line 1422
  break;
  default: 
#line 1425
  if (! ((unsigned int )node->token.type & 8U) == 0) {
#line 1425
    __libc_failwith((char *)"Assertion failed: !IS_EPSILON_NODE (node->token.type) at regcomp.c:1425");
  }
#line 1426
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1427
  break;
  }
#line 1430
  return (err);
}
}
#line 1437 "regcomp.c"
static reg_errcode_t duplicate_node_closure(re_dfa_t *dfa , Idx top_org_node , Idx top_clone_node ,
                                            Idx root_node , unsigned int init_constraint ) 
{ Idx org_node ;
  Idx clone_node ;
  _Bool ok ;
  unsigned int constraint ;
  Idx org_dest ;
  Idx clone_dest ;
  reg_errcode_t err ;

  {
#line 1444
  constraint = init_constraint;
#line 1445
  org_node = top_org_node;
#line 1445
  clone_node = top_clone_node;
#line 1445
  while (1) {
#line 1448
    if ((unsigned int )(dfa->nodes + org_node)->type == 4U) {
#line 1454
      org_dest = *(dfa->nexts + org_node);
#line 1455
      (dfa->edests + clone_node)->nelem = 0U;
#line 1456
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1457
      if (clone_dest == 4294967295U) {
#line 1458
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 1459
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1460
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1461
      if (! ok) {
#line 1462
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
    } else
#line 1464
    if ((dfa->edests + org_node)->nelem == 0U) {
#line 1469
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1470
      break;
    } else
#line 1472
    if ((dfa->edests + org_node)->nelem == 1U) {
#line 1476
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1477
      (dfa->edests + clone_node)->nelem = 0U;
#line 1478
      if ((unsigned int )(dfa->nodes + org_node)->type == 12U) {
#line 1481
        if (org_node == root_node && clone_node != org_node) {
#line 1486
          ok = re_node_set_insert(dfa->edests + clone_node, org_dest);
#line 1487
          if (! ok) {
#line 1488
            return ((enum __anonenum_reg_errcode_t_7 )12);
          }
#line 1489
          break;
        }
#line 1491
        constraint |= (unsigned int )(dfa->nodes + org_node)->opr.ctx_type;
      }
#line 1493
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1494
      if (clone_dest == 4294967295U) {
#line 1495
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 1496
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1497
      if (! ok) {
#line 1498
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
    } else {
#line 1504
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1505
      (dfa->edests + clone_node)->nelem = 0U;
#line 1507
      clone_dest = search_duplicated_node((re_dfa_t const   *)dfa, org_dest, constraint);
#line 1508
      if (clone_dest == 4294967295U) {
#line 1512
        clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1513
        if (clone_dest == 4294967295U) {
#line 1514
          return ((enum __anonenum_reg_errcode_t_7 )12);
        }
#line 1515
        ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1516
        if (! ok) {
#line 1517
          return ((enum __anonenum_reg_errcode_t_7 )12);
        }
#line 1518
        err = duplicate_node_closure(dfa, org_dest, clone_dest, root_node, constraint);
#line 1520
        if ((int )err != 0) {
#line 1521
          return (err);
        }
      } else {
#line 1527
        ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1528
        if (! ok) {
#line 1529
          return ((enum __anonenum_reg_errcode_t_7 )12);
        }
      }
#line 1532
      org_dest = *((dfa->edests + org_node)->elems + 1);
#line 1533
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1534
      if (clone_dest == 4294967295U) {
#line 1535
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 1536
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1537
      if (! ok) {
#line 1538
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
    }
#line 1540
    org_node = org_dest;
#line 1541
    clone_node = clone_dest;
  }
#line 1543
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1549 "regcomp.c"
static Idx search_duplicated_node(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) 
{ Idx idx ;

  {
#line 1554
  idx = (unsigned int )(dfa->nodes_len - 1U);
#line 1554
  while ((dfa->nodes + idx)->duplicated && idx > 0U) {
#line 1556
    if (org_node == *(dfa->org_indices + idx) && constraint == (dfa->nodes + idx)->constraint) {
#line 1558
      return (idx);
    }
#line 1554
    idx --;
  }
#line 1560
  return (4294967295U);
}
}
#line 1567 "regcomp.c"
static Idx duplicate_node(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) 
{ Idx dup_idx ;
  Idx __cil_tmp ;

  {
#line 1570
  __cil_tmp = re_dfa_add_node(dfa, *(dfa->nodes + org_idx));
#line 1570
  dup_idx = __cil_tmp;
#line 1571
  if (dup_idx != 4294967295U) {
#line 1573
    (dfa->nodes + dup_idx)->constraint = constraint;
#line 1574
    if ((unsigned int )(dfa->nodes + org_idx)->type == 12U) {
#line 1575
      (dfa->nodes + dup_idx)->constraint |= (unsigned int )(dfa->nodes + org_idx)->opr.ctx_type;
    }
#line 1576
    (dfa->nodes + dup_idx)->duplicated = 1U;
#line 1579
    *(dfa->org_indices + dup_idx) = org_idx;
  }
#line 1581
  return (dup_idx);
}
}
#line 1584 "regcomp.c"
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) 
{ Idx src ;
  Idx idx ;
  _Bool ok ;
  Idx *elems ;

  {
#line 1589
  idx = 0U;
#line 1589
  while (idx < dfa->nodes_len) {
#line 1590
    memset((void *)(dfa->inveclosures + idx), '\000', sizeof(re_node_set ));
#line 1589
    idx ++;
  }
#line 1592
  src = 0U;
#line 1592
  while (src < dfa->nodes_len) {
#line 1594
    elems = (dfa->eclosures + src)->elems;
#line 1595
    idx = 0U;
#line 1595
    while (idx < (dfa->eclosures + src)->nelem) {
#line 1597
      ok = re_node_set_insert_last(dfa->inveclosures + *(elems + idx), src);
#line 1598
      if (! ok) {
#line 1599
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 1595
      idx ++;
    }
#line 1592
    src ++;
  }
#line 1603
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1608 "regcomp.c"
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) 
{ Idx node_idx ;
  _Bool incomplete ;
  reg_errcode_t err ;
  re_node_set eclosure_elem ;

  {
#line 1616
  incomplete = (_Bool)0;
#line 1618
  node_idx = 0U;
#line 1618
  while (1) {
#line 1622
    if (node_idx == dfa->nodes_len) {
#line 1624
      if (! incomplete) {
#line 1625
        break;
      }
#line 1626
      incomplete = (_Bool)0;
#line 1627
      node_idx = 0U;
    }
#line 1635
    if ((dfa->eclosures + node_idx)->nelem != 0U) {
#line 1636
      goto __Cont;
    }
#line 1638
    err = calc_eclosure_iter(& eclosure_elem, dfa, node_idx, (_Bool)1);
#line 1639
    if ((int )err != 0) {
#line 1640
      return (err);
    }
#line 1642
    if ((dfa->eclosures + node_idx)->nelem == 0U) {
#line 1644
      incomplete = (_Bool)1;
#line 1645
      free((void *)eclosure_elem.elems);
    }
    __Cont: 
#line 1618
    node_idx ++;
  }
#line 1648
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1653 "regcomp.c"
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , Idx node ,
                                        _Bool root ) 
{ reg_errcode_t err ;
  unsigned int constraint ;
  Idx i ;
  _Bool incomplete ;
  _Bool ok ;
  re_node_set eclosure ;
  re_node_set eclosure_elem ;
  Idx edest ;

  {
#line 1662
  incomplete = (_Bool)0;
#line 1663
  err = re_node_set_alloc(& eclosure, (dfa->edests + node)->nelem + 1U);
#line 1664
  if ((int )err != 0) {
#line 1665
    return (err);
  }
#line 1669
  (dfa->eclosures + node)->nelem = 4294967295U;
#line 1671
  constraint = (unsigned int )(dfa->nodes + node)->type == 12U ? (unsigned int )(dfa->nodes + node)->opr.ctx_type : 0U;
#line 1675
  if ((constraint && (dfa->edests + node)->nelem) && ! (dfa->nodes + *((dfa->edests + node)->elems + 0))->duplicated) {
#line 1679
    err = duplicate_node_closure(dfa, node, node, node, constraint);
#line 1680
    if ((int )err != 0) {
#line 1681
      return (err);
    }
  }
#line 1685
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
#line 1686
    i = 0U;
#line 1686
    while (i < (dfa->edests + node)->nelem) {
#line 1689
      edest = *((dfa->edests + node)->elems + i);
#line 1692
      if ((dfa->eclosures + edest)->nelem == 4294967295U) {
#line 1694
        incomplete = (_Bool)1;
#line 1695
        goto __Cont;
      }
#line 1699
      if ((dfa->eclosures + edest)->nelem == 0U) {
#line 1701
        err = calc_eclosure_iter(& eclosure_elem, dfa, edest, (_Bool)0);
#line 1702
        if ((int )err != 0) {
#line 1703
          return (err);
        }
      } else {
#line 1706
        eclosure_elem = *(dfa->eclosures + edest);
      }
#line 1708
      re_node_set_merge(& eclosure, (re_node_set const   *)(& eclosure_elem));
#line 1711
      if ((dfa->eclosures + edest)->nelem == 0U) {
#line 1713
        incomplete = (_Bool)1;
#line 1714
        free((void *)eclosure_elem.elems);
      }
      __Cont: 
#line 1686
      i ++;
    }
  }
#line 1719
  ok = re_node_set_insert(& eclosure, node);
#line 1720
  if (! ok) {
#line 1721
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 1722
  if (incomplete && ! root) {
#line 1723
    (dfa->eclosures + node)->nelem = 0U;
  } else {
#line 1725
    *(dfa->eclosures + node) = eclosure;
  }
#line 1726
  *new_set = eclosure;
#line 1727
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1735 "regcomp.c"
static void fetch_token(re_token_t *result , re_string_t *input , reg_syntax_t syntax ) 
{ int __cil_tmp ;

  {
#line 1739
  __cil_tmp = peek_token(result, input, syntax);
#line 1739
  input->cur_idx += (unsigned int )__cil_tmp;
#line 1740
  return;
}
}
#line 1745 "regcomp.c"
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ unsigned char c ;
  unsigned char c2 ;
  wint_t wc ;
  wint_t __cil_tmp ;
  int __cil_tmp___0 ;
  wint_t wc___0 ;
  wint_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  char prev ;
  re_token_t next ;

  {
#line 1751
  if (input->stop <= input->cur_idx) {
#line 1753
    token->type = (enum __anonenum_re_token_type_t_15 )2;
#line 1754
    return (0);
  }
#line 1757
  c = *(input->mbs + input->cur_idx);
#line 1758
  token->opr.c = c;
#line 1760
  token->word_char = 0U;
#line 1762
  token->mb_partial = 0U;
#line 1763
  if (input->mb_cur_max > 1 && ! (input->cur_idx == input->valid_len || *(input->wcs + input->cur_idx) != -1)) {
#line 1766
    token->type = (enum __anonenum_re_token_type_t_15 )1;
#line 1767
    token->mb_partial = 1U;
#line 1768
    return (1);
  }
#line 1771
  if ((int )c == 92) {
#line 1774
    if (input->cur_idx + 1U >= input->len) {
#line 1776
      token->type = (enum __anonenum_re_token_type_t_15 )36;
#line 1777
      return (1);
    }
#line 1780
    c2 = re_string_peek_byte_case((re_string_t const   *)input, 1U);
#line 1781
    token->opr.c = c2;
#line 1782
    token->type = (enum __anonenum_re_token_type_t_15 )1;
#line 1784
    if (input->mb_cur_max > 1) {
#line 1786
      __cil_tmp = re_string_wchar_at((re_string_t const   *)input, input->cur_idx + 1U);
#line 1786
      wc = __cil_tmp;
#line 1788
      __cil_tmp___0 = iswalnum(wc);
#line 1788
      token->word_char = (unsigned int )((__cil_tmp___0 || wc == 95) != 0);
    } else {
#line 1792
      token->word_char = (unsigned int )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )c2))) + (int )c2) & 7 || (int )c2 == 95) != 0);
    }
#line 1794
    switch ((int )c2) {
    case 124: 
#line 1797
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && ! (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1798
      token->type = (enum __anonenum_re_token_type_t_15 )10;
    }
#line 1799
    break;
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
#line 1802
    if (! (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1804
      token->type = (enum __anonenum_re_token_type_t_15 )4;
#line 1805
      token->opr.idx = (unsigned int )((int )c2 - 49);
    }
#line 1807
    break;
    case 60: 
#line 1809
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1811
      token->type = (enum __anonenum_re_token_type_t_15 )12;
#line 1812
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )6;
    }
#line 1814
    break;
    case 62: 
#line 1816
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1818
      token->type = (enum __anonenum_re_token_type_t_15 )12;
#line 1819
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )9;
    }
#line 1821
    break;
    case 98: 
#line 1823
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1825
      token->type = (enum __anonenum_re_token_type_t_15 )12;
#line 1826
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )256;
    }
#line 1828
    break;
    case 66: 
#line 1830
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1832
      token->type = (enum __anonenum_re_token_type_t_15 )12;
#line 1833
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )512;
    }
#line 1835
    break;
    case 119: 
#line 1837
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1838
      token->type = (enum __anonenum_re_token_type_t_15 )32;
    }
#line 1839
    break;
    case 87: 
#line 1841
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1842
      token->type = (enum __anonenum_re_token_type_t_15 )33;
    }
#line 1843
    break;
    case 115: 
#line 1845
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1846
      token->type = (enum __anonenum_re_token_type_t_15 )34;
    }
#line 1847
    break;
    case 83: 
#line 1849
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1850
      token->type = (enum __anonenum_re_token_type_t_15 )35;
    }
#line 1851
    break;
    case 96: 
#line 1853
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1855
      token->type = (enum __anonenum_re_token_type_t_15 )12;
#line 1856
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )64;
    }
#line 1858
    break;
    case 39: 
#line 1860
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1862
      token->type = (enum __anonenum_re_token_type_t_15 )12;
#line 1863
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )128;
    }
#line 1865
    break;
    case 40: 
#line 1867
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1868
      token->type = (enum __anonenum_re_token_type_t_15 )8;
    }
#line 1869
    break;
    case 41: 
#line 1871
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1872
      token->type = (enum __anonenum_re_token_type_t_15 )9;
    }
#line 1873
    break;
    case 43: 
#line 1875
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && syntax & (1UL << 1)) {
#line 1876
      token->type = (enum __anonenum_re_token_type_t_15 )18;
    }
#line 1877
    break;
    case 63: 
#line 1879
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && syntax & (1UL << 1)) {
#line 1880
      token->type = (enum __anonenum_re_token_type_t_15 )19;
    }
#line 1881
    break;
    case 123: 
#line 1883
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && ! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1884
      token->type = (enum __anonenum_re_token_type_t_15 )23;
    }
#line 1885
    break;
    case 125: 
#line 1887
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && ! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1888
      token->type = (enum __anonenum_re_token_type_t_15 )24;
    }
#line 1889
    break;
    default: 
#line 1891
    break;
    }
#line 1893
    return (2);
  }
#line 1896
  token->type = (enum __anonenum_re_token_type_t_15 )1;
#line 1898
  if (input->mb_cur_max > 1) {
#line 1900
    __cil_tmp___1 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx);
#line 1900
    wc___0 = __cil_tmp___1;
#line 1901
    __cil_tmp___2 = iswalnum(wc___0);
#line 1901
    token->word_char = (unsigned int )((__cil_tmp___2 || wc___0 == 95) != 0);
  } else {
#line 1905
    token->word_char = (unsigned int )((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )token->opr.c))) + (int )token->opr.c) & 7 || (int )token->opr.c == 95);
  }
#line 1907
  switch ((int )c) {
  case 10: 
#line 1910
  if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1911
    token->type = (enum __anonenum_re_token_type_t_15 )10;
  }
#line 1912
  break;
  case 124: 
#line 1914
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1915
    token->type = (enum __anonenum_re_token_type_t_15 )10;
  }
#line 1916
  break;
  case 42: 
#line 1918
  token->type = (enum __anonenum_re_token_type_t_15 )11;
#line 1919
  break;
  case 43: 
#line 1921
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && ! (syntax & (1UL << 1))) {
#line 1922
    token->type = (enum __anonenum_re_token_type_t_15 )18;
  }
#line 1923
  break;
  case 63: 
#line 1925
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && ! (syntax & (1UL << 1))) {
#line 1926
    token->type = (enum __anonenum_re_token_type_t_15 )19;
  }
#line 1927
  break;
  case 123: 
#line 1929
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1930
    token->type = (enum __anonenum_re_token_type_t_15 )23;
  }
#line 1931
  break;
  case 125: 
#line 1933
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1934
    token->type = (enum __anonenum_re_token_type_t_15 )24;
  }
#line 1935
  break;
  case 40: 
#line 1937
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1938
    token->type = (enum __anonenum_re_token_type_t_15 )8;
  }
#line 1939
  break;
  case 41: 
#line 1941
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1942
    token->type = (enum __anonenum_re_token_type_t_15 )9;
  }
#line 1943
  break;
  case 91: 
#line 1945
  token->type = (enum __anonenum_re_token_type_t_15 )20;
#line 1946
  break;
  case 46: 
#line 1948
  token->type = (enum __anonenum_re_token_type_t_15 )5;
#line 1949
  break;
  case 94: 
#line 1951
  if (! (syntax & ((((1UL << 1) << 1) << 1) | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) && input->cur_idx != 0U) {
#line 1954
    prev = (char )*(input->mbs + (input->cur_idx + 4294967295U));
#line 1955
    if (! (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) || (int )prev != 10) {
#line 1956
      break;
    }
  }
#line 1958
  token->type = (enum __anonenum_re_token_type_t_15 )12;
#line 1959
  token->opr.ctx_type = (enum __anonenum_re_context_type_13 )16;
#line 1960
  break;
  case 36: 
#line 1962
  if (! (syntax & (((1UL << 1) << 1) << 1)) && input->cur_idx + 1U != input->len) {
#line 1966
    (input->cur_idx) ++;
#line 1967
    peek_token(& next, input, syntax);
#line 1968
    input->cur_idx += 4294967295U;
#line 1969
    if ((unsigned int )next.type != 10U && (unsigned int )next.type != 9U) {
#line 1970
      break;
    }
  }
#line 1972
  token->type = (enum __anonenum_re_token_type_t_15 )12;
#line 1973
  token->opr.ctx_type = (enum __anonenum_re_context_type_13 )32;
#line 1974
  break;
  default: 
#line 1976
  break;
  }
#line 1978
  return (1);
}
}
#line 1984 "regcomp.c"
static int peek_token_bracket(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ unsigned char c ;
  unsigned char c2 ;
  unsigned char c2___0 ;
  int token_len ;

  {
#line 1989
  if (input->stop <= input->cur_idx) {
#line 1991
    token->type = (enum __anonenum_re_token_type_t_15 )2;
#line 1992
    return (0);
  }
#line 1994
  c = *(input->mbs + input->cur_idx);
#line 1995
  token->opr.c = c;
#line 1998
  if (input->mb_cur_max > 1 && ! (input->cur_idx == input->valid_len || *(input->wcs + input->cur_idx) != -1)) {
#line 2001
    token->type = (enum __anonenum_re_token_type_t_15 )1;
#line 2002
    return (1);
  }
#line 2006
  if (((int )c == 92 && syntax & 1UL) && input->cur_idx + 1U < input->len) {
#line 2011
    (input->cur_idx) ++;
#line 2012
    c2 = *(input->mbs + input->cur_idx);
#line 2013
    token->opr.c = c2;
#line 2014
    token->type = (enum __anonenum_re_token_type_t_15 )1;
#line 2015
    return (1);
  }
#line 2017
  if ((int )c == 91) {
#line 2021
    if (input->cur_idx + 1U < input->len) {
#line 2022
      c2___0 = *(input->mbs + (input->cur_idx + 1U));
    } else {
#line 2024
      c2___0 = (unsigned char)0;
    }
#line 2025
    token->opr.c = c2___0;
#line 2026
    token_len = 2;
#line 2027
    switch ((int )c2___0) {
    case 46: 
#line 2030
    token->type = (enum __anonenum_re_token_type_t_15 )26;
#line 2031
    break;
    case 61: 
#line 2033
    token->type = (enum __anonenum_re_token_type_t_15 )28;
#line 2034
    break;
    case 58: 
#line 2036
    if (syntax & ((1UL << 1) << 1)) {
#line 2038
      token->type = (enum __anonenum_re_token_type_t_15 )30;
#line 2039
      break;
    }
    default: 
#line 2043
    token->type = (enum __anonenum_re_token_type_t_15 )1;
#line 2044
    token->opr.c = c;
#line 2045
    token_len = 1;
#line 2046
    break;
    }
#line 2048
    return (token_len);
  }
#line 2050
  switch ((int )c) {
  case 45: 
#line 2053
  token->type = (enum __anonenum_re_token_type_t_15 )22;
#line 2054
  break;
  case 93: 
#line 2056
  token->type = (enum __anonenum_re_token_type_t_15 )21;
#line 2057
  break;
  case 94: 
#line 2059
  token->type = (enum __anonenum_re_token_type_t_15 )25;
#line 2060
  break;
  default: 
#line 2062
  token->type = (enum __anonenum_re_token_type_t_15 )1;
  }
#line 2064
  return (1);
}
}
#line 2081 "regcomp.c"
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) 
{ re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *eor ;
  bin_tree_t *root ;
  re_token_t current_token ;

  {
#line 2085
  dfa = (re_dfa_t *)preg->buffer;
#line 2088
  dfa->syntax = syntax;
#line 2089
  fetch_token(& current_token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2090
  tree = parse_reg_exp(regexp, preg, & current_token, syntax, 0U, err);
#line 2091
  if ((int )*err != 0 && (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2092
    return ((bin_tree_t *)((void *)0));
  }
#line 2093
  eor = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (enum __anonenum_re_token_type_t_15 )2);
#line 2094
  if ((unsigned int )tree != (unsigned int )((void *)0)) {
#line 2095
    root = create_tree(dfa, tree, eor, (enum __anonenum_re_token_type_t_15 )16);
  } else {
#line 2097
    root = eor;
  }
#line 2098
  if ((unsigned int )eor == (unsigned int )((void *)0) || (unsigned int )root == (unsigned int )((void *)0)) {
#line 2100
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2101
    return ((bin_tree_t *)((void *)0));
  }
#line 2103
  return (root);
}
}
#line 2115 "regcomp.c"
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *branch ;

  {
#line 2119
  dfa = (re_dfa_t *)preg->buffer;
#line 2120
  branch = (bin_tree_t *)((void *)0);
#line 2121
  tree = parse_branch(regexp, preg, token, syntax, nest, err);
#line 2122
  if ((int )*err != 0 && (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2123
    return ((bin_tree_t *)((void *)0));
  }
#line 2125
  while ((unsigned int )token->type == 10U) {
#line 2127
    fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2128
    if (((unsigned int )token->type != 10U && (unsigned int )token->type != 2U) && (nest == 0U || (unsigned int )token->type != 9U)) {
#line 2131
      branch = parse_branch(regexp, preg, token, syntax, nest, err);
#line 2132
      if ((int )*err != 0 && (unsigned int )branch == (unsigned int )((void *)0)) {
#line 2133
        return ((bin_tree_t *)((void *)0));
      }
    } else {
#line 2136
      branch = (bin_tree_t *)((void *)0);
    }
#line 2137
    tree = create_tree(dfa, tree, branch, (enum __anonenum_re_token_type_t_15 )10);
#line 2138
    if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2140
      *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2141
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2144
  return (tree);
}
}
#line 2156 "regcomp.c"
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ bin_tree_t *tree ;
  bin_tree_t *expr ;
  re_dfa_t *dfa ;

  {
#line 2161
  dfa = (re_dfa_t *)preg->buffer;
#line 2162
  tree = parse_expression(regexp, preg, token, syntax, nest, err);
#line 2163
  if ((int )*err != 0 && (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2164
    return ((bin_tree_t *)((void *)0));
  }
#line 2166
  while (((unsigned int )token->type != 10U && (unsigned int )token->type != 2U) && (nest == 0U || (unsigned int )token->type != 9U)) {
#line 2169
    expr = parse_expression(regexp, preg, token, syntax, nest, err);
#line 2170
    if ((int )*err != 0 && (unsigned int )expr == (unsigned int )((void *)0)) {
#line 2172
      return ((bin_tree_t *)((void *)0));
    }
#line 2174
    if ((unsigned int )tree != (unsigned int )((void *)0) && (unsigned int )expr != (unsigned int )((void *)0)) {
#line 2176
      tree = create_tree(dfa, tree, expr, (enum __anonenum_re_token_type_t_15 )16);
#line 2177
      if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2179
        *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2180
        return ((bin_tree_t *)((void *)0));
      }
    } else
#line 2183
    if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2184
      tree = expr;
    }
  }
#line 2187
  return (tree);
}
}
#line 2196 "regcomp.c"
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *mbc_remain ;
  bin_tree_t *__cil_tmp ;
  bin_tree_t *tree_first ;
  bin_tree_t *tree_last ;

  {
#line 2200
  dfa = (re_dfa_t *)preg->buffer;
#line 2202
  switch ((int )token->type) {
  case 1: 
#line 2205
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2206
  if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2208
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2209
    return ((bin_tree_t *)((void *)0));
  }
#line 2212
  if (dfa->mb_cur_max > 1) {
#line 2214
    while (! (regexp->stop <= regexp->cur_idx) && ! (regexp->cur_idx == regexp->valid_len || *(regexp->wcs + regexp->cur_idx) != -1)) {
#line 2218
      fetch_token(token, regexp, syntax);
#line 2219
      mbc_remain = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2220
      tree = create_tree(dfa, tree, mbc_remain, (enum __anonenum_re_token_type_t_15 )16);
#line 2221
      if ((unsigned int )mbc_remain == (unsigned int )((void *)0) || (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2223
        *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2224
        return ((bin_tree_t *)((void *)0));
      }
    }
  }
#line 2229
  break;
  case 8: 
#line 2231
  tree = parse_sub_exp(regexp, preg, token, syntax, nest + 1U, err);
#line 2232
  if ((int )*err != 0 && (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2233
    return ((bin_tree_t *)((void *)0));
  }
#line 2234
  break;
  case 20: 
#line 2236
  tree = parse_bracket_exp(regexp, dfa, token, syntax, err);
#line 2237
  if ((int )*err != 0 && (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2238
    return ((bin_tree_t *)((void *)0));
  }
#line 2239
  break;
  case 4: 
#line 2241
  if (! (dfa->completed_bkref_map & (unsigned long )(1 << token->opr.idx))) {
#line 2243
    *err = (enum __anonenum_reg_errcode_t_7 )6;
#line 2244
    return ((bin_tree_t *)((void *)0));
  }
#line 2246
  dfa->used_bkref_map |= (unsigned long )(1 << token->opr.idx);
#line 2247
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2248
  if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2250
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2251
    return ((bin_tree_t *)((void *)0));
  }
#line 2253
  (dfa->nbackref) ++;
#line 2254
  dfa->has_mb_node = 1U;
#line 2255
  break;
  case 23: 
#line 2257
  if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2259
    *err = (enum __anonenum_reg_errcode_t_7 )13;
#line 2260
    return ((bin_tree_t *)((void *)0));
  }
  case 11: 
  case 18: 
  case 19: 
#line 2266
  if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 2268
    *err = (enum __anonenum_reg_errcode_t_7 )13;
#line 2269
    return ((bin_tree_t *)((void *)0));
  } else
#line 2271
  if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
#line 2273
    fetch_token(token, regexp, syntax);
#line 2274
    __cil_tmp = parse_expression(regexp, preg, token, syntax, nest, err);
#line 2274
    return (__cil_tmp);
  }
  case 9: 
#line 2278
  if ((unsigned int )token->type == 9U && ! (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2281
    *err = (enum __anonenum_reg_errcode_t_7 )16;
#line 2282
    return ((bin_tree_t *)((void *)0));
  }
  case 24: 
#line 2289
  token->type = (enum __anonenum_re_token_type_t_15 )1;
#line 2292
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2293
  if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2295
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2296
    return ((bin_tree_t *)((void *)0));
  }
#line 2298
  break;
  case 12: 
#line 2300
  if ((unsigned int )token->opr.ctx_type & 783U && dfa->word_ops_used == 0U) {
#line 2303
    init_word_char(dfa);
  }
#line 2304
  if ((unsigned int )token->opr.ctx_type == 256U || (unsigned int )token->opr.ctx_type == 512U) {
#line 2308
    if ((unsigned int )token->opr.ctx_type == 256U) {
#line 2310
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )6;
#line 2311
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2312
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )9;
    } else {
#line 2316
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )5;
#line 2317
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2318
      token->opr.ctx_type = (enum __anonenum_re_context_type_13 )10;
    }
#line 2320
    tree_last = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)token);
#line 2321
    tree = create_tree(dfa, tree_first, tree_last, (enum __anonenum_re_token_type_t_15 )10);
#line 2322
    if (((unsigned int )tree_first == (unsigned int )((void *)0) || (unsigned int )tree_last == (unsigned int )((void *)0)) || (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2324
      *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2325
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 2330
    tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                             (re_token_t const   *)token);
#line 2331
    if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2333
      *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2334
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2341
  fetch_token(token, regexp, syntax);
#line 2342
  return (tree);
  case 5: 
#line 2344
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2345
  if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2347
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2348
    return ((bin_tree_t *)((void *)0));
  }
#line 2350
  if (dfa->mb_cur_max > 1) {
#line 2351
    dfa->has_mb_node = 1U;
  }
#line 2352
  break;
  case 32: 
  case 33: 
#line 2355
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"alnum",
                            (unsigned char const   *)"_", (_Bool )((unsigned int )token->type == 33U),
                            err);
#line 2359
  if ((int )*err != 0 && (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2360
    return ((bin_tree_t *)((void *)0));
  }
#line 2361
  break;
  case 34: 
  case 35: 
#line 2364
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"space",
                            (unsigned char const   *)"", (_Bool )((unsigned int )token->type == 35U),
                            err);
#line 2368
  if ((int )*err != 0 && (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2369
    return ((bin_tree_t *)((void *)0));
  }
#line 2370
  break;
  case 10: 
  case 2: 
#line 2373
  return ((bin_tree_t *)((void *)0));
  case 36: 
#line 2375
  *err = (enum __anonenum_reg_errcode_t_7 )5;
#line 2376
  return ((bin_tree_t *)((void *)0));
  default: 
#line 2382
  return ((bin_tree_t *)((void *)0));
  }
#line 2384
  fetch_token(token, regexp, syntax);
#line 2386
  while ((((unsigned int )token->type == 11U || (unsigned int )token->type == 18U) || (unsigned int )token->type == 19U) || (unsigned int )token->type == 23U) {
#line 2389
    tree = parse_dup_op(tree, regexp, dfa, token, syntax, err);
#line 2390
    if ((int )*err != 0 && (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2391
      return ((bin_tree_t *)((void *)0));
    }
#line 2393
    if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && ((unsigned int )token->type == 11U || (unsigned int )token->type == 23U)) {
#line 2397
      *err = (enum __anonenum_reg_errcode_t_7 )13;
#line 2398
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2402
  return (tree);
}
}
#line 2412 "regcomp.c"
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ re_dfa_t *dfa ;
  bin_tree_t *tree ;
  size_t cur_nsub ;
  size_t __cil_tmp ;

  {
#line 2416
  dfa = (re_dfa_t *)preg->buffer;
#line 2419
  __cil_tmp = preg->re_nsub;
#line 2419
  (preg->re_nsub) ++;
#line 2419
  cur_nsub = __cil_tmp;
#line 2421
  fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2424
  if ((unsigned int )token->type == 9U) {
#line 2425
    tree = (bin_tree_t *)((void *)0);
  } else {
#line 2428
    tree = parse_reg_exp(regexp, preg, token, syntax, nest, err);
#line 2429
    if ((int )*err == 0 && (unsigned int )token->type != 9U) {
#line 2430
      *err = (enum __anonenum_reg_errcode_t_7 )8;
    }
#line 2431
    if ((int )*err != 0) {
#line 2432
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2435
  if (cur_nsub <= 8U) {
#line 2436
    dfa->completed_bkref_map |= (unsigned long )(1 << cur_nsub);
  }
#line 2438
  tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (enum __anonenum_re_token_type_t_15 )17);
#line 2439
  if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2441
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2442
    return ((bin_tree_t *)((void *)0));
  }
#line 2444
  tree->token.opr.idx = cur_nsub;
#line 2445
  return (tree);
}
}
#line 2450 "regcomp.c"
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) 
{ bin_tree_t *tree ;
  bin_tree_t *old_tree ;
  Idx i ;
  Idx start ;
  Idx end ;
  Idx start_idx ;
  re_token_t start_token ;
  Idx __cil_tmp ;
  Idx __cil_tmp___0 ;

  {
#line 2454
  tree = (bin_tree_t *)((void *)0);
#line 2454
  old_tree = (bin_tree_t *)((void *)0);
#line 2455
  start_idx = regexp->cur_idx;
#line 2456
  start_token = *token;
#line 2458
  if ((unsigned int )token->type == 23U) {
#line 2460
    end = 0U;
#line 2461
    start = fetch_number(regexp, token, syntax);
#line 2462
    if (start == 4294967295U) {
#line 2464
      if ((unsigned int )token->type == 1U && (int )token->opr.c == 44) {
#line 2465
        start = 0U;
      } else {
#line 2468
        *err = (enum __anonenum_reg_errcode_t_7 )10;
#line 2469
        return ((bin_tree_t *)((void *)0));
      }
    }
#line 2472
    if (start != 4294967294U) {
#line 2475
      if ((unsigned int )token->type == 24U) {
#line 2475
        end = start;
      } else {
#line 2475
        if ((unsigned int )token->type == 1U && (int )token->opr.c == 44) {
#line 2475
          __cil_tmp = fetch_number(regexp, token, syntax);
#line 2475
          __cil_tmp___0 = __cil_tmp;
        } else {
#line 2475
          __cil_tmp___0 = 4294967294U;
        }
#line 2475
        end = __cil_tmp___0;
      }
    }
#line 2479
    if (start == 4294967294U || end == 4294967294U) {
#line 2482
      if (! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2484
        if ((unsigned int )token->type == 2U) {
#line 2485
          *err = (enum __anonenum_reg_errcode_t_7 )9;
        } else {
#line 2487
          *err = (enum __anonenum_reg_errcode_t_7 )10;
        }
#line 2489
        return ((bin_tree_t *)((void *)0));
      }
#line 2493
      regexp->cur_idx = start_idx;
#line 2494
      *token = start_token;
#line 2495
      token->type = (enum __anonenum_re_token_type_t_15 )1;
#line 2498
      return (elem);
    }
#line 2501
    if (end != 4294967295U && start > end) {
#line 2504
      *err = (enum __anonenum_reg_errcode_t_7 )10;
#line 2505
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 2510
    start = (unsigned int )((unsigned int )token->type == 18U ? 1 : 0);
#line 2511
    end = (unsigned int )token->type == 19U ? 1U : 4294967295U;
  }
#line 2514
  fetch_token(token, regexp, syntax);
#line 2516
  if ((unsigned int )elem == (unsigned int )((void *)0)) {
#line 2517
    return ((bin_tree_t *)((void *)0));
  }
#line 2518
  if (start == 0U && end == 0U) {
#line 2520
    postorder(elem, & free_tree, (void *)0);
#line 2521
    return ((bin_tree_t *)((void *)0));
  }
#line 2525
  if (start > 0U) {
#line 2527
    tree = elem;
#line 2528
    i = 2U;
#line 2528
    while (i <= start) {
#line 2530
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2531
      tree = create_tree(dfa, tree, elem, (enum __anonenum_re_token_type_t_15 )16);
#line 2532
      if ((unsigned int )elem == (unsigned int )((void *)0) || (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2533
        goto parse_dup_op_espace;
      }
#line 2528
      i ++;
    }
#line 2536
    if (start == end) {
#line 2537
      return (tree);
    }
#line 2540
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2541
    old_tree = tree;
  } else {
#line 2544
    old_tree = (bin_tree_t *)((void *)0);
  }
#line 2546
  if ((unsigned int )elem->token.type == 17U) {
#line 2547
    postorder(elem, & mark_opt_subexp, (void *)((long )elem->token.opr.idx));
  }
#line 2549
  tree = create_tree(dfa, elem, (bin_tree_t *)((void *)0), (enum __anonenum_re_token_type_t_15 )(end == 4294967295U ? 11 : 10));
#line 2551
  if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2552
    goto parse_dup_op_espace;
  }
#line 2557
  if (end != 4294967295U) {
#line 2558
    i = start + 2U;
#line 2558
    while (i <= end) {
#line 2560
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2561
      tree = create_tree(dfa, tree, elem, (enum __anonenum_re_token_type_t_15 )16);
#line 2562
      if ((unsigned int )elem == (unsigned int )((void *)0) || (unsigned int )tree == (unsigned int )((void *)0)) {
#line 2563
        goto parse_dup_op_espace;
      }
#line 2565
      tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (enum __anonenum_re_token_type_t_15 )10);
#line 2566
      if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 2567
        goto parse_dup_op_espace;
      }
#line 2558
      i ++;
    }
  }
#line 2570
  if (old_tree) {
#line 2571
    tree = create_tree(dfa, old_tree, tree, (enum __anonenum_re_token_type_t_15 )16);
  }
#line 2573
  return (tree);
  parse_dup_op_espace: 
#line 2576
  *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2577
  return ((bin_tree_t *)((void *)0));
}
}
#line 2592 "regcomp.c"
static reg_errcode_t build_range_exp(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                     Idx *range_alloc , bracket_elem_t *start_elem ,
                                     bracket_elem_t *end_elem ) 
{ unsigned int start_ch ;
  unsigned int end_ch ;
  size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  wchar_t wc ;
  wint_t start_wc ;
  wint_t end_wc ;
  wchar_t cmp_buf[6] ;
  wint_t __cil_tmp___1 ;
  wint_t __cil_tmp___2 ;
  int __cil_tmp___3 ;
  wchar_t *new_array_start ;
  wchar_t *new_array_end ;
  Idx new_nranges ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;
  Idx __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;

  {
#line 2604
  if ((((unsigned int )start_elem->type == 2U || (unsigned int )start_elem->type == 4U) || (unsigned int )end_elem->type == 2U) || (unsigned int )end_elem->type == 4U) {
#line 2607
    return ((enum __anonenum_reg_errcode_t_7 )11);
  }
#line 2611
  if ((unsigned int )start_elem->type == 3U) {
#line 2611
    __cil_tmp = strlen((char const   *)((char *)start_elem->opr.name));
#line 2611
    if (__cil_tmp > 1U) {
#line 2615
      return ((enum __anonenum_reg_errcode_t_7 )3);
    } else {
#line 2611
      goto _L;
    }
  } else
  _L: 
#line 2611
  if ((unsigned int )end_elem->type == 3U) {
#line 2611
    __cil_tmp___0 = strlen((char const   *)((char *)end_elem->opr.name));
#line 2611
    if (__cil_tmp___0 > 1U) {
#line 2615
      return ((enum __anonenum_reg_errcode_t_7 )3);
    }
  }
#line 2622
  cmp_buf[0] = (short)0;
#line 2622
  cmp_buf[1] = (short)0;
#line 2622
  cmp_buf[2] = (short)0;
#line 2622
  cmp_buf[3] = (short)0;
#line 2622
  cmp_buf[4] = (short)0;
#line 2622
  cmp_buf[5] = (short)0;
#line 2624
  start_ch = (unsigned int )((unsigned int )start_elem->type == 0U ? (int )start_elem->opr.ch : ((unsigned int )start_elem->type == 3U ? (int )*(start_elem->opr.name + 0) : 0));
#line 2627
  end_ch = (unsigned int )((unsigned int )end_elem->type == 0U ? (int )end_elem->opr.ch : ((unsigned int )end_elem->type == 3U ? (int )*(end_elem->opr.name + 0) : 0));
#line 2630
  if ((unsigned int )start_elem->type == 0U || (unsigned int )start_elem->type == 3U) {
#line 2630
    __cil_tmp___1 = btowc((int )start_ch);
#line 2630
    start_wc = __cil_tmp___1;
  } else {
#line 2630
    start_wc = (int )start_elem->opr.wch;
  }
#line 2632
  if ((unsigned int )end_elem->type == 0U || (unsigned int )end_elem->type == 3U) {
#line 2632
    __cil_tmp___2 = btowc((int )end_ch);
#line 2632
    end_wc = __cil_tmp___2;
  } else {
#line 2632
    end_wc = (int )end_elem->opr.wch;
  }
#line 2634
  if (start_wc == -1 || end_wc == -1) {
#line 2635
    return ((enum __anonenum_reg_errcode_t_7 )3);
  }
#line 2636
  cmp_buf[0] = (short )start_wc;
#line 2637
  cmp_buf[4] = (short )end_wc;
#line 2638
  __cil_tmp___3 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 4));
#line 2638
  if (__cil_tmp___3 > 0) {
#line 2639
    return ((enum __anonenum_reg_errcode_t_7 )11);
  }
#line 2646
  if (mbcset) {
#line 2649
    if (*range_alloc == mbcset->nranges) {
#line 2656
      new_nranges = 2U * mbcset->nranges + 1U;
#line 2659
      __cil_tmp___4 = rpl_realloc((void *)mbcset->range_starts, new_nranges * sizeof(wchar_t ));
#line 2659
      new_array_start = (wchar_t *)__cil_tmp___4;
#line 2661
      __cil_tmp___5 = rpl_realloc((void *)mbcset->range_ends, new_nranges * sizeof(wchar_t ));
#line 2661
      new_array_end = (wchar_t *)__cil_tmp___5;
#line 2664
      if ((unsigned int )new_array_start == (unsigned int )((void *)0) || (unsigned int )new_array_end == (unsigned int )((void *)0)) {
#line 2665
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 2667
      mbcset->range_starts = new_array_start;
#line 2668
      mbcset->range_ends = new_array_end;
#line 2669
      *range_alloc = new_nranges;
    }
#line 2672
    *(mbcset->range_starts + mbcset->nranges) = (short )start_wc;
#line 2673
    __cil_tmp___6 = mbcset->nranges;
#line 2673
    (mbcset->nranges) ++;
#line 2673
    *(mbcset->range_ends + __cil_tmp___6) = (short )end_wc;
  }
#line 2677
  wc = (short)0;
#line 2677
  while ((int )wc < 256) {
#line 2679
    cmp_buf[2] = wc;
#line 2680
    __cil_tmp___7 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
#line 2680
    if (__cil_tmp___7 <= 0) {
#line 2680
      __cil_tmp___8 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
#line 2680
      if (__cil_tmp___8 <= 0) {
#line 2682
        bitset_set(sbcset, (unsigned int )wc);
      }
    }
#line 2677
    wc = (short )((int )wc + 1);
  }
#line 2702
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 2713 "regcomp.c"
static reg_errcode_t build_collating_symbol(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                            Idx *coll_sym_alloc , unsigned char const   *name ) 
{ size_t name_len ;
  size_t __cil_tmp ;

  {
#line 2721
  __cil_tmp = strlen((char const   *)name);
#line 2721
  name_len = __cil_tmp;
#line 2722
  if (name_len != 1U) {
#line 2723
    return ((enum __anonenum_reg_errcode_t_7 )3);
  } else {
#line 2726
    bitset_set(sbcset, (unsigned int )*(name + 0));
#line 2727
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
}
}
#line 2735 "regcomp.c"
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) 
{ re_token_t br_token ;
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx coll_sym_alloc ;
  Idx range_alloc ;
  Idx mbchar_alloc ;
  Idx equiv_class_alloc ;
  Idx char_class_alloc ;
  _Bool non_match ;
  bin_tree_t *work_tree ;
  int token_len ;
  _Bool first_round ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  bracket_elem_t start_elem ;
  bracket_elem_t end_elem ;
  unsigned char start_name_buf[32] ;
  unsigned char end_name_buf[32] ;
  reg_errcode_t ret ;
  int token_len2 ;
  _Bool is_range_exp ;
  re_token_t token2 ;
  wchar_t *new_mbchars ;
  void *__cil_tmp___1 ;
  Idx __cil_tmp___2 ;
  bin_tree_t *mbc_tree ;
  int sbc_idx ;

  {
#line 3006
  coll_sym_alloc = 0U;
#line 3006
  range_alloc = 0U;
#line 3006
  mbchar_alloc = 0U;
#line 3007
  equiv_class_alloc = 0U;
#line 3007
  char_class_alloc = 0U;
#line 3009
  non_match = (_Bool)0;
#line 3012
  first_round = (_Bool)1;
#line 3030
  __cil_tmp = rpl_calloc(sizeof(bitset_t ), 1U);
#line 3030
  sbcset = (bitset_word_t *)__cil_tmp;
#line 3032
  __cil_tmp___0 = rpl_calloc(sizeof(re_charset_t ), 1U);
#line 3032
  mbcset = (re_charset_t *)__cil_tmp___0;
#line 3035
  if ((unsigned int )sbcset == (unsigned int )((void *)0) || (unsigned int )mbcset == (unsigned int )((void *)0)) {
#line 3040
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 3041
    return ((bin_tree_t *)((void *)0));
  }
#line 3044
  token_len = peek_token_bracket(token, regexp, syntax);
#line 3045
  if ((unsigned int )token->type == 2U) {
#line 3047
    *err = (enum __anonenum_reg_errcode_t_7 )2;
#line 3048
    goto parse_bracket_exp_free_return;
  }
#line 3050
  if ((unsigned int )token->type == 25U) {
#line 3053
    mbcset->non_match = 1U;
#line 3055
    non_match = (_Bool)1;
#line 3056
    if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3057
      bitset_set(sbcset, (unsigned int )'\n');
    }
#line 3058
    regexp->cur_idx += (unsigned int )token_len;
#line 3059
    token_len = peek_token_bracket(token, regexp, syntax);
#line 3060
    if ((unsigned int )token->type == 2U) {
#line 3062
      *err = (enum __anonenum_reg_errcode_t_7 )2;
#line 3063
      goto parse_bracket_exp_free_return;
    }
  }
#line 3068
  if ((unsigned int )token->type == 21U) {
#line 3069
    token->type = (enum __anonenum_re_token_type_t_15 )1;
  }
#line 3071
  while (1) {
#line 3077
    token_len2 = 0;
#line 3078
    is_range_exp = (_Bool)0;
#line 3081
    start_elem.opr.name = start_name_buf;
#line 3082
    ret = parse_bracket_element(& start_elem, regexp, token, token_len, dfa, syntax,
                                first_round);
#line 3084
    if ((int )ret != 0) {
#line 3086
      *err = ret;
#line 3087
      goto parse_bracket_exp_free_return;
    }
#line 3089
    first_round = (_Bool)0;
#line 3092
    token_len = peek_token_bracket(token, regexp, syntax);
#line 3095
    if ((unsigned int )start_elem.type != 4U && (unsigned int )start_elem.type != 2U) {
#line 3097
      if ((unsigned int )token->type == 2U) {
#line 3099
        *err = (enum __anonenum_reg_errcode_t_7 )7;
#line 3100
        goto parse_bracket_exp_free_return;
      }
#line 3102
      if ((unsigned int )token->type == 22U) {
#line 3104
        regexp->cur_idx += (unsigned int )token_len;
#line 3105
        token_len2 = peek_token_bracket(& token2, regexp, syntax);
#line 3106
        if ((unsigned int )token2.type == 2U) {
#line 3108
          *err = (enum __anonenum_reg_errcode_t_7 )7;
#line 3109
          goto parse_bracket_exp_free_return;
        }
#line 3111
        if ((unsigned int )token2.type == 21U) {
#line 3114
          regexp->cur_idx += (unsigned int )(- token_len);
#line 3115
          token->type = (enum __anonenum_re_token_type_t_15 )1;
        } else {
#line 3118
          is_range_exp = (_Bool)1;
        }
      }
    }
#line 3122
    if ((int )is_range_exp == 1) {
#line 3124
      end_elem.opr.name = end_name_buf;
#line 3125
      ret = parse_bracket_element(& end_elem, regexp, & token2, token_len2, dfa, syntax,
                                  (_Bool)1);
#line 3127
      if ((int )ret != 0) {
#line 3129
        *err = ret;
#line 3130
        goto parse_bracket_exp_free_return;
      }
#line 3133
      token_len = peek_token_bracket(token, regexp, syntax);
#line 3140
      *err = build_range_exp(sbcset, dfa->mb_cur_max > 1 ? mbcset : (re_charset_t *)((void *)0),
                             & range_alloc, & start_elem, & end_elem);
#line 3147
      if ((int )*err != 0) {
#line 3148
        goto parse_bracket_exp_free_return;
      }
    } else {
#line 3152
      switch ((int )start_elem.type) {
      case 0: 
#line 3155
      bitset_set(sbcset, (unsigned int )start_elem.opr.ch);
#line 3156
      break;
      case 1: 
#line 3160
      if (mbchar_alloc == mbcset->nmbchars) {
#line 3165
        mbchar_alloc = 2U * mbcset->nmbchars + 1U;
#line 3167
        __cil_tmp___1 = rpl_realloc((void *)mbcset->mbchars, mbchar_alloc * sizeof(wchar_t ));
#line 3167
        new_mbchars = (wchar_t *)__cil_tmp___1;
#line 3169
        if ((unsigned int )new_mbchars == (unsigned int )((void *)0)) {
#line 3170
          goto parse_bracket_exp_espace;
        }
#line 3171
        mbcset->mbchars = new_mbchars;
      }
#line 3173
      __cil_tmp___2 = mbcset->nmbchars;
#line 3173
      (mbcset->nmbchars) ++;
#line 3173
      *(mbcset->mbchars + __cil_tmp___2) = start_elem.opr.wch;
#line 3174
      break;
      case 2: 
#line 3177
      *err = build_equiv_class(sbcset, mbcset, & equiv_class_alloc, (unsigned char const   *)start_elem.opr.name);
#line 3182
      if ((int )*err != 0) {
#line 3183
        goto parse_bracket_exp_free_return;
      }
#line 3184
      break;
      case 3: 
#line 3186
      *err = build_collating_symbol(sbcset, mbcset, & coll_sym_alloc, (unsigned char const   *)start_elem.opr.name);
#line 3191
      if ((int )*err != 0) {
#line 3192
        goto parse_bracket_exp_free_return;
      }
#line 3193
      break;
      case 4: 
#line 3195
      *err = build_charclass(regexp->trans, sbcset, mbcset, & char_class_alloc, (unsigned char const   *)start_elem.opr.name,
                             syntax);
#line 3200
      if ((int )*err != 0) {
#line 3201
        goto parse_bracket_exp_free_return;
      }
#line 3202
      break;
      default: 
#line 3204
      __libc_failwith((char *)"Assertion failed: 0 at regcomp.c:3204");
#line 3205
      break;
      }
    }
#line 3208
    if ((unsigned int )token->type == 2U) {
#line 3210
      *err = (enum __anonenum_reg_errcode_t_7 )7;
#line 3211
      goto parse_bracket_exp_free_return;
    }
#line 3213
    if ((unsigned int )token->type == 21U) {
#line 3214
      break;
    }
  }
#line 3217
  regexp->cur_idx += (unsigned int )token_len;
#line 3220
  if (non_match) {
#line 3221
    bitset_not(sbcset);
  }
#line 3225
  if (dfa->mb_cur_max > 1) {
#line 3226
    bitset_mask(sbcset, dfa->sb_char);
  }
#line 3228
  if ((((mbcset->nmbchars || mbcset->ncoll_syms) || mbcset->nequiv_classes) || mbcset->nranges) || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes || mbcset->non_match))) {
#line 3235
    dfa->has_mb_node = 1U;
#line 3236
    br_token.type = (enum __anonenum_re_token_type_t_15 )6;
#line 3237
    br_token.opr.mbcset = mbcset;
#line 3238
    mbc_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                 (re_token_t const   *)(& br_token));
#line 3239
    if ((unsigned int )mbc_tree == (unsigned int )((void *)0)) {
#line 3240
      goto parse_bracket_exp_espace;
    }
#line 3241
    sbc_idx = 0;
#line 3241
    while (sbc_idx < 8) {
#line 3242
      if (*(sbcset + sbc_idx)) {
#line 3243
        break;
      }
#line 3241
      sbc_idx ++;
    }
#line 3246
    if (sbc_idx < 8) {
#line 3249
      br_token.type = (enum __anonenum_re_token_type_t_15 )3;
#line 3250
      br_token.opr.sbcset = sbcset;
#line 3251
      work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                    (re_token_t const   *)(& br_token));
#line 3252
      if ((unsigned int )work_tree == (unsigned int )((void *)0)) {
#line 3253
        goto parse_bracket_exp_espace;
      }
#line 3256
      work_tree = create_tree(dfa, work_tree, mbc_tree, (enum __anonenum_re_token_type_t_15 )10);
#line 3257
      if ((unsigned int )work_tree == (unsigned int )((void *)0)) {
#line 3258
        goto parse_bracket_exp_espace;
      }
    } else {
#line 3262
      free((void *)sbcset);
#line 3263
      work_tree = mbc_tree;
    }
  } else {
#line 3270
    free_charset(mbcset);
#line 3273
    br_token.type = (enum __anonenum_re_token_type_t_15 )3;
#line 3274
    br_token.opr.sbcset = sbcset;
#line 3275
    work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)(& br_token));
#line 3276
    if ((unsigned int )work_tree == (unsigned int )((void *)0)) {
#line 3277
      goto parse_bracket_exp_espace;
    }
  }
#line 3279
  return (work_tree);
  parse_bracket_exp_espace: 
#line 3282
  *err = (enum __anonenum_reg_errcode_t_7 )12;
  parse_bracket_exp_free_return: 
#line 3284
  free((void *)sbcset);
#line 3286
  free_charset(mbcset);
#line 3288
  return ((bin_tree_t *)((void *)0));
}
}
#line 3293 "regcomp.c"
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax , _Bool accept_hyphen ) 
{ int cur_char_size ;
  wint_t __cil_tmp ;
  reg_errcode_t __cil_tmp___0 ;
  re_token_t token2 ;

  {
#line 3300
  cur_char_size = re_string_char_size_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3301
  if (cur_char_size > 1) {
#line 3303
    elem->type = (enum __anonenum_bracket_elem_type_24 )1;
#line 3304
    __cil_tmp = re_string_wchar_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3304
    elem->opr.wch = (short )__cil_tmp;
#line 3305
    regexp->cur_idx += (unsigned int )cur_char_size;
#line 3306
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
#line 3309
  regexp->cur_idx += (unsigned int )token_len;
#line 3310
  if (((unsigned int )token->type == 26U || (unsigned int )token->type == 30U) || (unsigned int )token->type == 28U) {
#line 3312
    __cil_tmp___0 = parse_bracket_symbol(elem, regexp, token);
#line 3312
    return (__cil_tmp___0);
  }
#line 3313
  if ((unsigned int )token->type == 22U && ! accept_hyphen) {
#line 3318
    peek_token_bracket(& token2, regexp, syntax);
#line 3319
    if ((unsigned int )token2.type != 21U) {
#line 3322
      return ((enum __anonenum_reg_errcode_t_7 )11);
    }
  }
#line 3324
  elem->type = (enum __anonenum_bracket_elem_type_24 )0;
#line 3325
  elem->opr.ch = token->opr.c;
#line 3326
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3333 "regcomp.c"
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) 
{ unsigned char ch ;
  unsigned char delim ;
  int i ;
  Idx __cil_tmp ;

  {
#line 3337
  delim = token->opr.c;
#line 3338
  i = 0;
#line 3339
  if (regexp->stop <= regexp->cur_idx) {
#line 3340
    return ((enum __anonenum_reg_errcode_t_7 )7);
  }
#line 3341
  while (1) {
#line 3343
    if (i >= 32) {
#line 3344
      return ((enum __anonenum_reg_errcode_t_7 )7);
    }
#line 3345
    if ((unsigned int )token->type == 30U) {
#line 3346
      ch = re_string_fetch_byte_case(regexp);
    } else {
#line 3348
      __cil_tmp = regexp->cur_idx;
#line 3348
      (regexp->cur_idx) ++;
#line 3348
      ch = *(regexp->mbs + __cil_tmp);
    }
#line 3349
    if (regexp->stop <= regexp->cur_idx) {
#line 3350
      return ((enum __anonenum_reg_errcode_t_7 )7);
    }
#line 3351
    if ((int )ch == (int )delim && (int )*(regexp->mbs + regexp->cur_idx) == 93) {
#line 3352
      break;
    }
#line 3353
    *(elem->opr.name + i) = ch;
#line 3341
    i ++;
  }
#line 3355
  (regexp->cur_idx) ++;
#line 3356
  *(elem->opr.name + i) = (unsigned char )'\000';
#line 3357
  switch ((int )token->type) {
  case 26: 
#line 3360
  elem->type = (enum __anonenum_bracket_elem_type_24 )3;
#line 3361
  break;
  case 28: 
#line 3363
  elem->type = (enum __anonenum_bracket_elem_type_24 )2;
#line 3364
  break;
  case 30: 
#line 3366
  elem->type = (enum __anonenum_bracket_elem_type_24 )4;
#line 3367
  break;
  default: 
#line 3369
  break;
  }
#line 3371
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3380 "regcomp.c"
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                       Idx *equiv_class_alloc , unsigned char const   *name ) 
{ size_t __cil_tmp ;

  {
#line 3459
  __cil_tmp = strlen((char const   *)name);
#line 3459
  if (__cil_tmp != 1U) {
#line 3460
    return ((enum __anonenum_reg_errcode_t_7 )3);
  }
#line 3461
  bitset_set(sbcset, (unsigned int )*name);
#line 3463
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3472 "regcomp.c"
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *char_class_alloc ,
                                     unsigned char const   *class_name , reg_syntax_t syntax ) 
{ int i ;
  char const   *name ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  Idx new_char_class_alloc ;
  wctype_t *new_char_classes ;
  void *__cil_tmp___1 ;
  Idx __cil_tmp___2 ;
  int __x ;
  int __x___0 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;

  {
#line 3483
  name = (char const   *)class_name;
#line 3487
  if (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3487
    __cil_tmp = strcmp(name, "upper");
#line 3487
    if (__cil_tmp == 0) {
#line 3489
      name = "alpha";
    } else {
#line 3487
      __cil_tmp___0 = strcmp(name, "lower");
#line 3487
      if (__cil_tmp___0 == 0) {
#line 3489
        name = "alpha";
      }
    }
  }
#line 3493
  if (*char_class_alloc == mbcset->nchar_classes) {
#line 3497
    new_char_class_alloc = 2U * mbcset->nchar_classes + 1U;
#line 3499
    __cil_tmp___1 = rpl_realloc((void *)mbcset->char_classes, new_char_class_alloc * sizeof(wctype_t ));
#line 3499
    new_char_classes = (wctype_t *)__cil_tmp___1;
#line 3501
    if ((unsigned int )new_char_classes == (unsigned int )((void *)0)) {
#line 3502
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 3503
    mbcset->char_classes = new_char_classes;
#line 3504
    *char_class_alloc = new_char_class_alloc;
  }
#line 3506
  __cil_tmp___2 = mbcset->nchar_classes;
#line 3506
  (mbcset->nchar_classes) ++;
#line 3506
  *(mbcset->char_classes + __cil_tmp___2) = wctype(name);
#line 3525
  __cil_tmp___14 = strcmp(name, "alnum");
#line 3525
  if (__cil_tmp___14 == 0) {
#line 3526
    while (1) {
#line 3526
      if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3526
        i = 0;
#line 3526
        while (i < 256) {
#line 3526
          if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 7) {
#line 3526
            bitset_set(sbcset, (unsigned int )*(trans + i));
          }
#line 3526
          i ++;
        }
      } else {
#line 3526
        i = 0;
#line 3526
        while (i < 256) {
#line 3526
          if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 7) {
#line 3526
            bitset_set(sbcset, (unsigned int )i);
          }
#line 3526
          i ++;
        }
      }
#line 3526
      break;
    }
  } else {
#line 3527
    __cil_tmp___13 = strcmp(name, "cntrl");
#line 3527
    if (__cil_tmp___13 == 0) {
#line 3528
      while (1) {
#line 3528
        if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3528
          i = 0;
#line 3528
          while (i < 256) {
#line 3528
            if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 32) {
#line 3528
              bitset_set(sbcset, (unsigned int )*(trans + i));
            }
#line 3528
            i ++;
          }
        } else {
#line 3528
          i = 0;
#line 3528
          while (i < 256) {
#line 3528
            if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 32) {
#line 3528
              bitset_set(sbcset, (unsigned int )i);
            }
#line 3528
            i ++;
          }
        }
#line 3528
        break;
      }
    } else {
#line 3529
      __cil_tmp___12 = strcmp(name, "lower");
#line 3529
      if (__cil_tmp___12 == 0) {
#line 3530
        while (1) {
#line 3530
          if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3530
            i = 0;
#line 3530
            while (i < 256) {
#line 3530
              if (((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 3) == 2) {
#line 3530
                bitset_set(sbcset, (unsigned int )*(trans + i));
              }
#line 3530
              i ++;
            }
          } else {
#line 3530
            i = 0;
#line 3530
            while (i < 256) {
#line 3530
              if (((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 3) == 2) {
#line 3530
                bitset_set(sbcset, (unsigned int )i);
              }
#line 3530
              i ++;
            }
          }
#line 3530
          break;
        }
      } else {
#line 3531
        __cil_tmp___11 = strcmp(name, "space");
#line 3531
        if (__cil_tmp___11 == 0) {
#line 3532
          while (1) {
#line 3532
            if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3532
              i = 0;
#line 3532
              while (i < 256) {
#line 3532
                if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 8) {
#line 3532
                  bitset_set(sbcset, (unsigned int )*(trans + i));
                }
#line 3532
                i ++;
              }
            } else {
#line 3532
              i = 0;
#line 3532
              while (i < 256) {
#line 3532
                if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 8) {
#line 3532
                  bitset_set(sbcset, (unsigned int )i);
                }
#line 3532
                i ++;
              }
            }
#line 3532
            break;
          }
        } else {
#line 3533
          __cil_tmp___10 = strcmp(name, "alpha");
#line 3533
          if (__cil_tmp___10 == 0) {
#line 3534
            while (1) {
#line 3534
              if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3534
                i = 0;
#line 3534
                while (i < 256) {
#line 3534
                  if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 3) {
#line 3534
                    bitset_set(sbcset, (unsigned int )*(trans + i));
                  }
#line 3534
                  i ++;
                }
              } else {
#line 3534
                i = 0;
#line 3534
                while (i < 256) {
#line 3534
                  if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 3) {
#line 3534
                    bitset_set(sbcset, (unsigned int )i);
                  }
#line 3534
                  i ++;
                }
              }
#line 3534
              break;
            }
          } else {
#line 3535
            __cil_tmp___9 = strcmp(name, "digit");
#line 3535
            if (__cil_tmp___9 == 0) {
#line 3536
              while (1) {
#line 3536
                if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3536
                  i = 0;
#line 3536
                  while (i < 256) {
#line 3536
                    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 4) {
#line 3536
                      bitset_set(sbcset, (unsigned int )*(trans + i));
                    }
#line 3536
                    i ++;
                  }
                } else {
#line 3536
                  i = 0;
#line 3536
                  while (i < 256) {
#line 3536
                    if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 4) {
#line 3536
                      bitset_set(sbcset, (unsigned int )i);
                    }
#line 3536
                    i ++;
                  }
                }
#line 3536
                break;
              }
            } else {
#line 3537
              __cil_tmp___8 = strcmp(name, "print");
#line 3537
              if (__cil_tmp___8 == 0) {
#line 3538
                while (1) {
#line 3538
                  if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3538
                    i = 0;
#line 3538
                    while (i < 256) {
#line 3538
                      if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 151) {
#line 3538
                        bitset_set(sbcset, (unsigned int )*(trans + i));
                      }
#line 3538
                      i ++;
                    }
                  } else {
#line 3538
                    i = 0;
#line 3538
                    while (i < 256) {
#line 3538
                      if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 151) {
#line 3538
                        bitset_set(sbcset, (unsigned int )i);
                      }
#line 3538
                      i ++;
                    }
                  }
#line 3538
                  break;
                }
              } else {
#line 3539
                __cil_tmp___7 = strcmp(name, "upper");
#line 3539
                if (__cil_tmp___7 == 0) {
#line 3540
                  while (1) {
#line 3540
                    if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3540
                      i = 0;
#line 3540
                      while (i < 256) {
#line 3540
                        if (((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 3) == 1) {
#line 3540
                          bitset_set(sbcset, (unsigned int )*(trans + i));
                        }
#line 3540
                        i ++;
                      }
                    } else {
#line 3540
                      i = 0;
#line 3540
                      while (i < 256) {
#line 3540
                        if (((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 3) == 1) {
#line 3540
                          bitset_set(sbcset, (unsigned int )i);
                        }
#line 3540
                        i ++;
                      }
                    }
#line 3540
                    break;
                  }
                } else {
#line 3541
                  __cil_tmp___6 = strcmp(name, "blank");
#line 3541
                  if (__cil_tmp___6 == 0) {
#line 3542
                    while (1) {
#line 3542
                      if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3542
                        i = 0;
#line 3542
                        while (i < 256) {
#line 3542
                          __x = i;
#line 3542
                          if ((int const   )*((__ctype_ptr__ + sizeof(*("" + __x))) + __x) & 128 || __x == 9) {
#line 3542
                            bitset_set(sbcset, (unsigned int )*(trans + i));
                          }
#line 3542
                          i ++;
                        }
                      } else {
#line 3542
                        i = 0;
#line 3542
                        while (i < 256) {
#line 3542
                          __x___0 = i;
#line 3542
                          if ((int const   )*((__ctype_ptr__ + sizeof(*("" + __x___0))) + __x___0) & 128 || __x___0 == 9) {
#line 3542
                            bitset_set(sbcset, (unsigned int )i);
                          }
#line 3542
                          i ++;
                        }
                      }
#line 3542
                      break;
                    }
                  } else {
#line 3543
                    __cil_tmp___5 = strcmp(name, "graph");
#line 3543
                    if (__cil_tmp___5 == 0) {
#line 3544
                      while (1) {
#line 3544
                        if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3544
                          i = 0;
#line 3544
                          while (i < 256) {
#line 3544
                            if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 23) {
#line 3544
                              bitset_set(sbcset, (unsigned int )*(trans + i));
                            }
#line 3544
                            i ++;
                          }
                        } else {
#line 3544
                          i = 0;
#line 3544
                          while (i < 256) {
#line 3544
                            if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 23) {
#line 3544
                              bitset_set(sbcset, (unsigned int )i);
                            }
#line 3544
                            i ++;
                          }
                        }
#line 3544
                        break;
                      }
                    } else {
#line 3545
                      __cil_tmp___4 = strcmp(name, "punct");
#line 3545
                      if (__cil_tmp___4 == 0) {
#line 3546
                        while (1) {
#line 3546
                          if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3546
                            i = 0;
#line 3546
                            while (i < 256) {
#line 3546
                              if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 16) {
#line 3546
                                bitset_set(sbcset, (unsigned int )*(trans + i));
                              }
#line 3546
                              i ++;
                            }
                          } else {
#line 3546
                            i = 0;
#line 3546
                            while (i < 256) {
#line 3546
                              if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 16) {
#line 3546
                                bitset_set(sbcset, (unsigned int )i);
                              }
#line 3546
                              i ++;
                            }
                          }
#line 3546
                          break;
                        }
                      } else {
#line 3547
                        __cil_tmp___3 = strcmp(name, "xdigit");
#line 3547
                        if (__cil_tmp___3 == 0) {
#line 3548
                          while (1) {
#line 3548
                            if ((unsigned int )trans != (unsigned int )((void *)0)) {
#line 3548
                              i = 0;
#line 3548
                              while (i < 256) {
#line 3548
                                if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 68) {
#line 3548
                                  bitset_set(sbcset, (unsigned int )*(trans + i));
                                }
#line 3548
                                i ++;
                              }
                            } else {
#line 3548
                              i = 0;
#line 3548
                              while (i < 256) {
#line 3548
                                if ((int const   )*((__ctype_ptr__ + sizeof(*("" + i))) + i) & 68) {
#line 3548
                                  bitset_set(sbcset, (unsigned int )i);
                                }
#line 3548
                                i ++;
                              }
                            }
#line 3548
                            break;
                          }
                        } else {
#line 3550
                          return ((enum __anonenum_reg_errcode_t_7 )4);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3552
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3555 "regcomp.c"
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , _Bool non_match ,
                                      reg_errcode_t *err ) 
{ re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx alloc ;
  reg_errcode_t ret ;
  re_token_t br_token ;
  bin_tree_t *tree ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  bin_tree_t *mbc_tree ;

  {
#line 3564
  alloc = 0U;
#line 3570
  __cil_tmp = rpl_calloc(sizeof(bitset_t ), 1U);
#line 3570
  sbcset = (bitset_word_t *)__cil_tmp;
#line 3572
  __cil_tmp___0 = rpl_calloc(sizeof(re_charset_t ), 1U);
#line 3572
  mbcset = (re_charset_t *)__cil_tmp___0;
#line 3576
  if ((unsigned int )sbcset == (unsigned int )((void *)0) || (unsigned int )mbcset == (unsigned int )((void *)0)) {
#line 3581
    *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 3582
    return ((bin_tree_t *)((void *)0));
  }
#line 3585
  if (non_match) {
#line 3588
    mbcset->non_match = 1U;
  }
#line 3593
  ret = build_charclass(trans, sbcset, mbcset, & alloc, class_name, 0UL);
#line 3599
  if ((int )ret != 0) {
#line 3601
    free((void *)sbcset);
#line 3603
    free_charset(mbcset);
#line 3605
    *err = ret;
#line 3606
    return ((bin_tree_t *)((void *)0));
  }
#line 3609
  while (*extra) {
#line 3610
    bitset_set(sbcset, (unsigned int )*extra);
#line 3609
    extra ++;
  }
#line 3613
  if (non_match) {
#line 3614
    bitset_not(sbcset);
  }
#line 3618
  if (dfa->mb_cur_max > 1) {
#line 3619
    bitset_mask(sbcset, dfa->sb_char);
  }
#line 3623
  br_token.type = (enum __anonenum_re_token_type_t_15 )3;
#line 3624
  br_token.opr.sbcset = sbcset;
#line 3625
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)(& br_token));
#line 3626
  if ((unsigned int )tree == (unsigned int )((void *)0)) {
#line 3627
    goto build_word_op_espace;
  }
#line 3630
  if (dfa->mb_cur_max > 1) {
#line 3634
    br_token.type = (enum __anonenum_re_token_type_t_15 )6;
#line 3635
    br_token.opr.mbcset = mbcset;
#line 3636
    dfa->has_mb_node = 1U;
#line 3637
    mbc_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                 (re_token_t const   *)(& br_token));
#line 3638
    if ((unsigned int )mbc_tree == (unsigned int )((void *)0)) {
#line 3639
      goto build_word_op_espace;
    }
#line 3641
    tree = create_tree(dfa, tree, mbc_tree, (enum __anonenum_re_token_type_t_15 )10);
#line 3642
    if ((unsigned int )mbc_tree != (unsigned int )((void *)0)) {
#line 3643
      return (tree);
    }
  } else {
#line 3647
    free_charset(mbcset);
#line 3648
    return (tree);
  }
  build_word_op_espace: 
#line 3655
  free((void *)sbcset);
#line 3657
  free_charset(mbcset);
#line 3659
  *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 3660
  return ((bin_tree_t *)((void *)0));
}
}
#line 3668 "regcomp.c"
static Idx fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) 
{ Idx num ;
  unsigned char c ;

  {
#line 3671
  num = 4294967295U;
#line 3673
  while (1) {
#line 3675
    fetch_token(token, input, syntax);
#line 3676
    c = token->opr.c;
#line 3677
    if ((unsigned int )token->type == 2U) {
#line 3678
      return (4294967294U);
    }
#line 3679
    if ((unsigned int )token->type == 24U || (int )c == 44) {
#line 3680
      break;
    }
#line 3681
    num = (((unsigned int )token->type != 1U || (int )c < 48) || 57 < (int )c) || num == 4294967294U ? 4294967294U : (num == 4294967295U ? (unsigned int )((int )c - 48) : (num * 10U + (unsigned int )c) - 48U);
#line 3685
    num = num > 32767U ? 4294967294U : num;
  }
#line 3687
  return (num);
}
}
#line 3691 "regcomp.c"
static void free_charset(re_charset_t *cset ) 
{ 

  {
#line 3694
  free((void *)cset->mbchars);
#line 3701
  free((void *)cset->char_classes);
#line 3702
  free((void *)cset);
#line 3703
  return;
}
}
#line 3710 "regcomp.c"
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) 
{ re_token_t t ;
  bin_tree_t *__cil_tmp ;

  {
#line 3715
  t.type = type;
#line 3716
  __cil_tmp = create_token_tree(dfa, left, right, (re_token_t const   *)(& t));
#line 3716
  return (__cil_tmp);
}
}
#line 3719 "regcomp.c"
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) 
{ bin_tree_t *tree ;
  bin_tree_storage_t *storage ;
  void *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 3724
  if ((unsigned int )dfa->str_tree_storage_idx == (1024U - sizeof(void *)) / sizeof(bin_tree_t )) {
#line 3726
    __cil_tmp = rpl_malloc(sizeof(bin_tree_storage_t ));
#line 3726
    storage = (bin_tree_storage_t *)__cil_tmp;
#line 3728
    if ((unsigned int )storage == (unsigned int )((void *)0)) {
#line 3729
      return ((bin_tree_t *)((void *)0));
    }
#line 3730
    storage->next = dfa->str_tree_storage;
#line 3731
    dfa->str_tree_storage = storage;
#line 3732
    dfa->str_tree_storage_idx = 0;
  }
#line 3734
  __cil_tmp___0 = dfa->str_tree_storage_idx;
#line 3734
  (dfa->str_tree_storage_idx) ++;
#line 3734
  tree = & (dfa->str_tree_storage)->data[__cil_tmp___0];
#line 3736
  tree->parent = (struct bin_tree_t *)((void *)0);
#line 3737
  tree->left = left;
#line 3738
  tree->right = right;
#line 3739
  tree->token = (struct __anonstruct_re_token_t_17 )*token;
#line 3740
  tree->token.duplicated = 0U;
#line 3741
  tree->token.opt_subexp = 0U;
#line 3742
  tree->first = (struct bin_tree_t *)((void *)0);
#line 3743
  tree->next = (struct bin_tree_t *)((void *)0);
#line 3744
  tree->node_idx = 4294967295U;
#line 3746
  if ((unsigned int )left != (unsigned int )((void *)0)) {
#line 3747
    left->parent = tree;
  }
#line 3748
  if ((unsigned int )right != (unsigned int )((void *)0)) {
#line 3749
    right->parent = tree;
  }
#line 3750
  return (tree);
}
}
#line 3756 "regcomp.c"
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) 
{ Idx idx ;

  {
#line 3759
  idx = (unsigned int )((long )extra);
#line 3760
  if ((unsigned int )node->token.type == 17U && node->token.opr.idx == idx) {
#line 3761
    node->token.opt_subexp = 1U;
  }
#line 3763
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3768 "regcomp.c"
static void free_token(re_token_t *node ) 
{ 

  {
#line 3772
  if ((unsigned int )node->type == 6U && node->duplicated == 0U) {
#line 3773
    free_charset(node->opr.mbcset);
  } else
#line 3776
  if ((unsigned int )node->type == 3U && node->duplicated == 0U) {
#line 3777
    free((void *)node->opr.sbcset);
  }
#line 3778
  return;
}
}
#line 3783 "regcomp.c"
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) 
{ 

  {
#line 3786
  free_token(& node->token);
#line 3787
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3796 "regcomp.c"
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) 
{ bin_tree_t const   *node ;
  bin_tree_t *dup_root ;
  bin_tree_t **p_new ;
  bin_tree_t *dup_node ;
  bin_tree_t const   *prev ;

  {
#line 3801
  p_new = & dup_root;
#line 3801
  dup_node = (bin_tree_t *)root->parent;
#line 3803
  node = root;
#line 3803
  while (1) {
#line 3806
    *p_new = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               & node->token);
#line 3807
    if ((unsigned int )*p_new == (unsigned int )((void *)0)) {
#line 3808
      return ((bin_tree_t *)((void *)0));
    }
#line 3809
    (*p_new)->parent = dup_node;
#line 3810
    (*p_new)->token.duplicated = 1U;
#line 3811
    dup_node = *p_new;
#line 3814
    if (node->left) {
#line 3816
      node = (bin_tree_t const   *)node->left;
#line 3817
      p_new = & dup_node->left;
    } else {
#line 3821
      prev = (bin_tree_t const   *)((void *)0);
#line 3822
      while ((unsigned int )node->right == (unsigned int )prev || (unsigned int )node->right == (unsigned int )((void *)0)) {
#line 3824
        prev = node;
#line 3825
        node = (bin_tree_t const   *)node->parent;
#line 3826
        dup_node = dup_node->parent;
#line 3827
        if (! node) {
#line 3828
          return (dup_root);
        }
      }
#line 3830
      node = (bin_tree_t const   *)node->right;
#line 3831
      p_new = & dup_node->right;
    }
  }
}
}
#line 23 "regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , Idx n ) ;
#line 25
static void match_ctx_clean(re_match_context_t *mctx ) ;
#line 26
static void match_ctx_free(re_match_context_t *mctx ) ;
#line 27
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , Idx node , Idx str_idx ,
                                         Idx from , Idx to ) ;
#line 30
static Idx search_cur_bkref_entry(re_match_context_t const   *mctx , Idx str_idx ) ;
#line 32
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , Idx node , Idx str_idx ) ;
#line 34
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , Idx node ,
                                                  Idx str_idx ) ;
#line 37
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          Idx last_node , Idx last_str_idx ) ;
#line 41
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        Idx length , Idx start , Idx last_start ,
                                        Idx stop , size_t nmatch , regmatch_t *pmatch ,
                                        int eflags ) ;
#line 46
static regoff_t re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                                 Idx length1 , char const   *string2 , Idx length2 ,
                                 Idx start , regoff_t range , struct re_registers *regs ,
                                 Idx stop , _Bool ret_len ) ;
#line 52
static regoff_t re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                               Idx length , Idx start , regoff_t range , Idx stop ,
                               struct re_registers *regs , _Bool ret_len ) ;
#line 57
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 Idx nregs , int regs_allocated ) ;
#line 60
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) ;
#line 62
static Idx check_matching(re_match_context_t *mctx , _Bool fl_longest_match , Idx *p_match_first ) ;
#line 64
static Idx check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state ,
                                    Idx idx ) ;
#line 67
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        Idx cur_node , Idx cur_idx , Idx nmatch ) ;
#line 70
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , Idx str_idx , Idx dest_node ,
                                     Idx nregs , regmatch_t *regs , re_node_set *eps_via_nodes ) ;
#line 75
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , _Bool fl_backtrack ) ;
#line 79
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) ;
#line 83
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               Idx node_idx , Idx str_idx , Idx max_str_idx ) ;
#line 88
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) ;
#line 91
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         Idx str_idx , re_node_set *cur_dest ) ;
#line 95
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *dest_nodes ) ;
#line 100
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) ;
#line 104
static _Bool check_dst_limits(re_match_context_t const   *mctx , re_node_set const   *limits ,
                              Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) ;
#line 108
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       Idx subexp_idx , Idx from_node , Idx bkref_idx ) ;
#line 112
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , Idx limit ,
                                     Idx subexp_idx , Idx from_node , Idx str_idx ,
                                     Idx bkref_idx ) ;
#line 116
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         Idx str_idx ) ;
#line 122
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       Idx str_idx , re_node_set const   *candidates ) ;
#line 126
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , Idx num ) ;
#line 130
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) ;
#line 132
static re_dfastate_t *transit_state(reg_errcode_t *err , re_match_context_t *mctx ,
                                    re_dfastate_t *state ) ;
#line 135
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state___0 ) ;
#line 139
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               Idx str_idx ) ;
#line 149
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) ;
#line 153
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) ;
#line 156
static reg_errcode_t get_subexp(re_match_context_t *mctx , Idx bkref_node , Idx bkref_str_idx ) ;
#line 159
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , Idx bkref_node ,
                                    Idx bkref_str ) ;
#line 164
static Idx find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , Idx subexp_idx ,
                            int type ) ;
#line 166
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   Idx top_node , Idx top_str , Idx last_node , Idx last_str ,
                                   int type ) ;
#line 170
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , Idx str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) ;
#line 175
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              Idx ex_subexp , int type ) ;
#line 179
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                  Idx target , Idx ex_subexp , int type ) ;
#line 183
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        Idx cur_str , Idx subexp_num , int type ) ;
#line 187
static _Bool build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state ) ;
#line 190
static int check_node_accept_bytes(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                   Idx str_idx ) ;
#line 199
static Idx group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) ;
#line 203
static _Bool check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                               Idx idx ) ;
#line 206
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) ;
#line 225 "regexec.c"
int rpl_regexec(regex_t const   *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
                int eflags ) 
{ reg_errcode_t err ;
  Idx start ;
  Idx length ;

  {
#line 239
  if (eflags & ~ ((1 | (1 << 1)) | (1 << 2))) {
#line 240
    return (2);
  }
#line 242
  if (eflags & (1 << 2)) {
#line 244
    start = (unsigned int )(pmatch + 0)->rm_so;
#line 245
    length = (unsigned int )(pmatch + 0)->rm_eo;
  } else {
#line 249
    start = 0U;
#line 250
    length = strlen(string);
  }
#line 253
  while (1) {
#line 253
    break;
  }
#line 254
  if (preg->no_sub) {
#line 255
    err = re_search_internal(preg, string, length, start, length, length, 0U, (regmatch_t *)((void *)0),
                             eflags);
  } else {
#line 258
    err = re_search_internal(preg, string, length, start, length, length, nmatch,
                             pmatch, eflags);
  }
#line 260
  while (1) {
#line 260
    break;
  }
#line 261
  return ((int )err != 0);
}
}
#line 313 "regexec.c"
regoff_t rpl_re_match(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                      __re_idx_t start , struct re_registers *regs ) 
{ regoff_t __cil_tmp ;

  {
#line 320
  __cil_tmp = re_search_stub(bufp, string, length, start, 0, length, regs, (_Bool)1);
#line 320
  return (__cil_tmp);
}
}
#line 326 "regexec.c"
regoff_t rpl_re_search(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                       __re_idx_t start , regoff_t range , struct re_registers *regs ) 
{ regoff_t __cil_tmp ;

  {
#line 334
  __cil_tmp = re_search_stub(bufp, string, length, start, range, length, regs, (_Bool)0);
#line 334
  return (__cil_tmp);
}
}
#line 341 "regexec.c"
regoff_t rpl_re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , __re_idx_t length1 ,
                        char const   *string2 , __re_idx_t length2 , __re_idx_t start ,
                        struct re_registers *regs , __re_idx_t stop ) 
{ regoff_t __cil_tmp ;

  {
#line 348
  __cil_tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, 0,
                               regs, stop, (_Bool)1);
#line 348
  return (__cil_tmp);
}
}
#line 355 "regexec.c"
regoff_t rpl_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                         __re_idx_t length1 , char const   *string2 , __re_idx_t length2 ,
                         __re_idx_t start , regoff_t range , struct re_registers *regs ,
                         __re_idx_t stop ) 
{ regoff_t __cil_tmp ;

  {
#line 363
  __cil_tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, range,
                               regs, stop, (_Bool)0);
#line 363
  return (__cil_tmp);
}
}
#line 370 "regexec.c"
static regoff_t re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                                 Idx length1 , char const   *string2 , Idx length2 ,
                                 Idx start , regoff_t range , struct re_registers *regs ,
                                 Idx stop , _Bool ret_len ) 
{ char const   *str ;
  regoff_t rval ;
  Idx len ;
  char *s ;
  void *__cil_tmp ;

  {
#line 380
  len = length1 + length2;
#line 381
  s = (char *)((void *)0);
#line 383
  if (((length1 < 0U || length2 < 0U) || stop < 0U) || len < length1) {
#line 384
    return (-2);
  }
#line 387
  if (length2 > 0U) {
#line 388
    if (length1 > 0U) {
#line 390
      __cil_tmp = rpl_malloc(len * sizeof(char ));
#line 390
      s = (char *)__cil_tmp;
#line 392
      if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 393
        return (-2);
      }
#line 397
      memcpy((void *)s, (void const   *)string1, length1);
#line 398
      memcpy((void *)(s + length1), (void const   *)string2, length2);
#line 400
      str = (char const   *)s;
    } else {
#line 403
      str = string2;
    }
  } else {
#line 405
    str = string1;
  }
#line 407
  rval = re_search_stub(bufp, str, len, start, range, stop, regs, ret_len);
#line 409
  free((void *)s);
#line 410
  return (rval);
}
}
#line 418 "regexec.c"
static regoff_t re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                               Idx length , Idx start , regoff_t range , Idx stop ,
                               struct re_registers *regs , _Bool ret_len ) 
{ reg_errcode_t result ;
  regmatch_t *pmatch ;
  Idx nregs ;
  regoff_t rval ;
  int eflags ;
  Idx last_start ;
  void *__cil_tmp ;

  {
#line 429
  eflags = 0;
#line 433
  last_start = start + (unsigned int )range;
#line 436
  if (start < 0U || start > length) {
#line 437
    return (-1);
  }
#line 438
  if (length < last_start || (0 <= range && last_start < start)) {
#line 439
    last_start = length;
  } else
#line 440
  if (last_start < 0U || (range < 0 && start <= last_start)) {
#line 441
    last_start = 0U;
  }
#line 443
  while (1) {
#line 443
    break;
  }
#line 445
  eflags |= bufp->not_bol ? 1 : 0;
#line 446
  eflags |= bufp->not_eol ? 1 << 1 : 0;
#line 449
  if ((start < last_start && (unsigned int )bufp->fastmap != (unsigned int )((void *)0)) && ! bufp->fastmap_accurate) {
#line 450
    rpl_re_compile_fastmap(bufp);
  }
#line 452
  if (bufp->no_sub) {
#line 453
    regs = (struct re_registers *)((void *)0);
  }
#line 456
  if ((unsigned int )regs == (unsigned int )((void *)0)) {
#line 457
    nregs = 1U;
  } else
#line 458
  if (bufp->regs_allocated == 2U && regs->num_regs <= bufp->re_nsub) {
#line 461
    nregs = regs->num_regs;
#line 462
    if (nregs < 1U) {
#line 465
      regs = (struct re_registers *)((void *)0);
#line 466
      nregs = 1U;
    }
  } else {
#line 470
    nregs = bufp->re_nsub + 1U;
  }
#line 471
  __cil_tmp = rpl_malloc(nregs * sizeof(regmatch_t ));
#line 471
  pmatch = (regmatch_t *)__cil_tmp;
#line 472
  if ((unsigned int )pmatch == (unsigned int )((void *)0)) {
#line 474
    rval = -2;
#line 475
    goto out;
  }
#line 478
  result = re_search_internal((regex_t const   *)bufp, string, length, start, last_start,
                              stop, nregs, pmatch, eflags);
#line 481
  rval = 0;
#line 484
  if ((int )result != 0) {
#line 485
    rval = -1;
  } else
#line 486
  if ((unsigned int )regs != (unsigned int )((void *)0)) {
#line 489
    bufp->regs_allocated = re_copy_regs(regs, pmatch, nregs, (int )bufp->regs_allocated);
#line 491
    if (bufp->regs_allocated == 0U) {
#line 492
      rval = -2;
    }
  }
#line 495
  if (rval == 0) {
#line 497
    if (ret_len) {
#line 499
      if (((unsigned int )(pmatch + 0)->rm_so == start) == 0) {
#line 499
        __libc_failwith((char *)"Assertion failed: pmatch[0].rm_so == start at regexec.c:499");
      }
#line 500
      rval = (int )((unsigned int )(pmatch + 0)->rm_eo - start);
    } else {
#line 503
      rval = (pmatch + 0)->rm_so;
    }
  }
#line 505
  free((void *)pmatch);
  out: 
#line 507
  while (1) {
#line 507
    break;
  }
#line 508
  return (rval);
}
}
#line 511 "regexec.c"
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 Idx nregs , int regs_allocated ) 
{ int rval ;
  Idx i ;
  Idx need_regs ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  regoff_t *new_start ;
  void *__cil_tmp___1 ;
  regoff_t *new_end ;
  void *__cil_tmp___2 ;
  regoff_t __cil_tmp___3 ;

  {
#line 516
  rval = 1;
#line 518
  need_regs = nregs + 1U;
#line 523
  if (regs_allocated == 0) {
#line 525
    __cil_tmp = rpl_malloc(need_regs * sizeof(regoff_t ));
#line 525
    regs->start = (regoff_t *)__cil_tmp;
#line 526
    if ((unsigned int )regs->start == (unsigned int )((void *)0)) {
#line 527
      return (0U);
    }
#line 528
    __cil_tmp___0 = rpl_malloc(need_regs * sizeof(regoff_t ));
#line 528
    regs->end = (regoff_t *)__cil_tmp___0;
#line 529
    if ((unsigned int )regs->end == (unsigned int )((void *)0)) {
#line 531
      free((void *)regs->start);
#line 532
      return (0U);
    }
#line 534
    regs->num_regs = need_regs;
  } else
#line 536
  if (regs_allocated == 1) {
#line 540
    if (need_regs > regs->num_regs) {
#line 542
      __cil_tmp___1 = rpl_realloc((void *)regs->start, need_regs * sizeof(regoff_t ));
#line 542
      new_start = (regoff_t *)__cil_tmp___1;
#line 544
      if ((unsigned int )new_start == (unsigned int )((void *)0)) {
#line 545
        return (0U);
      }
#line 546
      __cil_tmp___2 = rpl_realloc((void *)regs->end, need_regs * sizeof(regoff_t ));
#line 546
      new_end = (regoff_t *)__cil_tmp___2;
#line 547
      if ((unsigned int )new_end == (unsigned int )((void *)0)) {
#line 549
        free((void *)new_start);
#line 550
        return (0U);
      }
#line 552
      regs->start = new_start;
#line 553
      regs->end = new_end;
#line 554
      regs->num_regs = need_regs;
    }
  } else {
#line 559
    if ((regs_allocated == 2) == 0) {
#line 559
      __libc_failwith((char *)"Assertion failed: regs_allocated == REGS_FIXED at regexec.c:559");
    }
#line 561
    if ((regs->num_regs >= nregs) == 0) {
#line 561
      __libc_failwith((char *)"Assertion failed: regs->num_regs >= nregs at regexec.c:561");
    }
#line 562
    rval = 2;
  }
#line 566
  i = 0U;
#line 566
  while (i < nregs) {
#line 568
    *(regs->start + i) = (pmatch + i)->rm_so;
#line 569
    *(regs->end + i) = (pmatch + i)->rm_eo;
#line 566
    i ++;
  }
#line 571
  while (i < regs->num_regs) {
#line 572
    __cil_tmp___3 = -1;
#line 572
    *(regs->end + i) = __cil_tmp___3;
#line 572
    *(regs->start + i) = __cil_tmp___3;
#line 571
    i ++;
  }
#line 574
  return ((unsigned int )rval);
}
}
#line 590 "regexec.c"
void rpl_re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                          __re_size_t num_regs , regoff_t *starts , regoff_t *ends ) 
{ regoff_t *__cil_tmp ;

  {
#line 597
  if (num_regs) {
#line 599
    bufp->regs_allocated = 1U;
#line 600
    regs->num_regs = num_regs;
#line 601
    regs->start = starts;
#line 602
    regs->end = ends;
  } else {
#line 606
    bufp->regs_allocated = 0U;
#line 607
    regs->num_regs = 0U;
#line 608
    __cil_tmp = (regoff_t *)((void *)0);
#line 608
    regs->end = __cil_tmp;
#line 608
    regs->start = __cil_tmp;
  }
#line 610
  return;
}
}
#line 641 "regexec.c"
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        Idx length , Idx start , Idx last_start ,
                                        Idx stop , size_t nmatch , regmatch_t *pmatch ,
                                        int eflags ) 
{ reg_errcode_t err ;
  re_dfa_t const   *dfa ;
  Idx left_lim ;
  Idx right_lim ;
  int incr ;
  _Bool fl_longest_match ;
  int match_kind ;
  Idx match_first ;
  Idx match_last ;
  Idx extra_nmatch ;
  _Bool sb ;
  int ch ;
  re_match_context_t mctx ;
  char *fastmap ;
  unsigned char *t ;
  void *__cil_tmp ;
  __re_size_t offset ;
  re_dfastate_t *pstate ;
  Idx reg_idx ;
  regoff_t __cil_tmp___0 ;

  {
#line 650
  dfa = (re_dfa_t const   *)preg->buffer;
#line 656
  match_last = 4294967295U;
#line 665
  fastmap = (char *)((((unsigned int )preg->fastmap != (unsigned int )((void *)0) && preg->fastmap_accurate) && start != last_start) && ! preg->can_be_null ? preg->fastmap : (char * const  )((void *)0));
#line 668
  t = (unsigned char *)preg->translate;
#line 671
  memset((void *)(& mctx), '\000', sizeof(re_match_context_t ));
#line 672
  mctx.dfa = dfa;
#line 675
  extra_nmatch = nmatch > (unsigned int )preg->re_nsub ? nmatch - (unsigned int )(preg->re_nsub + 1U) : 0U;
#line 676
  nmatch -= extra_nmatch;
#line 679
  if ((((preg->used == 0U || (unsigned int )dfa->init_state == (unsigned int )((void *)0)) || (unsigned int )dfa->init_state_word == (unsigned int )((void *)0)) || (unsigned int )dfa->init_state_nl == (unsigned int )((void *)0)) || (unsigned int )dfa->init_state_begbuf == (unsigned int )((void *)0)) {
#line 682
    return ((enum __anonenum_reg_errcode_t_7 )1);
  }
#line 692
  if (((dfa->init_state)->nodes.nelem == 0U && (dfa->init_state_word)->nodes.nelem == 0U) && ((dfa->init_state_nl)->nodes.nelem == 0U || ! preg->newline_anchor)) {
#line 697
    if (start != 0U && last_start != 0U) {
#line 698
      return ((enum __anonenum_reg_errcode_t_7 )1);
    }
#line 699
    last_start = 0U;
#line 699
    start = last_start;
  }
#line 703
  fl_longest_match = (_Bool )(nmatch != 0U || dfa->nbackref);
#line 705
  err = re_string_allocate(& mctx.input, string, length, (unsigned int )(dfa->nodes_len + 1U),
                           (unsigned char *)preg->translate, (_Bool )(preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)),
                           dfa);
#line 707
  if ((int )err != 0) {
#line 708
    goto free_return;
  }
#line 709
  mctx.input.stop = stop;
#line 710
  mctx.input.raw_stop = stop;
#line 711
  mctx.input.newline_anchor = (unsigned char )preg->newline_anchor;
#line 713
  err = match_ctx_init(& mctx, eflags, (unsigned int )(dfa->nbackref * 2U));
#line 714
  if ((int )err != 0) {
#line 715
    goto free_return;
  }
#line 721
  if (nmatch > 1U || dfa->has_mb_node) {
#line 724
    if ((((1U << 31) - 1U) * 2U + 1U) / sizeof(re_dfastate_t *) <= mctx.input.bufs_len) {
#line 726
      err = (enum __anonenum_reg_errcode_t_7 )12;
#line 727
      goto free_return;
    }
#line 730
    __cil_tmp = rpl_malloc((mctx.input.bufs_len + 1U) * sizeof(re_dfastate_t *));
#line 730
    mctx.state_log = (re_dfastate_t **)__cil_tmp;
#line 731
    if ((unsigned int )mctx.state_log == (unsigned int )((void *)0)) {
#line 733
      err = (enum __anonenum_reg_errcode_t_7 )12;
#line 734
      goto free_return;
    }
  } else {
#line 738
    mctx.state_log = (re_dfastate_t **)((void *)0);
  }
#line 740
  match_first = start;
#line 741
  mctx.input.tip_context = (unsigned int )(eflags & 1 ? (1 << 1) << 1 : (1 << 1) | ((1 << 1) << 1));
#line 745
  incr = last_start < start ? -1 : 1;
#line 746
  left_lim = last_start < start ? last_start : start;
#line 747
  right_lim = last_start < start ? start : last_start;
#line 748
  sb = (_Bool )(dfa->mb_cur_max == 1);
#line 749
  match_kind = fastmap ? ((sb || ! (preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || t) ? 4 : 0) | (start <= last_start ? 2 : 0)) | ((unsigned int )t != (unsigned int )((void *)0) ? 1 : 0) : 8;
#line 756
  while (1) {
#line 758
    err = (enum __anonenum_reg_errcode_t_7 )1;
#line 759
    if (match_first < left_lim || right_lim < match_first) {
#line 760
      goto free_return;
    }
#line 767
    switch (match_kind) {
    case 8: 
#line 771
    break;
    case 7: 
#line 775
    while (match_first < right_lim && ! *(fastmap + (int )*(t + (int )((unsigned char )*(string + match_first))))) {
#line 777
      match_first ++;
    }
#line 778
    goto forward_match_found_start_or_reached_end;
    case 6: 
#line 782
    while (match_first < right_lim && ! *(fastmap + (int )((unsigned char )*(string + match_first)))) {
#line 784
      match_first ++;
    }
    forward_match_found_start_or_reached_end: 
#line 787
    if (match_first == right_lim) {
#line 789
      ch = match_first >= length ? 0 : (int )((unsigned char )*(string + match_first));
#line 791
      if (! *(fastmap + (t ? (int )*(t + ch) : ch))) {
#line 792
        goto free_return;
      }
    }
#line 794
    break;
    case 4: 
    case 5: 
#line 799
    while (match_first >= left_lim) {
#line 801
      ch = match_first >= length ? 0 : (int )((unsigned char )*(string + match_first));
#line 803
      if (*(fastmap + (t ? (int )*(t + ch) : ch))) {
#line 804
        break;
      }
#line 805
      match_first --;
    }
#line 807
    if (match_first < left_lim) {
#line 808
      goto free_return;
    }
#line 809
    break;
    default: 
#line 815
    while (1) {
#line 819
      offset = match_first - mctx.input.raw_mbs_idx;
#line 820
      if (offset >= mctx.input.valid_raw_len) {
#line 822
        err = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 824
        if ((int )err != 0) {
#line 825
          goto free_return;
        }
#line 827
        offset = match_first - mctx.input.raw_mbs_idx;
      }
#line 831
      ch = match_first >= length ? 0 : (int )*(mctx.input.mbs + offset);
#line 833
      if (*(fastmap + ch)) {
#line 834
        break;
      }
#line 835
      match_first += (unsigned int )incr;
#line 836
      if (match_first < left_lim || match_first > right_lim) {
#line 838
        err = (enum __anonenum_reg_errcode_t_7 )1;
#line 839
        goto free_return;
      }
    }
#line 842
    break;
    }
#line 847
    err = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 848
    if ((int )err != 0) {
#line 849
      goto free_return;
    }
#line 854
    if (! sb && ! (0U == mctx.input.valid_len || *(mctx.input.wcs + 0) != -1)) {
#line 855
      goto __Cont;
    }
#line 860
    mctx.max_mb_elem_len = 0;
#line 860
    mctx.nbkref_ents = (unsigned int )mctx.max_mb_elem_len;
#line 860
    mctx.state_log_top = mctx.nbkref_ents;
#line 861
    match_last = check_matching(& mctx, fl_longest_match, start <= last_start ? & match_first : (Idx *)((void *)0));
#line 863
    if (match_last != 4294967295U) {
#line 865
      if (match_last == 4294967294U) {
#line 867
        err = (enum __anonenum_reg_errcode_t_7 )12;
#line 868
        goto free_return;
      } else {
#line 872
        mctx.match_last = match_last;
#line 873
        if ((! preg->no_sub && nmatch > 1U) || dfa->nbackref) {
#line 875
          pstate = *(mctx.state_log + match_last);
#line 876
          mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                    (re_dfastate_t const   *)pstate,
                                                    match_last);
        }
#line 879
        if (((! preg->no_sub && nmatch > 1U) && dfa->has_plural_match) || dfa->nbackref) {
#line 882
          err = prune_impossible_nodes(& mctx);
#line 883
          if ((int )err == 0) {
#line 884
            break;
          }
#line 885
          if ((int )err != 1) {
#line 886
            goto free_return;
          }
#line 887
          match_last = 4294967295U;
        } else {
#line 890
          break;
        }
      }
    }
#line 894
    match_ctx_clean(& mctx);
    __Cont: 
#line 756
    match_first += (unsigned int )incr;
  }
#line 903
  if (nmatch > 0U) {
#line 908
    reg_idx = 1U;
#line 908
    while (reg_idx < nmatch) {
#line 909
      __cil_tmp___0 = -1;
#line 909
      (pmatch + reg_idx)->rm_eo = __cil_tmp___0;
#line 909
      (pmatch + reg_idx)->rm_so = __cil_tmp___0;
#line 908
      reg_idx ++;
    }
#line 912
    (pmatch + 0)->rm_so = 0;
#line 913
    (pmatch + 0)->rm_eo = (int )mctx.match_last;
#line 918
    if (! preg->no_sub && nmatch > 1U) {
#line 920
      err = set_regs(preg, (re_match_context_t const   *)(& mctx), nmatch, pmatch,
                     (_Bool )(dfa->has_plural_match && dfa->nbackref > 0U));
#line 922
      if ((int )err != 0) {
#line 923
        goto free_return;
      }
    }
#line 929
    reg_idx = 0U;
#line 929
    while (reg_idx < nmatch) {
#line 930
      if ((pmatch + reg_idx)->rm_so != -1) {
#line 933
        if ((int )mctx.input.offsets_needed != 0) {
#line 935
          (pmatch + reg_idx)->rm_so = (int )((unsigned int )(pmatch + reg_idx)->rm_so == mctx.input.valid_len ? mctx.input.valid_raw_len : *(mctx.input.offsets + (pmatch + reg_idx)->rm_so));
#line 939
          (pmatch + reg_idx)->rm_eo = (int )((unsigned int )(pmatch + reg_idx)->rm_eo == mctx.input.valid_len ? mctx.input.valid_raw_len : *(mctx.input.offsets + (pmatch + reg_idx)->rm_eo));
        }
#line 947
        (pmatch + reg_idx)->rm_so = (int )((unsigned int )(pmatch + reg_idx)->rm_so + match_first);
#line 948
        (pmatch + reg_idx)->rm_eo = (int )((unsigned int )(pmatch + reg_idx)->rm_eo + match_first);
      }
#line 929
      reg_idx ++;
    }
#line 950
    reg_idx = 0U;
#line 950
    while (reg_idx < extra_nmatch) {
#line 952
      (pmatch + (nmatch + reg_idx))->rm_so = -1;
#line 953
      (pmatch + (nmatch + reg_idx))->rm_eo = -1;
#line 950
      reg_idx ++;
    }
#line 956
    if (dfa->subexp_map) {
#line 957
      reg_idx = 0U;
#line 957
      while (reg_idx + 1U < nmatch) {
#line 958
        if (*(dfa->subexp_map + reg_idx) != reg_idx) {
#line 960
          (pmatch + (reg_idx + 1U))->rm_so = (pmatch + (*(dfa->subexp_map + reg_idx) + 1U))->rm_so;
#line 962
          (pmatch + (reg_idx + 1U))->rm_eo = (pmatch + (*(dfa->subexp_map + reg_idx) + 1U))->rm_eo;
        }
#line 957
        reg_idx ++;
      }
    }
  }
  free_return: 
#line 968
  free((void *)mctx.state_log);
#line 969
  if (dfa->nbackref) {
#line 970
    match_ctx_free(& mctx);
  }
#line 971
  re_string_destruct(& mctx.input);
#line 972
  return (err);
}
}
#line 975 "regexec.c"
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) 
{ re_dfa_t const   *dfa ;
  Idx halt_node ;
  Idx match_last ;
  reg_errcode_t ret ;
  re_dfastate_t **sifted_states ;
  re_dfastate_t **lim_states ;
  re_sift_context_t sctx ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 979
  dfa = mctx->dfa;
#line 983
  lim_states = (re_dfastate_t **)((void *)0);
#line 988
  match_last = mctx->match_last;
#line 989
  halt_node = mctx->last_node;
#line 992
  if ((((1U << 31) - 1U) * 2U + 1U) / sizeof(re_dfastate_t *) <= match_last) {
#line 993
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 995
  __cil_tmp = rpl_malloc((match_last + 1U) * sizeof(re_dfastate_t *));
#line 995
  sifted_states = (re_dfastate_t **)__cil_tmp;
#line 996
  if ((unsigned int )sifted_states == (unsigned int )((void *)0)) {
#line 998
    ret = (enum __anonenum_reg_errcode_t_7 )12;
#line 999
    goto free_return;
  }
#line 1001
  if (dfa->nbackref) {
#line 1003
    __cil_tmp___0 = rpl_malloc((match_last + 1U) * sizeof(re_dfastate_t *));
#line 1003
    lim_states = (re_dfastate_t **)__cil_tmp___0;
#line 1004
    if ((unsigned int )lim_states == (unsigned int )((void *)0)) {
#line 1006
      ret = (enum __anonenum_reg_errcode_t_7 )12;
#line 1007
      goto free_return;
    }
#line 1009
    while (1) {
#line 1011
      memset((void *)lim_states, '\000', sizeof(re_dfastate_t *) * (match_last + 1U));
#line 1013
      sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1015
      ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 1016
      free((void *)sctx.limits.elems);
#line 1017
      if ((int )ret != 0) {
#line 1018
        goto free_return;
      }
#line 1019
      if ((unsigned int )*(sifted_states + 0) != (unsigned int )((void *)0) || (unsigned int )*(lim_states + 0) != (unsigned int )((void *)0)) {
#line 1020
        break;
      }
#line 1021
      while (1) {
#line 1023
        match_last --;
#line 1024
        if (! (match_last < 4294967294U)) {
#line 1026
          ret = (enum __anonenum_reg_errcode_t_7 )1;
#line 1027
          goto free_return;
        }
#line 1021
        if (! ((unsigned int )*(mctx->state_log + match_last) == (unsigned int )((void *)0) || ! (*(mctx->state_log + match_last))->halt)) {
#line 1021
          break;
        }
      }
#line 1031
      halt_node = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)*(mctx->state_log + match_last),
                                           match_last);
    }
#line 1035
    ret = merge_state_array(dfa, sifted_states, lim_states, match_last + 1U);
#line 1037
    free((void *)lim_states);
#line 1038
    lim_states = (re_dfastate_t **)((void *)0);
#line 1039
    if ((int )ret != 0) {
#line 1040
      goto free_return;
    }
  } else {
#line 1044
    sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1045
    ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 1046
    free((void *)sctx.limits.elems);
#line 1047
    if ((int )ret != 0) {
#line 1048
      goto free_return;
    }
  }
#line 1050
  free((void *)mctx->state_log);
#line 1051
  mctx->state_log = sifted_states;
#line 1052
  sifted_states = (re_dfastate_t **)((void *)0);
#line 1053
  mctx->last_node = halt_node;
#line 1054
  mctx->match_last = match_last;
#line 1055
  ret = (enum __anonenum_reg_errcode_t_7 )0;
  free_return: 
#line 1057
  free((void *)sifted_states);
#line 1058
  free((void *)lim_states);
#line 1059
  return (ret);
}
}
#line 1066 "regexec.c"
__inline static re_dfastate_t *acquire_init_state_context(reg_errcode_t *err , re_match_context_t const   *mctx ,
                                                          Idx idx ) 
{ re_dfa_t const   *dfa ;
  unsigned int context ;
  re_dfastate_t *__cil_tmp ;

  {
#line 1071
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1072
  if ((dfa->init_state)->has_constraint) {
#line 1075
    context = re_string_context_at(& mctx->input, idx - 1U, (int )mctx->eflags);
#line 1076
    if (context & 1U) {
#line 1077
      return ((re_dfastate_t *)dfa->init_state_word);
    } else
#line 1078
    if (context == 0U) {
#line 1079
      return ((re_dfastate_t *)dfa->init_state);
    } else
#line 1080
    if (context & (unsigned int )((1 << 1) << 1) && context & (unsigned int )(1 << 1)) {
#line 1081
      return ((re_dfastate_t *)dfa->init_state_begbuf);
    } else
#line 1082
    if (context & (unsigned int )(1 << 1)) {
#line 1083
      return ((re_dfastate_t *)dfa->init_state_nl);
    } else
#line 1084
    if (context & (unsigned int )((1 << 1) << 1)) {
#line 1087
      __cil_tmp = re_acquire_state_context(err, dfa, (re_node_set const   *)(dfa->init_state)->entrance_nodes,
                                           context);
#line 1087
      return (__cil_tmp);
    } else {
#line 1093
      return ((re_dfastate_t *)dfa->init_state);
    }
  } else {
#line 1096
    return ((re_dfastate_t *)dfa->init_state);
  }
}
}
#line 1108 "regexec.c"
static Idx check_matching(re_match_context_t *mctx , _Bool fl_longest_match , Idx *p_match_first ) 
{ re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx match ;
  Idx match_last ;
  Idx cur_str_idx ;
  re_dfastate_t *cur_state ;
  _Bool at_init_state ;
  Idx next_start_idx ;
  Idx __cil_tmp ;
  re_dfastate_t *old_state ;
  Idx next_char_idx ;
  Idx __cil_tmp___0 ;

  {
#line 1113
  dfa = mctx->dfa;
#line 1115
  match = 0U;
#line 1116
  match_last = 4294967295U;
#line 1117
  cur_str_idx = mctx->input.cur_idx;
#line 1119
  at_init_state = (_Bool )((unsigned int )p_match_first != (unsigned int )((void *)0));
#line 1120
  next_start_idx = cur_str_idx;
#line 1122
  err = (enum __anonenum_reg_errcode_t_7 )0;
#line 1123
  cur_state = acquire_init_state_context(& err, (re_match_context_t const   *)mctx,
                                         cur_str_idx);
#line 1125
  if ((unsigned int )cur_state == (unsigned int )((void *)0)) {
#line 1127
    if (((int )err == 12) == 0) {
#line 1127
      __libc_failwith((char *)"Assertion failed: err == REG_ESPACE at regexec.c:1127");
    }
#line 1128
    return (4294967294U);
  }
#line 1131
  if ((unsigned int )mctx->state_log != (unsigned int )((void *)0)) {
#line 1133
    *(mctx->state_log + cur_str_idx) = cur_state;
#line 1137
    if (dfa->nbackref) {
#line 1139
      at_init_state = (_Bool)0;
#line 1140
      err = check_subexp_matching_top(mctx, & cur_state->nodes, 0U);
#line 1141
      if ((int )err != 0) {
#line 1142
        return ((unsigned int )err);
      }
#line 1144
      if (cur_state->has_backref) {
#line 1146
        err = transit_state_bkref(mctx, (re_node_set const   *)(& cur_state->nodes));
#line 1147
        if ((int )err != 0) {
#line 1148
          return ((unsigned int )err);
        }
      }
    }
  }
#line 1154
  if (cur_state->halt) {
#line 1156
    if (! cur_state->has_constraint) {
#line 1156
      goto _L;
    } else {
#line 1156
      __cil_tmp = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                           cur_str_idx);
#line 1156
      if (__cil_tmp) {
        _L: 
#line 1159
        if (! fl_longest_match) {
#line 1160
          return (cur_str_idx);
        } else {
#line 1163
          match_last = cur_str_idx;
#line 1164
          match = 1U;
        }
      }
    }
  }
#line 1169
  while (! (mctx->input.stop <= mctx->input.cur_idx)) {
#line 1171
    old_state = cur_state;
#line 1172
    next_char_idx = mctx->input.cur_idx + 1U;
#line 1174
    if (next_char_idx >= mctx->input.bufs_len || (next_char_idx >= mctx->input.valid_len && mctx->input.valid_len < mctx->input.len)) {
#line 1178
      err = extend_buffers(mctx);
#line 1179
      if ((int )err != 0) {
#line 1181
        if (((int )err == 12) == 0) {
#line 1181
          __libc_failwith((char *)"Assertion failed: err == REG_ESPACE at regexec.c:1181");
        }
#line 1182
        return (4294967294U);
      }
    }
#line 1186
    cur_state = transit_state(& err, mctx, cur_state);
#line 1187
    if ((unsigned int )mctx->state_log != (unsigned int )((void *)0)) {
#line 1188
      cur_state = merge_state_with_log(& err, mctx, cur_state);
    }
#line 1190
    if ((unsigned int )cur_state == (unsigned int )((void *)0)) {
#line 1195
      if ((int )err != 0) {
#line 1196
        return (4294967294U);
      }
#line 1198
      if ((unsigned int )mctx->state_log == (unsigned int )((void *)0) || (match && ! fl_longest_match)) {
#line 1201
        break;
      } else {
#line 1198
        cur_state = find_recover_state(& err, mctx);
#line 1198
        if ((unsigned int )cur_state == (unsigned int )((void *)0)) {
#line 1201
          break;
        }
      }
    }
#line 1204
    if (at_init_state) {
#line 1206
      if ((unsigned int )old_state == (unsigned int )cur_state) {
#line 1207
        next_start_idx = next_char_idx;
      } else {
#line 1209
        at_init_state = (_Bool)0;
      }
    }
#line 1212
    if (cur_state->halt) {
#line 1216
      if (! cur_state->has_constraint) {
#line 1216
        goto _L___0;
      } else {
#line 1216
        __cil_tmp___0 = check_halt_state_context((re_match_context_t const   *)mctx,
                                                 (re_dfastate_t const   *)cur_state,
                                                 mctx->input.cur_idx);
#line 1216
        if (__cil_tmp___0) {
          _L___0: 
#line 1221
          match_last = mctx->input.cur_idx;
#line 1222
          match = 1U;
#line 1225
          p_match_first = (Idx *)((void *)0);
#line 1226
          if (! fl_longest_match) {
#line 1227
            break;
          }
        }
      }
    }
  }
#line 1232
  if (p_match_first) {
#line 1233
    *p_match_first += next_start_idx;
  }
#line 1235
  return (match_last);
}
}
#line 1240 "regexec.c"
static _Bool check_halt_node_context(re_dfa_t const   *dfa , Idx node , unsigned int context ) 
{ re_token_type_t type ;
  unsigned int constraint ;

  {
#line 1244
  type = (dfa->nodes + node)->type;
#line 1245
  constraint = (dfa->nodes + node)->constraint;
#line 1246
  if ((unsigned int )type != 2U) {
#line 1247
    return ((_Bool)0);
  }
#line 1248
  if (! constraint) {
#line 1249
    return ((_Bool)1);
  }
#line 1250
  if ((((constraint & 4U && ! (context & 1U)) || (constraint & 8U && context & 1U)) || (constraint & 32U && ! (context & (unsigned int )(1 << 1)))) || (constraint & 128U && ! (context & (unsigned int )(((1 << 1) << 1) << 1)))) {
#line 1251
    return ((_Bool)0);
  }
#line 1252
  return ((_Bool)1);
}
}
#line 1259 "regexec.c"
static Idx check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state ,
                                    Idx idx ) 
{ Idx i ;
  unsigned int context ;
  _Bool __cil_tmp ;

  {
#line 1269
  context = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
#line 1270
  i = 0U;
#line 1270
  while (i < (unsigned int )state->nodes.nelem) {
#line 1271
    __cil_tmp = check_halt_node_context((re_dfa_t const   *)mctx->dfa, *(state->nodes.elems + i),
                                        context);
#line 1271
    if (__cil_tmp) {
#line 1272
      return (*(state->nodes.elems + i));
    }
#line 1270
    i ++;
  }
#line 1273
  return (0U);
}
}
#line 1281 "regexec.c"
static Idx proceed_next_node(re_match_context_t const   *mctx , Idx nregs , regmatch_t *regs ,
                             Idx *pidx , Idx node , re_node_set *eps_via_nodes , struct re_fail_stack_t *fs ) 
{ re_dfa_t const   *dfa ;
  Idx i ;
  _Bool ok ;
  re_node_set *cur_nodes ;
  re_node_set *edests ;
  Idx dest_node ;
  Idx candidate ;
  Idx __cil_tmp ;
  reg_errcode_t __cil_tmp___0 ;
  Idx __cil_tmp___1 ;
  Idx naccepted ;
  re_token_type_t type ;
  int __cil_tmp___2 ;
  Idx subexp_idx ;
  char *buf___0 ;
  int __cil_tmp___3 ;
  Idx dest_node___0 ;
  Idx __cil_tmp___4 ;
  Idx dest_node___1 ;
  Idx __cil_tmp___5 ;
  _Bool __cil_tmp___6 ;

  {
#line 1287
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1290
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
#line 1292
    cur_nodes = & (*(mctx->state_log + *pidx))->nodes;
#line 1293
    edests = (re_node_set *)(dfa->edests + node);
#line 1295
    ok = re_node_set_insert(eps_via_nodes, node);
#line 1296
    if (! ok) {
#line 1297
      return (4294967294U);
    }
#line 1300
    dest_node = 4294967295U;
#line 1300
    i = 0U;
#line 1300
    while (i < edests->nelem) {
#line 1302
      candidate = *(edests->elems + i);
#line 1303
      __cil_tmp = re_node_set_contains((re_node_set const   *)cur_nodes, candidate);
#line 1303
      if (! __cil_tmp) {
#line 1304
        goto __Cont;
      }
#line 1305
      if (dest_node == 4294967295U) {
#line 1306
        dest_node = candidate;
      } else {
#line 1312
        __cil_tmp___1 = re_node_set_contains((re_node_set const   *)eps_via_nodes,
                                             dest_node);
#line 1312
        if (__cil_tmp___1) {
#line 1313
          return (candidate);
        } else
#line 1316
        if ((unsigned int )fs != (unsigned int )((void *)0)) {
#line 1316
          __cil_tmp___0 = push_fail_stack(fs, *pidx, candidate, nregs, regs, eps_via_nodes);
#line 1316
          if (__cil_tmp___0) {
#line 1319
            return (4294967294U);
          }
        }
#line 1322
        break;
      }
      __Cont: 
#line 1300
      i ++;
    }
#line 1325
    return (dest_node);
  } else {
#line 1329
    naccepted = 0U;
#line 1330
    type = (dfa->nodes + node)->type;
#line 1333
    if ((dfa->nodes + node)->accept_mb) {
#line 1334
      __cil_tmp___2 = check_node_accept_bytes(dfa, node, & mctx->input, *pidx);
#line 1334
      naccepted = (unsigned int )__cil_tmp___2;
    } else
#line 1337
    if ((unsigned int )type == 4U) {
#line 1339
      subexp_idx = (dfa->nodes + node)->opr.idx + 1U;
#line 1340
      naccepted = (unsigned int )((regs + subexp_idx)->rm_eo - (regs + subexp_idx)->rm_so);
#line 1341
      if ((unsigned int )fs != (unsigned int )((void *)0)) {
#line 1343
        if ((regs + subexp_idx)->rm_so == -1 || (regs + subexp_idx)->rm_eo == -1) {
#line 1344
          return (4294967295U);
        } else
#line 1345
        if (naccepted) {
#line 1347
          buf___0 = (char *)mctx->input.mbs;
#line 1348
          __cil_tmp___3 = rpl_memcmp((void const   *)(buf___0 + (regs + subexp_idx)->rm_so),
                                     (void const   *)(buf___0 + *pidx), naccepted);
#line 1348
          if (__cil_tmp___3 != 0) {
#line 1350
            return (4294967295U);
          }
        }
      }
#line 1354
      if (naccepted == 0U) {
#line 1357
        ok = re_node_set_insert(eps_via_nodes, node);
#line 1358
        if (! ok) {
#line 1359
          return (4294967294U);
        }
#line 1360
        dest_node___0 = *((dfa->edests + node)->elems + 0);
#line 1361
        __cil_tmp___4 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                             dest_node___0);
#line 1361
        if (__cil_tmp___4) {
#line 1363
          return (dest_node___0);
        }
      }
    }
#line 1367
    if (naccepted != 0U) {
#line 1367
      goto _L;
    } else {
#line 1367
      __cil_tmp___6 = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + node),
                                        *pidx);
#line 1367
      if (__cil_tmp___6) {
        _L: 
#line 1370
        dest_node___1 = *(dfa->nexts + node);
#line 1371
        *pidx = naccepted == 0U ? *pidx + 1U : *pidx + naccepted;
#line 1372
        if (fs) {
#line 1372
          if (*pidx > (unsigned int )mctx->match_last || (unsigned int )*(mctx->state_log + *pidx) == (unsigned int )((void *)0)) {
#line 1375
            return (4294967295U);
          } else {
#line 1372
            __cil_tmp___5 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                                 dest_node___1);
#line 1372
            if (! __cil_tmp___5) {
#line 1375
              return (4294967295U);
            }
          }
        }
#line 1376
        eps_via_nodes->nelem = 0U;
#line 1377
        return (dest_node___1);
      }
    }
  }
#line 1380
  return (4294967295U);
}
}
#line 1383 "regexec.c"
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , Idx str_idx , Idx dest_node ,
                                     Idx nregs , regmatch_t *regs , re_node_set *eps_via_nodes ) 
{ reg_errcode_t err ;
  Idx num ;
  Idx __cil_tmp ;
  struct re_fail_stack_ent_t *new_array ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;

  {
#line 1389
  __cil_tmp = fs->num;
#line 1389
  (fs->num) ++;
#line 1389
  num = __cil_tmp;
#line 1390
  if (fs->num == fs->alloc) {
#line 1393
    __cil_tmp___0 = rpl_realloc((void *)fs->stack, (sizeof(struct re_fail_stack_ent_t ) * fs->alloc) * 2U);
#line 1393
    new_array = (struct re_fail_stack_ent_t *)__cil_tmp___0;
#line 1395
    if ((unsigned int )new_array == (unsigned int )((void *)0)) {
#line 1396
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 1397
    fs->alloc *= 2U;
#line 1398
    fs->stack = new_array;
  }
#line 1400
  (fs->stack + num)->idx = str_idx;
#line 1401
  (fs->stack + num)->node = dest_node;
#line 1402
  __cil_tmp___1 = rpl_malloc(nregs * sizeof(regmatch_t ));
#line 1402
  (fs->stack + num)->regs = (regmatch_t *)__cil_tmp___1;
#line 1403
  if ((unsigned int )(fs->stack + num)->regs == (unsigned int )((void *)0)) {
#line 1404
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 1405
  memcpy((void *)(fs->stack + num)->regs, (void const   *)regs, sizeof(regmatch_t ) * nregs);
#line 1406
  err = re_node_set_init_copy(& (fs->stack + num)->eps_via_nodes, (re_node_set const   *)eps_via_nodes);
#line 1407
  return (err);
}
}
#line 1410 "regexec.c"
static Idx pop_fail_stack(struct re_fail_stack_t *fs , Idx *pidx , Idx nregs , regmatch_t *regs ,
                          re_node_set *eps_via_nodes ) 
{ Idx num ;

  {
#line 1415
  (fs->num) --;
#line 1415
  num = fs->num;
#line 1416
  if ((num < 4294967294U) == 0) {
#line 1416
    __libc_failwith((char *)"Assertion failed: REG_VALID_INDEX (num) at regexec.c:1416");
  }
#line 1417
  *pidx = (fs->stack + num)->idx;
#line 1418
  memcpy((void *)regs, (void const   *)(fs->stack + num)->regs, sizeof(regmatch_t ) * nregs);
#line 1419
  free((void *)eps_via_nodes->elems);
#line 1420
  free((void *)(fs->stack + num)->regs);
#line 1421
  *eps_via_nodes = (fs->stack + num)->eps_via_nodes;
#line 1422
  return ((fs->stack + num)->node);
}
}
#line 1430 "regexec.c"
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , _Bool fl_backtrack ) 
{ re_dfa_t const   *dfa ;
  Idx idx ;
  Idx cur_node ;
  re_node_set eps_via_nodes ;
  struct re_fail_stack_t *fs ;
  struct re_fail_stack_t fs_body ;
  regmatch_t *prev_idx_match ;
  _Bool prev_idx_match_malloced ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;
  Idx reg_idx ;
  reg_errcode_t __cil_tmp___2 ;
  reg_errcode_t __cil_tmp___3 ;

  {
#line 1435
  dfa = (re_dfa_t const   *)preg->buffer;
#line 1439
  fs_body.num = 0U;
#line 1439
  fs_body.alloc = 2U;
#line 1439
  fs_body.stack = (struct re_fail_stack_ent_t *)((void *)0);
#line 1441
  prev_idx_match_malloced = (_Bool)0;
#line 1447
  if (fl_backtrack) {
#line 1449
    fs = & fs_body;
#line 1450
    __cil_tmp = rpl_malloc(fs->alloc * sizeof(struct re_fail_stack_ent_t ));
#line 1450
    fs->stack = (struct re_fail_stack_ent_t *)__cil_tmp;
#line 1451
    if ((unsigned int )fs->stack == (unsigned int )((void *)0)) {
#line 1452
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
  } else {
#line 1455
    fs = (struct re_fail_stack_t *)((void *)0);
  }
#line 1457
  cur_node = (unsigned int )dfa->init_node;
#line 1458
  memset((void *)(& eps_via_nodes), '\000', sizeof(re_node_set ));
#line 1460
  if (nmatch * sizeof(regmatch_t ) < 4032U) {
#line 1461
    __cil_tmp___0 = __builtin_alloca(nmatch * sizeof(regmatch_t ));
#line 1461
    prev_idx_match = (regmatch_t *)__cil_tmp___0;
  } else {
#line 1464
    __cil_tmp___1 = rpl_malloc(nmatch * sizeof(regmatch_t ));
#line 1464
    prev_idx_match = (regmatch_t *)__cil_tmp___1;
#line 1465
    if ((unsigned int )prev_idx_match == (unsigned int )((void *)0)) {
#line 1467
      free_fail_stack_return(fs);
#line 1468
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 1470
    prev_idx_match_malloced = (_Bool)1;
  }
#line 1472
  memcpy((void *)prev_idx_match, (void const   *)pmatch, sizeof(regmatch_t ) * nmatch);
#line 1474
  idx = (unsigned int )(pmatch + 0)->rm_so;
#line 1474
  while (idx <= (unsigned int )(pmatch + 0)->rm_eo) {
#line 1476
    update_regs(dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);
#line 1478
    if (idx == (unsigned int )(pmatch + 0)->rm_eo && cur_node == (unsigned int )mctx->last_node) {
#line 1481
      if (fs) {
#line 1483
        reg_idx = 0U;
#line 1483
        while (reg_idx < nmatch) {
#line 1484
          if ((pmatch + reg_idx)->rm_so > -1 && (pmatch + reg_idx)->rm_eo == -1) {
#line 1485
            break;
          }
#line 1483
          reg_idx ++;
        }
#line 1486
        if (reg_idx == nmatch) {
#line 1488
          free((void *)eps_via_nodes.elems);
#line 1489
          if (prev_idx_match_malloced) {
#line 1490
            free((void *)prev_idx_match);
          }
#line 1491
          __cil_tmp___2 = free_fail_stack_return(fs);
#line 1491
          return (__cil_tmp___2);
        }
#line 1493
        cur_node = pop_fail_stack(fs, & idx, nmatch, pmatch, & eps_via_nodes);
      } else {
#line 1498
        free((void *)eps_via_nodes.elems);
#line 1499
        if (prev_idx_match_malloced) {
#line 1500
          free((void *)prev_idx_match);
        }
#line 1501
        return ((enum __anonenum_reg_errcode_t_7 )0);
      }
    }
#line 1506
    cur_node = proceed_next_node(mctx, nmatch, pmatch, & idx, cur_node, & eps_via_nodes,
                                 fs);
#line 1509
    if (! (cur_node < 4294967294U)) {
#line 1511
      if (cur_node == 4294967294U) {
#line 1513
        free((void *)eps_via_nodes.elems);
#line 1514
        if (prev_idx_match_malloced) {
#line 1515
          free((void *)prev_idx_match);
        }
#line 1516
        free_fail_stack_return(fs);
#line 1517
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 1519
      if (fs) {
#line 1520
        cur_node = pop_fail_stack(fs, & idx, nmatch, pmatch, & eps_via_nodes);
      } else {
#line 1524
        free((void *)eps_via_nodes.elems);
#line 1525
        if (prev_idx_match_malloced) {
#line 1526
          free((void *)prev_idx_match);
        }
#line 1527
        return ((enum __anonenum_reg_errcode_t_7 )1);
      }
    }
  }
#line 1531
  free((void *)eps_via_nodes.elems);
#line 1532
  if (prev_idx_match_malloced) {
#line 1533
    free((void *)prev_idx_match);
  }
#line 1534
  __cil_tmp___3 = free_fail_stack_return(fs);
#line 1534
  return (__cil_tmp___3);
}
}
#line 1537 "regexec.c"
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) 
{ Idx fs_idx ;

  {
#line 1541
  if (fs) {
#line 1544
    fs_idx = 0U;
#line 1544
    while (fs_idx < fs->num) {
#line 1546
      free((void *)(fs->stack + fs_idx)->eps_via_nodes.elems);
#line 1547
      free((void *)(fs->stack + fs_idx)->regs);
#line 1544
      fs_idx ++;
    }
#line 1549
    free((void *)fs->stack);
  }
#line 1551
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1554 "regexec.c"
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        Idx cur_node , Idx cur_idx , Idx nmatch ) 
{ int type ;
  Idx reg_num ;
  Idx reg_num___0 ;

  {
#line 1559
  type = (int )(dfa->nodes + cur_node)->type;
#line 1560
  if (type == 8) {
#line 1562
    reg_num = (dfa->nodes + cur_node)->opr.idx + 1U;
#line 1565
    if (reg_num < nmatch) {
#line 1567
      (pmatch + reg_num)->rm_so = (int )cur_idx;
#line 1568
      (pmatch + reg_num)->rm_eo = -1;
    }
  } else
#line 1571
  if (type == 9) {
#line 1573
    reg_num___0 = (dfa->nodes + cur_node)->opr.idx + 1U;
#line 1574
    if (reg_num___0 < nmatch) {
#line 1577
      if ((unsigned int )(pmatch + reg_num___0)->rm_so < cur_idx) {
#line 1579
        (pmatch + reg_num___0)->rm_eo = (int )cur_idx;
#line 1582
        memcpy((void *)prev_idx_match, (void const   *)pmatch, sizeof(regmatch_t ) * nmatch);
      } else
#line 1586
      if ((dfa->nodes + cur_node)->opt_subexp && (prev_idx_match + reg_num___0)->rm_so != -1) {
#line 1593
        memcpy((void *)pmatch, (void const   *)prev_idx_match, sizeof(regmatch_t ) * nmatch);
      } else {
#line 1597
        (pmatch + reg_num___0)->rm_eo = (int )cur_idx;
      }
    }
  }
#line 1601
  return;
}
}
#line 1626 "regexec.c"
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) 
{ reg_errcode_t err ;
  int null_cnt ;
  Idx str_idx ;
  re_node_set cur_dest ;

  {
#line 1631
  null_cnt = 0;
#line 1632
  str_idx = sctx->last_str_idx;
#line 1641
  err = re_node_set_init_1(& cur_dest, sctx->last_node);
#line 1642
  if ((int )err != 0) {
#line 1643
    return (err);
  }
#line 1644
  err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1645
  if ((int )err != 0) {
#line 1646
    goto free_return;
  }
#line 1649
  while (str_idx > 0U) {
#line 1652
    null_cnt = (unsigned int )*(sctx->sifted_states + str_idx) == (unsigned int )((void *)0) ? null_cnt + 1 : 0;
#line 1653
    if (null_cnt > (int )mctx->max_mb_elem_len) {
#line 1655
      memset((void *)sctx->sifted_states, '\000', sizeof(re_dfastate_t *) * str_idx);
#line 1657
      free((void *)cur_dest.elems);
#line 1658
      return ((enum __anonenum_reg_errcode_t_7 )0);
    }
#line 1660
    cur_dest.nelem = 0U;
#line 1661
    str_idx --;
#line 1663
    if (*(mctx->state_log + str_idx)) {
#line 1665
      err = build_sifted_states(mctx, sctx, str_idx, & cur_dest);
#line 1666
      if ((int )err != 0) {
#line 1667
        goto free_return;
      }
    }
#line 1674
    err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1675
    if ((int )err != 0) {
#line 1676
      goto free_return;
    }
  }
#line 1678
  err = (enum __anonenum_reg_errcode_t_7 )0;
  free_return: 
#line 1680
  free((void *)cur_dest.elems);
#line 1681
  return (err);
}
}
#line 1684 "regexec.c"
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         Idx str_idx , re_node_set *cur_dest ) 
{ re_dfa_t const   *dfa ;
  re_node_set const   *cur_src ;
  Idx i ;
  Idx prev_node ;
  int naccepted ;
  _Bool ok ;
  _Bool __cil_tmp ;
  Idx __cil_tmp___0 ;
  Idx to_idx ;
  _Bool __cil_tmp___1 ;

  {
#line 1689
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1690
  cur_src = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->non_eps_nodes);
#line 1700
  i = 0U;
#line 1700
  while (i < (unsigned int )cur_src->nelem) {
#line 1702
    prev_node = *(cur_src->elems + i);
#line 1703
    naccepted = 0;
#line 1712
    if ((dfa->nodes + prev_node)->accept_mb) {
#line 1713
      naccepted = sift_states_iter_mb(mctx, sctx, prev_node, str_idx, sctx->last_str_idx);
    }
#line 1719
    if (! naccepted) {
#line 1719
      __cil_tmp = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + prev_node),
                                    str_idx);
#line 1719
      if (__cil_tmp) {
#line 1719
        if ((unsigned int )*(sctx->sifted_states + (str_idx + 1U)) != (unsigned int )((void *)0)) {
#line 1719
          __cil_tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + 1U)))->nodes),
                                               *(dfa->nexts + prev_node));
#line 1719
          if (__cil_tmp___0) {
#line 1723
            naccepted = 1;
          }
        }
      }
    }
#line 1725
    if (naccepted == 0) {
#line 1726
      goto __Cont;
    }
#line 1728
    if (sctx->limits.nelem) {
#line 1730
      to_idx = str_idx + (unsigned int )naccepted;
#line 1731
      __cil_tmp___1 = check_dst_limits(mctx, (re_node_set const   *)(& sctx->limits),
                                       *(dfa->nexts + prev_node), to_idx, prev_node,
                                       str_idx);
#line 1731
      if (__cil_tmp___1) {
#line 1734
        goto __Cont;
      }
    }
#line 1736
    ok = re_node_set_insert(cur_dest, prev_node);
#line 1737
    if (! ok) {
#line 1738
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
    __Cont: 
#line 1700
    i ++;
  }
#line 1741
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1746 "regexec.c"
static reg_errcode_t clean_state_log_if_needed(re_match_context_t *mctx , Idx next_state_log_idx ) 
{ Idx top ;
  reg_errcode_t err ;

  {
#line 1750
  top = mctx->state_log_top;
#line 1752
  if (next_state_log_idx >= mctx->input.bufs_len || (next_state_log_idx >= mctx->input.valid_len && mctx->input.valid_len < mctx->input.len)) {
#line 1757
    err = extend_buffers(mctx);
#line 1758
    if ((int )err != 0) {
#line 1759
      return (err);
    }
  }
#line 1762
  if (top < next_state_log_idx) {
#line 1764
    memset((void *)((mctx->state_log + top) + 1), '\000', sizeof(re_dfastate_t *) * (next_state_log_idx - top));
#line 1766
    mctx->state_log_top = next_state_log_idx;
  }
#line 1768
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1771 "regexec.c"
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , Idx num ) 
{ Idx st_idx ;
  reg_errcode_t err ;
  re_node_set merged_set ;

  {
#line 1778
  st_idx = 0U;
#line 1778
  while (st_idx < num) {
#line 1780
    if ((unsigned int )*(dst + st_idx) == (unsigned int )((void *)0)) {
#line 1781
      *(dst + st_idx) = *(src + st_idx);
    } else
#line 1782
    if ((unsigned int )*(src + st_idx) != (unsigned int )((void *)0)) {
#line 1785
      err = re_node_set_init_union(& merged_set, (re_node_set const   *)(& (*(dst + st_idx))->nodes),
                                   (re_node_set const   *)(& (*(src + st_idx))->nodes));
#line 1787
      if ((int )err != 0) {
#line 1788
        return (err);
      }
#line 1789
      *(dst + st_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& merged_set));
#line 1790
      free((void *)merged_set.elems);
#line 1791
      if ((int )err != 0) {
#line 1792
        return (err);
      }
    }
#line 1778
    st_idx ++;
  }
#line 1795
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1798 "regexec.c"
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *dest_nodes ) 
{ re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  re_node_set const   *candidates ;

  {
#line 1804
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1805
  err = (enum __anonenum_reg_errcode_t_7 )0;
#line 1807
  candidates = (re_node_set const   *)((unsigned int )*(mctx->state_log + str_idx) == (unsigned int )((void *)0) ? (re_node_set *)((void *)0) : & (*(mctx->state_log + str_idx))->nodes);
#line 1810
  if (dest_nodes->nelem == 0U) {
#line 1811
    *(sctx->sifted_states + str_idx) = (re_dfastate_t *)((void *)0);
  } else {
#line 1814
    if (candidates) {
#line 1818
      err = add_epsilon_src_nodes(dfa, dest_nodes, candidates);
#line 1819
      if ((int )err != 0) {
#line 1820
        return (err);
      }
#line 1823
      if (sctx->limits.nelem) {
#line 1825
        err = check_subexp_limits(dfa, dest_nodes, candidates, & sctx->limits, (struct re_backref_cache_entry *)mctx->bkref_ents,
                                  str_idx);
#line 1827
        if ((int )err != 0) {
#line 1828
          return (err);
        }
      }
    }
#line 1832
    *(sctx->sifted_states + str_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1833
    if ((int )err != 0) {
#line 1834
      return (err);
    }
  }
#line 1837
  if (candidates && (*(mctx->state_log + str_idx))->has_backref) {
#line 1839
    err = sift_states_bkref(mctx, sctx, str_idx, candidates);
#line 1840
    if ((int )err != 0) {
#line 1841
      return (err);
    }
  }
#line 1843
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1846 "regexec.c"
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ reg_errcode_t err ;
  Idx i ;
  re_dfastate_t *state ;
  re_dfastate_t *__cil_tmp ;
  reg_errcode_t __cil_tmp___0 ;

  {
#line 1851
  err = (enum __anonenum_reg_errcode_t_7 )0;
#line 1854
  __cil_tmp = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1854
  state = __cil_tmp;
#line 1855
  if ((int )err != 0) {
#line 1856
    return (err);
  }
#line 1858
  if (! state->inveclosure.alloc) {
#line 1860
    err = re_node_set_alloc(& state->inveclosure, dest_nodes->nelem);
#line 1861
    if ((int )err != 0) {
#line 1862
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 1863
    i = 0U;
#line 1863
    while (i < dest_nodes->nelem) {
#line 1864
      re_node_set_merge(& state->inveclosure, (re_node_set const   *)(dfa->inveclosures + *(dest_nodes->elems + i)));
#line 1863
      i ++;
    }
  }
#line 1867
  __cil_tmp___0 = re_node_set_add_intersect(dest_nodes, candidates, (re_node_set const   *)(& state->inveclosure));
#line 1867
  return (__cil_tmp___0);
}
}
#line 1871 "regexec.c"
static reg_errcode_t sub_epsilon_src_nodes(re_dfa_t const   *dfa , Idx node , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ Idx ecl_idx ;
  reg_errcode_t err ;
  re_node_set *inv_eclosure ;
  re_node_set except_nodes ;
  Idx cur_node ;
  Idx edst1 ;
  Idx edst2 ;
  Idx __cil_tmp ;
  Idx __cil_tmp___0 ;
  Idx __cil_tmp___1 ;
  Idx __cil_tmp___2 ;
  Idx cur_node___0 ;
  Idx idx ;
  Idx __cil_tmp___3 ;
  Idx __cil_tmp___4 ;

  {
#line 1878
  inv_eclosure = (re_node_set *)(dfa->inveclosures + node);
#line 1880
  memset((void *)(& except_nodes), '\000', sizeof(re_node_set ));
#line 1881
  ecl_idx = 0U;
#line 1881
  while (ecl_idx < inv_eclosure->nelem) {
#line 1883
    cur_node = *(inv_eclosure->elems + ecl_idx);
#line 1884
    if (cur_node == node) {
#line 1885
      goto __Cont;
    }
#line 1886
    if ((unsigned int )(dfa->nodes + cur_node)->type & 8U) {
#line 1888
      edst1 = *((dfa->edests + cur_node)->elems + 0);
#line 1889
      edst2 = (dfa->edests + cur_node)->nelem > 1U ? *((dfa->edests + cur_node)->elems + 1) : 4294967295U;
#line 1891
      __cil_tmp = re_node_set_contains((re_node_set const   *)inv_eclosure, edst1);
#line 1891
      if (__cil_tmp) {
        _L___0: 
#line 1891
        if (edst2 - 1U < 4294967293U) {
#line 1891
          __cil_tmp___1 = re_node_set_contains((re_node_set const   *)inv_eclosure,
                                               edst2);
#line 1891
          if (! __cil_tmp___1) {
#line 1891
            __cil_tmp___2 = re_node_set_contains((re_node_set const   *)dest_nodes,
                                                 edst2);
#line 1891
            if (__cil_tmp___2) {
              _L: 
#line 1897
              err = re_node_set_add_intersect(& except_nodes, candidates, (re_node_set const   *)(dfa->inveclosures + cur_node));
#line 1899
              if ((int )err != 0) {
#line 1901
                free((void *)except_nodes.elems);
#line 1902
                return (err);
              }
            }
          }
        }
      } else {
#line 1891
        __cil_tmp___0 = re_node_set_contains((re_node_set const   *)dest_nodes, edst1);
#line 1891
        if (__cil_tmp___0) {
#line 1891
          goto _L;
        } else {
#line 1891
          goto _L___0;
        }
      }
    }
    __Cont: 
#line 1881
    ecl_idx ++;
  }
#line 1907
  ecl_idx = 0U;
#line 1907
  while (ecl_idx < inv_eclosure->nelem) {
#line 1909
    cur_node___0 = *(inv_eclosure->elems + ecl_idx);
#line 1910
    __cil_tmp___4 = re_node_set_contains((re_node_set const   *)(& except_nodes),
                                         cur_node___0);
#line 1910
    if (! __cil_tmp___4) {
#line 1912
      __cil_tmp___3 = re_node_set_contains((re_node_set const   *)dest_nodes, cur_node___0);
#line 1912
      idx = __cil_tmp___3 - 1U;
#line 1913
      re_node_set_remove_at(dest_nodes, idx);
    }
#line 1907
    ecl_idx ++;
  }
#line 1916
  free((void *)except_nodes.elems);
#line 1917
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 1920 "regexec.c"
static _Bool check_dst_limits(re_match_context_t const   *mctx , re_node_set const   *limits ,
                              Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) 
{ re_dfa_t const   *dfa ;
  Idx lim_idx ;
  Idx src_pos ;
  Idx dst_pos ;
  Idx dst_bkref_idx ;
  Idx __cil_tmp ;
  Idx src_bkref_idx ;
  Idx __cil_tmp___0 ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 1925
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1928
  __cil_tmp = search_cur_bkref_entry(mctx, dst_idx);
#line 1928
  dst_bkref_idx = __cil_tmp;
#line 1929
  __cil_tmp___0 = search_cur_bkref_entry(mctx, src_idx);
#line 1929
  src_bkref_idx = __cil_tmp___0;
#line 1930
  lim_idx = 0U;
#line 1930
  while (lim_idx < (unsigned int )limits->nelem) {
#line 1934
    ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + *(limits->elems + lim_idx));
#line 1935
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 1937
    __cil_tmp___1 = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                              dst_node, dst_idx, dst_bkref_idx);
#line 1937
    dst_pos = (unsigned int )__cil_tmp___1;
#line 1940
    __cil_tmp___2 = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                              src_node, src_idx, src_bkref_idx);
#line 1940
    src_pos = (unsigned int )__cil_tmp___2;
#line 1948
    if (! (src_pos == dst_pos)) {
#line 1951
      return ((_Bool)1);
    }
#line 1930
    lim_idx ++;
  }
#line 1953
  return ((_Bool)0);
}
}
#line 1956 "regexec.c"
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       Idx subexp_idx , Idx from_node , Idx bkref_idx ) 
{ re_dfa_t const   *dfa ;
  re_node_set const   *eclosures ;
  Idx node_idx ;
  Idx node ;
  struct re_backref_cache_entry *ent ;
  Idx dst ;
  int cpos ;
  struct re_backref_cache_entry *__cil_tmp ;

  {
#line 1961
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1962
  eclosures = (re_node_set const   *)(dfa->eclosures + from_node);
#line 1967
  node_idx = 0U;
#line 1967
  while (node_idx < (unsigned int )eclosures->nelem) {
#line 1969
    node = *(eclosures->elems + node_idx);
#line 1970
    switch ((int )(dfa->nodes + node)->type) {
    case 4: 
#line 1973
    if (bkref_idx != 4294967295U) {
#line 1975
      ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + bkref_idx);
#line 1976
      while (1) {
#line 1981
        if (ent->node != node) {
#line 1982
          goto __Cont;
        }
#line 1984
        if (subexp_idx < 32U && ! ((unsigned long )ent->eps_reachable_subexps_map & (1UL << subexp_idx))) {
#line 1987
          goto __Cont;
        }
#line 1995
        dst = *((dfa->edests + node)->elems + 0);
#line 1996
        if (dst == from_node) {
#line 1998
          if (boundaries & 1) {
#line 1999
            return (-1);
          } else {
#line 2001
            return (0);
          }
        }
#line 2004
        cpos = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, dst, bkref_idx);
#line 2007
        if (cpos == -1) {
#line 2008
          return (-1);
        }
#line 2009
        if (cpos == 0 && boundaries & 2) {
#line 2010
          return (0);
        }
#line 2012
        if (subexp_idx < 32U) {
#line 2013
          ent->eps_reachable_subexps_map = (unsigned short )((unsigned long )ent->eps_reachable_subexps_map & ~ (1UL << subexp_idx));
        }
        __Cont: 
#line 1976
        __cil_tmp = ent;
#line 1976
        ent ++;
#line 1976
        if (! __cil_tmp->more) {
#line 1976
          break;
        }
      }
    }
#line 2018
    break;
    case 8: 
#line 2021
    if (boundaries & 1 && subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2022
      return (-1);
    }
#line 2023
    break;
    case 9: 
#line 2026
    if (boundaries & 2 && subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2027
      return (0);
    }
#line 2028
    break;
    default: 
#line 2031
    break;
    }
#line 1967
    node_idx ++;
  }
#line 2035
  return (boundaries & 2 ? 1 : 0);
}
}
#line 2038 "regexec.c"
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , Idx limit ,
                                     Idx subexp_idx , Idx from_node , Idx str_idx ,
                                     Idx bkref_idx ) 
{ struct re_backref_cache_entry *lim ;
  int boundaries ;
  int __cil_tmp ;

  {
#line 2044
  lim = (struct re_backref_cache_entry *)(mctx->bkref_ents + limit);
#line 2048
  if (str_idx < lim->subexp_from) {
#line 2049
    return (-1);
  }
#line 2051
  if (lim->subexp_to < str_idx) {
#line 2052
    return (1);
  }
#line 2055
  boundaries = str_idx == lim->subexp_from;
#line 2056
  boundaries |= (str_idx == lim->subexp_to) << 1;
#line 2057
  if (boundaries == 0) {
#line 2058
    return (0);
  }
#line 2061
  __cil_tmp = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, from_node,
                                          bkref_idx);
#line 2061
  return (__cil_tmp);
}
}
#line 2068 "regexec.c"
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         Idx str_idx ) 
{ reg_errcode_t err ;
  Idx node_idx ;
  Idx lim_idx ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  Idx ops_node ;
  Idx cls_node ;
  Idx node ;
  re_token_type_t type ;
  Idx node___0 ;
  Idx __cil_tmp ;
  Idx __cil_tmp___0 ;
  Idx node___1 ;
  re_token_type_t type___0 ;

  {
#line 2077
  lim_idx = 0U;
#line 2077
  while (lim_idx < limits->nelem) {
#line 2081
    ent = bkref_ents + *(limits->elems + lim_idx);
#line 2083
    if (str_idx <= ent->subexp_from || ent->str_idx < str_idx) {
#line 2084
      goto __Cont;
    }
#line 2086
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 2087
    if (ent->subexp_to == str_idx) {
#line 2089
      ops_node = 4294967295U;
#line 2090
      cls_node = 4294967295U;
#line 2091
      node_idx = 0U;
#line 2091
      while (node_idx < dest_nodes->nelem) {
#line 2093
        node = *(dest_nodes->elems + node_idx);
#line 2094
        type = (dfa->nodes + node)->type;
#line 2095
        if ((unsigned int )type == 8U && subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2097
          ops_node = node;
        } else
#line 2098
        if ((unsigned int )type == 9U && subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2100
          cls_node = node;
        }
#line 2091
        node_idx ++;
      }
#line 2105
      if (ops_node < 4294967294U) {
#line 2107
        err = sub_epsilon_src_nodes(dfa, ops_node, dest_nodes, candidates);
#line 2109
        if ((int )err != 0) {
#line 2110
          return (err);
        }
      }
#line 2114
      if (cls_node < 4294967294U) {
#line 2115
        node_idx = 0U;
#line 2115
        while (node_idx < dest_nodes->nelem) {
#line 2117
          node___0 = *(dest_nodes->elems + node_idx);
#line 2118
          __cil_tmp = re_node_set_contains((re_node_set const   *)(dfa->inveclosures + node___0),
                                           cls_node);
#line 2118
          if (! __cil_tmp) {
#line 2118
            __cil_tmp___0 = re_node_set_contains((re_node_set const   *)(dfa->eclosures + node___0),
                                                 cls_node);
#line 2118
            if (! __cil_tmp___0) {
#line 2125
              err = sub_epsilon_src_nodes(dfa, node___0, dest_nodes, candidates);
#line 2127
              if ((int )err != 0) {
#line 2128
                return (err);
              }
#line 2129
              node_idx --;
            }
          }
#line 2115
          node_idx ++;
        }
      }
    } else {
#line 2135
      node_idx = 0U;
#line 2135
      while (node_idx < dest_nodes->nelem) {
#line 2137
        node___1 = *(dest_nodes->elems + node_idx);
#line 2138
        type___0 = (dfa->nodes + node___1)->type;
#line 2139
        if ((unsigned int )type___0 == 9U || (unsigned int )type___0 == 8U) {
#line 2141
          if (subexp_idx != (dfa->nodes + node___1)->opr.idx) {
#line 2142
            goto __Cont___0;
          }
#line 2145
          err = sub_epsilon_src_nodes(dfa, node___1, dest_nodes, candidates);
#line 2147
          if ((int )err != 0) {
#line 2148
            return (err);
          }
        }
        __Cont___0: 
#line 2135
        node_idx ++;
      }
    }
    __Cont: 
#line 2077
    lim_idx ++;
  }
#line 2153
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 2156 "regexec.c"
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       Idx str_idx , re_node_set const   *candidates ) 
{ re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx node_idx ;
  Idx node ;
  re_sift_context_t local_sctx ;
  Idx first_idx ;
  Idx __cil_tmp ;
  Idx enabled_idx ;
  re_token_type_t type ;
  struct re_backref_cache_entry *entry ;
  Idx subexp_len ;
  Idx to_idx ;
  Idx dst_node ;
  _Bool ok ;
  re_dfastate_t *cur_state ;
  Idx __cil_tmp___0 ;
  _Bool __cil_tmp___1 ;
  Idx __cil_tmp___2 ;
  struct re_backref_cache_entry *__cil_tmp___3 ;

  {
#line 2161
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2165
  __cil_tmp = search_cur_bkref_entry(mctx, str_idx);
#line 2165
  first_idx = __cil_tmp;
#line 2167
  if (first_idx == 4294967295U) {
#line 2168
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
#line 2170
  local_sctx.sifted_states = (re_dfastate_t **)((void *)0);
#line 2172
  node_idx = 0U;
#line 2172
  while (node_idx < (unsigned int )candidates->nelem) {
#line 2177
    node = *(candidates->elems + node_idx);
#line 2178
    type = (dfa->nodes + node)->type;
#line 2180
    if (node == sctx->last_node && str_idx == sctx->last_str_idx) {
#line 2181
      goto __Cont;
    }
#line 2182
    if ((unsigned int )type != 4U) {
#line 2183
      goto __Cont;
    }
#line 2185
    entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + first_idx);
#line 2186
    enabled_idx = first_idx;
#line 2187
    while (1) {
#line 2195
      if (entry->node != node) {
#line 2196
        goto __Cont___0;
      }
#line 2197
      subexp_len = entry->subexp_to - entry->subexp_from;
#line 2198
      to_idx = str_idx + subexp_len;
#line 2199
      dst_node = subexp_len ? *(dfa->nexts + node) : *((dfa->edests + node)->elems + 0);
#line 2202
      if (to_idx > sctx->last_str_idx || (unsigned int )*(sctx->sifted_states + to_idx) == (unsigned int )((void *)0)) {
#line 2207
        goto __Cont___0;
      } else
#line 2202
      if ((unsigned int )*(sctx->sifted_states + to_idx) != (unsigned int )((void *)0)) {
#line 2202
        __cil_tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + to_idx))->nodes),
                                             dst_node);
#line 2202
        if (__cil_tmp___0) {
#line 2202
          __cil_tmp___1 = check_dst_limits(mctx, (re_node_set const   *)(& sctx->limits),
                                           node, str_idx, dst_node, to_idx);
#line 2202
          if (__cil_tmp___1) {
#line 2207
            goto __Cont___0;
          }
        } else {
#line 2207
          goto __Cont___0;
        }
      } else {
#line 2207
        goto __Cont___0;
      }
#line 2209
      if ((unsigned int )local_sctx.sifted_states == (unsigned int )((void *)0)) {
#line 2211
        local_sctx = *sctx;
#line 2212
        err = re_node_set_init_copy(& local_sctx.limits, (re_node_set const   *)(& sctx->limits));
#line 2213
        if ((int )err != 0) {
#line 2214
          goto free_return;
        }
      }
#line 2216
      local_sctx.last_node = node;
#line 2217
      local_sctx.last_str_idx = str_idx;
#line 2218
      ok = re_node_set_insert(& local_sctx.limits, enabled_idx);
#line 2219
      if (! ok) {
#line 2221
        err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2222
        goto free_return;
      }
#line 2224
      cur_state = *(local_sctx.sifted_states + str_idx);
#line 2225
      err = sift_states_backward(mctx, & local_sctx);
#line 2226
      if ((int )err != 0) {
#line 2227
        goto free_return;
      }
#line 2228
      if ((unsigned int )sctx->limited_states != (unsigned int )((void *)0)) {
#line 2230
        err = merge_state_array(dfa, sctx->limited_states, local_sctx.sifted_states,
                                str_idx + 1U);
#line 2233
        if ((int )err != 0) {
#line 2234
          goto free_return;
        }
      }
#line 2236
      *(local_sctx.sifted_states + str_idx) = cur_state;
#line 2237
      __cil_tmp___2 = re_node_set_contains((re_node_set const   *)(& local_sctx.limits),
                                           enabled_idx);
#line 2237
      re_node_set_remove_at(& local_sctx.limits, __cil_tmp___2 - 1U);
#line 2240
      entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + enabled_idx);
      __Cont___0: 
#line 2187
      enabled_idx ++;
#line 2187
      __cil_tmp___3 = entry;
#line 2187
      entry ++;
#line 2187
      if (! __cil_tmp___3->more) {
#line 2187
        break;
      }
    }
    __Cont: 
#line 2172
    node_idx ++;
  }
#line 2244
  err = (enum __anonenum_reg_errcode_t_7 )0;
  free_return: 
#line 2246
  if ((unsigned int )local_sctx.sifted_states != (unsigned int )((void *)0)) {
#line 2248
    free((void *)local_sctx.limits.elems);
  }
#line 2251
  return (err);
}
}
#line 2256 "regexec.c"
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               Idx node_idx , Idx str_idx , Idx max_str_idx ) 
{ re_dfa_t const   *dfa ;
  int naccepted ;
  Idx __cil_tmp ;

  {
#line 2261
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2264
  naccepted = check_node_accept_bytes(dfa, node_idx, & mctx->input, str_idx);
#line 2265
  if (naccepted > 0 && str_idx + (unsigned int )naccepted <= max_str_idx) {
#line 2265
    if ((unsigned int )*(sctx->sifted_states + (str_idx + (unsigned int )naccepted)) != (unsigned int )((void *)0)) {
#line 2265
      __cil_tmp = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + (unsigned int )naccepted)))->nodes),
                                       *(dfa->nexts + node_idx));
#line 2265
      if (! __cil_tmp) {
#line 2271
        naccepted = 0;
      }
    } else {
#line 2271
      naccepted = 0;
    }
  }
#line 2274
  return (naccepted);
}
}
#line 2286 "regexec.c"
static re_dfastate_t *transit_state(reg_errcode_t *err , re_match_context_t *mctx ,
                                    re_dfastate_t *state ) 
{ re_dfastate_t **trtable ;
  unsigned char ch ;
  Idx __cil_tmp ;
  unsigned int context ;
  _Bool __cil_tmp___0 ;

  {
#line 2296
  if (state->accept_mb) {
#line 2298
    *err = transit_state_mb(mctx, state);
#line 2299
    if ((int )*err != 0) {
#line 2300
      return ((re_dfastate_t *)((void *)0));
    }
  }
#line 2312
  __cil_tmp = mctx->input.cur_idx;
#line 2312
  (mctx->input.cur_idx) ++;
#line 2312
  ch = *(mctx->input.mbs + __cil_tmp);
#line 2313
  while (1) {
#line 2315
    trtable = state->trtable;
#line 2316
    if ((unsigned int )trtable != (unsigned int )((void *)0)) {
#line 2317
      return (*(trtable + (int )ch));
    }
#line 2319
    trtable = state->word_trtable;
#line 2320
    if ((unsigned int )trtable != (unsigned int )((void *)0)) {
#line 2323
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1U,
                                     mctx->eflags);
#line 2327
      if (context & 1U) {
#line 2328
        return (*(trtable + ((int )ch + 256)));
      } else {
#line 2330
        return (*(trtable + (int )ch));
      }
    }
#line 2333
    __cil_tmp___0 = build_trtable(mctx->dfa, state);
#line 2333
    if (! __cil_tmp___0) {
#line 2335
      *err = (enum __anonenum_reg_errcode_t_7 )12;
#line 2336
      return ((re_dfastate_t *)((void *)0));
    }
  }
}
}
#line 2344 "regexec.c"
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state___0 ) 
{ re_dfa_t const   *dfa ;
  Idx cur_idx ;
  re_dfastate_t *pstate ;
  unsigned int context ;
  re_node_set next_nodes ;
  re_node_set *log_nodes ;
  re_node_set *table_nodes ;
  re_dfastate_t *__cil_tmp ;

  {
#line 2349
  dfa = mctx->dfa;
#line 2350
  cur_idx = mctx->input.cur_idx;
#line 2352
  if (cur_idx > mctx->state_log_top) {
#line 2354
    *(mctx->state_log + cur_idx) = next_state___0;
#line 2355
    mctx->state_log_top = cur_idx;
  } else
#line 2357
  if ((unsigned int )*(mctx->state_log + cur_idx) == (unsigned int )((re_dfastate_t *)0)) {
#line 2359
    *(mctx->state_log + cur_idx) = next_state___0;
  } else {
#line 2365
    table_nodes = (re_node_set *)((void *)0);
#line 2370
    pstate = *(mctx->state_log + cur_idx);
#line 2371
    log_nodes = pstate->entrance_nodes;
#line 2372
    if ((unsigned int )next_state___0 != (unsigned int )((void *)0)) {
#line 2374
      table_nodes = next_state___0->entrance_nodes;
#line 2375
      *err = re_node_set_init_union(& next_nodes, (re_node_set const   *)table_nodes,
                                    (re_node_set const   *)log_nodes);
#line 2377
      if ((int )*err != 0) {
#line 2378
        return ((re_dfastate_t *)((void *)0));
      }
    } else {
#line 2381
      next_nodes = *log_nodes;
    }
#line 2385
    context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1U,
                                   mctx->eflags);
#line 2388
    __cil_tmp = re_acquire_state_context(err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
#line 2388
    *(mctx->state_log + cur_idx) = __cil_tmp;
#line 2388
    next_state___0 = __cil_tmp;
#line 2393
    if ((unsigned int )table_nodes != (unsigned int )((void *)0)) {
#line 2394
      free((void *)next_nodes.elems);
    }
  }
#line 2397
  if (dfa->nbackref && (unsigned int )next_state___0 != (unsigned int )((void *)0)) {
#line 2402
    *err = check_subexp_matching_top(mctx, & next_state___0->nodes, cur_idx);
#line 2404
    if ((int )*err != 0) {
#line 2405
      return ((re_dfastate_t *)((void *)0));
    }
#line 2408
    if (next_state___0->has_backref) {
#line 2410
      *err = transit_state_bkref(mctx, (re_node_set const   *)(& next_state___0->nodes));
#line 2411
      if ((int )*err != 0) {
#line 2412
        return ((re_dfastate_t *)((void *)0));
      }
#line 2413
      next_state___0 = *(mctx->state_log + cur_idx);
    }
  }
#line 2417
  return (next_state___0);
}
}
#line 2423 "regexec.c"
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) 
{ re_dfastate_t *cur_state ;
  Idx max ;
  Idx cur_str_idx ;

  {
#line 2428
  while (1) {
#line 2430
    max = mctx->state_log_top;
#line 2431
    cur_str_idx = mctx->input.cur_idx;
#line 2433
    while (1) {
#line 2435
      cur_str_idx ++;
#line 2435
      if (cur_str_idx > max) {
#line 2436
        return ((re_dfastate_t *)((void *)0));
      }
#line 2437
      (mctx->input.cur_idx) ++;
#line 2433
      if (! ((unsigned int )*(mctx->state_log + cur_str_idx) == (unsigned int )((void *)0))) {
#line 2433
        break;
      }
    }
#line 2441
    cur_state = merge_state_with_log(err, mctx, (re_dfastate_t *)((void *)0));
#line 2428
    if (! ((int )*err == 0 && (unsigned int )cur_state == (unsigned int )((void *)0))) {
#line 2428
      break;
    }
  }
#line 2444
  return (cur_state);
}
}
#line 2454 "regexec.c"
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               Idx str_idx ) 
{ re_dfa_t const   *dfa ;
  Idx node_idx ;
  reg_errcode_t err ;
  Idx node ;

  {
#line 2459
  dfa = mctx->dfa;
#line 2468
  node_idx = 0U;
#line 2468
  while (node_idx < cur_nodes->nelem) {
#line 2470
    node = *(cur_nodes->elems + node_idx);
#line 2471
    if (((unsigned int )(dfa->nodes + node)->type == 8U && (dfa->nodes + node)->opr.idx < 32U) && dfa->used_bkref_map & (unsigned long const   )(1UL << (dfa->nodes + node)->opr.idx)) {
#line 2476
      err = match_ctx_add_subtop(mctx, node, str_idx);
#line 2477
      if ((int )err != 0) {
#line 2478
        return (err);
      }
    }
#line 2468
    node_idx ++;
  }
#line 2481
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 2527 "regexec.c"
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) 
{ re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  re_node_set dest_nodes ;
  re_node_set *new_nodes ;
  Idx cur_node_idx ;
  int naccepted ;
  Idx dest_idx ;
  unsigned int context ;
  re_dfastate_t *dest_state ;

  {
#line 2531
  dfa = mctx->dfa;
#line 2535
  i = 0U;
#line 2535
  while (i < pstate->nodes.nelem) {
#line 2538
    cur_node_idx = *(pstate->nodes.elems + i);
#line 2544
    if (! (dfa->nodes + cur_node_idx)->accept_mb) {
#line 2545
      goto __Cont;
    }
#line 2547
    if ((dfa->nodes + cur_node_idx)->constraint) {
#line 2549
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx,
                                     mctx->eflags);
#line 2552
      if (((((dfa->nodes + cur_node_idx)->constraint & 4U && ! (context & 1U)) || ((dfa->nodes + cur_node_idx)->constraint & 8U && context & 1U)) || ((dfa->nodes + cur_node_idx)->constraint & 32U && ! (context & (unsigned int )(1 << 1)))) || ((dfa->nodes + cur_node_idx)->constraint & 128U && ! (context & (unsigned int )(((1 << 1) << 1) << 1)))) {
#line 2554
        goto __Cont;
      }
    }
#line 2558
    naccepted = check_node_accept_bytes(dfa, cur_node_idx, (re_string_t const   *)(& mctx->input),
                                        mctx->input.cur_idx);
#line 2560
    if (naccepted == 0) {
#line 2561
      goto __Cont;
    }
#line 2564
    dest_idx = mctx->input.cur_idx + (unsigned int )naccepted;
#line 2565
    mctx->max_mb_elem_len = mctx->max_mb_elem_len < naccepted ? naccepted : mctx->max_mb_elem_len;
#line 2567
    err = clean_state_log_if_needed(mctx, dest_idx);
#line 2568
    if ((int )err != 0) {
#line 2569
      return (err);
    }
#line 2573
    new_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + cur_node_idx));
#line 2575
    dest_state = *(mctx->state_log + dest_idx);
#line 2576
    if ((unsigned int )dest_state == (unsigned int )((void *)0)) {
#line 2577
      dest_nodes = *new_nodes;
    } else {
#line 2580
      err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                   (re_node_set const   *)new_nodes);
#line 2582
      if ((int )err != 0) {
#line 2583
        return (err);
      }
    }
#line 2585
    context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_idx - 1U,
                                   mctx->eflags);
#line 2587
    *(mctx->state_log + dest_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                             context);
#line 2589
    if ((unsigned int )dest_state != (unsigned int )((void *)0)) {
#line 2590
      free((void *)dest_nodes.elems);
    }
#line 2591
    if ((unsigned int )*(mctx->state_log + dest_idx) == (unsigned int )((void *)0) && (int )err != 0) {
#line 2592
      return (err);
    }
    __Cont: 
#line 2535
    i ++;
  }
#line 2594
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 2598 "regexec.c"
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) 
{ re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  Idx cur_str_idx ;
  Idx dest_str_idx ;
  Idx prev_nelem ;
  Idx bkc_idx ;
  Idx node_idx ;
  unsigned int context ;
  re_token_t const   *node ;
  re_node_set *new_dest_nodes ;
  Idx subexp_len ;
  re_dfastate_t *dest_state ;
  struct re_backref_cache_entry *bkref_ent ;
  re_node_set dest_nodes ;

  {
#line 2602
  dfa = mctx->dfa;
#line 2605
  cur_str_idx = mctx->input.cur_idx;
#line 2607
  i = 0U;
#line 2607
  while (i < (unsigned int )nodes->nelem) {
#line 2610
    node_idx = *(nodes->elems + i);
#line 2612
    node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 2616
    if ((unsigned int const   )node->type != 4U) {
#line 2617
      goto __Cont;
    }
#line 2619
    if (node->constraint) {
#line 2621
      context = re_string_context_at((re_string_t const   *)(& mctx->input), cur_str_idx,
                                     mctx->eflags);
#line 2623
      if ((((node->constraint & 4U && ! (context & 1U)) || (node->constraint & 8U && context & 1U)) || (node->constraint & 32U && ! (context & (unsigned int )(1 << 1)))) || (node->constraint & 128U && ! (context & (unsigned int )(((1 << 1) << 1) << 1)))) {
#line 2624
        goto __Cont;
      }
    }
#line 2629
    bkc_idx = mctx->nbkref_ents;
#line 2630
    err = get_subexp(mctx, node_idx, cur_str_idx);
#line 2631
    if ((int )err != 0) {
#line 2632
      goto free_return;
    }
#line 2639
    while (bkc_idx < mctx->nbkref_ents) {
#line 2644
      bkref_ent = mctx->bkref_ents + bkc_idx;
#line 2645
      if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx) {
#line 2646
        goto __Cont___0;
      }
#line 2647
      subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
#line 2648
      new_dest_nodes = (re_node_set *)(subexp_len == 0U ? dfa->eclosures + *((dfa->edests + node_idx)->elems + 0) : dfa->eclosures + *(dfa->nexts + node_idx));
#line 2651
      dest_str_idx = (cur_str_idx + bkref_ent->subexp_to) - bkref_ent->subexp_from;
#line 2653
      context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_str_idx - 1U,
                                     mctx->eflags);
#line 2655
      dest_state = *(mctx->state_log + dest_str_idx);
#line 2656
      prev_nelem = (unsigned int )*(mctx->state_log + cur_str_idx) == (unsigned int )((void *)0) ? 0U : (*(mctx->state_log + cur_str_idx))->nodes.nelem;
#line 2659
      if ((unsigned int )dest_state == (unsigned int )((void *)0)) {
#line 2661
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)new_dest_nodes,
                                                                     context);
#line 2664
        if ((unsigned int )*(mctx->state_log + dest_str_idx) == (unsigned int )((void *)0) && (int )err != 0) {
#line 2666
          goto free_return;
        }
      } else {
#line 2671
        err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                     (re_node_set const   *)new_dest_nodes);
#line 2674
        if ((int )err != 0) {
#line 2676
          free((void *)dest_nodes.elems);
#line 2677
          goto free_return;
        }
#line 2679
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                                     context);
#line 2681
        free((void *)dest_nodes.elems);
#line 2682
        if ((unsigned int )*(mctx->state_log + dest_str_idx) == (unsigned int )((void *)0) && (int )err != 0) {
#line 2684
          goto free_return;
        }
      }
#line 2688
      if (subexp_len == 0U && (*(mctx->state_log + cur_str_idx))->nodes.nelem > prev_nelem) {
#line 2691
        err = check_subexp_matching_top(mctx, new_dest_nodes, cur_str_idx);
#line 2693
        if ((int )err != 0) {
#line 2694
          goto free_return;
        }
#line 2695
        err = transit_state_bkref(mctx, (re_node_set const   *)new_dest_nodes);
#line 2696
        if ((int )err != 0) {
#line 2697
          goto free_return;
        }
      }
      __Cont___0: 
#line 2639
      bkc_idx ++;
    }
    __Cont: 
#line 2607
    i ++;
  }
#line 2701
  err = (enum __anonenum_reg_errcode_t_7 )0;
  free_return: 
#line 2703
  return (err);
}
}
#line 2712 "regexec.c"
static reg_errcode_t get_subexp(re_match_context_t *mctx , Idx bkref_node , Idx bkref_str_idx ) 
{ re_dfa_t const   *dfa ;
  Idx subexp_num ;
  Idx sub_top_idx ;
  char const   *buf___0 ;
  Idx cache_idx ;
  Idx __cil_tmp ;
  struct re_backref_cache_entry  const  *entry ;
  struct re_backref_cache_entry  const  *__cil_tmp___0 ;
  reg_errcode_t err ;
  re_sub_match_top_t *sub_top ;
  re_sub_match_last_t *sub_last ;
  Idx sub_last_idx ;
  Idx sl_str ;
  Idx bkref_str_off ;
  regoff_t sl_str_diff ;
  int __cil_tmp___1 ;
  Idx cls_node ;
  regoff_t sl_str_off ;
  re_node_set const   *nodes ;
  Idx __cil_tmp___2 ;
  void *__cil_tmp___3 ;

  {
#line 2716
  dfa = mctx->dfa;
#line 2718
  buf___0 = (char const   *)mctx->input.mbs;
#line 2720
  __cil_tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, bkref_str_idx);
#line 2720
  cache_idx = __cil_tmp;
#line 2721
  if (cache_idx != 4294967295U) {
#line 2723
    entry = (struct re_backref_cache_entry  const  *)(mctx->bkref_ents + cache_idx);
#line 2725
    while (1) {
#line 2726
      if (entry->node == (unsigned int const   )bkref_node) {
#line 2727
        return ((enum __anonenum_reg_errcode_t_7 )0);
      }
#line 2725
      __cil_tmp___0 = entry;
#line 2725
      entry ++;
#line 2725
      if (! __cil_tmp___0->more) {
#line 2725
        break;
      }
    }
  }
#line 2731
  subexp_num = (dfa->nodes + bkref_node)->opr.idx;
#line 2734
  sub_top_idx = 0U;
#line 2734
  while (sub_top_idx < mctx->nsub_tops) {
#line 2737
    sub_top = *(mctx->sub_tops + sub_top_idx);
#line 2741
    if ((dfa->nodes + sub_top->node)->opr.idx != subexp_num) {
#line 2742
      goto __Cont;
    }
#line 2744
    sl_str = sub_top->str_idx;
#line 2745
    bkref_str_off = bkref_str_idx;
#line 2748
    sub_last_idx = 0U;
#line 2748
    while (sub_last_idx < sub_top->nlasts) {
#line 2751
      sub_last = *(sub_top->lasts + sub_last_idx);
#line 2752
      sl_str_diff = (int )(sub_last->str_idx - sl_str);
#line 2755
      if (sl_str_diff > 0) {
#line 2757
        if (bkref_str_off + (unsigned int )sl_str_diff > mctx->input.valid_len) {
#line 2760
          if (bkref_str_off + (unsigned int )sl_str_diff > mctx->input.len) {
#line 2761
            break;
          }
#line 2763
          err = clean_state_log_if_needed(mctx, bkref_str_off + (unsigned int )sl_str_diff);
#line 2766
          if ((int )err != 0) {
#line 2767
            return (err);
          }
#line 2768
          buf___0 = (char const   *)mctx->input.mbs;
        }
#line 2770
        __cil_tmp___1 = rpl_memcmp((void const   *)(buf___0 + bkref_str_off), (void const   *)(buf___0 + sl_str),
                                   (unsigned int )sl_str_diff);
#line 2770
        if (__cil_tmp___1 != 0) {
#line 2772
          break;
        }
      }
#line 2774
      bkref_str_off += (unsigned int )sl_str_diff;
#line 2775
      sl_str += (unsigned int )sl_str_diff;
#line 2776
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
#line 2781
      buf___0 = (char const   *)mctx->input.mbs;
#line 2783
      if ((int )err == 1) {
#line 2784
        goto __Cont___0;
      }
#line 2785
      if ((int )err != 0) {
#line 2786
        return (err);
      }
      __Cont___0: 
#line 2748
      sub_last_idx ++;
    }
#line 2789
    if (sub_last_idx < sub_top->nlasts) {
#line 2790
      goto __Cont;
    }
#line 2791
    if (sub_last_idx > 0U) {
#line 2792
      sl_str ++;
    }
#line 2794
    while (sl_str <= bkref_str_idx) {
#line 2799
      sl_str_off = (int )(sl_str - sub_top->str_idx);
#line 2802
      if (sl_str_off > 0) {
#line 2804
        if (bkref_str_off >= mctx->input.valid_len) {
#line 2807
          if (bkref_str_off >= mctx->input.len) {
#line 2808
            break;
          }
#line 2810
          err = extend_buffers(mctx);
#line 2811
          if ((int )err != 0) {
#line 2812
            return (err);
          }
#line 2814
          buf___0 = (char const   *)mctx->input.mbs;
        }
#line 2816
        __cil_tmp___2 = bkref_str_off;
#line 2816
        bkref_str_off ++;
#line 2816
        if ((int const   )*(buf___0 + __cil_tmp___2) != (int const   )*(buf___0 + (sl_str - 1U))) {
#line 2817
          break;
        }
      }
#line 2820
      if ((unsigned int )*(mctx->state_log + sl_str) == (unsigned int )((void *)0)) {
#line 2821
        goto __Cont___1;
      }
#line 2823
      nodes = (re_node_set const   *)(& (*(mctx->state_log + sl_str))->nodes);
#line 2824
      cls_node = find_subexp_node(dfa, nodes, subexp_num, 9);
#line 2826
      if (cls_node == 4294967295U) {
#line 2827
        goto __Cont___1;
      }
#line 2828
      if ((unsigned int )sub_top->path == (unsigned int )((void *)0)) {
#line 2830
        __cil_tmp___3 = rpl_calloc(sizeof(state_array_t ), (sl_str - sub_top->str_idx) + 1U);
#line 2830
        sub_top->path = (state_array_t *)__cil_tmp___3;
#line 2832
        if ((unsigned int )sub_top->path == (unsigned int )((void *)0)) {
#line 2833
          return ((enum __anonenum_reg_errcode_t_7 )12);
        }
      }
#line 2837
      err = check_arrival(mctx, sub_top->path, sub_top->node, sub_top->str_idx, cls_node,
                          sl_str, 9);
#line 2840
      if ((int )err == 1) {
#line 2841
        goto __Cont___1;
      }
#line 2842
      if ((int )err != 0) {
#line 2843
        return (err);
      }
#line 2844
      sub_last = match_ctx_add_sublast(sub_top, cls_node, sl_str);
#line 2845
      if ((unsigned int )sub_last == (unsigned int )((void *)0)) {
#line 2846
        return ((enum __anonenum_reg_errcode_t_7 )12);
      }
#line 2847
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
#line 2849
      if ((int )err == 1) {
#line 2850
        goto __Cont___1;
      }
      __Cont___1: 
#line 2794
      sl_str ++;
    }
    __Cont: 
#line 2734
    sub_top_idx ++;
  }
#line 2853
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 2862 "regexec.c"
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , Idx bkref_node ,
                                    Idx bkref_str ) 
{ reg_errcode_t err ;
  Idx to_idx ;
  reg_errcode_t __cil_tmp ;

  {
#line 2870
  err = check_arrival(mctx, & sub_last->path, sub_last->node, sub_last->str_idx, bkref_node,
                      bkref_str, 8);
#line 2873
  if ((int )err != 0) {
#line 2874
    return (err);
  }
#line 2875
  err = match_ctx_add_entry(mctx, bkref_node, bkref_str, (unsigned int )sub_top->str_idx,
                            sub_last->str_idx);
#line 2877
  if ((int )err != 0) {
#line 2878
    return (err);
  }
#line 2879
  to_idx = (bkref_str + sub_last->str_idx) - (unsigned int )sub_top->str_idx;
#line 2880
  __cil_tmp = clean_state_log_if_needed(mctx, to_idx);
#line 2880
  return (__cil_tmp);
}
}
#line 2891 "regexec.c"
static Idx find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , Idx subexp_idx ,
                            int type ) 
{ Idx cls_idx ;
  Idx cls_node ;
  re_token_t const   *node ;

  {
#line 2897
  cls_idx = 0U;
#line 2897
  while (cls_idx < (unsigned int )nodes->nelem) {
#line 2899
    cls_node = *(nodes->elems + cls_idx);
#line 2900
    node = (re_token_t const   *)(dfa->nodes + cls_node);
#line 2901
    if ((unsigned int const   )node->type == (unsigned int const   )type && node->opr.idx == (unsigned int const   )subexp_idx) {
#line 2903
      return (cls_node);
    }
#line 2897
    cls_idx ++;
  }
#line 2905
  return (4294967295U);
}
}
#line 2913 "regexec.c"
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   Idx top_node , Idx top_str , Idx last_node , Idx last_str ,
                                   int type ) 
{ re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx subexp_num ;
  Idx backup_cur_idx ;
  Idx str_idx ;
  Idx null_cnt ;
  re_dfastate_t *cur_state ;
  re_node_set *cur_nodes ;
  re_node_set next_nodes ;
  re_dfastate_t **backup_state_log ;
  unsigned int context ;
  re_dfastate_t **new_array ;
  Idx old_alloc ;
  Idx new_alloc ;
  void *__cil_tmp ;
  Idx __cil_tmp___0 ;

  {
#line 2918
  dfa = mctx->dfa;
#line 2919
  err = (enum __anonenum_reg_errcode_t_7 )0;
#line 2921
  cur_state = (re_dfastate_t *)((void *)0);
#line 2926
  subexp_num = (dfa->nodes + top_node)->opr.idx;
#line 2928
  if (path->alloc < (last_str + (unsigned int )mctx->max_mb_elem_len) + 1U) {
#line 2931
    old_alloc = path->alloc;
#line 2932
    new_alloc = ((old_alloc + last_str) + (unsigned int )mctx->max_mb_elem_len) + 1U;
#line 2933
    if (new_alloc < old_alloc || (((1U << 31) - 1U) * 2U + 1U) / sizeof(re_dfastate_t *) < new_alloc) {
#line 2935
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 2936
    __cil_tmp = rpl_realloc((void *)path->array, new_alloc * sizeof(re_dfastate_t *));
#line 2936
    new_array = (re_dfastate_t **)__cil_tmp;
#line 2937
    if ((unsigned int )new_array == (unsigned int )((void *)0)) {
#line 2938
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 2939
    path->array = new_array;
#line 2940
    path->alloc = new_alloc;
#line 2941
    memset((void *)(new_array + old_alloc), '\000', sizeof(re_dfastate_t *) * (path->alloc - old_alloc));
  }
#line 2945
  str_idx = path->next_idx ? path->next_idx : top_str;
#line 2948
  backup_state_log = mctx->state_log;
#line 2949
  backup_cur_idx = mctx->input.cur_idx;
#line 2950
  mctx->state_log = path->array;
#line 2951
  mctx->input.cur_idx = str_idx;
#line 2954
  context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1U,
                                 mctx->eflags);
#line 2955
  if (str_idx == top_str) {
#line 2957
    err = re_node_set_init_1(& next_nodes, top_node);
#line 2958
    if ((int )err != 0) {
#line 2959
      return (err);
    }
#line 2960
    err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
#line 2961
    if ((int )err != 0) {
#line 2963
      free((void *)next_nodes.elems);
#line 2964
      return (err);
    }
  } else {
#line 2969
    cur_state = *(mctx->state_log + str_idx);
#line 2970
    if (cur_state && cur_state->has_backref) {
#line 2972
      err = re_node_set_init_copy(& next_nodes, (re_node_set const   *)(& cur_state->nodes));
#line 2973
      if ((int )err != 0) {
#line 2974
        return (err);
      }
    } else {
#line 2977
      memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
    }
  }
#line 2979
  if (str_idx == top_str || (cur_state && cur_state->has_backref)) {
#line 2981
    if (next_nodes.nelem) {
#line 2983
      err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 2985
      if ((int )err != 0) {
#line 2987
        free((void *)next_nodes.elems);
#line 2988
        return (err);
      }
    }
#line 2991
    cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
#line 2992
    if ((unsigned int )cur_state == (unsigned int )((void *)0) && (int )err != 0) {
#line 2994
      free((void *)next_nodes.elems);
#line 2995
      return (err);
    }
#line 2997
    *(mctx->state_log + str_idx) = cur_state;
  }
#line 3000
  null_cnt = 0U;
#line 3000
  while (str_idx < last_str && null_cnt <= (unsigned int )mctx->max_mb_elem_len) {
#line 3002
    next_nodes.nelem = 0U;
#line 3003
    if (*(mctx->state_log + (str_idx + 1U))) {
#line 3005
      err = re_node_set_merge(& next_nodes, (re_node_set const   *)(& (*(mctx->state_log + (str_idx + 1U)))->nodes));
#line 3007
      if ((int )err != 0) {
#line 3009
        free((void *)next_nodes.elems);
#line 3010
        return (err);
      }
    }
#line 3013
    if (cur_state) {
#line 3015
      err = check_arrival_add_next_nodes(mctx, str_idx, & cur_state->non_eps_nodes,
                                         & next_nodes);
#line 3018
      if ((int )err != 0) {
#line 3020
        free((void *)next_nodes.elems);
#line 3021
        return (err);
      }
    }
#line 3024
    str_idx ++;
#line 3025
    if (next_nodes.nelem) {
#line 3027
      err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
#line 3028
      if ((int )err != 0) {
#line 3030
        free((void *)next_nodes.elems);
#line 3031
        return (err);
      }
#line 3033
      err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 3035
      if ((int )err != 0) {
#line 3037
        free((void *)next_nodes.elems);
#line 3038
        return (err);
      }
    }
#line 3041
    context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1U,
                                   mctx->eflags);
#line 3042
    cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
#line 3043
    if ((unsigned int )cur_state == (unsigned int )((void *)0) && (int )err != 0) {
#line 3045
      free((void *)next_nodes.elems);
#line 3046
      return (err);
    }
#line 3048
    *(mctx->state_log + str_idx) = cur_state;
#line 3049
    null_cnt = (unsigned int )cur_state == (unsigned int )((void *)0) ? null_cnt + 1U : 0U;
  }
#line 3051
  free((void *)next_nodes.elems);
#line 3052
  cur_nodes = (unsigned int )*(mctx->state_log + last_str) == (unsigned int )((void *)0) ? (re_node_set *)((void *)0) : & (*(mctx->state_log + last_str))->nodes;
#line 3054
  path->next_idx = str_idx;
#line 3057
  mctx->state_log = backup_state_log;
#line 3058
  mctx->input.cur_idx = backup_cur_idx;
#line 3061
  if ((unsigned int )cur_nodes != (unsigned int )((void *)0)) {
#line 3061
    __cil_tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, last_node);
#line 3061
    if (__cil_tmp___0) {
#line 3062
      return ((enum __anonenum_reg_errcode_t_7 )0);
    }
  }
#line 3064
  return ((enum __anonenum_reg_errcode_t_7 )1);
}
}
#line 3075 "regexec.c"
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , Idx str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) 
{ re_dfa_t const   *dfa ;
  _Bool ok ;
  Idx cur_idx ;
  reg_errcode_t err ;
  re_node_set union_set ;
  int naccepted ;
  Idx cur_node ;
  re_dfastate_t *dest_state ;
  Idx next_node ;
  Idx next_idx ;
  _Bool __cil_tmp ;

  {
#line 3080
  dfa = mctx->dfa;
#line 3083
  err = (enum __anonenum_reg_errcode_t_7 )0;
#line 3085
  memset((void *)(& union_set), '\000', sizeof(re_node_set ));
#line 3086
  cur_idx = 0U;
#line 3086
  while (cur_idx < cur_nodes->nelem) {
#line 3088
    naccepted = 0;
#line 3089
    cur_node = *(cur_nodes->elems + cur_idx);
#line 3096
    if ((dfa->nodes + cur_node)->accept_mb) {
#line 3098
      naccepted = check_node_accept_bytes(dfa, cur_node, (re_string_t const   *)(& mctx->input),
                                          str_idx);
#line 3100
      if (naccepted > 1) {
#line 3103
        next_node = *(dfa->nexts + cur_node);
#line 3104
        next_idx = str_idx + (unsigned int )naccepted;
#line 3105
        dest_state = *(mctx->state_log + next_idx);
#line 3106
        union_set.nelem = 0U;
#line 3107
        if (dest_state) {
#line 3109
          err = re_node_set_merge(& union_set, (re_node_set const   *)(& dest_state->nodes));
#line 3110
          if ((int )err != 0) {
#line 3112
            free((void *)union_set.elems);
#line 3113
            return (err);
          }
        }
#line 3116
        ok = re_node_set_insert(& union_set, next_node);
#line 3117
        if (! ok) {
#line 3119
          free((void *)union_set.elems);
#line 3120
          return ((enum __anonenum_reg_errcode_t_7 )12);
        }
#line 3122
        *(mctx->state_log + next_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
#line 3124
        if ((unsigned int )*(mctx->state_log + next_idx) == (unsigned int )((void *)0) && (int )err != 0) {
#line 3127
          free((void *)union_set.elems);
#line 3128
          return (err);
        }
      }
    }
#line 3133
    if (naccepted) {
#line 3133
      goto _L;
    } else {
#line 3133
      __cil_tmp = check_node_accept((re_match_context_t const   *)mctx, (re_token_t const   *)(dfa->nodes + cur_node),
                                    str_idx);
#line 3133
      if (__cil_tmp) {
        _L: 
#line 3136
        ok = re_node_set_insert(next_nodes, *(dfa->nexts + cur_node));
#line 3137
        if (! ok) {
#line 3139
          free((void *)union_set.elems);
#line 3140
          return ((enum __anonenum_reg_errcode_t_7 )12);
        }
      }
    }
#line 3086
    cur_idx ++;
  }
#line 3144
  free((void *)union_set.elems);
#line 3145
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3154 "regexec.c"
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              Idx ex_subexp , int type ) 
{ reg_errcode_t err ;
  Idx idx ;
  Idx outside_node ;
  re_node_set new_nodes ;
  Idx cur_node ;
  re_node_set const   *eclosure ;

  {
#line 3165
  err = re_node_set_alloc(& new_nodes, cur_nodes->nelem);
#line 3166
  if ((int )err != 0) {
#line 3167
    return (err);
  }
#line 3171
  idx = 0U;
#line 3171
  while (idx < cur_nodes->nelem) {
#line 3173
    cur_node = *(cur_nodes->elems + idx);
#line 3174
    eclosure = (re_node_set const   *)(dfa->eclosures + cur_node);
#line 3175
    outside_node = find_subexp_node(dfa, eclosure, ex_subexp, type);
#line 3176
    if (outside_node == 4294967295U) {
#line 3179
      err = re_node_set_merge(& new_nodes, eclosure);
#line 3180
      if ((int )err != 0) {
#line 3182
        free((void *)new_nodes.elems);
#line 3183
        return (err);
      }
    } else {
#line 3189
      err = check_arrival_expand_ecl_sub(dfa, & new_nodes, cur_node, ex_subexp, type);
#line 3191
      if ((int )err != 0) {
#line 3193
        free((void *)new_nodes.elems);
#line 3194
        return (err);
      }
    }
#line 3171
    idx ++;
  }
#line 3198
  free((void *)cur_nodes->elems);
#line 3199
  *cur_nodes = new_nodes;
#line 3200
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3207 "regexec.c"
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                  Idx target , Idx ex_subexp , int type ) 
{ Idx cur_node ;
  _Bool ok ;
  reg_errcode_t err ;
  Idx __cil_tmp ;

  {
#line 3213
  cur_node = target;
#line 3213
  while (1) {
#line 3213
    __cil_tmp = re_node_set_contains((re_node_set const   *)dst_nodes, cur_node);
#line 3213
    if (__cil_tmp) {
#line 3213
      break;
    }
#line 3217
    if ((unsigned int )(dfa->nodes + cur_node)->type == (unsigned int )type && (dfa->nodes + cur_node)->opr.idx == ex_subexp) {
#line 3220
      if (type == 9) {
#line 3222
        ok = re_node_set_insert(dst_nodes, cur_node);
#line 3223
        if (! ok) {
#line 3224
          return ((enum __anonenum_reg_errcode_t_7 )12);
        }
      }
#line 3226
      break;
    }
#line 3228
    ok = re_node_set_insert(dst_nodes, cur_node);
#line 3229
    if (! ok) {
#line 3230
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 3231
    if ((dfa->edests + cur_node)->nelem == 0U) {
#line 3232
      break;
    }
#line 3233
    if ((dfa->edests + cur_node)->nelem == 2U) {
#line 3236
      err = check_arrival_expand_ecl_sub(dfa, dst_nodes, *((dfa->edests + cur_node)->elems + 1),
                                         ex_subexp, type);
#line 3239
      if ((int )err != 0) {
#line 3240
        return (err);
      }
    }
#line 3242
    cur_node = *((dfa->edests + cur_node)->elems + 0);
  }
#line 3244
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3252 "regexec.c"
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        Idx cur_str , Idx subexp_num , int type ) 
{ re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx cache_idx_start ;
  Idx __cil_tmp ;
  struct re_backref_cache_entry *ent ;
  Idx to_idx ;
  Idx next_node ;
  Idx __cil_tmp___0 ;
  re_node_set new_dests ;
  reg_errcode_t err2 ;
  reg_errcode_t err3 ;
  Idx __cil_tmp___1 ;
  re_node_set union_set ;
  _Bool ok ;
  Idx __cil_tmp___2 ;
  struct re_backref_cache_entry *__cil_tmp___3 ;

  {
#line 3257
  dfa = mctx->dfa;
#line 3259
  __cil_tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, cur_str);
#line 3259
  cache_idx_start = __cil_tmp;
#line 3262
  if (cache_idx_start == 4294967295U) {
#line 3263
    return ((enum __anonenum_reg_errcode_t_7 )0);
  }
  restart: 
#line 3266
  ent = mctx->bkref_ents + cache_idx_start;
#line 3267
  while (1) {
#line 3272
    __cil_tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, ent->node);
#line 3272
    if (! __cil_tmp___0) {
#line 3273
      goto __Cont;
    }
#line 3275
    to_idx = (cur_str + ent->subexp_to) - ent->subexp_from;
#line 3278
    if (to_idx == cur_str) {
#line 3284
      next_node = *((dfa->edests + ent->node)->elems + 0);
#line 3285
      __cil_tmp___1 = re_node_set_contains((re_node_set const   *)cur_nodes, next_node);
#line 3285
      if (__cil_tmp___1) {
#line 3286
        goto __Cont;
      }
#line 3287
      err = re_node_set_init_1(& new_dests, next_node);
#line 3288
      err2 = check_arrival_expand_ecl(dfa, & new_dests, subexp_num, type);
#line 3289
      err3 = re_node_set_merge(cur_nodes, (re_node_set const   *)(& new_dests));
#line 3290
      free((void *)new_dests.elems);
#line 3291
      if (((int )err != 0 || (int )err2 != 0) || (int )err3 != 0) {
#line 3294
        err = (enum __anonenum_reg_errcode_t_7 )((int )err != 0 ? (int )err : ((int )err2 != 0 ? (int )err2 : (int )err3));
#line 3296
        return (err);
      }
#line 3299
      goto restart;
    } else {
#line 3304
      next_node = *(dfa->nexts + ent->node);
#line 3305
      if (*(mctx->state_log + to_idx)) {
#line 3308
        __cil_tmp___2 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes),
                                             next_node);
#line 3308
        if (__cil_tmp___2) {
#line 3310
          goto __Cont;
        }
#line 3311
        err = re_node_set_init_copy(& union_set, (re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes));
#line 3313
        ok = re_node_set_insert(& union_set, next_node);
#line 3314
        if ((int )err != 0 || ! ok) {
#line 3316
          free((void *)union_set.elems);
#line 3317
          err = (enum __anonenum_reg_errcode_t_7 )((int )err != 0 ? (int )err : 12);
#line 3318
          return (err);
        }
      } else {
#line 3323
        err = re_node_set_init_1(& union_set, next_node);
#line 3324
        if ((int )err != 0) {
#line 3325
          return (err);
        }
      }
#line 3327
      *(mctx->state_log + to_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
#line 3328
      free((void *)union_set.elems);
#line 3329
      if ((unsigned int )*(mctx->state_log + to_idx) == (unsigned int )((void *)0) && (int )err != 0) {
#line 3331
        return (err);
      }
    }
    __Cont: 
#line 3267
    __cil_tmp___3 = ent;
#line 3267
    ent ++;
#line 3267
    if (! __cil_tmp___3->more) {
#line 3267
      break;
    }
  }
#line 3335
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 3341 "regexec.c"
static _Bool build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state ) 
{ reg_errcode_t err ;
  Idx i ;
  Idx j ;
  int ch ;
  _Bool need_word_trtable ;
  bitset_word_t elem ;
  bitset_word_t mask ;
  _Bool dests_node_malloced ;
  _Bool dest_states_malloced ;
  Idx ndests ;
  re_dfastate_t **trtable ;
  re_dfastate_t **dest_states ;
  re_dfastate_t **dest_states_word ;
  re_dfastate_t **dest_states_nl ;
  re_node_set follows ;
  re_node_set *dests_node ;
  bitset_t *dests_ch ;
  bitset_t acceptable ;
  struct dests_alloc *dests_alloc ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  struct re_dfastate_t **__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  void *__cil_tmp___3 ;
  void *__cil_tmp___4 ;
  Idx next_node ;
  struct re_dfastate_t **__cil_tmp___5 ;
  void *__cil_tmp___6 ;
  struct re_dfastate_t **__cil_tmp___7 ;
  void *__cil_tmp___8 ;
  _Bool __cil_tmp___9 ;
  _Bool __cil_tmp___10 ;

  {
#line 3348
  need_word_trtable = (_Bool)0;
#line 3350
  dests_node_malloced = (_Bool)0;
#line 3351
  dest_states_malloced = (_Bool)0;
#line 3354
  dest_states = (re_dfastate_t **)((void *)0);
#line 3369
  if (sizeof(struct dests_alloc ) < 4032U) {
#line 3370
    __cil_tmp = __builtin_alloca(sizeof(struct dests_alloc ));
#line 3370
    dests_alloc = (struct dests_alloc *)__cil_tmp;
  } else {
#line 3373
    __cil_tmp___0 = rpl_malloc(sizeof(struct dests_alloc ));
#line 3373
    dests_alloc = (struct dests_alloc *)__cil_tmp___0;
#line 3374
    if ((unsigned int )dests_alloc == (unsigned int )((void *)0)) {
#line 3375
      return ((_Bool)0);
    }
#line 3376
    dests_node_malloced = (_Bool)1;
  }
#line 3378
  dests_node = dests_alloc->dests_node;
#line 3379
  dests_ch = dests_alloc->dests_ch;
#line 3382
  __cil_tmp___1 = (struct re_dfastate_t **)((void *)0);
#line 3382
  state->trtable = __cil_tmp___1;
#line 3382
  state->word_trtable = __cil_tmp___1;
#line 3386
  ndests = group_nodes_into_DFAstates(dfa, (re_dfastate_t const   *)state, dests_node,
                                      dests_ch);
#line 3387
  if (! (ndests - 1U < 4294967293U)) {
#line 3389
    if (dests_node_malloced) {
#line 3390
      free((void *)dests_alloc);
    }
#line 3391
    if (ndests == 0U) {
#line 3393
      __cil_tmp___2 = rpl_calloc(sizeof(re_dfastate_t *), 256U);
#line 3393
      state->trtable = (re_dfastate_t **)__cil_tmp___2;
#line 3395
      return ((_Bool)1);
    }
#line 3397
    return ((_Bool)0);
  }
#line 3400
  err = re_node_set_alloc(& follows, ndests + 1U);
#line 3401
  if ((int )err != 0) {
#line 3402
    goto out_free;
  }
#line 3405
  if (((((1U << 31) - 1U) * 2U + 1U) - (sizeof(re_node_set ) + sizeof(bitset_t )) * 256U) / (3U * sizeof(re_dfastate_t *)) < ndests) {
#line 3409
    goto out_free;
  }
#line 3411
  if ((sizeof(re_node_set ) + sizeof(bitset_t )) * 256U + (ndests * 3U) * sizeof(re_dfastate_t *) < 4032U) {
#line 3413
    __cil_tmp___3 = __builtin_alloca((ndests * 3U) * sizeof(re_dfastate_t *));
#line 3413
    dest_states = (re_dfastate_t **)__cil_tmp___3;
  } else {
#line 3417
    __cil_tmp___4 = rpl_malloc((ndests * 3U) * sizeof(re_dfastate_t *));
#line 3417
    dest_states = (re_dfastate_t **)__cil_tmp___4;
#line 3419
    if ((unsigned int )dest_states == (unsigned int )((void *)0)) {
      out_free: 
#line 3422
      if (dest_states_malloced) {
#line 3423
        free((void *)dest_states);
      }
#line 3424
      free((void *)follows.elems);
#line 3425
      i = 0U;
#line 3425
      while (i < ndests) {
#line 3426
        free((void *)(dests_node + i)->elems);
#line 3425
        i ++;
      }
#line 3427
      if (dests_node_malloced) {
#line 3428
        free((void *)dests_alloc);
      }
#line 3429
      return ((_Bool)0);
    }
#line 3431
    dest_states_malloced = (_Bool)1;
  }
#line 3433
  dest_states_word = dest_states + ndests;
#line 3434
  dest_states_nl = dest_states_word + ndests;
#line 3435
  bitset_empty(acceptable);
#line 3438
  i = 0U;
#line 3438
  while (i < ndests) {
#line 3441
    follows.nelem = 0U;
#line 3443
    j = 0U;
#line 3443
    while (j < (dests_node + i)->nelem) {
#line 3445
      next_node = *(dfa->nexts + *((dests_node + i)->elems + j));
#line 3446
      if (next_node != 4294967295U) {
#line 3448
        err = re_node_set_merge(& follows, (re_node_set const   *)(dfa->eclosures + next_node));
#line 3449
        if ((int )err != 0) {
#line 3450
          goto out_free;
        }
      }
#line 3443
      j ++;
    }
#line 3453
    *(dest_states + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                  0U);
#line 3454
    if ((unsigned int )*(dest_states + i) == (unsigned int )((void *)0) && (int )err != 0) {
#line 3455
      goto out_free;
    }
#line 3458
    if ((*(dest_states + i))->has_constraint) {
#line 3460
      *(dest_states_word + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                         1U);
#line 3462
      if ((unsigned int )*(dest_states_word + i) == (unsigned int )((void *)0) && (int )err != 0) {
#line 3463
        goto out_free;
      }
#line 3465
      if ((unsigned int )*(dest_states + i) != (unsigned int )*(dest_states_word + i) && dfa->mb_cur_max > 1) {
#line 3466
        need_word_trtable = (_Bool)1;
      }
#line 3468
      *(dest_states_nl + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                       (unsigned int )(1 << 1));
#line 3470
      if ((unsigned int )*(dest_states_nl + i) == (unsigned int )((void *)0) && (int )err != 0) {
#line 3471
        goto out_free;
      }
    } else {
#line 3475
      *(dest_states_word + i) = *(dest_states + i);
#line 3476
      *(dest_states_nl + i) = *(dest_states + i);
    }
#line 3478
    bitset_merge(acceptable, *(dests_ch + i));
#line 3438
    i ++;
  }
#line 3481
  if (! need_word_trtable) {
#line 3487
    __cil_tmp___6 = rpl_calloc(sizeof(re_dfastate_t *), 256U);
#line 3487
    __cil_tmp___5 = (re_dfastate_t **)__cil_tmp___6;
#line 3487
    state->trtable = __cil_tmp___5;
#line 3487
    trtable = __cil_tmp___5;
#line 3489
    if ((unsigned int )trtable == (unsigned int )((void *)0)) {
#line 3490
      goto out_free;
    }
#line 3493
    i = 0U;
#line 3493
    while (i < 8U) {
#line 3494
      ch = (int )(i * 32U);
#line 3494
      elem = acceptable[i];
#line 3494
      mask = 1UL;
#line 3494
      while (elem) {
#line 3497
        if (elem & 1UL) {
#line 3501
          j = 0U;
#line 3501
          while (((*(dests_ch + j))[i] & mask) == 0UL) {
#line 3501
            j ++;
          }
#line 3505
          if (dfa->word_char[i] & mask) {
#line 3506
            *(trtable + ch) = *(dest_states_word + j);
          } else {
#line 3508
            *(trtable + ch) = *(dest_states + j);
          }
        }
#line 3494
        mask <<= 1;
#line 3494
        elem >>= 1;
#line 3494
        ch ++;
      }
#line 3493
      i ++;
    }
  } else {
#line 3518
    __cil_tmp___8 = rpl_calloc(sizeof(re_dfastate_t *), 512U);
#line 3518
    __cil_tmp___7 = (re_dfastate_t **)__cil_tmp___8;
#line 3518
    state->word_trtable = __cil_tmp___7;
#line 3518
    trtable = __cil_tmp___7;
#line 3520
    if ((unsigned int )trtable == (unsigned int )((void *)0)) {
#line 3521
      goto out_free;
    }
#line 3524
    i = 0U;
#line 3524
    while (i < 8U) {
#line 3525
      ch = (int )(i * 32U);
#line 3525
      elem = acceptable[i];
#line 3525
      mask = 1UL;
#line 3525
      while (elem) {
#line 3528
        if (elem & 1UL) {
#line 3532
          j = 0U;
#line 3532
          while (((*(dests_ch + j))[i] & mask) == 0UL) {
#line 3532
            j ++;
          }
#line 3536
          *(trtable + ch) = *(dest_states + j);
#line 3537
          *(trtable + (ch + 256)) = *(dest_states_word + j);
        }
#line 3525
        mask <<= 1;
#line 3525
        elem >>= 1;
#line 3525
        ch ++;
      }
#line 3524
      i ++;
    }
  }
#line 3542
  __cil_tmp___10 = bitset_contain(acceptable, (unsigned int )'\n');
#line 3542
  if (__cil_tmp___10) {
#line 3545
    j = 0U;
#line 3545
    while (j < ndests) {
#line 3546
      __cil_tmp___9 = bitset_contain(*(dests_ch + j), (unsigned int )'\n');
#line 3546
      if (__cil_tmp___9) {
#line 3549
        *(trtable + 10) = *(dest_states_nl + j);
#line 3550
        if (need_word_trtable) {
#line 3551
          *(trtable + 266) = *(dest_states_nl + j);
        }
#line 3554
        break;
      }
#line 3545
      j ++;
    }
  }
#line 3558
  if (dest_states_malloced) {
#line 3559
    free((void *)dest_states);
  }
#line 3561
  free((void *)follows.elems);
#line 3562
  i = 0U;
#line 3562
  while (i < ndests) {
#line 3563
    free((void *)(dests_node + i)->elems);
#line 3562
    i ++;
  }
#line 3565
  if (dests_node_malloced) {
#line 3566
    free((void *)dests_alloc);
  }
#line 3568
  return ((_Bool)1);
}
}
#line 3576 "regexec.c"
static Idx group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) 
{ reg_errcode_t err ;
  _Bool ok ;
  Idx i ;
  Idx j ;
  Idx k ;
  Idx ndests ;
  bitset_t accepts ;
  re_node_set const   *cur_nodes ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  _Bool accepts_newline ;
  _Bool __cil_tmp ;
  bitset_word_t any_set ;
  unsigned long __cil_tmp___0 ;
  unsigned long __cil_tmp___1 ;
  bitset_word_t any_set___0 ;
  unsigned long __cil_tmp___2 ;
  unsigned long __cil_tmp___3 ;
  bitset_t intersec ;
  bitset_t remains ;
  bitset_word_t has_intersec ;
  bitset_word_t not_subset ;
  bitset_word_t not_consumed ;
  _Bool __cil_tmp___4 ;
  bitset_word_t __cil_tmp___5 ;
  bitset_word_t __cil_tmp___6 ;
  bitset_word_t __cil_tmp___7 ;

  {
#line 3586
  cur_nodes = & state->nodes;
#line 3587
  bitset_empty(accepts);
#line 3588
  ndests = 0U;
#line 3591
  i = 0U;
#line 3591
  while (i < (unsigned int )cur_nodes->nelem) {
#line 3593
    node = (re_token_t *)(dfa->nodes + *(cur_nodes->elems + i));
#line 3594
    type = node->type;
#line 3595
    constraint = node->constraint;
#line 3598
    if ((unsigned int )type == 1U) {
#line 3599
      bitset_set(accepts, (unsigned int )node->opr.c);
    } else
#line 3600
    if ((unsigned int )type == 3U) {
#line 3602
      bitset_merge(accepts, node->opr.sbcset);
    } else
#line 3604
    if ((unsigned int )type == 5U) {
#line 3607
      if (dfa->mb_cur_max > 1) {
#line 3608
        bitset_merge(accepts, (bitset_word_t *)dfa->sb_char);
      } else {
#line 3611
        bitset_set_all(accepts);
      }
#line 3612
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3613
        bitset_clear(accepts, (unsigned int )'\n');
      }
#line 3614
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3615
        bitset_clear(accepts, (unsigned int )'\000');
      }
    } else
#line 3618
    if ((unsigned int )type == 7U) {
#line 3621
      memset((void *)(accepts), -1, 16U);
#line 3624
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3625
        bitset_clear(accepts, (unsigned int )'\n');
      }
#line 3626
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3627
        bitset_clear(accepts, (unsigned int )'\000');
      }
    } else {
#line 3631
      goto __Cont;
    }
#line 3635
    if (constraint) {
#line 3637
      if (constraint & 32U) {
#line 3639
        __cil_tmp = bitset_contain(accepts, (unsigned int )'\n');
#line 3639
        accepts_newline = __cil_tmp;
#line 3640
        bitset_empty(accepts);
#line 3641
        if (accepts_newline) {
#line 3642
          bitset_set(accepts, (unsigned int )'\n');
        } else {
#line 3644
          goto __Cont;
        }
      }
#line 3646
      if (constraint & 128U) {
#line 3648
        bitset_empty(accepts);
#line 3649
        goto __Cont;
      }
#line 3652
      if (constraint & 4U) {
#line 3654
        any_set = 0UL;
#line 3655
        if ((unsigned int )type == 1U && ! node->word_char) {
#line 3657
          bitset_empty(accepts);
#line 3658
          goto __Cont;
        }
#line 3661
        if (dfa->mb_cur_max > 1) {
#line 3662
          j = 0U;
#line 3662
          while (j < 8U) {
#line 3663
            __cil_tmp___0 = accepts[j] & (dfa->word_char[j] | ~ *(dfa->sb_char + j));
#line 3663
            accepts[j] = __cil_tmp___0;
#line 3663
            any_set |= __cil_tmp___0;
#line 3662
            j ++;
          }
        } else {
#line 3666
          j = 0U;
#line 3666
          while (j < 8U) {
#line 3667
            __cil_tmp___1 = accepts[j] & dfa->word_char[j];
#line 3667
            accepts[j] = __cil_tmp___1;
#line 3667
            any_set |= __cil_tmp___1;
#line 3666
            j ++;
          }
        }
#line 3668
        if (! any_set) {
#line 3669
          goto __Cont;
        }
      }
#line 3671
      if (constraint & 8U) {
#line 3673
        any_set___0 = 0UL;
#line 3674
        if ((unsigned int )type == 1U && node->word_char) {
#line 3676
          bitset_empty(accepts);
#line 3677
          goto __Cont;
        }
#line 3680
        if (dfa->mb_cur_max > 1) {
#line 3681
          j = 0U;
#line 3681
          while (j < 8U) {
#line 3682
            __cil_tmp___2 = accepts[j] & ~ (dfa->word_char[j] & *(dfa->sb_char + j));
#line 3682
            accepts[j] = __cil_tmp___2;
#line 3682
            any_set___0 |= __cil_tmp___2;
#line 3681
            j ++;
          }
        } else {
#line 3685
          j = 0U;
#line 3685
          while (j < 8U) {
#line 3686
            __cil_tmp___3 = accepts[j] & ~ dfa->word_char[j];
#line 3686
            accepts[j] = __cil_tmp___3;
#line 3686
            any_set___0 |= __cil_tmp___3;
#line 3685
            j ++;
          }
        }
#line 3687
        if (! any_set___0) {
#line 3688
          goto __Cont;
        }
      }
    }
#line 3694
    j = 0U;
#line 3694
    while (j < ndests) {
#line 3702
      if ((unsigned int )type == 1U) {
#line 3702
        __cil_tmp___4 = bitset_contain(*(dests_ch + j), (unsigned int )node->opr.c);
#line 3702
        if (! __cil_tmp___4) {
#line 3703
          goto __Cont___0;
        }
      }
#line 3706
      has_intersec = 0UL;
#line 3707
      k = 0U;
#line 3707
      while (k < 8U) {
#line 3708
        __cil_tmp___5 = accepts[k] & (*(dests_ch + j))[k];
#line 3708
        intersec[k] = __cil_tmp___5;
#line 3708
        has_intersec |= __cil_tmp___5;
#line 3707
        k ++;
      }
#line 3710
      if (! has_intersec) {
#line 3711
        goto __Cont___0;
      }
#line 3714
      not_consumed = 0UL;
#line 3714
      not_subset = not_consumed;
#line 3715
      k = 0U;
#line 3715
      while (k < 8U) {
#line 3717
        __cil_tmp___6 = ~ accepts[k] & (*(dests_ch + j))[k];
#line 3717
        remains[k] = __cil_tmp___6;
#line 3717
        not_subset |= __cil_tmp___6;
#line 3718
        __cil_tmp___7 = accepts[k] & ~ (*(dests_ch + j))[k];
#line 3718
        accepts[k] = __cil_tmp___7;
#line 3718
        not_consumed |= __cil_tmp___7;
#line 3715
        k ++;
      }
#line 3723
      if (not_subset) {
#line 3725
        bitset_copy(*(dests_ch + ndests), remains);
#line 3726
        bitset_copy(*(dests_ch + j), intersec);
#line 3727
        err = re_node_set_init_copy(dests_node + ndests, (re_node_set const   *)(dests_node + j));
#line 3728
        if ((int )err != 0) {
#line 3729
          goto error_return;
        }
#line 3730
        ndests ++;
      }
#line 3734
      ok = re_node_set_insert(dests_node + j, *(cur_nodes->elems + i));
#line 3735
      if (! ok) {
#line 3736
        goto error_return;
      }
#line 3739
      if (! not_consumed) {
#line 3740
        break;
      }
      __Cont___0: 
#line 3694
      j ++;
    }
#line 3743
    if (j == ndests) {
#line 3745
      bitset_copy(*(dests_ch + ndests), accepts);
#line 3746
      err = re_node_set_init_1(dests_node + ndests, *(cur_nodes->elems + i));
#line 3747
      if ((int )err != 0) {
#line 3748
        goto error_return;
      }
#line 3749
      ndests ++;
#line 3750
      bitset_empty(accepts);
    }
    __Cont: 
#line 3591
    i ++;
  }
#line 3753
  return (ndests);
  error_return: 
#line 3755
  j = 0U;
#line 3755
  while (j < ndests) {
#line 3756
    free((void *)(dests_node + j)->elems);
#line 3755
    j ++;
  }
#line 3757
  return (4294967295U);
}
}
#line 3769 "regexec.c"
static int check_node_accept_bytes(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                   Idx str_idx ) 
{ re_token_t const   *node ;
  int char_len ;
  int elem_len ;
  Idx i ;
  unsigned char c ;
  unsigned char d ;
  re_charset_t const   *cset ;
  int match_len ;
  wchar_t wc ;
  wint_t __cil_tmp ;
  wint_t __cil_tmp___0 ;
  wctype_t wt ;
  int __cil_tmp___1 ;
  wchar_t cmp_buf[6] ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 3774
  node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 3778
  if ((unsigned int const   )node->type == 7U) {
#line 3780
    c = *(input->mbs + str_idx);
#line 3781
    if ((int )c < 194) {
#line 3782
      return (0);
    }
#line 3784
    if (str_idx + 2U > (unsigned int )input->len) {
#line 3785
      return (0);
    }
#line 3787
    d = *(input->mbs + (str_idx + 1U));
#line 3788
    if ((int )c < 224) {
#line 3789
      return ((int )d < 128 || (int )d > 191 ? 0 : 2);
    } else
#line 3790
    if ((int )c < 240) {
#line 3792
      char_len = 3;
#line 3793
      if ((int )c == 224 && (int )d < 160) {
#line 3794
        return (0);
      }
    } else
#line 3796
    if ((int )c < 248) {
#line 3798
      char_len = 4;
#line 3799
      if ((int )c == 240 && (int )d < 144) {
#line 3800
        return (0);
      }
    } else
#line 3802
    if ((int )c < 252) {
#line 3804
      char_len = 5;
#line 3805
      if ((int )c == 248 && (int )d < 136) {
#line 3806
        return (0);
      }
    } else
#line 3808
    if ((int )c < 254) {
#line 3810
      char_len = 6;
#line 3811
      if ((int )c == 252 && (int )d < 132) {
#line 3812
        return (0);
      }
    } else {
#line 3815
      return (0);
    }
#line 3817
    if (str_idx + (unsigned int )char_len > (unsigned int )input->len) {
#line 3818
      return (0);
    }
#line 3820
    i = 1U;
#line 3820
    while (i < (unsigned int )char_len) {
#line 3822
      d = *(input->mbs + (str_idx + i));
#line 3823
      if ((int )d < 128 || (int )d > 191) {
#line 3824
        return (0);
      }
#line 3820
      i ++;
    }
#line 3826
    return (char_len);
  }
#line 3829
  char_len = re_string_char_size_at(input, str_idx);
#line 3830
  if ((unsigned int const   )node->type == 5U) {
#line 3832
    if (char_len <= 1) {
#line 3833
      return (0);
    }
#line 3837
    if ((! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) && (int )*(input->mbs + str_idx) == 10) || (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) && (int )*(input->mbs + str_idx) == 0)) {
#line 3841
      return (0);
    }
#line 3842
    return (char_len);
  }
#line 3845
  elem_len = re_string_elem_size_at(input, str_idx);
#line 3846
  if ((elem_len <= 1 && char_len <= 1) || char_len == 0) {
#line 3847
    return (0);
  }
#line 3849
  if ((unsigned int const   )node->type == 6U) {
#line 3851
    cset = (re_charset_t const   *)node->opr.mbcset;
#line 3858
    match_len = 0;
#line 3859
    if ((cset->nranges || cset->nchar_classes) || cset->nmbchars) {
#line 3859
      __cil_tmp = re_string_wchar_at(input, str_idx);
#line 3859
      __cil_tmp___0 = __cil_tmp;
    } else {
#line 3859
      __cil_tmp___0 = 0;
    }
#line 3859
    wc = (short )__cil_tmp___0;
#line 3863
    i = 0U;
#line 3863
    while (i < (unsigned int )cset->nmbchars) {
#line 3864
      if ((int )wc == (int )*(cset->mbchars + i)) {
#line 3866
        match_len = char_len;
#line 3867
        goto check_node_accept_bytes_match;
      }
#line 3863
      i ++;
    }
#line 3870
    i = 0U;
#line 3870
    while (i < (unsigned int )cset->nchar_classes) {
#line 3872
      wt = *(cset->char_classes + i);
#line 3873
      __cil_tmp___1 = iswctype((int )wc, wt);
#line 3873
      if (__cil_tmp___1) {
#line 3875
        match_len = char_len;
#line 3876
        goto check_node_accept_bytes_match;
      }
#line 3870
      i ++;
    }
#line 3975
    cmp_buf[0] = (short)0;
#line 3975
    cmp_buf[1] = (short)0;
#line 3975
    cmp_buf[2] = (short)0;
#line 3975
    cmp_buf[3] = (short)0;
#line 3975
    cmp_buf[4] = (short)0;
#line 3975
    cmp_buf[5] = (short)0;
#line 3976
    cmp_buf[2] = wc;
#line 3978
    i = 0U;
#line 3978
    while (i < (unsigned int )cset->nranges) {
#line 3980
      cmp_buf[0] = *(cset->range_starts + i);
#line 3981
      cmp_buf[4] = *(cset->range_ends + i);
#line 3982
      __cil_tmp___2 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
#line 3982
      if (__cil_tmp___2 <= 0) {
#line 3982
        __cil_tmp___3 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
#line 3982
        if (__cil_tmp___3 <= 0) {
#line 3985
          match_len = char_len;
#line 3986
          goto check_node_accept_bytes_match;
        }
      }
#line 3978
      i ++;
    }
    check_node_accept_bytes_match: 
#line 3991
    if (! cset->non_match) {
#line 3992
      return (match_len);
    } else
#line 3995
    if (match_len > 0) {
#line 3996
      return (0);
    } else {
#line 3998
      return (elem_len > char_len ? elem_len : char_len);
    }
  }
#line 4001
  return (0);
}
}
#line 4069 "regexec.c"
static _Bool check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                               Idx idx ) 
{ unsigned char ch ;
  _Bool __cil_tmp ;
  unsigned int context ;
  unsigned int __cil_tmp___0 ;

  {
#line 4075
  ch = *(mctx->input.mbs + idx);
#line 4076
  switch ((int )node->type) {
  case 1: 
#line 4079
  if ((int const   )node->opr.c != (int const   )ch) {
#line 4080
    return ((_Bool)0);
  }
#line 4081
  break;
  case 3: 
#line 4084
  __cil_tmp = bitset_contain((bitset_word_t *)node->opr.sbcset, (unsigned int )ch);
#line 4084
  if (! __cil_tmp) {
#line 4085
    return ((_Bool)0);
  }
#line 4086
  break;
  case 7: 
#line 4090
  if ((int )ch >= 128) {
#line 4091
    return ((_Bool)0);
  }
  case 5: 
#line 4095
  if (((int )ch == 10 && ! ((mctx->dfa)->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) || ((int )ch == 0 && (mctx->dfa)->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4097
    return ((_Bool)0);
  }
#line 4098
  break;
  default: 
#line 4101
  return ((_Bool)0);
  }
#line 4104
  if (node->constraint) {
#line 4108
    __cil_tmp___0 = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
#line 4108
    context = __cil_tmp___0;
#line 4110
    if ((((node->constraint & 4U && ! (context & 1U)) || (node->constraint & 8U && context & 1U)) || (node->constraint & 32U && ! (context & (unsigned int )(1 << 1)))) || (node->constraint & 128U && ! (context & (unsigned int )(((1 << 1) << 1) << 1)))) {
#line 4111
      return ((_Bool)0);
    }
  }
#line 4114
  return ((_Bool)1);
}
}
#line 4119 "regexec.c"
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) 
{ reg_errcode_t ret ;
  re_string_t *pstr ;
  re_dfastate_t **new_array ;
  void *__cil_tmp ;

  {
#line 4124
  pstr = & mctx->input;
#line 4127
  if (((((1U << 31) - 1U) * 2U + 1U) / 2U) / sizeof(re_dfastate_t *) <= pstr->bufs_len) {
#line 4128
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 4131
  ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2U);
#line 4132
  if ((int )ret != 0) {
#line 4133
    return (ret);
  }
#line 4135
  if ((unsigned int )mctx->state_log != (unsigned int )((void *)0)) {
#line 4141
    __cil_tmp = rpl_realloc((void *)mctx->state_log, (pstr->bufs_len + 1U) * sizeof(re_dfastate_t *));
#line 4141
    new_array = (re_dfastate_t **)__cil_tmp;
#line 4143
    if ((unsigned int )new_array == (unsigned int )((void *)0)) {
#line 4144
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 4145
    mctx->state_log = new_array;
  }
#line 4149
  if (pstr->icase) {
#line 4152
    if (pstr->mb_cur_max > 1) {
#line 4154
      ret = build_wcs_upper_buffer(pstr);
#line 4155
      if ((int )ret != 0) {
#line 4156
        return (ret);
      }
    } else {
#line 4160
      build_upper_buffer(pstr);
    }
  } else
#line 4165
  if (pstr->mb_cur_max > 1) {
#line 4166
    build_wcs_buffer(pstr);
  } else
#line 4170
  if ((unsigned int )pstr->trans != (unsigned int )((void *)0)) {
#line 4171
    re_string_translate_buffer(pstr);
  }
#line 4174
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 4182 "regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , Idx n ) 
{ size_t max_object_size ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 4186
  mctx->eflags = eflags;
#line 4187
  mctx->match_last = 4294967295U;
#line 4188
  if (n > 0U) {
#line 4191
    max_object_size = sizeof(struct re_backref_cache_entry ) < sizeof(re_sub_match_top_t *) ? sizeof(re_sub_match_top_t *) : sizeof(struct re_backref_cache_entry );
#line 4194
    if ((((1U << 31) - 1U) * 2U + 1U) / max_object_size < n) {
#line 4195
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 4197
    __cil_tmp = rpl_malloc(n * sizeof(struct re_backref_cache_entry ));
#line 4197
    mctx->bkref_ents = (struct re_backref_cache_entry *)__cil_tmp;
#line 4198
    __cil_tmp___0 = rpl_malloc(n * sizeof(re_sub_match_top_t *));
#line 4198
    mctx->sub_tops = (re_sub_match_top_t **)__cil_tmp___0;
#line 4199
    if ((unsigned int )mctx->bkref_ents == (unsigned int )((void *)0) || (unsigned int )mctx->sub_tops == (unsigned int )((void *)0)) {
#line 4200
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
  }
#line 4207
  mctx->abkref_ents = n;
#line 4208
  mctx->max_mb_elem_len = 1;
#line 4209
  mctx->asub_tops = n;
#line 4210
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 4217 "regexec.c"
static void match_ctx_clean(re_match_context_t *mctx ) 
{ Idx st_idx ;
  Idx sl_idx ;
  re_sub_match_top_t *top ;
  re_sub_match_last_t *last ;

  {
#line 4222
  st_idx = 0U;
#line 4222
  while (st_idx < mctx->nsub_tops) {
#line 4225
    top = *(mctx->sub_tops + st_idx);
#line 4226
    sl_idx = 0U;
#line 4226
    while (sl_idx < top->nlasts) {
#line 4228
      last = *(top->lasts + sl_idx);
#line 4229
      free((void *)last->path.array);
#line 4230
      free((void *)last);
#line 4226
      sl_idx ++;
    }
#line 4232
    free((void *)top->lasts);
#line 4233
    if (top->path) {
#line 4235
      free((void *)(top->path)->array);
#line 4236
      free((void *)top->path);
    }
#line 4238
    free((void *)top);
#line 4222
    st_idx ++;
  }
#line 4241
  mctx->nsub_tops = 0U;
#line 4242
  mctx->nbkref_ents = 0U;
#line 4243
  return;
}
}
#line 4247 "regexec.c"
static void match_ctx_free(re_match_context_t *mctx ) 
{ 

  {
#line 4252
  match_ctx_clean(mctx);
#line 4253
  free((void *)mctx->sub_tops);
#line 4254
  free((void *)mctx->bkref_ents);
#line 4255
  return;
}
}
#line 4262 "regexec.c"
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , Idx node , Idx str_idx ,
                                         Idx from , Idx to ) 
{ struct re_backref_cache_entry *new_entry ;
  void *__cil_tmp ;
  Idx __cil_tmp___0 ;

  {
#line 4267
  if (mctx->nbkref_ents >= mctx->abkref_ents) {
#line 4270
    __cil_tmp = rpl_realloc((void *)mctx->bkref_ents, (mctx->abkref_ents * 2U) * sizeof(struct re_backref_cache_entry ));
#line 4270
    new_entry = (struct re_backref_cache_entry *)__cil_tmp;
#line 4272
    if ((unsigned int )new_entry == (unsigned int )((void *)0)) {
#line 4274
      free((void *)mctx->bkref_ents);
#line 4275
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 4277
    mctx->bkref_ents = new_entry;
#line 4278
    memset((void *)(mctx->bkref_ents + mctx->nbkref_ents), '\000', sizeof(struct re_backref_cache_entry ) * mctx->abkref_ents);
#line 4280
    mctx->abkref_ents *= 2U;
  }
#line 4282
  if (mctx->nbkref_ents > 0U && (mctx->bkref_ents + (mctx->nbkref_ents - 1U))->str_idx == str_idx) {
#line 4284
    (mctx->bkref_ents + (mctx->nbkref_ents - 1U))->more = (char)1;
  }
#line 4286
  (mctx->bkref_ents + mctx->nbkref_ents)->node = node;
#line 4287
  (mctx->bkref_ents + mctx->nbkref_ents)->str_idx = str_idx;
#line 4288
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_from = from;
#line 4289
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_to = to;
#line 4299
  (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short )(from == to ? -1 : 0);
#line 4302
  __cil_tmp___0 = mctx->nbkref_ents;
#line 4302
  (mctx->nbkref_ents) ++;
#line 4302
  (mctx->bkref_ents + __cil_tmp___0)->more = (char)0;
#line 4303
  if ((unsigned int )mctx->max_mb_elem_len < to - from) {
#line 4304
    mctx->max_mb_elem_len = (int )(to - from);
  }
#line 4305
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 4311 "regexec.c"
static Idx search_cur_bkref_entry(re_match_context_t const   *mctx , Idx str_idx ) 
{ Idx left ;
  Idx right ;
  Idx mid ;
  Idx last ;

  {
#line 4316
  right = (unsigned int )mctx->nbkref_ents;
#line 4316
  last = right;
#line 4317
  left = 0U;
#line 4317
  while (left < right) {
#line 4319
    mid = (left + right) / 2U;
#line 4320
    if ((mctx->bkref_ents + mid)->str_idx < str_idx) {
#line 4321
      left = mid + 1U;
    } else {
#line 4323
      right = mid;
    }
  }
#line 4325
  if (left < last && (mctx->bkref_ents + left)->str_idx == str_idx) {
#line 4326
    return (left);
  } else {
#line 4328
    return (4294967295U);
  }
}
}
#line 4334 "regexec.c"
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , Idx node , Idx str_idx ) 
{ Idx new_asub_tops ;
  re_sub_match_top_t **new_array ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;
  Idx __cil_tmp___1 ;

  {
#line 4342
  if (mctx->nsub_tops == mctx->asub_tops) {
#line 4344
    new_asub_tops = mctx->asub_tops * 2U;
#line 4345
    __cil_tmp = rpl_realloc((void *)mctx->sub_tops, new_asub_tops * sizeof(re_sub_match_top_t *));
#line 4345
    new_array = (re_sub_match_top_t **)__cil_tmp;
#line 4348
    if ((unsigned int )new_array == (unsigned int )((void *)0)) {
#line 4349
      return ((enum __anonenum_reg_errcode_t_7 )12);
    }
#line 4350
    mctx->sub_tops = new_array;
#line 4351
    mctx->asub_tops = new_asub_tops;
  }
#line 4353
  __cil_tmp___0 = rpl_calloc(1U, sizeof(re_sub_match_top_t ));
#line 4353
  *(mctx->sub_tops + mctx->nsub_tops) = (re_sub_match_top_t *)__cil_tmp___0;
#line 4354
  if ((unsigned int )*(mctx->sub_tops + mctx->nsub_tops) == (unsigned int )((void *)0)) {
#line 4355
    return ((enum __anonenum_reg_errcode_t_7 )12);
  }
#line 4356
  (*(mctx->sub_tops + mctx->nsub_tops))->node = node;
#line 4357
  __cil_tmp___1 = mctx->nsub_tops;
#line 4357
  (mctx->nsub_tops) ++;
#line 4357
  (*(mctx->sub_tops + __cil_tmp___1))->str_idx = str_idx;
#line 4358
  return ((enum __anonenum_reg_errcode_t_7 )0);
}
}
#line 4364 "regexec.c"
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , Idx node ,
                                                  Idx str_idx ) 
{ re_sub_match_last_t *new_entry ;
  Idx new_alasts ;
  re_sub_match_last_t **new_array ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 4369
  if (subtop->nlasts == subtop->alasts) {
#line 4371
    new_alasts = 2U * subtop->alasts + 1U;
#line 4372
    __cil_tmp = rpl_realloc((void *)subtop->lasts, new_alasts * sizeof(re_sub_match_last_t *));
#line 4372
    new_array = (re_sub_match_last_t **)__cil_tmp;
#line 4375
    if ((unsigned int )new_array == (unsigned int )((void *)0)) {
#line 4376
      return ((re_sub_match_last_t *)((void *)0));
    }
#line 4377
    subtop->lasts = new_array;
#line 4378
    subtop->alasts = new_alasts;
  }
#line 4380
  __cil_tmp___0 = rpl_calloc(1U, sizeof(re_sub_match_last_t ));
#line 4380
  new_entry = (re_sub_match_last_t *)__cil_tmp___0;
#line 4381
  if ((unsigned int )new_entry != (unsigned int )((void *)0)) {
#line 4383
    *(subtop->lasts + subtop->nlasts) = new_entry;
#line 4384
    new_entry->node = node;
#line 4385
    new_entry->str_idx = str_idx;
#line 4386
    (subtop->nlasts) ++;
  }
#line 4388
  return (new_entry);
}
}
#line 4391 "regexec.c"
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          Idx last_node , Idx last_str_idx ) 
{ 

  {
#line 4396
  sctx->sifted_states = sifted_sts;
#line 4397
  sctx->limited_states = limited_sts;
#line 4398
  sctx->last_node = last_node;
#line 4399
  sctx->last_str_idx = last_str_idx;
#line 4400
  memset((void *)(& sctx->limits), '\000', sizeof(re_node_set ));
#line 4401
  return;
}
}
#line 1 "rename.o"
#pragma merger(0,"/tmp/cil-fOqEcZT7.i","-g,-O2")
#line 229 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/stdio.h"
extern int rename(char const   * , char const   * ) ;
#line 35 "rename.c"
int rpl_rename(char const   *src , char const   *dst ) 
{ char *src_temp ;
  int ret_val ;
  size_t s_len ;
  size_t __cil_tmp ;

  {
#line 40
  __cil_tmp = strlen(src);
#line 40
  s_len = __cil_tmp;
#line 42
  if (s_len && (int const   )*(src + (s_len - 1U)) == 47) {
#line 44
    src_temp = xstrdup(src);
#line 45
    strip_trailing_slashes(src_temp);
  } else {
#line 48
    src_temp = (char *)src;
  }
#line 50
  ret_val = rename((char const   *)src_temp, dst);
#line 52
  if ((unsigned int )src_temp != (unsigned int )src) {
#line 53
    free((void *)src_temp);
  }
#line 55
  return (ret_val);
}
}
#line 1 "rename-dest-slash.o"
#pragma merger(0,"/tmp/cil-QJomkyen.i","-g,-O2")
#line 40 "rename-dest-slash.c"
static _Bool has_trailing_slash(char const   *file ) 
{ _Bool has_non_slash ;
  _Bool ends_in_slash ;

  {
#line 44
  has_non_slash = (_Bool)0;
#line 45
  ends_in_slash = (_Bool)0;
#line 47
  file += 0;
#line 47
  while (*file) {
#line 49
    ends_in_slash = (_Bool )((int const   )*file == 47);
#line 50
    has_non_slash = (_Bool )((int )has_non_slash | ~ ((int )ends_in_slash));
#line 47
    file ++;
  }
#line 53
  return ((_Bool )((int )has_non_slash & (int )ends_in_slash));
}
}
#line 63 "rename-dest-slash.c"
int rpl_rename_dest_slash(char const   *src , char const   *dst ) 
{ int ret_val ;
  int __cil_tmp ;
  int rename_errno ;
  struct stat sb ;
  char *dst_temp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  _Bool __cil_tmp___5 ;

  {
#line 66
  __cil_tmp = rename(src, dst);
#line 66
  ret_val = __cil_tmp;
#line 68
  if (ret_val != 0) {
#line 68
    __cil_tmp___4 = __errno();
#line 68
    if (*__cil_tmp___4 == 2) {
#line 68
      __cil_tmp___5 = has_trailing_slash(dst);
#line 68
      if (__cil_tmp___5) {
#line 70
        rename_errno = 2;
#line 74
        __cil_tmp___2 = lstat(src, & sb);
#line 74
        if (__cil_tmp___2 == 0 && (sb.st_mode & 8323072U) == 1048576U) {
#line 76
          __cil_tmp___0 = xstrdup(dst);
#line 76
          dst_temp = __cil_tmp___0;
#line 77
          strip_trailing_slashes(dst_temp);
#line 78
          ret_val = rename(src, (char const   *)dst_temp);
#line 79
          __cil_tmp___1 = __errno();
#line 79
          rename_errno = *__cil_tmp___1;
#line 80
          free((void *)dst_temp);
        }
#line 83
        __cil_tmp___3 = __errno();
#line 83
        *__cil_tmp___3 = rename_errno;
      }
    }
  }
#line 86
  return (ret_val);
}
}
#line 1 "root-dev-ino.o"
#pragma merger(0,"/tmp/cil-OHQ8tNW5.i","-g,-O2")
#line 24 "root-dev-ino.h"
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) ;
#line 28 "root-dev-ino.c"
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) 
{ struct stat statbuf ;
  int __cil_tmp ;

  {
#line 32
  __cil_tmp = lstat("/", & statbuf);
#line 32
  if (__cil_tmp) {
#line 33
    return ((struct dev_ino *)((void *)0));
  }
#line 34
  root_d_i->st_ino = statbuf.st_ino;
#line 35
  root_d_i->st_dev = statbuf.st_dev;
#line 36
  return (root_d_i);
}
}
#line 1 "rpmatch.o"
#pragma merger(0,"/tmp/cil-1Nxm6Vv3.i","-g,-O2")
#line 57 "rpmatch.c"
int rpmatch(char const   *response ) 
{ 

  {
#line 75
  return ((int const   )*response == 121 || (int const   )*response == 89 ? 1 : ((int const   )*response == 110 || (int const   )*response == 78 ? 0 : -1));
}
}
#line 1 "safe-read.o"
#pragma merger(0,"/tmp/cil-G2p6HUlu.i","-g,-O2")
#line 138 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern int read(int __fd , void *__buf , size_t __nbyte ) ;
#line 55 "safe-read.c"
size_t safe_read(int fd , void *buf___0 , size_t count ) 
{ ssize_t result ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 64
  while (1) {
#line 66
    __cil_tmp = read(fd, buf___0, count);
#line 66
    result = __cil_tmp;
#line 68
    if (0 <= result) {
#line 69
      return ((unsigned int )result);
    } else {
#line 70
      __cil_tmp___1 = __errno();
#line 70
      if (*__cil_tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
#line 72
        __cil_tmp___0 = __errno();
#line 72
        if (*__cil_tmp___0 == 22 && 2147475456U < count) {
#line 73
          count = 2147475456U;
        } else {
#line 75
          return ((unsigned int )result);
        }
      }
    }
    __Cont: ;
  }
}
}
#line 1 "safe-write.o"
#pragma merger(0,"/tmp/cil-tXZO5MN1.i","-g,-O2")
#line 183 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern int write(int __fd , void const   *__buf , size_t __nbyte ) ;
#line 55 "safe-read.c"
size_t safe_write(int fd , void const   *buf___0 , size_t count ) 
{ ssize_t result ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 64
  while (1) {
#line 66
    __cil_tmp = write(fd, buf___0, count);
#line 66
    result = __cil_tmp;
#line 68
    if (0 <= result) {
#line 69
      return ((unsigned int )result);
    } else {
#line 70
      __cil_tmp___1 = __errno();
#line 70
      if (*__cil_tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
#line 72
        __cil_tmp___0 = __errno();
#line 72
        if (*__cil_tmp___0 == 22 && 2147475456U < count) {
#line 73
          count = 2147475456U;
        } else {
#line 75
          return ((unsigned int )result);
        }
      }
    }
    __Cont: ;
  }
}
}
#line 1 "same.o"
#pragma merger(0,"/tmp/cil-Tf1PENlV.i","-g,-O2")
#line 52 "same.c"
_Bool same_name(char const   *source , char const   *dest ) 
{ char const   *source_basename ;
  char *__cil_tmp ;
  char const   *dest_basename ;
  char *__cil_tmp___0 ;
  size_t source_baselen ;
  size_t __cil_tmp___1 ;
  size_t dest_baselen ;
  size_t __cil_tmp___2 ;
  _Bool identical_basenames ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  _Bool compare_dirs ;
  _Bool same ;
  struct stat source_dir_stats ;
  struct stat dest_dir_stats ;
  char *source_dirname ;
  char *dest_dirname ;
  int *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int __cil_tmp___8 ;

  {
#line 56
  __cil_tmp = last_component(source);
#line 56
  source_basename = (char const   *)__cil_tmp;
#line 57
  __cil_tmp___0 = last_component(dest);
#line 57
  dest_basename = (char const   *)__cil_tmp___0;
#line 58
  __cil_tmp___1 = base_len(source_basename);
#line 58
  source_baselen = __cil_tmp___1;
#line 59
  __cil_tmp___2 = base_len(dest_basename);
#line 59
  dest_baselen = __cil_tmp___2;
#line 60
  if (source_baselen == dest_baselen) {
#line 60
    __cil_tmp___3 = rpl_memcmp((void const   *)source_basename, (void const   *)dest_basename,
                               dest_baselen);
#line 60
    if (__cil_tmp___3 == 0) {
#line 60
      __cil_tmp___4 = 1;
    } else {
#line 60
      __cil_tmp___4 = 0;
    }
  } else {
#line 60
    __cil_tmp___4 = 0;
  }
#line 60
  identical_basenames = (_Bool )__cil_tmp___4;
#line 63
  compare_dirs = identical_basenames;
#line 64
  same = (_Bool)0;
#line 77
  if (compare_dirs) {
#line 84
    source_dirname = dir_name(source);
#line 85
    dest_dirname = dir_name(dest);
#line 87
    __cil_tmp___6 = stat((char const   *)source_dirname, & source_dir_stats);
#line 87
    if (__cil_tmp___6) {
#line 90
      __cil_tmp___5 = __errno();
#line 90
      error(1, *__cil_tmp___5, "%s", source_dirname);
    }
#line 93
    __cil_tmp___8 = stat((char const   *)dest_dirname, & dest_dir_stats);
#line 93
    if (__cil_tmp___8) {
#line 96
      __cil_tmp___7 = __errno();
#line 96
      error(1, *__cil_tmp___7, "%s", dest_dirname);
    }
#line 99
    same = (_Bool )((int )source_dir_stats.st_ino == (int )dest_dir_stats.st_ino && (int )source_dir_stats.st_dev == (int )dest_dir_stats.st_dev);
#line 120
    free((void *)source_dirname);
#line 121
    free((void *)dest_dirname);
  }
#line 124
  return (same);
}
}
#line 1 "save-cwd.o"
#pragma merger(0,"/tmp/cil-tiMOLu8r.i","-g,-O2")
#line 67 "save-cwd.c"
int save_cwd(struct saved_cwd *cwd ) 
{ 

  {
#line 70
  cwd->name = (char *)((void *)0);
#line 72
  cwd->desc = open_safer(".", 1);
#line 73
  if (cwd->desc < 0) {
#line 75
    cwd->name = xgetcwd();
#line 76
    return (cwd->name ? 0 : -1);
  }
#line 79
  return (0);
}
}
#line 86 "save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 89
  if (0 <= (int )cwd->desc) {
#line 90
    __cil_tmp = fchdir(cwd->desc);
#line 90
    return (__cil_tmp);
  } else {
#line 92
    __cil_tmp___0 = chdir_long((char *)cwd->name);
#line 92
    return (__cil_tmp___0);
  }
}
}
#line 95 "save-cwd.c"
void free_cwd(struct saved_cwd *cwd ) 
{ 

  {
#line 98
  if (cwd->desc >= 0) {
#line 99
    close(cwd->desc);
  }
#line 100
  if (cwd->name) {
#line 101
    free((void *)cwd->name);
  }
#line 102
  return;
}
}
#line 1 "savedir.o"
#pragma merger(0,"/tmp/cil-ggSOL4Sg.i","-g,-O2")
#line 23 "savedir.h"
char *savedir(char const   *dir ) ;
#line 24
char *fdsavedir(int fd ) ;
#line 56 "savedir.c"
static char *savedirstream(DIR *dirp ) 
{ char *name_space ;
  size_t allocated ;
  size_t used ;
  int save_errno ;
  void *__cil_tmp ;
  struct dirent  const  *dp ;
  char const   *entry ;
  int *__cil_tmp___0 ;
  struct dirent *__cil_tmp___1 ;
  size_t entry_size ;
  size_t __cil_tmp___2 ;
  void *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  int *__cil_tmp___7 ;

  {
#line 60
  allocated = 512U;
#line 61
  used = 0U;
#line 64
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 65
    return ((char *)((void *)0));
  }
#line 67
  __cil_tmp = xmalloc(allocated);
#line 67
  name_space = (char *)__cil_tmp;
#line 69
  while (1) {
#line 74
    __cil_tmp___0 = __errno();
#line 74
    *__cil_tmp___0 = 0;
#line 75
    __cil_tmp___1 = readdir(dirp);
#line 75
    dp = (struct dirent  const  *)__cil_tmp___1;
#line 76
    if (! dp) {
#line 77
      break;
    }
#line 81
    entry = (char const   *)(dp->d_name);
#line 82
    if ((int const   )*(entry + ((int const   )*(entry + 0) != 46 ? 0 : ((int const   )*(entry + 1) != 46 ? 1 : 2))) != 0) {
#line 84
      __cil_tmp___2 = strlen((char const   *)(dp->d_name));
#line 84
      entry_size = __cil_tmp___2 + 1U;
#line 85
      if (used + entry_size < used) {
#line 86
        xalloc_die();
      }
#line 87
      if (allocated <= used + entry_size) {
#line 89
        while (1) {
#line 91
          if (2U * allocated < allocated) {
#line 92
            xalloc_die();
          }
#line 93
          allocated *= 2U;
#line 89
          if (! (allocated <= used + entry_size)) {
#line 89
            break;
          }
        }
#line 97
        __cil_tmp___3 = xrealloc((void *)name_space, allocated);
#line 97
        name_space = (char *)__cil_tmp___3;
      }
#line 99
      memcpy((void *)(name_space + used), (void const   *)entry, entry_size);
#line 100
      used += entry_size;
    }
  }
#line 103
  *(name_space + used) = (char )'\000';
#line 104
  __cil_tmp___4 = __errno();
#line 104
  save_errno = *__cil_tmp___4;
#line 105
  __cil_tmp___6 = closedir(dirp);
#line 105
  if (__cil_tmp___6 != 0) {
#line 106
    __cil_tmp___5 = __errno();
#line 106
    save_errno = *__cil_tmp___5;
  }
#line 107
  if (save_errno != 0) {
#line 109
    free((void *)name_space);
#line 110
    __cil_tmp___7 = __errno();
#line 110
    *__cil_tmp___7 = save_errno;
#line 111
    return ((char *)((void *)0));
  }
#line 113
  return (name_space);
}
}
#line 121 "savedir.c"
char *savedir(char const   *dir ) 
{ DIR *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 124
  __cil_tmp = opendir(dir);
#line 124
  __cil_tmp___0 = savedirstream(__cil_tmp);
#line 124
  return (__cil_tmp___0);
}
}
#line 132 "savedir.c"
char *fdsavedir(int fd ) 
{ DIR *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 135
  __cil_tmp = rpl_fdopendir(fd);
#line 135
  __cil_tmp___0 = savedirstream(__cil_tmp);
#line 135
  return (__cil_tmp___0);
}
}
#line 1 "selinux-at.o"
#pragma merger(0,"/tmp/cil-CEthfCSw.i","-g,-O2")
#line 32 "./selinux/selinux.h"
__inline static int getfilecon(char const   *s , char **con ) 
{ int *__cil_tmp ;

  {
#line 33
  __cil_tmp = __errno();
#line 33
  *__cil_tmp = 134;
#line 33
  return (-1);
}
}
#line 36 "./selinux/selinux.h"
__inline static int setfilecon(char const   *s , char *con ) 
{ int *__cil_tmp ;

  {
#line 37
  __cil_tmp = __errno();
#line 37
  *__cil_tmp = 134;
#line 37
  return (-1);
}
}
#line 20 "selinux-at.h"
int getfileconat(int fd , char const   *file , char **con ) ;
#line 21
int lgetfileconat(int fd , char const   *file , char **con ) ;
#line 22
int setfileconat(int fd , char const   *file , char *con ) ;
#line 23
int lsetfileconat(int fd , char const   *file , char *con ) ;
#line 30 "at-func.c"
int getfileconat(int fd , char const   *file , char **con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___1 ;
  int proc_result ;
  int __cil_tmp___2 ;
  int proc_errno ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int *__cil_tmp___13 ;
  int *__cil_tmp___14 ;
  int __cil_tmp___15 ;
  int *__cil_tmp___16 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    __cil_tmp = getfilecon(file, con);
#line 38
    return (__cil_tmp);
  }
#line 42
  __cil_tmp___1 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___1;
#line 43
  if (proc_file) {
#line 45
    __cil_tmp___2 = getfilecon((char const   *)proc_file, con);
#line 45
    proc_result = __cil_tmp___2;
#line 46
    __cil_tmp___4 = __errno();
#line 46
    proc_errno = *__cil_tmp___4;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___5 = __errno();
#line 56
      *__cil_tmp___5 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___7 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___7 != 0) {
#line 63
    __cil_tmp___6 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___6);
  }
#line 65
  __cil_tmp___10 = fchdir(fd);
#line 65
  if (__cil_tmp___10 != 0) {
#line 67
    __cil_tmp___8 = __errno();
#line 67
    saved_errno = *__cil_tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___9 = __errno();
#line 69
    *__cil_tmp___9 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  __cil_tmp___11 = getfilecon(file, con);
#line 73
  err = __cil_tmp___11;
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___13 = __errno();
#line 74
    saved_errno = *__cil_tmp___13;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___15 != 0) {
#line 77
    __cil_tmp___14 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___14);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___16 = __errno();
#line 82
    *__cil_tmp___16 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 30 "at-func.c"
int lgetfileconat(int fd , char const   *file , char **con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___1 ;
  int proc_result ;
  int __cil_tmp___2 ;
  int proc_errno ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int *__cil_tmp___13 ;
  int *__cil_tmp___14 ;
  int __cil_tmp___15 ;
  int *__cil_tmp___16 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    __cil_tmp = getfilecon(file, con);
#line 38
    return (__cil_tmp);
  }
#line 42
  __cil_tmp___1 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___1;
#line 43
  if (proc_file) {
#line 45
    __cil_tmp___2 = getfilecon((char const   *)proc_file, con);
#line 45
    proc_result = __cil_tmp___2;
#line 46
    __cil_tmp___4 = __errno();
#line 46
    proc_errno = *__cil_tmp___4;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___5 = __errno();
#line 56
      *__cil_tmp___5 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___7 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___7 != 0) {
#line 63
    __cil_tmp___6 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___6);
  }
#line 65
  __cil_tmp___10 = fchdir(fd);
#line 65
  if (__cil_tmp___10 != 0) {
#line 67
    __cil_tmp___8 = __errno();
#line 67
    saved_errno = *__cil_tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___9 = __errno();
#line 69
    *__cil_tmp___9 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  __cil_tmp___11 = getfilecon(file, con);
#line 73
  err = __cil_tmp___11;
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___13 = __errno();
#line 74
    saved_errno = *__cil_tmp___13;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___15 != 0) {
#line 77
    __cil_tmp___14 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___14);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___16 = __errno();
#line 82
    *__cil_tmp___16 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 30 "at-func.c"
int setfileconat(int fd , char const   *file , char *con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___1 ;
  int proc_result ;
  int __cil_tmp___2 ;
  int proc_errno ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int *__cil_tmp___13 ;
  int *__cil_tmp___14 ;
  int __cil_tmp___15 ;
  int *__cil_tmp___16 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    __cil_tmp = setfilecon(file, con);
#line 38
    return (__cil_tmp);
  }
#line 42
  __cil_tmp___1 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___1;
#line 43
  if (proc_file) {
#line 45
    __cil_tmp___2 = setfilecon((char const   *)proc_file, con);
#line 45
    proc_result = __cil_tmp___2;
#line 46
    __cil_tmp___4 = __errno();
#line 46
    proc_errno = *__cil_tmp___4;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___5 = __errno();
#line 56
      *__cil_tmp___5 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___7 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___7 != 0) {
#line 63
    __cil_tmp___6 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___6);
  }
#line 65
  __cil_tmp___10 = fchdir(fd);
#line 65
  if (__cil_tmp___10 != 0) {
#line 67
    __cil_tmp___8 = __errno();
#line 67
    saved_errno = *__cil_tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___9 = __errno();
#line 69
    *__cil_tmp___9 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  __cil_tmp___11 = setfilecon(file, con);
#line 73
  err = __cil_tmp___11;
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___13 = __errno();
#line 74
    saved_errno = *__cil_tmp___13;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___15 != 0) {
#line 77
    __cil_tmp___14 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___14);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___16 = __errno();
#line 82
    *__cil_tmp___16 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 30 "at-func.c"
int lsetfileconat(int fd , char const   *file , char *con ) 
{ struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int __cil_tmp ;
  char buf___0[512] ;
  char *proc_file ;
  char *__cil_tmp___1 ;
  int proc_result ;
  int __cil_tmp___2 ;
  int proc_errno ;
  int *__cil_tmp___4 ;
  int *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int *__cil_tmp___13 ;
  int *__cil_tmp___14 ;
  int __cil_tmp___15 ;
  int *__cil_tmp___16 ;

  {
#line 37
  if (fd == -3041965 || (int const   )*(file + 0) == 47) {
#line 38
    __cil_tmp = setfilecon(file, con);
#line 38
    return (__cil_tmp);
  }
#line 42
  __cil_tmp___1 = openat_proc_name(buf___0, fd, file);
#line 42
  proc_file = __cil_tmp___1;
#line 43
  if (proc_file) {
#line 45
    __cil_tmp___2 = setfilecon((char const   *)proc_file, con);
#line 45
    proc_result = __cil_tmp___2;
#line 46
    __cil_tmp___4 = __errno();
#line 46
    proc_errno = *__cil_tmp___4;
#line 47
    if ((unsigned int )proc_file != (unsigned int )(buf___0)) {
#line 48
      free((void *)proc_file);
    }
#line 52
    if (0 <= proc_result) {
#line 53
      return (proc_result);
    }
#line 54
    if (! (((((proc_errno == 20 || proc_errno == 2) || proc_errno == 1) || proc_errno == 13) || proc_errno == 88) || proc_errno == 95)) {
#line 56
      __cil_tmp___5 = __errno();
#line 56
      *__cil_tmp___5 = proc_errno;
#line 57
      return (proc_result);
    }
  }
#line 62
  __cil_tmp___7 = save_cwd(& saved_cwd);
#line 62
  if (__cil_tmp___7 != 0) {
#line 63
    __cil_tmp___6 = __errno();
#line 63
    openat_save_fail(*__cil_tmp___6);
  }
#line 65
  __cil_tmp___10 = fchdir(fd);
#line 65
  if (__cil_tmp___10 != 0) {
#line 67
    __cil_tmp___8 = __errno();
#line 67
    saved_errno = *__cil_tmp___8;
#line 68
    free_cwd(& saved_cwd);
#line 69
    __cil_tmp___9 = __errno();
#line 69
    *__cil_tmp___9 = saved_errno;
#line 70
    return (-1);
  }
#line 73
  __cil_tmp___11 = setfilecon(file, con);
#line 73
  err = __cil_tmp___11;
#line 74
  if (err < 0) {
#line 74
    __cil_tmp___13 = __errno();
#line 74
    saved_errno = *__cil_tmp___13;
  } else {
#line 74
    saved_errno = 0;
  }
#line 76
  __cil_tmp___15 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 76
  if (__cil_tmp___15 != 0) {
#line 77
    __cil_tmp___14 = __errno();
#line 77
    openat_restore_fail(*__cil_tmp___14);
  }
#line 79
  free_cwd(& saved_cwd);
#line 81
  if (saved_errno) {
#line 82
    __cil_tmp___16 = __errno();
#line 82
    *__cil_tmp___16 = saved_errno;
  }
#line 83
  return (err);
}
}
#line 1 "setenv.o"
#pragma merger(0,"/tmp/cil-BCji72GP.i","-g,-O2")
#line 54 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/search.h"
extern void *tfind(void const   * , void ** , int (*)(void const   * , void const   * ) ) ;
#line 55
extern void *tsearch(void const   * , void ** , int (*)(void const   * , void const   * ) ) ;
#line 79 "setenv.c"
static void *known_values  ;
#line 100 "setenv.c"
static char **last_environ___0  ;
#line 109 "setenv.c"
int __add_to_environ(char const   *name , char const   *value , char const   *combined ,
                     int replace ) 
{ register char **ep ;
  register size_t size ;
  size_t namelen ;
  size_t __cil_tmp ;
  size_t vallen ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  char **new_environ ;
  char *new_value ;
  void *__cil_tmp___3 ;
  void *__cil_tmp___4 ;
  void *__cil_tmp___5 ;
  void *__cil_tmp___6 ;
  void *__cil_tmp___7 ;
  void *__cil_tmp___8 ;
  int *__cil_tmp___9 ;
  void *value___0 ;
  void *__cil_tmp___10 ;
  void *__cil_tmp___11 ;
  int *__cil_tmp___12 ;
  char *np ;
  char *new_value___0 ;
  void *__cil_tmp___13 ;
  void *__cil_tmp___14 ;
  int *__cil_tmp___15 ;
  void *value___1 ;
  void *__cil_tmp___16 ;
  void *__cil_tmp___17 ;
  int *__cil_tmp___18 ;

  {
#line 115
  __cil_tmp = strlen(name);
#line 115
  namelen = __cil_tmp;
#line 116
  if ((unsigned int )value != (unsigned int )((void *)0)) {
#line 116
    __cil_tmp___0 = strlen(value);
#line 116
    __cil_tmp___1 = __cil_tmp___0 + 1U;
  } else {
#line 116
    __cil_tmp___1 = 0U;
  }
#line 116
  vallen = __cil_tmp___1;
#line 122
  ep = environ;
#line 124
  size = 0U;
#line 125
  if ((unsigned int )ep != (unsigned int )((void *)0)) {
#line 127
    while ((unsigned int )*ep != (unsigned int )((void *)0)) {
#line 128
      __cil_tmp___2 = strncmp((char const   *)*ep, name, namelen);
#line 128
      if (__cil_tmp___2) {
#line 131
        size ++;
      } else
#line 128
      if ((int )*(*ep + namelen) == 61) {
#line 129
        break;
      } else {
#line 131
        size ++;
      }
#line 127
      ep ++;
    }
  }
#line 134
  if ((unsigned int )ep == (unsigned int )((void *)0) || (unsigned int )*ep == (unsigned int )((void *)0)) {
#line 142
    if ((unsigned int )last_environ___0 == (unsigned int )((void *)0)) {
#line 142
      __cil_tmp___3 = rpl_malloc((size + 2U) * sizeof(char *));
#line 142
      __cil_tmp___5 = __cil_tmp___3;
    } else {
#line 142
      __cil_tmp___4 = rpl_realloc((void *)last_environ___0, (size + 2U) * sizeof(char *));
#line 142
      __cil_tmp___5 = __cil_tmp___4;
    }
#line 142
    new_environ = (char **)__cil_tmp___5;
#line 146
    if ((unsigned int )new_environ == (unsigned int )((void *)0)) {
#line 149
      return (-1);
    }
#line 153
    if ((unsigned int )combined != (unsigned int )((void *)0)) {
#line 156
      *(new_environ + size) = (char *)combined;
    } else {
#line 166
      if ((namelen + 1U) + vallen < 4028U) {
#line 166
        __cil_tmp___6 = __builtin_alloca(((namelen + 1U) + vallen) + 4U);
#line 166
        __cil_tmp___8 = (void *)((char *)__cil_tmp___6 + 4);
      } else {
#line 166
        __cil_tmp___7 = mmalloca((namelen + 1U) + vallen);
#line 166
        __cil_tmp___8 = __cil_tmp___7;
      }
#line 166
      new_value = (char *)__cil_tmp___8;
#line 167
      if ((unsigned int )new_value == (unsigned int )((void *)0)) {
#line 169
        __cil_tmp___9 = __errno();
#line 169
        *__cil_tmp___9 = 12;
#line 171
        return (-1);
      }
#line 173
      memcpy((void *)new_value, (void const   *)name, namelen);
#line 174
      *(new_value + namelen) = (char )'=';
#line 175
      memcpy((void *)(new_value + (namelen + 1U)), (void const   *)value, vallen);
#line 178
      __cil_tmp___10 = tfind((void const   *)new_value, & known_values, (int (*)(void const   * ,
                                                                                 void const   * ))(& strcmp));
#line 178
      value___0 = __cil_tmp___10;
#line 178
      *(new_environ + size) = (unsigned int )value___0 != (unsigned int )((void *)0) ? *((char **)value___0) : (char *)((void *)0);
#line 179
      if ((unsigned int )*(new_environ + size) == (unsigned int )((void *)0)) {
#line 182
        __cil_tmp___11 = rpl_malloc((namelen + 1U) + vallen);
#line 182
        *(new_environ + size) = (char *)__cil_tmp___11;
#line 183
        if ((unsigned int )*(new_environ + size) == (unsigned int )((void *)0)) {
#line 186
          freea((void *)new_value);
#line 188
          __cil_tmp___12 = __errno();
#line 188
          *__cil_tmp___12 = 12;
#line 190
          return (-1);
        }
#line 194
        memcpy((void *)*(new_environ + size), (void const   *)new_value, (namelen + 1U) + vallen);
#line 203
        tsearch((void const   *)*(new_environ + size), & known_values, (int (*)(void const   * ,
                                                                                void const   * ))(& strcmp));
      }
#line 206
      freea((void *)new_value);
    }
#line 210
    if ((unsigned int )environ != (unsigned int )last_environ___0) {
#line 211
      memcpy((void *)((char *)new_environ), (void const   *)((char *)environ), size * sizeof(char *));
    }
#line 214
    *(new_environ + (size + 1U)) = (char *)((void *)0);
#line 216
    environ = new_environ;
#line 216
    last_environ___0 = environ;
  } else
#line 218
  if (replace) {
#line 223
    if ((unsigned int )combined != (unsigned int )((void *)0)) {
#line 224
      np = (char *)combined;
    } else {
#line 234
      if ((namelen + 1U) + vallen < 4028U) {
#line 234
        __cil_tmp___13 = __builtin_alloca(((namelen + 1U) + vallen) + 4U);
#line 234
        new_value___0 = (char *)((void *)((char *)__cil_tmp___13 + 4));
      } else {
#line 234
        __cil_tmp___14 = mmalloca((namelen + 1U) + vallen);
#line 234
        new_value___0 = (char *)__cil_tmp___14;
      }
#line 235
      if ((unsigned int )new_value___0 == (unsigned int )((void *)0)) {
#line 237
        __cil_tmp___15 = __errno();
#line 237
        *__cil_tmp___15 = 12;
#line 239
        return (-1);
      }
#line 241
      memcpy((void *)new_value___0, (void const   *)name, namelen);
#line 242
      *(new_value___0 + namelen) = (char )'=';
#line 243
      memcpy((void *)(new_value___0 + (namelen + 1U)), (void const   *)value, vallen);
#line 246
      __cil_tmp___16 = tfind((void const   *)new_value___0, & known_values, (int (*)(void const   * ,
                                                                                     void const   * ))(& strcmp));
#line 246
      value___1 = __cil_tmp___16;
#line 246
      np = (unsigned int )value___1 != (unsigned int )((void *)0) ? *((char **)value___1) : (char *)((void *)0);
#line 247
      if ((unsigned int )np == (unsigned int )((void *)0)) {
#line 250
        __cil_tmp___17 = rpl_malloc((namelen + 1U) + vallen);
#line 250
        np = (char *)__cil_tmp___17;
#line 251
        if ((unsigned int )np == (unsigned int )((void *)0)) {
#line 254
          freea((void *)new_value___0);
#line 256
          __cil_tmp___18 = __errno();
#line 256
          *__cil_tmp___18 = 12;
#line 258
          return (-1);
        }
#line 262
        memcpy((void *)np, (void const   *)new_value___0, (namelen + 1U) + vallen);
#line 269
        tsearch((void const   *)np, & known_values, (int (*)(void const   * , void const   * ))(& strcmp));
      }
#line 272
      freea((void *)new_value___0);
    }
#line 276
    *ep = np;
  }
#line 281
  return (0);
}
}
#line 284 "setenv.c"
int setenv(char const   *name , char const   *value , int replace ) 
{ int __cil_tmp ;

  {
#line 287
  __cil_tmp = __add_to_environ(name, value, (char const   *)((void *)0), replace);
#line 287
  return (__cil_tmp);
}
}
#line 293 "setenv.c"
int clearenv(void) 
{ 

  {
#line 298
  if ((unsigned int )environ == (unsigned int )last_environ___0 && (unsigned int )environ != (unsigned int )((void *)0)) {
#line 301
    free((void *)environ);
#line 302
    last_environ___0 = (char **)((void *)0);
  }
#line 306
  environ = (char **)((void *)0);
#line 310
  return (0);
}
}
#line 1 "settime.o"
#pragma merger(0,"/tmp/cil-iLQbA7eo.i","-g,-O2")
#line 34 "timespec.h"
int settime(struct timespec  const  *ts ) ;
#line 42 "settime.c"
int settime(struct timespec  const  *ts ) 
{ int *__cil_tmp ;

  {
#line 67
  __cil_tmp = __errno();
#line 67
  *__cil_tmp = 88;
#line 68
  return (-1);
}
}
#line 1 "sha1.o"
#pragma merger(0,"/tmp/cil-ftmO0c67.i","-g,-O2")
#line 43 "sha1.h"
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
#line 49
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
#line 56
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
#line 66
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
#line 75
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) ;
#line 81
int sha1_stream(FILE *stream , void *resblock ) ;
#line 87
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 53 "sha1.c"
static unsigned char const   fillbuf___0[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 59 "sha1.c"
void sha1_init_ctx(struct sha1_ctx *ctx ) 
{ unsigned int __cil_tmp ;

  {
#line 62
  ctx->A = 1732584193U;
#line 63
  ctx->B = 4023233417U;
#line 64
  ctx->C = 2562383102U;
#line 65
  ctx->D = 271733878U;
#line 66
  ctx->E = 3285377520U;
#line 68
  __cil_tmp = 0U;
#line 68
  ctx->total[1] = __cil_tmp;
#line 68
  ctx->total[0] = __cil_tmp;
#line 69
  ctx->buflen = 0U;
#line 70
  return;
}
}
#line 77 "sha1.c"
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) 
{ 

  {
#line 80
  *((unsigned int *)resbuf + 0) = (unsigned int )((((ctx->A << 24) | ((ctx->A & 65280U) << 8)) | ((ctx->A >> 8) & 65280U)) | (ctx->A >> 24));
#line 81
  *((unsigned int *)resbuf + 1) = (unsigned int )((((ctx->B << 24) | ((ctx->B & 65280U) << 8)) | ((ctx->B >> 8) & 65280U)) | (ctx->B >> 24));
#line 82
  *((unsigned int *)resbuf + 2) = (unsigned int )((((ctx->C << 24) | ((ctx->C & 65280U) << 8)) | ((ctx->C >> 8) & 65280U)) | (ctx->C >> 24));
#line 83
  *((unsigned int *)resbuf + 3) = (unsigned int )((((ctx->D << 24) | ((ctx->D & 65280U) << 8)) | ((ctx->D >> 8) & 65280U)) | (ctx->D >> 24));
#line 84
  *((unsigned int *)resbuf + 4) = (unsigned int )((((ctx->E << 24) | ((ctx->E & 65280U) << 8)) | ((ctx->E >> 8) & 65280U)) | (ctx->E >> 24));
#line 86
  return (resbuf);
}
}
#line 94 "sha1.c"
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) 
{ unsigned int bytes ;
  size_t size ;
  void *__cil_tmp ;

  {
#line 98
  bytes = ctx->buflen;
#line 99
  size = (unsigned int )(bytes < 56U ? 16 : 32);
#line 102
  ctx->total[0] += bytes;
#line 103
  if (ctx->total[0] < bytes) {
#line 104
    (ctx->total[1]) ++;
  }
#line 107
  ctx->buffer[size - 2U] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
#line 108
  ctx->buffer[size - 1U] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
#line 110
  memcpy((void *)((char *)(ctx->buffer) + bytes), (void const   *)(fillbuf___0), (size - 2U) * 4U - bytes);
#line 113
  sha1_process_block((void const   *)(ctx->buffer), size * 4U, ctx);
#line 115
  __cil_tmp = sha1_read_ctx((struct sha1_ctx  const  *)ctx, resbuf);
#line 115
  return (__cil_tmp);
}
}
#line 121 "sha1.c"
int sha1_stream(FILE *stream , void *resblock ) 
{ struct sha1_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 129
  sha1_init_ctx(& ctx);
#line 132
  while (1) {
#line 138
    sum = 0U;
#line 141
    while (1) {
#line 143
      n = fread((void *)(buffer + sum), 1U, 4096U - sum, stream);
#line 145
      sum += n;
#line 147
      if (sum == 4096U) {
#line 148
        break;
      }
#line 150
      if (n == 0U) {
#line 155
        __cil_tmp = ferror(stream);
#line 155
        if (__cil_tmp) {
#line 156
          return (1);
        }
#line 157
        goto process_partial_block;
      }
#line 163
      __cil_tmp___0 = feof(stream);
#line 163
      if (__cil_tmp___0) {
#line 164
        goto process_partial_block;
      }
    }
#line 170
    sha1_process_block((void const   *)(buffer), 4096U, & ctx);
  }
  process_partial_block: ;
#line 176
  if (sum > 0U) {
#line 177
    sha1_process_bytes((void const   *)(buffer), sum, & ctx);
  }
#line 180
  sha1_finish_ctx(& ctx, resblock);
#line 181
  return (0);
}
}
#line 188 "sha1.c"
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha1_ctx ctx ;
  void *__cil_tmp ;

  {
#line 194
  sha1_init_ctx(& ctx);
#line 197
  sha1_process_bytes((void const   *)buffer, len, & ctx);
#line 200
  __cil_tmp = sha1_finish_ctx(& ctx, resblock);
#line 200
  return (__cil_tmp);
}
}
#line 203 "sha1.c"
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  void *__cil_tmp ;
  size_t left_over___0 ;

  {
#line 208
  if (ctx->buflen != 0U) {
#line 210
    left_over = ctx->buflen;
#line 211
    add = 128U - left_over > len ? len : 128U - left_over;
#line 213
    memcpy((void *)((char *)(ctx->buffer) + left_over), buffer, add);
#line 214
    ctx->buflen += add;
#line 216
    if (ctx->buflen > 64U) {
#line 218
      sha1_process_block((void const   *)(ctx->buffer), ctx->buflen & 4294967232U,
                         ctx);
#line 220
      ctx->buflen &= 63U;
#line 222
      memcpy((void *)(ctx->buffer), (void const   *)((char *)(ctx->buffer) + ((left_over + add) & 4294967232U)),
             ctx->buflen);
    }
#line 227
    buffer = (void const   *)((char const   *)buffer + add);
#line 228
    len -= add;
  }
#line 232
  if (len >= 64U) {
#line 237
    if ((unsigned int )buffer % (unsigned int )((char *)(& ((struct __anonstruct_9 *)0)->x)) != 0U) {
#line 238
      while (len > 64U) {
#line 240
        __cil_tmp = memcpy((void *)(ctx->buffer), buffer, 64U);
#line 240
        sha1_process_block((void const   *)__cil_tmp, 64U, ctx);
#line 241
        buffer = (void const   *)((char const   *)buffer + 64);
#line 242
        len -= 64U;
      }
    } else {
#line 247
      sha1_process_block(buffer, len & 4294967232U, ctx);
#line 248
      buffer = (void const   *)((char const   *)buffer + (len & 4294967232U));
#line 249
      len &= 63U;
    }
  }
#line 254
  if (len > 0U) {
#line 256
    left_over___0 = ctx->buflen;
#line 258
    memcpy((void *)((char *)(ctx->buffer) + left_over___0), buffer, len);
#line 259
    left_over___0 += len;
#line 260
    if (left_over___0 >= 64U) {
#line 262
      sha1_process_block((void const   *)(ctx->buffer), 64U, ctx);
#line 263
      left_over___0 -= 64U;
#line 264
      memcpy((void *)(ctx->buffer), (void const   *)(& ctx->buffer[16]), left_over___0);
    }
#line 266
    ctx->buflen = left_over___0;
  }
#line 268
  return;
}
}
#line 288 "sha1.c"
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ unsigned int const   *words ;
  size_t nwords ;
  unsigned int const   *endp ;
  unsigned int x[16] ;
  unsigned int a ;
  unsigned int b ;
  unsigned int c ;
  unsigned int d ;
  unsigned int e ;
  unsigned int tm ;
  int t ;
  unsigned int __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  unsigned int __cil_tmp___1 ;
  unsigned int __cil_tmp___2 ;
  unsigned int __cil_tmp___3 ;

  {
#line 291
  words = (unsigned int const   *)buffer;
#line 292
  nwords = len / sizeof(unsigned int );
#line 293
  endp = words + nwords;
#line 295
  a = ctx->A;
#line 296
  b = ctx->B;
#line 297
  c = ctx->C;
#line 298
  d = ctx->D;
#line 299
  e = ctx->E;
#line 304
  ctx->total[0] += len;
#line 305
  if (ctx->total[0] < len) {
#line 306
    (ctx->total[1]) ++;
  }
#line 321
  while ((unsigned int )words < (unsigned int )endp) {
#line 325
    t = 0;
#line 325
    while (t < 16) {
#line 327
      x[t] = (unsigned int )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 328
      words ++;
#line 325
      t ++;
    }
#line 331
    while (1) {
#line 331
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[0];
#line 331
      b = (b << 30) | (b >> 2);
#line 331
      break;
    }
#line 332
    while (1) {
#line 332
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[1];
#line 332
      a = (a << 30) | (a >> 2);
#line 332
      break;
    }
#line 333
    while (1) {
#line 333
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[2];
#line 333
      e = (e << 30) | (e >> 2);
#line 333
      break;
    }
#line 334
    while (1) {
#line 334
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[3];
#line 334
      d = (d << 30) | (d >> 2);
#line 334
      break;
    }
#line 335
    while (1) {
#line 335
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[4];
#line 335
      c = (c << 30) | (c >> 2);
#line 335
      break;
    }
#line 336
    while (1) {
#line 336
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[5];
#line 336
      b = (b << 30) | (b >> 2);
#line 336
      break;
    }
#line 337
    while (1) {
#line 337
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[6];
#line 337
      a = (a << 30) | (a >> 2);
#line 337
      break;
    }
#line 338
    while (1) {
#line 338
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[7];
#line 338
      e = (e << 30) | (e >> 2);
#line 338
      break;
    }
#line 339
    while (1) {
#line 339
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[8];
#line 339
      d = (d << 30) | (d >> 2);
#line 339
      break;
    }
#line 340
    while (1) {
#line 340
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[9];
#line 340
      c = (c << 30) | (c >> 2);
#line 340
      break;
    }
#line 341
    while (1) {
#line 341
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[10];
#line 341
      b = (b << 30) | (b >> 2);
#line 341
      break;
    }
#line 342
    while (1) {
#line 342
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[11];
#line 342
      a = (a << 30) | (a >> 2);
#line 342
      break;
    }
#line 343
    while (1) {
#line 343
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[12];
#line 343
      e = (e << 30) | (e >> 2);
#line 343
      break;
    }
#line 344
    while (1) {
#line 344
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[13];
#line 344
      d = (d << 30) | (d >> 2);
#line 344
      break;
    }
#line 345
    while (1) {
#line 345
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[14];
#line 345
      c = (c << 30) | (c >> 2);
#line 345
      break;
    }
#line 346
    while (1) {
#line 346
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[15];
#line 346
      b = (b << 30) | (b >> 2);
#line 346
      break;
    }
#line 347
    while (1) {
#line 347
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 347
      x[0] = (tm << 1) | (tm >> 31);
#line 347
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[0];
#line 347
      a = (a << 30) | (a >> 2);
#line 347
      break;
    }
#line 348
    while (1) {
#line 348
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 348
      x[1] = (tm << 1) | (tm >> 31);
#line 348
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[1];
#line 348
      e = (e << 30) | (e >> 2);
#line 348
      break;
    }
#line 349
    while (1) {
#line 349
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 349
      x[2] = (tm << 1) | (tm >> 31);
#line 349
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[2];
#line 349
      d = (d << 30) | (d >> 2);
#line 349
      break;
    }
#line 350
    while (1) {
#line 350
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 350
      x[3] = (tm << 1) | (tm >> 31);
#line 350
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[3];
#line 350
      c = (c << 30) | (c >> 2);
#line 350
      break;
    }
#line 351
    while (1) {
#line 351
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 351
      x[4] = (tm << 1) | (tm >> 31);
#line 351
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[4];
#line 351
      b = (b << 30) | (b >> 2);
#line 351
      break;
    }
#line 352
    while (1) {
#line 352
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 352
      x[5] = (tm << 1) | (tm >> 31);
#line 352
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[5];
#line 352
      a = (a << 30) | (a >> 2);
#line 352
      break;
    }
#line 353
    while (1) {
#line 353
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 353
      x[6] = (tm << 1) | (tm >> 31);
#line 353
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[6];
#line 353
      e = (e << 30) | (e >> 2);
#line 353
      break;
    }
#line 354
    while (1) {
#line 354
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 354
      x[7] = (tm << 1) | (tm >> 31);
#line 354
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[7];
#line 354
      d = (d << 30) | (d >> 2);
#line 354
      break;
    }
#line 355
    while (1) {
#line 355
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 355
      x[8] = (tm << 1) | (tm >> 31);
#line 355
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[8];
#line 355
      c = (c << 30) | (c >> 2);
#line 355
      break;
    }
#line 356
    while (1) {
#line 356
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 356
      x[9] = (tm << 1) | (tm >> 31);
#line 356
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[9];
#line 356
      b = (b << 30) | (b >> 2);
#line 356
      break;
    }
#line 357
    while (1) {
#line 357
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 357
      x[10] = (tm << 1) | (tm >> 31);
#line 357
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[10];
#line 357
      a = (a << 30) | (a >> 2);
#line 357
      break;
    }
#line 358
    while (1) {
#line 358
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 358
      x[11] = (tm << 1) | (tm >> 31);
#line 358
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[11];
#line 358
      e = (e << 30) | (e >> 2);
#line 358
      break;
    }
#line 359
    while (1) {
#line 359
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 359
      x[12] = (tm << 1) | (tm >> 31);
#line 359
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[12];
#line 359
      d = (d << 30) | (d >> 2);
#line 359
      break;
    }
#line 360
    while (1) {
#line 360
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 360
      x[13] = (tm << 1) | (tm >> 31);
#line 360
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[13];
#line 360
      c = (c << 30) | (c >> 2);
#line 360
      break;
    }
#line 361
    while (1) {
#line 361
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 361
      x[14] = (tm << 1) | (tm >> 31);
#line 361
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[14];
#line 361
      b = (b << 30) | (b >> 2);
#line 361
      break;
    }
#line 362
    while (1) {
#line 362
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 362
      x[15] = (tm << 1) | (tm >> 31);
#line 362
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[15];
#line 362
      a = (a << 30) | (a >> 2);
#line 362
      break;
    }
#line 363
    while (1) {
#line 363
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 363
      x[0] = (tm << 1) | (tm >> 31);
#line 363
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[0];
#line 363
      e = (e << 30) | (e >> 2);
#line 363
      break;
    }
#line 364
    while (1) {
#line 364
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 364
      x[1] = (tm << 1) | (tm >> 31);
#line 364
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[1];
#line 364
      d = (d << 30) | (d >> 2);
#line 364
      break;
    }
#line 365
    while (1) {
#line 365
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 365
      x[2] = (tm << 1) | (tm >> 31);
#line 365
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[2];
#line 365
      c = (c << 30) | (c >> 2);
#line 365
      break;
    }
#line 366
    while (1) {
#line 366
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 366
      x[3] = (tm << 1) | (tm >> 31);
#line 366
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[3];
#line 366
      b = (b << 30) | (b >> 2);
#line 366
      break;
    }
#line 367
    while (1) {
#line 367
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 367
      x[4] = (tm << 1) | (tm >> 31);
#line 367
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[4];
#line 367
      a = (a << 30) | (a >> 2);
#line 367
      break;
    }
#line 368
    while (1) {
#line 368
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 368
      x[5] = (tm << 1) | (tm >> 31);
#line 368
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[5];
#line 368
      e = (e << 30) | (e >> 2);
#line 368
      break;
    }
#line 369
    while (1) {
#line 369
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 369
      x[6] = (tm << 1) | (tm >> 31);
#line 369
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[6];
#line 369
      d = (d << 30) | (d >> 2);
#line 369
      break;
    }
#line 370
    while (1) {
#line 370
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 370
      x[7] = (tm << 1) | (tm >> 31);
#line 370
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[7];
#line 370
      c = (c << 30) | (c >> 2);
#line 370
      break;
    }
#line 371
    while (1) {
#line 371
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 371
      x[8] = (tm << 1) | (tm >> 31);
#line 371
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[8];
#line 371
      b = (b << 30) | (b >> 2);
#line 371
      break;
    }
#line 372
    while (1) {
#line 372
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 372
      x[9] = (tm << 1) | (tm >> 31);
#line 372
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[9];
#line 372
      a = (a << 30) | (a >> 2);
#line 372
      break;
    }
#line 373
    while (1) {
#line 373
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 373
      x[10] = (tm << 1) | (tm >> 31);
#line 373
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[10];
#line 373
      e = (e << 30) | (e >> 2);
#line 373
      break;
    }
#line 374
    while (1) {
#line 374
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 374
      x[11] = (tm << 1) | (tm >> 31);
#line 374
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[11];
#line 374
      d = (d << 30) | (d >> 2);
#line 374
      break;
    }
#line 375
    while (1) {
#line 375
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 375
      x[12] = (tm << 1) | (tm >> 31);
#line 375
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[12];
#line 375
      c = (c << 30) | (c >> 2);
#line 375
      break;
    }
#line 376
    while (1) {
#line 376
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 376
      x[13] = (tm << 1) | (tm >> 31);
#line 376
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[13];
#line 376
      b = (b << 30) | (b >> 2);
#line 376
      break;
    }
#line 377
    while (1) {
#line 377
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 377
      x[14] = (tm << 1) | (tm >> 31);
#line 377
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[14];
#line 377
      a = (a << 30) | (a >> 2);
#line 377
      break;
    }
#line 378
    while (1) {
#line 378
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 378
      x[15] = (tm << 1) | (tm >> 31);
#line 378
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[15];
#line 378
      e = (e << 30) | (e >> 2);
#line 378
      break;
    }
#line 379
    while (1) {
#line 379
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 379
      x[0] = (tm << 1) | (tm >> 31);
#line 379
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[0];
#line 379
      d = (d << 30) | (d >> 2);
#line 379
      break;
    }
#line 380
    while (1) {
#line 380
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 380
      x[1] = (tm << 1) | (tm >> 31);
#line 380
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[1];
#line 380
      c = (c << 30) | (c >> 2);
#line 380
      break;
    }
#line 381
    while (1) {
#line 381
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 381
      x[2] = (tm << 1) | (tm >> 31);
#line 381
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[2];
#line 381
      b = (b << 30) | (b >> 2);
#line 381
      break;
    }
#line 382
    while (1) {
#line 382
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 382
      x[3] = (tm << 1) | (tm >> 31);
#line 382
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[3];
#line 382
      a = (a << 30) | (a >> 2);
#line 382
      break;
    }
#line 383
    while (1) {
#line 383
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 383
      x[4] = (tm << 1) | (tm >> 31);
#line 383
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[4];
#line 383
      e = (e << 30) | (e >> 2);
#line 383
      break;
    }
#line 384
    while (1) {
#line 384
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 384
      x[5] = (tm << 1) | (tm >> 31);
#line 384
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[5];
#line 384
      d = (d << 30) | (d >> 2);
#line 384
      break;
    }
#line 385
    while (1) {
#line 385
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 385
      x[6] = (tm << 1) | (tm >> 31);
#line 385
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[6];
#line 385
      c = (c << 30) | (c >> 2);
#line 385
      break;
    }
#line 386
    while (1) {
#line 386
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 386
      x[7] = (tm << 1) | (tm >> 31);
#line 386
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[7];
#line 386
      b = (b << 30) | (b >> 2);
#line 386
      break;
    }
#line 387
    while (1) {
#line 387
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 387
      x[8] = (tm << 1) | (tm >> 31);
#line 387
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[8];
#line 387
      a = (a << 30) | (a >> 2);
#line 387
      break;
    }
#line 388
    while (1) {
#line 388
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 388
      x[9] = (tm << 1) | (tm >> 31);
#line 388
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[9];
#line 388
      e = (e << 30) | (e >> 2);
#line 388
      break;
    }
#line 389
    while (1) {
#line 389
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 389
      x[10] = (tm << 1) | (tm >> 31);
#line 389
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[10];
#line 389
      d = (d << 30) | (d >> 2);
#line 389
      break;
    }
#line 390
    while (1) {
#line 390
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 390
      x[11] = (tm << 1) | (tm >> 31);
#line 390
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[11];
#line 390
      c = (c << 30) | (c >> 2);
#line 390
      break;
    }
#line 391
    while (1) {
#line 391
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 391
      x[12] = (tm << 1) | (tm >> 31);
#line 391
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[12];
#line 391
      b = (b << 30) | (b >> 2);
#line 391
      break;
    }
#line 392
    while (1) {
#line 392
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 392
      x[13] = (tm << 1) | (tm >> 31);
#line 392
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[13];
#line 392
      a = (a << 30) | (a >> 2);
#line 392
      break;
    }
#line 393
    while (1) {
#line 393
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 393
      x[14] = (tm << 1) | (tm >> 31);
#line 393
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[14];
#line 393
      e = (e << 30) | (e >> 2);
#line 393
      break;
    }
#line 394
    while (1) {
#line 394
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 394
      x[15] = (tm << 1) | (tm >> 31);
#line 394
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[15];
#line 394
      d = (d << 30) | (d >> 2);
#line 394
      break;
    }
#line 395
    while (1) {
#line 395
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 395
      x[0] = (tm << 1) | (tm >> 31);
#line 395
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[0];
#line 395
      c = (c << 30) | (c >> 2);
#line 395
      break;
    }
#line 396
    while (1) {
#line 396
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 396
      x[1] = (tm << 1) | (tm >> 31);
#line 396
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[1];
#line 396
      b = (b << 30) | (b >> 2);
#line 396
      break;
    }
#line 397
    while (1) {
#line 397
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 397
      x[2] = (tm << 1) | (tm >> 31);
#line 397
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[2];
#line 397
      a = (a << 30) | (a >> 2);
#line 397
      break;
    }
#line 398
    while (1) {
#line 398
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 398
      x[3] = (tm << 1) | (tm >> 31);
#line 398
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[3];
#line 398
      e = (e << 30) | (e >> 2);
#line 398
      break;
    }
#line 399
    while (1) {
#line 399
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 399
      x[4] = (tm << 1) | (tm >> 31);
#line 399
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[4];
#line 399
      d = (d << 30) | (d >> 2);
#line 399
      break;
    }
#line 400
    while (1) {
#line 400
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 400
      x[5] = (tm << 1) | (tm >> 31);
#line 400
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[5];
#line 400
      c = (c << 30) | (c >> 2);
#line 400
      break;
    }
#line 401
    while (1) {
#line 401
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 401
      x[6] = (tm << 1) | (tm >> 31);
#line 401
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[6];
#line 401
      b = (b << 30) | (b >> 2);
#line 401
      break;
    }
#line 402
    while (1) {
#line 402
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 402
      x[7] = (tm << 1) | (tm >> 31);
#line 402
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[7];
#line 402
      a = (a << 30) | (a >> 2);
#line 402
      break;
    }
#line 403
    while (1) {
#line 403
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 403
      x[8] = (tm << 1) | (tm >> 31);
#line 403
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[8];
#line 403
      e = (e << 30) | (e >> 2);
#line 403
      break;
    }
#line 404
    while (1) {
#line 404
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 404
      x[9] = (tm << 1) | (tm >> 31);
#line 404
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[9];
#line 404
      d = (d << 30) | (d >> 2);
#line 404
      break;
    }
#line 405
    while (1) {
#line 405
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 405
      x[10] = (tm << 1) | (tm >> 31);
#line 405
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[10];
#line 405
      c = (c << 30) | (c >> 2);
#line 405
      break;
    }
#line 406
    while (1) {
#line 406
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 406
      x[11] = (tm << 1) | (tm >> 31);
#line 406
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[11];
#line 406
      b = (b << 30) | (b >> 2);
#line 406
      break;
    }
#line 407
    while (1) {
#line 407
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 407
      x[12] = (tm << 1) | (tm >> 31);
#line 407
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[12];
#line 407
      a = (a << 30) | (a >> 2);
#line 407
      break;
    }
#line 408
    while (1) {
#line 408
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 408
      x[13] = (tm << 1) | (tm >> 31);
#line 408
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[13];
#line 408
      e = (e << 30) | (e >> 2);
#line 408
      break;
    }
#line 409
    while (1) {
#line 409
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 409
      x[14] = (tm << 1) | (tm >> 31);
#line 409
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[14];
#line 409
      d = (d << 30) | (d >> 2);
#line 409
      break;
    }
#line 410
    while (1) {
#line 410
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 410
      x[15] = (tm << 1) | (tm >> 31);
#line 410
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[15];
#line 410
      c = (c << 30) | (c >> 2);
#line 410
      break;
    }
#line 412
    __cil_tmp = ctx->A + a;
#line 412
    ctx->A = __cil_tmp;
#line 412
    a = __cil_tmp;
#line 413
    __cil_tmp___0 = ctx->B + b;
#line 413
    ctx->B = __cil_tmp___0;
#line 413
    b = __cil_tmp___0;
#line 414
    __cil_tmp___1 = ctx->C + c;
#line 414
    ctx->C = __cil_tmp___1;
#line 414
    c = __cil_tmp___1;
#line 415
    __cil_tmp___2 = ctx->D + d;
#line 415
    ctx->D = __cil_tmp___2;
#line 415
    d = __cil_tmp___2;
#line 416
    __cil_tmp___3 = ctx->E + e;
#line 416
    ctx->E = __cil_tmp___3;
#line 416
    e = __cil_tmp___3;
  }
#line 418
  return;
}
}
#line 1 "sig2str.o"
#pragma merger(0,"/tmp/cil-aLUPqPkx.i","-g,-O2")
#line 30 "sig2str.h"
int sig2str(int signum , char *signame ) ;
#line 31
int str2sig(char const   *signame , int *signum ) ;
#line 41 "sig2str.c"
static struct numname numname_table[35]  = 
#line 41 "sig2str.c"
  {      {1, {(char const   )'H', (char const   )'U', (char const   )'P', (char const   )'\000',
          (char const   )(char)0, (char const   )(char)0, (char const   )(char)0,
          (char const   )(char)0}}, 
        {2, {(char const   )'I', (char const   )'N', (char const   )'T', (char const   )'\000',
          (char const   )(char)0, (char const   )(char)0, (char const   )(char)0,
          (char const   )(char)0}}, 
        {3, {(char const   )'Q', (char const   )'U', (char const   )'I', (char const   )'T',
          (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {4,
      {(char const   )'I', (char const   )'L', (char const   )'L', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {5,
      {(char const   )'T', (char const   )'R', (char const   )'A', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {6,
      {(char const   )'A', (char const   )'B', (char const   )'R', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {8,
      {(char const   )'F', (char const   )'P', (char const   )'E', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {9,
      {(char const   )'K', (char const   )'I', (char const   )'L', (char const   )'L',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {10,
      {(char const   )'B', (char const   )'U', (char const   )'S', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {11,
      {(char const   )'S', (char const   )'E', (char const   )'G', (char const   )'V',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {13,
      {(char const   )'P', (char const   )'I', (char const   )'P', (char const   )'E',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {14,
      {(char const   )'A', (char const   )'L', (char const   )'R', (char const   )'M',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {15,
      {(char const   )'T', (char const   )'E', (char const   )'R', (char const   )'M',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {30,
      {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'1',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {31,
      {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'2',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {20,
      {(char const   )'C', (char const   )'H', (char const   )'L', (char const   )'D',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {16,
      {(char const   )'U', (char const   )'R', (char const   )'G', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {17,
      {(char const   )'S', (char const   )'T', (char const   )'O', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {18,
      {(char const   )'T', (char const   )'S', (char const   )'T', (char const   )'P',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {19,
      {(char const   )'C', (char const   )'O', (char const   )'N', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {21,
      {(char const   )'T', (char const   )'T', (char const   )'I', (char const   )'N',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {22,
      {(char const   )'T', (char const   )'T', (char const   )'O', (char const   )'U',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {12,
      {(char const   )'S', (char const   )'Y', (char const   )'S', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {23,
      {(char const   )'P', (char const   )'O', (char const   )'L', (char const   )'L',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {26,
      {(char const   )'V', (char const   )'T', (char const   )'A', (char const   )'L',
       (char const   )'R', (char const   )'M', (char const   )'\000', (char const   )(char)0}}, 
        {27,
      {(char const   )'P', (char const   )'R', (char const   )'O', (char const   )'F',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {24,
      {(char const   )'X', (char const   )'C', (char const   )'P', (char const   )'U',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {25,
      {(char const   )'X', (char const   )'F', (char const   )'S', (char const   )'Z',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {6,
      {(char const   )'I', (char const   )'O', (char const   )'T', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {7,
      {(char const   )'E', (char const   )'M', (char const   )'T', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {20,
      {(char const   )'C', (char const   )'L', (char const   )'D', (char const   )'\000',
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {29,
      {(char const   )'L', (char const   )'O', (char const   )'S', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {28,
      {(char const   )'W', (char const   )'I', (char const   )'N', (char const   )'C',
       (char const   )'H', (char const   )'\000', (char const   )(char)0, (char const   )(char)0}}, 
        {23,
      {(char const   )'I', (char const   )'O', (char const   )'\000', (char const   )(char)0,
       (char const   )(char)0, (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}, 
        {0,
      {(char const   )'E', (char const   )'X', (char const   )'I', (char const   )'T',
       (char const   )'\000', (char const   )(char)0, (char const   )(char)0, (char const   )(char)0}}};
#line 258 "sig2str.c"
static int str2signum(char const   *signame ) 
{ char *endp ;
  long n ;
  long __cil_tmp ;
  unsigned int i ;
  int __cil_tmp___0 ;
  char *endp___0 ;
  int rtmin ;
  int rtmax ;
  long n___0 ;
  long __cil_tmp___1 ;
  long n___1 ;
  long __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 261
  if ((unsigned int )*signame - 48U <= 9U) {
#line 264
    __cil_tmp = strtol(signame, & endp, 10);
#line 264
    n = __cil_tmp;
#line 265
    if (! *endp && n <= 31L) {
#line 266
      return ((int )n);
    }
  } else {
#line 271
    i = 0U;
#line 271
    while (i < sizeof(numname_table) / sizeof(numname_table[0])) {
#line 272
      __cil_tmp___0 = strcmp(numname_table[i].name, signame);
#line 272
      if (__cil_tmp___0 == 0) {
#line 273
        return (numname_table[i].num);
      }
#line 271
      i ++;
    }
#line 277
    rtmin = 0;
#line 278
    rtmax = -1;
#line 280
    if (0 < rtmin) {
#line 280
      __cil_tmp___4 = strncmp(signame, "RTMIN", 5U);
#line 280
      if (__cil_tmp___4 == 0) {
#line 282
        __cil_tmp___1 = strtol(signame + 5, & endp___0, 10);
#line 282
        n___0 = __cil_tmp___1;
#line 283
        if ((! *endp___0 && 0L <= n___0) && n___0 <= (long )(rtmax - rtmin)) {
#line 284
          return ((int )((long )rtmin + n___0));
        }
      } else {
#line 280
        goto _L;
      }
    } else
    _L: 
#line 286
    if (0 < rtmax) {
#line 286
      __cil_tmp___3 = strncmp(signame, "RTMAX", 5U);
#line 286
      if (__cil_tmp___3 == 0) {
#line 288
        __cil_tmp___2 = strtol(signame + 5, & endp___0, 10);
#line 288
        n___1 = __cil_tmp___2;
#line 289
        if ((! *endp___0 && (long )(rtmin - rtmax) <= n___1) && n___1 <= 0L) {
#line 290
          return ((int )((long )rtmax + n___1));
        }
      }
    }
  }
#line 295
  return (-1);
}
}
#line 301 "sig2str.c"
int str2sig(char const   *signame , int *signum ) 
{ 

  {
#line 304
  *signum = str2signum(signame);
#line 305
  return (*signum < 0 ? -1 : 0);
}
}
#line 312 "sig2str.c"
int sig2str(int signum , char *signame ) 
{ unsigned int i ;
  int rtmin ;
  int rtmax ;
  int delta ;
  int delta___0 ;

  {
#line 316
  i = 0U;
#line 316
  while (i < sizeof(numname_table) / sizeof(numname_table[0])) {
#line 317
    if (numname_table[i].num == signum) {
#line 319
      strcpy(signame, numname_table[i].name);
#line 320
      return (0);
    }
#line 316
    i ++;
  }
#line 324
  rtmin = 0;
#line 325
  rtmax = -1;
#line 327
  if (! (rtmin <= signum && signum <= rtmax)) {
#line 328
    return (-1);
  }
#line 330
  if (signum <= rtmin + (rtmax - rtmin) / 2) {
#line 332
    delta = signum - rtmin;
#line 333
    sprintf(signame, delta ? "RTMIN+%d" : "RTMIN", delta);
  } else {
#line 337
    delta___0 = rtmax - signum;
#line 338
    sprintf(signame, delta___0 ? "RTMAX-%d" : "RTMAX", delta___0);
  }
#line 341
  return (0);
}
}
#line 1 "signbitd.o"
#pragma merger(0,"/tmp/cil-Hk2TXkY7.i","-g,-O2")
#line 388 "./math.h"
int gl_signbitd(double arg ) ;
#line 55 "signbitd.c"
static double plus_zero  =    0.0;
#line 28 "signbitd.c"
int gl_signbitd(double arg ) 
{ int __cil_tmp ;
  double arg_mem ;
  int __cil_tmp___0 ;

  {
#line 48
  __cil_tmp = rpl_isnan(arg);
#line 48
  if (__cil_tmp) {
#line 49
    return (0);
  }
#line 50
  if (arg < 0.0) {
#line 51
    return (1);
  } else
#line 52
  if (arg == 0.0) {
#line 56
    arg_mem = arg;
#line 57
    __cil_tmp___0 = rpl_memcmp((void const   *)(& plus_zero), (void const   *)(& arg_mem),
                               8U);
#line 57
    return (__cil_tmp___0 != 0);
  } else {
#line 60
    return (0);
  }
}
}
#line 1 "signbitf.o"
#pragma merger(0,"/tmp/cil-okBQKYss.i","-g,-O2")
#line 387 "./math.h"
int gl_signbitf(float arg ) ;
#line 55 "signbitf.c"
static float plus_zero___0  =    0.0f;
#line 28 "signbitf.c"
int gl_signbitf(float arg ) 
{ int __cil_tmp ;
  float arg_mem ;
  int __cil_tmp___0 ;

  {
#line 48
  __cil_tmp = rpl_isnanf(arg);
#line 48
  if (__cil_tmp) {
#line 49
    return (0);
  }
#line 50
  if (arg < 0.0f) {
#line 51
    return (1);
  } else
#line 52
  if (arg == 0.0f) {
#line 56
    arg_mem = arg;
#line 57
    __cil_tmp___0 = rpl_memcmp((void const   *)(& plus_zero___0), (void const   *)(& arg_mem),
                               4U);
#line 57
    return (__cil_tmp___0 != 0);
  } else {
#line 60
    return (0);
  }
}
}
#line 1 "signbitl.o"
#pragma merger(0,"/tmp/cil-HlfbzZeK.i","-g,-O2")
#line 389 "./math.h"
int gl_signbitl(long double arg ) ;
#line 55 "signbitl.c"
static long double plus_zero___1  =    0.0L;
#line 28 "signbitl.c"
int gl_signbitl(long double arg ) 
{ int __cil_tmp ;
  long double arg_mem ;
  int __cil_tmp___0 ;

  {
#line 48
  __cil_tmp = rpl_isnanl(arg);
#line 48
  if (__cil_tmp) {
#line 49
    return (0);
  }
#line 50
  if (arg < 0.0L) {
#line 51
    return (1);
  } else
#line 52
  if (arg == 0.0L) {
#line 56
    arg_mem = arg;
#line 57
    __cil_tmp___0 = rpl_memcmp((void const   *)(& plus_zero___1), (void const   *)(& arg_mem),
                               8U);
#line 57
    return (__cil_tmp___0 != 0);
  } else {
#line 60
    return (0);
  }
}
}
#line 1 "snprintf.o"
#pragma merger(0,"/tmp/cil-JxskHUMX.i","-g,-O2")
#line 44 "snprintf.c"
int snprintf(char *str , size_t size , char const   *format  , ...) 
{ char *output ;
  size_t len ;
  size_t lenbuf ;
  va_list args ;
  size_t pruned_len ;
  int *__cil_tmp ;

  {
#line 49
  lenbuf = size;
#line 52
  __builtin_va_start(args, format);
#line 53
  output = vasnprintf(str, & lenbuf, format, args);
#line 54
  len = lenbuf;
#line 55
  __builtin_va_end(args);
#line 57
  if (! output) {
#line 58
    return (-1);
  }
#line 60
  if ((unsigned int )output != (unsigned int )str) {
#line 62
    if (size) {
#line 64
      pruned_len = len < size ? len : size - 1U;
#line 65
      memcpy((void *)str, (void const   *)output, pruned_len);
#line 66
      *(str + pruned_len) = (char )'\000';
    }
#line 69
    free((void *)output);
  }
#line 72
  if (2147483647U < len) {
#line 74
    __cil_tmp = __errno();
#line 74
    *__cil_tmp = 139;
#line 75
    return (-1);
  }
#line 78
  return ((int )len);
}
}
#line 1 "stpncpy.o"
#pragma merger(0,"/tmp/cil-7UNuARlu.i","-g,-O2")
#line 145 "./string.h"
char *gnu_stpncpy(char * __restrict  dest , char const   * __restrict  src , size_t n ) ;
#line 32 "stpncpy.c"
char *gnu_stpncpy(char * __restrict  dest , char const   * __restrict  src , size_t n ) 
{ char c ;
  char *s ;
  size_t n4 ;
  char const   * __restrict  __cil_tmp ;
  char * __restrict  __cil_tmp___0 ;
  char const   * __restrict  __cil_tmp___1 ;
  char * __restrict  __cil_tmp___2 ;
  char const   * __restrict  __cil_tmp___3 ;
  char * __restrict  __cil_tmp___4 ;
  char const   * __restrict  __cil_tmp___5 ;
  char * __restrict  __cil_tmp___6 ;
  char const   * __restrict  __cil_tmp___7 ;
  char * __restrict  __cil_tmp___8 ;
  size_t __cil_tmp___9 ;

  {
#line 36
  s = (char *)dest;
#line 38
  if (n >= 4U) {
#line 40
    n4 = n >> 2;
#line 42
    while (1) {
#line 44
      __cil_tmp = src;
#line 44
      src ++;
#line 44
      c = (char )*__cil_tmp;
#line 45
      __cil_tmp___0 = dest;
#line 45
      dest ++;
#line 45
      *__cil_tmp___0 = c;
#line 46
      if ((int )c == 0) {
#line 47
        break;
      }
#line 48
      __cil_tmp___1 = src;
#line 48
      src ++;
#line 48
      c = (char )*__cil_tmp___1;
#line 49
      __cil_tmp___2 = dest;
#line 49
      dest ++;
#line 49
      *__cil_tmp___2 = c;
#line 50
      if ((int )c == 0) {
#line 51
        break;
      }
#line 52
      __cil_tmp___3 = src;
#line 52
      src ++;
#line 52
      c = (char )*__cil_tmp___3;
#line 53
      __cil_tmp___4 = dest;
#line 53
      dest ++;
#line 53
      *__cil_tmp___4 = c;
#line 54
      if ((int )c == 0) {
#line 55
        break;
      }
#line 56
      __cil_tmp___5 = src;
#line 56
      src ++;
#line 56
      c = (char )*__cil_tmp___5;
#line 57
      __cil_tmp___6 = dest;
#line 57
      dest ++;
#line 57
      *__cil_tmp___6 = c;
#line 58
      if ((int )c == 0) {
#line 59
        break;
      }
#line 60
      n4 --;
#line 60
      if (n4 == 0U) {
#line 61
        goto last_chars;
      }
    }
#line 63
    n -= (unsigned int )(dest - (char * __restrict  )s);
#line 64
    goto zero_fill;
  }
  last_chars: 
#line 68
  n &= 3U;
#line 69
  if (n == 0U) {
#line 70
    return ((char *)dest);
  }
#line 72
  while (1) {
#line 74
    __cil_tmp___7 = src;
#line 74
    src ++;
#line 74
    c = (char )*__cil_tmp___7;
#line 75
    n --;
#line 76
    __cil_tmp___8 = dest;
#line 76
    dest ++;
#line 76
    *__cil_tmp___8 = c;
#line 77
    if ((int )c == 0) {
#line 78
      break;
    }
#line 79
    if (n == 0U) {
#line 80
      return ((char *)dest);
    }
  }
  zero_fill: 
#line 84
  while (1) {
#line 84
    __cil_tmp___9 = n;
#line 84
    n --;
#line 84
    if (! (__cil_tmp___9 > 0U)) {
#line 84
      break;
    }
#line 85
    *(dest + n) = (char )'\000';
  }
#line 87
  return ((char *)(dest - 1));
}
}
#line 1 "strftime.o"
#pragma merger(0,"/tmp/cil-7tUn2dZE.i","-g,-O2")
#line 61 "strftime.c"
static mbstate_t const   mbstate_zero___0  ;
#line 311 "strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ unsigned char __x ;
  size_t __cil_tmp ;

  {
#line 315
  while (1) {
#line 315
    __cil_tmp = len;
#line 315
    len --;
#line 315
    if (! (__cil_tmp > 0U)) {
#line 315
      break;
    }
#line 316
    __x = (unsigned char )*(src + len);
#line 316
    *(dest + len) = (char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 1 ? ((int )__x - 65) + 97 : (int )__x);
  }
#line 317
  return (dest);
}
}
#line 320 "strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ unsigned char __x ;
  size_t __cil_tmp ;

  {
#line 324
  while (1) {
#line 324
    __cil_tmp = len;
#line 324
    len --;
#line 324
    if (! (__cil_tmp > 0U)) {
#line 324
      break;
    }
#line 325
    __x = (unsigned char )*(src + len);
#line 325
    *(dest + len) = (char )(((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 2 ? ((int )__x - 97) + 65 : (int )__x);
  }
#line 326
  return (dest);
}
}
#line 335 "strftime.c"
static int ftime_tm_diff___0(struct tm  const  *a , struct tm  const  *b ) 
{ int a4 ;
  int b4 ;
  int a100 ;
  int b100 ;
  int a400 ;
  int b400 ;
  int intervening_leap_days ;
  int years ;
  int days ;

  {
#line 341
  a4 = (int )(((-1 >> 1 == -1 ? a->tm_year >> 2 : a->tm_year / (int const   )(1 << 2) - (int const   )(a->tm_year % (int const   )(1 << 2) < 0)) + (int const   )(-1 >> 1 == -1 ? 1900 >> 2 : 1900 / (1 << 2) - (1900 % (1 << 2) < 0))) - (int const   )(! (a->tm_year & 3)));
#line 342
  b4 = (int )(((-1 >> 1 == -1 ? b->tm_year >> 2 : b->tm_year / (int const   )(1 << 2) - (int const   )(b->tm_year % (int const   )(1 << 2) < 0)) + (int const   )(-1 >> 1 == -1 ? 1900 >> 2 : 1900 / (1 << 2) - (1900 % (1 << 2) < 0))) - (int const   )(! (b->tm_year & 3)));
#line 343
  a100 = a4 / 25 - (a4 % 25 < 0);
#line 344
  b100 = b4 / 25 - (b4 % 25 < 0);
#line 345
  a400 = -1 >> 1 == -1 ? a100 >> 2 : a100 / (1 << 2) - (a100 % (1 << 2) < 0);
#line 346
  b400 = -1 >> 1 == -1 ? b100 >> 2 : b100 / (1 << 2) - (b100 % (1 << 2) < 0);
#line 347
  intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
#line 348
  years = (int )(a->tm_year - b->tm_year);
#line 349
  days = (365 * years + intervening_leap_days) + (int )(a->tm_yday - b->tm_yday);
#line 351
  return (60 * (60 * (24 * days + (int )(a->tm_hour - b->tm_hour)) + (int )(a->tm_min - b->tm_min)) + (int )(a->tm_sec - b->tm_sec));
}
}
#line 415 "strftime.c"
static size_t strftime_case____0(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                                 struct tm  const  *tp , int ut , int ns ) 
{ int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  char const   *format_end ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___0[3U + (((sizeof(int ) * 8U - 1U) * 146U) / 485U + 2U)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  mbstate_t mbstate ;
  size_t len ;
  size_t fsize ;
  size_t __cil_tmp ;
  size_t bytes ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  char const   *__cil_tmp___3 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  size_t len___0 ;
  size_t __cil_tmp___4 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___1 ;
  char *__cil_tmp___5 ;
  char *__cil_tmp___6 ;
  char *__cil_tmp___7 ;
  char *__cil_tmp___8 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int century ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int padding ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int j ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int _n___10 ;
  int _delta___10 ;
  int _incr___10 ;
  int year___0 ;
  int year_adjust ;
  int days ;
  int __cil_tmp___9 ;
  int d___0 ;
  int __cil_tmp___10 ;
  int yy ;
  int yy___0 ;
  int _n___11 ;
  size_t __cil_tmp___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  struct tm gtm ;
  struct tm ltm___0 ;
  time_t lt ;
  struct tm tm ;
  struct tm *__cil_tmp___12 ;
  struct tm *__cil_tmp___13 ;
  int flen ;
  int _n___12 ;
  int _delta___12 ;
  int _incr___12 ;

  {
#line 428
  hour12 = (int )tp->tm_hour;
#line 453
  i = 0U;
#line 454
  p = s;
#line 457
  format_end = (char const   *)((void *)0);
#line 469
  zone = (char const   *)((void *)0);
#line 480
  if (ut) {
#line 482
    if (! (zone && *zone)) {
#line 483
      zone = "GMT";
    }
  }
#line 495
  if (hour12 > 12) {
#line 496
    hour12 -= 12;
  } else
#line 498
  if (hour12 == 0) {
#line 499
    hour12 = 12;
  }
#line 501
  f = format;
#line 501
  while ((int const   )*f != 0) {
#line 503
    pad = 0;
#line 505
    digits = 0;
#line 519
    width = -1;
#line 520
    to_lowcase = (_Bool)0;
#line 521
    to_uppcase = upcase;
#line 523
    change_case = (_Bool)0;
#line 527
    switch ((int )*f) {
    case 37: 
#line 530
    break;
    case 8: 
    case 9: 
    case 10: 
    case 11: 
    case 12: 
    case 13: 
    case 32: 
    case 33: 
    case 34: 
    case 35: 
    case 38: 
    case 39: 
    case 40: 
    case 41: 
    case 42: 
    case 43: 
    case 44: 
    case 45: 
    case 46: 
    case 47: 
    case 48: 
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    case 58: 
    case 59: 
    case 60: 
    case 61: 
    case 62: 
    case 63: 
    case 65: 
    case 66: 
    case 67: 
    case 68: 
    case 69: 
    case 70: 
    case 71: 
    case 72: 
    case 73: 
    case 74: 
    case 75: 
    case 76: 
    case 77: 
    case 78: 
    case 79: 
    case 80: 
    case 81: 
    case 82: 
    case 83: 
    case 84: 
    case 85: 
    case 86: 
    case 87: 
    case 88: 
    case 89: 
    case 90: 
    case 91: 
    case 92: 
    case 93: 
    case 94: 
    case 95: 
    case 97: 
    case 98: 
    case 99: 
    case 100: 
    case 101: 
    case 102: 
    case 103: 
    case 104: 
    case 105: 
    case 106: 
    case 107: 
    case 108: 
    case 109: 
    case 110: 
    case 111: 
    case 112: 
    case 113: 
    case 114: 
    case 115: 
    case 116: 
    case 117: 
    case 118: 
    case 119: 
    case 120: 
    case 121: 
    case 122: 
    case 123: 
    case 124: 
    case 125: 
    case 126: 
#line 557
    while (1) {
#line 557
      _n = 1;
#line 557
      _delta = width - _n;
#line 557
      _incr = _n + (_delta > 0 ? _delta : 0);
#line 557
      if ((unsigned int )_incr >= maxsize - i) {
#line 557
        return (0U);
      }
#line 557
      if (p) {
#line 557
        if (digits == 0 && _delta > 0) {
#line 557
          if (pad == 48) {
#line 557
            memset((void *)p, '0', (unsigned int )_delta);
#line 557
            p += _delta;
          } else {
#line 557
            memset((void *)p, ' ', (unsigned int )_delta);
#line 557
            p += _delta;
          }
        }
#line 557
        *p = (char )*f;
#line 557
        p += _n;
      }
#line 557
      i += (unsigned int )_incr;
#line 557
      break;
    }
#line 558
    goto __Cont;
    default: 
#line 564
    mbstate = (struct __anonstruct__mbstate_t_1 )mbstate_zero___0;
#line 565
    len = 0U;
#line 568
    if (! format_end) {
#line 569
      __cil_tmp = strlen(f);
#line 569
      format_end = (f + __cil_tmp) + 1;
    }
#line 570
    fsize = (unsigned int )(format_end - f);
#line 572
    while (1) {
#line 574
      __cil_tmp___0 = mbrlen(f + len, fsize - len, & mbstate);
#line 574
      bytes = __cil_tmp___0;
#line 576
      if (bytes == 0U) {
#line 577
        break;
      }
#line 579
      if (bytes == 4294967294U) {
#line 581
        __cil_tmp___1 = strlen(f + len);
#line 581
        len += __cil_tmp___1;
#line 582
        break;
      }
#line 585
      if (bytes == 4294967295U) {
#line 587
        len ++;
#line 588
        break;
      }
#line 591
      len += bytes;
#line 572
      __cil_tmp___2 = mbsinit((mbstate_t const   *)(& mbstate));
#line 572
      if (__cil_tmp___2) {
#line 572
        break;
      }
    }
#line 595
    while (1) {
#line 595
      _n___0 = (int )len;
#line 595
      _delta___0 = width - _n___0;
#line 595
      _incr___0 = _n___0 + (_delta___0 > 0 ? _delta___0 : 0);
#line 595
      if ((unsigned int )_incr___0 >= maxsize - i) {
#line 595
        return (0U);
      }
#line 595
      if (p) {
#line 595
        if (digits == 0 && _delta___0 > 0) {
#line 595
          if (pad == 48) {
#line 595
            memset((void *)p, '0', (unsigned int )_delta___0);
#line 595
            p += _delta___0;
          } else {
#line 595
            memset((void *)p, ' ', (unsigned int )_delta___0);
#line 595
            p += _delta___0;
          }
        }
#line 595
        if (to_lowcase) {
#line 595
          memcpy_lowcase(p, f, (unsigned int )_n___0);
        } else
#line 595
        if (to_uppcase) {
#line 595
          memcpy_uppcase(p, f, (unsigned int )_n___0);
        } else {
#line 595
          memcpy((void *)p, (void const   *)f, (unsigned int )_n___0);
        }
#line 595
        p += _n___0;
      }
#line 595
      i += (unsigned int )_incr___0;
#line 595
      break;
    }
#line 596
    f += len - 1U;
#line 597
    goto __Cont;
    }
#line 615
    while (1) {
#line 617
      f ++;
#line 617
      switch ((int )*f) {
      case 95: 
      case 45: 
      case 48: 
#line 623
      pad = (int )*f;
#line 624
      continue;
      case 94: 
#line 628
      to_uppcase = (_Bool)1;
#line 629
      continue;
      case 35: 
#line 631
      change_case = (_Bool)1;
#line 632
      continue;
      default: 
#line 635
      break;
      }
#line 637
      break;
    }
#line 641
    if ((unsigned int )*f - 48U <= 9U) {
#line 643
      width = 0;
#line 644
      while (1) {
#line 646
        if (width > 214748364 || (width == 214748364 && (int const   )*f - 48 > 7)) {
#line 649
          width = 2147483647;
        } else {
#line 652
          width *= 10;
#line 653
          width += (int )((int const   )*f - 48);
        }
#line 655
        f ++;
#line 644
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 644
          break;
        }
      }
    }
#line 661
    switch ((int )*f) {
    case 69: 
    case 79: 
#line 665
    __cil_tmp___3 = f;
#line 665
    f ++;
#line 665
    modifier = (int )*__cil_tmp___3;
#line 666
    break;
    default: 
#line 669
    modifier = 0;
#line 670
    break;
    }
#line 674
    format_char = (int )*f;
#line 675
    switch (format_char) {
    case 37: 
#line 698
    if (modifier != 0) {
#line 699
      goto bad_format;
    }
#line 700
    while (1) {
#line 700
      _n___1 = 1;
#line 700
      _delta___1 = width - _n___1;
#line 700
      _incr___1 = _n___1 + (_delta___1 > 0 ? _delta___1 : 0);
#line 700
      if ((unsigned int )_incr___1 >= maxsize - i) {
#line 700
        return (0U);
      }
#line 700
      if (p) {
#line 700
        if (digits == 0 && _delta___1 > 0) {
#line 700
          if (pad == 48) {
#line 700
            memset((void *)p, '0', (unsigned int )_delta___1);
#line 700
            p += _delta___1;
          } else {
#line 700
            memset((void *)p, ' ', (unsigned int )_delta___1);
#line 700
            p += _delta___1;
          }
        }
#line 700
        *p = (char )*f;
#line 700
        p += _n___1;
      }
#line 700
      i += (unsigned int )_incr___1;
#line 700
      break;
    }
#line 701
    break;
    case 97: 
#line 704
    if (modifier != 0) {
#line 705
      goto bad_format;
    }
#line 706
    if (change_case) {
#line 708
      to_uppcase = (_Bool)1;
#line 709
      to_lowcase = (_Bool)0;
    }
#line 715
    goto underlying_strftime;
    case 65: 
#line 719
    if (modifier != 0) {
#line 720
      goto bad_format;
    }
#line 721
    if (change_case) {
#line 723
      to_uppcase = (_Bool)1;
#line 724
      to_lowcase = (_Bool)0;
    }
#line 730
    goto underlying_strftime;
    case 98: 
    case 104: 
#line 735
    if (change_case) {
#line 737
      to_uppcase = (_Bool)1;
#line 738
      to_lowcase = (_Bool)0;
    }
#line 740
    if (modifier != 0) {
#line 741
      goto bad_format;
    }
#line 746
    goto underlying_strftime;
    case 66: 
#line 750
    if (modifier != 0) {
#line 751
      goto bad_format;
    }
#line 752
    if (change_case) {
#line 754
      to_uppcase = (_Bool)1;
#line 755
      to_lowcase = (_Bool)0;
    }
#line 761
    goto underlying_strftime;
    case 99: 
#line 765
    if (modifier == 79) {
#line 766
      goto bad_format;
    }
#line 775
    goto underlying_strftime;
    subformat: 
#line 780
    __cil_tmp___4 = strftime_case____0(to_uppcase, (char *)((void *)0), 4294967295U,
                                       subfmt, tp, ut, ns);
#line 780
    len___0 = __cil_tmp___4;
#line 784
    while (1) {
#line 784
      _n___2 = (int )len___0;
#line 784
      _delta___2 = width - _n___2;
#line 784
      _incr___2 = _n___2 + (_delta___2 > 0 ? _delta___2 : 0);
#line 784
      if ((unsigned int )_incr___2 >= maxsize - i) {
#line 784
        return (0U);
      }
#line 784
      if (p) {
#line 784
        if (digits == 0 && _delta___2 > 0) {
#line 784
          if (pad == 48) {
#line 784
            memset((void *)p, '0', (unsigned int )_delta___2);
#line 784
            p += _delta___2;
          } else {
#line 784
            memset((void *)p, ' ', (unsigned int )_delta___2);
#line 784
            p += _delta___2;
          }
        }
#line 784
        strftime_case____0(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
#line 784
        p += _n___2;
      }
#line 784
      i += (unsigned int )_incr___2;
#line 784
      break;
    }
#line 789
    break;
    underlying_strftime: 
#line 797
    u = ufmt;
#line 810
    __cil_tmp___5 = u;
#line 810
    u ++;
#line 810
    *__cil_tmp___5 = (char )' ';
#line 811
    __cil_tmp___6 = u;
#line 811
    u ++;
#line 811
    *__cil_tmp___6 = (char )'%';
#line 812
    if (modifier != 0) {
#line 813
      __cil_tmp___7 = u;
#line 813
      u ++;
#line 813
      *__cil_tmp___7 = (char )modifier;
    }
#line 814
    __cil_tmp___8 = u;
#line 814
    u ++;
#line 814
    *__cil_tmp___8 = (char )format_char;
#line 815
    *u = (char )'\000';
#line 816
    len___1 = strftime(ubuf, sizeof(ubuf), (char const   *)(ufmt), tp);
#line 817
    if (len___1 != 0U) {
#line 818
      while (1) {
#line 818
        _n___3 = (int )(len___1 - 1U);
#line 818
        _delta___3 = width - _n___3;
#line 818
        _incr___3 = _n___3 + (_delta___3 > 0 ? _delta___3 : 0);
#line 818
        if ((unsigned int )_incr___3 >= maxsize - i) {
#line 818
          return (0U);
        }
#line 818
        if (p) {
#line 818
          if (digits == 0 && _delta___3 > 0) {
#line 818
            if (pad == 48) {
#line 818
              memset((void *)p, '0', (unsigned int )_delta___3);
#line 818
              p += _delta___3;
            } else {
#line 818
              memset((void *)p, ' ', (unsigned int )_delta___3);
#line 818
              p += _delta___3;
            }
          }
#line 818
          if (to_lowcase) {
#line 818
            memcpy_lowcase(p, (char const   *)(ubuf + 1), (unsigned int )_n___3);
          } else
#line 818
          if (to_uppcase) {
#line 818
            memcpy_uppcase(p, (char const   *)(ubuf + 1), (unsigned int )_n___3);
          } else {
#line 818
            memcpy((void *)p, (void const   *)(ubuf + 1), (unsigned int )_n___3);
          }
#line 818
          p += _n___3;
        }
#line 818
        i += (unsigned int )_incr___3;
#line 818
        break;
      }
    }
#line 820
    break;
    case 67: 
#line 824
    if (modifier == 79) {
#line 825
      goto bad_format;
    }
#line 826
    if (modifier == 69) {
#line 842
      goto underlying_strftime;
    }
#line 847
    century = (int )(tp->tm_year / 100 + 19);
#line 848
    century -= tp->tm_year % 100 < 0 && 0 < century;
#line 849
    digits = 2;
#line 849
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 849
    u_number_value = (unsigned int )century;
#line 849
    goto do_signed_number;
    case 120: 
#line 853
    if (modifier == 79) {
#line 854
      goto bad_format;
    }
#line 863
    goto underlying_strftime;
    case 68: 
#line 866
    if (modifier != 0) {
#line 867
      goto bad_format;
    }
#line 868
    subfmt = "%m/%d/%y";
#line 869
    goto subformat;
    case 100: 
#line 872
    if (modifier == 69) {
#line 873
      goto bad_format;
    }
#line 875
    digits = 2;
#line 875
    number_value = (int )tp->tm_mday;
#line 875
    goto do_number;
    case 101: 
#line 878
    if (modifier == 69) {
#line 879
      goto bad_format;
    }
#line 881
    digits = 2;
#line 881
    number_value = (int )tp->tm_mday;
#line 881
    goto do_number_spacepad;
    do_tz_offset: 
#line 887
    always_output_a_sign = (_Bool)1;
#line 888
    goto do_number_body;
    do_number_spacepad: 
#line 892
    if (pad != 48 && pad != 45) {
#line 893
      pad = '_';
    }
    do_number: 
#line 897
    negative_number = (_Bool )(number_value < 0);
#line 898
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 901
    always_output_a_sign = (_Bool)0;
#line 902
    tz_colon_mask = 0;
    do_number_body: 
#line 910
    if (modifier == 79 && ! negative_number) {
#line 928
      goto underlying_strftime;
    }
#line 932
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 934
    if (negative_number) {
#line 935
      u_number_value = - u_number_value;
    }
#line 937
    while (1) {
#line 939
      if (tz_colon_mask & 1) {
#line 940
        bufp --;
#line 940
        *bufp = (char )':';
      }
#line 941
      tz_colon_mask >>= 1;
#line 942
      bufp --;
#line 942
      *bufp = (char )(u_number_value % 10U + 48U);
#line 943
      u_number_value /= 10U;
#line 937
      if (! (u_number_value != 0U || tz_colon_mask != 0)) {
#line 937
        break;
      }
    }
    do_number_sign_and_padding: 
#line 948
    if (digits < width) {
#line 949
      digits = width;
    }
#line 951
    sign_char = (char )(negative_number ? '-' : (always_output_a_sign ? '+' : 0));
#line 955
    if (pad == 45) {
#line 957
      if (sign_char) {
#line 958
        while (1) {
#line 958
          _n___4 = 1;
#line 958
          _delta___4 = width - _n___4;
#line 958
          _incr___4 = _n___4 + (_delta___4 > 0 ? _delta___4 : 0);
#line 958
          if ((unsigned int )_incr___4 >= maxsize - i) {
#line 958
            return (0U);
          }
#line 958
          if (p) {
#line 958
            if (digits == 0 && _delta___4 > 0) {
#line 958
              if (pad == 48) {
#line 958
                memset((void *)p, '0', (unsigned int )_delta___4);
#line 958
                p += _delta___4;
              } else {
#line 958
                memset((void *)p, ' ', (unsigned int )_delta___4);
#line 958
                p += _delta___4;
              }
            }
#line 958
            *p = sign_char;
#line 958
            p += _n___4;
          }
#line 958
          i += (unsigned int )_incr___4;
#line 958
          break;
        }
      }
    } else {
#line 962
      padding = (digits - ((buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp)) - ! (! sign_char);
#line 965
      if (padding > 0) {
#line 967
        if (pad == 95) {
#line 969
          if ((unsigned int )padding >= maxsize - i) {
#line 970
            return (0U);
          }
#line 972
          if (p) {
#line 973
            memset((void *)p, ' ', (unsigned int )padding);
#line 973
            p += padding;
          }
#line 974
          i += (unsigned int )padding;
#line 975
          width = width > padding ? width - padding : 0;
#line 976
          if (sign_char) {
#line 977
            while (1) {
#line 977
              _n___5 = 1;
#line 977
              _delta___5 = width - _n___5;
#line 977
              _incr___5 = _n___5 + (_delta___5 > 0 ? _delta___5 : 0);
#line 977
              if ((unsigned int )_incr___5 >= maxsize - i) {
#line 977
                return (0U);
              }
#line 977
              if (p) {
#line 977
                if (digits == 0 && _delta___5 > 0) {
#line 977
                  if (pad == 48) {
#line 977
                    memset((void *)p, '0', (unsigned int )_delta___5);
#line 977
                    p += _delta___5;
                  } else {
#line 977
                    memset((void *)p, ' ', (unsigned int )_delta___5);
#line 977
                    p += _delta___5;
                  }
                }
#line 977
                *p = sign_char;
#line 977
                p += _n___5;
              }
#line 977
              i += (unsigned int )_incr___5;
#line 977
              break;
            }
          }
        } else {
#line 981
          if ((unsigned int )digits >= maxsize - i) {
#line 982
            return (0U);
          }
#line 984
          if (sign_char) {
#line 985
            while (1) {
#line 985
              _n___6 = 1;
#line 985
              _delta___6 = width - _n___6;
#line 985
              _incr___6 = _n___6 + (_delta___6 > 0 ? _delta___6 : 0);
#line 985
              if ((unsigned int )_incr___6 >= maxsize - i) {
#line 985
                return (0U);
              }
#line 985
              if (p) {
#line 985
                if (digits == 0 && _delta___6 > 0) {
#line 985
                  if (pad == 48) {
#line 985
                    memset((void *)p, '0', (unsigned int )_delta___6);
#line 985
                    p += _delta___6;
                  } else {
#line 985
                    memset((void *)p, ' ', (unsigned int )_delta___6);
#line 985
                    p += _delta___6;
                  }
                }
#line 985
                *p = sign_char;
#line 985
                p += _n___6;
              }
#line 985
              i += (unsigned int )_incr___6;
#line 985
              break;
            }
          }
#line 987
          if (p) {
#line 988
            memset((void *)p, '0', (unsigned int )padding);
#line 988
            p += padding;
          }
#line 989
          i += (unsigned int )padding;
#line 990
          width = 0;
        }
      } else
#line 995
      if (sign_char) {
#line 996
        while (1) {
#line 996
          _n___7 = 1;
#line 996
          _delta___7 = width - _n___7;
#line 996
          _incr___7 = _n___7 + (_delta___7 > 0 ? _delta___7 : 0);
#line 996
          if ((unsigned int )_incr___7 >= maxsize - i) {
#line 996
            return (0U);
          }
#line 996
          if (p) {
#line 996
            if (digits == 0 && _delta___7 > 0) {
#line 996
              if (pad == 48) {
#line 996
                memset((void *)p, '0', (unsigned int )_delta___7);
#line 996
                p += _delta___7;
              } else {
#line 996
                memset((void *)p, ' ', (unsigned int )_delta___7);
#line 996
                p += _delta___7;
              }
            }
#line 996
            *p = sign_char;
#line 996
            p += _n___7;
          }
#line 996
          i += (unsigned int )_incr___7;
#line 996
          break;
        }
      }
    }
#line 1000
    while (1) {
#line 1000
      _n___8 = (buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp;
#line 1000
      _delta___8 = width - _n___8;
#line 1000
      _incr___8 = _n___8 + (_delta___8 > 0 ? _delta___8 : 0);
#line 1000
      if ((unsigned int )_incr___8 >= maxsize - i) {
#line 1000
        return (0U);
      }
#line 1000
      if (p) {
#line 1000
        if (digits == 0 && _delta___8 > 0) {
#line 1000
          if (pad == 48) {
#line 1000
            memset((void *)p, '0', (unsigned int )_delta___8);
#line 1000
            p += _delta___8;
          } else {
#line 1000
            memset((void *)p, ' ', (unsigned int )_delta___8);
#line 1000
            p += _delta___8;
          }
        }
#line 1000
        if (to_lowcase) {
#line 1000
          memcpy_lowcase(p, (char const   *)bufp, (unsigned int )_n___8);
        } else
#line 1000
        if (to_uppcase) {
#line 1000
          memcpy_uppcase(p, (char const   *)bufp, (unsigned int )_n___8);
        } else {
#line 1000
          memcpy((void *)p, (void const   *)bufp, (unsigned int )_n___8);
        }
#line 1000
        p += _n___8;
      }
#line 1000
      i += (unsigned int )_incr___8;
#line 1000
      break;
    }
#line 1001
    break;
    case 70: 
#line 1004
    if (modifier != 0) {
#line 1005
      goto bad_format;
    }
#line 1006
    subfmt = "%Y-%m-%d";
#line 1007
    goto subformat;
    case 72: 
#line 1010
    if (modifier == 69) {
#line 1011
      goto bad_format;
    }
#line 1013
    digits = 2;
#line 1013
    number_value = (int )tp->tm_hour;
#line 1013
    goto do_number;
    case 73: 
#line 1016
    if (modifier == 69) {
#line 1017
      goto bad_format;
    }
#line 1019
    digits = 2;
#line 1019
    number_value = hour12;
#line 1019
    goto do_number;
    case 107: 
#line 1022
    if (modifier == 69) {
#line 1023
      goto bad_format;
    }
#line 1025
    digits = 2;
#line 1025
    number_value = (int )tp->tm_hour;
#line 1025
    goto do_number_spacepad;
    case 108: 
#line 1028
    if (modifier == 69) {
#line 1029
      goto bad_format;
    }
#line 1031
    digits = 2;
#line 1031
    number_value = hour12;
#line 1031
    goto do_number_spacepad;
    case 106: 
#line 1034
    if (modifier == 69) {
#line 1035
      goto bad_format;
    }
#line 1037
    digits = 3;
#line 1037
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1037
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1037
    goto do_signed_number;
    case 77: 
#line 1040
    if (modifier == 69) {
#line 1041
      goto bad_format;
    }
#line 1043
    digits = 2;
#line 1043
    number_value = (int )tp->tm_min;
#line 1043
    goto do_number;
    case 109: 
#line 1046
    if (modifier == 69) {
#line 1047
      goto bad_format;
    }
#line 1049
    digits = 2;
#line 1049
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1049
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1049
    goto do_signed_number;
    case 78: 
#line 1053
    if (modifier == 69) {
#line 1054
      goto bad_format;
    }
#line 1056
    number_value = ns;
#line 1057
    if (width == -1) {
#line 1058
      width = 9;
    } else {
#line 1063
      j = width;
#line 1063
      while (j < 9) {
#line 1064
        number_value /= 10;
#line 1063
        j ++;
      }
    }
#line 1067
    digits = width;
#line 1067
    number_value = number_value;
#line 1067
    goto do_number;
    case 110: 
#line 1071
    while (1) {
#line 1071
      _n___9 = 1;
#line 1071
      _delta___9 = width - _n___9;
#line 1071
      _incr___9 = _n___9 + (_delta___9 > 0 ? _delta___9 : 0);
#line 1071
      if ((unsigned int )_incr___9 >= maxsize - i) {
#line 1071
        return (0U);
      }
#line 1071
      if (p) {
#line 1071
        if (digits == 0 && _delta___9 > 0) {
#line 1071
          if (pad == 48) {
#line 1071
            memset((void *)p, '0', (unsigned int )_delta___9);
#line 1071
            p += _delta___9;
          } else {
#line 1071
            memset((void *)p, ' ', (unsigned int )_delta___9);
#line 1071
            p += _delta___9;
          }
        }
#line 1071
        *p = (char )'\n';
#line 1071
        p += _n___9;
      }
#line 1071
      i += (unsigned int )_incr___9;
#line 1071
      break;
    }
#line 1072
    break;
    case 80: 
#line 1075
    to_lowcase = (_Bool)1;
#line 1077
    format_char = 'p';
    case 112: 
#line 1082
    if (change_case) {
#line 1084
      to_uppcase = (_Bool)0;
#line 1085
      to_lowcase = (_Bool)1;
    }
#line 1091
    goto underlying_strftime;
    case 82: 
#line 1095
    subfmt = "%H:%M";
#line 1096
    goto subformat;
    case 114: 
#line 1106
    goto underlying_strftime;
    case 83: 
#line 1110
    if (modifier == 69) {
#line 1111
      goto bad_format;
    }
#line 1113
    digits = 2;
#line 1113
    number_value = (int )tp->tm_sec;
#line 1113
    goto do_number;
    case 115: 
#line 1120
    ltm = (struct tm )*tp;
#line 1121
    t = rpl_mktime(& ltm);
#line 1126
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 1127
    negative_number = (_Bool )(t < 0L);
#line 1129
    while (1) {
#line 1131
      d = (int )(t % 10L);
#line 1132
      t /= 10L;
#line 1133
      bufp --;
#line 1133
      *bufp = (char )((negative_number ? - d : d) + 48);
#line 1129
      if (! (t != 0L)) {
#line 1129
        break;
      }
    }
#line 1137
    digits = 1;
#line 1138
    always_output_a_sign = (_Bool)0;
#line 1139
    goto do_number_sign_and_padding;
    case 88: 
#line 1143
    if (modifier == 79) {
#line 1144
      goto bad_format;
    }
#line 1153
    goto underlying_strftime;
    case 84: 
#line 1156
    subfmt = "%H:%M:%S";
#line 1157
    goto subformat;
    case 116: 
#line 1160
    while (1) {
#line 1160
      _n___10 = 1;
#line 1160
      _delta___10 = width - _n___10;
#line 1160
      _incr___10 = _n___10 + (_delta___10 > 0 ? _delta___10 : 0);
#line 1160
      if ((unsigned int )_incr___10 >= maxsize - i) {
#line 1160
        return (0U);
      }
#line 1160
      if (p) {
#line 1160
        if (digits == 0 && _delta___10 > 0) {
#line 1160
          if (pad == 48) {
#line 1160
            memset((void *)p, '0', (unsigned int )_delta___10);
#line 1160
            p += _delta___10;
          } else {
#line 1160
            memset((void *)p, ' ', (unsigned int )_delta___10);
#line 1160
            p += _delta___10;
          }
        }
#line 1160
        *p = (char )'\t';
#line 1160
        p += _n___10;
      }
#line 1160
      i += (unsigned int )_incr___10;
#line 1160
      break;
    }
#line 1161
    break;
    case 117: 
#line 1164
    digits = 1;
#line 1164
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1164
    goto do_number;
    case 85: 
#line 1167
    if (modifier == 69) {
#line 1168
      goto bad_format;
    }
#line 1170
    digits = 2;
#line 1170
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1170
    goto do_number;
    case 86: 
    case 103: 
    case 71: 
#line 1175
    if (modifier == 69) {
#line 1176
      goto bad_format;
    }
#line 1182
    year___0 = (int )(tp->tm_year + (int const   )(tp->tm_year < 0 ? 300 : -100));
#line 1186
    year_adjust = 0;
#line 1187
    __cil_tmp___9 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1187
    days = __cil_tmp___9;
#line 1189
    if (days < 0) {
#line 1192
      year_adjust = -1;
#line 1193
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + ((year___0 - 1) % 4 == 0 && ((year___0 - 1) % 100 != 0 || (year___0 - 1) % 400 == 0)))),
                           (int )tp->tm_wday);
    } else {
#line 1198
      __cil_tmp___10 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + (year___0 % 4 == 0 && (year___0 % 100 != 0 || year___0 % 400 == 0)))),
                                     (int )tp->tm_wday);
#line 1198
      d___0 = __cil_tmp___10;
#line 1200
      if (0 <= d___0) {
#line 1203
        year_adjust = 1;
#line 1204
        days = d___0;
      }
    }
#line 1208
    switch ((int )*f) {
    case 103: 
#line 1212
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1213
    digits = 2;
#line 1213
    number_value = 0 <= yy ? yy : (tp->tm_year < (int const   )(-1900 - year_adjust) ? - yy : yy + 100);
#line 1213
    goto do_number;
    case 71: 
#line 1221
    digits = 4;
#line 1221
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1221
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1221
    goto do_signed_number;
    default: 
#line 1226
    digits = 2;
#line 1226
    number_value = days / 7 + 1;
#line 1226
    goto do_number;
    }
    case 87: 
#line 1231
    if (modifier == 69) {
#line 1232
      goto bad_format;
    }
#line 1234
    digits = 2;
#line 1234
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1234
    goto do_number;
    case 119: 
#line 1237
    if (modifier == 69) {
#line 1238
      goto bad_format;
    }
#line 1240
    digits = 1;
#line 1240
    number_value = (int )tp->tm_wday;
#line 1240
    goto do_number;
    case 89: 
#line 1243
    if (modifier == 69) {
#line 1257
      goto underlying_strftime;
    }
#line 1260
    if (modifier == 79) {
#line 1261
      goto bad_format;
    } else {
#line 1263
      digits = 4;
    }
#line 1263
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1263
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1263
    goto do_signed_number;
    case 121: 
#line 1267
    if (modifier == 69) {
#line 1278
      goto underlying_strftime;
    }
#line 1283
    yy___0 = (int )(tp->tm_year % 100);
#line 1284
    if (yy___0 < 0) {
#line 1285
      yy___0 = tp->tm_year < -1900 ? - yy___0 : yy___0 + 100;
    }
#line 1286
    digits = 2;
#line 1286
    number_value = yy___0;
#line 1286
    goto do_number;
    case 90: 
#line 1290
    if (change_case) {
#line 1292
      to_uppcase = (_Bool)0;
#line 1293
      to_lowcase = (_Bool)1;
    }
#line 1298
    if (! (zone && *zone) && tp->tm_isdst >= 0) {
#line 1299
      zone = (char const   *)_tzname[tp->tm_isdst != 0];
    }
#line 1301
    if (! zone) {
#line 1302
      zone = "";
    }
#line 1314
    while (1) {
#line 1314
      __cil_tmp___11 = strlen(zone);
#line 1314
      _n___11 = (int )__cil_tmp___11;
#line 1314
      _delta___11 = width - _n___11;
#line 1314
      _incr___11 = _n___11 + (_delta___11 > 0 ? _delta___11 : 0);
#line 1314
      if ((unsigned int )_incr___11 >= maxsize - i) {
#line 1314
        return (0U);
      }
#line 1314
      if (p) {
#line 1314
        if (digits == 0 && _delta___11 > 0) {
#line 1314
          if (pad == 48) {
#line 1314
            memset((void *)p, '0', (unsigned int )_delta___11);
#line 1314
            p += _delta___11;
          } else {
#line 1314
            memset((void *)p, ' ', (unsigned int )_delta___11);
#line 1314
            p += _delta___11;
          }
        }
#line 1314
        if (to_lowcase) {
#line 1314
          memcpy_lowcase(p, zone, (unsigned int )_n___11);
        } else
#line 1314
        if (to_uppcase) {
#line 1314
          memcpy_uppcase(p, zone, (unsigned int )_n___11);
        } else {
#line 1314
          memcpy((void *)p, (void const   *)zone, (unsigned int )_n___11);
        }
#line 1314
        p += _n___11;
      }
#line 1314
      i += (unsigned int )_incr___11;
#line 1314
      break;
    }
#line 1316
    break;
    case 58: 
#line 1321
    colons = 1U;
#line 1321
    while ((int const   )*(f + colons) == 58) {
#line 1322
      goto __Cont___0;
      __Cont___0: 
#line 1321
      colons ++;
    }
#line 1323
    if ((int const   )*(f + colons) != 122) {
#line 1324
      goto bad_format;
    }
#line 1325
    f += colons;
#line 1326
    goto do_z_conversion;
    case 122: 
#line 1329
    colons = 0U;
    do_z_conversion: 
#line 1332
    if (tp->tm_isdst < 0) {
#line 1333
      break;
    }
#line 1343
    if (ut) {
#line 1344
      diff = 0;
    } else {
#line 1351
      ltm___0 = (struct tm )*tp;
#line 1352
      lt = rpl_mktime(& ltm___0);
#line 1354
      if (lt == -1L) {
#line 1361
        __cil_tmp___12 = localtime_r((time_t const   *)(& lt), & tm);
#line 1361
        if (__cil_tmp___12) {
#line 1361
          if ((((((ltm___0.tm_sec ^ tm.tm_sec) | (ltm___0.tm_min ^ tm.tm_min)) | (ltm___0.tm_hour ^ tm.tm_hour)) | (ltm___0.tm_mday ^ tm.tm_mday)) | (ltm___0.tm_mon ^ tm.tm_mon)) | (ltm___0.tm_year ^ tm.tm_year)) {
#line 1368
            break;
          }
        } else {
#line 1368
          break;
        }
      }
#line 1371
      __cil_tmp___13 = gmtime_r((time_t const   *)(& lt), & gtm);
#line 1371
      if (! __cil_tmp___13) {
#line 1372
        break;
      }
#line 1374
      diff = ftime_tm_diff___0((struct tm  const  *)(& ltm___0), (struct tm  const  *)(& gtm));
    }
#line 1378
    hour_diff = (diff / 60) / 60;
#line 1379
    min_diff = (diff / 60) % 60;
#line 1380
    sec_diff = diff % 60;
#line 1382
    switch ((int )colons) {
    case 0: 
#line 1385
    digits = 5;
#line 1385
    negative_number = (_Bool )(diff < 0);
#line 1385
    tz_colon_mask = 0;
#line 1385
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1385
    goto do_tz_offset;
    tz_hh_mm: 
    case 1: 
#line 1388
    digits = 6;
#line 1388
    negative_number = (_Bool )(diff < 0);
#line 1388
    tz_colon_mask = 4;
#line 1388
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1388
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case 2: 
#line 1391
    digits = 9;
#line 1391
    negative_number = (_Bool )(diff < 0);
#line 1391
    tz_colon_mask = 20;
#line 1391
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1391
    goto do_tz_offset;
    case 3: 
#line 1395
    if (sec_diff != 0) {
#line 1396
      goto tz_hh_mm_ss;
    }
#line 1397
    if (min_diff != 0) {
#line 1398
      goto tz_hh_mm;
    }
#line 1399
    digits = 3;
#line 1399
    negative_number = (_Bool )(diff < 0);
#line 1399
    tz_colon_mask = 0;
#line 1399
    u_number_value = (unsigned int )hour_diff;
#line 1399
    goto do_tz_offset;
    default: 
#line 1402
    goto bad_format;
    }
    case 0: 
#line 1407
    f --;
    bad_format: 
    default: 
#line 1416
    flen = 1;
#line 1416
    while ((int const   )*(f + (1 - flen)) != 37) {
#line 1417
      goto __Cont___1;
      __Cont___1: 
#line 1416
      flen ++;
    }
#line 1418
    while (1) {
#line 1418
      _n___12 = flen;
#line 1418
      _delta___12 = width - _n___12;
#line 1418
      _incr___12 = _n___12 + (_delta___12 > 0 ? _delta___12 : 0);
#line 1418
      if ((unsigned int )_incr___12 >= maxsize - i) {
#line 1418
        return (0U);
      }
#line 1418
      if (p) {
#line 1418
        if (digits == 0 && _delta___12 > 0) {
#line 1418
          if (pad == 48) {
#line 1418
            memset((void *)p, '0', (unsigned int )_delta___12);
#line 1418
            p += _delta___12;
          } else {
#line 1418
            memset((void *)p, ' ', (unsigned int )_delta___12);
#line 1418
            p += _delta___12;
          }
        }
#line 1418
        if (to_lowcase) {
#line 1418
          memcpy_lowcase(p, f + (1 - flen), (unsigned int )_n___12);
        } else
#line 1418
        if (to_uppcase) {
#line 1418
          memcpy_uppcase(p, f + (1 - flen), (unsigned int )_n___12);
        } else {
#line 1418
          memcpy((void *)p, (void const   *)(f + (1 - flen)), (unsigned int )_n___12);
        }
#line 1418
        p += _n___12;
      }
#line 1418
      i += (unsigned int )_incr___12;
#line 1418
      break;
    }
#line 1420
    break;
    }
    __Cont: 
#line 501
    f ++;
  }
#line 1425
  if (p && maxsize != 0U) {
#line 1426
    *p = (char )'\000';
  }
#line 1429
  return (i);
}
}
#line 1438 "strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ size_t __cil_tmp ;

  {
#line 1443
  __cil_tmp = strftime_case____0((_Bool)0, s, maxsize, format, tp, ut, ns);
#line 1443
  return (__cil_tmp);
}
}
#line 1 "stripslash.o"
#pragma merger(0,"/tmp/cil-SLFWGa4R.i","-g,-O2")
#line 29 "stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ char *base ;
  char *__cil_tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t __cil_tmp___0 ;

  {
#line 32
  __cil_tmp = last_component((char const   *)file);
#line 32
  base = __cil_tmp;
#line 38
  if (! *base) {
#line 39
    base = file;
  }
#line 40
  __cil_tmp___0 = base_len((char const   *)base);
#line 40
  base_lim = base + __cil_tmp___0;
#line 41
  had_slash = (_Bool )((int )*base_lim != 0);
#line 42
  *base_lim = (char )'\000';
#line 43
  return (had_slash);
}
}
#line 1 "strnlen.o"
#pragma merger(0,"/tmp/cil-hOtIQmwd.i","-g,-O2")
#line 73 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
size_t rpl_strnlen(char const   *string , size_t maxlen ) ;
#line 28 "strnlen.c"
size_t rpl_strnlen(char const   *string , size_t maxlen ) 
{ char const   *end ;
  void *__cil_tmp ;

  {
#line 31
  __cil_tmp = memchr((void const   *)string, '\000', maxlen);
#line 31
  end = (char const   *)__cil_tmp;
#line 32
  return (end ? (unsigned int )(end - string) : maxlen);
}
}
#line 1 "strtod.o"
#pragma merger(0,"/tmp/cil-JCRMU9Fk.i","-g,-O2")
#line 136 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/math.h"
extern double pow(double  , double  ) ;
#line 30 "strtod.c"
double rpl_strtod(char const   *nptr , char **endptr ) 
{ register char const   *s ;
  short sign ;
  double num ;
  int got_dot ;
  int got_digit ;
  long exponent ;
  int *__cil_tmp ;
  int save ;
  int *__cil_tmp___0 ;
  char *end ;
  long exp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  unsigned char __x ;
  double __cil_tmp___4 ;
  double __cil_tmp___5 ;
  double __cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;

  {
#line 45
  if ((unsigned int )nptr == (unsigned int )((void *)0)) {
#line 47
    __cil_tmp = __errno();
#line 47
    *__cil_tmp = 22;
#line 48
    goto noconv;
  }
#line 51
  s = nptr;
#line 54
  while ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )((unsigned char )*s)))) + (int )((unsigned char )*s)) & 8) {
#line 55
    s ++;
  }
#line 58
  sign = (short )((int const   )*s == 45 ? -1 : 1);
#line 59
  if ((int const   )*s == 45 || (int const   )*s == 43) {
#line 60
    s ++;
  }
#line 62
  num = 0.0;
#line 63
  got_dot = 0;
#line 64
  got_digit = 0;
#line 65
  exponent = 0L;
#line 66
  while (1) {
#line 68
    if (48 <= (int )*s && (int const   )*s <= 57) {
#line 70
      got_digit = 1;
#line 73
      if (num > 1.7976931348623157e+308 * 0.1) {
#line 81
        exponent ++;
      } else {
#line 83
        num = num * 10.0 + (double )((int const   )*s - 48);
      }
#line 87
      if (got_dot) {
#line 88
        exponent --;
      }
    } else
#line 90
    if (! got_dot && (int const   )*s == 46) {
#line 92
      got_dot = 1;
    } else {
#line 95
      break;
    }
#line 66
    s ++;
  }
#line 98
  if (! got_digit) {
#line 99
    goto noconv;
  }
#line 101
  __x = (unsigned char )*s;
#line 101
  if ((((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )__x))) + (int )__x) & 3) == 1 ? ((int )__x - 65) + 97 : (int )__x) == 101) {
#line 104
    __cil_tmp___0 = __errno();
#line 104
    save = *__cil_tmp___0;
#line 108
    __cil_tmp___1 = __errno();
#line 108
    *__cil_tmp___1 = 0;
#line 109
    s ++;
#line 110
    exp___0 = strtol(s, & end, 10);
#line 111
    __cil_tmp___2 = __errno();
#line 111
    if (*__cil_tmp___2 == 34) {
#line 116
      if ((unsigned int )endptr != (unsigned int )((void *)0)) {
#line 117
        *endptr = end;
      }
#line 118
      if (exp___0 < 0L) {
#line 119
        goto underflow;
      } else {
#line 121
        goto overflow;
      }
    } else
#line 123
    if ((unsigned int )end == (unsigned int )s) {
#line 126
      end = (char *)s - 1;
    }
#line 127
    __cil_tmp___3 = __errno();
#line 127
    *__cil_tmp___3 = save;
#line 128
    s = (char const   *)end;
#line 129
    exponent += exp___0;
  }
#line 132
  if ((unsigned int )endptr != (unsigned int )((void *)0)) {
#line 133
    *endptr = (char *)s;
  }
#line 135
  if (num == 0.0) {
#line 136
    return (0.0);
  }
#line 141
  if (exponent < 0L) {
#line 143
    __cil_tmp___4 = pow(10.0, (double )(- exponent));
#line 143
    if (num < 2.2250738585072014e-308 * __cil_tmp___4) {
#line 144
      goto underflow;
    }
  } else
#line 146
  if (exponent > 0L) {
#line 148
    __cil_tmp___5 = pow(10.0, (double )(- exponent));
#line 148
    if (num > 1.7976931348623157e+308 * __cil_tmp___5) {
#line 149
      goto overflow;
    }
  }
#line 152
  __cil_tmp___6 = pow(10.0, (double )exponent);
#line 152
  num *= __cil_tmp___6;
#line 154
  return (num * (double )sign);
  overflow: 
#line 158
  __cil_tmp___7 = __errno();
#line 158
  *__cil_tmp___7 = 34;
#line 159
  return (1.0e999999999 * (double )sign);
  underflow: 
#line 163
  if ((unsigned int )endptr != (unsigned int )((void *)0)) {
#line 164
    *endptr = (char *)nptr;
  }
#line 165
  __cil_tmp___8 = __errno();
#line 165
  *__cil_tmp___8 = 34;
#line 166
  return (0.0);
  noconv: 
#line 170
  if ((unsigned int )endptr != (unsigned int )((void *)0)) {
#line 171
    *endptr = (char *)nptr;
  }
#line 172
  return (0.0);
}
}
#line 1 "strverscmp.o"
#pragma merger(0,"/tmp/cil-nokPVXmG.i","-g,-O2")
#line 73 "strverscmp.c"
int strverscmp(char const   *s1 , char const   *s2 ) ;
#line 73 "strverscmp.c"
static unsigned int const   next_state[16]  = 
#line 73
  {      (unsigned int const   )0,      (unsigned int const   )4,      (unsigned int const   )12,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )4,      (unsigned int const   )4,      (unsigned int const   )4, 
        (unsigned int const   )0,      (unsigned int const   )8,      (unsigned int const   )8,      (unsigned int const   )8, 
        (unsigned int const   )0,      (unsigned int const   )8,      (unsigned int const   )12,      (unsigned int const   )12};
#line 82 "strverscmp.c"
static int const   result_type[60]  = 
#line 82
  {      (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )3,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )-1,      (int const   )-1,      (int const   )2, 
        (int const   )1,      (int const   )3,      (int const   )3,      (int const   )2, 
        (int const   )1,      (int const   )3,      (int const   )3,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )3,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )-1,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )-1,      (int const   )2,      (int const   )2,      (int const   )2};
#line 62 "strverscmp.c"
int strverscmp(char const   *s1 , char const   *s2 ) 
{ unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int state ;
  int diff ;
  unsigned char const   *__cil_tmp ;
  unsigned char const   *__cil_tmp___0 ;
  unsigned char const   *__cil_tmp___1 ;
  unsigned char const   *__cil_tmp___2 ;
  unsigned char const   *__cil_tmp___3 ;
  unsigned char const   *__cil_tmp___4 ;

  {
#line 65
  p1 = (unsigned char const   *)s1;
#line 66
  p2 = (unsigned char const   *)s2;
#line 97
  if ((unsigned int )p1 == (unsigned int )p2) {
#line 98
    return (0);
  }
#line 100
  __cil_tmp = p1;
#line 100
  p1 ++;
#line 100
  c1 = (unsigned char )*__cil_tmp;
#line 101
  __cil_tmp___0 = p2;
#line 101
  p2 ++;
#line 101
  c2 = (unsigned char )*__cil_tmp___0;
#line 103
  state = ((int )c1 == 48) + (((unsigned int )c1 - 48U <= 9U) != 0);
#line 105
  while (1) {
#line 105
    diff = (int )c1 - (int )c2;
#line 105
    if (! (diff == 0 && (int )c1 != 0)) {
#line 105
      break;
    }
#line 107
    state = (int )next_state[state];
#line 108
    __cil_tmp___1 = p1;
#line 108
    p1 ++;
#line 108
    c1 = (unsigned char )*__cil_tmp___1;
#line 109
    __cil_tmp___2 = p2;
#line 109
    p2 ++;
#line 109
    c2 = (unsigned char )*__cil_tmp___2;
#line 110
    state |= ((int )c1 == 48) + (((unsigned int )c1 - 48U <= 9U) != 0);
  }
#line 113
  state = (int )result_type[(state << 2) | (((int )c2 == 48) + (((unsigned int )c2 - 48U <= 9U) != 0))];
#line 115
  switch (state) {
  case 2: 
#line 118
  return (diff);
  case 3: 
#line 121
  while (1) {
#line 121
    __cil_tmp___4 = p1;
#line 121
    p1 ++;
#line 121
    if (! ((unsigned int )*__cil_tmp___4 - 48U <= 9U)) {
#line 121
      break;
    }
#line 122
    __cil_tmp___3 = p2;
#line 122
    p2 ++;
#line 122
    if (! ((unsigned int )*__cil_tmp___3 - 48U <= 9U)) {
#line 123
      return (1);
    }
  }
#line 125
  return ((unsigned int )*p2 - 48U <= 9U ? -1 : diff);
  default: 
#line 128
  return (state);
  }
}
}
#line 1 "tempname.o"
#pragma merger(0,"/tmp/cil-G1Foftds.i","-g,-O2")
#line 41 "tempname.h"
int gen_tempname_len(char *tmpl , int kind , size_t x_suffix_len ) ;
#line 155 "tempname.c"
__inline static _Bool check_x_suffix(char const   *s , size_t len ) 
{ size_t __cil_tmp ;

  {
#line 158
  __cil_tmp = strspn(s, "X");
#line 158
  return ((_Bool )(__cil_tmp == len));
}
}
#line 162 "tempname.c"
static char const   letters[63]  = 
#line 162
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 179 "tempname.c"
int gen_tempname_len(char *tmpl , int kind , size_t x_suffix_len ) 
{ size_t len ;
  char *XXXXXX ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *__cil_tmp ;
  struct stat st ;
  struct randint_source *rand_src ;
  unsigned int attempts ;
  int *__cil_tmp___0 ;
  _Bool __cil_tmp___1 ;
  size_t i ;
  randint __cil_tmp___2 ;
  int *__cil_tmp___3 ;
  int *__cil_tmp___4 ;
  int __cil_tmp___5 ;
  int *__cil_tmp___6 ;
  int *__cil_tmp___7 ;
  int *__cil_tmp___8 ;
  int saved_errno ;
  int *__cil_tmp___9 ;
  int *__cil_tmp___10 ;

  {
#line 185
  fd = -1;
#line 186
  __cil_tmp = __errno();
#line 186
  save_errno = *__cil_tmp;
#line 203
  attempts = 238328U;
#line 206
  len = strlen((char const   *)tmpl);
#line 207
  if (len < x_suffix_len) {
#line 210
    __cil_tmp___0 = __errno();
#line 210
    *__cil_tmp___0 = 22;
#line 211
    return (-1);
  } else {
#line 207
    __cil_tmp___1 = check_x_suffix((char const   *)(tmpl + (len - x_suffix_len)),
                                   x_suffix_len);
#line 207
    if (! __cil_tmp___1) {
#line 210
      __cil_tmp___0 = __errno();
#line 210
      *__cil_tmp___0 = 22;
#line 211
      return (-1);
    }
  }
#line 214
  rand_src = randint_all_new((char const   *)((void *)0), 8U);
#line 215
  if (! rand_src) {
#line 216
    return (-1);
  }
#line 219
  XXXXXX = tmpl + (len - x_suffix_len);
#line 221
  count = 0U;
#line 221
  while (count < attempts) {
#line 225
    i = 0U;
#line 225
    while (i < x_suffix_len) {
#line 227
      __cil_tmp___2 = randint_genmax(rand_src, (unsigned long long )(sizeof(letters) - 2U));
#line 227
      *(XXXXXX + i) = (char )letters[__cil_tmp___2];
#line 225
      i ++;
    }
#line 230
    switch (kind) {
    case 0: 
#line 233
    fd = open((char const   *)tmpl, 15, 384);
#line 234
    break;
    case 1: 
#line 237
    fd = open((char const   *)tmpl, 15, 384);
#line 238
    break;
    case 2: 
#line 241
    fd = rpl_mkdir((char const   *)tmpl, 448U);
#line 242
    break;
    case 3: 
#line 249
    __cil_tmp___5 = lstat((char const   *)tmpl, & st);
#line 249
    if (__cil_tmp___5 < 0) {
#line 251
      __cil_tmp___4 = __errno();
#line 251
      if (*__cil_tmp___4 == 2) {
#line 253
        __cil_tmp___3 = __errno();
#line 253
        *__cil_tmp___3 = save_errno;
#line 254
        fd = 0;
#line 255
        goto done;
      } else {
#line 260
        fd = -1;
#line 261
        goto done;
      }
    }
#line 264
    goto __Cont;
    default: 
#line 267
    __libc_failwith((char *)"Assertion failed: ! \"invalid KIND in __gen_tempname\" at tempname.c:267");
    }
#line 270
    if (fd >= 0) {
#line 272
      __cil_tmp___6 = __errno();
#line 272
      *__cil_tmp___6 = save_errno;
#line 273
      goto done;
    } else {
#line 275
      __cil_tmp___7 = __errno();
#line 275
      if (*__cil_tmp___7 != 17) {
#line 277
        fd = -1;
#line 278
        goto done;
      }
    }
    __Cont: 
#line 221
    count ++;
  }
#line 282
  randint_all_free(rand_src);
#line 285
  __cil_tmp___8 = __errno();
#line 285
  *__cil_tmp___8 = 17;
#line 286
  return (-1);
  done: 
#line 290
  __cil_tmp___9 = __errno();
#line 290
  saved_errno = *__cil_tmp___9;
#line 291
  randint_all_free(rand_src);
#line 292
  __cil_tmp___10 = __errno();
#line 292
  *__cil_tmp___10 = saved_errno;
#line 294
  return (fd);
}
}
#line 297 "tempname.c"
int gen_tempname(char *tmpl , int kind ) 
{ int __cil_tmp ;

  {
#line 300
  __cil_tmp = gen_tempname_len(tmpl, kind, 6U);
#line 300
  return (__cil_tmp);
}
}
#line 1 "uinttostr.o"
#pragma merger(0,"/tmp/cil-LZ4SroCy.i","-g,-O2")
#line 29 "inttostr.h"
char *uinttostr(unsigned int i , char *buf___0 ) ;
#line 28 "inttostr.c"
char *uinttostr(unsigned int i , char *buf___0 ) 
{ char *p ;

  {
#line 31
  p = buf___0 + ((((sizeof(unsigned int ) * 8U - 1U) * 146U) / 485U + 1U) + 1U);
#line 32
  *p = (char)0;
#line 34
  if (i < 0U) {
#line 36
    while (1) {
#line 37
      p --;
#line 37
      *p = (char )(48U - i % 10U);
#line 36
      i /= 10U;
#line 36
      if (! (i != 0U)) {
#line 36
        break;
      }
    }
#line 40
    p --;
#line 40
    *p = (char )'-';
  } else {
#line 44
    while (1) {
#line 45
      p --;
#line 45
      *p = (char )(48U + i % 10U);
#line 44
      i /= 10U;
#line 44
      if (! (i != 0U)) {
#line 44
        break;
      }
    }
  }
#line 49
  return (p);
}
}
#line 1 "umaxtostr.o"
#pragma merger(0,"/tmp/cil-JYeE4PgF.i","-g,-O2")
#line 28 "inttostr.h"
char *umaxtostr(unsigned long long i , char *buf___0 ) ;
#line 28 "inttostr.c"
char *umaxtostr(unsigned long long i , char *buf___0 ) 
{ char *p ;

  {
#line 31
  p = buf___0 + ((((sizeof(unsigned long long ) * 8U - 1U) * 146U) / 485U + 1U) + 1U);
#line 32
  *p = (char)0;
#line 34
  if (i < 0ULL) {
#line 36
    while (1) {
#line 37
      p --;
#line 37
      *p = (char )(48ULL - i % 10ULL);
#line 36
      i /= 10ULL;
#line 36
      if (! (i != 0ULL)) {
#line 36
        break;
      }
    }
#line 40
    p --;
#line 40
    *p = (char )'-';
  } else {
#line 44
    while (1) {
#line 45
      p --;
#line 45
      *p = (char )(48ULL + i % 10ULL);
#line 44
      i /= 10ULL;
#line 44
      if (! (i != 0ULL)) {
#line 44
        break;
      }
    }
  }
#line 49
  return (p);
}
}
#line 1 "unlinkdir.o"
#pragma merger(0,"/tmp/cil-P2l9Y70M.i","-g,-O2")
#line 25 "unlinkdir.h"
_Bool cannot_unlink_dir(void) ;
#line 38 "unlinkdir.c"
static _Bool initialized___1  ;
#line 39 "unlinkdir.c"
static _Bool cannot  ;
#line 35 "unlinkdir.c"
_Bool cannot_unlink_dir(void) 
{ uid_t __cil_tmp ;

  {
#line 41
  if (! initialized___1) {
#line 59
    __cil_tmp = geteuid();
#line 59
    cannot = (_Bool )((int )__cil_tmp != 0);
#line 61
    initialized___1 = (_Bool)1;
  }
#line 64
  return (cannot);
}
}
#line 1 "userspec.o"
#pragma merger(0,"/tmp/cil-AiOJufZz.i","-g,-O2")
#line 6 "userspec.h"
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) ;
#line 20 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/otter/include/pwd.h"
extern void endpwent() ;
#line 45 "xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 106 "userspec.c"
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) ;
#line 106 "userspec.c"
static char const   *E_invalid_user  =    "invalid user";
#line 107 "userspec.c"
static char const   *E_invalid_group  =    "invalid group";
#line 108 "userspec.c"
static char const   *E_bad_spec  =    "invalid spec";
#line 101 "userspec.c"
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) 
{ char const   *error_msg ;
  struct passwd *pwd ;
  struct group *grp ;
  char *u ;
  char const   *g ;
  char *gname ;
  uid_t unum ;
  gid_t gnum ;
  char *__cil_tmp ;
  size_t ulen ;
  void *__cil_tmp___0 ;
  struct passwd *__cil_tmp___1 ;
  _Bool use_login_group ;
  unsigned long tmp ;
  strtol_error __cil_tmp___2 ;
  char buf___0[((((sizeof(unsigned long long ) * 8U - 1U) * 146U) / 485U + 1U) + 1U) + 1U] ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  struct group *__cil_tmp___5 ;
  unsigned long tmp___0 ;
  strtol_error __cil_tmp___6 ;

  {
#line 115
  gname = (char *)((void *)0);
#line 116
  unum = *uid;
#line 117
  gnum = *gid;
#line 119
  error_msg = (char const   *)((void *)0);
#line 120
  __cil_tmp = (char *)((void *)0);
#line 120
  *groupname = __cil_tmp;
#line 120
  *username = __cil_tmp;
#line 126
  u = (char *)((void *)0);
#line 127
  if ((unsigned int )separator == (unsigned int )((void *)0)) {
#line 129
    if (*spec) {
#line 130
      u = xstrdup(spec);
    }
  } else {
#line 134
    ulen = (unsigned int )(separator - spec);
#line 135
    if (ulen != 0U) {
#line 137
      __cil_tmp___0 = xmemdup((void const   *)spec, ulen + 1U);
#line 137
      u = (char *)__cil_tmp___0;
#line 138
      *(u + ulen) = (char )'\000';
    }
  }
#line 142
  g = (unsigned int )separator == (unsigned int )((void *)0) || (int const   )*(separator + 1) == 0 ? (char const   *)((void *)0) : separator + 1;
#line 155
  if ((unsigned int )u != (unsigned int )((void *)0)) {
#line 158
    if ((int )*u == 43) {
#line 158
      pwd = (struct passwd *)((void *)0);
    } else {
#line 158
      __cil_tmp___1 = getpwnam((char const   *)u);
#line 158
      pwd = __cil_tmp___1;
    }
#line 159
    if ((unsigned int )pwd == (unsigned int )((void *)0)) {
#line 161
      use_login_group = (_Bool )((unsigned int )separator != (unsigned int )((void *)0) && (unsigned int )g == (unsigned int )((void *)0));
#line 162
      if (use_login_group) {
#line 166
        error_msg = E_bad_spec;
      } else {
#line 171
        __cil_tmp___2 = xstrtoul((char const   *)u, (char **)((void *)0), 10, & tmp,
                                 "");
#line 171
        if ((unsigned int )__cil_tmp___2 == 0U && tmp <= 65535UL) {
#line 173
          unum = (unsigned short )tmp;
        } else {
#line 175
          error_msg = E_invalid_user;
        }
      }
    } else {
#line 180
      unum = pwd->pw_uid;
#line 181
      if ((unsigned int )g == (unsigned int )((void *)0) && (unsigned int )separator != (unsigned int )((void *)0)) {
#line 186
        gnum = pwd->pw_gid;
#line 187
        grp = getgrgid(gnum);
#line 188
        if (grp) {
#line 188
          __cil_tmp___4 = grp->gr_name;
        } else {
#line 188
          __cil_tmp___3 = umaxtostr((unsigned long long )gnum, buf___0);
#line 188
          __cil_tmp___4 = __cil_tmp___3;
        }
#line 188
        gname = xstrdup((char const   *)__cil_tmp___4);
#line 189
        endgrent();
      }
    }
#line 192
    endpwent();
  }
#line 195
  if ((unsigned int )g != (unsigned int )((void *)0) && (unsigned int )error_msg == (unsigned int )((void *)0)) {
#line 199
    if ((int const   )*g == 43) {
#line 199
      grp = (struct group *)((void *)0);
    } else {
#line 199
      __cil_tmp___5 = getgrnam(g);
#line 199
      grp = __cil_tmp___5;
    }
#line 200
    if ((unsigned int )grp == (unsigned int )((void *)0)) {
#line 203
      __cil_tmp___6 = xstrtoul(g, (char **)((void *)0), 10, & tmp___0, "");
#line 203
      if ((unsigned int )__cil_tmp___6 == 0U && tmp___0 <= 65535UL) {
#line 204
        gnum = (unsigned short )tmp___0;
      } else {
#line 206
        error_msg = E_invalid_group;
      }
    } else {
#line 209
      gnum = grp->gr_gid;
    }
#line 210
    endgrent();
#line 211
    gname = xstrdup(g);
  }
#line 214
  if ((unsigned int )error_msg == (unsigned int )((void *)0)) {
#line 216
    *uid = unum;
#line 217
    *gid = gnum;
#line 218
    *username = u;
#line 219
    *groupname = gname;
#line 220
    u = (char *)((void *)0);
  } else {
#line 223
    free((void *)gname);
  }
#line 225
  free((void *)u);
#line 226
  return (error_msg);
}
}
#line 245 "userspec.c"
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) 
{ char const   *colon ;
  char *__cil_tmp ;
  char const   *error_msg ;
  char const   *__cil_tmp___0 ;
  char const   *dot ;
  char *__cil_tmp___1 ;
  char const   *__cil_tmp___2 ;

  {
#line 249
  __cil_tmp = strchr(spec, ':');
#line 249
  colon = (char const   *)__cil_tmp;
#line 250
  __cil_tmp___0 = parse_with_separator(spec, colon, uid, gid, username, groupname);
#line 250
  error_msg = __cil_tmp___0;
#line 253
  if (! colon && error_msg) {
#line 261
    __cil_tmp___1 = strchr(spec, '.');
#line 261
    dot = (char const   *)__cil_tmp___1;
#line 262
    if (dot) {
#line 262
      __cil_tmp___2 = parse_with_separator(spec, dot, uid, gid, username, groupname);
#line 262
      if (! __cil_tmp___2) {
#line 264
        error_msg = (char const   *)((void *)0);
      }
    }
  }
#line 267
  return (error_msg);
}
}
#line 1 "utime.o"
#pragma merger(0,"/tmp/cil-PzCsczuN.i","-g,-O2")
#line 58 "utime.c"
static int utime_null(char const   *file ) 
{ int fd ;
  char c ;
  int status ;
  struct stat st ;
  int saved_errno ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  off_t __cil_tmp___2 ;
  size_t __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int *__cil_tmp___6 ;

  {
#line 66
  status = 0;
#line 68
  saved_errno = 0;
#line 70
  fd = open(file, 3);
#line 71
  if (fd < 0) {
#line 82
    __cil_tmp = __errno();
#line 82
    saved_errno = *__cil_tmp;
#line 83
    status = -1;
  } else {
#line 71
    __cil_tmp___0 = fstat(fd, & st);
#line 71
    if (__cil_tmp___0 < 0) {
#line 82
      __cil_tmp = __errno();
#line 82
      saved_errno = *__cil_tmp;
#line 83
      status = -1;
    } else {
#line 71
      __cil_tmp___1 = safe_read(fd, (void *)(& c), sizeof(c));
#line 71
      if (__cil_tmp___1 == 4294967295U) {
#line 82
        __cil_tmp = __errno();
#line 82
        saved_errno = *__cil_tmp;
#line 83
        status = -1;
      } else {
#line 71
        __cil_tmp___2 = lseek(fd, 0L, 0);
#line 71
        if (__cil_tmp___2 < 0L) {
#line 82
          __cil_tmp = __errno();
#line 82
          saved_errno = *__cil_tmp;
#line 83
          status = -1;
        } else {
#line 71
          __cil_tmp___3 = full_write(fd, (void const   *)(& c), sizeof(c));
#line 71
          if (__cil_tmp___3 != sizeof(c)) {
#line 82
            __cil_tmp = __errno();
#line 82
            saved_errno = *__cil_tmp;
#line 83
            status = -1;
          } else
#line 71
          if (st.st_size == 0L) {
#line 71
            __cil_tmp___4 = ftruncate(fd, st.st_size);
#line 71
            if (__cil_tmp___4 < 0) {
#line 82
              __cil_tmp = __errno();
#line 82
              saved_errno = *__cil_tmp;
#line 83
              status = -1;
            }
          }
        }
      }
    }
  }
#line 86
  if (0 <= fd) {
#line 88
    __cil_tmp___5 = close(fd);
#line 88
    if (__cil_tmp___5 < 0) {
#line 89
      status = -1;
    }
#line 93
    if (saved_errno) {
#line 94
      __cil_tmp___6 = __errno();
#line 94
      *__cil_tmp___6 = saved_errno;
    }
  }
#line 97
  return (status);
}
}
#line 105
extern int utime() ;
#line 101 "utime.c"
int rpl_utime(char const   *file , struct utimbuf  const  *times ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 104
  if (times) {
#line 105
    __cil_tmp = utime(file, times);
#line 105
    return (__cil_tmp);
  }
#line 107
  __cil_tmp___0 = utime_null(file);
#line 107
  return (__cil_tmp___0);
}
}
#line 1 "utimecmp.o"
#pragma merger(0,"/tmp/cil-XnC69Wnu.i","-g,-O2")
#line 35 "utimecmp.h"
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) ;
#line 49 "stat-time.h"
__inline static long get_stat_atime_ns(struct stat  const  *st ) 
{ 

  {
#line 57
  return (0L);
}
}
#line 3 "utimens.h"
int utimens(char const   *file , struct timespec  const  *timespec ) ;
#line 75 "utimecmp.c"
static size_t dev_info_hash(void const   *x , size_t table_size ) 
{ struct fs_res  const  *p ;
  unsigned long long dev ;

  {
#line 78
  p = (struct fs_res  const  *)x;
#line 81
  if (((1U << 31) - 1U) * 2U + 1U < (unsigned int )(2147483647 > (int )((short )(~ (-1 << (sizeof(dev_t ) * 8U - 1U)))) ? 2147483647 : (int )((short )(~ (-1 << (sizeof(dev_t ) * 8U - 1U)))))) {
#line 83
    dev = (unsigned long long )p->dev;
#line 84
    return ((unsigned int )(dev % (unsigned long long )table_size));
  }
#line 87
  return ((unsigned int )p->dev % table_size);
}
}
#line 91 "utimecmp.c"
static _Bool dev_info_compare(void const   *x , void const   *y ) 
{ struct fs_res  const  *a ;
  struct fs_res  const  *b ;

  {
#line 94
  a = (struct fs_res  const  *)x;
#line 95
  b = (struct fs_res  const  *)y;
#line 96
  return ((_Bool )((int const   )a->dev == (int const   )b->dev));
}
}
#line 141 "utimecmp.c"
static Hash_table *ht  ;
#line 144 "utimecmp.c"
static struct fs_res *new_dst_res  ;
#line 110 "utimecmp.c"
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) 
{ time_t dst_s ;
  time_t src_s ;
  int dst_ns ;
  long __cil_tmp ;
  int src_ns ;
  long __cil_tmp___0 ;
  struct fs_res *dst_res ;
  int res ;
  void *__cil_tmp___1 ;
  void *__cil_tmp___2 ;
  time_t dst_a_s ;
  time_t dst_c_s ;
  time_t dst_m_s ;
  int dst_a_ns ;
  long __cil_tmp___3 ;
  int dst_c_ns ;
  long __cil_tmp___4 ;
  int dst_m_ns ;
  _Bool odd_second ;
  struct timespec timespec[2] ;
  struct stat dst_status ;
  time_t s ;
  int __cil_tmp___5 ;
  int stat_result ;
  int __cil_tmp___6 ;
  long __cil_tmp___7 ;
  int old_res ;
  int a___0 ;
  long __cil_tmp___8 ;

  {
#line 131
  dst_s = (long )dst_stat->st_mtime;
#line 132
  src_s = (long )src_stat->st_mtime;
#line 133
  __cil_tmp = get_stat_atime_ns(dst_stat);
#line 133
  dst_ns = (int )__cil_tmp;
#line 134
  __cil_tmp___0 = get_stat_atime_ns(src_stat);
#line 134
  src_ns = (int )__cil_tmp___0;
#line 136
  if (options & 1) {
#line 150
    if (! ht) {
#line 151
      ht = hash_initialize(16U, (Hash_tuning const   *)((void *)0), & dev_info_hash,
                           & dev_info_compare, & free);
    }
#line 152
    if (! new_dst_res) {
#line 154
      __cil_tmp___1 = xmalloc(sizeof(*new_dst_res));
#line 154
      new_dst_res = (struct fs_res *)__cil_tmp___1;
#line 155
      new_dst_res->resolution = 2000000000;
#line 156
      new_dst_res->exact = (_Bool)0;
    }
#line 158
    new_dst_res->dev = (short )dst_stat->st_dev;
#line 159
    __cil_tmp___2 = hash_insert(ht, (void const   *)new_dst_res);
#line 159
    dst_res = (struct fs_res *)__cil_tmp___2;
#line 160
    if (! dst_res) {
#line 161
      xalloc_die();
    }
#line 163
    if ((unsigned int )dst_res == (unsigned int )new_dst_res) {
#line 167
      new_dst_res = (struct fs_res *)((void *)0);
    }
#line 170
    res = dst_res->resolution;
#line 172
    if (! dst_res->exact) {
#line 177
      dst_a_s = (long )dst_stat->st_atime;
#line 178
      dst_c_s = (long )dst_stat->st_ctime;
#line 179
      dst_m_s = dst_s;
#line 180
      __cil_tmp___3 = get_stat_atime_ns(dst_stat);
#line 180
      dst_a_ns = (int )__cil_tmp___3;
#line 181
      __cil_tmp___4 = get_stat_atime_ns(dst_stat);
#line 181
      dst_c_ns = (int )__cil_tmp___4;
#line 182
      dst_m_ns = dst_ns;
#line 191
      odd_second = (_Bool )(((dst_a_s | dst_c_s) | dst_m_s) & 1L);
#line 195
      if ((((int )odd_second | dst_a_ns) | dst_c_ns) | dst_m_ns) {
#line 196
        res = 1000000000;
      }
#line 223
      dst_res->resolution = res;
#line 226
      if (1000000000 < res) {
#line 233
        src_ns -= src_ns % 1000000000;
#line 239
        s = src_s & (long )(~ (res == 2000000000));
#line 240
        if (src_s < dst_s || (src_s == dst_s && src_ns <= dst_ns)) {
#line 241
          return (1);
        }
#line 242
        if (dst_s < s || (dst_s == s && dst_ns < src_ns - src_ns % res)) {
#line 244
          return (-1);
        }
#line 253
        timespec[0].tv_sec = dst_a_s;
#line 254
        timespec[0].tv_nsec = (long )dst_a_ns;
#line 255
        timespec[1].tv_sec = dst_m_s | (long )(res == 2000000000);
#line 256
        timespec[1].tv_nsec = (long )(dst_m_ns + res / 9);
#line 261
        if ((dst_stat->st_mode & 8323072U) == 2097152U) {
#line 263
          return (-2);
        } else {
#line 261
          __cil_tmp___5 = utimens(dst_name, (struct timespec  const  *)(timespec));
#line 261
          if (__cil_tmp___5 != 0) {
#line 263
            return (-2);
          }
        }
#line 270
        __cil_tmp___6 = stat(dst_name, & dst_status);
#line 270
        stat_result = __cil_tmp___6;
#line 272
        __cil_tmp___7 = get_stat_atime_ns((struct stat  const  *)(& dst_status));
#line 272
        if (((long )stat_result | (dst_status.st_mtime ^ dst_m_s)) | (__cil_tmp___7 ^ (long )dst_m_ns)) {
#line 278
          timespec[1].tv_sec = dst_m_s;
#line 279
          timespec[1].tv_nsec = (long )dst_m_ns;
#line 280
          utimens(dst_name, (struct timespec  const  *)(timespec));
        }
#line 283
        if (stat_result != 0) {
#line 284
          return (-2);
        }
#line 290
        old_res = res;
#line 291
        __cil_tmp___8 = get_stat_atime_ns((struct stat  const  *)(& dst_status));
#line 291
        a___0 = (int )(1000000000L * (dst_status.st_mtime & 1L) + __cil_tmp___8);
#line 294
        res = 1000000000;
#line 296
        a___0 /= res;
#line 296
        while (a___0 % 10 != 0) {
#line 298
          if (res == 1000000000) {
#line 300
            res *= 2;
#line 301
            break;
          }
#line 303
          res *= 10;
#line 304
          if (res == old_res) {
#line 305
            break;
          }
#line 296
          a___0 /= 10;
        }
      }
#line 310
      dst_res->resolution = res;
#line 311
      dst_res->exact = (_Bool)1;
    }
#line 315
    src_s &= (long )(~ (res == 2000000000));
#line 316
    src_ns -= src_ns % res;
  }
#line 320
  return (dst_s < src_s ? -1 : (dst_s > src_s ? 1 : (dst_ns < src_ns ? -1 : dst_ns > src_ns)));
}
}
#line 1 "utimens.o"
#pragma merger(0,"/tmp/cil-Rl0x34jt.i","-g,-O2")
#line 2 "utimens.h"
int gl_futimens(int fd , char const   *file , struct timespec  const  *timespec ) ;
#line 38 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/sys/unistd.h"
extern int dup(int __fildes ) ;
#line 76 "utimens.c"
int gl_futimens(int fd , char const   *file , struct timespec  const  *timespec ) 
{ int *__cil_tmp ;
  int fd2 ;
  int __cil_tmp___0 ;
  int dup_errno ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  struct utimbuf utimbuf ;
  struct utimbuf  const  *ut ;
  int __cil_tmp___4 ;

  {
#line 143
  if (! file) {
#line 146
    __cil_tmp = __errno();
#line 146
    *__cil_tmp = 88;
#line 150
    __cil_tmp___3 = __errno();
#line 150
    if (*__cil_tmp___3 == 88) {
#line 152
      __cil_tmp___0 = dup(fd);
#line 152
      fd2 = __cil_tmp___0;
#line 153
      __cil_tmp___1 = __errno();
#line 153
      dup_errno = *__cil_tmp___1;
#line 154
      if (0 <= fd2) {
#line 155
        close(fd2);
      }
#line 156
      __cil_tmp___2 = __errno();
#line 156
      *__cil_tmp___2 = fd2 < 0 && dup_errno == 9 ? 9 : 88;
    }
#line 159
    return (-1);
  }
#line 168
  if (timespec) {
#line 170
    utimbuf.actime = (long )(timespec + 0)->tv_sec;
#line 171
    utimbuf.modtime = (long )(timespec + 1)->tv_sec;
#line 172
    ut = (struct utimbuf  const  *)(& utimbuf);
  } else {
#line 175
    ut = (struct utimbuf  const  *)((void *)0);
  }
#line 177
  __cil_tmp___4 = rpl_utime(file, ut);
#line 177
  return (__cil_tmp___4);
}
}
#line 184 "utimens.c"
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ int __cil_tmp ;

  {
#line 187
  __cil_tmp = gl_futimens(-1, file, timespec);
#line 187
  return (__cil_tmp);
}
}
#line 1 "vasnprintf.o"
#pragma merger(0,"/tmp/cil-YkCPQgto.i","-g,-O2")
#line 75 "xsize.h"
__inline static size_t xsum4(size_t size1 , size_t size2 , size_t size3 , size_t size4 ) 
{ size_t __cil_tmp ;
  size_t __cil_tmp___0 ;
  size_t __cil_tmp___1 ;

  {
#line 81
  __cil_tmp = xsum(size1, size2);
#line 81
  __cil_tmp___0 = xsum(__cil_tmp, size3);
#line 81
  __cil_tmp___1 = xsum(__cil_tmp___0, size4);
#line 81
  return (__cil_tmp___1);
}
}
#line 85 "xsize.h"
__inline static size_t xmax(size_t size1 , size_t size2 ) 
{ 

  {
#line 93
  return (size1 >= size2 ? size1 : size2);
}
}
#line 212 "vasnprintf.c"
static char decimal_point_char(void) 
{ char const   *point ;
  char pointbuf[5] ;

  {
#line 224
  sprintf(pointbuf, "%#.0f", 1.0);
#line 225
  point = (char const   *)(& pointbuf[1]);
#line 230
  return ((char )((int const   )*(point + 0) != 0 ? (int const   )*(point + 0) : (int const   )'.'));
}
}
#line 281 "vasnprintf.c"
static void *multiply(mpn_t src1 , mpn_t src2 , mpn_t *dest ) 
{ mp_limb_t const   *p1 ;
  mp_limb_t const   *p2 ;
  size_t len1 ;
  size_t len2 ;
  void *__cil_tmp ;
  size_t dlen ;
  mp_limb_t *dp ;
  size_t k ;
  size_t i ;
  size_t j ;
  void *__cil_tmp___0 ;
  mp_limb_t digit1 ;
  mp_twolimb_t carry ;
  mp_limb_t digit2 ;

  {
#line 289
  if (src1.nlimbs <= src2.nlimbs) {
#line 291
    len1 = src1.nlimbs;
#line 292
    p1 = (mp_limb_t const   *)src1.limbs;
#line 293
    len2 = src2.nlimbs;
#line 294
    p2 = (mp_limb_t const   *)src2.limbs;
  } else {
#line 298
    len1 = src2.nlimbs;
#line 299
    p1 = (mp_limb_t const   *)src2.limbs;
#line 300
    len2 = src1.nlimbs;
#line 301
    p2 = (mp_limb_t const   *)src1.limbs;
  }
#line 304
  if (len1 == 0U) {
#line 307
    dest->nlimbs = 0U;
#line 308
    __cil_tmp = rpl_malloc(1U);
#line 308
    dest->limbs = (mp_limb_t *)__cil_tmp;
  } else {
#line 317
    dlen = len1 + len2;
#line 318
    __cil_tmp___0 = rpl_malloc(dlen * sizeof(mp_limb_t ));
#line 318
    dp = (mp_limb_t *)__cil_tmp___0;
#line 319
    if ((unsigned int )dp == (unsigned int )((void *)0)) {
#line 320
      return ((void *)0);
    }
#line 321
    k = len2;
#line 321
    while (k > 0U) {
#line 322
      k --;
#line 322
      *(dp + k) = 0U;
    }
#line 323
    i = 0U;
#line 323
    while (i < len1) {
#line 325
      digit1 = (unsigned int )*(p1 + i);
#line 326
      carry = 0ULL;
#line 327
      j = 0U;
#line 327
      while (j < len2) {
#line 329
        digit2 = (unsigned int )*(p2 + j);
#line 330
        carry += (unsigned long long )digit1 * (unsigned long long )digit2;
#line 331
        carry += (unsigned long long )*(dp + (i + j));
#line 332
        *(dp + (i + j)) = (unsigned int )carry;
#line 333
        carry >>= 32;
#line 327
        j ++;
      }
#line 335
      *(dp + (i + len2)) = (unsigned int )carry;
#line 323
      i ++;
    }
#line 338
    while (dlen > 0U && *(dp + (dlen - 1U)) == 0U) {
#line 339
      dlen --;
    }
#line 340
    dest->nlimbs = dlen;
#line 341
    dest->limbs = dp;
  }
#line 343
  return ((void *)dest->limbs);
}
}
#line 353 "vasnprintf.c"
static void *divide(mpn_t a , mpn_t b , mpn_t *q ) 
{ mp_limb_t const   *a_ptr ;
  size_t a_len ;
  mp_limb_t const   *b_ptr ;
  size_t b_len ;
  mp_limb_t *roomptr ;
  mp_limb_t *tmp_roomptr ;
  mp_limb_t *q_ptr ;
  size_t q_len ;
  mp_limb_t *r_ptr ;
  size_t r_len ;
  void *__cil_tmp ;
  mp_limb_t den ;
  mp_limb_t remainder___0 ;
  mp_limb_t const   *sourceptr ;
  mp_limb_t *destptr ;
  size_t count ;
  mp_twolimb_t num ;
  size_t s ;
  mp_limb_t msd ;
  void *__cil_tmp___0 ;
  mp_limb_t const   *sourceptr___0 ;
  mp_limb_t *destptr___0 ;
  mp_twolimb_t accu ;
  size_t count___0 ;
  mp_limb_t const   *__cil_tmp___1 ;
  mp_limb_t *__cil_tmp___2 ;
  mp_limb_t const   *sourceptr___1 ;
  mp_limb_t *destptr___1 ;
  mp_twolimb_t accu___0 ;
  size_t count___1 ;
  mp_limb_t const   *__cil_tmp___3 ;
  mp_limb_t *__cil_tmp___4 ;
  mp_limb_t *__cil_tmp___5 ;
  size_t j ;
  mp_limb_t b_msd ;
  mp_limb_t b_2msd ;
  mp_twolimb_t b_msdd ;
  mp_limb_t q_star ;
  mp_limb_t c1 ;
  mp_twolimb_t num___0 ;
  mp_twolimb_t c2 ;
  mp_twolimb_t c3 ;
  mp_limb_t cr ;
  mp_limb_t const   *sourceptr___2 ;
  mp_limb_t *destptr___2 ;
  mp_twolimb_t carry ;
  size_t count___2 ;
  mp_limb_t const   *__cil_tmp___6 ;
  mp_limb_t *__cil_tmp___7 ;
  mp_limb_t const   *sourceptr___3 ;
  mp_limb_t *destptr___3 ;
  mp_limb_t carry___0 ;
  size_t count___3 ;
  mp_limb_t source1 ;
  mp_limb_t const   *__cil_tmp___8 ;
  mp_limb_t source2 ;
  mp_limb_t *__cil_tmp___9 ;
  size_t i ;
  mp_limb_t r_i ;
  mp_limb_t b_i ;
  size_t i___0 ;
  size_t __cil_tmp___10 ;

  {
#line 407
  a_ptr = (mp_limb_t const   *)a.limbs;
#line 408
  a_len = a.nlimbs;
#line 409
  b_ptr = (mp_limb_t const   *)b.limbs;
#line 410
  b_len = b.nlimbs;
#line 412
  tmp_roomptr = (mp_limb_t *)((void *)0);
#line 421
  __cil_tmp = rpl_malloc((a_len + 2U) * sizeof(mp_limb_t ));
#line 421
  roomptr = (mp_limb_t *)__cil_tmp;
#line 422
  if ((unsigned int )roomptr == (unsigned int )((void *)0)) {
#line 423
    return ((void *)0);
  }
#line 426
  while (a_len > 0U && *(a_ptr + (a_len - 1U)) == 0U) {
#line 427
    a_len --;
  }
#line 430
  while (1) {
#line 432
    if (b_len == 0U) {
#line 434
      abort();
    }
#line 435
    if (*(b_ptr + (b_len - 1U)) == 0U) {
#line 436
      b_len --;
    } else {
#line 438
      break;
    }
  }
#line 443
  if (a_len < b_len) {
#line 446
    r_ptr = roomptr;
#line 447
    r_len = a_len;
#line 448
    memcpy((void *)r_ptr, (void const   *)a_ptr, a_len * sizeof(mp_limb_t ));
#line 449
    q_ptr = roomptr + a_len;
#line 450
    q_len = 0U;
  } else
#line 452
  if (b_len == 1U) {
#line 456
    r_ptr = roomptr;
#line 457
    q_ptr = roomptr + 1;
#line 459
    den = (unsigned int )*(b_ptr + 0);
#line 460
    remainder___0 = 0U;
#line 461
    sourceptr = a_ptr + a_len;
#line 462
    destptr = q_ptr + a_len;
#line 464
    count = a_len;
#line 464
    while (count > 0U) {
#line 466
      sourceptr --;
#line 466
      num = ((unsigned long long )remainder___0 << 32) | (unsigned long long )*sourceptr;
#line 468
      destptr --;
#line 468
      *destptr = (unsigned int )(num / (unsigned long long )den);
#line 469
      remainder___0 = (unsigned int )(num % (unsigned long long )den);
#line 464
      count --;
    }
#line 472
    if (remainder___0 > 0U) {
#line 474
      *(r_ptr + 0) = remainder___0;
#line 475
      r_len = 1U;
    } else {
#line 478
      r_len = 0U;
    }
#line 480
    q_len = a_len;
#line 481
    if (*(q_ptr + (q_len - 1U)) == 0U) {
#line 482
      q_len --;
    }
  } else {
#line 493
    msd = (unsigned int )*(b_ptr + (b_len - 1U));
#line 494
    s = 31U;
#line 495
    if (msd >= 65536U) {
#line 497
      msd >>= 16;
#line 498
      s -= 16U;
    }
#line 500
    if (msd >= 256U) {
#line 502
      msd >>= 8;
#line 503
      s -= 8U;
    }
#line 505
    if (msd >= 16U) {
#line 507
      msd >>= 4;
#line 508
      s -= 4U;
    }
#line 510
    if (msd >= 4U) {
#line 512
      msd >>= 2;
#line 513
      s -= 2U;
    }
#line 515
    if (msd >= 2U) {
#line 517
      msd >>= 1;
#line 518
      s --;
    }
#line 523
    if (s > 0U) {
#line 525
      __cil_tmp___0 = rpl_malloc(b_len * sizeof(mp_limb_t ));
#line 525
      tmp_roomptr = (mp_limb_t *)__cil_tmp___0;
#line 526
      if ((unsigned int )tmp_roomptr == (unsigned int )((void *)0)) {
#line 528
        free((void *)roomptr);
#line 529
        return ((void *)0);
      }
#line 532
      sourceptr___0 = b_ptr;
#line 533
      destptr___0 = tmp_roomptr;
#line 534
      accu = 0ULL;
#line 536
      count___0 = b_len;
#line 536
      while (count___0 > 0U) {
#line 538
        __cil_tmp___1 = sourceptr___0;
#line 538
        sourceptr___0 ++;
#line 538
        accu += (unsigned long long )*__cil_tmp___1 << s;
#line 539
        __cil_tmp___2 = destptr___0;
#line 539
        destptr___0 ++;
#line 539
        *__cil_tmp___2 = (unsigned int )accu;
#line 540
        accu >>= 32;
#line 536
        count___0 --;
      }
#line 543
      if (accu != 0ULL) {
#line 544
        abort();
      }
#line 546
      b_ptr = (mp_limb_t const   *)tmp_roomptr;
    }
#line 552
    r_ptr = roomptr;
#line 553
    if (s == 0U) {
#line 555
      memcpy((void *)r_ptr, (void const   *)a_ptr, a_len * sizeof(mp_limb_t ));
#line 556
      *(r_ptr + a_len) = 0U;
    } else {
#line 560
      sourceptr___1 = a_ptr;
#line 561
      destptr___1 = r_ptr;
#line 562
      accu___0 = 0ULL;
#line 564
      count___1 = a_len;
#line 564
      while (count___1 > 0U) {
#line 566
        __cil_tmp___3 = sourceptr___1;
#line 566
        sourceptr___1 ++;
#line 566
        accu___0 += (unsigned long long )*__cil_tmp___3 << s;
#line 567
        __cil_tmp___4 = destptr___1;
#line 567
        destptr___1 ++;
#line 567
        *__cil_tmp___4 = (unsigned int )accu___0;
#line 568
        accu___0 >>= 32;
#line 564
        count___1 --;
      }
#line 570
      __cil_tmp___5 = destptr___1;
#line 570
      destptr___1 ++;
#line 570
      *__cil_tmp___5 = (unsigned int )accu___0;
    }
#line 572
    q_ptr = roomptr + b_len;
#line 573
    q_len = (a_len - b_len) + 1U;
#line 575
    j = a_len - b_len;
#line 576
    b_msd = (unsigned int )*(b_ptr + (b_len - 1U));
#line 577
    b_2msd = (unsigned int )*(b_ptr + (b_len - 2U));
#line 578
    b_msdd = ((unsigned long long )b_msd << 32) | (unsigned long long )b_2msd;
#line 582
    while (1) {
#line 586
      if (*(r_ptr + (j + b_len)) < b_msd) {
#line 589
        num___0 = ((unsigned long long )*(r_ptr + (j + b_len)) << 32) | (unsigned long long )*(r_ptr + ((j + b_len) - 1U));
#line 592
        q_star = (unsigned int )(num___0 / (unsigned long long )b_msd);
#line 593
        c1 = (unsigned int )(num___0 % (unsigned long long )b_msd);
      } else {
#line 598
        q_star = ~ 0U;
#line 606
        if (*(r_ptr + (j + b_len)) > b_msd) {
#line 611
          goto subtract;
        } else {
#line 606
          c1 = *(r_ptr + ((j + b_len) - 1U)) + b_msd;
#line 606
          if (c1 < b_msd) {
#line 611
            goto subtract;
          }
        }
      }
#line 616
      c2 = ((unsigned long long )c1 << 32) | (unsigned long long )*(r_ptr + ((j + b_len) - 2U));
#line 618
      c3 = (unsigned long long )b_2msd * (unsigned long long )q_star;
#line 624
      if (c3 > c2) {
#line 626
        q_star --;
#line 627
        if (c3 - c2 > b_msdd) {
#line 628
          q_star --;
        }
      }
#line 631
      if (q_star > 0U) {
        subtract: 
#line 637
        sourceptr___2 = b_ptr;
#line 638
        destptr___2 = r_ptr + j;
#line 639
        carry = 0ULL;
#line 641
        count___2 = b_len;
#line 641
        while (count___2 > 0U) {
#line 644
          __cil_tmp___6 = sourceptr___2;
#line 644
          sourceptr___2 ++;
#line 644
          carry = (carry + (unsigned long long )q_star * (unsigned long long )*__cil_tmp___6) + (unsigned long long )(~ *destptr___2);
#line 649
          __cil_tmp___7 = destptr___2;
#line 649
          destptr___2 ++;
#line 649
          *__cil_tmp___7 = ~ ((unsigned int )carry);
#line 650
          carry >>= 32;
#line 641
          count___2 --;
        }
#line 652
        cr = (unsigned int )carry;
#line 656
        if (cr > *(r_ptr + (j + b_len))) {
#line 659
          q_star --;
#line 662
          sourceptr___3 = b_ptr;
#line 663
          destptr___3 = r_ptr + j;
#line 664
          carry___0 = 0U;
#line 666
          count___3 = b_len;
#line 666
          while (count___3 > 0U) {
#line 668
            __cil_tmp___8 = sourceptr___3;
#line 668
            sourceptr___3 ++;
#line 668
            source1 = (unsigned int )*__cil_tmp___8;
#line 669
            source2 = *destptr___3;
#line 670
            __cil_tmp___9 = destptr___3;
#line 670
            destptr___3 ++;
#line 670
            *__cil_tmp___9 = (source1 + source2) + carry___0;
#line 671
            carry___0 = (unsigned int )(carry___0 ? source1 >= ~ source2 : source1 > ~ source2);
#line 666
            count___3 --;
          }
        }
      }
#line 681
      *(q_ptr + j) = q_star;
#line 682
      if (j == 0U) {
#line 683
        break;
      }
#line 684
      j --;
    }
#line 687
    r_len = b_len;
#line 689
    if (*(q_ptr + (q_len - 1U)) == 0U) {
#line 690
      q_len --;
    }
#line 708
    while (r_len > 0U && *(r_ptr + (r_len - 1U)) == 0U) {
#line 709
      r_len --;
    }
  }
#line 712
  if (r_len > b_len) {
#line 713
    goto increment_q;
  }
#line 716
  i = b_len;
#line 716
  while (1) {
#line 718
    r_i = (i <= r_len && i > 0U ? *(r_ptr + (i - 1U)) >> 31 : 0U) | (i < r_len ? *(r_ptr + i) << 1 : 0U);
#line 721
    b_i = (unsigned int )(i < b_len ? *(b_ptr + i) : (unsigned int const   )0);
#line 722
    if (r_i > b_i) {
#line 723
      goto increment_q;
    }
#line 724
    if (r_i < b_i) {
#line 725
      goto keep_q;
    }
#line 726
    if (i == 0U) {
#line 727
      break;
    }
#line 728
    i --;
  }
#line 731
  if (q_len > 0U && (*(q_ptr + 0) & 1U) != 0U) {
    increment_q: 
#line 736
    i___0 = 0U;
#line 736
    while (i___0 < q_len) {
#line 737
      (*(q_ptr + i___0)) ++;
#line 737
      if (*(q_ptr + i___0) != 0U) {
#line 738
        goto keep_q;
      }
#line 736
      i___0 ++;
    }
#line 739
    __cil_tmp___10 = q_len;
#line 739
    q_len ++;
#line 739
    *(q_ptr + __cil_tmp___10) = 1U;
  }
  keep_q: 
#line 742
  if ((unsigned int )tmp_roomptr != (unsigned int )((void *)0)) {
#line 743
    free((void *)tmp_roomptr);
  }
#line 744
  q->limbs = q_ptr;
#line 745
  q->nlimbs = q_len;
#line 746
  return ((void *)roomptr);
}
}
#line 755 "vasnprintf.c"
static char *convert_to_decimal(mpn_t a , size_t extra_zeroes ) 
{ mp_limb_t *a_ptr ;
  size_t a_len ;
  size_t c_len ;
  char *c_ptr ;
  size_t __cil_tmp ;
  void *__cil_tmp___0 ;
  char *d_ptr ;
  char *__cil_tmp___1 ;
  mp_limb_t remainder___0 ;
  mp_limb_t *ptr ;
  size_t count ;
  mp_twolimb_t num ;
  char *__cil_tmp___2 ;
  char *__cil_tmp___3 ;

  {
#line 758
  a_ptr = a.limbs;
#line 759
  a_len = a.nlimbs;
#line 761
  c_len = 9U * ((unsigned int )((float )a_len * ((float )32 * 0.03345f)) + 1U);
#line 762
  __cil_tmp = xsum(c_len, extra_zeroes);
#line 762
  __cil_tmp___0 = rpl_malloc(__cil_tmp);
#line 762
  c_ptr = (char *)__cil_tmp___0;
#line 763
  if ((unsigned int )c_ptr != (unsigned int )((void *)0)) {
#line 765
    d_ptr = c_ptr;
#line 766
    while (extra_zeroes > 0U) {
#line 767
      __cil_tmp___1 = d_ptr;
#line 767
      d_ptr ++;
#line 767
      *__cil_tmp___1 = (char )'0';
#line 766
      extra_zeroes --;
    }
#line 768
    while (a_len > 0U) {
#line 771
      remainder___0 = 0U;
#line 772
      ptr = a_ptr + a_len;
#line 774
      count = a_len;
#line 774
      while (count > 0U) {
#line 776
        ptr --;
#line 776
        num = ((unsigned long long )remainder___0 << 32) | (unsigned long long )*ptr;
#line 778
        *ptr = (unsigned int )(num / 1000000000ULL);
#line 779
        remainder___0 = (unsigned int )(num % 1000000000ULL);
#line 774
        count --;
      }
#line 782
      count = 9U;
#line 782
      while (count > 0U) {
#line 784
        __cil_tmp___2 = d_ptr;
#line 784
        d_ptr ++;
#line 784
        *__cil_tmp___2 = (char )(48U + remainder___0 % 10U);
#line 785
        remainder___0 /= 10U;
#line 782
        count --;
      }
#line 788
      if (*(a_ptr + (a_len - 1U)) == 0U) {
#line 789
        a_len --;
      }
    }
#line 792
    while ((unsigned int )d_ptr > (unsigned int )c_ptr && (int )*(d_ptr + -1) == 48) {
#line 793
      d_ptr --;
    }
#line 795
    if ((unsigned int )d_ptr == (unsigned int )c_ptr) {
#line 796
      __cil_tmp___3 = d_ptr;
#line 796
      d_ptr ++;
#line 796
      *__cil_tmp___3 = (char )'0';
    }
#line 798
    *d_ptr = (char )'\000';
  }
#line 800
  return (c_ptr);
}
}
#line 809 "vasnprintf.c"
static void *decode_long_double(long double x , int *ep , mpn_t *mp ) 
{ mpn_t m ;
  int exp___0 ;
  long double y ;
  size_t i ;
  void *__cil_tmp ;
  mp_limb_t hi ;
  mp_limb_t lo ;
  mp_limb_t hi___0 ;
  mp_limb_t lo___0 ;

  {
#line 818
  m.nlimbs = 2U;
#line 819
  __cil_tmp = rpl_malloc(m.nlimbs * sizeof(mp_limb_t ));
#line 819
  m.limbs = (mp_limb_t *)__cil_tmp;
#line 820
  if ((unsigned int )m.limbs == (unsigned int )((void *)0)) {
#line 821
    return ((void *)0);
  }
#line 823
  y = rpl_frexpl(x, & exp___0);
#line 824
  if (! (y >= 0.0L && y < 1.0L)) {
#line 825
    abort();
  }
#line 837
  y *= (long double )(1U << 5);
#line 838
  hi = (unsigned int )((int )y);
#line 839
  y -= (long double )hi;
#line 840
  if (! (y >= 0.0L && y < 1.0L)) {
#line 841
    abort();
  }
#line 842
  y *= (long double )(1U << 16);
#line 843
  lo = (unsigned int )((int )y);
#line 844
  y -= (long double )lo;
#line 845
  if (! (y >= 0.0L && y < 1.0L)) {
#line 846
    abort();
  }
#line 847
  *(m.limbs + 1) = (hi << 16) | lo;
#line 861
  i = 1U;
#line 861
  while (i > 0U) {
#line 864
    y *= (long double )(1U << 16);
#line 865
    hi___0 = (unsigned int )((int )y);
#line 866
    y -= (long double )hi___0;
#line 867
    if (! (y >= 0.0L && y < 1.0L)) {
#line 868
      abort();
    }
#line 869
    y *= (long double )(1U << 16);
#line 870
    lo___0 = (unsigned int )((int )y);
#line 871
    y -= (long double )lo___0;
#line 872
    if (! (y >= 0.0L && y < 1.0L)) {
#line 873
      abort();
    }
#line 874
    i --;
#line 874
    *(m.limbs + i) = (hi___0 << 16) | lo___0;
  }
#line 882
  while (m.nlimbs > 0U && *(m.limbs + (m.nlimbs - 1U)) == 0U) {
#line 883
    (m.nlimbs) --;
  }
#line 884
  *mp = m;
#line 885
  *ep = exp___0 - 53;
#line 886
  return ((void *)m.limbs);
}
}
#line 897 "vasnprintf.c"
static void *decode_double(double x , int *ep , mpn_t *mp ) 
{ mpn_t m ;
  int exp___0 ;
  double y ;
  size_t i ;
  void *__cil_tmp ;
  mp_limb_t hi ;
  mp_limb_t lo ;
  mp_limb_t hi___0 ;
  mp_limb_t lo___0 ;

  {
#line 906
  m.nlimbs = 2U;
#line 907
  __cil_tmp = rpl_malloc(m.nlimbs * sizeof(mp_limb_t ));
#line 907
  m.limbs = (mp_limb_t *)__cil_tmp;
#line 908
  if ((unsigned int )m.limbs == (unsigned int )((void *)0)) {
#line 909
    return ((void *)0);
  }
#line 911
  y = rpl_frexp(x, & exp___0);
#line 912
  if (! (y >= 0.0 && y < 1.0)) {
#line 913
    abort();
  }
#line 925
  y *= (double )(1U << 5);
#line 926
  hi = (unsigned int )((int )y);
#line 927
  y -= (double )hi;
#line 928
  if (! (y >= 0.0 && y < 1.0)) {
#line 929
    abort();
  }
#line 930
  y *= (double )(1U << 16);
#line 931
  lo = (unsigned int )((int )y);
#line 932
  y -= (double )lo;
#line 933
  if (! (y >= 0.0 && y < 1.0)) {
#line 934
    abort();
  }
#line 935
  *(m.limbs + 1) = (hi << 16) | lo;
#line 949
  i = 1U;
#line 949
  while (i > 0U) {
#line 952
    y *= (double )(1U << 16);
#line 953
    hi___0 = (unsigned int )((int )y);
#line 954
    y -= (double )hi___0;
#line 955
    if (! (y >= 0.0 && y < 1.0)) {
#line 956
      abort();
    }
#line 957
    y *= (double )(1U << 16);
#line 958
    lo___0 = (unsigned int )((int )y);
#line 959
    y -= (double )lo___0;
#line 960
    if (! (y >= 0.0 && y < 1.0)) {
#line 961
      abort();
    }
#line 962
    i --;
#line 962
    *(m.limbs + i) = (hi___0 << 16) | lo___0;
  }
#line 964
  if (! (y == 0.0)) {
#line 965
    abort();
  }
#line 967
  while (m.nlimbs > 0U && *(m.limbs + (m.nlimbs - 1U)) == 0U) {
#line 968
    (m.nlimbs) --;
  }
#line 969
  *mp = m;
#line 970
  *ep = exp___0 - 53;
#line 971
  return ((void *)m.limbs);
}
}
#line 1032
static char *scale10_round_decimal_decoded(int e , mpn_t m , void *memory , int n ) ;
#line 1032 "vasnprintf.c"
static mp_limb_t const   small_pow5[14]  = 
#line 1032
  {      (unsigned int const   )1,      (unsigned int const   )5,      (unsigned int const   )25,      (unsigned int const   )125, 
        (unsigned int const   )625,      (unsigned int const   )3125,      (unsigned int const   )15625,      (unsigned int const   )78125, 
        (unsigned int const   )390625,      (unsigned int const   )1953125,      (unsigned int const   )9765625,      (unsigned int const   )48828125, 
        (unsigned int const   )244140625,      (unsigned int const   )1220703125};
#line 981 "vasnprintf.c"
static char *scale10_round_decimal_decoded(int e , mpn_t m , void *memory , int n ) 
{ int s ;
  size_t extra_zeroes ;
  unsigned int abs_n ;
  unsigned int abs_s ;
  mp_limb_t *pow5_ptr ;
  size_t pow5_len ;
  unsigned int s_limbs ;
  unsigned int s_bits ;
  mpn_t pow5 ;
  mpn_t z ;
  void *z_memory ;
  char *digits ;
  void *__cil_tmp ;
  unsigned int n13 ;
  mp_limb_t digit1 ;
  size_t j ;
  mp_twolimb_t carry ;
  mp_limb_t digit2 ;
  size_t __cil_tmp___0 ;
  mp_limb_t *ptr ;
  mp_twolimb_t accu ;
  size_t count ;
  mp_limb_t *__cil_tmp___1 ;
  size_t count___0 ;
  mpn_t numerator ;
  mpn_t denominator ;
  void *tmp_memory ;
  mp_limb_t *ptr___0 ;
  size_t i ;
  mpn_t numerator___0 ;
  mp_limb_t *num_ptr ;
  void *__cil_tmp___2 ;
  mp_limb_t *destptr ;
  size_t i___0 ;
  mp_limb_t *__cil_tmp___3 ;
  mp_limb_t const   *sourceptr ;
  mp_twolimb_t accu___0 ;
  size_t count___1 ;
  mp_limb_t const   *__cil_tmp___4 ;
  mp_limb_t *__cil_tmp___5 ;
  mp_limb_t *__cil_tmp___6 ;
  mp_limb_t const   *sourceptr___0 ;
  size_t count___2 ;
  mp_limb_t *__cil_tmp___7 ;
  mp_limb_t const   *__cil_tmp___8 ;

  {
#line 997
  if ((unsigned int )memory == (unsigned int )((void *)0)) {
#line 998
    return ((char *)((void *)0));
  }
#line 1002
  s = e + n;
#line 1003
  extra_zeroes = 0U;
#line 1005
  if (s > 0 && n > 0) {
#line 1007
    extra_zeroes = (unsigned int )(s < n ? s : n);
#line 1008
    s = (int )((unsigned int )s - extra_zeroes);
#line 1009
    n = (int )((unsigned int )n - extra_zeroes);
  }
#line 1016
  abs_n = (unsigned int )(n >= 0 ? n : - n);
#line 1017
  abs_s = (unsigned int )(s >= 0 ? s : - s);
#line 1018
  __cil_tmp = rpl_malloc((((unsigned int )((int )((float )abs_n * (2.322f / (float )32)) + 1) + abs_s / 32U) + 1U) * sizeof(mp_limb_t ));
#line 1018
  pow5_ptr = (mp_limb_t *)__cil_tmp;
#line 1021
  if ((unsigned int )pow5_ptr == (unsigned int )((void *)0)) {
#line 1023
    free(memory);
#line 1024
    return ((char *)((void *)0));
  }
#line 1027
  *(pow5_ptr + 0) = 1U;
#line 1028
  pow5_len = 1U;
#line 1030
  if (abs_n > 0U) {
#line 1038
    n13 = 0U;
#line 1038
    while (n13 <= abs_n) {
#line 1040
      digit1 = (unsigned int )small_pow5[n13 + 13U <= abs_n ? 13U : abs_n - n13];
#line 1042
      carry = 0ULL;
#line 1043
      j = 0U;
#line 1043
      while (j < pow5_len) {
#line 1045
        digit2 = *(pow5_ptr + j);
#line 1046
        carry += (unsigned long long )digit1 * (unsigned long long )digit2;
#line 1047
        *(pow5_ptr + j) = (unsigned int )carry;
#line 1048
        carry >>= 32;
#line 1043
        j ++;
      }
#line 1050
      if (carry > 0ULL) {
#line 1051
        __cil_tmp___0 = pow5_len;
#line 1051
        pow5_len ++;
#line 1051
        *(pow5_ptr + __cil_tmp___0) = (unsigned int )carry;
      }
#line 1038
      n13 += 13U;
    }
  }
#line 1054
  s_limbs = abs_s / 32U;
#line 1055
  s_bits = abs_s % 32U;
#line 1056
  if (n >= 0 ? s >= 0 : s <= 0) {
#line 1059
    if (s_bits > 0U) {
#line 1061
      ptr = pow5_ptr;
#line 1062
      accu = 0ULL;
#line 1064
      count = pow5_len;
#line 1064
      while (count > 0U) {
#line 1066
        accu += (unsigned long long )*ptr << s_bits;
#line 1067
        __cil_tmp___1 = ptr;
#line 1067
        ptr ++;
#line 1067
        *__cil_tmp___1 = (unsigned int )accu;
#line 1068
        accu >>= 32;
#line 1064
        count --;
      }
#line 1070
      if (accu > 0ULL) {
#line 1072
        *ptr = (unsigned int )accu;
#line 1073
        pow5_len ++;
      }
    }
#line 1076
    if (s_limbs > 0U) {
#line 1079
      count___0 = pow5_len;
#line 1079
      while (count___0 > 0U) {
#line 1081
        count___0 --;
#line 1082
        *(pow5_ptr + (s_limbs + count___0)) = *(pow5_ptr + count___0);
      }
#line 1084
      count___0 = s_limbs;
#line 1084
      while (count___0 > 0U) {
#line 1086
        count___0 --;
#line 1087
        *(pow5_ptr + count___0) = 0U;
      }
#line 1089
      pow5_len += s_limbs;
    }
#line 1091
    pow5.limbs = pow5_ptr;
#line 1092
    pow5.nlimbs = pow5_len;
#line 1093
    if (n >= 0) {
#line 1096
      z_memory = multiply(m, pow5, & z);
    } else {
#line 1101
      z_memory = divide(m, pow5, & z);
    }
  } else {
#line 1106
    pow5.limbs = pow5_ptr;
#line 1107
    pow5.nlimbs = pow5_len;
#line 1108
    if (n >= 0) {
#line 1115
      tmp_memory = multiply(m, pow5, & numerator);
#line 1116
      if ((unsigned int )tmp_memory == (unsigned int )((void *)0)) {
#line 1118
        free((void *)pow5_ptr);
#line 1119
        free(memory);
#line 1120
        return ((char *)((void *)0));
      }
#line 1124
      ptr___0 = pow5_ptr + pow5_len;
#line 1126
      i = 0U;
#line 1126
      while (i < s_limbs) {
#line 1127
        *(ptr___0 + i) = 0U;
#line 1126
        i ++;
      }
#line 1128
      *(ptr___0 + s_limbs) = 1U << s_bits;
#line 1129
      denominator.limbs = ptr___0;
#line 1130
      denominator.nlimbs = s_limbs + 1U;
#line 1132
      z_memory = divide(numerator, denominator, & z);
#line 1133
      free(tmp_memory);
    } else {
#line 1141
      __cil_tmp___2 = rpl_malloc(((m.nlimbs + s_limbs) + 1U) * sizeof(mp_limb_t ));
#line 1141
      num_ptr = (mp_limb_t *)__cil_tmp___2;
#line 1143
      if ((unsigned int )num_ptr == (unsigned int )((void *)0)) {
#line 1145
        free((void *)pow5_ptr);
#line 1146
        free(memory);
#line 1147
        return ((char *)((void *)0));
      }
#line 1150
      destptr = num_ptr;
#line 1153
      i___0 = 0U;
#line 1153
      while (i___0 < s_limbs) {
#line 1154
        __cil_tmp___3 = destptr;
#line 1154
        destptr ++;
#line 1154
        *__cil_tmp___3 = 0U;
#line 1153
        i___0 ++;
      }
#line 1156
      if (s_bits > 0U) {
#line 1158
        sourceptr = (mp_limb_t const   *)m.limbs;
#line 1159
        accu___0 = 0ULL;
#line 1161
        count___1 = m.nlimbs;
#line 1161
        while (count___1 > 0U) {
#line 1163
          __cil_tmp___4 = sourceptr;
#line 1163
          sourceptr ++;
#line 1163
          accu___0 += (unsigned long long )*__cil_tmp___4 << s_bits;
#line 1164
          __cil_tmp___5 = destptr;
#line 1164
          destptr ++;
#line 1164
          *__cil_tmp___5 = (unsigned int )accu___0;
#line 1165
          accu___0 >>= 32;
#line 1161
          count___1 --;
        }
#line 1167
        if (accu___0 > 0ULL) {
#line 1168
          __cil_tmp___6 = destptr;
#line 1168
          destptr ++;
#line 1168
          *__cil_tmp___6 = (unsigned int )accu___0;
        }
      } else {
#line 1172
        sourceptr___0 = (mp_limb_t const   *)m.limbs;
#line 1174
        count___2 = m.nlimbs;
#line 1174
        while (count___2 > 0U) {
#line 1175
          __cil_tmp___7 = destptr;
#line 1175
          destptr ++;
#line 1175
          __cil_tmp___8 = sourceptr___0;
#line 1175
          sourceptr___0 ++;
#line 1175
          *__cil_tmp___7 = (unsigned int )*__cil_tmp___8;
#line 1174
          count___2 --;
        }
      }
#line 1177
      numerator___0.limbs = num_ptr;
#line 1178
      numerator___0.nlimbs = (unsigned int )(destptr - num_ptr);
#line 1180
      z_memory = divide(numerator___0, pow5, & z);
#line 1181
      free((void *)num_ptr);
    }
  }
#line 1184
  free((void *)pow5_ptr);
#line 1185
  free(memory);
#line 1189
  if ((unsigned int )z_memory == (unsigned int )((void *)0)) {
#line 1190
    return ((char *)((void *)0));
  }
#line 1191
  digits = convert_to_decimal(z, extra_zeroes);
#line 1192
  free(z_memory);
#line 1193
  return (digits);
}
}
#line 1203 "vasnprintf.c"
static char *scale10_round_decimal_long_double(long double x , int n ) 
{ int e ;
  mpn_t m ;
  void *memory ;
  void *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 1208
  __cil_tmp = decode_long_double(x, & e, & m);
#line 1208
  memory = __cil_tmp;
#line 1209
  __cil_tmp___0 = scale10_round_decimal_decoded(e, m, memory, n);
#line 1209
  return (__cil_tmp___0);
}
}
#line 1221 "vasnprintf.c"
static char *scale10_round_decimal_double(double x , int n ) 
{ int e ;
  mpn_t m ;
  void *memory ;
  void *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 1226
  __cil_tmp = decode_double(x, & e, & m);
#line 1226
  memory = __cil_tmp;
#line 1227
  __cil_tmp___0 = scale10_round_decimal_decoded(e, m, memory, n);
#line 1227
  return (__cil_tmp___0);
}
}
#line 1237 "vasnprintf.c"
static int floorlog10l(long double x ) 
{ int exp___0 ;
  long double y ;
  double z ;
  double l ;

  {
#line 1246
  y = rpl_frexpl(x, & exp___0);
#line 1247
  if (! (y >= 0.0L && y < 1.0L)) {
#line 1248
    abort();
  }
#line 1249
  if (y == 0.0L) {
#line 1250
    return ((-0x7FFFFFFF-1));
  }
#line 1251
  if (y < 0.5L) {
#line 1253
    while (y < (1.0L / (long double )(1 << 16)) / (long double )(1 << 16)) {
#line 1255
      y *= (1.0L * (long double )(1 << 16)) * (long double )(1 << 16);
#line 1256
      exp___0 -= 32;
    }
#line 1258
    if (y < 1.0L / (long double )(1 << 16)) {
#line 1260
      y *= 1.0L * (long double )(1 << 16);
#line 1261
      exp___0 -= 16;
    }
#line 1263
    if (y < 1.0L / (long double )(1 << 8)) {
#line 1265
      y *= 1.0L * (long double )(1 << 8);
#line 1266
      exp___0 -= 8;
    }
#line 1268
    if (y < 1.0L / (long double )(1 << 4)) {
#line 1270
      y *= 1.0L * (long double )(1 << 4);
#line 1271
      exp___0 -= 4;
    }
#line 1273
    if (y < 1.0L / (long double )(1 << 2)) {
#line 1275
      y *= 1.0L * (long double )(1 << 2);
#line 1276
      exp___0 -= 2;
    }
#line 1278
    if (y < 1.0L / (long double )(1 << 1)) {
#line 1280
      y *= 1.0L * (long double )(1 << 1);
#line 1281
      exp___0 --;
    }
  }
#line 1284
  if (! (y >= 0.5L && y < 1.0L)) {
#line 1285
    abort();
  }
#line 1287
  l = (double )exp___0;
#line 1288
  z = (double )y;
#line 1289
  if (z < 0.70710678118654752444) {
#line 1291
    z *= 1.4142135623730950488;
#line 1292
    l -= 0.5;
  }
#line 1294
  if (z < 0.8408964152537145431) {
#line 1296
    z *= 1.1892071150027210667;
#line 1297
    l -= 0.25;
  }
#line 1299
  if (z < 0.91700404320467123175) {
#line 1301
    z *= 1.0905077326652576592;
#line 1302
    l -= 0.125;
  }
#line 1304
  if (z < 0.9576032806985736469) {
#line 1306
    z *= 1.0442737824274138403;
#line 1307
    l -= 0.0625;
  }
#line 1310
  z = (double )1 - z;
#line 1313
  l -= z * (1.0 + z * (0.5 + z * (1.0 / (double )3 + z * 0.25)));
#line 1316
  l *= 0.30102999566398119523;
#line 1318
  return ((int )l + (l < (double )0 ? -1 : 0));
}
}
#line 1328 "vasnprintf.c"
static int floorlog10(double x ) 
{ int exp___0 ;
  double y ;
  double z ;
  double l ;

  {
#line 1337
  y = rpl_frexp(x, & exp___0);
#line 1338
  if (! (y >= 0.0 && y < 1.0)) {
#line 1339
    abort();
  }
#line 1340
  if (y == 0.0) {
#line 1341
    return ((-0x7FFFFFFF-1));
  }
#line 1342
  if (y < 0.5) {
#line 1344
    while (y < (1.0 / (double )(1 << 16)) / (double )(1 << 16)) {
#line 1346
      y *= (1.0 * (double )(1 << 16)) * (double )(1 << 16);
#line 1347
      exp___0 -= 32;
    }
#line 1349
    if (y < 1.0 / (double )(1 << 16)) {
#line 1351
      y *= 1.0 * (double )(1 << 16);
#line 1352
      exp___0 -= 16;
    }
#line 1354
    if (y < 1.0 / (double )(1 << 8)) {
#line 1356
      y *= 1.0 * (double )(1 << 8);
#line 1357
      exp___0 -= 8;
    }
#line 1359
    if (y < 1.0 / (double )(1 << 4)) {
#line 1361
      y *= 1.0 * (double )(1 << 4);
#line 1362
      exp___0 -= 4;
    }
#line 1364
    if (y < 1.0 / (double )(1 << 2)) {
#line 1366
      y *= 1.0 * (double )(1 << 2);
#line 1367
      exp___0 -= 2;
    }
#line 1369
    if (y < 1.0 / (double )(1 << 1)) {
#line 1371
      y *= 1.0 * (double )(1 << 1);
#line 1372
      exp___0 --;
    }
  }
#line 1375
  if (! (y >= 0.5 && y < 1.0)) {
#line 1376
    abort();
  }
#line 1378
  l = (double )exp___0;
#line 1379
  z = y;
#line 1380
  if (z < 0.70710678118654752444) {
#line 1382
    z *= 1.4142135623730950488;
#line 1383
    l -= 0.5;
  }
#line 1385
  if (z < 0.8408964152537145431) {
#line 1387
    z *= 1.1892071150027210667;
#line 1388
    l -= 0.25;
  }
#line 1390
  if (z < 0.91700404320467123175) {
#line 1392
    z *= 1.0905077326652576592;
#line 1393
    l -= 0.125;
  }
#line 1395
  if (z < 0.9576032806985736469) {
#line 1397
    z *= 1.0442737824274138403;
#line 1398
    l -= 0.0625;
  }
#line 1401
  z = (double )1 - z;
#line 1404
  l -= z * (1.0 + z * (0.5 + z * (1.0 / (double )3 + z * 0.25)));
#line 1407
  l *= 0.30102999566398119523;
#line 1409
  return ((int )l + (l < (double )0 ? -1 : 0));
}
}
#line 3249 "vasnprintf.c"
static char const   decimal_format[6]  = {      (char const   )'%',      (char const   )'+',      (char const   )'.',      (char const   )'2', 
        (char const   )'d',      (char const   )'\000'};
#line 3419 "vasnprintf.c"
static char const   decimal_format___0[6]  = {      (char const   )'%',      (char const   )'+',      (char const   )'.',      (char const   )'2', 
        (char const   )'d',      (char const   )'\000'};
#line 1416 "vasnprintf.c"
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) 
{ char_directives d ;
  arguments a ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  size_t buf_neededlength ;
  char *buf___0 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  void *__cil_tmp___2 ;
  size_t buf_memsize ;
  void *__cil_tmp___3 ;
  size_t n ;
  size_t augmented_length ;
  size_t __cil_tmp___4 ;
  size_t memory_size ;
  char *memory ;
  void *__cil_tmp___5 ;
  void *__cil_tmp___6 ;
  size_t __cil_tmp___7 ;
  char const   *__cil_tmp___8 ;
  size_t augmented_length___0 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  void *__cil_tmp___9 ;
  void *__cil_tmp___10 ;
  arg_type type ;
  int flags ;
  int has_width ;
  size_t width ;
  int has_precision ;
  size_t precision ;
  size_t tmp_length ;
  char tmpbuf[700] ;
  char *tmp ;
  char *pad_ptr ;
  char *p ;
  int arg ;
  char const   *digitp ;
  char const   *__cil_tmp___11 ;
  int arg___0 ;
  char const   *digitp___0 ;
  char const   *__cil_tmp___12 ;
  size_t tmp_memsize ;
  void *__cil_tmp___13 ;
  long double arg___1 ;
  char *__cil_tmp___14 ;
  char *__cil_tmp___15 ;
  char *__cil_tmp___16 ;
  char *__cil_tmp___17 ;
  char *__cil_tmp___18 ;
  char *__cil_tmp___19 ;
  int sign ;
  int __cil_tmp___20 ;
  int __cil_tmp___21 ;
  int __cil_tmp___22 ;
  int __cil_tmp___23 ;
  int __cil_tmp___24 ;
  char *__cil_tmp___25 ;
  char *__cil_tmp___26 ;
  char *__cil_tmp___27 ;
  char *__cil_tmp___28 ;
  char *__cil_tmp___29 ;
  char *__cil_tmp___30 ;
  char *__cil_tmp___31 ;
  char *__cil_tmp___32 ;
  char *__cil_tmp___33 ;
  int exponent ;
  long double mantissa ;
  long double tail ;
  size_t q ;
  int digit ;
  char *__cil_tmp___34 ;
  char *__cil_tmp___35 ;
  int digit___0 ;
  char *__cil_tmp___36 ;
  char *__cil_tmp___37 ;
  char *__cil_tmp___38 ;
  char *__cil_tmp___39 ;
  char *__cil_tmp___40 ;
  char expbuf[7] ;
  char const   *ep ;
  char __cil_tmp___41 ;
  int __cil_tmp___42 ;
  double arg___2 ;
  char *__cil_tmp___43 ;
  char *__cil_tmp___44 ;
  char *__cil_tmp___45 ;
  char *__cil_tmp___46 ;
  char *__cil_tmp___47 ;
  char *__cil_tmp___48 ;
  int sign___0 ;
  int __cil_tmp___49 ;
  int __cil_tmp___50 ;
  int __cil_tmp___51 ;
  int __cil_tmp___52 ;
  int __cil_tmp___53 ;
  char *__cil_tmp___54 ;
  char *__cil_tmp___55 ;
  char *__cil_tmp___56 ;
  char *__cil_tmp___57 ;
  char *__cil_tmp___58 ;
  char *__cil_tmp___59 ;
  char *__cil_tmp___60 ;
  char *__cil_tmp___61 ;
  char *__cil_tmp___62 ;
  int exponent___0 ;
  double mantissa___0 ;
  double tail___0 ;
  size_t q___0 ;
  int digit___1 ;
  char *__cil_tmp___63 ;
  char *__cil_tmp___64 ;
  int digit___2 ;
  char *__cil_tmp___65 ;
  char *__cil_tmp___66 ;
  char *__cil_tmp___67 ;
  char *__cil_tmp___68 ;
  char *__cil_tmp___69 ;
  char expbuf___0[7] ;
  char const   *ep___0 ;
  char __cil_tmp___70 ;
  int __cil_tmp___71 ;
  size_t pad ;
  char *end ;
  char *__cil_tmp___72 ;
  char *q___1 ;
  char *__cil_tmp___73 ;
  char *q___2 ;
  char *__cil_tmp___74 ;
  size_t count ;
  size_t n___0 ;
  size_t __cil_tmp___75 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  void *__cil_tmp___76 ;
  void *__cil_tmp___77 ;
  arg_type type___0 ;
  int flags___0 ;
  int has_width___0 ;
  size_t width___0 ;
  int has_precision___0 ;
  size_t precision___0 ;
  size_t tmp_length___0 ;
  char tmpbuf___0[700] ;
  char *tmp___0 ;
  char *pad_ptr___0 ;
  char *p___0 ;
  int arg___3 ;
  char const   *digitp___1 ;
  char const   *__cil_tmp___78 ;
  int arg___4 ;
  char const   *digitp___2 ;
  char const   *__cil_tmp___79 ;
  long double arg___5 ;
  int exponent___1 ;
  int __cil_tmp___80 ;
  int __cil_tmp___81 ;
  double arg___6 ;
  int exponent___2 ;
  int __cil_tmp___82 ;
  int __cil_tmp___83 ;
  size_t tmp_memsize___0 ;
  void *__cil_tmp___84 ;
  long double arg___7 ;
  char *__cil_tmp___85 ;
  char *__cil_tmp___86 ;
  char *__cil_tmp___87 ;
  char *__cil_tmp___88 ;
  char *__cil_tmp___89 ;
  char *__cil_tmp___90 ;
  int sign___1 ;
  int __cil_tmp___91 ;
  int __cil_tmp___92 ;
  int __cil_tmp___93 ;
  int __cil_tmp___94 ;
  int __cil_tmp___95 ;
  char *__cil_tmp___96 ;
  char *__cil_tmp___97 ;
  char *__cil_tmp___98 ;
  char *__cil_tmp___99 ;
  char *__cil_tmp___100 ;
  char *__cil_tmp___101 ;
  char *__cil_tmp___102 ;
  char *__cil_tmp___103 ;
  char *__cil_tmp___104 ;
  char *digits ;
  size_t ndigits ;
  char *__cil_tmp___105 ;
  char *__cil_tmp___106 ;
  char *__cil_tmp___107 ;
  char *__cil_tmp___108 ;
  char *__cil_tmp___109 ;
  int exponent___3 ;
  char *__cil_tmp___110 ;
  char *__cil_tmp___111 ;
  char *__cil_tmp___112 ;
  int adjusted ;
  char *digits___0 ;
  size_t ndigits___0 ;
  char *__cil_tmp___113 ;
  char *__cil_tmp___114 ;
  char *__cil_tmp___115 ;
  char *__cil_tmp___116 ;
  char expbuf___1[7] ;
  char const   *ep___1 ;
  char __cil_tmp___117 ;
  size_t ndigits___1 ;
  size_t nzeroes ;
  char *__cil_tmp___118 ;
  char *__cil_tmp___119 ;
  char *__cil_tmp___120 ;
  int exponent___4 ;
  int adjusted___0 ;
  char *digits___1 ;
  size_t ndigits___2 ;
  size_t nzeroes___0 ;
  size_t count___0 ;
  char *__cil_tmp___121 ;
  char *__cil_tmp___122 ;
  char *__cil_tmp___123 ;
  size_t count___1 ;
  char *__cil_tmp___124 ;
  char *__cil_tmp___125 ;
  char *__cil_tmp___126 ;
  char *__cil_tmp___127 ;
  char *__cil_tmp___128 ;
  char *__cil_tmp___129 ;
  char *__cil_tmp___130 ;
  char *__cil_tmp___131 ;
  char expbuf___2[7] ;
  char const   *ep___2 ;
  char __cil_tmp___132 ;
  int __cil_tmp___133 ;
  double arg___8 ;
  char *__cil_tmp___134 ;
  char *__cil_tmp___135 ;
  char *__cil_tmp___136 ;
  char *__cil_tmp___137 ;
  char *__cil_tmp___138 ;
  char *__cil_tmp___139 ;
  int sign___2 ;
  int __cil_tmp___140 ;
  int __cil_tmp___141 ;
  int __cil_tmp___142 ;
  int __cil_tmp___143 ;
  int __cil_tmp___144 ;
  char *__cil_tmp___145 ;
  char *__cil_tmp___146 ;
  char *__cil_tmp___147 ;
  char *__cil_tmp___148 ;
  char *__cil_tmp___149 ;
  char *__cil_tmp___150 ;
  char *__cil_tmp___151 ;
  char *__cil_tmp___152 ;
  char *__cil_tmp___153 ;
  char *digits___2 ;
  size_t ndigits___3 ;
  char *__cil_tmp___154 ;
  char *__cil_tmp___155 ;
  char *__cil_tmp___156 ;
  char *__cil_tmp___157 ;
  char *__cil_tmp___158 ;
  int exponent___5 ;
  char *__cil_tmp___159 ;
  char *__cil_tmp___160 ;
  char *__cil_tmp___161 ;
  int adjusted___1 ;
  char *digits___3 ;
  size_t ndigits___4 ;
  char *__cil_tmp___162 ;
  char *__cil_tmp___163 ;
  char *__cil_tmp___164 ;
  char *__cil_tmp___165 ;
  char expbuf___3[7] ;
  char const   *ep___3 ;
  char __cil_tmp___166 ;
  size_t ndigits___5 ;
  size_t nzeroes___1 ;
  char *__cil_tmp___167 ;
  char *__cil_tmp___168 ;
  char *__cil_tmp___169 ;
  int exponent___6 ;
  int adjusted___2 ;
  char *digits___4 ;
  size_t ndigits___6 ;
  size_t nzeroes___2 ;
  size_t count___2 ;
  char *__cil_tmp___170 ;
  char *__cil_tmp___171 ;
  char *__cil_tmp___172 ;
  size_t count___3 ;
  char *__cil_tmp___173 ;
  char *__cil_tmp___174 ;
  char *__cil_tmp___175 ;
  char *__cil_tmp___176 ;
  char *__cil_tmp___177 ;
  char *__cil_tmp___178 ;
  char *__cil_tmp___179 ;
  char *__cil_tmp___180 ;
  char expbuf___4[7] ;
  char const   *ep___4 ;
  char __cil_tmp___181 ;
  int __cil_tmp___182 ;
  size_t pad___0 ;
  char *end___0 ;
  char *__cil_tmp___183 ;
  char *q___3 ;
  char *__cil_tmp___184 ;
  char *q___4 ;
  char *__cil_tmp___185 ;
  size_t count___4 ;
  size_t n___1 ;
  size_t __cil_tmp___186 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  void *__cil_tmp___187 ;
  void *__cil_tmp___188 ;
  arg_type type___1 ;
  int flags___1 ;
  int has_width___1 ;
  size_t width___1 ;
  int has_precision___1 ;
  size_t precision___1 ;
  int pad_ourselves ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  size_t tmp_length___1 ;
  char tmpbuf___1[700] ;
  char *tmp___1 ;
  int arg___9 ;
  char const   *digitp___3 ;
  char const   *__cil_tmp___189 ;
  int arg___10 ;
  char const   *digitp___4 ;
  char const   *__cil_tmp___190 ;
  int __cil_tmp___191 ;
  int __cil_tmp___193 ;
  int __cil_tmp___194 ;
  size_t tmp_memsize___1 ;
  void *__cil_tmp___195 ;
  char *__cil_tmp___196 ;
  char *__cil_tmp___197 ;
  char *__cil_tmp___198 ;
  char *__cil_tmp___199 ;
  char *__cil_tmp___200 ;
  char *__cil_tmp___201 ;
  char *__cil_tmp___202 ;
  size_t n___2 ;
  char const   *mp ;
  char *__cil_tmp___203 ;
  char const   *__cil_tmp___204 ;
  size_t n___3 ;
  char const   *mp___0 ;
  char *__cil_tmp___205 ;
  char const   *__cil_tmp___206 ;
  char *__cil_tmp___207 ;
  char *__cil_tmp___208 ;
  char *__cil_tmp___209 ;
  unsigned int __cil_tmp___210 ;
  unsigned int __cil_tmp___211 ;
  int count___5 ;
  int arg___11 ;
  unsigned int arg___12 ;
  int arg___13 ;
  unsigned int arg___14 ;
  int arg___15 ;
  unsigned int arg___16 ;
  long arg___17 ;
  unsigned long arg___18 ;
  long long arg___19 ;
  unsigned long long arg___20 ;
  double arg___21 ;
  long double arg___22 ;
  int arg___23 ;
  wint_t arg___24 ;
  char const   *arg___25 ;
  wchar_t const   *arg___26 ;
  void *arg___27 ;
  int *__cil_tmp___212 ;
  size_t n___4 ;
  size_t __cil_tmp___213 ;
  size_t __cil_tmp___214 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  void *__cil_tmp___215 ;
  void *__cil_tmp___216 ;
  size_t w ;
  size_t pad___1 ;
  char *rp ;
  char *p___1 ;
  char *end___1 ;
  char *pad_ptr___1 ;
  char *__cil_tmp___217 ;
  char *q___5 ;
  char *__cil_tmp___218 ;
  char *q___6 ;
  char *__cil_tmp___219 ;
  char *rp___0 ;
  size_t rc ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t __cil_tmp___220 ;
  void *__cil_tmp___221 ;
  void *__cil_tmp___222 ;
  size_t __cil_tmp___223 ;
  char *memory___5 ;
  void *__cil_tmp___224 ;
  int *__cil_tmp___225 ;
  int *__cil_tmp___226 ;

  {
#line 1423
  __cil_tmp = printf_parse(format, & d, & a);
#line 1423
  if (__cil_tmp < 0) {
#line 1425
    return ((char *)((void *)0));
  }
#line 1432
  __cil_tmp___1 = printf_fetchargs(args, & a);
#line 1432
  if (__cil_tmp___1 < 0) {
#line 1434
    free((void *)d.dir);
#line 1434
    if (a.arg) {
#line 1434
      free((void *)a.arg);
    }
#line 1435
    __cil_tmp___0 = __errno();
#line 1435
    *__cil_tmp___0 = 22;
#line 1436
    return ((char *)((void *)0));
  }
#line 1453
  buf_neededlength = xsum4(7U, d.max_width_length, d.max_precision_length, 6U);
#line 1456
  if (buf_neededlength < 4000U / sizeof(char )) {
#line 1458
    __cil_tmp___2 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1458
    buf___0 = (char *)__cil_tmp___2;
#line 1459
    buf_malloced = (char *)((void *)0);
  } else {
#line 1464
    buf_memsize = buf_neededlength <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? buf_neededlength * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 1465
    if (buf_memsize == ((1U << 31) - 1U) * 2U + 1U) {
#line 1466
      goto out_of_memory_1;
    }
#line 1467
    __cil_tmp___3 = rpl_malloc(buf_memsize);
#line 1467
    buf___0 = (char *)__cil_tmp___3;
#line 1468
    if ((unsigned int )buf___0 == (unsigned int )((void *)0)) {
#line 1469
      goto out_of_memory_1;
    }
#line 1470
    buf_malloced = buf___0;
  }
#line 1473
  if ((unsigned int )resultbuf != (unsigned int )((void *)0)) {
#line 1475
    result = resultbuf;
#line 1476
    allocated = *lengthp;
  } else {
#line 1480
    result = (char *)((void *)0);
#line 1481
    allocated = 0U;
  }
#line 1483
  length = 0U;
#line 1513
  cp = format;
#line 1513
  i = 0U;
#line 1513
  dp = d.dir + 0;
#line 1513
  while (1) {
#line 1515
    if ((unsigned int )cp != (unsigned int )dp->dir_start) {
#line 1517
      n = (unsigned int )(dp->dir_start - cp);
#line 1518
      __cil_tmp___4 = xsum(length, n);
#line 1518
      augmented_length = __cil_tmp___4;
#line 1520
      if (augmented_length > allocated) {
#line 1520
        allocated = allocated > 0U ? (allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? allocated * 2U : ((1U << 31) - 1U) * 2U + 1U) : 12U;
#line 1520
        if (augmented_length > allocated) {
#line 1520
          allocated = augmented_length;
        }
#line 1520
        memory_size = allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? allocated * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 1520
        if (memory_size == ((1U << 31) - 1U) * 2U + 1U) {
#line 1520
          goto out_of_memory;
        }
#line 1520
        if ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0)) {
#line 1520
          __cil_tmp___5 = rpl_malloc(memory_size);
#line 1520
          memory = (char *)__cil_tmp___5;
        } else {
#line 1520
          __cil_tmp___6 = rpl_realloc((void *)result, memory_size);
#line 1520
          memory = (char *)__cil_tmp___6;
        }
#line 1520
        if ((unsigned int )memory == (unsigned int )((void *)0)) {
#line 1520
          goto out_of_memory;
        }
#line 1520
        if ((unsigned int )result == (unsigned int )resultbuf && length > 0U) {
#line 1520
          memcpy((void *)memory, (void const   *)result, length);
        }
#line 1520
        result = memory;
      }
#line 1524
      if (sizeof(char ) == sizeof(char )) {
#line 1526
        memcpy((void *)(result + length), (void const   *)cp, n);
#line 1527
        length = augmented_length;
      } else {
#line 1531
        while (1) {
#line 1532
          __cil_tmp___7 = length;
#line 1532
          length ++;
#line 1532
          __cil_tmp___8 = cp;
#line 1532
          cp ++;
#line 1532
          *(result + __cil_tmp___7) = (char )((unsigned char )*__cil_tmp___8);
#line 1531
          n --;
#line 1531
          if (! (n > 0U)) {
#line 1531
            break;
          }
        }
      }
    }
#line 1536
    if (i == d.count) {
#line 1537
      break;
    }
#line 1540
    if ((int )dp->conversion == 37) {
#line 1544
      if (! (dp->arg_index == 4294967295U)) {
#line 1545
        abort();
      }
#line 1546
      augmented_length___0 = xsum(length, 1U);
#line 1547
      if (augmented_length___0 > allocated) {
#line 1547
        allocated = allocated > 0U ? (allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? allocated * 2U : ((1U << 31) - 1U) * 2U + 1U) : 12U;
#line 1547
        if (augmented_length___0 > allocated) {
#line 1547
          allocated = augmented_length___0;
        }
#line 1547
        memory_size___0 = allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? allocated * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 1547
        if (memory_size___0 == ((1U << 31) - 1U) * 2U + 1U) {
#line 1547
          goto out_of_memory;
        }
#line 1547
        if ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0)) {
#line 1547
          __cil_tmp___9 = rpl_malloc(memory_size___0);
#line 1547
          memory___0 = (char *)__cil_tmp___9;
        } else {
#line 1547
          __cil_tmp___10 = rpl_realloc((void *)result, memory_size___0);
#line 1547
          memory___0 = (char *)__cil_tmp___10;
        }
#line 1547
        if ((unsigned int )memory___0 == (unsigned int )((void *)0)) {
#line 1547
          goto out_of_memory;
        }
#line 1547
        if ((unsigned int )result == (unsigned int )resultbuf && length > 0U) {
#line 1547
          memcpy((void *)memory___0, (void const   *)result, length);
        }
#line 1547
        result = memory___0;
      }
#line 1548
      *(result + length) = (char )'%';
#line 1549
      length = augmented_length___0;
    } else {
#line 1553
      if (! (dp->arg_index != 4294967295U)) {
#line 1554
        abort();
      }
#line 1556
      if ((int )dp->conversion == 110) {
#line 1558
        switch ((int )(a.arg + dp->arg_index)->type) {
        case 18: 
#line 1561
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1562
        break;
        case 19: 
#line 1564
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1565
        break;
        case 20: 
#line 1567
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1568
        break;
        case 21: 
#line 1570
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1571
        break;
        case 22: 
#line 1574
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1575
        break;
        default: 
#line 1578
        abort();
        }
      } else
#line 2046
      if ((int )dp->conversion == 97 || (int )dp->conversion == 65) {
#line 2059
        type = (a.arg + dp->arg_index)->type;
#line 2060
        flags = dp->flags;
#line 2071
        has_width = 0;
#line 2072
        width = 0U;
#line 2073
        if ((unsigned int )dp->width_start != (unsigned int )dp->width_end) {
#line 2075
          if (dp->width_arg_index != 4294967295U) {
#line 2079
            if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
#line 2080
              abort();
            }
#line 2081
            arg = (a.arg + dp->width_arg_index)->a.a_int;
#line 2082
            if (arg < 0) {
#line 2086
              flags |= 2;
#line 2087
              width = (unsigned int )(- arg);
            } else {
#line 2090
              width = (unsigned int )arg;
            }
          } else {
#line 2094
            digitp = dp->width_start;
#line 2096
            while (1) {
#line 2097
              __cil_tmp___11 = digitp;
#line 2097
              digitp ++;
#line 2097
              width = xsum(width <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? width * 10U : ((1U << 31) - 1U) * 2U + 1U,
                           (unsigned int )((int const   )*__cil_tmp___11 - 48));
#line 2096
              if (! ((unsigned int )digitp != (unsigned int )dp->width_end)) {
#line 2096
                break;
              }
            }
          }
#line 2100
          has_width = 1;
        }
#line 2103
        has_precision = 0;
#line 2104
        precision = 0U;
#line 2105
        if ((unsigned int )dp->precision_start != (unsigned int )dp->precision_end) {
#line 2107
          if (dp->precision_arg_index != 4294967295U) {
#line 2111
            if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
#line 2112
              abort();
            }
#line 2113
            arg___0 = (a.arg + dp->precision_arg_index)->a.a_int;
#line 2116
            if (arg___0 >= 0) {
#line 2118
              precision = (unsigned int )arg___0;
#line 2119
              has_precision = 1;
            }
          } else {
#line 2124
            digitp___0 = dp->precision_start + 1;
#line 2126
            precision = 0U;
#line 2127
            while ((unsigned int )digitp___0 != (unsigned int )dp->precision_end) {
#line 2128
              __cil_tmp___12 = digitp___0;
#line 2128
              digitp___0 ++;
#line 2128
              precision = xsum(precision <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? precision * 10U : ((1U << 31) - 1U) * 2U + 1U,
                               (unsigned int )((int const   )*__cil_tmp___12 - 48));
            }
#line 2129
            has_precision = 1;
          }
        }
#line 2134
        if ((unsigned int )type == 12U) {
#line 2135
          tmp_length = (unsigned int )((double )16 * 0.831) + 1U;
        } else {
#line 2141
          tmp_length = (unsigned int )((double )16 * 0.831) + 1U;
        }
#line 2146
        if (tmp_length < precision) {
#line 2147
          tmp_length = precision;
        }
#line 2149
        tmp_length = xsum(tmp_length, 12U);
#line 2151
        if (tmp_length < width) {
#line 2152
          tmp_length = width;
        }
#line 2154
        tmp_length = xsum(tmp_length, 1U);
#line 2156
        if (tmp_length <= sizeof(tmpbuf) / sizeof(char )) {
#line 2157
          tmp = tmpbuf;
        } else {
#line 2160
          tmp_memsize = tmp_length <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? tmp_length * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 2162
          if (tmp_memsize == ((1U << 31) - 1U) * 2U + 1U) {
#line 2164
            goto out_of_memory;
          }
#line 2165
          __cil_tmp___13 = rpl_malloc(tmp_memsize);
#line 2165
          tmp = (char *)__cil_tmp___13;
#line 2166
          if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 2168
            goto out_of_memory;
          }
        }
#line 2171
        pad_ptr = (char *)((void *)0);
#line 2172
        p = tmp;
#line 2173
        if ((unsigned int )type == 12U) {
#line 2176
          arg___1 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 2178
          __cil_tmp___42 = rpl_isnanl(arg___1);
#line 2178
          if (__cil_tmp___42) {
#line 2180
            if ((int )dp->conversion == 65) {
#line 2182
              __cil_tmp___14 = p;
#line 2182
              p ++;
#line 2182
              *__cil_tmp___14 = (char )'N';
#line 2182
              __cil_tmp___15 = p;
#line 2182
              p ++;
#line 2182
              *__cil_tmp___15 = (char )'A';
#line 2182
              __cil_tmp___16 = p;
#line 2182
              p ++;
#line 2182
              *__cil_tmp___16 = (char )'N';
            } else {
#line 2186
              __cil_tmp___17 = p;
#line 2186
              p ++;
#line 2186
              *__cil_tmp___17 = (char )'n';
#line 2186
              __cil_tmp___18 = p;
#line 2186
              p ++;
#line 2186
              *__cil_tmp___18 = (char )'a';
#line 2186
              __cil_tmp___19 = p;
#line 2186
              p ++;
#line 2186
              *__cil_tmp___19 = (char )'n';
            }
          } else {
#line 2191
            sign = 0;
#line 2196
            if (sizeof(arg___1) == sizeof(long double )) {
#line 2196
              __cil_tmp___20 = gl_signbitl(arg___1);
#line 2196
              __cil_tmp___24 = __cil_tmp___20;
            } else {
#line 2196
              if (sizeof(arg___1) == sizeof(double )) {
#line 2196
                __cil_tmp___21 = gl_signbitd((double )arg___1);
#line 2196
                __cil_tmp___23 = __cil_tmp___21;
              } else {
#line 2196
                __cil_tmp___22 = gl_signbitf((float )arg___1);
#line 2196
                __cil_tmp___23 = __cil_tmp___22;
              }
#line 2196
              __cil_tmp___24 = __cil_tmp___23;
            }
#line 2196
            if (__cil_tmp___24) {
#line 2198
              sign = -1;
#line 2199
              arg___1 = - arg___1;
            }
#line 2202
            if (sign < 0) {
#line 2203
              __cil_tmp___25 = p;
#line 2203
              p ++;
#line 2203
              *__cil_tmp___25 = (char )'-';
            } else
#line 2204
            if (flags & 4) {
#line 2205
              __cil_tmp___26 = p;
#line 2205
              p ++;
#line 2205
              *__cil_tmp___26 = (char )'+';
            } else
#line 2206
            if (flags & 8) {
#line 2207
              __cil_tmp___27 = p;
#line 2207
              p ++;
#line 2207
              *__cil_tmp___27 = (char )' ';
            }
#line 2209
            if (arg___1 > 0.0L && arg___1 + arg___1 == arg___1) {
#line 2211
              if ((int )dp->conversion == 65) {
#line 2213
                __cil_tmp___28 = p;
#line 2213
                p ++;
#line 2213
                *__cil_tmp___28 = (char )'I';
#line 2213
                __cil_tmp___29 = p;
#line 2213
                p ++;
#line 2213
                *__cil_tmp___29 = (char )'N';
#line 2213
                __cil_tmp___30 = p;
#line 2213
                p ++;
#line 2213
                *__cil_tmp___30 = (char )'F';
              } else {
#line 2217
                __cil_tmp___31 = p;
#line 2217
                p ++;
#line 2217
                *__cil_tmp___31 = (char )'i';
#line 2217
                __cil_tmp___32 = p;
#line 2217
                p ++;
#line 2217
                *__cil_tmp___32 = (char )'n';
#line 2217
                __cil_tmp___33 = p;
#line 2217
                p ++;
#line 2217
                *__cil_tmp___33 = (char )'f';
              }
            } else {
#line 2225
              if (arg___1 > 0.0L) {
#line 2226
                mantissa = printf_frexpl(arg___1, & exponent);
              } else {
#line 2229
                exponent = 0;
#line 2230
                mantissa = 0.0L;
              }
#line 2233
              if (has_precision && precision < (unsigned int )((double )16 * 0.831) + 1U) {
#line 2237
                tail = mantissa;
#line 2240
                q = precision;
#line 2240
                while (1) {
#line 2242
                  digit = (int )tail;
#line 2243
                  tail -= (long double )digit;
#line 2244
                  if (q == 0U) {
#line 2246
                    if (digit & 1 ? tail >= 0.5L : tail > 0.5L) {
#line 2247
                      tail = (long double )1 - tail;
                    } else {
#line 2249
                      tail = - tail;
                    }
#line 2250
                    break;
                  }
#line 2252
                  tail *= 16.0L;
#line 2240
                  q --;
                }
#line 2254
                if (tail != 0.0L) {
#line 2255
                  q = precision;
#line 2255
                  while (q > 0U) {
#line 2256
                    tail *= 0.0625L;
#line 2255
                    q --;
                  }
                }
#line 2257
                mantissa += tail;
              }
#line 2260
              __cil_tmp___34 = p;
#line 2260
              p ++;
#line 2260
              *__cil_tmp___34 = (char )'0';
#line 2261
              __cil_tmp___35 = p;
#line 2261
              p ++;
#line 2261
              *__cil_tmp___35 = (char )(((int )dp->conversion - 65) + 88);
#line 2262
              pad_ptr = p;
#line 2266
              digit___0 = (int )mantissa;
#line 2267
              mantissa -= (long double )digit___0;
#line 2268
              __cil_tmp___36 = p;
#line 2268
              p ++;
#line 2268
              *__cil_tmp___36 = (char )(48 + digit___0);
#line 2269
              if ((flags & 16 || mantissa > 0.0L) || precision > 0U) {
#line 2272
                __cil_tmp___37 = p;
#line 2272
                p ++;
#line 2272
                *__cil_tmp___37 = decimal_point_char();
#line 2275
                while (mantissa > 0.0L) {
#line 2277
                  mantissa *= 16.0L;
#line 2278
                  digit___0 = (int )mantissa;
#line 2279
                  mantissa -= (long double )digit___0;
#line 2280
                  __cil_tmp___38 = p;
#line 2280
                  p ++;
#line 2280
                  *__cil_tmp___38 = (char )(digit___0 + (digit___0 < 10 ? '0' : (int )dp->conversion - 10));
#line 2284
                  if (precision > 0U) {
#line 2285
                    precision --;
                  }
                }
#line 2287
                while (precision > 0U) {
#line 2289
                  __cil_tmp___39 = p;
#line 2289
                  p ++;
#line 2289
                  *__cil_tmp___39 = (char )'0';
#line 2290
                  precision --;
                }
              }
#line 2294
              __cil_tmp___40 = p;
#line 2294
              p ++;
#line 2294
              *__cil_tmp___40 = (char )(((int )dp->conversion - 65) + 80);
#line 2304
              if (sizeof(char ) == 1U) {
#line 2306
                sprintf(p, "%+d", exponent);
#line 2307
                while ((int )*p != 0) {
#line 2308
                  p ++;
                }
              } else {
#line 2314
                sprintf(expbuf, "%+d", exponent);
#line 2315
                ep = (char const   *)(expbuf);
#line 2315
                while (1) {
#line 2315
                  __cil_tmp___41 = (char )*ep;
#line 2315
                  *p = __cil_tmp___41;
#line 2315
                  if (! ((int )__cil_tmp___41 != 0)) {
#line 2315
                    break;
                  }
#line 2316
                  p ++;
#line 2315
                  ep ++;
                }
              }
            }
          }
        } else {
#line 2330
          arg___2 = (a.arg + dp->arg_index)->a.a_double;
#line 2332
          __cil_tmp___71 = rpl_isnan(arg___2);
#line 2332
          if (__cil_tmp___71) {
#line 2334
            if ((int )dp->conversion == 65) {
#line 2336
              __cil_tmp___43 = p;
#line 2336
              p ++;
#line 2336
              *__cil_tmp___43 = (char )'N';
#line 2336
              __cil_tmp___44 = p;
#line 2336
              p ++;
#line 2336
              *__cil_tmp___44 = (char )'A';
#line 2336
              __cil_tmp___45 = p;
#line 2336
              p ++;
#line 2336
              *__cil_tmp___45 = (char )'N';
            } else {
#line 2340
              __cil_tmp___46 = p;
#line 2340
              p ++;
#line 2340
              *__cil_tmp___46 = (char )'n';
#line 2340
              __cil_tmp___47 = p;
#line 2340
              p ++;
#line 2340
              *__cil_tmp___47 = (char )'a';
#line 2340
              __cil_tmp___48 = p;
#line 2340
              p ++;
#line 2340
              *__cil_tmp___48 = (char )'n';
            }
          } else {
#line 2345
            sign___0 = 0;
#line 2347
            if (sizeof(arg___2) == sizeof(long double )) {
#line 2347
              __cil_tmp___49 = gl_signbitl((long double )arg___2);
#line 2347
              __cil_tmp___53 = __cil_tmp___49;
            } else {
#line 2347
              if (sizeof(arg___2) == sizeof(double )) {
#line 2347
                __cil_tmp___50 = gl_signbitd(arg___2);
#line 2347
                __cil_tmp___52 = __cil_tmp___50;
              } else {
#line 2347
                __cil_tmp___51 = gl_signbitf((float )arg___2);
#line 2347
                __cil_tmp___52 = __cil_tmp___51;
              }
#line 2347
              __cil_tmp___53 = __cil_tmp___52;
            }
#line 2347
            if (__cil_tmp___53) {
#line 2349
              sign___0 = -1;
#line 2350
              arg___2 = - arg___2;
            }
#line 2353
            if (sign___0 < 0) {
#line 2354
              __cil_tmp___54 = p;
#line 2354
              p ++;
#line 2354
              *__cil_tmp___54 = (char )'-';
            } else
#line 2355
            if (flags & 4) {
#line 2356
              __cil_tmp___55 = p;
#line 2356
              p ++;
#line 2356
              *__cil_tmp___55 = (char )'+';
            } else
#line 2357
            if (flags & 8) {
#line 2358
              __cil_tmp___56 = p;
#line 2358
              p ++;
#line 2358
              *__cil_tmp___56 = (char )' ';
            }
#line 2360
            if (arg___2 > 0.0 && arg___2 + arg___2 == arg___2) {
#line 2362
              if ((int )dp->conversion == 65) {
#line 2364
                __cil_tmp___57 = p;
#line 2364
                p ++;
#line 2364
                *__cil_tmp___57 = (char )'I';
#line 2364
                __cil_tmp___58 = p;
#line 2364
                p ++;
#line 2364
                *__cil_tmp___58 = (char )'N';
#line 2364
                __cil_tmp___59 = p;
#line 2364
                p ++;
#line 2364
                *__cil_tmp___59 = (char )'F';
              } else {
#line 2368
                __cil_tmp___60 = p;
#line 2368
                p ++;
#line 2368
                *__cil_tmp___60 = (char )'i';
#line 2368
                __cil_tmp___61 = p;
#line 2368
                p ++;
#line 2368
                *__cil_tmp___61 = (char )'n';
#line 2368
                __cil_tmp___62 = p;
#line 2368
                p ++;
#line 2368
                *__cil_tmp___62 = (char )'f';
              }
            } else {
#line 2376
              if (arg___2 > 0.0) {
#line 2377
                mantissa___0 = printf_frexp(arg___2, & exponent___0);
              } else {
#line 2380
                exponent___0 = 0;
#line 2381
                mantissa___0 = 0.0;
              }
#line 2384
              if (has_precision && precision < (unsigned int )((double )16 * 0.831) + 1U) {
#line 2388
                tail___0 = mantissa___0;
#line 2391
                q___0 = precision;
#line 2391
                while (1) {
#line 2393
                  digit___1 = (int )tail___0;
#line 2394
                  tail___0 -= (double )digit___1;
#line 2395
                  if (q___0 == 0U) {
#line 2397
                    if (digit___1 & 1 ? tail___0 >= 0.5 : tail___0 > 0.5) {
#line 2398
                      tail___0 = (double )1 - tail___0;
                    } else {
#line 2400
                      tail___0 = - tail___0;
                    }
#line 2401
                    break;
                  }
#line 2403
                  tail___0 *= 16.0;
#line 2391
                  q___0 --;
                }
#line 2405
                if (tail___0 != 0.0) {
#line 2406
                  q___0 = precision;
#line 2406
                  while (q___0 > 0U) {
#line 2407
                    tail___0 *= 0.0625;
#line 2406
                    q___0 --;
                  }
                }
#line 2408
                mantissa___0 += tail___0;
              }
#line 2411
              __cil_tmp___63 = p;
#line 2411
              p ++;
#line 2411
              *__cil_tmp___63 = (char )'0';
#line 2412
              __cil_tmp___64 = p;
#line 2412
              p ++;
#line 2412
              *__cil_tmp___64 = (char )(((int )dp->conversion - 65) + 88);
#line 2413
              pad_ptr = p;
#line 2417
              digit___2 = (int )mantissa___0;
#line 2418
              mantissa___0 -= (double )digit___2;
#line 2419
              __cil_tmp___65 = p;
#line 2419
              p ++;
#line 2419
              *__cil_tmp___65 = (char )(48 + digit___2);
#line 2420
              if ((flags & 16 || mantissa___0 > 0.0) || precision > 0U) {
#line 2423
                __cil_tmp___66 = p;
#line 2423
                p ++;
#line 2423
                *__cil_tmp___66 = decimal_point_char();
#line 2426
                while (mantissa___0 > 0.0) {
#line 2428
                  mantissa___0 *= 16.0;
#line 2429
                  digit___2 = (int )mantissa___0;
#line 2430
                  mantissa___0 -= (double )digit___2;
#line 2431
                  __cil_tmp___67 = p;
#line 2431
                  p ++;
#line 2431
                  *__cil_tmp___67 = (char )(digit___2 + (digit___2 < 10 ? '0' : (int )dp->conversion - 10));
#line 2435
                  if (precision > 0U) {
#line 2436
                    precision --;
                  }
                }
#line 2438
                while (precision > 0U) {
#line 2440
                  __cil_tmp___68 = p;
#line 2440
                  p ++;
#line 2440
                  *__cil_tmp___68 = (char )'0';
#line 2441
                  precision --;
                }
              }
#line 2445
              __cil_tmp___69 = p;
#line 2445
              p ++;
#line 2445
              *__cil_tmp___69 = (char )(((int )dp->conversion - 65) + 80);
#line 2455
              if (sizeof(char ) == 1U) {
#line 2457
                sprintf(p, "%+d", exponent___0);
#line 2458
                while ((int )*p != 0) {
#line 2459
                  p ++;
                }
              } else {
#line 2465
                sprintf(expbuf___0, "%+d", exponent___0);
#line 2466
                ep___0 = (char const   *)(expbuf___0);
#line 2466
                while (1) {
#line 2466
                  __cil_tmp___70 = (char )*ep___0;
#line 2466
                  *p = __cil_tmp___70;
#line 2466
                  if (! ((int )__cil_tmp___70 != 0)) {
#line 2466
                    break;
                  }
#line 2467
                  p ++;
#line 2466
                  ep___0 ++;
                }
              }
            }
          }
        }
#line 2478
        if (has_width && (unsigned int )(p - tmp) < width) {
#line 2480
          pad = width - (unsigned int )(p - tmp);
#line 2481
          end = p + pad;
#line 2483
          if (flags & 2) {
#line 2486
            while (pad > 0U) {
#line 2487
              __cil_tmp___72 = p;
#line 2487
              p ++;
#line 2487
              *__cil_tmp___72 = (char )' ';
#line 2486
              pad --;
            }
          } else
#line 2489
          if (flags & 32 && (unsigned int )pad_ptr != (unsigned int )((void *)0)) {
#line 2492
            q___1 = end;
#line 2494
            while ((unsigned int )p > (unsigned int )pad_ptr) {
#line 2495
              q___1 --;
#line 2495
              p --;
#line 2495
              *q___1 = *p;
            }
#line 2496
            while (pad > 0U) {
#line 2497
              __cil_tmp___73 = p;
#line 2497
              p ++;
#line 2497
              *__cil_tmp___73 = (char )'0';
#line 2496
              pad --;
            }
          } else {
#line 2502
            q___2 = end;
#line 2504
            while ((unsigned int )p > (unsigned int )tmp) {
#line 2505
              q___2 --;
#line 2505
              p --;
#line 2505
              *q___2 = *p;
            }
#line 2506
            while (pad > 0U) {
#line 2507
              __cil_tmp___74 = p;
#line 2507
              p ++;
#line 2507
              *__cil_tmp___74 = (char )' ';
#line 2506
              pad --;
            }
          }
#line 2510
          p = end;
        }
#line 2514
        count = (unsigned int )(p - tmp);
#line 2516
        if (count >= tmp_length) {
#line 2519
          abort();
        }
#line 2522
        if (count >= allocated - length) {
#line 2524
          __cil_tmp___75 = xsum(length, count);
#line 2524
          n___0 = __cil_tmp___75;
#line 2526
          if (n___0 > allocated) {
#line 2526
            allocated = allocated > 0U ? (allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? allocated * 2U : ((1U << 31) - 1U) * 2U + 1U) : 12U;
#line 2526
            if (n___0 > allocated) {
#line 2526
              allocated = n___0;
            }
#line 2526
            memory_size___1 = allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? allocated * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 2526
            if (memory_size___1 == ((1U << 31) - 1U) * 2U + 1U) {
#line 2526
              goto out_of_memory;
            }
#line 2526
            if ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0)) {
#line 2526
              __cil_tmp___76 = rpl_malloc(memory_size___1);
#line 2526
              memory___1 = (char *)__cil_tmp___76;
            } else {
#line 2526
              __cil_tmp___77 = rpl_realloc((void *)result, memory_size___1);
#line 2526
              memory___1 = (char *)__cil_tmp___77;
            }
#line 2526
            if ((unsigned int )memory___1 == (unsigned int )((void *)0)) {
#line 2526
              goto out_of_memory;
            }
#line 2526
            if ((unsigned int )result == (unsigned int )resultbuf && length > 0U) {
#line 2526
              memcpy((void *)memory___1, (void const   *)result, length);
            }
#line 2526
            result = memory___1;
          }
        }
#line 2530
        memcpy((void *)(result + length), (void const   *)tmp, count * sizeof(char ));
#line 2531
        if ((unsigned int )tmp != (unsigned int )(tmpbuf)) {
#line 2532
          free((void *)tmp);
        }
#line 2533
        length += count;
      } else
#line 2538
      if (((((((((int )dp->conversion == 102 || (int )dp->conversion == 70) || (int )dp->conversion == 101) || (int )dp->conversion == 69) || (int )dp->conversion == 103) || (int )dp->conversion == 71) || (int )dp->conversion == 97) || (int )dp->conversion == 65) && ((unsigned int )(a.arg + dp->arg_index)->type == 11U || (unsigned int )(a.arg + dp->arg_index)->type == 12U)) {
#line 2563
        type___0 = (a.arg + dp->arg_index)->type;
#line 2565
        flags___0 = dp->flags;
#line 2576
        has_width___0 = 0;
#line 2577
        width___0 = 0U;
#line 2578
        if ((unsigned int )dp->width_start != (unsigned int )dp->width_end) {
#line 2580
          if (dp->width_arg_index != 4294967295U) {
#line 2584
            if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
#line 2585
              abort();
            }
#line 2586
            arg___3 = (a.arg + dp->width_arg_index)->a.a_int;
#line 2587
            if (arg___3 < 0) {
#line 2591
              flags___0 |= 2;
#line 2592
              width___0 = (unsigned int )(- arg___3);
            } else {
#line 2595
              width___0 = (unsigned int )arg___3;
            }
          } else {
#line 2599
            digitp___1 = dp->width_start;
#line 2601
            while (1) {
#line 2602
              __cil_tmp___78 = digitp___1;
#line 2602
              digitp___1 ++;
#line 2602
              width___0 = xsum(width___0 <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? width___0 * 10U : ((1U << 31) - 1U) * 2U + 1U,
                               (unsigned int )((int const   )*__cil_tmp___78 - 48));
#line 2601
              if (! ((unsigned int )digitp___1 != (unsigned int )dp->width_end)) {
#line 2601
                break;
              }
            }
          }
#line 2605
          has_width___0 = 1;
        }
#line 2608
        has_precision___0 = 0;
#line 2609
        precision___0 = 0U;
#line 2610
        if ((unsigned int )dp->precision_start != (unsigned int )dp->precision_end) {
#line 2612
          if (dp->precision_arg_index != 4294967295U) {
#line 2616
            if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
#line 2617
              abort();
            }
#line 2618
            arg___4 = (a.arg + dp->precision_arg_index)->a.a_int;
#line 2621
            if (arg___4 >= 0) {
#line 2623
              precision___0 = (unsigned int )arg___4;
#line 2624
              has_precision___0 = 1;
            }
          } else {
#line 2629
            digitp___2 = dp->precision_start + 1;
#line 2631
            precision___0 = 0U;
#line 2632
            while ((unsigned int )digitp___2 != (unsigned int )dp->precision_end) {
#line 2633
              __cil_tmp___79 = digitp___2;
#line 2633
              digitp___2 ++;
#line 2633
              precision___0 = xsum(precision___0 <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? precision___0 * 10U : ((1U << 31) - 1U) * 2U + 1U,
                                   (unsigned int )((int const   )*__cil_tmp___79 - 48));
            }
#line 2634
            has_precision___0 = 1;
          }
        }
#line 2641
        if (! has_precision___0) {
#line 2642
          precision___0 = 6U;
        }
#line 2646
        tmp_length___0 = (unsigned int )((unsigned int )type___0 == 12U ? 16 : 16);
#line 2656
        if (tmp_length___0 < precision___0) {
#line 2657
          tmp_length___0 = precision___0;
        }
#line 2660
        if ((unsigned int )type___0 == 12U) {
#line 2662
          if ((int )dp->conversion == 102 || (int )dp->conversion == 70) {
#line 2664
            arg___5 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 2665
            __cil_tmp___81 = rpl_isnanl(arg___5);
#line 2665
            if (! (__cil_tmp___81 || arg___5 + arg___5 == arg___5)) {
#line 2668
              __cil_tmp___80 = floorlog10l(arg___5 < (long double )0 ? - arg___5 : arg___5);
#line 2668
              exponent___1 = __cil_tmp___80;
#line 2669
              if (exponent___1 >= 0 && tmp_length___0 < (unsigned int )exponent___1 + precision___0) {
#line 2670
                tmp_length___0 = (unsigned int )exponent___1 + precision___0;
              }
            }
          }
        }
#line 2676
        if ((unsigned int )type___0 == 11U) {
#line 2678
          if ((int )dp->conversion == 102 || (int )dp->conversion == 70) {
#line 2680
            arg___6 = (a.arg + dp->arg_index)->a.a_double;
#line 2681
            __cil_tmp___83 = rpl_isnan(arg___6);
#line 2681
            if (! (__cil_tmp___83 || arg___6 + arg___6 == arg___6)) {
#line 2684
              __cil_tmp___82 = floorlog10(arg___6 < (double )0 ? - arg___6 : arg___6);
#line 2684
              exponent___2 = __cil_tmp___82;
#line 2685
              if (exponent___2 >= 0 && tmp_length___0 < (unsigned int )exponent___2 + precision___0) {
#line 2686
                tmp_length___0 = (unsigned int )exponent___2 + precision___0;
              }
            }
          }
        }
#line 2691
        tmp_length___0 = xsum(tmp_length___0, 12U);
#line 2693
        if (tmp_length___0 < width___0) {
#line 2694
          tmp_length___0 = width___0;
        }
#line 2696
        tmp_length___0 = xsum(tmp_length___0, 1U);
#line 2698
        if (tmp_length___0 <= sizeof(tmpbuf___0) / sizeof(char )) {
#line 2699
          tmp___0 = tmpbuf___0;
        } else {
#line 2702
          tmp_memsize___0 = tmp_length___0 <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? tmp_length___0 * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 2704
          if (tmp_memsize___0 == ((1U << 31) - 1U) * 2U + 1U) {
#line 2706
            goto out_of_memory;
          }
#line 2707
          __cil_tmp___84 = rpl_malloc(tmp_memsize___0);
#line 2707
          tmp___0 = (char *)__cil_tmp___84;
#line 2708
          if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 2710
            goto out_of_memory;
          }
        }
#line 2713
        pad_ptr___0 = (char *)((void *)0);
#line 2714
        p___0 = tmp___0;
#line 2718
        if ((unsigned int )type___0 == 12U) {
#line 2721
          arg___7 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 2723
          __cil_tmp___133 = rpl_isnanl(arg___7);
#line 2723
          if (__cil_tmp___133) {
#line 2725
            if ((int )dp->conversion >= 65 && (int )dp->conversion <= 90) {
#line 2727
              __cil_tmp___85 = p___0;
#line 2727
              p___0 ++;
#line 2727
              *__cil_tmp___85 = (char )'N';
#line 2727
              __cil_tmp___86 = p___0;
#line 2727
              p___0 ++;
#line 2727
              *__cil_tmp___86 = (char )'A';
#line 2727
              __cil_tmp___87 = p___0;
#line 2727
              p___0 ++;
#line 2727
              *__cil_tmp___87 = (char )'N';
            } else {
#line 2731
              __cil_tmp___88 = p___0;
#line 2731
              p___0 ++;
#line 2731
              *__cil_tmp___88 = (char )'n';
#line 2731
              __cil_tmp___89 = p___0;
#line 2731
              p___0 ++;
#line 2731
              *__cil_tmp___89 = (char )'a';
#line 2731
              __cil_tmp___90 = p___0;
#line 2731
              p___0 ++;
#line 2731
              *__cil_tmp___90 = (char )'n';
            }
          } else {
#line 2736
            sign___1 = 0;
#line 2741
            if (sizeof(arg___7) == sizeof(long double )) {
#line 2741
              __cil_tmp___91 = gl_signbitl(arg___7);
#line 2741
              __cil_tmp___95 = __cil_tmp___91;
            } else {
#line 2741
              if (sizeof(arg___7) == sizeof(double )) {
#line 2741
                __cil_tmp___92 = gl_signbitd((double )arg___7);
#line 2741
                __cil_tmp___94 = __cil_tmp___92;
              } else {
#line 2741
                __cil_tmp___93 = gl_signbitf((float )arg___7);
#line 2741
                __cil_tmp___94 = __cil_tmp___93;
              }
#line 2741
              __cil_tmp___95 = __cil_tmp___94;
            }
#line 2741
            if (__cil_tmp___95) {
#line 2743
              sign___1 = -1;
#line 2744
              arg___7 = - arg___7;
            }
#line 2747
            if (sign___1 < 0) {
#line 2748
              __cil_tmp___96 = p___0;
#line 2748
              p___0 ++;
#line 2748
              *__cil_tmp___96 = (char )'-';
            } else
#line 2749
            if (flags___0 & 4) {
#line 2750
              __cil_tmp___97 = p___0;
#line 2750
              p___0 ++;
#line 2750
              *__cil_tmp___97 = (char )'+';
            } else
#line 2751
            if (flags___0 & 8) {
#line 2752
              __cil_tmp___98 = p___0;
#line 2752
              p___0 ++;
#line 2752
              *__cil_tmp___98 = (char )' ';
            }
#line 2754
            if (arg___7 > 0.0L && arg___7 + arg___7 == arg___7) {
#line 2756
              if ((int )dp->conversion >= 65 && (int )dp->conversion <= 90) {
#line 2758
                __cil_tmp___99 = p___0;
#line 2758
                p___0 ++;
#line 2758
                *__cil_tmp___99 = (char )'I';
#line 2758
                __cil_tmp___100 = p___0;
#line 2758
                p___0 ++;
#line 2758
                *__cil_tmp___100 = (char )'N';
#line 2758
                __cil_tmp___101 = p___0;
#line 2758
                p___0 ++;
#line 2758
                *__cil_tmp___101 = (char )'F';
              } else {
#line 2762
                __cil_tmp___102 = p___0;
#line 2762
                p___0 ++;
#line 2762
                *__cil_tmp___102 = (char )'i';
#line 2762
                __cil_tmp___103 = p___0;
#line 2762
                p___0 ++;
#line 2762
                *__cil_tmp___103 = (char )'n';
#line 2762
                __cil_tmp___104 = p___0;
#line 2762
                p___0 ++;
#line 2762
                *__cil_tmp___104 = (char )'f';
              }
            } else {
#line 2768
              pad_ptr___0 = p___0;
#line 2770
              if ((int )dp->conversion == 102 || (int )dp->conversion == 70) {
#line 2775
                digits = scale10_round_decimal_long_double(arg___7, (int )precision___0);
#line 2777
                if ((unsigned int )digits == (unsigned int )((void *)0)) {
#line 2780
                  goto out_of_memory;
                }
#line 2782
                ndigits = strlen((char const   *)digits);
#line 2784
                if (ndigits > precision___0) {
#line 2785
                  while (1) {
#line 2787
                    ndigits --;
#line 2788
                    __cil_tmp___105 = p___0;
#line 2788
                    p___0 ++;
#line 2788
                    *__cil_tmp___105 = *(digits + ndigits);
#line 2785
                    if (! (ndigits > precision___0)) {
#line 2785
                      break;
                    }
                  }
                } else {
#line 2792
                  __cil_tmp___106 = p___0;
#line 2792
                  p___0 ++;
#line 2792
                  *__cil_tmp___106 = (char )'0';
                }
#line 2794
                if (flags___0 & 16 || precision___0 > 0U) {
#line 2796
                  __cil_tmp___107 = p___0;
#line 2796
                  p___0 ++;
#line 2796
                  *__cil_tmp___107 = decimal_point_char();
#line 2797
                  while (precision___0 > ndigits) {
#line 2798
                    __cil_tmp___108 = p___0;
#line 2798
                    p___0 ++;
#line 2798
                    *__cil_tmp___108 = (char )'0';
#line 2797
                    precision___0 --;
                  }
#line 2799
                  while (ndigits > 0U) {
#line 2801
                    ndigits --;
#line 2802
                    __cil_tmp___109 = p___0;
#line 2802
                    p___0 ++;
#line 2802
                    *__cil_tmp___109 = *(digits + ndigits);
                  }
                }
#line 2806
                free((void *)digits);
              } else
#line 2808
              if ((int )dp->conversion == 101 || (int )dp->conversion == 69) {
#line 2812
                if (arg___7 == 0.0L) {
#line 2814
                  exponent___3 = 0;
#line 2815
                  __cil_tmp___110 = p___0;
#line 2815
                  p___0 ++;
#line 2815
                  *__cil_tmp___110 = (char )'0';
#line 2816
                  if (flags___0 & 16 || precision___0 > 0U) {
#line 2818
                    __cil_tmp___111 = p___0;
#line 2818
                    p___0 ++;
#line 2818
                    *__cil_tmp___111 = decimal_point_char();
#line 2819
                    while (precision___0 > 0U) {
#line 2820
                      __cil_tmp___112 = p___0;
#line 2820
                      p___0 ++;
#line 2820
                      *__cil_tmp___112 = (char )'0';
#line 2819
                      precision___0 --;
                    }
                  }
                } else {
#line 2830
                  exponent___3 = floorlog10l(arg___7);
#line 2831
                  adjusted = 0;
#line 2832
                  while (1) {
#line 2834
                    digits___0 = scale10_round_decimal_long_double(arg___7, (int )precision___0 - exponent___3);
#line 2837
                    if ((unsigned int )digits___0 == (unsigned int )((void *)0)) {
#line 2840
                      goto out_of_memory;
                    }
#line 2842
                    ndigits___0 = strlen((char const   *)digits___0);
#line 2844
                    if (ndigits___0 == precision___0 + 1U) {
#line 2845
                      break;
                    }
#line 2846
                    if (ndigits___0 < precision___0 || ndigits___0 > precision___0 + 2U) {
#line 2850
                      abort();
                    }
#line 2851
                    if (adjusted) {
#line 2855
                      abort();
                    }
#line 2856
                    free((void *)digits___0);
#line 2857
                    if (ndigits___0 == precision___0) {
#line 2858
                      exponent___3 --;
                    } else {
#line 2860
                      exponent___3 ++;
                    }
#line 2861
                    adjusted = 1;
                  }
#line 2865
                  __cil_tmp___113 = p___0;
#line 2865
                  p___0 ++;
#line 2865
                  ndigits___0 --;
#line 2865
                  *__cil_tmp___113 = *(digits___0 + ndigits___0);
#line 2866
                  if (flags___0 & 16 || precision___0 > 0U) {
#line 2868
                    __cil_tmp___114 = p___0;
#line 2868
                    p___0 ++;
#line 2868
                    *__cil_tmp___114 = decimal_point_char();
#line 2869
                    while (ndigits___0 > 0U) {
#line 2871
                      ndigits___0 --;
#line 2872
                      __cil_tmp___115 = p___0;
#line 2872
                      p___0 ++;
#line 2872
                      *__cil_tmp___115 = *(digits___0 + ndigits___0);
                    }
                  }
#line 2876
                  free((void *)digits___0);
                }
#line 2879
                __cil_tmp___116 = p___0;
#line 2879
                p___0 ++;
#line 2879
                *__cil_tmp___116 = dp->conversion;
#line 2889
                if (sizeof(char ) == 1U) {
#line 2891
                  sprintf(p___0, "%+.2d", exponent___3);
#line 2892
                  while ((int )*p___0 != 0) {
#line 2893
                    p___0 ++;
                  }
                } else {
#line 2899
                  sprintf(expbuf___1, "%+.2d", exponent___3);
#line 2900
                  ep___1 = (char const   *)(expbuf___1);
#line 2900
                  while (1) {
#line 2900
                    __cil_tmp___117 = (char )*ep___1;
#line 2900
                    *p___0 = __cil_tmp___117;
#line 2900
                    if (! ((int )__cil_tmp___117 != 0)) {
#line 2900
                      break;
                    }
#line 2901
                    p___0 ++;
#line 2900
                    ep___1 ++;
                  }
                }
              } else
#line 2905
              if ((int )dp->conversion == 103 || (int )dp->conversion == 71) {
#line 2907
                if (precision___0 == 0U) {
#line 2908
                  precision___0 = 1U;
                }
#line 2911
                if (arg___7 == 0.0L) {
#line 2915
                  ndigits___1 = precision___0;
#line 2918
                  nzeroes = flags___0 & 16 ? 0U : precision___0 - 1U;
#line 2921
                  ndigits___1 --;
#line 2922
                  __cil_tmp___118 = p___0;
#line 2922
                  p___0 ++;
#line 2922
                  *__cil_tmp___118 = (char )'0';
#line 2923
                  if (flags___0 & 16 || ndigits___1 > nzeroes) {
#line 2925
                    __cil_tmp___119 = p___0;
#line 2925
                    p___0 ++;
#line 2925
                    *__cil_tmp___119 = decimal_point_char();
#line 2926
                    while (ndigits___1 > nzeroes) {
#line 2928
                      ndigits___1 --;
#line 2929
                      __cil_tmp___120 = p___0;
#line 2929
                      p___0 ++;
#line 2929
                      *__cil_tmp___120 = (char )'0';
                    }
                  }
                } else {
#line 2942
                  exponent___4 = floorlog10l(arg___7);
#line 2943
                  adjusted___0 = 0;
#line 2944
                  while (1) {
#line 2946
                    digits___1 = scale10_round_decimal_long_double(arg___7, (int )(precision___0 - 1U) - exponent___4);
#line 2949
                    if ((unsigned int )digits___1 == (unsigned int )((void *)0)) {
#line 2952
                      goto out_of_memory;
                    }
#line 2954
                    ndigits___2 = strlen((char const   *)digits___1);
#line 2956
                    if (ndigits___2 == precision___0) {
#line 2957
                      break;
                    }
#line 2958
                    if (ndigits___2 < precision___0 - 1U || ndigits___2 > precision___0 + 1U) {
#line 2962
                      abort();
                    }
#line 2963
                    if (adjusted___0) {
#line 2967
                      abort();
                    }
#line 2968
                    free((void *)digits___1);
#line 2969
                    if (ndigits___2 < precision___0) {
#line 2970
                      exponent___4 --;
                    } else {
#line 2972
                      exponent___4 ++;
                    }
#line 2973
                    adjusted___0 = 1;
                  }
#line 2979
                  nzeroes___0 = 0U;
#line 2980
                  if ((flags___0 & 16) == 0) {
#line 2981
                    while (nzeroes___0 < ndigits___2 && (int )*(digits___1 + nzeroes___0) == 48) {
#line 2983
                      nzeroes___0 ++;
                    }
                  }
#line 2986
                  if (exponent___4 >= -4 && (long )exponent___4 < (long )precision___0) {
#line 2993
                    if (exponent___4 >= 0) {
#line 2995
                      count___0 = (unsigned int )(exponent___4 + 1);
#line 2997
                      while (count___0 > 0U) {
#line 2998
                        __cil_tmp___121 = p___0;
#line 2998
                        p___0 ++;
#line 2998
                        ndigits___2 --;
#line 2998
                        *__cil_tmp___121 = *(digits___1 + ndigits___2);
#line 2997
                        count___0 --;
                      }
#line 2999
                      if (flags___0 & 16 || ndigits___2 > nzeroes___0) {
#line 3001
                        __cil_tmp___122 = p___0;
#line 3001
                        p___0 ++;
#line 3001
                        *__cil_tmp___122 = decimal_point_char();
#line 3002
                        while (ndigits___2 > nzeroes___0) {
#line 3004
                          ndigits___2 --;
#line 3005
                          __cil_tmp___123 = p___0;
#line 3005
                          p___0 ++;
#line 3005
                          *__cil_tmp___123 = *(digits___1 + ndigits___2);
                        }
                      }
                    } else {
#line 3011
                      count___1 = (unsigned int )(- exponent___4 - 1);
#line 3012
                      __cil_tmp___124 = p___0;
#line 3012
                      p___0 ++;
#line 3012
                      *__cil_tmp___124 = (char )'0';
#line 3013
                      __cil_tmp___125 = p___0;
#line 3013
                      p___0 ++;
#line 3013
                      *__cil_tmp___125 = decimal_point_char();
#line 3014
                      while (count___1 > 0U) {
#line 3015
                        __cil_tmp___126 = p___0;
#line 3015
                        p___0 ++;
#line 3015
                        *__cil_tmp___126 = (char )'0';
#line 3014
                        count___1 --;
                      }
#line 3016
                      while (ndigits___2 > nzeroes___0) {
#line 3018
                        ndigits___2 --;
#line 3019
                        __cil_tmp___127 = p___0;
#line 3019
                        p___0 ++;
#line 3019
                        *__cil_tmp___127 = *(digits___1 + ndigits___2);
                      }
                    }
                  } else {
#line 3026
                    __cil_tmp___128 = p___0;
#line 3026
                    p___0 ++;
#line 3026
                    ndigits___2 --;
#line 3026
                    *__cil_tmp___128 = *(digits___1 + ndigits___2);
#line 3027
                    if (flags___0 & 16 || ndigits___2 > nzeroes___0) {
#line 3029
                      __cil_tmp___129 = p___0;
#line 3029
                      p___0 ++;
#line 3029
                      *__cil_tmp___129 = decimal_point_char();
#line 3030
                      while (ndigits___2 > nzeroes___0) {
#line 3032
                        ndigits___2 --;
#line 3033
                        __cil_tmp___130 = p___0;
#line 3033
                        p___0 ++;
#line 3033
                        *__cil_tmp___130 = *(digits___1 + ndigits___2);
                      }
                    }
#line 3036
                    __cil_tmp___131 = p___0;
#line 3036
                    p___0 ++;
#line 3036
                    *__cil_tmp___131 = (char )(((int )dp->conversion - 71) + 69);
#line 3046
                    if (sizeof(char ) == 1U) {
#line 3048
                      sprintf(p___0, "%+.2d", exponent___4);
#line 3049
                      while ((int )*p___0 != 0) {
#line 3050
                        p___0 ++;
                      }
                    } else {
#line 3056
                      sprintf(expbuf___2, "%+.2d", exponent___4);
#line 3057
                      ep___2 = (char const   *)(expbuf___2);
#line 3057
                      while (1) {
#line 3057
                        __cil_tmp___132 = (char )*ep___2;
#line 3057
                        *p___0 = __cil_tmp___132;
#line 3057
                        if (! ((int )__cil_tmp___132 != 0)) {
#line 3057
                          break;
                        }
#line 3058
                        p___0 ++;
#line 3057
                        ep___2 ++;
                      }
                    }
                  }
#line 3063
                  free((void *)digits___1);
                }
              } else {
#line 3067
                abort();
              }
            }
          }
        } else {
#line 3083
          arg___8 = (a.arg + dp->arg_index)->a.a_double;
#line 3085
          __cil_tmp___182 = rpl_isnan(arg___8);
#line 3085
          if (__cil_tmp___182) {
#line 3087
            if ((int )dp->conversion >= 65 && (int )dp->conversion <= 90) {
#line 3089
              __cil_tmp___134 = p___0;
#line 3089
              p___0 ++;
#line 3089
              *__cil_tmp___134 = (char )'N';
#line 3089
              __cil_tmp___135 = p___0;
#line 3089
              p___0 ++;
#line 3089
              *__cil_tmp___135 = (char )'A';
#line 3089
              __cil_tmp___136 = p___0;
#line 3089
              p___0 ++;
#line 3089
              *__cil_tmp___136 = (char )'N';
            } else {
#line 3093
              __cil_tmp___137 = p___0;
#line 3093
              p___0 ++;
#line 3093
              *__cil_tmp___137 = (char )'n';
#line 3093
              __cil_tmp___138 = p___0;
#line 3093
              p___0 ++;
#line 3093
              *__cil_tmp___138 = (char )'a';
#line 3093
              __cil_tmp___139 = p___0;
#line 3093
              p___0 ++;
#line 3093
              *__cil_tmp___139 = (char )'n';
            }
          } else {
#line 3098
            sign___2 = 0;
#line 3100
            if (sizeof(arg___8) == sizeof(long double )) {
#line 3100
              __cil_tmp___140 = gl_signbitl((long double )arg___8);
#line 3100
              __cil_tmp___144 = __cil_tmp___140;
            } else {
#line 3100
              if (sizeof(arg___8) == sizeof(double )) {
#line 3100
                __cil_tmp___141 = gl_signbitd(arg___8);
#line 3100
                __cil_tmp___143 = __cil_tmp___141;
              } else {
#line 3100
                __cil_tmp___142 = gl_signbitf((float )arg___8);
#line 3100
                __cil_tmp___143 = __cil_tmp___142;
              }
#line 3100
              __cil_tmp___144 = __cil_tmp___143;
            }
#line 3100
            if (__cil_tmp___144) {
#line 3102
              sign___2 = -1;
#line 3103
              arg___8 = - arg___8;
            }
#line 3106
            if (sign___2 < 0) {
#line 3107
              __cil_tmp___145 = p___0;
#line 3107
              p___0 ++;
#line 3107
              *__cil_tmp___145 = (char )'-';
            } else
#line 3108
            if (flags___0 & 4) {
#line 3109
              __cil_tmp___146 = p___0;
#line 3109
              p___0 ++;
#line 3109
              *__cil_tmp___146 = (char )'+';
            } else
#line 3110
            if (flags___0 & 8) {
#line 3111
              __cil_tmp___147 = p___0;
#line 3111
              p___0 ++;
#line 3111
              *__cil_tmp___147 = (char )' ';
            }
#line 3113
            if (arg___8 > 0.0 && arg___8 + arg___8 == arg___8) {
#line 3115
              if ((int )dp->conversion >= 65 && (int )dp->conversion <= 90) {
#line 3117
                __cil_tmp___148 = p___0;
#line 3117
                p___0 ++;
#line 3117
                *__cil_tmp___148 = (char )'I';
#line 3117
                __cil_tmp___149 = p___0;
#line 3117
                p___0 ++;
#line 3117
                *__cil_tmp___149 = (char )'N';
#line 3117
                __cil_tmp___150 = p___0;
#line 3117
                p___0 ++;
#line 3117
                *__cil_tmp___150 = (char )'F';
              } else {
#line 3121
                __cil_tmp___151 = p___0;
#line 3121
                p___0 ++;
#line 3121
                *__cil_tmp___151 = (char )'i';
#line 3121
                __cil_tmp___152 = p___0;
#line 3121
                p___0 ++;
#line 3121
                *__cil_tmp___152 = (char )'n';
#line 3121
                __cil_tmp___153 = p___0;
#line 3121
                p___0 ++;
#line 3121
                *__cil_tmp___153 = (char )'f';
              }
            } else {
#line 3127
              pad_ptr___0 = p___0;
#line 3129
              if ((int )dp->conversion == 102 || (int )dp->conversion == 70) {
#line 3134
                digits___2 = scale10_round_decimal_double(arg___8, (int )precision___0);
#line 3136
                if ((unsigned int )digits___2 == (unsigned int )((void *)0)) {
#line 3137
                  goto out_of_memory;
                }
#line 3138
                ndigits___3 = strlen((char const   *)digits___2);
#line 3140
                if (ndigits___3 > precision___0) {
#line 3141
                  while (1) {
#line 3143
                    ndigits___3 --;
#line 3144
                    __cil_tmp___154 = p___0;
#line 3144
                    p___0 ++;
#line 3144
                    *__cil_tmp___154 = *(digits___2 + ndigits___3);
#line 3141
                    if (! (ndigits___3 > precision___0)) {
#line 3141
                      break;
                    }
                  }
                } else {
#line 3148
                  __cil_tmp___155 = p___0;
#line 3148
                  p___0 ++;
#line 3148
                  *__cil_tmp___155 = (char )'0';
                }
#line 3150
                if (flags___0 & 16 || precision___0 > 0U) {
#line 3152
                  __cil_tmp___156 = p___0;
#line 3152
                  p___0 ++;
#line 3152
                  *__cil_tmp___156 = decimal_point_char();
#line 3153
                  while (precision___0 > ndigits___3) {
#line 3154
                    __cil_tmp___157 = p___0;
#line 3154
                    p___0 ++;
#line 3154
                    *__cil_tmp___157 = (char )'0';
#line 3153
                    precision___0 --;
                  }
#line 3155
                  while (ndigits___3 > 0U) {
#line 3157
                    ndigits___3 --;
#line 3158
                    __cil_tmp___158 = p___0;
#line 3158
                    p___0 ++;
#line 3158
                    *__cil_tmp___158 = *(digits___2 + ndigits___3);
                  }
                }
#line 3162
                free((void *)digits___2);
              } else
#line 3164
              if ((int )dp->conversion == 101 || (int )dp->conversion == 69) {
#line 3168
                if (arg___8 == 0.0) {
#line 3170
                  exponent___5 = 0;
#line 3171
                  __cil_tmp___159 = p___0;
#line 3171
                  p___0 ++;
#line 3171
                  *__cil_tmp___159 = (char )'0';
#line 3172
                  if (flags___0 & 16 || precision___0 > 0U) {
#line 3174
                    __cil_tmp___160 = p___0;
#line 3174
                    p___0 ++;
#line 3174
                    *__cil_tmp___160 = decimal_point_char();
#line 3175
                    while (precision___0 > 0U) {
#line 3176
                      __cil_tmp___161 = p___0;
#line 3176
                      p___0 ++;
#line 3176
                      *__cil_tmp___161 = (char )'0';
#line 3175
                      precision___0 --;
                    }
                  }
                } else {
#line 3186
                  exponent___5 = floorlog10(arg___8);
#line 3187
                  adjusted___1 = 0;
#line 3188
                  while (1) {
#line 3190
                    digits___3 = scale10_round_decimal_double(arg___8, (int )precision___0 - exponent___5);
#line 3193
                    if ((unsigned int )digits___3 == (unsigned int )((void *)0)) {
#line 3194
                      goto out_of_memory;
                    }
#line 3195
                    ndigits___4 = strlen((char const   *)digits___3);
#line 3197
                    if (ndigits___4 == precision___0 + 1U) {
#line 3198
                      break;
                    }
#line 3199
                    if (ndigits___4 < precision___0 || ndigits___4 > precision___0 + 2U) {
#line 3203
                      abort();
                    }
#line 3204
                    if (adjusted___1) {
#line 3208
                      abort();
                    }
#line 3209
                    free((void *)digits___3);
#line 3210
                    if (ndigits___4 == precision___0) {
#line 3211
                      exponent___5 --;
                    } else {
#line 3213
                      exponent___5 ++;
                    }
#line 3214
                    adjusted___1 = 1;
                  }
#line 3218
                  __cil_tmp___162 = p___0;
#line 3218
                  p___0 ++;
#line 3218
                  ndigits___4 --;
#line 3218
                  *__cil_tmp___162 = *(digits___3 + ndigits___4);
#line 3219
                  if (flags___0 & 16 || precision___0 > 0U) {
#line 3221
                    __cil_tmp___163 = p___0;
#line 3221
                    p___0 ++;
#line 3221
                    *__cil_tmp___163 = decimal_point_char();
#line 3222
                    while (ndigits___4 > 0U) {
#line 3224
                      ndigits___4 --;
#line 3225
                      __cil_tmp___164 = p___0;
#line 3225
                      p___0 ++;
#line 3225
                      *__cil_tmp___164 = *(digits___3 + ndigits___4);
                    }
                  }
#line 3229
                  free((void *)digits___3);
                }
#line 3232
                __cil_tmp___165 = p___0;
#line 3232
                p___0 ++;
#line 3232
                *__cil_tmp___165 = dp->conversion;
#line 3257
                if (sizeof(char ) == 1U) {
#line 3259
                  sprintf(p___0, decimal_format, exponent___5);
#line 3260
                  while ((int )*p___0 != 0) {
#line 3261
                    p___0 ++;
                  }
                } else {
#line 3267
                  sprintf(expbuf___3, decimal_format, exponent___5);
#line 3268
                  ep___3 = (char const   *)(expbuf___3);
#line 3268
                  while (1) {
#line 3268
                    __cil_tmp___166 = (char )*ep___3;
#line 3268
                    *p___0 = __cil_tmp___166;
#line 3268
                    if (! ((int )__cil_tmp___166 != 0)) {
#line 3268
                      break;
                    }
#line 3269
                    p___0 ++;
#line 3268
                    ep___3 ++;
                  }
                }
              } else
#line 3274
              if ((int )dp->conversion == 103 || (int )dp->conversion == 71) {
#line 3276
                if (precision___0 == 0U) {
#line 3277
                  precision___0 = 1U;
                }
#line 3280
                if (arg___8 == 0.0) {
#line 3284
                  ndigits___5 = precision___0;
#line 3287
                  nzeroes___1 = flags___0 & 16 ? 0U : precision___0 - 1U;
#line 3290
                  ndigits___5 --;
#line 3291
                  __cil_tmp___167 = p___0;
#line 3291
                  p___0 ++;
#line 3291
                  *__cil_tmp___167 = (char )'0';
#line 3292
                  if (flags___0 & 16 || ndigits___5 > nzeroes___1) {
#line 3294
                    __cil_tmp___168 = p___0;
#line 3294
                    p___0 ++;
#line 3294
                    *__cil_tmp___168 = decimal_point_char();
#line 3295
                    while (ndigits___5 > nzeroes___1) {
#line 3297
                      ndigits___5 --;
#line 3298
                      __cil_tmp___169 = p___0;
#line 3298
                      p___0 ++;
#line 3298
                      *__cil_tmp___169 = (char )'0';
                    }
                  }
                } else {
#line 3311
                  exponent___6 = floorlog10(arg___8);
#line 3312
                  adjusted___2 = 0;
#line 3313
                  while (1) {
#line 3315
                    digits___4 = scale10_round_decimal_double(arg___8, (int )(precision___0 - 1U) - exponent___6);
#line 3318
                    if ((unsigned int )digits___4 == (unsigned int )((void *)0)) {
#line 3319
                      goto out_of_memory;
                    }
#line 3320
                    ndigits___6 = strlen((char const   *)digits___4);
#line 3322
                    if (ndigits___6 == precision___0) {
#line 3323
                      break;
                    }
#line 3324
                    if (ndigits___6 < precision___0 - 1U || ndigits___6 > precision___0 + 1U) {
#line 3328
                      abort();
                    }
#line 3329
                    if (adjusted___2) {
#line 3333
                      abort();
                    }
#line 3334
                    free((void *)digits___4);
#line 3335
                    if (ndigits___6 < precision___0) {
#line 3336
                      exponent___6 --;
                    } else {
#line 3338
                      exponent___6 ++;
                    }
#line 3339
                    adjusted___2 = 1;
                  }
#line 3345
                  nzeroes___2 = 0U;
#line 3346
                  if ((flags___0 & 16) == 0) {
#line 3347
                    while (nzeroes___2 < ndigits___6 && (int )*(digits___4 + nzeroes___2) == 48) {
#line 3349
                      nzeroes___2 ++;
                    }
                  }
#line 3352
                  if (exponent___6 >= -4 && (long )exponent___6 < (long )precision___0) {
#line 3359
                    if (exponent___6 >= 0) {
#line 3361
                      count___2 = (unsigned int )(exponent___6 + 1);
#line 3363
                      while (count___2 > 0U) {
#line 3364
                        __cil_tmp___170 = p___0;
#line 3364
                        p___0 ++;
#line 3364
                        ndigits___6 --;
#line 3364
                        *__cil_tmp___170 = *(digits___4 + ndigits___6);
#line 3363
                        count___2 --;
                      }
#line 3365
                      if (flags___0 & 16 || ndigits___6 > nzeroes___2) {
#line 3367
                        __cil_tmp___171 = p___0;
#line 3367
                        p___0 ++;
#line 3367
                        *__cil_tmp___171 = decimal_point_char();
#line 3368
                        while (ndigits___6 > nzeroes___2) {
#line 3370
                          ndigits___6 --;
#line 3371
                          __cil_tmp___172 = p___0;
#line 3371
                          p___0 ++;
#line 3371
                          *__cil_tmp___172 = *(digits___4 + ndigits___6);
                        }
                      }
                    } else {
#line 3377
                      count___3 = (unsigned int )(- exponent___6 - 1);
#line 3378
                      __cil_tmp___173 = p___0;
#line 3378
                      p___0 ++;
#line 3378
                      *__cil_tmp___173 = (char )'0';
#line 3379
                      __cil_tmp___174 = p___0;
#line 3379
                      p___0 ++;
#line 3379
                      *__cil_tmp___174 = decimal_point_char();
#line 3380
                      while (count___3 > 0U) {
#line 3381
                        __cil_tmp___175 = p___0;
#line 3381
                        p___0 ++;
#line 3381
                        *__cil_tmp___175 = (char )'0';
#line 3380
                        count___3 --;
                      }
#line 3382
                      while (ndigits___6 > nzeroes___2) {
#line 3384
                        ndigits___6 --;
#line 3385
                        __cil_tmp___176 = p___0;
#line 3385
                        p___0 ++;
#line 3385
                        *__cil_tmp___176 = *(digits___4 + ndigits___6);
                      }
                    }
                  } else {
#line 3392
                    __cil_tmp___177 = p___0;
#line 3392
                    p___0 ++;
#line 3392
                    ndigits___6 --;
#line 3392
                    *__cil_tmp___177 = *(digits___4 + ndigits___6);
#line 3393
                    if (flags___0 & 16 || ndigits___6 > nzeroes___2) {
#line 3395
                      __cil_tmp___178 = p___0;
#line 3395
                      p___0 ++;
#line 3395
                      *__cil_tmp___178 = decimal_point_char();
#line 3396
                      while (ndigits___6 > nzeroes___2) {
#line 3398
                        ndigits___6 --;
#line 3399
                        __cil_tmp___179 = p___0;
#line 3399
                        p___0 ++;
#line 3399
                        *__cil_tmp___179 = *(digits___4 + ndigits___6);
                      }
                    }
#line 3402
                    __cil_tmp___180 = p___0;
#line 3402
                    p___0 ++;
#line 3402
                    *__cil_tmp___180 = (char )(((int )dp->conversion - 71) + 69);
#line 3427
                    if (sizeof(char ) == 1U) {
#line 3429
                      sprintf(p___0, decimal_format___0, exponent___6);
#line 3430
                      while ((int )*p___0 != 0) {
#line 3431
                        p___0 ++;
                      }
                    } else {
#line 3437
                      sprintf(expbuf___4, decimal_format___0, exponent___6);
#line 3438
                      ep___4 = (char const   *)(expbuf___4);
#line 3438
                      while (1) {
#line 3438
                        __cil_tmp___181 = (char )*ep___4;
#line 3438
                        *p___0 = __cil_tmp___181;
#line 3438
                        if (! ((int )__cil_tmp___181 != 0)) {
#line 3438
                          break;
                        }
#line 3439
                        p___0 ++;
#line 3438
                        ep___4 ++;
                      }
                    }
                  }
#line 3445
                  free((void *)digits___4);
                }
              } else {
#line 3449
                abort();
              }
            }
          }
        }
#line 3508
        if (has_width___0 && (unsigned int )(p___0 - tmp___0) < width___0) {
#line 3510
          pad___0 = width___0 - (unsigned int )(p___0 - tmp___0);
#line 3511
          end___0 = p___0 + pad___0;
#line 3513
          if (flags___0 & 2) {
#line 3516
            while (pad___0 > 0U) {
#line 3517
              __cil_tmp___183 = p___0;
#line 3517
              p___0 ++;
#line 3517
              *__cil_tmp___183 = (char )' ';
#line 3516
              pad___0 --;
            }
          } else
#line 3519
          if (flags___0 & 32 && (unsigned int )pad_ptr___0 != (unsigned int )((void *)0)) {
#line 3522
            q___3 = end___0;
#line 3524
            while ((unsigned int )p___0 > (unsigned int )pad_ptr___0) {
#line 3525
              q___3 --;
#line 3525
              p___0 --;
#line 3525
              *q___3 = *p___0;
            }
#line 3526
            while (pad___0 > 0U) {
#line 3527
              __cil_tmp___184 = p___0;
#line 3527
              p___0 ++;
#line 3527
              *__cil_tmp___184 = (char )'0';
#line 3526
              pad___0 --;
            }
          } else {
#line 3532
            q___4 = end___0;
#line 3534
            while ((unsigned int )p___0 > (unsigned int )tmp___0) {
#line 3535
              q___4 --;
#line 3535
              p___0 --;
#line 3535
              *q___4 = *p___0;
            }
#line 3536
            while (pad___0 > 0U) {
#line 3537
              __cil_tmp___185 = p___0;
#line 3537
              p___0 ++;
#line 3537
              *__cil_tmp___185 = (char )' ';
#line 3536
              pad___0 --;
            }
          }
#line 3540
          p___0 = end___0;
        }
#line 3544
        count___4 = (unsigned int )(p___0 - tmp___0);
#line 3546
        if (count___4 >= tmp_length___0) {
#line 3549
          abort();
        }
#line 3552
        if (count___4 >= allocated - length) {
#line 3554
          __cil_tmp___186 = xsum(length, count___4);
#line 3554
          n___1 = __cil_tmp___186;
#line 3556
          if (n___1 > allocated) {
#line 3556
            allocated = allocated > 0U ? (allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? allocated * 2U : ((1U << 31) - 1U) * 2U + 1U) : 12U;
#line 3556
            if (n___1 > allocated) {
#line 3556
              allocated = n___1;
            }
#line 3556
            memory_size___2 = allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? allocated * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 3556
            if (memory_size___2 == ((1U << 31) - 1U) * 2U + 1U) {
#line 3556
              goto out_of_memory;
            }
#line 3556
            if ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0)) {
#line 3556
              __cil_tmp___187 = rpl_malloc(memory_size___2);
#line 3556
              memory___2 = (char *)__cil_tmp___187;
            } else {
#line 3556
              __cil_tmp___188 = rpl_realloc((void *)result, memory_size___2);
#line 3556
              memory___2 = (char *)__cil_tmp___188;
            }
#line 3556
            if ((unsigned int )memory___2 == (unsigned int )((void *)0)) {
#line 3556
              goto out_of_memory;
            }
#line 3556
            if ((unsigned int )result == (unsigned int )resultbuf && length > 0U) {
#line 3556
              memcpy((void *)memory___2, (void const   *)result, length);
            }
#line 3556
            result = memory___2;
          }
        }
#line 3560
        memcpy((void *)(result + length), (void const   *)tmp___0, count___4 * sizeof(char ));
#line 3561
        if ((unsigned int )tmp___0 != (unsigned int )(tmpbuf___0)) {
#line 3562
          free((void *)tmp___0);
        }
#line 3563
        length += count___4;
      } else {
#line 3569
        type___1 = (a.arg + dp->arg_index)->type;
#line 3570
        flags___1 = dp->flags;
#line 3599
        has_width___1 = 0;
#line 3600
        width___1 = 0U;
#line 3601
        if ((unsigned int )dp->width_start != (unsigned int )dp->width_end) {
#line 3603
          if (dp->width_arg_index != 4294967295U) {
#line 3607
            if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
#line 3608
              abort();
            }
#line 3609
            arg___9 = (a.arg + dp->width_arg_index)->a.a_int;
#line 3610
            if (arg___9 < 0) {
#line 3614
              flags___1 |= 2;
#line 3615
              width___1 = (unsigned int )(- arg___9);
            } else {
#line 3618
              width___1 = (unsigned int )arg___9;
            }
          } else {
#line 3622
            digitp___3 = dp->width_start;
#line 3624
            while (1) {
#line 3625
              __cil_tmp___189 = digitp___3;
#line 3625
              digitp___3 ++;
#line 3625
              width___1 = xsum(width___1 <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? width___1 * 10U : ((1U << 31) - 1U) * 2U + 1U,
                               (unsigned int )((int const   )*__cil_tmp___189 - 48));
#line 3624
              if (! ((unsigned int )digitp___3 != (unsigned int )dp->width_end)) {
#line 3624
                break;
              }
            }
          }
#line 3628
          has_width___1 = 1;
        }
#line 3633
        has_precision___1 = 0;
#line 3634
        precision___1 = 6U;
#line 3635
        if ((unsigned int )dp->precision_start != (unsigned int )dp->precision_end) {
#line 3637
          if (dp->precision_arg_index != 4294967295U) {
#line 3641
            if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
#line 3642
              abort();
            }
#line 3643
            arg___10 = (a.arg + dp->precision_arg_index)->a.a_int;
#line 3646
            if (arg___10 >= 0) {
#line 3648
              precision___1 = (unsigned int )arg___10;
#line 3649
              has_precision___1 = 1;
            }
          } else {
#line 3654
            digitp___4 = dp->precision_start + 1;
#line 3656
            precision___1 = 0U;
#line 3657
            while ((unsigned int )digitp___4 != (unsigned int )dp->precision_end) {
#line 3658
              __cil_tmp___190 = digitp___4;
#line 3658
              digitp___4 ++;
#line 3658
              precision___1 = xsum(precision___1 <= (((1U << 31) - 1U) * 2U + 1U) / 10U ? precision___1 * 10U : ((1U << 31) - 1U) * 2U + 1U,
                                   (unsigned int )((int const   )*__cil_tmp___190 - 48));
            }
#line 3659
            has_precision___1 = 1;
          }
        }
#line 3668
        switch ((int )dp->conversion) {
        case 100: 
        case 105: 
        case 117: 
#line 3673
        if ((unsigned int )type___1 == 9U || (unsigned int )type___1 == 10U) {
#line 3674
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned long long ) * 8U) * 0.30103) + 1U;
        } else
#line 3681
        if ((unsigned int )type___1 == 7U || (unsigned int )type___1 == 8U) {
#line 3682
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned long ) * 8U) * 0.30103) + 1U;
        } else {
#line 3688
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned int ) * 8U) * 0.30103) + 1U;
        }
#line 3693
        if (tmp_length___1 < precision___1) {
#line 3694
          tmp_length___1 = precision___1;
        }
#line 3696
        tmp_length___1 = xsum(tmp_length___1, tmp_length___1);
#line 3698
        tmp_length___1 = xsum(tmp_length___1, 1U);
#line 3699
        break;
        case 111: 
#line 3703
        if ((unsigned int )type___1 == 9U || (unsigned int )type___1 == 10U) {
#line 3704
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned long long ) * 8U) * 0.333334) + 1U;
        } else
#line 3711
        if ((unsigned int )type___1 == 7U || (unsigned int )type___1 == 8U) {
#line 3712
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned long ) * 8U) * 0.333334) + 1U;
        } else {
#line 3718
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned int ) * 8U) * 0.333334) + 1U;
        }
#line 3723
        if (tmp_length___1 < precision___1) {
#line 3724
          tmp_length___1 = precision___1;
        }
#line 3726
        tmp_length___1 = xsum(tmp_length___1, 1U);
#line 3727
        break;
        case 120: 
        case 88: 
#line 3731
        if ((unsigned int )type___1 == 9U || (unsigned int )type___1 == 10U) {
#line 3732
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned long long ) * 8U) * 0.25) + 1U;
        } else
#line 3739
        if ((unsigned int )type___1 == 7U || (unsigned int )type___1 == 8U) {
#line 3740
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned long ) * 8U) * 0.25) + 1U;
        } else {
#line 3746
          tmp_length___1 = (unsigned int )((double )(sizeof(unsigned int ) * 8U) * 0.25) + 1U;
        }
#line 3751
        if (tmp_length___1 < precision___1) {
#line 3752
          tmp_length___1 = precision___1;
        }
#line 3754
        tmp_length___1 = xsum(tmp_length___1, 2U);
#line 3755
        break;
        case 102: 
        case 70: 
#line 3758
        if ((unsigned int )type___1 == 12U) {
#line 3759
          tmp_length___1 = ((unsigned int )(((double )1024 * 0.30103) * (double )2) + 1U) + 10U;
        } else {
#line 3767
          tmp_length___1 = ((unsigned int )(((double )1024 * 0.30103) * (double )2) + 1U) + 10U;
        }
#line 3774
        tmp_length___1 = xsum(tmp_length___1, precision___1);
#line 3775
        break;
        case 101: 
        case 69: 
        case 103: 
        case 71: 
#line 3778
        tmp_length___1 = 12U;
#line 3780
        tmp_length___1 = xsum(tmp_length___1, precision___1);
#line 3781
        break;
        case 97: 
        case 65: 
#line 3784
        if ((unsigned int )type___1 == 12U) {
#line 3785
          tmp_length___1 = (unsigned int )((double )15 * 0.831) + 1U;
        } else {
#line 3791
          tmp_length___1 = (unsigned int )((double )15 * 0.831) + 1U;
        }
#line 3796
        if (tmp_length___1 < precision___1) {
#line 3797
          tmp_length___1 = precision___1;
        }
#line 3799
        tmp_length___1 = xsum(tmp_length___1, 12U);
#line 3800
        break;
        case 99: 
#line 3804
        if ((unsigned int )type___1 == 14U) {
#line 3805
          __cil_tmp___191 = __locale_mb_cur_max();
#line 3805
          tmp_length___1 = (unsigned int )__cil_tmp___191;
        } else {
#line 3808
          tmp_length___1 = 1U;
        }
#line 3809
        break;
        case 115: 
#line 3813
        if ((unsigned int )type___1 == 16U) {
#line 3815
          tmp_length___1 = wcslen((a.arg + dp->arg_index)->a.a_wide_string);
#line 3819
          __cil_tmp___194 = __locale_mb_cur_max();
#line 3819
          if (tmp_length___1 <= (((1U << 31) - 1U) * 2U + 1U) / (unsigned int )__cil_tmp___194) {
#line 3819
            __cil_tmp___193 = __locale_mb_cur_max();
#line 3819
            tmp_length___1 *= (unsigned int )__cil_tmp___193;
          } else {
#line 3819
            tmp_length___1 = ((1U << 31) - 1U) * 2U + 1U;
          }
        } else {
#line 3824
          tmp_length___1 = strlen((a.arg + dp->arg_index)->a.a_string);
        }
#line 3825
        break;
        case 112: 
#line 3828
        tmp_length___1 = ((unsigned int )((double )(sizeof(void *) * 8U) * 0.25) + 1U) + 2U;
#line 3834
        break;
        default: 
#line 3837
        abort();
        }
#line 3849
        if (tmp_length___1 < width___1) {
#line 3850
          tmp_length___1 = width___1;
        }
#line 3853
        tmp_length___1 = xsum(tmp_length___1, 1U);
#line 3856
        if (tmp_length___1 <= sizeof(tmpbuf___1) / sizeof(char )) {
#line 3857
          tmp___1 = tmpbuf___1;
        } else {
#line 3860
          tmp_memsize___1 = tmp_length___1 <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? tmp_length___1 * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 3862
          if (tmp_memsize___1 == ((1U << 31) - 1U) * 2U + 1U) {
#line 3864
            goto out_of_memory;
          }
#line 3865
          __cil_tmp___195 = rpl_malloc(tmp_memsize___1);
#line 3865
          tmp___1 = (char *)__cil_tmp___195;
#line 3866
          if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 3868
            goto out_of_memory;
          }
        }
#line 3889
        switch ((int )dp->conversion) {
        case 102: 
        case 70: 
        case 101: 
        case 69: 
        case 103: 
        case 71: 
        case 97: 
        case 65: 
#line 3902
        pad_ourselves = 1;
#line 3903
        break;
        default: 
#line 3905
        pad_ourselves = 0;
#line 3906
        break;
        }
#line 3912
        fbp = buf___0;
#line 3913
        __cil_tmp___196 = fbp;
#line 3913
        fbp ++;
#line 3913
        *__cil_tmp___196 = (char )'%';
#line 3919
        if (flags___1 & 1) {
#line 3920
          __cil_tmp___197 = fbp;
#line 3920
          fbp ++;
#line 3920
          *__cil_tmp___197 = (char )'\'';
        }
#line 3922
        if (flags___1 & 2) {
#line 3923
          __cil_tmp___198 = fbp;
#line 3923
          fbp ++;
#line 3923
          *__cil_tmp___198 = (char )'-';
        }
#line 3924
        if (flags___1 & 4) {
#line 3925
          __cil_tmp___199 = fbp;
#line 3925
          fbp ++;
#line 3925
          *__cil_tmp___199 = (char )'+';
        }
#line 3926
        if (flags___1 & 8) {
#line 3927
          __cil_tmp___200 = fbp;
#line 3927
          fbp ++;
#line 3927
          *__cil_tmp___200 = (char )' ';
        }
#line 3928
        if (flags___1 & 16) {
#line 3929
          __cil_tmp___201 = fbp;
#line 3929
          fbp ++;
#line 3929
          *__cil_tmp___201 = (char )'#';
        }
#line 3930
        if (! pad_ourselves) {
#line 3932
          if (flags___1 & 32) {
#line 3933
            __cil_tmp___202 = fbp;
#line 3933
            fbp ++;
#line 3933
            *__cil_tmp___202 = (char )'0';
          }
#line 3934
          if ((unsigned int )dp->width_start != (unsigned int )dp->width_end) {
#line 3936
            n___2 = (unsigned int )(dp->width_end - dp->width_start);
#line 3939
            if (sizeof(char ) == sizeof(char )) {
#line 3941
              memcpy((void *)fbp, (void const   *)dp->width_start, n___2 * sizeof(char ));
#line 3942
              fbp += n___2;
            } else {
#line 3946
              mp = dp->width_start;
#line 3947
              while (1) {
#line 3948
                __cil_tmp___203 = fbp;
#line 3948
                fbp ++;
#line 3948
                __cil_tmp___204 = mp;
#line 3948
                mp ++;
#line 3948
                *__cil_tmp___203 = (char )((unsigned char )*__cil_tmp___204);
#line 3947
                n___2 --;
#line 3947
                if (! (n___2 > 0U)) {
#line 3947
                  break;
                }
              }
            }
          }
        }
#line 3955
        if ((unsigned int )dp->precision_start != (unsigned int )dp->precision_end) {
#line 3957
          n___3 = (unsigned int )(dp->precision_end - dp->precision_start);
#line 3960
          if (sizeof(char ) == sizeof(char )) {
#line 3962
            memcpy((void *)fbp, (void const   *)dp->precision_start, n___3 * sizeof(char ));
#line 3963
            fbp += n___3;
          } else {
#line 3967
            mp___0 = dp->precision_start;
#line 3968
            while (1) {
#line 3969
              __cil_tmp___205 = fbp;
#line 3969
              fbp ++;
#line 3969
              __cil_tmp___206 = mp___0;
#line 3969
              mp___0 ++;
#line 3969
              *__cil_tmp___205 = (char )((unsigned char )*__cil_tmp___206);
#line 3968
              n___3 --;
#line 3968
              if (! (n___3 > 0U)) {
#line 3968
                break;
              }
            }
          }
        }
#line 3975
        switch ((int )type___1) {
        case 9: 
        case 10: 
#line 3986
        __cil_tmp___207 = fbp;
#line 3986
        fbp ++;
#line 3986
        *__cil_tmp___207 = (char )'l';
        case 7: 
        case 8: 
        case 14: 
        case 16: 
#line 3998
        __cil_tmp___208 = fbp;
#line 3998
        fbp ++;
#line 3998
        *__cil_tmp___208 = (char )'l';
#line 3999
        break;
        case 12: 
#line 4001
        __cil_tmp___209 = fbp;
#line 4001
        fbp ++;
#line 4001
        *__cil_tmp___209 = (char )'L';
#line 4002
        break;
        default: 
#line 4004
        break;
        }
#line 4007
        if ((int )dp->conversion == 70) {
#line 4008
          *fbp = (char )'f';
        } else {
#line 4011
          *fbp = dp->conversion;
        }
#line 4029
        *(fbp + 1) = (char )'\000';
#line 4033
        prefix_count = 0U;
#line 4034
        if (! pad_ourselves && dp->width_arg_index != 4294967295U) {
#line 4036
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
#line 4037
            abort();
          }
#line 4038
          __cil_tmp___210 = prefix_count;
#line 4038
          prefix_count ++;
#line 4038
          prefixes[__cil_tmp___210] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4040
        if (dp->precision_arg_index != 4294967295U) {
#line 4042
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
#line 4043
            abort();
          }
#line 4044
          __cil_tmp___211 = prefix_count;
#line 4044
          prefix_count ++;
#line 4044
          prefixes[__cil_tmp___211] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
#line 4064
        while (1) {
#line 4066
          count___5 = -1;
#line 4117
          switch ((int )type___1) {
          case 1: 
#line 4121
          arg___11 = (int )(a.arg + dp->arg_index)->a.a_schar;
#line 4122
          switch ((int )prefix_count) {
          case 0: 
#line 4122
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___11);
#line 4122
          break;
          case 1: 
#line 4122
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___11);
#line 4122
          break;
          case 2: 
#line 4122
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___11);
#line 4122
          break;
          default: 
#line 4122
          abort();
          }
#line 4124
          break;
          case 2: 
#line 4127
          arg___12 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
#line 4128
          switch ((int )prefix_count) {
          case 0: 
#line 4128
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___12);
#line 4128
          break;
          case 1: 
#line 4128
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___12);
#line 4128
          break;
          case 2: 
#line 4128
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___12);
#line 4128
          break;
          default: 
#line 4128
          abort();
          }
#line 4130
          break;
          case 3: 
#line 4133
          arg___13 = (int )(a.arg + dp->arg_index)->a.a_short;
#line 4134
          switch ((int )prefix_count) {
          case 0: 
#line 4134
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___13);
#line 4134
          break;
          case 1: 
#line 4134
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___13);
#line 4134
          break;
          case 2: 
#line 4134
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___13);
#line 4134
          break;
          default: 
#line 4134
          abort();
          }
#line 4136
          break;
          case 4: 
#line 4139
          arg___14 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
#line 4140
          switch ((int )prefix_count) {
          case 0: 
#line 4140
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___14);
#line 4140
          break;
          case 1: 
#line 4140
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___14);
#line 4140
          break;
          case 2: 
#line 4140
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___14);
#line 4140
          break;
          default: 
#line 4140
          abort();
          }
#line 4142
          break;
          case 5: 
#line 4145
          arg___15 = (a.arg + dp->arg_index)->a.a_int;
#line 4146
          switch ((int )prefix_count) {
          case 0: 
#line 4146
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___15);
#line 4146
          break;
          case 1: 
#line 4146
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___15);
#line 4146
          break;
          case 2: 
#line 4146
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___15);
#line 4146
          break;
          default: 
#line 4146
          abort();
          }
#line 4148
          break;
          case 6: 
#line 4151
          arg___16 = (a.arg + dp->arg_index)->a.a_uint;
#line 4152
          switch ((int )prefix_count) {
          case 0: 
#line 4152
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___16);
#line 4152
          break;
          case 1: 
#line 4152
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___16);
#line 4152
          break;
          case 2: 
#line 4152
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___16);
#line 4152
          break;
          default: 
#line 4152
          abort();
          }
#line 4154
          break;
          case 7: 
#line 4157
          arg___17 = (a.arg + dp->arg_index)->a.a_longint;
#line 4158
          switch ((int )prefix_count) {
          case 0: 
#line 4158
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___17);
#line 4158
          break;
          case 1: 
#line 4158
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___17);
#line 4158
          break;
          case 2: 
#line 4158
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___17);
#line 4158
          break;
          default: 
#line 4158
          abort();
          }
#line 4160
          break;
          case 8: 
#line 4163
          arg___18 = (a.arg + dp->arg_index)->a.a_ulongint;
#line 4164
          switch ((int )prefix_count) {
          case 0: 
#line 4164
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___18);
#line 4164
          break;
          case 1: 
#line 4164
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___18);
#line 4164
          break;
          case 2: 
#line 4164
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___18);
#line 4164
          break;
          default: 
#line 4164
          abort();
          }
#line 4166
          break;
          case 9: 
#line 4170
          arg___19 = (a.arg + dp->arg_index)->a.a_longlongint;
#line 4171
          switch ((int )prefix_count) {
          case 0: 
#line 4171
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___19);
#line 4171
          break;
          case 1: 
#line 4171
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___19);
#line 4171
          break;
          case 2: 
#line 4171
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___19);
#line 4171
          break;
          default: 
#line 4171
          abort();
          }
#line 4173
          break;
          case 10: 
#line 4176
          arg___20 = (a.arg + dp->arg_index)->a.a_ulonglongint;
#line 4177
          switch ((int )prefix_count) {
          case 0: 
#line 4177
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___20);
#line 4177
          break;
          case 1: 
#line 4177
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___20);
#line 4177
          break;
          case 2: 
#line 4177
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___20);
#line 4177
          break;
          default: 
#line 4177
          abort();
          }
#line 4179
          break;
          case 11: 
#line 4183
          arg___21 = (a.arg + dp->arg_index)->a.a_double;
#line 4184
          switch ((int )prefix_count) {
          case 0: 
#line 4184
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___21);
#line 4184
          break;
          case 1: 
#line 4184
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___21);
#line 4184
          break;
          case 2: 
#line 4184
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___21);
#line 4184
          break;
          default: 
#line 4184
          abort();
          }
#line 4186
          break;
          case 12: 
#line 4189
          arg___22 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 4190
          switch ((int )prefix_count) {
          case 0: 
#line 4190
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___22);
#line 4190
          break;
          case 1: 
#line 4190
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___22);
#line 4190
          break;
          case 2: 
#line 4190
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___22);
#line 4190
          break;
          default: 
#line 4190
          abort();
          }
#line 4192
          break;
          case 13: 
#line 4195
          arg___23 = (a.arg + dp->arg_index)->a.a_char;
#line 4196
          switch ((int )prefix_count) {
          case 0: 
#line 4196
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___23);
#line 4196
          break;
          case 1: 
#line 4196
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___23);
#line 4196
          break;
          case 2: 
#line 4196
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___23);
#line 4196
          break;
          default: 
#line 4196
          abort();
          }
#line 4198
          break;
          case 14: 
#line 4202
          arg___24 = (a.arg + dp->arg_index)->a.a_wide_char;
#line 4203
          switch ((int )prefix_count) {
          case 0: 
#line 4203
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___24);
#line 4203
          break;
          case 1: 
#line 4203
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___24);
#line 4203
          break;
          case 2: 
#line 4203
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___24);
#line 4203
          break;
          default: 
#line 4203
          abort();
          }
#line 4205
          break;
          case 15: 
#line 4209
          arg___25 = (a.arg + dp->arg_index)->a.a_string;
#line 4210
          switch ((int )prefix_count) {
          case 0: 
#line 4210
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___25);
#line 4210
          break;
          case 1: 
#line 4210
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___25);
#line 4210
          break;
          case 2: 
#line 4210
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___25);
#line 4210
          break;
          default: 
#line 4210
          abort();
          }
#line 4212
          break;
          case 16: 
#line 4216
          arg___26 = (a.arg + dp->arg_index)->a.a_wide_string;
#line 4217
          switch ((int )prefix_count) {
          case 0: 
#line 4217
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___26);
#line 4217
          break;
          case 1: 
#line 4217
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___26);
#line 4217
          break;
          case 2: 
#line 4217
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___26);
#line 4217
          break;
          default: 
#line 4217
          abort();
          }
#line 4219
          break;
          case 17: 
#line 4223
          arg___27 = (a.arg + dp->arg_index)->a.a_pointer;
#line 4224
          switch ((int )prefix_count) {
          case 0: 
#line 4224
          count___5 = sprintf(tmp___1, (char const   *)buf___0, arg___27);
#line 4224
          break;
          case 1: 
#line 4224
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], arg___27);
#line 4224
          break;
          case 2: 
#line 4224
          count___5 = sprintf(tmp___1, (char const   *)buf___0, prefixes[0], prefixes[1],
                              arg___27);
#line 4224
          break;
          default: 
#line 4224
          abort();
          }
#line 4226
          break;
          default: 
#line 4228
          abort();
          }
#line 4280
          if (count___5 < 0) {
#line 4282
            if (! ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0))) {
#line 4283
              free((void *)result);
            }
#line 4284
            if ((unsigned int )buf_malloced != (unsigned int )((void *)0)) {
#line 4285
              free((void *)buf_malloced);
            }
#line 4286
            free((void *)d.dir);
#line 4286
            if (a.arg) {
#line 4286
              free((void *)a.arg);
            }
#line 4287
            __cil_tmp___212 = __errno();
#line 4287
            *__cil_tmp___212 = 22;
#line 4288
            return ((char *)((void *)0));
          }
#line 4485
          if ((unsigned int )count___5 > allocated - length) {
#line 4489
            __cil_tmp___213 = xsum(length, (unsigned int )count___5);
#line 4489
            __cil_tmp___214 = xmax(__cil_tmp___213, allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? allocated * 2U : ((1U << 31) - 1U) * 2U + 1U);
#line 4489
            n___4 = __cil_tmp___214;
#line 4492
            if (n___4 > allocated) {
#line 4492
              allocated = allocated > 0U ? (allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? allocated * 2U : ((1U << 31) - 1U) * 2U + 1U) : 12U;
#line 4492
              if (n___4 > allocated) {
#line 4492
                allocated = n___4;
              }
#line 4492
              memory_size___3 = allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? allocated * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 4492
              if (memory_size___3 == ((1U << 31) - 1U) * 2U + 1U) {
#line 4492
                goto out_of_memory;
              }
#line 4492
              if ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0)) {
#line 4492
                __cil_tmp___215 = rpl_malloc(memory_size___3);
#line 4492
                memory___3 = (char *)__cil_tmp___215;
              } else {
#line 4492
                __cil_tmp___216 = rpl_realloc((void *)result, memory_size___3);
#line 4492
                memory___3 = (char *)__cil_tmp___216;
              }
#line 4492
              if ((unsigned int )memory___3 == (unsigned int )((void *)0)) {
#line 4492
                goto out_of_memory;
              }
#line 4492
              if ((unsigned int )result == (unsigned int )resultbuf && length > 0U) {
#line 4492
                memcpy((void *)memory___3, (void const   *)result, length);
              }
#line 4492
              result = memory___3;
            }
          }
#line 4500
          if (pad_ourselves && has_width___1) {
#line 4511
            w = (unsigned int )count___5;
#line 4513
            if (w < width___1) {
#line 4515
              pad___1 = width___1 - w;
#line 4536
              rp = tmp___1;
#line 4538
              p___1 = rp + count___5;
#line 4539
              end___1 = p___1 + pad___1;
#line 4550
              pad_ptr___1 = (int )*rp == 45 ? rp + 1 : rp;
#line 4552
              if (((int )*pad_ptr___1 >= 65 && (int )*pad_ptr___1 <= 90) || ((int )*pad_ptr___1 >= 97 && (int )*pad_ptr___1 <= 122)) {
#line 4554
                pad_ptr___1 = (char *)((void *)0);
              }
#line 4561
              count___5 = (int )((unsigned int )count___5 + pad___1);
#line 4563
              if (flags___1 & 2) {
#line 4566
                while (pad___1 > 0U) {
#line 4567
                  __cil_tmp___217 = p___1;
#line 4567
                  p___1 ++;
#line 4567
                  *__cil_tmp___217 = (char )' ';
#line 4566
                  pad___1 --;
                }
              } else
#line 4570
              if (flags___1 & 32 && (unsigned int )pad_ptr___1 != (unsigned int )((void *)0)) {
#line 4573
                q___5 = end___1;
#line 4575
                while ((unsigned int )p___1 > (unsigned int )pad_ptr___1) {
#line 4576
                  q___5 --;
#line 4576
                  p___1 --;
#line 4576
                  *q___5 = *p___1;
                }
#line 4577
                while (pad___1 > 0U) {
#line 4578
                  __cil_tmp___218 = p___1;
#line 4578
                  p___1 ++;
#line 4578
                  *__cil_tmp___218 = (char )'0';
#line 4577
                  pad___1 --;
                }
              } else {
#line 4584
                q___6 = end___1;
#line 4586
                while ((unsigned int )p___1 > (unsigned int )rp) {
#line 4587
                  q___6 --;
#line 4587
                  p___1 --;
#line 4587
                  *q___6 = *p___1;
                }
#line 4588
                while (pad___1 > 0U) {
#line 4589
                  __cil_tmp___219 = p___1;
#line 4589
                  p___1 ++;
#line 4589
                  *__cil_tmp___219 = (char )' ';
#line 4588
                  pad___1 --;
                }
              }
            }
          }
#line 4597
          if ((unsigned int )count___5 >= tmp_length___1) {
#line 4600
            abort();
          }
#line 4609
          memcpy((void *)(result + length), (void const   *)tmp___1, (unsigned int )count___5 * sizeof(char ));
#line 4612
          if ((unsigned int )tmp___1 != (unsigned int )(tmpbuf___1)) {
#line 4613
            free((void *)tmp___1);
          }
#line 4617
          if ((int )dp->conversion == 70) {
#line 4620
            rp___0 = result + length;
#line 4622
            rc = (unsigned int )count___5;
#line 4622
            while (rc > 0U) {
#line 4623
              if ((int )*rp___0 >= 97 && (int )*rp___0 <= 122) {
#line 4624
                *rp___0 = (char )(((int )*rp___0 - 97) + 65);
              }
#line 4622
              rc --;
#line 4622
              rp___0 ++;
            }
          }
#line 4628
          length += (unsigned int )count___5;
#line 4629
          break;
        }
      }
    }
#line 1513
    cp = dp->dir_end;
#line 1513
    i ++;
#line 1513
    dp ++;
  }
#line 4636
  __cil_tmp___223 = xsum(length, 1U);
#line 4636
  if (__cil_tmp___223 > allocated) {
#line 4636
    allocated = allocated > 0U ? (allocated <= (((1U << 31) - 1U) * 2U + 1U) / 2U ? allocated * 2U : ((1U << 31) - 1U) * 2U + 1U) : 12U;
#line 4636
    __cil_tmp___220 = xsum(length, 1U);
#line 4636
    if (__cil_tmp___220 > allocated) {
#line 4636
      allocated = xsum(length, 1U);
    }
#line 4636
    memory_size___4 = allocated <= (((1U << 31) - 1U) * 2U + 1U) / sizeof(char ) ? allocated * sizeof(char ) : ((1U << 31) - 1U) * 2U + 1U;
#line 4636
    if (memory_size___4 == ((1U << 31) - 1U) * 2U + 1U) {
#line 4636
      goto out_of_memory;
    }
#line 4636
    if ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0)) {
#line 4636
      __cil_tmp___221 = rpl_malloc(memory_size___4);
#line 4636
      memory___4 = (char *)__cil_tmp___221;
    } else {
#line 4636
      __cil_tmp___222 = rpl_realloc((void *)result, memory_size___4);
#line 4636
      memory___4 = (char *)__cil_tmp___222;
    }
#line 4636
    if ((unsigned int )memory___4 == (unsigned int )((void *)0)) {
#line 4636
      goto out_of_memory;
    }
#line 4636
    if ((unsigned int )result == (unsigned int )resultbuf && length > 0U) {
#line 4636
      memcpy((void *)memory___4, (void const   *)result, length);
    }
#line 4636
    result = memory___4;
  }
#line 4637
  *(result + length) = (char )'\000';
#line 4639
  if ((unsigned int )result != (unsigned int )resultbuf && length + 1U < allocated) {
#line 4644
    __cil_tmp___224 = rpl_realloc((void *)result, (length + 1U) * sizeof(char ));
#line 4644
    memory___5 = (char *)__cil_tmp___224;
#line 4645
    if ((unsigned int )memory___5 != (unsigned int )((void *)0)) {
#line 4646
      result = memory___5;
    }
  }
#line 4649
  if ((unsigned int )buf_malloced != (unsigned int )((void *)0)) {
#line 4650
    free((void *)buf_malloced);
  }
#line 4651
  free((void *)d.dir);
#line 4651
  if (a.arg) {
#line 4651
    free((void *)a.arg);
  }
#line 4652
  *lengthp = length;
#line 4657
  return (result);
#line 4660
  if (! ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0))) {
#line 4661
    free((void *)result);
  }
#line 4662
  if ((unsigned int )buf_malloced != (unsigned int )((void *)0)) {
#line 4663
    free((void *)buf_malloced);
  }
#line 4664
  free((void *)d.dir);
#line 4664
  if (a.arg) {
#line 4664
    free((void *)a.arg);
  }
#line 4665
  __cil_tmp___225 = __errno();
#line 4665
  *__cil_tmp___225 = 139;
#line 4666
  return ((char *)((void *)0));
  out_of_memory: 
#line 4669
  if (! ((unsigned int )result == (unsigned int )resultbuf || (unsigned int )result == (unsigned int )((void *)0))) {
#line 4670
    free((void *)result);
  }
#line 4671
  if ((unsigned int )buf_malloced != (unsigned int )((void *)0)) {
#line 4672
    free((void *)buf_malloced);
  }
  out_of_memory_1: 
#line 4674
  free((void *)d.dir);
#line 4674
  if (a.arg) {
#line 4674
    free((void *)a.arg);
  }
#line 4675
  __cil_tmp___226 = __errno();
#line 4675
  *__cil_tmp___226 = 12;
#line 4676
  return ((char *)((void *)0));
}
}
#line 1 "vasprintf.o"
#pragma merger(0,"/tmp/cil-ZX3ordWx.i","-g,-O2")
#line 40 "vasprintf.c"
int vasprintf(char **resultp , char const   *format , va_list args ) 
{ size_t length ;
  char *result ;
  char *__cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 44
  __cil_tmp = vasnprintf((char *)((void *)0), & length, format, args);
#line 44
  result = __cil_tmp;
#line 45
  if ((unsigned int )result == (unsigned int )((void *)0)) {
#line 46
    return (-1);
  }
#line 48
  if (length > 2147483647U) {
#line 50
    free((void *)result);
#line 51
    __cil_tmp___0 = __errno();
#line 51
    *__cil_tmp___0 = 139;
#line 52
    return (-1);
  }
#line 55
  *resultp = result;
#line 57
  return ((int )length);
}
}
#line 1 "vfprintf.o"
#pragma merger(0,"/tmp/cil-oQekyDId.i","-g,-O2")
#line 42 "vfprintf.c"
int rpl_vfprintf(FILE *fp , char const   *format , va_list args ) 
{ char buf___0[2000] ;
  char *output ;
  size_t len ;
  size_t lenbuf ;
  int saved_errno ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 48
  lenbuf = sizeof(buf___0);
#line 50
  output = vasnprintf(buf___0, & lenbuf, format, args);
#line 51
  len = lenbuf;
#line 53
  if (! output) {
#line 55
    fseterr(fp);
#line 56
    return (-1);
  }
#line 59
  __cil_tmp___1 = fwrite((void const   *)output, 1U, len, fp);
#line 59
  if (__cil_tmp___1 < len) {
#line 61
    if ((unsigned int )output != (unsigned int )(buf___0)) {
#line 63
      __cil_tmp = __errno();
#line 63
      saved_errno = *__cil_tmp;
#line 64
      free((void *)output);
#line 65
      __cil_tmp___0 = __errno();
#line 65
      *__cil_tmp___0 = saved_errno;
    }
#line 67
    return (-1);
  }
#line 70
  if (len > 2147483647U) {
#line 72
    __cil_tmp___2 = __errno();
#line 72
    *__cil_tmp___2 = 139;
#line 73
    fseterr(fp);
#line 74
    return (-1);
  }
#line 77
  return ((int )len);
}
}
#line 1 "vprintf.o"
#pragma merger(0,"/tmp/cil-6OF6J5OV.i","-g,-O2")
#line 31 "vprintf.c"
int rpl_vprintf(char const   *format , va_list args ) 
{ int __cil_tmp ;

  {
#line 34
  __cil_tmp = rpl_vfprintf(_impure_ptr->_stdout, format, args);
#line 34
  return (__cil_tmp);
}
}
#line 1 "wcwidth.o"
#pragma merger(0,"/tmp/cil-xZfDfe2C.i","-g,-O2")
#line 103 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/wchar.h"
extern int wcwidth(wchar_t  ) ;
#line 31 "wcwidth.c"
int rpl_wcwidth(wchar_t wc ) 
{ char const   *encoding ;
  char const   *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 35
  __cil_tmp = locale_charset();
#line 35
  encoding = __cil_tmp;
#line 36
  __cil_tmp___2 = strcmp(encoding, "UTF-8");
#line 36
  if (__cil_tmp___2 == 0) {
#line 40
    __cil_tmp___0 = uc_width((unsigned int )wc, encoding);
#line 40
    return (__cil_tmp___0);
  } else {
#line 46
    __cil_tmp___1 = wcwidth(wc);
#line 46
    return (__cil_tmp___1);
  }
}
}
#line 1 "write-any-file.o"
#pragma merger(0,"/tmp/cil-NjXfzFcz.i","-g,-O2")
#line 2 "write-any-file.h"
_Bool can_write_any_file(void) ;
#line 35 "write-any-file.c"
static _Bool initialized___2  ;
#line 36 "write-any-file.c"
static _Bool can_write  ;
#line 32 "write-any-file.c"
_Bool can_write_any_file(void) 
{ _Bool can ;
  uid_t __cil_tmp ;

  {
#line 38
  if (! initialized___2) {
#line 40
    can = (_Bool)0;
#line 52
    __cil_tmp = geteuid();
#line 52
    can = (_Bool )((int )__cil_tmp == 0);
#line 54
    can_write = can;
#line 55
    initialized___2 = (_Bool)1;
  }
#line 58
  return (can_write);
}
}
#line 1 "xgetcwd.o"
#pragma merger(0,"/tmp/cil-mrzRNb1K.i","-g,-O2")
#line 33 "xgetcwd.c"
char *xgetcwd(void) 
{ char *cwd ;
  char *__cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 36
  __cil_tmp = rpl_getcwd((char *)((void *)0), 0U);
#line 36
  cwd = __cil_tmp;
#line 37
  if (! cwd) {
#line 37
    __cil_tmp___0 = __errno();
#line 37
    if (*__cil_tmp___0 == 12) {
#line 38
      xalloc_die();
    }
  }
#line 39
  return (cwd);
}
}
#line 1 "xmalloc.o"
#pragma merger(0,"/tmp/cil-doA6sXJh.i","-g,-O2")
#line 49 "xalloc.h"
void *xcalloc(size_t n , size_t s ) ;
#line 46 "xmalloc.c"
void *xmalloc(size_t n ) 
{ void *p ;
  void *__cil_tmp ;

  {
#line 49
  __cil_tmp = rpl_malloc(n);
#line 49
  p = __cil_tmp;
#line 50
  if (! p && n != 0U) {
#line 51
    xalloc_die();
  }
#line 52
  return (p);
}
}
#line 58 "xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 

  {
#line 61
  p = rpl_realloc(p, n);
#line 62
  if (! p && n != 0U) {
#line 63
    xalloc_die();
  }
#line 64
  return (p);
}
}
#line 73 "xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ void *__cil_tmp ;

  {
#line 76
  __cil_tmp = x2nrealloc(p, pn, 1U);
#line 76
  return (__cil_tmp);
}
}
#line 83 "xmalloc.c"
void *xzalloc(size_t s ) 
{ void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 86
  __cil_tmp = xmalloc(s);
#line 86
  __cil_tmp___0 = memset(__cil_tmp, 0, s);
#line 86
  return (__cil_tmp___0);
}
}
#line 92 "xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ void *p ;

  {
#line 100
  p = rpl_calloc(n, s);
#line 100
  if (! p) {
#line 102
    xalloc_die();
  }
#line 103
  return (p);
}
}
#line 110 "xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 113
  __cil_tmp = xmalloc(s);
#line 113
  __cil_tmp___0 = memcpy(__cil_tmp, p, s);
#line 113
  return (__cil_tmp___0);
}
}
#line 118 "xmalloc.c"
char *xstrdup(char const   *string ) 
{ size_t __cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 121
  __cil_tmp = strlen(string);
#line 121
  __cil_tmp___0 = xmemdup((void const   *)string, __cil_tmp + 1U);
#line 121
  return ((char *)__cil_tmp___0);
}
}
#line 1 "xnanosleep.o"
#pragma merger(0,"/tmp/cil-AGRACO7J.i","-g,-O2")
#line 1 "xnanosleep.h"
int xnanosleep(double seconds ) ;
#line 47 "xnanosleep.c"
int xnanosleep(double seconds ) 
{ _Bool overflow ;
  struct timespec ts_sleep ;
  time_t floor_seconds ;
  double ns ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 59
  overflow = (_Bool )((long )((double )(~ (-1L << (sizeof(time_t ) * 8U - 1U))) / (double )2) == ~ (-1L << (sizeof(time_t ) * 8U - 1U)) / 2L ? (double )(~ (-1L << (sizeof(time_t ) * 8U - 1U))) < seconds : ((long )((long double )(~ (-1L << (sizeof(time_t ) * 8U - 1U))) / (long double )2) == ~ (-1L << (sizeof(time_t ) * 8U - 1U)) / 2L ? (long double )(~ (-1L << (sizeof(time_t ) * 8U - 1U))) < (long double )seconds : (long double )(~ (-1L << (sizeof(time_t ) * 8U - 1U))) <= (long double )seconds));
#line 67
  if (((double )0 <= seconds) == 0) {
#line 67
    __libc_failwith((char *)"Assertion failed: 0 <= seconds at xnanosleep.c:67");
  }
#line 70
  if (! overflow) {
#line 72
    floor_seconds = (long )seconds;
#line 73
    ns = (double )1000000000 * (seconds - (double )floor_seconds);
#line 74
    ts_sleep.tv_sec = floor_seconds;
#line 81
    ts_sleep.tv_nsec = (long )ns;
#line 82
    ts_sleep.tv_nsec += (long )((double )ts_sleep.tv_nsec < ns);
#line 85
    if (1000000000L <= ts_sleep.tv_nsec) {
#line 87
      if (ts_sleep.tv_sec == ~ (-1L << (sizeof(time_t ) * 8U - 1U))) {
#line 88
        overflow = (_Bool)1;
      } else {
#line 91
        (ts_sleep.tv_sec) ++;
#line 92
        ts_sleep.tv_nsec -= 1000000000L;
      }
    }
  }
#line 97
  while (1) {
#line 99
    if (overflow) {
#line 101
      ts_sleep.tv_sec = ~ (-1L << (sizeof(time_t ) * 8U - 1U));
#line 102
      ts_sleep.tv_nsec = 999999999L;
    }
#line 111
    __cil_tmp = __errno();
#line 111
    *__cil_tmp = 0;
#line 112
    __cil_tmp___0 = rpl_nanosleep((struct timespec  const  *)(& ts_sleep), (struct timespec *)((void *)0));
#line 112
    if (__cil_tmp___0 == 0) {
#line 113
      break;
    }
#line 114
    __cil_tmp___1 = __errno();
#line 114
    if (*__cil_tmp___1 != 4) {
#line 114
      __cil_tmp___2 = __errno();
#line 114
      if (*__cil_tmp___2 != 0) {
#line 115
        return (-1);
      }
    }
  }
#line 118
  return (0);
}
}
#line 1 "xstrtod.o"
#pragma merger(0,"/tmp/cil-Ra4fxBkH.i","-g,-O2")
#line 25 "xstrtod.h"
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) ;
#line 44 "xstrtod.c"
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) 
{ double val ;
  char *terminator ;
  _Bool ok ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 50
  ok = (_Bool)1;
#line 52
  __cil_tmp = __errno();
#line 52
  *__cil_tmp = 0;
#line 53
  val = (*convert)(str, & terminator);
#line 56
  if ((unsigned int )terminator == (unsigned int )str || ((unsigned int )ptr == (unsigned int )((void *)0) && (int )*terminator != 0)) {
#line 57
    ok = (_Bool)0;
  } else
#line 62
  if (val != (double )0) {
#line 62
    __cil_tmp___0 = __errno();
#line 62
    if (*__cil_tmp___0 == 34) {
#line 63
      ok = (_Bool)0;
    }
  }
#line 66
  if ((unsigned int )ptr != (unsigned int )((void *)0)) {
#line 67
    *ptr = (char const   *)terminator;
  }
#line 69
  *result = val;
#line 70
  return (ok);
}
}
#line 1 "xstrtol.o"
#pragma merger(0,"/tmp/cil-LPWZmtQz.i","-g,-O2")
#line 44 "xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 46 "xstrtol.c"
static strtol_error bkm_scale___1(long *x , int scale_factor ) 
{ 

  {
#line 49
  if (*x < (-0x7FFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFF-1);
#line 52
    return ((enum strtol_error )1);
  }
#line 54
  if (2147483647L / (long )scale_factor < *x) {
#line 56
    *x = 2147483647L;
#line 57
    return ((enum strtol_error )1);
  }
#line 59
  *x *= (long )scale_factor;
#line 60
  return ((enum strtol_error )0);
}
}
#line 63 "xstrtol.c"
static strtol_error bkm_scale_by_power___1(long *x , int base , int power ) 
{ strtol_error err ;
  strtol_error __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 66
  err = (enum strtol_error )0;
#line 67
  while (1) {
#line 67
    __cil_tmp___0 = power;
#line 67
    power --;
#line 67
    if (! __cil_tmp___0) {
#line 67
      break;
    }
#line 68
    __cil_tmp = bkm_scale___1(x, base);
#line 68
    err = (enum strtol_error )((unsigned int )err | (unsigned int )__cil_tmp);
  }
#line 69
  return (err);
}
}
#line 74 "xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;

  {
#line 81
  err = (enum strtol_error )0;
#line 83
  if ((0 <= strtol_base && strtol_base <= 36) == 0) {
#line 83
    __libc_failwith((char *)"Assertion failed: 0 <= strtol_base && strtol_base <= 36 at xstrtol.c:83");
  }
#line 85
  p = ptr ? ptr : & t_ptr;
#line 97
  __cil_tmp = __errno();
#line 97
  *__cil_tmp = 0;
#line 98
  tmp = strtol(s, p, strtol_base);
#line 100
  if ((unsigned int )*p == (unsigned int )s) {
#line 104
    if (valid_suffixes && *(*p)) {
#line 104
      __cil_tmp___0 = strchr(valid_suffixes, (int )*(*p));
#line 104
      if (__cil_tmp___0) {
#line 105
        tmp = 1L;
      } else {
#line 107
        return ((enum strtol_error )4);
      }
    } else {
#line 107
      return ((enum strtol_error )4);
    }
  } else {
#line 109
    __cil_tmp___2 = __errno();
#line 109
    if (*__cil_tmp___2 != 0) {
#line 111
      __cil_tmp___1 = __errno();
#line 111
      if (*__cil_tmp___1 != 34) {
#line 112
        return ((enum strtol_error )4);
      }
#line 113
      err = (enum strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    __cil_tmp___3 = strchr(valid_suffixes, (int )*(*p));
#line 131
    if (! __cil_tmp___3) {
#line 133
      *val = tmp;
#line 134
      return ((enum strtol_error )((unsigned int )err | 2U));
    }
#line 137
    __cil_tmp___4 = strchr(valid_suffixes, '0');
#line 137
    if (__cil_tmp___4) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 66: 
      case 68: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___1(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___1(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (enum strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
#line 177
    break;
    case 71: 
    case 103: 
#line 181
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
#line 182
    break;
    case 107: 
    case 75: 
#line 186
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
#line 187
    break;
    case 77: 
    case 109: 
#line 191
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
#line 196
    break;
    case 84: 
    case 116: 
#line 200
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___1(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((enum strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (enum strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (enum strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "xstrtol-error.o"
#pragma merger(0,"/tmp/cil-13xlDePt.i","-g,-O2")
#line 74 "xstrtol.h"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) ;
#line 46 "xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                          char const   *arg , int exit_status ) 
{ char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;

  {
#line 52
  hyphens = "--";
#line 57
  switch ((int )err) {
  default: 
#line 60
  abort();
  case 4: 
#line 63
  msgid = "invalid %s%s argument `%s\'";
#line 64
  break;
  case 2: 
  case 3: 
#line 68
  msgid = "invalid suffix in %s%s argument `%s\'";
#line 69
  break;
  case 1: 
#line 72
  msgid = "%s%s argument `%s\' too large";
#line 73
  break;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___0 + opt_idx)->name;
  }
#line 86
  error((int )exit_failure, 0, msgid, hyphens, option, arg);
#line 87
  return;
}
}
#line 91 "xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___0 ,
                   char const   *arg ) 
{ 

  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options___0, arg, (int )exit_failure);
#line 97
  abort();
}
}
#line 1 "xstrtold.o"
#pragma merger(0,"/tmp/cil-FHw4NbsV.i","-g,-O2")
#line 27 "xstrtod.h"
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) ;
#line 44 "xstrtod.c"
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) 
{ long double val ;
  char *terminator ;
  _Bool ok ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 50
  ok = (_Bool)1;
#line 52
  __cil_tmp = __errno();
#line 52
  *__cil_tmp = 0;
#line 53
  val = (*convert)(str, & terminator);
#line 56
  if ((unsigned int )terminator == (unsigned int )str || ((unsigned int )ptr == (unsigned int )((void *)0) && (int )*terminator != 0)) {
#line 57
    ok = (_Bool)0;
  } else
#line 62
  if (val != (long double )0) {
#line 62
    __cil_tmp___0 = __errno();
#line 62
    if (*__cil_tmp___0 == 34) {
#line 63
      ok = (_Bool)0;
    }
  }
#line 66
  if ((unsigned int )ptr != (unsigned int )((void *)0)) {
#line 67
    *ptr = (char const   *)terminator;
  }
#line 69
  *result = val;
#line 70
  return (ok);
}
}
#line 1 "xstrtoul.o"
#pragma merger(0,"/tmp/cil-8RiRI59j.i","-g,-O2")
#line 46 "xstrtol.c"
static strtol_error bkm_scale___2(unsigned long *x , int scale_factor ) 
{ 

  {
#line 54
  if (4294967295UL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 4294967295UL;
#line 57
    return ((enum strtol_error )1);
  }
#line 59
  *x *= (unsigned long )scale_factor;
#line 60
  return ((enum strtol_error )0);
}
}
#line 63 "xstrtol.c"
static strtol_error bkm_scale_by_power___2(unsigned long *x , int base , int power ) 
{ strtol_error err ;
  strtol_error __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 66
  err = (enum strtol_error )0;
#line 67
  while (1) {
#line 67
    __cil_tmp___0 = power;
#line 67
    power --;
#line 67
    if (! __cil_tmp___0) {
#line 67
      break;
    }
#line 68
    __cil_tmp = bkm_scale___2(x, base);
#line 68
    err = (enum strtol_error )((unsigned int )err | (unsigned int )__cil_tmp);
  }
#line 69
  return (err);
}
}
#line 74 "xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  int *__cil_tmp ;
  char *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;

  {
#line 81
  err = (enum strtol_error )0;
#line 83
  if ((0 <= strtol_base && strtol_base <= 36) == 0) {
#line 83
    __libc_failwith((char *)"Assertion failed: 0 <= strtol_base && strtol_base <= 36 at xstrtol.c:83");
  }
#line 85
  p = ptr ? ptr : & t_ptr;
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
#line 91
  while ((int const   )*((__ctype_ptr__ + sizeof(*("" + (int )ch))) + (int )ch) & 8) {
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((enum strtol_error )4);
  }
#line 97
  __cil_tmp = __errno();
#line 97
  *__cil_tmp = 0;
#line 98
  tmp = strtoul(s, p, strtol_base);
#line 100
  if ((unsigned int )*p == (unsigned int )s) {
#line 104
    if (valid_suffixes && *(*p)) {
#line 104
      __cil_tmp___0 = strchr(valid_suffixes, (int )*(*p));
#line 104
      if (__cil_tmp___0) {
#line 105
        tmp = 1UL;
      } else {
#line 107
        return ((enum strtol_error )4);
      }
    } else {
#line 107
      return ((enum strtol_error )4);
    }
  } else {
#line 109
    __cil_tmp___2 = __errno();
#line 109
    if (*__cil_tmp___2 != 0) {
#line 111
      __cil_tmp___1 = __errno();
#line 111
      if (*__cil_tmp___1 != 34) {
#line 112
        return ((enum strtol_error )4);
      }
#line 113
      err = (enum strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    __cil_tmp___3 = strchr(valid_suffixes, (int )*(*p));
#line 131
    if (! __cil_tmp___3) {
#line 133
      *val = tmp;
#line 134
      return ((enum strtol_error )((unsigned int )err | 2U));
    }
#line 137
    __cil_tmp___4 = strchr(valid_suffixes, '0');
#line 137
    if (__cil_tmp___4) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 66: 
      case 68: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___2(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___2(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (enum strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___2(& tmp, base, 6);
#line 177
    break;
    case 71: 
    case 103: 
#line 181
    overflow = bkm_scale_by_power___2(& tmp, base, 3);
#line 182
    break;
    case 107: 
    case 75: 
#line 186
    overflow = bkm_scale_by_power___2(& tmp, base, 1);
#line 187
    break;
    case 77: 
    case 109: 
#line 191
    overflow = bkm_scale_by_power___2(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___2(& tmp, base, 5);
#line 196
    break;
    case 84: 
    case 116: 
#line 200
    overflow = bkm_scale_by_power___2(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___2(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___2(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___2(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((enum strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (enum strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (enum strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "yesno.o"
#pragma merger(0,"/tmp/cil-HIGer6dN.i","-g,-O2")
#line 22 "yesno.h"
_Bool yesno(void) ;
#line 34 "yesno.c"
_Bool yesno(void) 
{ _Bool yes ;
  int c ;
  int __cil_tmp ;
  unsigned char *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  unsigned char *__cil_tmp___3 ;

  {
#line 56
  ((_impure_ptr->_stdin)->_r) --;
#line 56
  if ((_impure_ptr->_stdin)->_r < 0) {
#line 56
    __cil_tmp = __srget_r(_impure_ptr, _impure_ptr->_stdin);
#line 56
    __cil_tmp___1 = __cil_tmp;
  } else {
#line 56
    __cil_tmp___0 = (_impure_ptr->_stdin)->_p;
#line 56
    ((_impure_ptr->_stdin)->_p) ++;
#line 56
    __cil_tmp___1 = (int )*__cil_tmp___0;
  }
#line 56
  c = __cil_tmp___1;
#line 57
  yes = (_Bool )(c == 121 || c == 89);
#line 58
  while (c != 10 && c != -1) {
#line 59
    ((_impure_ptr->_stdin)->_r) --;
#line 59
    if ((_impure_ptr->_stdin)->_r < 0) {
#line 59
      __cil_tmp___2 = __srget_r(_impure_ptr, _impure_ptr->_stdin);
#line 59
      c = __cil_tmp___2;
    } else {
#line 59
      __cil_tmp___3 = (_impure_ptr->_stdin)->_p;
#line 59
      ((_impure_ptr->_stdin)->_p) ++;
#line 59
      c = (int )*__cil_tmp___3;
    }
  }
#line 62
  return (yes);
}
}
#line 1 "euidaccess-stat.o"
#pragma merger(0,"/tmp/cil-h7w9kE3j.i","-g,-O2")
#line 5 "euidaccess-stat.h"
_Bool euidaccess_stat(struct stat  const  *st , int mode ) ;
#line 49 "euidaccess-stat.c"
_Bool euidaccess_stat(struct stat  const  *st , int mode ) 
{ uid_t euid ;
  unsigned int granted ;
  gid_t egid ;
  gid_t __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 57
  mode &= 7;
#line 63
  if (mode == 0) {
#line 64
    return ((_Bool)1);
  }
#line 66
  euid = geteuid();
#line 70
  if ((int )euid == 0 && ((mode & 1) == 0 || st->st_mode & 73U)) {
#line 72
    return ((_Bool)1);
  }
#line 75
  if (((((256 == 4 << 6 && 128 == 2 << 6) && 64 == 1 << 6) && 32 == 4 << 3) && 16 == 2 << 3) && 8 == 1 << 3) {
#line 84
    granted = (unsigned int )st->st_mode;
  } else {
#line 86
    granted = (unsigned int )(((((((((st->st_mode & 256U ? 4 << 6 : 0) + (st->st_mode & 128U ? 2 << 6 : 0)) + (st->st_mode & 64U ? 1 << 6 : 0)) + (st->st_mode & 32U ? 4 << 3 : 0)) + (st->st_mode & 16U ? 2 << 3 : 0)) + (st->st_mode & 8U ? 1 << 3 : 0)) + (st->st_mode & 4U ? 4 : 0)) + (st->st_mode & 2U ? 2 : 0)) + (st->st_mode & 1U ? 1 : 0));
  }
#line 96
  if ((int )euid == (int )st->st_uid) {
#line 97
    granted >>= 6;
  } else {
#line 100
    __cil_tmp = getegid();
#line 100
    egid = __cil_tmp;
#line 101
    if ((int )egid == (int )st->st_gid) {
#line 102
      granted >>= 3;
    } else {
#line 101
      __cil_tmp___0 = group_member((unsigned short )st->st_gid);
#line 101
      if (__cil_tmp___0) {
#line 102
        granted >>= 3;
      }
    }
  }
#line 105
  if (((unsigned int )mode & ~ granted) == 0U) {
#line 106
    return ((_Bool)1);
  }
#line 108
  return ((_Bool)0);
}
}
#line 1 "fd-reopen.o"
#pragma merger(0,"/tmp/cil-IRrDNKxt.i","-g,-O2")
#line 22 "fd-reopen.h"
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) ;
#line 31 "fd-reopen.c"
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) 
{ int fd ;
  int fd2 ;
  int __cil_tmp ;
  int saved_errno ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 36
  close(desired_fd);
#line 37
  fd = open(file, flags, mode);
#line 38
  if (fd == desired_fd || fd < 0) {
#line 39
    return (fd);
  } else {
#line 42
    __cil_tmp = fcntl(fd, 1, desired_fd);
#line 42
    fd2 = __cil_tmp;
#line 43
    __cil_tmp___0 = __errno();
#line 43
    saved_errno = *__cil_tmp___0;
#line 44
    close(fd);
#line 45
    __cil_tmp___1 = __errno();
#line 45
    *__cil_tmp___1 = saved_errno;
#line 46
    return (fd2);
  }
}
}
#line 1 "xfts.o"
#pragma merger(0,"/tmp/cil-y6nLgdDb.i","-g,-O2")
#line 3 "xfts.h"
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) ;
#line 36 "xfts.c"
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) 
{ FTS *fts ;
  FTS *__cil_tmp ;
  _Bool invalid_arg ;
  char const   *__cil_tmp___0 ;

  {
#line 40
  __cil_tmp = fts_open(argv, options | 512, compar);
#line 40
  fts = __cil_tmp;
#line 41
  if ((unsigned int )fts == (unsigned int )((void *)0)) {
#line 50
    invalid_arg = (_Bool)0;
#line 51
    while (*argv) {
#line 53
      if ((int )*(*argv) == 0) {
#line 54
        invalid_arg = (_Bool)1;
      }
#line 51
      argv ++;
    }
#line 56
    if (invalid_arg) {
#line 57
      __cil_tmp___0 = quote("");
#line 57
      error(1, 0, "invalid argument: %s", __cil_tmp___0);
    } else {
#line 59
      xalloc_die();
    }
  }
#line 62
  return (fts);
}
}
#line 1 "memxfrm.o"
#pragma merger(0,"/tmp/cil-GdUhweyd.i","-g,-O2")
#line 47 "/fs/buzz/kkma/code/wc1/trunk/newlib-1.19.0/newlib/libc/include/string.h"
extern size_t strxfrm(char * , char const   * , size_t  ) ;
#line 41 "memxfrm.c"
size_t memxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
               size_t srcsize ) 
{ size_t di ;
  size_t si ;
  size_t result ;
  char ch ;
  size_t slen ;
  size_t __cil_tmp ;
  size_t result0 ;
  int *__cil_tmp___0 ;
  size_t __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  size_t bufsize___0 ;
  char stackbuf[4000] ;
  char *buf___0 ;
  void *__cil_tmp___4 ;
  int *__cil_tmp___5 ;

  {
#line 47
  di = 0U;
#line 48
  si = 0U;
#line 49
  result = 0U;
#line 51
  ch = *(src + srcsize);
#line 52
  *(src + srcsize) = (char )'\000';
#line 54
  while (si < srcsize) {
#line 56
    __cil_tmp = strlen((char const   *)(src + si));
#line 56
    slen = __cil_tmp;
#line 58
    result0 = result;
#line 59
    __cil_tmp___0 = __errno();
#line 59
    *__cil_tmp___0 = 0;
#line 60
    __cil_tmp___1 = strxfrm((char *)(dest + di), (char const   *)(src + si), destsize - di);
#line 60
    result += __cil_tmp___1 + 1U;
#line 61
    __cil_tmp___2 = __errno();
#line 61
    if (*__cil_tmp___2 != 0) {
#line 62
      break;
    }
#line 63
    if (result <= result0) {
#line 65
      __cil_tmp___3 = __errno();
#line 65
      *__cil_tmp___3 = 34;
#line 66
      break;
    }
#line 69
    if (result == destsize + 1U && si + slen == srcsize) {
#line 74
      bufsize___0 = (destsize - di) + 1U;
#line 76
      buf___0 = stackbuf;
#line 77
      if (sizeof(stackbuf) < bufsize___0) {
#line 79
        __cil_tmp___4 = rpl_malloc(bufsize___0);
#line 79
        buf___0 = (char *)__cil_tmp___4;
#line 80
        if (! buf___0) {
#line 81
          break;
        }
      }
#line 83
      strxfrm(buf___0, (char const   *)(src + si), bufsize___0);
#line 84
      memcpy((void *)(dest + di), (void const   *)buf___0, destsize - di);
#line 85
      if (sizeof(stackbuf) < bufsize___0) {
#line 86
        free((void *)buf___0);
      }
#line 87
      __cil_tmp___5 = __errno();
#line 87
      *__cil_tmp___5 = 0;
    }
#line 90
    di = result < destsize ? result : destsize;
#line 91
    si += slen + 1U;
  }
#line 94
  *(src + srcsize) = ch;
#line 95
  return (result - (unsigned int )(si != srcsize));
}
}
#line 1 "sha256.o"
#pragma merger(0,"/tmp/cil-MlOf2N5T.i","-g,-O2")
#line 36 "sha256.h"
void sha256_init_ctx(struct sha256_ctx *ctx ) ;
#line 37
void sha224_init_ctx(struct sha256_ctx *ctx ) ;
#line 43
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
#line 50
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
#line 60
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
#line 61
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
#line 70
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
#line 71
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
#line 77
int sha256_stream(FILE *stream , void *resblock ) ;
#line 78
int sha224_stream(FILE *stream , void *resblock ) ;
#line 84
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 85
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 48 "sha256.c"
static unsigned char const   fillbuf___1[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 56 "sha256.c"
void sha256_init_ctx(struct sha256_ctx *ctx ) 
{ unsigned int __cil_tmp ;

  {
#line 59
  ctx->state[0] = 1779033703U;
#line 60
  ctx->state[1] = 3144134277U;
#line 61
  ctx->state[2] = 1013904242U;
#line 62
  ctx->state[3] = 2773480762U;
#line 63
  ctx->state[4] = 1359893119U;
#line 64
  ctx->state[5] = 2600822924U;
#line 65
  ctx->state[6] = 528734635U;
#line 66
  ctx->state[7] = 1541459225U;
#line 68
  __cil_tmp = 0U;
#line 68
  ctx->total[1] = __cil_tmp;
#line 68
  ctx->total[0] = __cil_tmp;
#line 69
  ctx->buflen = 0U;
#line 70
  return;
}
}
#line 72 "sha256.c"
void sha224_init_ctx(struct sha256_ctx *ctx ) 
{ unsigned int __cil_tmp ;

  {
#line 75
  ctx->state[0] = 3238371032U;
#line 76
  ctx->state[1] = 914150663U;
#line 77
  ctx->state[2] = 812702999U;
#line 78
  ctx->state[3] = 4144912697U;
#line 79
  ctx->state[4] = 4290775857U;
#line 80
  ctx->state[5] = 1750603025U;
#line 81
  ctx->state[6] = 1694076839U;
#line 82
  ctx->state[7] = 3204075428U;
#line 84
  __cil_tmp = 0U;
#line 84
  ctx->total[1] = __cil_tmp;
#line 84
  ctx->total[0] = __cil_tmp;
#line 85
  ctx->buflen = 0U;
#line 86
  return;
}
}
#line 93 "sha256.c"
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ int i ;

  {
#line 98
  i = 0;
#line 98
  while (i < 8) {
#line 99
    *((unsigned int *)resbuf + i) = (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24);
#line 98
    i ++;
  }
#line 101
  return (resbuf);
}
}
#line 104 "sha256.c"
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ int i ;

  {
#line 109
  i = 0;
#line 109
  while (i < 7) {
#line 110
    *((unsigned int *)resbuf + i) = (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24);
#line 109
    i ++;
  }
#line 112
  return (resbuf);
}
}
#line 120 "sha256.c"
static void sha256_conclude_ctx(struct sha256_ctx *ctx ) 
{ unsigned int bytes ;
  size_t size ;

  {
#line 124
  bytes = ctx->buflen;
#line 125
  size = (unsigned int )(bytes < 56U ? 16 : 32);
#line 128
  ctx->total[0] += bytes;
#line 129
  if (ctx->total[0] < bytes) {
#line 130
    (ctx->total[1]) ++;
  }
#line 133
  ctx->buffer[size - 2U] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
#line 134
  ctx->buffer[size - 1U] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
#line 136
  memcpy((void *)((char *)(ctx->buffer) + bytes), (void const   *)(fillbuf___1), (size - 2U) * 4U - bytes);
#line 139
  sha256_process_block((void const   *)(ctx->buffer), size * 4U, ctx);
#line 140
  return;
}
}
#line 142 "sha256.c"
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ void *__cil_tmp ;

  {
#line 145
  sha256_conclude_ctx(ctx);
#line 146
  __cil_tmp = sha256_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
#line 146
  return (__cil_tmp);
}
}
#line 149 "sha256.c"
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ void *__cil_tmp ;

  {
#line 152
  sha256_conclude_ctx(ctx);
#line 153
  __cil_tmp = sha224_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
#line 153
  return (__cil_tmp);
}
}
#line 159 "sha256.c"
int sha256_stream(FILE *stream , void *resblock ) 
{ struct sha256_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 167
  sha256_init_ctx(& ctx);
#line 170
  while (1) {
#line 176
    sum = 0U;
#line 179
    while (1) {
#line 181
      n = fread((void *)(buffer + sum), 1U, 4096U - sum, stream);
#line 183
      sum += n;
#line 185
      if (sum == 4096U) {
#line 186
        break;
      }
#line 188
      if (n == 0U) {
#line 193
        __cil_tmp = ferror(stream);
#line 193
        if (__cil_tmp) {
#line 194
          return (1);
        }
#line 195
        goto process_partial_block;
      }
#line 201
      __cil_tmp___0 = feof(stream);
#line 201
      if (__cil_tmp___0) {
#line 202
        goto process_partial_block;
      }
    }
#line 208
    sha256_process_block((void const   *)(buffer), 4096U, & ctx);
  }
  process_partial_block: ;
#line 214
  if (sum > 0U) {
#line 215
    sha256_process_bytes((void const   *)(buffer), sum, & ctx);
  }
#line 218
  sha256_finish_ctx(& ctx, resblock);
#line 219
  return (0);
}
}
#line 223 "sha256.c"
int sha224_stream(FILE *stream , void *resblock ) 
{ struct sha256_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 231
  sha224_init_ctx(& ctx);
#line 234
  while (1) {
#line 240
    sum = 0U;
#line 243
    while (1) {
#line 245
      n = fread((void *)(buffer + sum), 1U, 4096U - sum, stream);
#line 247
      sum += n;
#line 249
      if (sum == 4096U) {
#line 250
        break;
      }
#line 252
      if (n == 0U) {
#line 257
        __cil_tmp = ferror(stream);
#line 257
        if (__cil_tmp) {
#line 258
          return (1);
        }
#line 259
        goto process_partial_block;
      }
#line 265
      __cil_tmp___0 = feof(stream);
#line 265
      if (__cil_tmp___0) {
#line 266
        goto process_partial_block;
      }
    }
#line 272
    sha256_process_block((void const   *)(buffer), 4096U, & ctx);
  }
  process_partial_block: ;
#line 278
  if (sum > 0U) {
#line 279
    sha256_process_bytes((void const   *)(buffer), sum, & ctx);
  }
#line 282
  sha224_finish_ctx(& ctx, resblock);
#line 283
  return (0);
}
}
#line 290 "sha256.c"
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha256_ctx ctx ;
  void *__cil_tmp ;

  {
#line 296
  sha256_init_ctx(& ctx);
#line 299
  sha256_process_bytes((void const   *)buffer, len, & ctx);
#line 302
  __cil_tmp = sha256_finish_ctx(& ctx, resblock);
#line 302
  return (__cil_tmp);
}
}
#line 305 "sha256.c"
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha256_ctx ctx ;
  void *__cil_tmp ;

  {
#line 311
  sha224_init_ctx(& ctx);
#line 314
  sha256_process_bytes((void const   *)buffer, len, & ctx);
#line 317
  __cil_tmp = sha224_finish_ctx(& ctx, resblock);
#line 317
  return (__cil_tmp);
}
}
#line 320 "sha256.c"
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  void *__cil_tmp ;
  size_t left_over___0 ;

  {
#line 325
  if (ctx->buflen != 0U) {
#line 327
    left_over = ctx->buflen;
#line 328
    add = 128U - left_over > len ? len : 128U - left_over;
#line 330
    memcpy((void *)((char *)(ctx->buffer) + left_over), buffer, add);
#line 331
    ctx->buflen += add;
#line 333
    if (ctx->buflen > 64U) {
#line 335
      sha256_process_block((void const   *)(ctx->buffer), ctx->buflen & 4294967232U,
                           ctx);
#line 337
      ctx->buflen &= 63U;
#line 339
      memcpy((void *)(ctx->buffer), (void const   *)((char *)(ctx->buffer) + ((left_over + add) & 4294967232U)),
             ctx->buflen);
    }
#line 344
    buffer = (void const   *)((char const   *)buffer + add);
#line 345
    len -= add;
  }
#line 349
  if (len >= 64U) {
#line 354
    if ((unsigned int )buffer % (unsigned int )((char *)(& ((struct __anonstruct_9___0 *)0)->x)) != 0U) {
#line 355
      while (len > 64U) {
#line 357
        __cil_tmp = memcpy((void *)(ctx->buffer), buffer, 64U);
#line 357
        sha256_process_block((void const   *)__cil_tmp, 64U, ctx);
#line 358
        buffer = (void const   *)((char const   *)buffer + 64);
#line 359
        len -= 64U;
      }
    } else {
#line 364
      sha256_process_block(buffer, len & 4294967232U, ctx);
#line 365
      buffer = (void const   *)((char const   *)buffer + (len & 4294967232U));
#line 366
      len &= 63U;
    }
  }
#line 371
  if (len > 0U) {
#line 373
    left_over___0 = ctx->buflen;
#line 375
    memcpy((void *)((char *)(ctx->buffer) + left_over___0), buffer, len);
#line 376
    left_over___0 += len;
#line 377
    if (left_over___0 >= 64U) {
#line 379
      sha256_process_block((void const   *)(ctx->buffer), 64U, ctx);
#line 380
      left_over___0 -= 64U;
#line 381
      memcpy((void *)(ctx->buffer), (void const   *)(& ctx->buffer[16]), left_over___0);
    }
#line 383
    ctx->buflen = left_over___0;
  }
#line 385
  return;
}
}
#line 391 "sha256.c"
static unsigned int const   sha256_round_constants[64]  = 
#line 391
  {      (unsigned int const   )1116352408UL,      (unsigned int const   )1899447441UL,      (unsigned int const   )3049323471UL,      (unsigned int const   )3921009573UL, 
        (unsigned int const   )961987163UL,      (unsigned int const   )1508970993UL,      (unsigned int const   )2453635748UL,      (unsigned int const   )2870763221UL, 
        (unsigned int const   )3624381080UL,      (unsigned int const   )310598401UL,      (unsigned int const   )607225278UL,      (unsigned int const   )1426881987UL, 
        (unsigned int const   )1925078388UL,      (unsigned int const   )2162078206UL,      (unsigned int const   )2614888103UL,      (unsigned int const   )3248222580UL, 
        (unsigned int const   )3835390401UL,      (unsigned int const   )4022224774UL,      (unsigned int const   )264347078UL,      (unsigned int const   )604807628UL, 
        (unsigned int const   )770255983UL,      (unsigned int const   )1249150122UL,      (unsigned int const   )1555081692UL,      (unsigned int const   )1996064986UL, 
        (unsigned int const   )2554220882UL,      (unsigned int const   )2821834349UL,      (unsigned int const   )2952996808UL,      (unsigned int const   )3210313671UL, 
        (unsigned int const   )3336571891UL,      (unsigned int const   )3584528711UL,      (unsigned int const   )113926993UL,      (unsigned int const   )338241895UL, 
        (unsigned int const   )666307205UL,      (unsigned int const   )773529912UL,      (unsigned int const   )1294757372UL,      (unsigned int const   )1396182291UL, 
        (unsigned int const   )1695183700UL,      (unsigned int const   )1986661051UL,      (unsigned int const   )2177026350UL,      (unsigned int const   )2456956037UL, 
        (unsigned int const   )2730485921UL,      (unsigned int const   )2820302411UL,      (unsigned int const   )3259730800UL,      (unsigned int const   )3345764771UL, 
        (unsigned int const   )3516065817UL,      (unsigned int const   )3600352804UL,      (unsigned int const   )4094571909UL,      (unsigned int const   )275423344UL, 
        (unsigned int const   )430227734UL,      (unsigned int const   )506948616UL,      (unsigned int const   )659060556UL,      (unsigned int const   )883997877UL, 
        (unsigned int const   )958139571UL,      (unsigned int const   )1322822218UL,      (unsigned int const   )1537002063UL,      (unsigned int const   )1747873779UL, 
        (unsigned int const   )1955562222UL,      (unsigned int const   )2024104815UL,      (unsigned int const   )2227730452UL,      (unsigned int const   )2361852424UL, 
        (unsigned int const   )2428436474UL,      (unsigned int const   )2756734187UL,      (unsigned int const   )3204031479UL,      (unsigned int const   )3329325298UL};
#line 418 "sha256.c"
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ unsigned int const   *words ;
  size_t nwords ;
  unsigned int const   *endp ;
  unsigned int x[16] ;
  unsigned int a ;
  unsigned int b ;
  unsigned int c ;
  unsigned int d ;
  unsigned int e ;
  unsigned int f ;
  unsigned int g ;
  unsigned int h ;
  unsigned int tm ;
  unsigned int t0 ;
  unsigned int t1 ;
  int t ;
  unsigned int __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  unsigned int __cil_tmp___1 ;
  unsigned int __cil_tmp___2 ;
  unsigned int __cil_tmp___3 ;
  unsigned int __cil_tmp___4 ;
  unsigned int __cil_tmp___5 ;
  unsigned int __cil_tmp___6 ;

  {
#line 421
  words = (unsigned int const   *)buffer;
#line 422
  nwords = len / sizeof(unsigned int );
#line 423
  endp = words + nwords;
#line 425
  a = ctx->state[0];
#line 426
  b = ctx->state[1];
#line 427
  c = ctx->state[2];
#line 428
  d = ctx->state[3];
#line 429
  e = ctx->state[4];
#line 430
  f = ctx->state[5];
#line 431
  g = ctx->state[6];
#line 432
  h = ctx->state[7];
#line 437
  ctx->total[0] += len;
#line 438
  if (ctx->total[0] < len) {
#line 439
    (ctx->total[1]) ++;
  }
#line 459
  while ((unsigned int )words < (unsigned int )endp) {
#line 465
    t = 0;
#line 465
    while (t < 16) {
#line 467
      x[t] = (unsigned int )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 468
      words ++;
#line 465
      t ++;
    }
#line 471
    while (1) {
#line 471
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 471
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (unsigned int )sha256_round_constants[0]) + x[0];
#line 471
      d += t1;
#line 471
      h = t0 + t1;
#line 471
      break;
    }
#line 472
    while (1) {
#line 472
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 472
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (unsigned int )sha256_round_constants[1]) + x[1];
#line 472
      c += t1;
#line 472
      g = t0 + t1;
#line 472
      break;
    }
#line 473
    while (1) {
#line 473
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 473
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (unsigned int )sha256_round_constants[2]) + x[2];
#line 473
      b += t1;
#line 473
      f = t0 + t1;
#line 473
      break;
    }
#line 474
    while (1) {
#line 474
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 474
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (unsigned int )sha256_round_constants[3]) + x[3];
#line 474
      a += t1;
#line 474
      e = t0 + t1;
#line 474
      break;
    }
#line 475
    while (1) {
#line 475
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 475
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (unsigned int )sha256_round_constants[4]) + x[4];
#line 475
      h += t1;
#line 475
      d = t0 + t1;
#line 475
      break;
    }
#line 476
    while (1) {
#line 476
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 476
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (unsigned int )sha256_round_constants[5]) + x[5];
#line 476
      g += t1;
#line 476
      c = t0 + t1;
#line 476
      break;
    }
#line 477
    while (1) {
#line 477
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 477
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (unsigned int )sha256_round_constants[6]) + x[6];
#line 477
      f += t1;
#line 477
      b = t0 + t1;
#line 477
      break;
    }
#line 478
    while (1) {
#line 478
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 478
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (unsigned int )sha256_round_constants[7]) + x[7];
#line 478
      e += t1;
#line 478
      a = t0 + t1;
#line 478
      break;
    }
#line 479
    while (1) {
#line 479
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 479
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (unsigned int )sha256_round_constants[8]) + x[8];
#line 479
      d += t1;
#line 479
      h = t0 + t1;
#line 479
      break;
    }
#line 480
    while (1) {
#line 480
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 480
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (unsigned int )sha256_round_constants[9]) + x[9];
#line 480
      c += t1;
#line 480
      g = t0 + t1;
#line 480
      break;
    }
#line 481
    while (1) {
#line 481
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 481
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (unsigned int )sha256_round_constants[10]) + x[10];
#line 481
      b += t1;
#line 481
      f = t0 + t1;
#line 481
      break;
    }
#line 482
    while (1) {
#line 482
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 482
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (unsigned int )sha256_round_constants[11]) + x[11];
#line 482
      a += t1;
#line 482
      e = t0 + t1;
#line 482
      break;
    }
#line 483
    while (1) {
#line 483
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 483
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (unsigned int )sha256_round_constants[12]) + x[12];
#line 483
      h += t1;
#line 483
      d = t0 + t1;
#line 483
      break;
    }
#line 484
    while (1) {
#line 484
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 484
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (unsigned int )sha256_round_constants[13]) + x[13];
#line 484
      g += t1;
#line 484
      c = t0 + t1;
#line 484
      break;
    }
#line 485
    while (1) {
#line 485
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 485
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (unsigned int )sha256_round_constants[14]) + x[14];
#line 485
      f += t1;
#line 485
      b = t0 + t1;
#line 485
      break;
    }
#line 486
    while (1) {
#line 486
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 486
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (unsigned int )sha256_round_constants[15]) + x[15];
#line 486
      e += t1;
#line 486
      a = t0 + t1;
#line 486
      break;
    }
#line 487
    while (1) {
#line 487
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 487
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 487
      x[0] = tm;
#line 487
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (unsigned int )sha256_round_constants[16]) + x[0];
#line 487
      d += t1;
#line 487
      h = t0 + t1;
#line 487
      break;
    }
#line 488
    while (1) {
#line 488
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 488
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 488
      x[1] = tm;
#line 488
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (unsigned int )sha256_round_constants[17]) + x[1];
#line 488
      c += t1;
#line 488
      g = t0 + t1;
#line 488
      break;
    }
#line 489
    while (1) {
#line 489
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 489
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 489
      x[2] = tm;
#line 489
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (unsigned int )sha256_round_constants[18]) + x[2];
#line 489
      b += t1;
#line 489
      f = t0 + t1;
#line 489
      break;
    }
#line 490
    while (1) {
#line 490
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 490
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 490
      x[3] = tm;
#line 490
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (unsigned int )sha256_round_constants[19]) + x[3];
#line 490
      a += t1;
#line 490
      e = t0 + t1;
#line 490
      break;
    }
#line 491
    while (1) {
#line 491
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 491
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 491
      x[4] = tm;
#line 491
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (unsigned int )sha256_round_constants[20]) + x[4];
#line 491
      h += t1;
#line 491
      d = t0 + t1;
#line 491
      break;
    }
#line 492
    while (1) {
#line 492
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 492
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 492
      x[5] = tm;
#line 492
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (unsigned int )sha256_round_constants[21]) + x[5];
#line 492
      g += t1;
#line 492
      c = t0 + t1;
#line 492
      break;
    }
#line 493
    while (1) {
#line 493
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 493
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 493
      x[6] = tm;
#line 493
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (unsigned int )sha256_round_constants[22]) + x[6];
#line 493
      f += t1;
#line 493
      b = t0 + t1;
#line 493
      break;
    }
#line 494
    while (1) {
#line 494
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 494
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 494
      x[7] = tm;
#line 494
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (unsigned int )sha256_round_constants[23]) + x[7];
#line 494
      e += t1;
#line 494
      a = t0 + t1;
#line 494
      break;
    }
#line 495
    while (1) {
#line 495
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 495
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 495
      x[8] = tm;
#line 495
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (unsigned int )sha256_round_constants[24]) + x[8];
#line 495
      d += t1;
#line 495
      h = t0 + t1;
#line 495
      break;
    }
#line 496
    while (1) {
#line 496
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 496
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 496
      x[9] = tm;
#line 496
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (unsigned int )sha256_round_constants[25]) + x[9];
#line 496
      c += t1;
#line 496
      g = t0 + t1;
#line 496
      break;
    }
#line 497
    while (1) {
#line 497
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 497
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 497
      x[10] = tm;
#line 497
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (unsigned int )sha256_round_constants[26]) + x[10];
#line 497
      b += t1;
#line 497
      f = t0 + t1;
#line 497
      break;
    }
#line 498
    while (1) {
#line 498
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 498
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 498
      x[11] = tm;
#line 498
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (unsigned int )sha256_round_constants[27]) + x[11];
#line 498
      a += t1;
#line 498
      e = t0 + t1;
#line 498
      break;
    }
#line 499
    while (1) {
#line 499
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 499
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 499
      x[12] = tm;
#line 499
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (unsigned int )sha256_round_constants[28]) + x[12];
#line 499
      h += t1;
#line 499
      d = t0 + t1;
#line 499
      break;
    }
#line 500
    while (1) {
#line 500
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 500
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 500
      x[13] = tm;
#line 500
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (unsigned int )sha256_round_constants[29]) + x[13];
#line 500
      g += t1;
#line 500
      c = t0 + t1;
#line 500
      break;
    }
#line 501
    while (1) {
#line 501
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 501
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 501
      x[14] = tm;
#line 501
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (unsigned int )sha256_round_constants[30]) + x[14];
#line 501
      f += t1;
#line 501
      b = t0 + t1;
#line 501
      break;
    }
#line 502
    while (1) {
#line 502
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 502
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 502
      x[15] = tm;
#line 502
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (unsigned int )sha256_round_constants[31]) + x[15];
#line 502
      e += t1;
#line 502
      a = t0 + t1;
#line 502
      break;
    }
#line 503
    while (1) {
#line 503
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 503
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 503
      x[0] = tm;
#line 503
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (unsigned int )sha256_round_constants[32]) + x[0];
#line 503
      d += t1;
#line 503
      h = t0 + t1;
#line 503
      break;
    }
#line 504
    while (1) {
#line 504
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 504
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 504
      x[1] = tm;
#line 504
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (unsigned int )sha256_round_constants[33]) + x[1];
#line 504
      c += t1;
#line 504
      g = t0 + t1;
#line 504
      break;
    }
#line 505
    while (1) {
#line 505
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 505
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 505
      x[2] = tm;
#line 505
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (unsigned int )sha256_round_constants[34]) + x[2];
#line 505
      b += t1;
#line 505
      f = t0 + t1;
#line 505
      break;
    }
#line 506
    while (1) {
#line 506
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 506
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 506
      x[3] = tm;
#line 506
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (unsigned int )sha256_round_constants[35]) + x[3];
#line 506
      a += t1;
#line 506
      e = t0 + t1;
#line 506
      break;
    }
#line 507
    while (1) {
#line 507
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 507
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 507
      x[4] = tm;
#line 507
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (unsigned int )sha256_round_constants[36]) + x[4];
#line 507
      h += t1;
#line 507
      d = t0 + t1;
#line 507
      break;
    }
#line 508
    while (1) {
#line 508
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 508
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 508
      x[5] = tm;
#line 508
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (unsigned int )sha256_round_constants[37]) + x[5];
#line 508
      g += t1;
#line 508
      c = t0 + t1;
#line 508
      break;
    }
#line 509
    while (1) {
#line 509
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 509
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 509
      x[6] = tm;
#line 509
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (unsigned int )sha256_round_constants[38]) + x[6];
#line 509
      f += t1;
#line 509
      b = t0 + t1;
#line 509
      break;
    }
#line 510
    while (1) {
#line 510
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 510
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 510
      x[7] = tm;
#line 510
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (unsigned int )sha256_round_constants[39]) + x[7];
#line 510
      e += t1;
#line 510
      a = t0 + t1;
#line 510
      break;
    }
#line 511
    while (1) {
#line 511
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 511
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 511
      x[8] = tm;
#line 511
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (unsigned int )sha256_round_constants[40]) + x[8];
#line 511
      d += t1;
#line 511
      h = t0 + t1;
#line 511
      break;
    }
#line 512
    while (1) {
#line 512
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 512
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 512
      x[9] = tm;
#line 512
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (unsigned int )sha256_round_constants[41]) + x[9];
#line 512
      c += t1;
#line 512
      g = t0 + t1;
#line 512
      break;
    }
#line 513
    while (1) {
#line 513
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 513
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 513
      x[10] = tm;
#line 513
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (unsigned int )sha256_round_constants[42]) + x[10];
#line 513
      b += t1;
#line 513
      f = t0 + t1;
#line 513
      break;
    }
#line 514
    while (1) {
#line 514
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 514
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 514
      x[11] = tm;
#line 514
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (unsigned int )sha256_round_constants[43]) + x[11];
#line 514
      a += t1;
#line 514
      e = t0 + t1;
#line 514
      break;
    }
#line 515
    while (1) {
#line 515
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 515
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 515
      x[12] = tm;
#line 515
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (unsigned int )sha256_round_constants[44]) + x[12];
#line 515
      h += t1;
#line 515
      d = t0 + t1;
#line 515
      break;
    }
#line 516
    while (1) {
#line 516
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 516
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 516
      x[13] = tm;
#line 516
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (unsigned int )sha256_round_constants[45]) + x[13];
#line 516
      g += t1;
#line 516
      c = t0 + t1;
#line 516
      break;
    }
#line 517
    while (1) {
#line 517
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 517
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 517
      x[14] = tm;
#line 517
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (unsigned int )sha256_round_constants[46]) + x[14];
#line 517
      f += t1;
#line 517
      b = t0 + t1;
#line 517
      break;
    }
#line 518
    while (1) {
#line 518
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 518
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 518
      x[15] = tm;
#line 518
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (unsigned int )sha256_round_constants[47]) + x[15];
#line 518
      e += t1;
#line 518
      a = t0 + t1;
#line 518
      break;
    }
#line 519
    while (1) {
#line 519
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 519
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 519
      x[0] = tm;
#line 519
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (unsigned int )sha256_round_constants[48]) + x[0];
#line 519
      d += t1;
#line 519
      h = t0 + t1;
#line 519
      break;
    }
#line 520
    while (1) {
#line 520
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 520
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 520
      x[1] = tm;
#line 520
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (unsigned int )sha256_round_constants[49]) + x[1];
#line 520
      c += t1;
#line 520
      g = t0 + t1;
#line 520
      break;
    }
#line 521
    while (1) {
#line 521
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 521
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 521
      x[2] = tm;
#line 521
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (unsigned int )sha256_round_constants[50]) + x[2];
#line 521
      b += t1;
#line 521
      f = t0 + t1;
#line 521
      break;
    }
#line 522
    while (1) {
#line 522
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 522
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 522
      x[3] = tm;
#line 522
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (unsigned int )sha256_round_constants[51]) + x[3];
#line 522
      a += t1;
#line 522
      e = t0 + t1;
#line 522
      break;
    }
#line 523
    while (1) {
#line 523
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 523
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 523
      x[4] = tm;
#line 523
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (unsigned int )sha256_round_constants[52]) + x[4];
#line 523
      h += t1;
#line 523
      d = t0 + t1;
#line 523
      break;
    }
#line 524
    while (1) {
#line 524
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 524
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 524
      x[5] = tm;
#line 524
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (unsigned int )sha256_round_constants[53]) + x[5];
#line 524
      g += t1;
#line 524
      c = t0 + t1;
#line 524
      break;
    }
#line 525
    while (1) {
#line 525
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 525
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 525
      x[6] = tm;
#line 525
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (unsigned int )sha256_round_constants[54]) + x[6];
#line 525
      f += t1;
#line 525
      b = t0 + t1;
#line 525
      break;
    }
#line 526
    while (1) {
#line 526
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 526
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 526
      x[7] = tm;
#line 526
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (unsigned int )sha256_round_constants[55]) + x[7];
#line 526
      e += t1;
#line 526
      a = t0 + t1;
#line 526
      break;
    }
#line 527
    while (1) {
#line 527
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 527
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 527
      x[8] = tm;
#line 527
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (unsigned int )sha256_round_constants[56]) + x[8];
#line 527
      d += t1;
#line 527
      h = t0 + t1;
#line 527
      break;
    }
#line 528
    while (1) {
#line 528
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 528
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 528
      x[9] = tm;
#line 528
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (unsigned int )sha256_round_constants[57]) + x[9];
#line 528
      c += t1;
#line 528
      g = t0 + t1;
#line 528
      break;
    }
#line 529
    while (1) {
#line 529
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 529
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 529
      x[10] = tm;
#line 529
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (unsigned int )sha256_round_constants[58]) + x[10];
#line 529
      b += t1;
#line 529
      f = t0 + t1;
#line 529
      break;
    }
#line 530
    while (1) {
#line 530
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 530
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 530
      x[11] = tm;
#line 530
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (unsigned int )sha256_round_constants[59]) + x[11];
#line 530
      a += t1;
#line 530
      e = t0 + t1;
#line 530
      break;
    }
#line 531
    while (1) {
#line 531
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 531
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 531
      x[12] = tm;
#line 531
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (unsigned int )sha256_round_constants[60]) + x[12];
#line 531
      h += t1;
#line 531
      d = t0 + t1;
#line 531
      break;
    }
#line 532
    while (1) {
#line 532
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 532
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 532
      x[13] = tm;
#line 532
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (unsigned int )sha256_round_constants[61]) + x[13];
#line 532
      g += t1;
#line 532
      c = t0 + t1;
#line 532
      break;
    }
#line 533
    while (1) {
#line 533
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 533
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 533
      x[14] = tm;
#line 533
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (unsigned int )sha256_round_constants[62]) + x[14];
#line 533
      f += t1;
#line 533
      b = t0 + t1;
#line 533
      break;
    }
#line 534
    while (1) {
#line 534
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 534
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 534
      x[15] = tm;
#line 534
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (unsigned int )sha256_round_constants[63]) + x[15];
#line 534
      e += t1;
#line 534
      a = t0 + t1;
#line 534
      break;
    }
#line 536
    __cil_tmp = ctx->state[0] + a;
#line 536
    ctx->state[0] = __cil_tmp;
#line 536
    a = __cil_tmp;
#line 537
    __cil_tmp___0 = ctx->state[1] + b;
#line 537
    ctx->state[1] = __cil_tmp___0;
#line 537
    b = __cil_tmp___0;
#line 538
    __cil_tmp___1 = ctx->state[2] + c;
#line 538
    ctx->state[2] = __cil_tmp___1;
#line 538
    c = __cil_tmp___1;
#line 539
    __cil_tmp___2 = ctx->state[3] + d;
#line 539
    ctx->state[3] = __cil_tmp___2;
#line 539
    d = __cil_tmp___2;
#line 540
    __cil_tmp___3 = ctx->state[4] + e;
#line 540
    ctx->state[4] = __cil_tmp___3;
#line 540
    e = __cil_tmp___3;
#line 541
    __cil_tmp___4 = ctx->state[5] + f;
#line 541
    ctx->state[5] = __cil_tmp___4;
#line 541
    f = __cil_tmp___4;
#line 542
    __cil_tmp___5 = ctx->state[6] + g;
#line 542
    ctx->state[6] = __cil_tmp___5;
#line 542
    g = __cil_tmp___5;
#line 543
    __cil_tmp___6 = ctx->state[7] + h;
#line 543
    ctx->state[7] = __cil_tmp___6;
#line 543
    h = __cil_tmp___6;
  }
#line 545
  return;
}
}
#line 1 "sha512.o"
#pragma merger(0,"/tmp/cil-pfilVeZb.i","-g,-O2")
#line 37 "sha512.h"
void sha512_init_ctx(struct sha512_ctx *ctx ) ;
#line 38
void sha384_init_ctx(struct sha512_ctx *ctx ) ;
#line 44
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
#line 51
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
#line 61
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
#line 62
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
#line 71
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
#line 72
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
#line 78
int sha512_stream(FILE *stream , void *resblock ) ;
#line 79
int sha384_stream(FILE *stream , void *resblock ) ;
#line 85
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 86
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 55 "sha512.c"
static unsigned char const   fillbuf___2[128]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 63 "sha512.c"
void sha512_init_ctx(struct sha512_ctx *ctx ) 
{ u64 __cil_tmp ;

  {
#line 66
  ctx->state[0] = (1779033703ULL << 32) + 4089235720ULL;
#line 67
  ctx->state[1] = (3144134277ULL << 32) + 2227873595ULL;
#line 68
  ctx->state[2] = (1013904242ULL << 32) + 4271175723ULL;
#line 69
  ctx->state[3] = (2773480762ULL << 32) + 1595750129ULL;
#line 70
  ctx->state[4] = (1359893119ULL << 32) + 2917565137ULL;
#line 71
  ctx->state[5] = (2600822924ULL << 32) + 725511199ULL;
#line 72
  ctx->state[6] = (528734635ULL << 32) + 4215389547ULL;
#line 73
  ctx->state[7] = (1541459225ULL << 32) + 327033209ULL;
#line 75
  __cil_tmp = 0ULL;
#line 75
  ctx->total[1] = __cil_tmp;
#line 75
  ctx->total[0] = __cil_tmp;
#line 76
  ctx->buflen = 0U;
#line 77
  return;
}
}
#line 79 "sha512.c"
void sha384_init_ctx(struct sha512_ctx *ctx ) 
{ u64 __cil_tmp ;

  {
#line 82
  ctx->state[0] = (3418070365ULL << 32) + 3238371032ULL;
#line 83
  ctx->state[1] = (1654270250ULL << 32) + 914150663ULL;
#line 84
  ctx->state[2] = (2438529370ULL << 32) + 812702999ULL;
#line 85
  ctx->state[3] = (355462360ULL << 32) + 4144912697ULL;
#line 86
  ctx->state[4] = (1731405415ULL << 32) + 4290775857ULL;
#line 87
  ctx->state[5] = (2394180231ULL << 32) + 1750603025ULL;
#line 88
  ctx->state[6] = (3675008525ULL << 32) + 1694076839ULL;
#line 89
  ctx->state[7] = (1203062813ULL << 32) + 3204075428ULL;
#line 91
  __cil_tmp = 0ULL;
#line 91
  ctx->total[1] = __cil_tmp;
#line 91
  ctx->total[0] = __cil_tmp;
#line 92
  ctx->buflen = 0U;
#line 93
  return;
}
}
#line 100 "sha512.c"
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ int i ;

  {
#line 105
  i = 0;
#line 105
  while (i < 8) {
#line 106
    *((u64 *)resbuf + i) = (((ctx->state[i] << 56) | ((ctx->state[i] & 65280ULL) << 40)) | (((ctx->state[i] & 16711680ULL) << 24) | ((ctx->state[i] & 4278190080ULL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080ULL) | ((ctx->state[i] >> 24) & 16711680ULL)) | (((ctx->state[i] >> 40) & 65280ULL) | (ctx->state[i] >> 56)));
#line 105
    i ++;
  }
#line 108
  return (resbuf);
}
}
#line 111 "sha512.c"
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ int i ;

  {
#line 116
  i = 0;
#line 116
  while (i < 6) {
#line 117
    *((u64 *)resbuf + i) = (((ctx->state[i] << 56) | ((ctx->state[i] & 65280ULL) << 40)) | (((ctx->state[i] & 16711680ULL) << 24) | ((ctx->state[i] & 4278190080ULL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080ULL) | ((ctx->state[i] >> 24) & 16711680ULL)) | (((ctx->state[i] >> 40) & 65280ULL) | (ctx->state[i] >> 56)));
#line 116
    i ++;
  }
#line 119
  return (resbuf);
}
}
#line 127 "sha512.c"
static void sha512_conclude_ctx(struct sha512_ctx *ctx ) 
{ size_t bytes ;
  size_t size ;

  {
#line 131
  bytes = ctx->buflen;
#line 132
  size = (unsigned int )(bytes < 112U ? 16 : 32);
#line 135
  ctx->total[0] += (unsigned long long )bytes;
#line 136
  if (ctx->total[0] < (unsigned long long )bytes) {
#line 137
    (ctx->total[1]) ++;
  }
#line 140
  ctx->buffer[size - 2U] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) << 56) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 65280ULL) << 40)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 16711680ULL) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 4278190080ULL) << 8))) | ((((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 8) & 4278190080ULL) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 24) & 16711680ULL)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 40) & 65280ULL) | (((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 56)));
#line 142
  ctx->buffer[size - 1U] = ((((ctx->total[0] << 3) << 56) | (((ctx->total[0] << 3) & 65280ULL) << 40)) | ((((ctx->total[0] << 3) & 16711680ULL) << 24) | (((ctx->total[0] << 3) & 4278190080ULL) << 8))) | (((((ctx->total[0] << 3) >> 8) & 4278190080ULL) | (((ctx->total[0] << 3) >> 24) & 16711680ULL)) | ((((ctx->total[0] << 3) >> 40) & 65280ULL) | ((ctx->total[0] << 3) >> 56)));
#line 144
  memcpy((void *)((char *)(ctx->buffer) + bytes), (void const   *)(fillbuf___2), (size - 2U) * 8U - bytes);
#line 147
  sha512_process_block((void const   *)(ctx->buffer), size * 8U, ctx);
#line 148
  return;
}
}
#line 150 "sha512.c"
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ void *__cil_tmp ;

  {
#line 153
  sha512_conclude_ctx(ctx);
#line 154
  __cil_tmp = sha512_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
#line 154
  return (__cil_tmp);
}
}
#line 157 "sha512.c"
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ void *__cil_tmp ;

  {
#line 160
  sha512_conclude_ctx(ctx);
#line 161
  __cil_tmp = sha384_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
#line 161
  return (__cil_tmp);
}
}
#line 167 "sha512.c"
int sha512_stream(FILE *stream , void *resblock ) 
{ struct sha512_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 175
  sha512_init_ctx(& ctx);
#line 178
  while (1) {
#line 184
    sum = 0U;
#line 187
    while (1) {
#line 189
      n = fread((void *)(buffer + sum), 1U, 4096U - sum, stream);
#line 191
      sum += n;
#line 193
      if (sum == 4096U) {
#line 194
        break;
      }
#line 196
      if (n == 0U) {
#line 201
        __cil_tmp = ferror(stream);
#line 201
        if (__cil_tmp) {
#line 202
          return (1);
        }
#line 203
        goto process_partial_block;
      }
#line 209
      __cil_tmp___0 = feof(stream);
#line 209
      if (__cil_tmp___0) {
#line 210
        goto process_partial_block;
      }
    }
#line 216
    sha512_process_block((void const   *)(buffer), 4096U, & ctx);
  }
  process_partial_block: ;
#line 222
  if (sum > 0U) {
#line 223
    sha512_process_bytes((void const   *)(buffer), sum, & ctx);
  }
#line 226
  sha512_finish_ctx(& ctx, resblock);
#line 227
  return (0);
}
}
#line 231 "sha512.c"
int sha384_stream(FILE *stream , void *resblock ) 
{ struct sha512_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 239
  sha384_init_ctx(& ctx);
#line 242
  while (1) {
#line 248
    sum = 0U;
#line 251
    while (1) {
#line 253
      n = fread((void *)(buffer + sum), 1U, 4096U - sum, stream);
#line 255
      sum += n;
#line 257
      if (sum == 4096U) {
#line 258
        break;
      }
#line 260
      if (n == 0U) {
#line 265
        __cil_tmp = ferror(stream);
#line 265
        if (__cil_tmp) {
#line 266
          return (1);
        }
#line 267
        goto process_partial_block;
      }
#line 273
      __cil_tmp___0 = feof(stream);
#line 273
      if (__cil_tmp___0) {
#line 274
        goto process_partial_block;
      }
    }
#line 280
    sha512_process_block((void const   *)(buffer), 4096U, & ctx);
  }
  process_partial_block: ;
#line 286
  if (sum > 0U) {
#line 287
    sha512_process_bytes((void const   *)(buffer), sum, & ctx);
  }
#line 290
  sha384_finish_ctx(& ctx, resblock);
#line 291
  return (0);
}
}
#line 298 "sha512.c"
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha512_ctx ctx ;
  void *__cil_tmp ;

  {
#line 304
  sha512_init_ctx(& ctx);
#line 307
  sha512_process_bytes((void const   *)buffer, len, & ctx);
#line 310
  __cil_tmp = sha512_finish_ctx(& ctx, resblock);
#line 310
  return (__cil_tmp);
}
}
#line 313 "sha512.c"
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) 
{ struct sha512_ctx ctx ;
  void *__cil_tmp ;

  {
#line 319
  sha384_init_ctx(& ctx);
#line 322
  sha512_process_bytes((void const   *)buffer, len, & ctx);
#line 325
  __cil_tmp = sha384_finish_ctx(& ctx, resblock);
#line 325
  return (__cil_tmp);
}
}
#line 328 "sha512.c"
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ size_t left_over ;
  size_t add ;
  void *__cil_tmp ;
  size_t left_over___0 ;

  {
#line 333
  if (ctx->buflen != 0U) {
#line 335
    left_over = ctx->buflen;
#line 336
    add = 256U - left_over > len ? len : 256U - left_over;
#line 338
    memcpy((void *)((char *)(ctx->buffer) + left_over), buffer, add);
#line 339
    ctx->buflen += add;
#line 341
    if (ctx->buflen > 128U) {
#line 343
      sha512_process_block((void const   *)(ctx->buffer), ctx->buflen & 4294967232U,
                           ctx);
#line 345
      ctx->buflen &= 127U;
#line 347
      memcpy((void *)(ctx->buffer), (void const   *)((char *)(ctx->buffer) + ((left_over + add) & 4294967168U)),
             ctx->buflen);
    }
#line 352
    buffer = (void const   *)((char const   *)buffer + add);
#line 353
    len -= add;
  }
#line 357
  if (len >= 128U) {
#line 362
    if ((unsigned int )buffer % (unsigned int )((char *)(& ((struct __anonstruct_9___1 *)0)->x)) != 0U) {
#line 363
      while (len > 128U) {
#line 365
        __cil_tmp = memcpy((void *)(ctx->buffer), buffer, 128U);
#line 365
        sha512_process_block((void const   *)__cil_tmp, 128U, ctx);
#line 366
        buffer = (void const   *)((char const   *)buffer + 128);
#line 367
        len -= 128U;
      }
    } else {
#line 372
      sha512_process_block(buffer, len & 4294967168U, ctx);
#line 373
      buffer = (void const   *)((char const   *)buffer + (len & 4294967168U));
#line 374
      len &= 127U;
    }
  }
#line 379
  if (len > 0U) {
#line 381
    left_over___0 = ctx->buflen;
#line 383
    memcpy((void *)((char *)(ctx->buffer) + left_over___0), buffer, len);
#line 384
    left_over___0 += len;
#line 385
    if (left_over___0 >= 128U) {
#line 387
      sha512_process_block((void const   *)(ctx->buffer), 128U, ctx);
#line 388
      left_over___0 -= 128U;
#line 389
      memcpy((void *)(ctx->buffer), (void const   *)(& ctx->buffer[16]), left_over___0);
    }
#line 391
    ctx->buflen = left_over___0;
  }
#line 393
  return;
}
}
#line 399 "sha512.c"
static u64 const   sha512_round_constants[80]  = 
#line 399
  {      (unsigned long long const   )((1116352408ULL << 32) + 3609767458ULL),      (unsigned long long const   )((1899447441ULL << 32) + 602891725ULL),      (unsigned long long const   )((3049323471ULL << 32) + 3964484399ULL),      (unsigned long long const   )((3921009573ULL << 32) + 2173295548ULL), 
        (unsigned long long const   )((961987163ULL << 32) + 4081628472ULL),      (unsigned long long const   )((1508970993ULL << 32) + 3053834265ULL),      (unsigned long long const   )((2453635748ULL << 32) + 2937671579ULL),      (unsigned long long const   )((2870763221ULL << 32) + 3664609560ULL), 
        (unsigned long long const   )((3624381080ULL << 32) + 2734883394ULL),      (unsigned long long const   )((310598401ULL << 32) + 1164996542ULL),      (unsigned long long const   )((607225278ULL << 32) + 1323610764ULL),      (unsigned long long const   )((1426881987ULL << 32) + 3590304994ULL), 
        (unsigned long long const   )((1925078388ULL << 32) + 4068182383ULL),      (unsigned long long const   )((2162078206ULL << 32) + 991336113ULL),      (unsigned long long const   )((2614888103ULL << 32) + 633803317ULL),      (unsigned long long const   )((3248222580ULL << 32) + 3479774868ULL), 
        (unsigned long long const   )((3835390401ULL << 32) + 2666613458ULL),      (unsigned long long const   )((4022224774ULL << 32) + 944711139ULL),      (unsigned long long const   )((264347078ULL << 32) + 2341262773ULL),      (unsigned long long const   )((604807628ULL << 32) + 2007800933ULL), 
        (unsigned long long const   )((770255983ULL << 32) + 1495990901ULL),      (unsigned long long const   )((1249150122ULL << 32) + 1856431235ULL),      (unsigned long long const   )((1555081692ULL << 32) + 3175218132ULL),      (unsigned long long const   )((1996064986ULL << 32) + 2198950837ULL), 
        (unsigned long long const   )((2554220882ULL << 32) + 3999719339ULL),      (unsigned long long const   )((2821834349ULL << 32) + 766784016ULL),      (unsigned long long const   )((2952996808ULL << 32) + 2566594879ULL),      (unsigned long long const   )((3210313671ULL << 32) + 3203337956ULL), 
        (unsigned long long const   )((3336571891ULL << 32) + 1034457026ULL),      (unsigned long long const   )((3584528711ULL << 32) + 2466948901ULL),      (unsigned long long const   )((113926993ULL << 32) + 3758326383ULL),      (unsigned long long const   )((338241895ULL << 32) + 168717936ULL), 
        (unsigned long long const   )((666307205ULL << 32) + 1188179964ULL),      (unsigned long long const   )((773529912ULL << 32) + 1546045734ULL),      (unsigned long long const   )((1294757372ULL << 32) + 1522805485ULL),      (unsigned long long const   )((1396182291ULL << 32) + 2643833823ULL), 
        (unsigned long long const   )((1695183700ULL << 32) + 2343527390ULL),      (unsigned long long const   )((1986661051ULL << 32) + 1014477480ULL),      (unsigned long long const   )((2177026350ULL << 32) + 1206759142ULL),      (unsigned long long const   )((2456956037ULL << 32) + 344077627ULL), 
        (unsigned long long const   )((2730485921ULL << 32) + 1290863460ULL),      (unsigned long long const   )((2820302411ULL << 32) + 3158454273ULL),      (unsigned long long const   )((3259730800ULL << 32) + 3505952657ULL),      (unsigned long long const   )((3345764771ULL << 32) + 106217008ULL), 
        (unsigned long long const   )((3516065817ULL << 32) + 3606008344ULL),      (unsigned long long const   )((3600352804ULL << 32) + 1432725776ULL),      (unsigned long long const   )((4094571909ULL << 32) + 1467031594ULL),      (unsigned long long const   )((275423344ULL << 32) + 851169720ULL), 
        (unsigned long long const   )((430227734ULL << 32) + 3100823752ULL),      (unsigned long long const   )((506948616ULL << 32) + 1363258195ULL),      (unsigned long long const   )((659060556ULL << 32) + 3750685593ULL),      (unsigned long long const   )((883997877ULL << 32) + 3785050280ULL), 
        (unsigned long long const   )((958139571ULL << 32) + 3318307427ULL),      (unsigned long long const   )((1322822218ULL << 32) + 3812723403ULL),      (unsigned long long const   )((1537002063ULL << 32) + 2003034995ULL),      (unsigned long long const   )((1747873779ULL << 32) + 3602036899ULL), 
        (unsigned long long const   )((1955562222ULL << 32) + 1575990012ULL),      (unsigned long long const   )((2024104815ULL << 32) + 1125592928ULL),      (unsigned long long const   )((2227730452ULL << 32) + 2716904306ULL),      (unsigned long long const   )((2361852424ULL << 32) + 442776044ULL), 
        (unsigned long long const   )((2428436474ULL << 32) + 593698344ULL),      (unsigned long long const   )((2756734187ULL << 32) + 3733110249ULL),      (unsigned long long const   )((3204031479ULL << 32) + 2999351573ULL),      (unsigned long long const   )((3329325298ULL << 32) + 3815920427ULL), 
        (unsigned long long const   )((3391569614ULL << 32) + 3928383900ULL),      (unsigned long long const   )((3515267271ULL << 32) + 566280711ULL),      (unsigned long long const   )((3940187606ULL << 32) + 3454069534ULL),      (unsigned long long const   )((4118630271ULL << 32) + 4000239992ULL), 
        (unsigned long long const   )((116418474ULL << 32) + 1914138554ULL),      (unsigned long long const   )((174292421ULL << 32) + 2731055270ULL),      (unsigned long long const   )((289380356ULL << 32) + 3203993006ULL),      (unsigned long long const   )((460393269ULL << 32) + 320620315ULL), 
        (unsigned long long const   )((685471733ULL << 32) + 587496836ULL),      (unsigned long long const   )((852142971ULL << 32) + 1086792851ULL),      (unsigned long long const   )((1017036298ULL << 32) + 365543100ULL),      (unsigned long long const   )((1126000580ULL << 32) + 2618297676ULL), 
        (unsigned long long const   )((1288033470ULL << 32) + 3409855158ULL),      (unsigned long long const   )((1501505948ULL << 32) + 4234509866ULL),      (unsigned long long const   )((1607167915ULL << 32) + 987167468ULL),      (unsigned long long const   )((1816402316ULL << 32) + 1246189591ULL)};
#line 450 "sha512.c"
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ u64 const   *words ;
  u64 const   *endp ;
  u64 x[16] ;
  u64 a ;
  u64 b ;
  u64 c ;
  u64 d ;
  u64 e ;
  u64 f ;
  u64 g ;
  u64 h ;
  int t ;
  u64 t0 ;
  u64 t1 ;
  u64 t0___0 ;
  u64 t1___0 ;
  u64 t0___1 ;
  u64 t1___1 ;
  u64 t0___2 ;
  u64 t1___2 ;
  u64 t0___3 ;
  u64 t1___3 ;
  u64 t0___4 ;
  u64 t1___4 ;
  u64 t0___5 ;
  u64 t1___5 ;
  u64 t0___6 ;
  u64 t1___6 ;
  u64 t0___7 ;
  u64 t1___7 ;
  u64 t0___8 ;
  u64 t1___8 ;
  u64 t0___9 ;
  u64 t1___9 ;
  u64 t0___10 ;
  u64 t1___10 ;
  u64 t0___11 ;
  u64 t1___11 ;
  u64 t0___12 ;
  u64 t1___12 ;
  u64 t0___13 ;
  u64 t1___13 ;
  u64 t0___14 ;
  u64 t1___14 ;
  u64 t0___15 ;
  u64 t1___15 ;
  u64 t0___16 ;
  u64 t1___16 ;
  u64 t0___17 ;
  u64 t1___17 ;
  u64 t0___18 ;
  u64 t1___18 ;
  u64 t0___19 ;
  u64 t1___19 ;
  u64 t0___20 ;
  u64 t1___20 ;
  u64 t0___21 ;
  u64 t1___21 ;
  u64 t0___22 ;
  u64 t1___22 ;
  u64 t0___23 ;
  u64 t1___23 ;
  u64 t0___24 ;
  u64 t1___24 ;
  u64 t0___25 ;
  u64 t1___25 ;
  u64 t0___26 ;
  u64 t1___26 ;
  u64 t0___27 ;
  u64 t1___27 ;
  u64 t0___28 ;
  u64 t1___28 ;
  u64 t0___29 ;
  u64 t1___29 ;
  u64 t0___30 ;
  u64 t1___30 ;
  u64 t0___31 ;
  u64 t1___31 ;
  u64 t0___32 ;
  u64 t1___32 ;
  u64 t0___33 ;
  u64 t1___33 ;
  u64 t0___34 ;
  u64 t1___34 ;
  u64 t0___35 ;
  u64 t1___35 ;
  u64 t0___36 ;
  u64 t1___36 ;
  u64 t0___37 ;
  u64 t1___37 ;
  u64 t0___38 ;
  u64 t1___38 ;
  u64 t0___39 ;
  u64 t1___39 ;
  u64 t0___40 ;
  u64 t1___40 ;
  u64 t0___41 ;
  u64 t1___41 ;
  u64 t0___42 ;
  u64 t1___42 ;
  u64 t0___43 ;
  u64 t1___43 ;
  u64 t0___44 ;
  u64 t1___44 ;
  u64 t0___45 ;
  u64 t1___45 ;
  u64 t0___46 ;
  u64 t1___46 ;
  u64 t0___47 ;
  u64 t1___47 ;
  u64 t0___48 ;
  u64 t1___48 ;
  u64 t0___49 ;
  u64 t1___49 ;
  u64 t0___50 ;
  u64 t1___50 ;
  u64 t0___51 ;
  u64 t1___51 ;
  u64 t0___52 ;
  u64 t1___52 ;
  u64 t0___53 ;
  u64 t1___53 ;
  u64 t0___54 ;
  u64 t1___54 ;
  u64 t0___55 ;
  u64 t1___55 ;
  u64 t0___56 ;
  u64 t1___56 ;
  u64 t0___57 ;
  u64 t1___57 ;
  u64 t0___58 ;
  u64 t1___58 ;
  u64 t0___59 ;
  u64 t1___59 ;
  u64 t0___60 ;
  u64 t1___60 ;
  u64 t0___61 ;
  u64 t1___61 ;
  u64 t0___62 ;
  u64 t1___62 ;
  u64 t0___63 ;
  u64 t1___63 ;
  u64 t0___64 ;
  u64 t1___64 ;
  u64 t0___65 ;
  u64 t1___65 ;
  u64 t0___66 ;
  u64 t1___66 ;
  u64 t0___67 ;
  u64 t1___67 ;
  u64 t0___68 ;
  u64 t1___68 ;
  u64 t0___69 ;
  u64 t1___69 ;
  u64 t0___70 ;
  u64 t1___70 ;
  u64 t0___71 ;
  u64 t1___71 ;
  u64 t0___72 ;
  u64 t1___72 ;
  u64 t0___73 ;
  u64 t1___73 ;
  u64 t0___74 ;
  u64 t1___74 ;
  u64 t0___75 ;
  u64 t1___75 ;
  u64 t0___76 ;
  u64 t1___76 ;
  u64 t0___77 ;
  u64 t1___77 ;
  u64 t0___78 ;
  u64 t1___78 ;
  u64 __cil_tmp ;
  u64 __cil_tmp___0 ;
  u64 __cil_tmp___1 ;
  u64 __cil_tmp___2 ;
  u64 __cil_tmp___3 ;
  u64 __cil_tmp___4 ;
  u64 __cil_tmp___5 ;
  u64 __cil_tmp___6 ;

  {
#line 453
  words = (u64 const   *)buffer;
#line 454
  endp = words + len / sizeof(u64 );
#line 456
  a = ctx->state[0];
#line 457
  b = ctx->state[1];
#line 458
  c = ctx->state[2];
#line 459
  d = ctx->state[3];
#line 460
  e = ctx->state[4];
#line 461
  f = ctx->state[5];
#line 462
  g = ctx->state[6];
#line 463
  h = ctx->state[7];
#line 468
  ctx->total[0] += (unsigned long long )len;
#line 469
  if (ctx->total[0] < (unsigned long long )len) {
#line 470
    (ctx->total[1]) ++;
  }
#line 495
  while ((unsigned int )words < (unsigned int )endp) {
#line 499
    t = 0;
#line 499
    while (t < 16) {
#line 501
      x[t] = (unsigned long long )((((*words << 56) | ((*words & 65280ULL) << 40)) | (((*words & 16711680ULL) << 24) | ((*words & 4278190080ULL) << 8))) | ((((*words >> 8) & 4278190080ULL) | ((*words >> 24) & 16711680ULL)) | (((*words >> 40) & 65280ULL) | (*words >> 56))));
#line 502
      words ++;
#line 499
      t ++;
    }
#line 505
    while (1) {
#line 505
      t0 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 505
      t1 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[0] + (unsigned long long const   )x[0])));
#line 505
      d += t1;
#line 505
      h = t0 + t1;
#line 505
      break;
    }
#line 506
    while (1) {
#line 506
      t0___0 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 506
      t1___0 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[1] + (unsigned long long const   )x[1])));
#line 506
      c += t1___0;
#line 506
      g = t0___0 + t1___0;
#line 506
      break;
    }
#line 507
    while (1) {
#line 507
      t0___1 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 507
      t1___1 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[2] + (unsigned long long const   )x[2])));
#line 507
      b += t1___1;
#line 507
      f = t0___1 + t1___1;
#line 507
      break;
    }
#line 508
    while (1) {
#line 508
      t0___2 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 508
      t1___2 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[3] + (unsigned long long const   )x[3])));
#line 508
      a += t1___2;
#line 508
      e = t0___2 + t1___2;
#line 508
      break;
    }
#line 509
    while (1) {
#line 509
      t0___3 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 509
      t1___3 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[4] + (unsigned long long const   )x[4])));
#line 509
      h += t1___3;
#line 509
      d = t0___3 + t1___3;
#line 509
      break;
    }
#line 510
    while (1) {
#line 510
      t0___4 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 510
      t1___4 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[5] + (unsigned long long const   )x[5])));
#line 510
      g += t1___4;
#line 510
      c = t0___4 + t1___4;
#line 510
      break;
    }
#line 511
    while (1) {
#line 511
      t0___5 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 511
      t1___5 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[6] + (unsigned long long const   )x[6])));
#line 511
      f += t1___5;
#line 511
      b = t0___5 + t1___5;
#line 511
      break;
    }
#line 512
    while (1) {
#line 512
      t0___6 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 512
      t1___6 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[7] + (unsigned long long const   )x[7])));
#line 512
      e += t1___6;
#line 512
      a = t0___6 + t1___6;
#line 512
      break;
    }
#line 513
    while (1) {
#line 513
      t0___7 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 513
      t1___7 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[8] + (unsigned long long const   )x[8])));
#line 513
      d += t1___7;
#line 513
      h = t0___7 + t1___7;
#line 513
      break;
    }
#line 514
    while (1) {
#line 514
      t0___8 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 514
      t1___8 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[9] + (unsigned long long const   )x[9])));
#line 514
      c += t1___8;
#line 514
      g = t0___8 + t1___8;
#line 514
      break;
    }
#line 515
    while (1) {
#line 515
      t0___9 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 515
      t1___9 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[10] + (unsigned long long const   )x[10])));
#line 515
      b += t1___9;
#line 515
      f = t0___9 + t1___9;
#line 515
      break;
    }
#line 516
    while (1) {
#line 516
      t0___10 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 516
      t1___10 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[11] + (unsigned long long const   )x[11])));
#line 516
      a += t1___10;
#line 516
      e = t0___10 + t1___10;
#line 516
      break;
    }
#line 517
    while (1) {
#line 517
      t0___11 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 517
      t1___11 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[12] + (unsigned long long const   )x[12])));
#line 517
      h += t1___11;
#line 517
      d = t0___11 + t1___11;
#line 517
      break;
    }
#line 518
    while (1) {
#line 518
      t0___12 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 518
      t1___12 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[13] + (unsigned long long const   )x[13])));
#line 518
      g += t1___12;
#line 518
      c = t0___12 + t1___12;
#line 518
      break;
    }
#line 519
    while (1) {
#line 519
      t0___13 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 519
      t1___13 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[14] + (unsigned long long const   )x[14])));
#line 519
      f += t1___13;
#line 519
      b = t0___13 + t1___13;
#line 519
      break;
    }
#line 520
    while (1) {
#line 520
      t0___14 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 520
      t1___14 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[15] + (unsigned long long const   )x[15])));
#line 520
      e += t1___14;
#line 520
      a = t0___14 + t1___14;
#line 520
      break;
    }
#line 521
    while (1) {
#line 521
      t0___15 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 521
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 521
      t1___15 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[16] + (unsigned long long const   )x[0])));
#line 521
      d += t1___15;
#line 521
      h = t0___15 + t1___15;
#line 521
      break;
    }
#line 522
    while (1) {
#line 522
      t0___16 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 522
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 522
      t1___16 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[17] + (unsigned long long const   )x[1])));
#line 522
      c += t1___16;
#line 522
      g = t0___16 + t1___16;
#line 522
      break;
    }
#line 523
    while (1) {
#line 523
      t0___17 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 523
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 523
      t1___17 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[18] + (unsigned long long const   )x[2])));
#line 523
      b += t1___17;
#line 523
      f = t0___17 + t1___17;
#line 523
      break;
    }
#line 524
    while (1) {
#line 524
      t0___18 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 524
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 524
      t1___18 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[19] + (unsigned long long const   )x[3])));
#line 524
      a += t1___18;
#line 524
      e = t0___18 + t1___18;
#line 524
      break;
    }
#line 525
    while (1) {
#line 525
      t0___19 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 525
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 525
      t1___19 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[20] + (unsigned long long const   )x[4])));
#line 525
      h += t1___19;
#line 525
      d = t0___19 + t1___19;
#line 525
      break;
    }
#line 526
    while (1) {
#line 526
      t0___20 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 526
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 526
      t1___20 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[21] + (unsigned long long const   )x[5])));
#line 526
      g += t1___20;
#line 526
      c = t0___20 + t1___20;
#line 526
      break;
    }
#line 527
    while (1) {
#line 527
      t0___21 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 527
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 527
      t1___21 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[22] + (unsigned long long const   )x[6])));
#line 527
      f += t1___21;
#line 527
      b = t0___21 + t1___21;
#line 527
      break;
    }
#line 528
    while (1) {
#line 528
      t0___22 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 528
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 528
      t1___22 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[23] + (unsigned long long const   )x[7])));
#line 528
      e += t1___22;
#line 528
      a = t0___22 + t1___22;
#line 528
      break;
    }
#line 529
    while (1) {
#line 529
      t0___23 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 529
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 529
      t1___23 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[24] + (unsigned long long const   )x[8])));
#line 529
      d += t1___23;
#line 529
      h = t0___23 + t1___23;
#line 529
      break;
    }
#line 530
    while (1) {
#line 530
      t0___24 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 530
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 530
      t1___24 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[25] + (unsigned long long const   )x[9])));
#line 530
      c += t1___24;
#line 530
      g = t0___24 + t1___24;
#line 530
      break;
    }
#line 531
    while (1) {
#line 531
      t0___25 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 531
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 531
      t1___25 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[26] + (unsigned long long const   )x[10])));
#line 531
      b += t1___25;
#line 531
      f = t0___25 + t1___25;
#line 531
      break;
    }
#line 532
    while (1) {
#line 532
      t0___26 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 532
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 532
      t1___26 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[27] + (unsigned long long const   )x[11])));
#line 532
      a += t1___26;
#line 532
      e = t0___26 + t1___26;
#line 532
      break;
    }
#line 533
    while (1) {
#line 533
      t0___27 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 533
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 533
      t1___27 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[28] + (unsigned long long const   )x[12])));
#line 533
      h += t1___27;
#line 533
      d = t0___27 + t1___27;
#line 533
      break;
    }
#line 534
    while (1) {
#line 534
      t0___28 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 534
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 534
      t1___28 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[29] + (unsigned long long const   )x[13])));
#line 534
      g += t1___28;
#line 534
      c = t0___28 + t1___28;
#line 534
      break;
    }
#line 535
    while (1) {
#line 535
      t0___29 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 535
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 535
      t1___29 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[30] + (unsigned long long const   )x[14])));
#line 535
      f += t1___29;
#line 535
      b = t0___29 + t1___29;
#line 535
      break;
    }
#line 536
    while (1) {
#line 536
      t0___30 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 536
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 536
      t1___30 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[31] + (unsigned long long const   )x[15])));
#line 536
      e += t1___30;
#line 536
      a = t0___30 + t1___30;
#line 536
      break;
    }
#line 537
    while (1) {
#line 537
      t0___31 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 537
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 537
      t1___31 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[32] + (unsigned long long const   )x[0])));
#line 537
      d += t1___31;
#line 537
      h = t0___31 + t1___31;
#line 537
      break;
    }
#line 538
    while (1) {
#line 538
      t0___32 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 538
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 538
      t1___32 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[33] + (unsigned long long const   )x[1])));
#line 538
      c += t1___32;
#line 538
      g = t0___32 + t1___32;
#line 538
      break;
    }
#line 539
    while (1) {
#line 539
      t0___33 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 539
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 539
      t1___33 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[34] + (unsigned long long const   )x[2])));
#line 539
      b += t1___33;
#line 539
      f = t0___33 + t1___33;
#line 539
      break;
    }
#line 540
    while (1) {
#line 540
      t0___34 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 540
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 540
      t1___34 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[35] + (unsigned long long const   )x[3])));
#line 540
      a += t1___34;
#line 540
      e = t0___34 + t1___34;
#line 540
      break;
    }
#line 541
    while (1) {
#line 541
      t0___35 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 541
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 541
      t1___35 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[36] + (unsigned long long const   )x[4])));
#line 541
      h += t1___35;
#line 541
      d = t0___35 + t1___35;
#line 541
      break;
    }
#line 542
    while (1) {
#line 542
      t0___36 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 542
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 542
      t1___36 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[37] + (unsigned long long const   )x[5])));
#line 542
      g += t1___36;
#line 542
      c = t0___36 + t1___36;
#line 542
      break;
    }
#line 543
    while (1) {
#line 543
      t0___37 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 543
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 543
      t1___37 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[38] + (unsigned long long const   )x[6])));
#line 543
      f += t1___37;
#line 543
      b = t0___37 + t1___37;
#line 543
      break;
    }
#line 544
    while (1) {
#line 544
      t0___38 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 544
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 544
      t1___38 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[39] + (unsigned long long const   )x[7])));
#line 544
      e += t1___38;
#line 544
      a = t0___38 + t1___38;
#line 544
      break;
    }
#line 545
    while (1) {
#line 545
      t0___39 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 545
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 545
      t1___39 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[40] + (unsigned long long const   )x[8])));
#line 545
      d += t1___39;
#line 545
      h = t0___39 + t1___39;
#line 545
      break;
    }
#line 546
    while (1) {
#line 546
      t0___40 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 546
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 546
      t1___40 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[41] + (unsigned long long const   )x[9])));
#line 546
      c += t1___40;
#line 546
      g = t0___40 + t1___40;
#line 546
      break;
    }
#line 547
    while (1) {
#line 547
      t0___41 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 547
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 547
      t1___41 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[42] + (unsigned long long const   )x[10])));
#line 547
      b += t1___41;
#line 547
      f = t0___41 + t1___41;
#line 547
      break;
    }
#line 548
    while (1) {
#line 548
      t0___42 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 548
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 548
      t1___42 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[43] + (unsigned long long const   )x[11])));
#line 548
      a += t1___42;
#line 548
      e = t0___42 + t1___42;
#line 548
      break;
    }
#line 549
    while (1) {
#line 549
      t0___43 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 549
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 549
      t1___43 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[44] + (unsigned long long const   )x[12])));
#line 549
      h += t1___43;
#line 549
      d = t0___43 + t1___43;
#line 549
      break;
    }
#line 550
    while (1) {
#line 550
      t0___44 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 550
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 550
      t1___44 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[45] + (unsigned long long const   )x[13])));
#line 550
      g += t1___44;
#line 550
      c = t0___44 + t1___44;
#line 550
      break;
    }
#line 551
    while (1) {
#line 551
      t0___45 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 551
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 551
      t1___45 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[46] + (unsigned long long const   )x[14])));
#line 551
      f += t1___45;
#line 551
      b = t0___45 + t1___45;
#line 551
      break;
    }
#line 552
    while (1) {
#line 552
      t0___46 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 552
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 552
      t1___46 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[47] + (unsigned long long const   )x[15])));
#line 552
      e += t1___46;
#line 552
      a = t0___46 + t1___46;
#line 552
      break;
    }
#line 553
    while (1) {
#line 553
      t0___47 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 553
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 553
      t1___47 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[48] + (unsigned long long const   )x[0])));
#line 553
      d += t1___47;
#line 553
      h = t0___47 + t1___47;
#line 553
      break;
    }
#line 554
    while (1) {
#line 554
      t0___48 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 554
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 554
      t1___48 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[49] + (unsigned long long const   )x[1])));
#line 554
      c += t1___48;
#line 554
      g = t0___48 + t1___48;
#line 554
      break;
    }
#line 555
    while (1) {
#line 555
      t0___49 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 555
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 555
      t1___49 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[50] + (unsigned long long const   )x[2])));
#line 555
      b += t1___49;
#line 555
      f = t0___49 + t1___49;
#line 555
      break;
    }
#line 556
    while (1) {
#line 556
      t0___50 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 556
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 556
      t1___50 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[51] + (unsigned long long const   )x[3])));
#line 556
      a += t1___50;
#line 556
      e = t0___50 + t1___50;
#line 556
      break;
    }
#line 557
    while (1) {
#line 557
      t0___51 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 557
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 557
      t1___51 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[52] + (unsigned long long const   )x[4])));
#line 557
      h += t1___51;
#line 557
      d = t0___51 + t1___51;
#line 557
      break;
    }
#line 558
    while (1) {
#line 558
      t0___52 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 558
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 558
      t1___52 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[53] + (unsigned long long const   )x[5])));
#line 558
      g += t1___52;
#line 558
      c = t0___52 + t1___52;
#line 558
      break;
    }
#line 559
    while (1) {
#line 559
      t0___53 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 559
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 559
      t1___53 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[54] + (unsigned long long const   )x[6])));
#line 559
      f += t1___53;
#line 559
      b = t0___53 + t1___53;
#line 559
      break;
    }
#line 560
    while (1) {
#line 560
      t0___54 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 560
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 560
      t1___54 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[55] + (unsigned long long const   )x[7])));
#line 560
      e += t1___54;
#line 560
      a = t0___54 + t1___54;
#line 560
      break;
    }
#line 561
    while (1) {
#line 561
      t0___55 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 561
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 561
      t1___55 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[56] + (unsigned long long const   )x[8])));
#line 561
      d += t1___55;
#line 561
      h = t0___55 + t1___55;
#line 561
      break;
    }
#line 562
    while (1) {
#line 562
      t0___56 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 562
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 562
      t1___56 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[57] + (unsigned long long const   )x[9])));
#line 562
      c += t1___56;
#line 562
      g = t0___56 + t1___56;
#line 562
      break;
    }
#line 563
    while (1) {
#line 563
      t0___57 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 563
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 563
      t1___57 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[58] + (unsigned long long const   )x[10])));
#line 563
      b += t1___57;
#line 563
      f = t0___57 + t1___57;
#line 563
      break;
    }
#line 564
    while (1) {
#line 564
      t0___58 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 564
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 564
      t1___58 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[59] + (unsigned long long const   )x[11])));
#line 564
      a += t1___58;
#line 564
      e = t0___58 + t1___58;
#line 564
      break;
    }
#line 565
    while (1) {
#line 565
      t0___59 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 565
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 565
      t1___59 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[60] + (unsigned long long const   )x[12])));
#line 565
      h += t1___59;
#line 565
      d = t0___59 + t1___59;
#line 565
      break;
    }
#line 566
    while (1) {
#line 566
      t0___60 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 566
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 566
      t1___60 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[61] + (unsigned long long const   )x[13])));
#line 566
      g += t1___60;
#line 566
      c = t0___60 + t1___60;
#line 566
      break;
    }
#line 567
    while (1) {
#line 567
      t0___61 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 567
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 567
      t1___61 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[62] + (unsigned long long const   )x[14])));
#line 567
      f += t1___61;
#line 567
      b = t0___61 + t1___61;
#line 567
      break;
    }
#line 568
    while (1) {
#line 568
      t0___62 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 568
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 568
      t1___62 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[63] + (unsigned long long const   )x[15])));
#line 568
      e += t1___62;
#line 568
      a = t0___62 + t1___62;
#line 568
      break;
    }
#line 569
    while (1) {
#line 569
      t0___63 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 569
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 569
      t1___63 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[64] + (unsigned long long const   )x[0])));
#line 569
      d += t1___63;
#line 569
      h = t0___63 + t1___63;
#line 569
      break;
    }
#line 570
    while (1) {
#line 570
      t0___64 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 570
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 570
      t1___64 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[65] + (unsigned long long const   )x[1])));
#line 570
      c += t1___64;
#line 570
      g = t0___64 + t1___64;
#line 570
      break;
    }
#line 571
    while (1) {
#line 571
      t0___65 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 571
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 571
      t1___65 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[66] + (unsigned long long const   )x[2])));
#line 571
      b += t1___65;
#line 571
      f = t0___65 + t1___65;
#line 571
      break;
    }
#line 572
    while (1) {
#line 572
      t0___66 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 572
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 572
      t1___66 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[67] + (unsigned long long const   )x[3])));
#line 572
      a += t1___66;
#line 572
      e = t0___66 + t1___66;
#line 572
      break;
    }
#line 573
    while (1) {
#line 573
      t0___67 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 573
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 573
      t1___67 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[68] + (unsigned long long const   )x[4])));
#line 573
      h += t1___67;
#line 573
      d = t0___67 + t1___67;
#line 573
      break;
    }
#line 574
    while (1) {
#line 574
      t0___68 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 574
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 574
      t1___68 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[69] + (unsigned long long const   )x[5])));
#line 574
      g += t1___68;
#line 574
      c = t0___68 + t1___68;
#line 574
      break;
    }
#line 575
    while (1) {
#line 575
      t0___69 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 575
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 575
      t1___69 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[70] + (unsigned long long const   )x[6])));
#line 575
      f += t1___69;
#line 575
      b = t0___69 + t1___69;
#line 575
      break;
    }
#line 576
    while (1) {
#line 576
      t0___70 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 576
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 576
      t1___70 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[71] + (unsigned long long const   )x[7])));
#line 576
      e += t1___70;
#line 576
      a = t0___70 + t1___70;
#line 576
      break;
    }
#line 577
    while (1) {
#line 577
      t0___71 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 577
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 577
      t1___71 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long long )(sha512_round_constants[72] + (unsigned long long const   )x[8])));
#line 577
      d += t1___71;
#line 577
      h = t0___71 + t1___71;
#line 577
      break;
    }
#line 578
    while (1) {
#line 578
      t0___72 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 578
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 578
      t1___72 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long long )(sha512_round_constants[73] + (unsigned long long const   )x[9])));
#line 578
      c += t1___72;
#line 578
      g = t0___72 + t1___72;
#line 578
      break;
    }
#line 579
    while (1) {
#line 579
      t0___73 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 579
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 579
      t1___73 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long long )(sha512_round_constants[74] + (unsigned long long const   )x[10])));
#line 579
      b += t1___73;
#line 579
      f = t0___73 + t1___73;
#line 579
      break;
    }
#line 580
    while (1) {
#line 580
      t0___74 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 580
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 580
      t1___74 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long long )(sha512_round_constants[75] + (unsigned long long const   )x[11])));
#line 580
      a += t1___74;
#line 580
      e = t0___74 + t1___74;
#line 580
      break;
    }
#line 581
    while (1) {
#line 581
      t0___75 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 581
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 581
      t1___75 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long long )(sha512_round_constants[76] + (unsigned long long const   )x[12])));
#line 581
      h += t1___75;
#line 581
      d = t0___75 + t1___75;
#line 581
      break;
    }
#line 582
    while (1) {
#line 582
      t0___76 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 582
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 582
      t1___76 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long long )(sha512_round_constants[77] + (unsigned long long const   )x[13])));
#line 582
      g += t1___76;
#line 582
      c = t0___76 + t1___76;
#line 582
      break;
    }
#line 583
    while (1) {
#line 583
      t0___77 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 583
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 583
      t1___77 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long long )(sha512_round_constants[78] + (unsigned long long const   )x[14])));
#line 583
      f += t1___77;
#line 583
      b = t0___77 + t1___77;
#line 583
      break;
    }
#line 584
    while (1) {
#line 584
      t0___78 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 584
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 584
      t1___78 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long long )(sha512_round_constants[79] + (unsigned long long const   )x[15])));
#line 584
      e += t1___78;
#line 584
      a = t0___78 + t1___78;
#line 584
      break;
    }
#line 586
    __cil_tmp = ctx->state[0] + a;
#line 586
    ctx->state[0] = __cil_tmp;
#line 586
    a = __cil_tmp;
#line 587
    __cil_tmp___0 = ctx->state[1] + b;
#line 587
    ctx->state[1] = __cil_tmp___0;
#line 587
    b = __cil_tmp___0;
#line 588
    __cil_tmp___1 = ctx->state[2] + c;
#line 588
    ctx->state[2] = __cil_tmp___1;
#line 588
    c = __cil_tmp___1;
#line 589
    __cil_tmp___2 = ctx->state[3] + d;
#line 589
    ctx->state[3] = __cil_tmp___2;
#line 589
    d = __cil_tmp___2;
#line 590
    __cil_tmp___3 = ctx->state[4] + e;
#line 590
    ctx->state[4] = __cil_tmp___3;
#line 590
    e = __cil_tmp___3;
#line 591
    __cil_tmp___4 = ctx->state[5] + f;
#line 591
    ctx->state[5] = __cil_tmp___4;
#line 591
    f = __cil_tmp___4;
#line 592
    __cil_tmp___5 = ctx->state[6] + g;
#line 592
    ctx->state[6] = __cil_tmp___5;
#line 592
    g = __cil_tmp___5;
#line 593
    __cil_tmp___6 = ctx->state[7] + h;
#line 593
    ctx->state[7] = __cil_tmp___6;
#line 593
    h = __cil_tmp___6;
  }
#line 595
  return;
}
}
#line 1 "strintcmp.o"
#pragma merger(0,"/tmp/cil-p15TcKcG.i","-g,-O2")
#line 1 "strnumcmp.h"
int strintcmp(char const   *a , char const   *b ) ;
#line 74 "strnumcmp-in.h"
__inline static int fraccompare(char const   *a , char const   *b , char decimal_point ) 
{ char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;

  {
#line 77
  if ((int const   )*a == (int const   )decimal_point && (int const   )*b == (int const   )decimal_point) {
#line 79
    while (1) {
#line 79
      a ++;
#line 79
      b ++;
#line 79
      if (! ((int const   )*a == (int const   )*b)) {
#line 79
        break;
      }
#line 80
      if (! ((unsigned int )*a - 48U <= 9U)) {
#line 81
        return (0);
      }
    }
#line 82
    if ((unsigned int )*a - 48U <= 9U && (unsigned int )*b - 48U <= 9U) {
#line 83
      return ((int )((int const   )*a - (int const   )*b));
    }
#line 84
    if ((unsigned int )*a - 48U <= 9U) {
#line 85
      goto a_trailing_nonzero;
    }
#line 86
    if ((unsigned int )*b - 48U <= 9U) {
#line 87
      goto b_trailing_nonzero;
    }
#line 88
    return (0);
  } else {
#line 90
    __cil_tmp___0 = a;
#line 90
    a ++;
#line 90
    if ((int const   )*__cil_tmp___0 == (int const   )decimal_point) {
      a_trailing_nonzero: 
#line 93
      while ((int const   )*a == 48) {
#line 94
        a ++;
      }
#line 95
      return ((unsigned int )*a - 48U <= 9U);
    } else {
#line 97
      __cil_tmp = b;
#line 97
      b ++;
#line 97
      if ((int const   )*__cil_tmp == (int const   )decimal_point) {
        b_trailing_nonzero: 
#line 100
        while ((int const   )*b == 48) {
#line 101
          b ++;
        }
#line 102
        return (- ((unsigned int )*b - 48U <= 9U));
      }
    }
  }
#line 104
  return (0);
}
}
#line 114 "strnumcmp-in.h"
__inline static int numcompare(char const   *a , char const   *b , int decimal_point ,
                               int thousands_sep ) 
{ unsigned char tmpa ;
  unsigned char tmpb ;
  int tmp ;
  size_t log_a ;
  size_t log_b ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 118
  tmpa = (unsigned char )*a;
#line 119
  tmpb = (unsigned char )*b;
#line 124
  if ((int )tmpa == 45) {
#line 126
    while (1) {
#line 127
      a ++;
#line 127
      tmpa = (unsigned char )*a;
#line 126
      if (! ((int )tmpa == 48 || (int )tmpa == thousands_sep)) {
#line 126
        break;
      }
    }
#line 129
    if ((int )tmpb != 45) {
#line 131
      if ((int )tmpa == decimal_point) {
#line 132
        while (1) {
#line 133
          a ++;
#line 133
          tmpa = (unsigned char )*a;
#line 132
          if (! ((int )tmpa == 48)) {
#line 132
            break;
          }
        }
      }
#line 135
      if ((unsigned int )tmpa - 48U <= 9U) {
#line 136
        return (-1);
      }
#line 137
      while ((int )tmpb == 48 || (int )tmpb == thousands_sep) {
#line 138
        b ++;
#line 138
        tmpb = (unsigned char )*b;
      }
#line 139
      if ((int )tmpb == decimal_point) {
#line 140
        while (1) {
#line 141
          b ++;
#line 141
          tmpb = (unsigned char )*b;
#line 140
          if (! ((int )tmpb == 48)) {
#line 140
            break;
          }
        }
      }
#line 143
      return (- ((unsigned int )tmpb - 48U <= 9U));
    }
#line 145
    while (1) {
#line 146
      b ++;
#line 146
      tmpb = (unsigned char )*b;
#line 145
      if (! ((int )tmpb == 48 || (int )tmpb == thousands_sep)) {
#line 145
        break;
      }
    }
#line 149
    while ((int )tmpa == (int )tmpb && (unsigned int )tmpa - 48U <= 9U) {
#line 151
      while (1) {
#line 152
        a ++;
#line 152
        tmpa = (unsigned char )*a;
#line 151
        if (! ((int )tmpa == thousands_sep)) {
#line 151
          break;
        }
      }
#line 154
      while (1) {
#line 155
        b ++;
#line 155
        tmpb = (unsigned char )*b;
#line 154
        if (! ((int )tmpb == thousands_sep)) {
#line 154
          break;
        }
      }
    }
#line 159
    if (((int )tmpa == decimal_point && ! ((unsigned int )tmpb - 48U <= 9U)) || ((int )tmpb == decimal_point && ! ((unsigned int )tmpa - 48U <= 9U))) {
#line 161
      __cil_tmp = fraccompare(b, a, (char )decimal_point);
#line 161
      return (__cil_tmp);
    }
#line 163
    tmp = (int )tmpb - (int )tmpa;
#line 165
    log_a = 0U;
#line 165
    while ((unsigned int )tmpa - 48U <= 9U) {
#line 166
      while (1) {
#line 167
        a ++;
#line 167
        tmpa = (unsigned char )*a;
#line 166
        if (! ((int )tmpa == thousands_sep)) {
#line 166
          break;
        }
      }
#line 165
      log_a ++;
    }
#line 170
    log_b = 0U;
#line 170
    while ((unsigned int )tmpb - 48U <= 9U) {
#line 171
      while (1) {
#line 172
        b ++;
#line 172
        tmpb = (unsigned char )*b;
#line 171
        if (! ((int )tmpb == thousands_sep)) {
#line 171
          break;
        }
      }
#line 170
      log_b ++;
    }
#line 175
    if (log_a != log_b) {
#line 176
      return (log_a < log_b ? 1 : -1);
    }
#line 178
    if (! log_a) {
#line 179
      return (0);
    }
#line 181
    return (tmp);
  } else
#line 183
  if ((int )tmpb == 45) {
#line 185
    while (1) {
#line 186
      b ++;
#line 186
      tmpb = (unsigned char )*b;
#line 185
      if (! ((int )tmpb == 48 || (int )tmpb == thousands_sep)) {
#line 185
        break;
      }
    }
#line 188
    if ((int )tmpb == decimal_point) {
#line 189
      while (1) {
#line 190
        b ++;
#line 190
        tmpb = (unsigned char )*b;
#line 189
        if (! ((int )tmpb == 48)) {
#line 189
          break;
        }
      }
    }
#line 192
    if ((unsigned int )tmpb - 48U <= 9U) {
#line 193
      return (1);
    }
#line 194
    while ((int )tmpa == 48 || (int )tmpa == thousands_sep) {
#line 195
      a ++;
#line 195
      tmpa = (unsigned char )*a;
    }
#line 196
    if ((int )tmpa == decimal_point) {
#line 197
      while (1) {
#line 198
        a ++;
#line 198
        tmpa = (unsigned char )*a;
#line 197
        if (! ((int )tmpa == 48)) {
#line 197
          break;
        }
      }
    }
#line 200
    return ((unsigned int )tmpa - 48U <= 9U);
  } else {
#line 204
    while ((int )tmpa == 48 || (int )tmpa == thousands_sep) {
#line 205
      a ++;
#line 205
      tmpa = (unsigned char )*a;
    }
#line 206
    while ((int )tmpb == 48 || (int )tmpb == thousands_sep) {
#line 207
      b ++;
#line 207
      tmpb = (unsigned char )*b;
    }
#line 209
    while ((int )tmpa == (int )tmpb && (unsigned int )tmpa - 48U <= 9U) {
#line 211
      while (1) {
#line 212
        a ++;
#line 212
        tmpa = (unsigned char )*a;
#line 211
        if (! ((int )tmpa == thousands_sep)) {
#line 211
          break;
        }
      }
#line 214
      while (1) {
#line 215
        b ++;
#line 215
        tmpb = (unsigned char )*b;
#line 214
        if (! ((int )tmpb == thousands_sep)) {
#line 214
          break;
        }
      }
    }
#line 219
    if (((int )tmpa == decimal_point && ! ((unsigned int )tmpb - 48U <= 9U)) || ((int )tmpb == decimal_point && ! ((unsigned int )tmpa - 48U <= 9U))) {
#line 221
      __cil_tmp___0 = fraccompare(a, b, (char )decimal_point);
#line 221
      return (__cil_tmp___0);
    }
#line 223
    tmp = (int )tmpa - (int )tmpb;
#line 225
    log_a = 0U;
#line 225
    while ((unsigned int )tmpa - 48U <= 9U) {
#line 226
      while (1) {
#line 227
        a ++;
#line 227
        tmpa = (unsigned char )*a;
#line 226
        if (! ((int )tmpa == thousands_sep)) {
#line 226
          break;
        }
      }
#line 225
      log_a ++;
    }
#line 230
    log_b = 0U;
#line 230
    while ((unsigned int )tmpb - 48U <= 9U) {
#line 231
      while (1) {
#line 232
        b ++;
#line 232
        tmpb = (unsigned char )*b;
#line 231
        if (! ((int )tmpb == thousands_sep)) {
#line 231
          break;
        }
      }
#line 230
      log_b ++;
    }
#line 235
    if (log_a != log_b) {
#line 236
      return (log_a < log_b ? -1 : 1);
    }
#line 238
    if (! log_a) {
#line 239
      return (0);
    }
#line 241
    return (tmp);
  }
}
}
#line 28 "strintcmp.c"
int strintcmp(char const   *a , char const   *b ) 
{ int __cil_tmp ;

  {
#line 31
  __cil_tmp = numcompare(a, b, -1, -1);
#line 31
  return (__cil_tmp);
}
}
#line 1 "strnumcmp.o"
#pragma merger(0,"/tmp/cil-X2E4gtd8.i","-g,-O2")
#line 2 "strnumcmp.h"
int strnumcmp(char const   *a , char const   *b , int decimal_point , int thousands_sep ) ;
#line 26 "strnumcmp.c"
int strnumcmp(char const   *a , char const   *b , int decimal_point , int thousands_sep ) 
{ int __cil_tmp ;

  {
#line 30
  __cil_tmp = numcompare(a, b, decimal_point, thousands_sep);
#line 30
  return (__cil_tmp);
}
}
