/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 10 "../../mockedFns/FD_MACROS.c"
struct fd_set {
   unsigned int count ;
   int fd[1024] ;
};
#line 10 "../../mockedFns/FD_MACROS.c"
typedef struct fd_set fd_set___0;
#line 13 "../../mockedFns/builtin.c"
typedef unsigned int size_t;
#line 214 "../../includes/usr/local/gcc-4.0.1/lib/gcc/i686-pc-linux-gnu/4.0.1/include/stddef.h"
typedef unsigned long size_t___0;
#line 44 "../../includes/usr/include/sys/capability.h"
struct _cap_struct;
#line 44 "../../includes/usr/include/sys/capability.h"
typedef struct _cap_struct *cap_t;
#line 59 "../../includes/usr/include/bits/types.h"
typedef long long __quad_t;
#line 143 "../../includes/usr/include/bits/types.h"
typedef long __off_t;
#line 46 "../../includes/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "../../includes/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 176 "../../includes/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "../../includes/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "../../includes/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __quad_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t___0 __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t___0 )] ;
};
#line 60 "../../includes/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 140 "../../includes/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 141 "../../includes/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 23 "../../includes/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __quad_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "../../includes/usr/include/dirent.h"
struct __dirstream;
#line 128 "../../includes/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 136 "../../includes/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "../../includes/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "../../includes/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "../../includes/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "../../includes/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 151 "../../includes/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "../../includes/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "../../includes/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 118 "../../includes/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "../../includes/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __quad_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 12 "../../mockedFns/iosim.h"
struct __anonstruct_sym_file_t_17 {
   char *contents ;
   struct stat stat ;
};
#line 12 "../../mockedFns/iosim.h"
typedef struct __anonstruct_sym_file_t_17 sym_file_t;
#line 17 "../../mockedFns/iosim.h"
struct __anonstruct_sym_file_stream_t_18 {
   int fd ;
   __quad_t offset ;
   sym_file_t *sym_file ;
   char *buffer ;
};
#line 17 "../../mockedFns/iosim.h"
typedef struct __anonstruct_sym_file_stream_t_18 sym_file_stream_t;
#line 83 "../../mockedFns/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 16 "../../mockedFns/getopt.c"
enum __anonenum_ordering_18 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 194 "../../includes/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 36 "../../includes/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "../../includes/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "../../includes/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 50 "../../includes/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 52 "../../includes/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 136 "../../includes/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "../../includes/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 72 "../../includes/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 352 "../../mockedFns/iosim.c"
struct __dirstream {
   char dirname[4097] ;
   int index ;
   struct dirent readdirRetval ;
   sym_file_stream_t filestream ;
};
#line 50 "../../includes/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 43 "../../includes/usr/local/gcc-4.0.1/lib/gcc/i686-pc-linux-gnu/4.0.1/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "../../includes/usr/local/gcc-4.0.1/lib/gcc/i686-pc-linux-gnu/4.0.1/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 33 "../../includes/usr/include/security/_pam_types.h"
struct pam_handle;
#line 33 "../../includes/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 238 "../../includes/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 263 "../../includes/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 270 "../../includes/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 182 "../../includes/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "../../includes/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 28 "../../includes/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_1 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "../../includes/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_1 __sigset_t;
#line 50 "../../includes/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 145 "../../includes/usr/include/bits/types.h"
typedef int __pid_t;
#line 147 "../../includes/usr/include/bits/types.h"
typedef long __clock_t;
#line 33 "../../includes/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "../../includes/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "../../includes/usr/include/bits/siginfo.h"
struct __anonstruct__kill_4 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "../../includes/usr/include/bits/siginfo.h"
struct __anonstruct__timer_5 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "../../includes/usr/include/bits/siginfo.h"
struct __anonstruct__rt_6 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "../../includes/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_7 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "../../includes/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_8 {
   void *si_addr ;
};
#line 51 "../../includes/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_9 {
   long si_band ;
   int si_fd ;
};
#line 51 "../../includes/usr/include/bits/siginfo.h"
union __anonunion__sifields_3 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_4 _kill ;
   struct __anonstruct__timer_5 _timer ;
   struct __anonstruct__rt_6 _rt ;
   struct __anonstruct__sigchld_7 _sigchld ;
   struct __anonstruct__sigfault_8 _sigfault ;
   struct __anonstruct__sigpoll_9 _sigpoll ;
};
#line 51 "../../includes/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_3 _sifields ;
};
#line 51 "../../includes/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "../../includes/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_21 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "../../includes/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_21 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 50 "../../includes/usr/include/bits/sigstack.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t___0 ss_size ;
};
#line 153 "../../includes/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "../../includes/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "../../includes/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "../../includes/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "../../includes/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 337 "../../includes/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 76 "../../includes/usr/include/time.h"
typedef __time_t time_t;
#line 131 "../../includes/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 56 "../../includes/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 57 "../../mockedFns/time.c"
struct utimbuf;
#line 141 "../../includes/usr/include/stdint.h"
typedef unsigned long long uintmax_t;
#line 13 "../../libc/vsnprintf.c"
enum flags {
    FL_ZERO = 1,
    FL_MINUS = 2,
    FL_PLUS = 4,
    FL_TICK = 8,
    FL_SPACE = 16,
    FL_HASH = 32,
    FL_SIGNED = 64,
    FL_UPPER = 128
} ;
#line 182
enum __anonenum_state_11 {
    st_normal = 0,
    st_flags = 1,
    st_width = 2,
    st_prec = 3,
    st_modifiers = 4
} ;
#line 4 "filesize.h"
typedef long long filesize_t;
#line 10 "str.h"
struct mystr {
   char *PRIVATE_HANDS_OFF_p_buf ;
   unsigned int PRIVATE_HANDS_OFF_len ;
   unsigned int PRIVATE_HANDS_OFF_alloc_bytes ;
};
#line 12 "session.h"
struct vsf_sysutil_sockaddr;
#line 13
struct mystr_list;
#line 18 "session.h"
struct vsf_session {
   struct vsf_sysutil_sockaddr *p_local_addr ;
   struct vsf_sysutil_sockaddr *p_remote_addr ;
   char *p_control_line_buf ;
   int pasv_listen_fd ;
   struct vsf_sysutil_sockaddr *p_port_sockaddr ;
   int data_fd ;
   int data_progress ;
   unsigned int bw_rate_max ;
   long bw_send_start_sec ;
   long bw_send_start_usec ;
   int is_anonymous ;
   int is_guest ;
   struct mystr user_str ;
   struct mystr anon_pass_str ;
   filesize_t restart_pos ;
   int is_ascii ;
   struct mystr rnfr_filename_str ;
   int abor_received ;
   int epsv_all ;
   struct mystr_list *p_visited_dir_list ;
   int anon_ftp_uid ;
   int guest_user_uid ;
   int anon_upload_chown_uid ;
   struct mystr banned_email_str ;
   struct mystr email_passwords_str ;
   struct mystr userlist_str ;
   struct mystr banner_str ;
   int tcp_wrapper_ok ;
   int xferlog_fd ;
   int vsftpd_log_fd ;
   struct mystr remote_ip_str ;
   unsigned long log_type ;
   long log_start_sec ;
   long log_start_usec ;
   struct mystr log_str ;
   filesize_t transfer_size ;
   struct mystr ftp_cmd_str ;
   struct mystr ftp_arg_str ;
   int parent_fd ;
   int child_fd ;
   unsigned int num_clients ;
   unsigned int num_this_ip ;
   struct mystr home_str ;
   int control_use_ssl ;
   int data_use_ssl ;
   void *p_ssl_ctx ;
   void *p_control_ssl ;
   void *p_data_ssl ;
   struct mystr control_cert_digest ;
   int ssl_slave_active ;
   int ssl_slave_fd ;
   int ssl_consumer_fd ;
   unsigned int login_fails ;
};
#line 24 "sysutil.h"
enum EVSFSysUtilSignal {
    kVSFSysUtilSigALRM = 1,
    kVSFSysUtilSigTERM = 2,
    kVSFSysUtilSigCHLD = 3,
    kVSFSysUtilSigPIPE = 4,
    kVSFSysUtilSigURG = 5,
    kVSFSysUtilSigHUP = 6
} ;
#line 106
struct vsf_sysutil_statbuf;
#line 276
struct vsf_sysutil_user;
#line 4 "standalone.h"
struct vsf_client_launch {
   unsigned int num_children ;
   unsigned int num_this_ip ;
};
#line 8 "logging.h"
enum EVSFLogEntryType {
    kVSFLogEntryNull = 1,
    kVSFLogEntryDownload = 2,
    kVSFLogEntryUpload = 3,
    kVSFLogEntryMkdir = 4,
    kVSFLogEntryLogin = 5,
    kVSFLogEntryFTPInput = 6,
    kVSFLogEntryFTPOutput = 7,
    kVSFLogEntryConnection = 8,
    kVSFLogEntryDelete = 9,
    kVSFLogEntryRename = 10,
    kVSFLogEntryRmdir = 11,
    kVSFLogEntryChmod = 12,
    kVSFLogEntryDebug = 13
} ;
#line 7 "readwrite.h"
enum EVSFRWTarget {
    kVSFRWControl = 1,
    kVSFRWData = 2
} ;
#line 68 "str.h"
struct str_locate_result {
   int found ;
   unsigned int index ;
   char char_found ;
};
#line 8 "ftpdataio.h"
struct vsf_sysutil_dir;
#line 72 "ftpdataio.h"
struct vsf_transfer_ret {
   int retval ;
   filesize_t transferred ;
};
#line 18 "sysstr.h"
enum EVSFSysStrOpenMode {
    kVSFSysStrOpenUnknown = 0,
    kVSFSysStrOpenReadOnly = 1
} ;
#line 12 "sysutil.h"
enum EVSFSysUtilError {
    kVSFSysUtilErrUnknown = 1,
    kVSFSysUtilErrADDRINUSE = 2,
    kVSFSysUtilErrNOSYS = 3,
    kVSFSysUtilErrINTR = 4,
    kVSFSysUtilErrINVAL = 5,
    kVSFSysUtilErrOPNOTSUPP = 6
} ;
#line 205 "sysutil.h"
struct vsf_sysutil_socketpair_retval {
   int socket_one ;
   int socket_two ;
};
#line 6 "strlist.h"
struct mystr_list_node;
#line 8 "strlist.h"
struct mystr_list {
   unsigned int PRIVATE_HANDS_OFF_alloc_len ;
   unsigned int PRIVATE_HANDS_OFF_list_len ;
   struct mystr_list_node *PRIVATE_HANDS_OFF_p_nodes ;
};
#line 22 "ascii.h"
struct ascii_to_bin_ret {
   unsigned int stored ;
   int last_was_cr ;
   char *p_buf ;
};
#line 147 "sysutil.h"
enum EVSFSysUtilMapPermission {
    kVSFSysUtilMapProtReadOnly = 1,
    kVSFSysUtilMapProtNone = 2
} ;
#line 277
struct vsf_sysutil_group;
#line 72
enum EVSFSysUtilOpenMode {
    kVSFSysUtilOpenReadOnly = 1,
    kVSFSysUtilOpenWriteOnly = 2,
    kVSFSysUtilOpenReadWrite = 3
} ;
#line 18 "strlist.c"
struct mystr_list_node {
   struct mystr str ;
   struct mystr sort_key_str ;
};
#line 31 "parseconf.c"
struct parseconf_bool_setting {
   char const   *p_setting_name ;
   int *p_variable ;
};
#line 112 "parseconf.c"
struct parseconf_uint_setting {
   char const   *p_setting_name ;
   unsigned int *p_variable ;
};
#line 142 "parseconf.c"
struct parseconf_str_setting {
   char const   *p_setting_name ;
   char const   **p_variable ;
};
#line 27 "privops.h"
enum EVSFPrivopLoginResult {
    kVSFLoginNull = 0,
    kVSFLoginFail = 1,
    kVSFLoginAnon = 2,
    kVSFLoginReal = 3
} ;
#line 166 "sysutil.h"
struct vsf_sysutil_wait_retval {
   int PRIVATE_HANDS_OFF_syscall_retval ;
   int PRIVATE_HANDS_OFF_exit_status ;
};
#line 4 "hash.h"
struct hash;
#line 236 "standalone.c"
struct vsf_sysutil_ipaddr;
#line 14 "hash.c"
struct hash_node {
   void *p_key ;
   void *p_value ;
   struct hash_node *p_prev ;
   struct hash_node *p_next ;
};
#line 22 "hash.c"
struct hash {
   unsigned int buckets ;
   unsigned int key_size ;
   unsigned int value_size ;
   unsigned int (*hash_func)(unsigned int  , void * ) ;
   struct hash_node **p_nodes ;
};
#line 33 "sysutil.h"
enum EVSFSysUtilInterruptContext {
    kVSFSysUtilUnknown = 0,
    kVSFSysUtilIO = 1
} ;
#line 308 "../../includes/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 138 "../../includes/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __quad_t l_start ;
   __quad_t l_len ;
   __pid_t l_pid ;
};
#line 49 "../../includes/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 92 "../../includes/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 193 "../../includes/usr/include/netinet/in.h"
union __anonunion_in6_u_38 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 193 "../../includes/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_38 in6_u ;
};
#line 219 "../../includes/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 233 "../../includes/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 43 "../../includes/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 62 "../../includes/usr/include/sys/wait.h"
union wait;
#line 67 "../../includes/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_50 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "../../includes/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_51 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "../../includes/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_50 __wait_terminated ;
   struct __anonstruct___wait_stopped_51 __wait_stopped ;
};
#line 62 "../../includes/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "../../includes/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 96 "../../includes/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 70 "sysutil.c"
struct vsf_sysutil_sig_details {
   void (*sync_sig_handler)(void * ) ;
   void *p_private ;
   int pending ;
   int running ;
};
#line 82 "sysutil.c"
union __anonunion_u_54 {
   struct sockaddr u_sockaddr ;
   struct sockaddr_in u_sockaddr_in ;
   struct sockaddr_in6 u_sockaddr_in6 ;
};
#line 82 "sysutil.c"
struct vsf_sysutil_sockaddr {
   union __anonunion_u_54 u ;
};
#line 604 "sysutil.c"
union __anonunion___u_55 {
   int __in ;
   int __i ;
};
#line 614 "sysutil.c"
union __anonunion___u_56 {
   int __in ;
   int __i ;
};
#line 44 "../../includes/usr/include/bits/types.h"
typedef int __int32_t;
#line 42 "../../includes/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t___0 iov_len ;
};
#line 215 "../../includes/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t___0 msg_iovlen ;
   void *msg_control ;
   size_t___0 msg_controllen ;
   int msg_flags ;
};
#line 230 "../../includes/usr/include/bits/socket.h"
struct cmsghdr {
   size_t___0 cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 43 "../../includes/usr/include/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 56 "../../includes/usr/include/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 52 "../../includes/usr/include/sys/capability.h"
typedef int cap_value_t;
#line 57
enum __anonenum_cap_flag_t_15 {
    CAP_EFFECTIVE = 0,
    CAP_PERMITTED = 1,
    CAP_INHERITABLE = 2
} ;
#line 57 "../../includes/usr/include/sys/capability.h"
typedef enum __anonenum_cap_flag_t_15 cap_flag_t;
#line 66
enum __anonenum_cap_flag_value_t_16 {
    CAP_CLEAR = 0,
    CAP_SET = 1
} ;
#line 66 "../../includes/usr/include/sys/capability.h"
typedef enum __anonenum_cap_flag_value_t_16 cap_flag_value_t;
#line 1 "cil-GO3jYZ6W.o"
#pragma merger(0,"/tmp/cil-j2jg2qd4.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 16 "../../mockedFns/FD_MACROS.c"
void FD_SET(int fd , fd_set___0 *fdset ) 
{ unsigned int __cil_tmp ;

  {
#line 18
  if (fdset->count < 1024U) {
#line 19
    __cil_tmp = fdset->count;
#line 19
    (fdset->count) ++;
#line 19
    fdset->fd[__cil_tmp] = fd;
  }
#line 20
  return;
}
}
#line 22 "../../mockedFns/FD_MACROS.c"
void FD_CLR(int fd , fd_set___0 *fdset ) 
{ unsigned int i ;

  {
#line 26
  i = 0U;
#line 26
  while (i < fdset->count) {
#line 27
    if (fdset->fd[i] == fd) {
#line 28
      while (i < fdset->count - 1U) {
#line 29
        fdset->fd[i] = fdset->fd[i + 1U];
#line 30
        i ++;
      }
#line 32
      (fdset->count) --;
#line 33
      break;
    }
#line 26
    i ++;
  }
#line 36
  return;
}
}
#line 38 "../../mockedFns/FD_MACROS.c"
int FD_ISSET(int fd , fd_set___0 *fdset ) 
{ unsigned int i ;

  {
#line 41
  i = 0U;
#line 41
  while (i < fdset->count) {
#line 42
    if (fdset->fd[i] == fd) {
#line 42
      return (1);
    }
#line 41
    i ++;
  }
#line 45
  return (0);
}
}
#line 48 "../../mockedFns/FD_MACROS.c"
void FD_ZERO(fd_set___0 *fdset ) 
{ 

  {
#line 50
  fdset->count = 0U;
#line 51
  return;
}
}
#line 1 "cil-nEpOtKzO.o"
#pragma merger(0,"/tmp/cil-pH3rUzrM.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 2 "../../mockedFns/__errno_location.c"
static int mock_errno  ;
#line 1
 __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 1 "../../mockedFns/__errno_location.c"
int *__errno_location(void) 
{ 

  {
#line 3
  return (& mock_errno);
}
}
#line 1 "cil-xWrhpAU6.o"
#pragma merger(0,"/tmp/cil-yDCRQnYY.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 640 "../../includes/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 2 "../../mockedFns/_exit.c"
 __attribute__((__noreturn__)) void _exit(int status ) ;
#line 2 "../../mockedFns/_exit.c"
void _exit(int status ) 
{ 

  {
#line 3
  exit(status);
}
}
#line 1 "cil-vthUozkC.o"
#pragma merger(0,"/tmp/cil-GSZi2jLz.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 1 "../../mockedFns/alarm.c"
 __attribute__((__nothrow__)) unsigned int alarm(unsigned int seconds ) ;
#line 1 "../../mockedFns/alarm.c"
unsigned int alarm(unsigned int seconds ) 
{ 

  {
#line 2
  return (0U);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   *s1 , char const   *s2 ) ;  */
/* compiler builtin: 
   long __builtin_expect(long x , long expected_value ) ;  */
#line 1 "cil-sL9EGPFc.o"
#pragma merger(0,"/tmp/cil-QuQUzXgb.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 2 "../../mockedFns/builtin.c"
long __builtin_expect(long x , long expected_value ) 
{ 

  {
#line 8
  return (x);
}
}
#line 16 "../../mockedFns/builtin.c"
size_t __ctype_get_mb_cur_max(void) 
{ 

  {
#line 17
  return (1U);
}
}
#line 99 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) int strcmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 22 "../../mockedFns/builtin.c"
int __builtin_strcmp(char const   *s1 , char const   *s2 ) 
{ int __cil_tmp ;

  {
#line 23
  __cil_tmp = strcmp(s1, s2);
#line 23
  return (__cil_tmp);
}
}
#line 1 "cil-Lhe34F99.o"
#pragma merger(0,"/tmp/cil-EGtKb8RB.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 584 "../../includes/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t___0 __size )  __attribute__((__malloc__)) ;
#line 586
 __attribute__((__nothrow__)) void *calloc(size_t___0 nmemb , size_t___0 size )  __attribute__((__malloc__)) ;
#line 59 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) void *memset(void *dst , int c , size_t___0 n )  __attribute__((__nonnull__(1))) ;
#line 4 "../../mockedFns/calloc.c"
 __attribute__((__nothrow__)) void *calloc(size_t___0 nmemb , size_t___0 size )  __attribute__((__malloc__)) ;
#line 4 "../../mockedFns/calloc.c"
void *calloc(size_t___0 nmemb , size_t___0 size ) 
{ void *p ;
  void *__cil_tmp ;

  {
#line 5
  __cil_tmp = malloc(nmemb * size);
#line 5
  p = __cil_tmp;
#line 6
  memset(p, 0, nmemb * size);
#line 7
  return (p);
}
}
#line 1 "cil-fCfmWAzT.o"
#pragma merger(0,"/tmp/cil-xji8DfX4.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 77 "../../includes/usr/include/sys/capability.h"
int cap_free(void *obj_d ) ;
#line 92
cap_t cap_get_proc(void) ;
#line 4 "../../mockedFns/cap.c"
cap_t cap_get_proc(void) 
{ 

  {
#line 5
  return ((struct _cap_struct *)((void *)0));
}
}
#line 8 "../../mockedFns/cap.c"
int cap_free(void *obj_d ) 
{ 

  {
#line 9
  return (-1);
}
}
#line 1 "cil-UzORAGlI.o"
#pragma merger(0,"/tmp/cil-LjrO4LnM.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 722 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) void clearerr(FILE *stream ) ;
#line 3 "../../mockedFns/clearerr.c"
 __attribute__((__nothrow__)) void clearerr(FILE *stream ) ;
#line 3 "../../mockedFns/clearerr.c"
void clearerr(FILE *stream ) 
{ 

  {
#line 5
  return;
}
}
#line 1 "cil-w7Up9N30.o"
#pragma merger(0,"/tmp/cil-UfBqZ7pv.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 284 "../../includes/usr/include/sys/stat.h"
 __attribute__((__nothrow__)) int mkdir(char const   *pathname , __mode_t mode )  __attribute__((__nonnull__(1))) ;
#line 135 "../../includes/usr/include/dirent.h"
DIR *opendir(char const   *dirname )  __attribute__((__nonnull__(1))) ;
#line 142
int closedir(DIR *dir )  __attribute__((__nonnull__(1))) ;
#line 158
struct dirent *readdir(DIR *dir )  __asm__("_readdir64") __attribute__((__nonnull__(1))) ;
#line 216
 __attribute__((__nothrow__)) int dirfd(DIR *dir )  __attribute__((__nonnull__(1))) ;
#line 49 "../../mockedFns/iosim.h"
int IOSIM_chdir(char const   *path ) ;
#line 50
DIR *IOSIM_opendir(char const   *dirname ) ;
#line 51
int IOSIM_closedir(DIR *dir ) ;
#line 52
struct dirent *IOSIM_readdir(DIR *dir ) ;
#line 53
int IOSIM_dirfd(DIR *dir ) ;
#line 58 "../../mockedFns/iosim.h"
unsigned short iosim_ip_version  =    (unsigned short)2;
#line 4 "../../mockedFns/dir.c"
 __attribute__((__nothrow__)) int chdir(char const   *path )  __attribute__((__nonnull__(1))) ;
#line 4 "../../mockedFns/dir.c"
int chdir(char const   *path ) 
{ int __cil_tmp ;

  {
#line 5
  __cil_tmp = IOSIM_chdir(path);
#line 5
  return (__cil_tmp);
}
}
#line 8
 __attribute__((__nothrow__)) int chroot(char const   *path )  __attribute__((__nonnull__(1))) ;
#line 8 "../../mockedFns/dir.c"
int chroot(char const   *path ) 
{ 

  {
#line 9
  return (0);
}
}
#line 12
DIR *opendir(char const   *dirname )  __attribute__((__nonnull__(1))) ;
#line 12 "../../mockedFns/dir.c"
DIR *opendir(char const   *dirname ) 
{ DIR *__cil_tmp ;

  {
#line 13
  __cil_tmp = IOSIM_opendir(dirname);
#line 13
  return (__cil_tmp);
}
}
#line 16
int closedir(DIR *dir )  __attribute__((__nonnull__(1))) ;
#line 16 "../../mockedFns/dir.c"
int closedir(DIR *dir ) 
{ int __cil_tmp ;

  {
#line 17
  __cil_tmp = IOSIM_closedir(dir);
#line 17
  return (__cil_tmp);
}
}
#line 20
 __attribute__((__nothrow__)) int dirfd(DIR *dir )  __attribute__((__nonnull__(1))) ;
#line 20 "../../mockedFns/dir.c"
int dirfd(DIR *dir ) 
{ int __cil_tmp ;

  {
#line 21
  __cil_tmp = IOSIM_dirfd(dir);
#line 21
  return (__cil_tmp);
}
}
#line 24
struct dirent *readdir(DIR *dir )  __asm__("_readdir64") __attribute__((__nonnull__(1))) ;
#line 24 "../../mockedFns/dir.c"
struct dirent *readdir(DIR *dir ) 
{ struct dirent *__cil_tmp ;

  {
#line 25
  __cil_tmp = IOSIM_readdir(dir);
#line 25
  return (__cil_tmp);
}
}
#line 28
 __attribute__((__nothrow__)) int mkdir(char const   *pathname , __mode_t mode )  __attribute__((__nonnull__(1))) ;
#line 28 "../../mockedFns/dir.c"
int mkdir(char const   *pathname , __mode_t mode ) 
{ 

  {
#line 29
  return (0);
}
}
#line 32
 __attribute__((__nothrow__)) int rmdir(char const   *pathname )  __attribute__((__nonnull__(1))) ;
#line 32 "../../mockedFns/dir.c"
int rmdir(char const   *pathname ) 
{ 

  {
#line 33
  return (0);
}
}
#line 1 "cil-phquEcny.o"
#pragma merger(0,"/tmp/cil-dqmOBqjo.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 8 "../../mockedFns/symexe.h"
extern void __COMMENT(char *str ) ;
#line 597 "../../includes/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 654
 __attribute__((__nothrow__)) char *getenv(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 665
 __attribute__((__nothrow__)) int putenv(char *str )  __attribute__((__nonnull__(1))) ;
#line 87 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) char *strncpy(char * __restrict  dst , char const   * __restrict  src ,
                                            size_t___0 n )  __attribute__((__nonnull__(1,2))) ;
#line 102
 __attribute__((__nothrow__)) int strncmp(char const   *s1 , char const   *s2 , size_t___0 n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 130
 __attribute__((__nothrow__)) char *strdup(char const   *p_str )  __attribute__((__nonnull__(1),
__malloc__)) ;
#line 167
 __attribute__((__nothrow__)) char *strchr(char const   *s , int c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 6 "../../mockedFns/env.c"
int var_count  =    0;
#line 7 "../../mockedFns/env.c"
char *var_names[8]  ;
#line 8 "../../mockedFns/env.c"
char *var_values[8]  ;
#line 10
 __attribute__((__nothrow__)) char *getenv(char const   *name )  __attribute__((__nonnull__(1))) ;
#line 10 "../../mockedFns/env.c"
char *getenv(char const   *name ) 
{ int i ;
  int __cil_tmp ;

  {
#line 12
  i = 0;
#line 12
  while (i < var_count) {
#line 13
    __cil_tmp = strcmp(name, (char const   *)var_names[i]);
#line 13
    if (__cil_tmp == 0) {
#line 14
      return (var_values[i]);
    }
#line 12
    i ++;
  }
#line 16
  return ((char *)((void *)0));
}
}
#line 19
 __attribute__((__nothrow__)) int putenv(char *str )  __attribute__((__nonnull__(1))) ;
#line 19 "../../mockedFns/env.c"
int putenv(char *str ) 
{ char *name_end ;
  char *__cil_tmp ;
  int found ;
  int i ;
  int __cil_tmp___0 ;
  void *__cil_tmp___1 ;

  {
#line 20
  __cil_tmp = strchr((char const   *)str, '=');
#line 20
  name_end = __cil_tmp;
#line 21
  found = -1;
#line 24
  i = 0;
#line 24
  while (i < var_count) {
#line 25
    __cil_tmp___0 = strncmp((char const   *)var_names[i], (char const   *)str, (unsigned long )(name_end - str));
#line 25
    if (! __cil_tmp___0) {
#line 26
      found = i;
    }
#line 24
    i ++;
  }
#line 30
  if (found >= 0) {
#line 32
    free((void *)var_values[found]);
#line 33
    var_values[found] = strdup((char const   *)(name_end + 1));
  } else {
#line 37
    if (var_count >= 8) {
#line 38
      __COMMENT((char *)"Too many environment variables");
#line 39
      exit(1);
    }
#line 41
    __cil_tmp___1 = malloc((unsigned long )((name_end - str) + 1));
#line 41
    var_names[var_count] = (char *)__cil_tmp___1;
#line 42
    strncpy((char * __restrict  )var_names[var_count], (char const   * __restrict  )str,
            (unsigned long )(name_end - str));
#line 43
    *(var_names[var_count] + (name_end - str)) = (char )'\000';
#line 45
    var_values[var_count] = strdup((char const   *)(name_end + 1));
#line 47
    var_count ++;
  }
#line 50
  return (0);
}
}
#line 1 "cil-Gya0gM2I.o"
#pragma merger(0,"/tmp/cil-XO2jE3rY.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 63 "../../includes/usr/include/fcntl.h"
int fcntl(int fildes , int cmd  , ...) ;
#line 6 "../../mockedFns/fcntl.c"
int fcntl(int fildes , int cmd  , ...) 
{ 

  {
#line 8
  return (0);
}
}
#line 1 "cil-LojLIXVr.o"
#pragma merger(0,"/tmp/cil-Pf5iGlwg.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 724 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int feof(FILE *stream ) ;
#line 41 "../../mockedFns/iosim.h"
int IOSIM_eof(int fildes ) ;
#line 4 "../../mockedFns/feof.c"
 __attribute__((__nothrow__)) int feof(FILE *stream ) ;
#line 4 "../../mockedFns/feof.c"
int feof(FILE *stream ) 
{ sym_file_stream_t *streamAsSymStream ;
  int __cil_tmp ;

  {
#line 6
  streamAsSymStream = (sym_file_stream_t *)stream;
#line 7
  __cil_tmp = IOSIM_eof(streamAsSymStream->fd);
#line 7
  return (__cil_tmp);
}
}
#line 1 "cil-pUDIp8wj.o"
#pragma merger(0,"/tmp/cil-2PMafoGL.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 726 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int ferror(FILE *stream ) ;
#line 3 "../../mockedFns/ferror.c"
 __attribute__((__nothrow__)) int ferror(FILE *stream ) ;
#line 3 "../../mockedFns/ferror.c"
int ferror(FILE *stream ) 
{ 

  {
#line 5
  return (0);
}
}
#line 1 "cil-42LG1HeK.o"
#pragma merger(0,"/tmp/cil-sjhb2amy.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 754 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int fileno(FILE *stream ) ;
#line 759
 __attribute__((__nothrow__)) int fileno_unlocked(FILE *stream ) ;
#line 4 "../../mockedFns/fileno.c"
 __attribute__((__nothrow__)) int fileno(FILE *stream ) ;
#line 4 "../../mockedFns/fileno.c"
int fileno(FILE *stream ) 
{ int retval ;

  {
#line 8
  retval = fileno_unlocked(stream);
#line 10
  return (retval);
}
}
#line 14
 __attribute__((__nothrow__)) int fileno_unlocked(FILE *stream ) ;
#line 14 "../../mockedFns/fileno.c"
int fileno_unlocked(FILE *stream ) 
{ sym_file_stream_t *s ;

  {
#line 17
  s = (sym_file_stream_t *)stream;
#line 18
  if (s->fd >= 0) {
#line 19
    return (s->fd);
  }
#line 22
  return (-1);
}
}
#line 1 "cil-RcdAJ4S3.o"
#pragma merger(0,"/tmp/cil-FkhfDQNN.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 254 "../../includes/usr/include/stdio.h"
FILE *fopen(char const   * __restrict  filename , char const   * __restrict  mode )  __asm__("_fopen64")  ;
#line 27 "../../mockedFns/iosim.h"
sym_file_stream_t *IOSIM_fd[1024] ;
#line 75 "../../includes/usr/include/fcntl.h"
int open(char const   *pathname , int flags  , ...)  __asm__("_open64") __attribute__((__nonnull__(1))) ;
#line 6 "../../mockedFns/fopen.c"
FILE *fopen(char const   * __restrict  filename , char const   * __restrict  mode )  __asm__("_fopen64")  ;
#line 6 "../../mockedFns/fopen.c"
FILE *fopen(char const   * __restrict  filename , char const   * __restrict  mode ) 
{ int openFlags ;
  int plus ;
  int *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;
  int fd ;
  int __cil_tmp___3 ;

  {
#line 8
  plus = 0;
#line 9
  if (! ((int )mode && (int )*(mode + 0))) {
#line 10
    __cil_tmp = __errno_location();
#line 10
    *__cil_tmp = 22;
#line 11
    return ((FILE *)((void *)0));
  }
#line 14
  if ((int const   )*(mode + 1) == 43 || ((int const   )*(mode + 1) == 98 && (int const   )*(mode + 2) == 43)) {
#line 15
    plus = 1;
  }
#line 18
  switch ((int )*(mode + 0)) {
  case 114: 
#line 20
  if (plus) {
#line 20
    openFlags = 2;
  } else {
#line 20
    openFlags = 0;
  }
#line 21
  break;
  case 119: 
#line 23
  if (plus) {
#line 23
    __cil_tmp___0 = 2;
  } else {
#line 23
    __cil_tmp___0 = 1;
  }
#line 23
  openFlags = 576 | __cil_tmp___0;
#line 24
  break;
  case 97: 
#line 26
  if (plus) {
#line 26
    __cil_tmp___1 = 2;
  } else {
#line 26
    __cil_tmp___1 = 1;
  }
#line 26
  openFlags = 1088 | __cil_tmp___1;
#line 27
  break;
  default: 
#line 29
  __cil_tmp___2 = __errno_location();
#line 29
  *__cil_tmp___2 = 22;
#line 30
  return ((FILE *)((void *)0));
  }
#line 33
  __cil_tmp___3 = open((char const   *)filename, openFlags, 438);
#line 33
  fd = __cil_tmp___3;
#line 34
  if (fd == -1) {
#line 35
    return ((FILE *)((void *)0));
  }
#line 37
  return ((FILE *)IOSIM_fd[fd]);
}
}
#line 1 "cil-A9p16GGA.o"
#pragma merger(0,"/tmp/cil-lDc2tcUP.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 645 "../../includes/usr/include/stdio.h"
int fseek(FILE *stream , long offset , int origin ) ;
#line 4 "../../mockedFns/fseek.c"
int fseek(FILE *stream , long offset , int origin ) 
{ 

  {
#line 6
  return (0);
}
}
#line 1 "cil-EuVwdWo5.o"
#pragma merger(0,"/tmp/cil-qi71YDyT.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 450 "../../includes/usr/include/libio.h"
 __attribute__((__nothrow__)) int _IO_getc(struct _IO_FILE *stream ) ;
#line 37 "../../mockedFns/iosim.h"
int IOSIM_read(int fildes , void *buf , size_t___0 nbyte ) ;
#line 4 "../../mockedFns/getc.c"
 __attribute__((__nothrow__)) int _IO_getc(struct _IO_FILE *stream ) ;
#line 4 "../../mockedFns/getc.c"
int _IO_getc(struct _IO_FILE *stream ) 
{ char b[1] ;
  sym_file_stream_t *streamAsSymStream ;
  int flag ;
  int __cil_tmp ;

  {
#line 6
  streamAsSymStream = (sym_file_stream_t *)stream;
#line 7
  __cil_tmp = IOSIM_read(streamAsSymStream->fd, (void *)(b), 1UL);
#line 7
  flag = __cil_tmp;
#line 8
  if (flag < 0) {
#line 8
    return (-1);
  } else {
#line 9
    return ((int )b[0]);
  }
}
}
#line 1 "cil-tJRbFQHX.o"
#pragma merger(0,"/tmp/cil-fG8VwowP.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 144 "../../includes/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 323
int fprintf(FILE * __restrict  file , char const   * __restrict  format  , ...) ;
#line 36 "../../mockedFns/getopt.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 140
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) ;
#line 147
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) ;
#line 242 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) size_t___0 strlen(char const   *s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 7 "../../mockedFns/getopt.c"
char *my_index(char const   *s , int c ) ;
#line 8
extern void exchange() ;
#line 9
extern char const   *_() ;
#line 11 "../../mockedFns/getopt.c"
static int first_nonopt  ;
#line 12 "../../mockedFns/getopt.c"
static int last_nonopt  ;
#line 13 "../../mockedFns/getopt.c"
static char *nextchar  ;
#line 14 "../../mockedFns/getopt.c"
static char *posixly_correct  ;
#line 16 "../../mockedFns/getopt.c"
static enum __anonenum_ordering_18 ordering  ;
#line 21 "../../mockedFns/getopt.c"
int __getopt_initialized  =    0;
#line 23 "../../mockedFns/getopt.c"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) 
{ int __cil_tmp ;

  {
#line 31
  __cil_tmp = _getopt_internal(argc, argv, options, long_options, opt_index, 0);
#line 31
  return (__cil_tmp);
}
}
#line 38
static char const   *_getopt_initialize(int argc , char * const  *argv , char const   *optstring ) ;
#line 40 "../../mockedFns/getopt.c"
static char const   *_getopt_initialize(int argc , char * const  *argv , char const   *optstring ) 
{ 

  {
#line 50
  last_nonopt = optind;
#line 50
  first_nonopt = last_nonopt;
#line 52
  nextchar = (char *)((void *)0);
#line 54
  posixly_correct = getenv("POSIXLY_CORRECT");
#line 58
  if ((int const   )*(optstring + 0) == 45) {
#line 60
    ordering = 2;
#line 61
    optstring ++;
  } else {
#line 63
    if ((int const   )*(optstring + 0) == 43) {
#line 65
      ordering = 0;
#line 66
      optstring ++;
    } else {
#line 68
      if ((unsigned int )posixly_correct != (unsigned int )((void *)0)) {
#line 69
        ordering = 0;
      } else {
#line 71
        ordering = 1;
      }
    }
  }
#line 103
  return (optstring);
}
}
#line 107 "../../mockedFns/getopt.c"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  char *nameend ;
  struct option  const  *p ;
  struct option  const  *pfound ;
  int exact ;
  int ambig ;
  int indfound ;
  int option_index ;
  size_t___0 __cil_tmp___1 ;
  int __cil_tmp___2 ;
  char const   *__cil_tmp___3 ;
  size_t___0 __cil_tmp___4 ;
  char const   *__cil_tmp___5 ;
  char const   *__cil_tmp___6 ;
  size_t___0 __cil_tmp___7 ;
  int __cil_tmp___8 ;
  char const   *__cil_tmp___9 ;
  size_t___0 __cil_tmp___10 ;
  int __cil_tmp___11 ;
  size_t___0 __cil_tmp___12 ;
  char const   *__cil_tmp___13 ;
  char const   *__cil_tmp___14 ;
  char *__cil_tmp___15 ;
  char *__cil_tmp___16 ;
  char c ;
  char *__cil_tmp___17 ;
  char *temp ;
  char *__cil_tmp___18 ;
  char const   *__cil_tmp___19 ;
  char const   *__cil_tmp___20 ;
  char *nameend___0 ;
  struct option  const  *p___0 ;
  struct option  const  *pfound___0 ;
  int exact___0 ;
  int ambig___0 ;
  int indfound___0 ;
  int option_index___0 ;
  char const   *__cil_tmp___21 ;
  int __cil_tmp___22 ;
  size_t___0 __cil_tmp___23 ;
  int __cil_tmp___24 ;
  char const   *__cil_tmp___25 ;
  size_t___0 __cil_tmp___26 ;
  char const   *__cil_tmp___27 ;
  size_t___0 __cil_tmp___28 ;
  int __cil_tmp___29 ;
  char const   *__cil_tmp___30 ;
  size_t___0 __cil_tmp___31 ;
  int __cil_tmp___32 ;
  size_t___0 __cil_tmp___33 ;
  char const   *__cil_tmp___34 ;
  int __cil_tmp___35 ;

  {
#line 116
  optarg = (char *)((void *)0);
#line 118
  if (optind == 0 || ! __getopt_initialized) {
#line 120
    if (optind == 0) {
#line 121
      optind = 1;
    }
#line 122
    optstring = _getopt_initialize(argc, argv, optstring);
#line 123
    __getopt_initialized = 1;
  }
#line 138
  if ((unsigned int )nextchar == (unsigned int )((void *)0) || (int )*nextchar == 0) {
#line 144
    if (last_nonopt > optind) {
#line 145
      last_nonopt = optind;
    }
#line 146
    if (first_nonopt > optind) {
#line 147
      first_nonopt = optind;
    }
#line 149
    if ((int )ordering == 1) {
#line 154
      if (first_nonopt != last_nonopt && last_nonopt != optind) {
#line 155
        exchange((char **)argv);
      } else {
#line 156
        if (last_nonopt != optind) {
#line 157
          first_nonopt = optind;
        }
      }
#line 162
      while (optind < argc && ((int )*(*(argv + optind) + 0) != 45 || (int )*(*(argv + optind) + 1) == 0)) {
#line 163
        optind ++;
      }
#line 164
      last_nonopt = optind;
    }
#line 172
    if (optind != argc) {
#line 172
      __cil_tmp = strcmp((char const   *)*(argv + optind), "--");
#line 172
      if (__cil_tmp) {
#line 172
        goto _L;
      } else {
#line 174
        optind ++;
#line 176
        if (first_nonopt != last_nonopt && last_nonopt != optind) {
#line 177
          exchange((char **)argv);
        } else {
#line 178
          if (first_nonopt == last_nonopt) {
#line 179
            first_nonopt = optind;
          }
        }
#line 180
        last_nonopt = argc;
#line 182
        optind = argc;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 188
    if (optind == argc) {
#line 192
      if (first_nonopt != last_nonopt) {
#line 193
        optind = first_nonopt;
      }
#line 194
      return (-1);
    }
#line 200
    if ((int )*(*(argv + optind) + 0) != 45 || (int )*(*(argv + optind) + 1) == 0) {
#line 202
      if ((int )ordering == 0) {
#line 203
        return (-1);
      }
#line 204
      __cil_tmp___0 = optind;
#line 204
      optind ++;
#line 204
      optarg = (char *)*(argv + __cil_tmp___0);
#line 205
      return (1);
    }
#line 211
    nextchar = (char *)((*(argv + optind) + 1) + ((unsigned int )longopts != (unsigned int )((void *)0) && (int )*(*(argv + optind) + 1) == 45));
  }
#line 230
  if ((unsigned int )longopts != (unsigned int )((void *)0)) {
#line 230
    if ((int )*(*(argv + optind) + 1) == 45) {
#line 230
      goto _L___4;
    } else {
#line 230
      if (long_only) {
#line 230
        if (*(*(argv + optind) + 2)) {
#line 230
          goto _L___4;
        } else {
#line 230
          __cil_tmp___16 = my_index(optstring, (int )*(*(argv + optind) + 1));
#line 230
          if (__cil_tmp___16) {
#line 230
            goto _L___3;
          } else {
            _L___4: /* CIL Label */ 
#line 236
            pfound = (struct option  const  *)((void *)0);
#line 237
            exact = 0;
#line 238
            ambig = 0;
#line 239
            indfound = -1;
#line 242
            nameend = nextchar;
#line 242
            while ((int )*nameend && (int )*nameend != 61) {
#line 242
              nameend ++;
            }
#line 247
            p = longopts;
#line 247
            option_index = 0;
#line 247
            while (p->name) {
#line 248
              __cil_tmp___2 = strncmp((char const   *)p->name, (char const   *)nextchar,
                                      (unsigned long )(nameend - nextchar));
#line 248
              if (! __cil_tmp___2) {
#line 250
                __cil_tmp___1 = strlen((char const   *)p->name);
#line 250
                if ((unsigned int )(nameend - nextchar) == (unsigned int )__cil_tmp___1) {
#line 254
                  pfound = p;
#line 255
                  indfound = option_index;
#line 256
                  exact = 1;
#line 257
                  break;
                } else {
#line 259
                  if ((unsigned int )pfound == (unsigned int )((void *)0)) {
#line 262
                    pfound = p;
#line 263
                    indfound = option_index;
                  } else {
#line 267
                    ambig = 1;
                  }
                }
              }
#line 247
              p ++;
#line 247
              option_index ++;
            }
#line 270
            if (ambig && ! exact) {
#line 272
              if (opterr) {
#line 273
                __cil_tmp___3 = _("%s: option `%s\' is ambiguous\n");
#line 273
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___3,
                        *(argv + 0), *(argv + optind));
              }
#line 275
              __cil_tmp___4 = strlen((char const   *)nextchar);
#line 275
              nextchar += __cil_tmp___4;
#line 276
              optind ++;
#line 277
              optopt = 0;
#line 278
              return ('?');
            }
#line 281
            if ((unsigned int )pfound != (unsigned int )((void *)0)) {
#line 283
              option_index = indfound;
#line 284
              optind ++;
#line 285
              if (*nameend) {
#line 289
                if (pfound->has_arg) {
#line 290
                  optarg = nameend + 1;
                } else {
#line 293
                  if (opterr) {
#line 294
                    if ((int )*(*(argv + (optind - 1)) + 1) == 45) {
#line 296
                      __cil_tmp___5 = _("%s: option `--%s\' doesn\'t allow an argument\n");
#line 296
                      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___5,
                              *(argv + 0), pfound->name);
                    } else {
#line 301
                      __cil_tmp___6 = _("%s: option `%c%s\' doesn\'t allow an argument\n");
#line 301
                      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___6,
                              *(argv + 0), *(*(argv + (optind - 1)) + 0), pfound->name);
                    }
                  }
#line 305
                  __cil_tmp___7 = strlen((char const   *)nextchar);
#line 305
                  nextchar += __cil_tmp___7;
#line 307
                  optopt = (int )pfound->val;
#line 308
                  return ('?');
                }
              } else {
#line 311
                if (pfound->has_arg == 1) {
#line 313
                  if (optind < argc) {
#line 314
                    __cil_tmp___8 = optind;
#line 314
                    optind ++;
#line 314
                    optarg = (char *)*(argv + __cil_tmp___8);
                  } else {
#line 317
                    if (opterr) {
#line 318
                      __cil_tmp___9 = _("%s: option `%s\' requires an argument\n");
#line 318
                      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___9,
                              *(argv + 0), *(argv + (optind - 1)));
                    }
#line 321
                    __cil_tmp___10 = strlen((char const   *)nextchar);
#line 321
                    nextchar += __cil_tmp___10;
#line 322
                    optopt = (int )pfound->val;
#line 323
                    if ((int const   )*(optstring + 0) == 58) {
#line 323
                      __cil_tmp___11 = ':';
                    } else {
#line 323
                      __cil_tmp___11 = '?';
                    }
#line 323
                    return (__cil_tmp___11);
                  }
                }
              }
#line 326
              __cil_tmp___12 = strlen((char const   *)nextchar);
#line 326
              nextchar += __cil_tmp___12;
#line 327
              if ((unsigned int )longind != (unsigned int )((void *)0)) {
#line 328
                *longind = option_index;
              }
#line 329
              if (pfound->flag) {
#line 331
                *(pfound->flag) = (int )pfound->val;
#line 332
                return (0);
              }
#line 334
              return ((int )pfound->val);
            }
#line 341
            if (! long_only || (int )*(*(argv + optind) + 1) == 45) {
#line 341
              goto _L___0;
            } else {
#line 341
              __cil_tmp___15 = my_index(optstring, (int )*nextchar);
#line 341
              if ((unsigned int )__cil_tmp___15 == (unsigned int )((void *)0)) {
                _L___0: /* CIL Label */ 
#line 344
                if (opterr) {
#line 346
                  if ((int )*(*(argv + optind) + 1) == 45) {
#line 348
                    __cil_tmp___13 = _("%s: unrecognized option `--%s\'\n");
#line 348
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___13,
                            *(argv + 0), nextchar);
                  } else {
#line 352
                    __cil_tmp___14 = _("%s: unrecognized option `%c%s\'\n");
#line 352
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___14,
                            *(argv + 0), *(*(argv + optind) + 0), nextchar);
                  }
                }
#line 355
                nextchar = (char *)"";
#line 356
                optind ++;
#line 357
                optopt = 0;
#line 358
                return ('?');
              }
            }
          }
        }
      } else {
        _L___3: /* CIL Label */ 
#line 230
        goto _L___1;
      }
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 365
  __cil_tmp___17 = nextchar;
#line 365
  nextchar ++;
#line 365
  c = *__cil_tmp___17;
#line 366
  __cil_tmp___18 = my_index(optstring, (int )c);
#line 366
  temp = __cil_tmp___18;
#line 369
  if ((int )*nextchar == 0) {
#line 370
    optind ++;
  }
#line 372
  if ((unsigned int )temp == (unsigned int )((void *)0) || (int )c == 58) {
#line 374
    if (opterr) {
#line 376
      if (posixly_correct) {
#line 378
        __cil_tmp___19 = _("%s: illegal option -- %c\n");
#line 378
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___19,
                *(argv + 0), c);
      } else {
#line 381
        __cil_tmp___20 = _("%s: invalid option -- %c\n");
#line 381
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___20,
                *(argv + 0), c);
      }
    }
#line 384
    optopt = (int )c;
#line 385
    return ('?');
  }
#line 388
  if ((int )*(temp + 0) == 87 && (int )*(temp + 1) == 59) {
#line 392
    pfound___0 = (struct option  const  *)((void *)0);
#line 393
    exact___0 = 0;
#line 394
    ambig___0 = 0;
#line 395
    indfound___0 = 0;
#line 399
    if ((int )*nextchar != 0) {
#line 401
      optarg = nextchar;
#line 404
      optind ++;
    } else {
#line 406
      if (optind == argc) {
#line 408
        if (opterr) {
#line 411
          __cil_tmp___21 = _("%s: option requires an argument -- %c\n");
#line 411
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___21,
                  *(argv + 0), c);
        }
#line 414
        optopt = (int )c;
#line 415
        if ((int const   )*(optstring + 0) == 58) {
#line 416
          c = (char )':';
        } else {
#line 418
          c = (char )'?';
        }
#line 419
        return ((int )c);
      } else {
#line 424
        __cil_tmp___22 = optind;
#line 424
        optind ++;
#line 424
        optarg = (char *)*(argv + __cil_tmp___22);
      }
    }
#line 429
    nameend___0 = optarg;
#line 429
    nextchar = nameend___0;
#line 429
    while ((int )*nameend___0 && (int )*nameend___0 != 61) {
#line 429
      nameend___0 ++;
    }
#line 434
    p___0 = longopts;
#line 434
    option_index___0 = 0;
#line 434
    while (p___0->name) {
#line 435
      __cil_tmp___24 = strncmp((char const   *)p___0->name, (char const   *)nextchar,
                               (unsigned long )(nameend___0 - nextchar));
#line 435
      if (! __cil_tmp___24) {
#line 437
        __cil_tmp___23 = strlen((char const   *)p___0->name);
#line 437
        if ((size_t___0 )((unsigned int )(nameend___0 - nextchar)) == __cil_tmp___23) {
#line 440
          pfound___0 = p___0;
#line 441
          indfound___0 = option_index___0;
#line 442
          exact___0 = 1;
#line 443
          break;
        } else {
#line 445
          if ((unsigned int )pfound___0 == (unsigned int )((void *)0)) {
#line 448
            pfound___0 = p___0;
#line 449
            indfound___0 = option_index___0;
          } else {
#line 453
            ambig___0 = 1;
          }
        }
      }
#line 434
      p___0 ++;
#line 434
      option_index___0 ++;
    }
#line 455
    if (ambig___0 && ! exact___0) {
#line 457
      if (opterr) {
#line 458
        __cil_tmp___25 = _("%s: option `-W %s\' is ambiguous\n");
#line 458
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___25,
                *(argv + 0), *(argv + optind));
      }
#line 460
      __cil_tmp___26 = strlen((char const   *)nextchar);
#line 460
      nextchar += __cil_tmp___26;
#line 461
      optind ++;
#line 462
      return ('?');
    }
#line 464
    if ((unsigned int )pfound___0 != (unsigned int )((void *)0)) {
#line 466
      option_index___0 = indfound___0;
#line 467
      if (*nameend___0) {
#line 471
        if (pfound___0->has_arg) {
#line 472
          optarg = nameend___0 + 1;
        } else {
#line 475
          if (opterr) {
#line 476
            __cil_tmp___27 = _("%s: option `-W %s\' doesn\'t allow an argument\n");
#line 476
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___27,
                    *(argv + 0), pfound___0->name);
          }
#line 480
          __cil_tmp___28 = strlen((char const   *)nextchar);
#line 480
          nextchar += __cil_tmp___28;
#line 481
          return ('?');
        }
      } else {
#line 484
        if (pfound___0->has_arg == 1) {
#line 486
          if (optind < argc) {
#line 487
            __cil_tmp___29 = optind;
#line 487
            optind ++;
#line 487
            optarg = (char *)*(argv + __cil_tmp___29);
          } else {
#line 490
            if (opterr) {
#line 491
              __cil_tmp___30 = _("%s: option `%s\' requires an argument\n");
#line 491
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___30,
                      *(argv + 0), *(argv + (optind - 1)));
            }
#line 494
            __cil_tmp___31 = strlen((char const   *)nextchar);
#line 494
            nextchar += __cil_tmp___31;
#line 495
            if ((int const   )*(optstring + 0) == 58) {
#line 495
              __cil_tmp___32 = ':';
            } else {
#line 495
              __cil_tmp___32 = '?';
            }
#line 495
            return (__cil_tmp___32);
          }
        }
      }
#line 498
      __cil_tmp___33 = strlen((char const   *)nextchar);
#line 498
      nextchar += __cil_tmp___33;
#line 499
      if ((unsigned int )longind != (unsigned int )((void *)0)) {
#line 500
        *longind = option_index___0;
      }
#line 501
      if (pfound___0->flag) {
#line 503
        *(pfound___0->flag) = (int )pfound___0->val;
#line 504
        return (0);
      }
#line 506
      return ((int )pfound___0->val);
    }
#line 508
    nextchar = (char *)((void *)0);
#line 509
    return ('W');
  }
#line 511
  if ((int )*(temp + 1) == 58) {
#line 513
    if ((int )*(temp + 2) == 58) {
#line 516
      if ((int )*nextchar != 0) {
#line 518
        optarg = nextchar;
#line 519
        optind ++;
      } else {
#line 522
        optarg = (char *)((void *)0);
      }
#line 523
      nextchar = (char *)((void *)0);
    } else {
#line 528
      if ((int )*nextchar != 0) {
#line 530
        optarg = nextchar;
#line 533
        optind ++;
      } else {
#line 535
        if (optind == argc) {
#line 537
          if (opterr) {
#line 540
            __cil_tmp___34 = _("%s: option requires an argument -- %c\n");
#line 540
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )__cil_tmp___34,
                    *(argv + 0), c);
          }
#line 544
          optopt = (int )c;
#line 545
          if ((int const   )*(optstring + 0) == 58) {
#line 546
            c = (char )':';
          } else {
#line 548
            c = (char )'?';
          }
        } else {
#line 553
          __cil_tmp___35 = optind;
#line 553
          optind ++;
#line 553
          optarg = (char *)*(argv + __cil_tmp___35);
        }
      }
#line 554
      nextchar = (char *)((void *)0);
    }
  }
#line 557
  return ((int )c);
}
}
#line 1 "cil-i7lzZ0qz.o"
#pragma merger(0,"/tmp/cil-75FcE0hN.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 1 "../../mockedFns/getpagesize.c"
 __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
#line 1 "../../mockedFns/getpagesize.c"
int getpagesize(void) 
{ 

  {
#line 2
  return (4096);
}
}
#line 1 "cil-K8TBi8UZ.o"
#pragma merger(0,"/tmp/cil-YE9lnONs.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 1 "../../mockedFns/symexe.h"
extern long long __SYMBOLIC(void *var ) ;
#line 128 "../../includes/usr/include/sys/socket.h"
 __attribute__((__nothrow__)) int getpeername(int socket___0 , struct sockaddr * __restrict  address ,
                                              socklen_t * __restrict  address_len ) ;
#line 5 "../../mockedFns/getpeername.c"
 __attribute__((__nothrow__)) int getpeername(int socket___0 , struct sockaddr * __restrict  address ,
                                              socklen_t * __restrict  address_len ) ;
#line 5 "../../mockedFns/getpeername.c"
int getpeername(int socket___0 , struct sockaddr * __restrict  address , socklen_t * __restrict  address_len ) 
{ long long __cil_tmp ;
  long long __cil_tmp___0 ;

  {
#line 7
  address->sa_family = (unsigned short)2;
#line 9
  __cil_tmp = __SYMBOLIC((void *)0);
#line 9
  address->sa_data[0] = (char )__cil_tmp;
#line 10
  __cil_tmp___0 = __SYMBOLIC((void *)0);
#line 10
  address->sa_data[1] = (char )__cil_tmp___0;
#line 13
  address->sa_data[2] = (char)10;
#line 14
  address->sa_data[3] = (char)20;
#line 15
  address->sa_data[4] = (char)30;
#line 16
  address->sa_data[5] = (char)40;
#line 17
  *address_len = 8U;
#line 18
  return (0);
}
}
#line 1 "cil-Ui64e7VD.o"
#pragma merger(0,"/tmp/cil-PIj04Cd7.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 117 "../../includes/usr/include/pwd.h"
struct passwd *getpwnam(char const   *__name ) ;
#line 4 "../../mockedFns/getpwnam.c"
struct passwd *getpwnam(char const   *__name ) 
{ struct passwd *x ;
  void *__cil_tmp ;

  {
#line 5
  __cil_tmp = malloc(sizeof(struct passwd ));
#line 5
  x = (struct passwd *)__cil_tmp;
#line 15
  x->pw_dir = (char *)"/ftp";
#line 23
  return (x);
}
}
#line 1 "cil-ou8ZMQQs.o"
#pragma merger(0,"/tmp/cil-s2OM4mZC.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 3 "../../mockedFns/gettext.c"
char *gettext(char const   *text ) 
{ 

  {
#line 5
  return ((char *)text);
}
}
#line 1 "cil-MuwfK8dt.o"
#pragma merger(0,"/tmp/cil-RBRjXimq.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 2 "../../mockedFns/groups.c"
int initgroups(char const   *user , __gid_t group ) 
{ 

  {
#line 3
  return (0);
}
}
#line 6
 __attribute__((__nothrow__)) int setgroups(size_t___0 __n , __gid_t const   *__groups ) ;
#line 6 "../../mockedFns/groups.c"
int setgroups(size_t___0 __n , __gid_t const   *__groups ) 
{ 

  {
#line 7
  return (0);
}
}
#line 1 "cil-CL4PWtZs.o"
#pragma merger(0,"/tmp/cil-mJVEUL5s.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 35 "../../includes/usr/include/arpa/inet.h"
 __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *cp ) ;
#line 54
 __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr in ) ;
#line 65
 __attribute__((__nothrow__)) char const   *inet_ntop(int af , void const   * __restrict  src ,
                                                      char * __restrict  dst , socklen_t size ) ;
#line 74
 __attribute__((__nothrow__)) int inet_aton(char const   *cp , struct in_addr *pin ) ;
#line 84 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) char *strcpy(char * __restrict  dst , char const   * __restrict  src )  __attribute__((__nonnull__(1,2))) ;
#line 148 "../../includes/usr/include/stdlib.h"
 __attribute__((__nothrow__)) int atoi(char const   *nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 331 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int sprintf(char * __restrict  buffer , char const   * __restrict  format 
                                          , ...) ;
#line 9 "../../mockedFns/inet.c"
char *inet_nextint(char *s , char delim , int *n ) 
{ char *p ;
  int flag ;

  {
#line 10
  p = s;
#line 11
  while ((int )*p != 0 && (int )*p != (int )delim) {
#line 11
    p ++;
  }
#line 12
  flag = (int )*p == 0;
#line 13
  *p = (char)0;
#line 14
  *n = atoi((char const   *)s);
#line 15
  if (flag) {
#line 15
    return ((char *)0);
  } else {
#line 16
    return (p + 1);
  }
}
}
#line 19
 __attribute__((__nothrow__)) int inet_aton(char const   *cp , struct in_addr *pin ) ;
#line 19 "../../mockedFns/inet.c"
int inet_aton(char const   *cp , struct in_addr *pin ) 
{ int r ;
  int n ;
  char cp2[1024] ;
  char *s ;

  {
#line 20
  r = 0;
#line 22
  strcpy((char * __restrict  )(cp2), (char const   * __restrict  )cp);
#line 23
  s = cp2;
#line 24
  while (1) {
#line 24
    s = inet_nextint(s, (char )'.', & n);
#line 24
    if (! ((unsigned int )s != (unsigned int )((char *)0))) {
#line 24
      break;
    }
#line 26
    r = r * 256 + n;
  }
#line 28
  pin->s_addr = (unsigned int )r;
#line 33
  return (1);
}
}
#line 39 "../../mockedFns/inet.c"
char inet_ntoa_return[20]  ;
#line 40
 __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr in ) ;
#line 40 "../../mockedFns/inet.c"
char *inet_ntoa(struct in_addr in ) 
{ long n ;
  int ip[4] ;
  int i ;

  {
#line 41
  n = (long )in.s_addr;
#line 43
  i = 0;
#line 43
  while (i < 4) {
#line 44
    ip[i] = (int )(n % 256L);
#line 45
    n /= 256L;
#line 43
    i ++;
  }
#line 47
  sprintf((char * __restrict  )(inet_ntoa_return), (char const   * __restrict  )"%d.%d.%d.%d",
          ip[3], ip[2], ip[1], ip[0]);
#line 53
  return (inet_ntoa_return);
}
}
#line 60
 __attribute__((__nothrow__)) char const   *inet_ntop(int af , void const   * __restrict  src ,
                                                      char * __restrict  dst , socklen_t size ) ;
#line 60 "../../mockedFns/inet.c"
char const   *inet_ntop(int af , void const   * __restrict  src , char * __restrict  dst ,
                        socklen_t size ) 
{ 

  {
#line 62
  strcpy(dst, (char const   * __restrict  )"11.22.33.44");
#line 63
  return ((char const   *)dst);
}
}
#line 66
 __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *cp ) ;
#line 66 "../../mockedFns/inet.c"
in_addr_t inet_addr(char const   *cp ) 
{ struct in_addr val ;
  int __cil_tmp ;

  {
#line 70
  __cil_tmp = inet_aton(cp, & val);
#line 70
  if (__cil_tmp) {
#line 71
    return (val.s_addr);
  }
#line 74
  return (4294967295U);
}
}
#line 1 "cil-AL6S4HLz.o"
#pragma merger(0,"/tmp/cil-DjQL7jbR.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 2 "../../mockedFns/symexe.h"
extern void __EVAL() ;
#line 7
extern void __EVALSTR(char *str , int len ) ;
#line 275 "../../includes/usr/include/sys/stat.h"
 __attribute__((__nothrow__)) __mode_t umask(__mode_t cmask ) ;
#line 27 "../../mockedFns/iosim.h"
sym_file_stream_t *IOSIM_fd[1024]  ;
#line 28
int IOSIM_num_fd ;
#line 31
sym_file_t *IOSIM_findfile(char const   *file ) ;
#line 32
sym_file_t *IOSIM_addfile(char const   *filename , mode_t mode ) ;
#line 34
char *IOSIM_toAbsolute(char const   *name ) ;
#line 36
int IOSIM_newfd(void) ;
#line 38
int IOSIM_ungetc(int c , int fildes ) ;
#line 39
int IOSIM_write(int fildes , void const   *buf , size_t___0 nbyte ) ;
#line 40
int IOSIM_close(int fildes ) ;
#line 42
int IOSIM_openWithMode(char const   *name , int flags , mode_t mode ) ;
#line 43
int IOSIM_open(char const   *name , int flags ) ;
#line 44
sym_file_stream_t *IOSIM_getStream(int fd ) ;
#line 45
int IOSIM_rename(char const   *old , char const   *new ) ;
#line 46
int IOSIM_unlink(char const   *pathname ) ;
#line 48
char *IOSIM_getcwd(char *buf , size_t___0 size ) ;
#line 38 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) void *memcpy(void * __restrict  dst , void const   * __restrict  src ,
                                           size_t___0 n )  __attribute__((__nonnull__(1,2))) ;
#line 170
 __attribute__((__nothrow__)) char *strrchr(char const   *s , int c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 595 "../../includes/usr/include/stdlib.h"
 __attribute__((__nothrow__)) void *realloc(void *ptr , size_t___0 size )  __attribute__((__malloc__)) ;
#line 749
 __attribute__((__nothrow__)) char *realpath(char const   * __restrict  path , char * __restrict  got_path ) ;
#line 9 "../../mockedFns/iosim.c"
int IOSIM_num_file  =    0;
#line 10 "../../mockedFns/iosim.c"
char *IOSIM_file_name[1024]  ;
#line 11 "../../mockedFns/iosim.c"
sym_file_t *IOSIM_file[1024]  ;
#line 14 "../../mockedFns/iosim.c"
char workingDir[4097]  = {      (char )'/',      (char )'\000'};
#line 20 "../../mockedFns/iosim.c"
int IOSIM_num_fd  =    3;
#line 35 "../../mockedFns/iosim.c"
sym_file_t *IOSIM_findfile(char const   *file ) 
{ int i ;
  int __cil_tmp ;

  {
#line 36
  i = 0;
#line 36
  while (i < IOSIM_num_file) {
#line 37
    __cil_tmp = strcmp(file, (char const   *)IOSIM_file_name[i]);
#line 37
    if (__cil_tmp == 0) {
#line 38
      return (IOSIM_file[i]);
    }
#line 36
    i ++;
  }
#line 40
  return ((sym_file_t *)((void *)0));
}
}
#line 44 "../../mockedFns/iosim.c"
sym_file_t *IOSIM_addfile(char const   *filename , mode_t mode ) 
{ int *__cil_tmp ;
  int *__cil_tmp___0 ;
  sym_file_t *file ;
  void *__cil_tmp___1 ;

  {
#line 45
  if (IOSIM_num_file >= 1024) {
#line 46
    __cil_tmp = __errno_location();
#line 46
    *__cil_tmp = 24;
#line 47
    return ((sym_file_t *)-1);
  }
#line 49
  if (IOSIM_num_fd >= 1024) {
#line 50
    __cil_tmp___0 = __errno_location();
#line 50
    *__cil_tmp___0 = 23;
#line 51
    return ((sym_file_t *)-1);
  }
#line 53
  __cil_tmp___1 = malloc(sizeof(sym_file_t ));
#line 53
  file = (sym_file_t *)__cil_tmp___1;
#line 58
  file->stat.st_size = 0LL;
#line 59
  file->contents = (char *)((void *)0);
#line 61
  file->stat.st_nlink = 1U;
#line 64
  file->stat.st_mode = (32768U | mode) | (unsigned int )((256 >> 3) >> 3);
#line 68
  file->stat.st_uid = 1234U;
#line 69
  file->stat.st_gid = 5678U;
#line 70
  file->stat.st_atim.tv_sec = 1L;
#line 71
  file->stat.st_atim.tv_nsec = 2L;
#line 72
  file->stat.st_mtim.tv_sec = 1L;
#line 73
  file->stat.st_mtim.tv_nsec = 2L;
#line 74
  file->stat.st_ctim.tv_sec = 1L;
#line 75
  file->stat.st_ctim.tv_nsec = 2L;
#line 77
  IOSIM_file_name[IOSIM_num_file] = strdup(filename);
#line 78
  IOSIM_file[IOSIM_num_file] = file;
#line 79
  IOSIM_num_file ++;
#line 81
  return (file);
}
}
#line 84 "../../mockedFns/iosim.c"
int IOSIM_newfd(void) 
{ int ret___0 ;

  {
#line 85
  if (IOSIM_num_fd >= 1024) {
#line 86
    __COMMENT((char *)"Too many file descriptors");
#line 87
    exit(1);
  }
#line 89
  ret___0 = IOSIM_num_fd;
#line 90
  IOSIM_num_fd ++;
#line 91
  return (ret___0);
}
}
#line 95 "../../mockedFns/iosim.c"
char *IOSIM_toAbsolute(char const   *name ) 
{ char *absoluteName ;
  void *__cil_tmp ;
  char *lastSlash ;
  char *__cil_tmp___0 ;
  char *path ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  char *end ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  char const   *__cil_tmp___5 ;

  {
#line 96
  __cil_tmp = malloc(4097UL);
#line 96
  absoluteName = (char *)__cil_tmp;
#line 97
  __cil_tmp___0 = strrchr(name, '/');
#line 97
  lastSlash = __cil_tmp___0;
#line 98
  if (lastSlash) {
#line 99
    if ((unsigned int )lastSlash == (unsigned int )name) {
#line 100
      strcpy((char * __restrict  )absoluteName, (char const   * __restrict  )"/");
    } else {
#line 102
      __cil_tmp___1 = strdup(name);
#line 102
      path = __cil_tmp___1;
#line 103
      *(path + (lastSlash - (char *)name)) = (char)0;
#line 104
      __cil_tmp___2 = realpath((char const   * __restrict  )path, (char * __restrict  )absoluteName);
#line 104
      if (! __cil_tmp___2) {
#line 105
        free((void *)path);
#line 106
        return ((char *)((void *)0));
      }
#line 108
      free((void *)path);
    }
  } else {
#line 111
    strcpy((char * __restrict  )absoluteName, (char const   * __restrict  )(workingDir));
  }
#line 114
  __cil_tmp___3 = strchr((char const   *)absoluteName, 0);
#line 114
  end = __cil_tmp___3;
#line 116
  if (*(absoluteName + 1)) {
#line 117
    __cil_tmp___4 = end;
#line 117
    end ++;
#line 117
    *__cil_tmp___4 = (char )'/';
  }
#line 119
  if (lastSlash) {
#line 119
    __cil_tmp___5 = (char const   *)(lastSlash + 1);
  } else {
#line 119
    __cil_tmp___5 = name;
  }
#line 119
  strcpy((char * __restrict  )end, (char const   * __restrict  )__cil_tmp___5);
#line 120
  return (absoluteName);
}
}
#line 123 "../../mockedFns/iosim.c"
static mode_t usermask  ;
#line 124
 __attribute__((__nothrow__)) __mode_t umask(__mode_t cmask ) ;
#line 124 "../../mockedFns/iosim.c"
__mode_t umask(__mode_t cmask ) 
{ mode_t oldMask ;

  {
#line 125
  oldMask = usermask;
#line 126
  usermask = cmask & 511U;
#line 127
  return (oldMask);
}
}
#line 130 "../../mockedFns/iosim.c"
int IOSIM_openWithMode(char const   *name , int flags , mode_t mode ) 
{ char *absoluteName ;
  char *__cil_tmp ;
  sym_file_t *sym_file ;
  sym_file_t *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;
  sym_file_stream_t *sym_stream ;
  void *__cil_tmp___3 ;
  int fd ;
  int __cil_tmp___4 ;

  {
#line 131
  __cil_tmp = IOSIM_toAbsolute(name);
#line 131
  absoluteName = __cil_tmp;
#line 132
  __cil_tmp___0 = IOSIM_findfile((char const   *)absoluteName);
#line 132
  sym_file = __cil_tmp___0;
#line 133
  if (sym_file) {
#line 135
    if (flags & 64 && flags & 128) {
#line 136
      __cil_tmp___1 = __errno_location();
#line 136
      *__cil_tmp___1 = 17;
#line 137
      free((void *)absoluteName);
#line 138
      return (-1);
    }
  } else {
#line 140
    if (flags & 64) {
#line 142
      sym_file = IOSIM_addfile((char const   *)absoluteName, mode & ~ usermask);
#line 143
      free((void *)absoluteName);
    } else {
#line 146
      __cil_tmp___2 = __errno_location();
#line 146
      *__cil_tmp___2 = 2;
#line 147
      free((void *)absoluteName);
#line 148
      return (-1);
    }
  }
#line 152
  __cil_tmp___3 = malloc(sizeof(sym_file_stream_t ));
#line 152
  sym_stream = (sym_file_stream_t *)__cil_tmp___3;
#line 155
  __cil_tmp___4 = IOSIM_newfd();
#line 155
  fd = __cil_tmp___4;
#line 156
  IOSIM_fd[fd] = sym_stream;
#line 159
  sym_stream->sym_file = sym_file;
#line 160
  sym_stream->offset = 0LL;
#line 161
  sym_stream->fd = fd;
#line 163
  return (fd);
}
}
#line 166 "../../mockedFns/iosim.c"
int IOSIM_open(char const   *name , int flags ) 
{ int __cil_tmp ;

  {
#line 167
  __cil_tmp = IOSIM_openWithMode(name, flags, 511U);
#line 167
  return (__cil_tmp);
}
}
#line 170 "../../mockedFns/iosim.c"
sym_file_stream_t *IOSIM_getStream(int fd ) 
{ 

  {
#line 171
  return (IOSIM_fd[fd]);
}
}
#line 174 "../../mockedFns/iosim.c"
int IOSIM_rename(char const   *old , char const   *new ) 
{ char *absOld ;
  char *__cil_tmp ;
  char *absNew ;
  char *__cil_tmp___0 ;
  int i ;
  sym_file_t *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;

  {
#line 176
  __cil_tmp = IOSIM_toAbsolute(old);
#line 176
  absOld = __cil_tmp;
#line 177
  if (! absOld) {
#line 178
    return (-1);
  }
#line 180
  __cil_tmp___0 = IOSIM_toAbsolute(new);
#line 180
  absNew = __cil_tmp___0;
#line 181
  if (! absNew) {
#line 182
    free((void *)absOld);
#line 183
    return (-1);
  }
#line 185
  i = 0;
#line 185
  while (i < IOSIM_num_file) {
#line 186
    __cil_tmp___2 = strcmp((char const   *)absOld, (char const   *)IOSIM_file_name[i]);
#line 186
    if (__cil_tmp___2 == 0) {
#line 188
      __cil_tmp___1 = IOSIM_findfile((char const   *)absNew);
#line 188
      if (__cil_tmp___1) {
#line 190
        IOSIM_unlink((char const   *)absNew);
      }
#line 192
      free((void *)IOSIM_file_name[i]);
#line 193
      free((void *)absOld);
#line 194
      IOSIM_file_name[i] = absNew;
#line 195
      return (0);
    }
#line 185
    i ++;
  }
#line 199
  free((void *)absOld);
#line 200
  __cil_tmp___3 = __errno_location();
#line 200
  *__cil_tmp___3 = 2;
#line 201
  return (-1);
}
}
#line 203 "../../mockedFns/iosim.c"
int IOSIM_unlink(char const   *pathname ) 
{ char *absoluteName ;
  char *__cil_tmp ;
  int i ;
  sym_file_t *sym_file ;
  int __cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 204
  __cil_tmp = IOSIM_toAbsolute(pathname);
#line 204
  absoluteName = __cil_tmp;
#line 205
  i = 0;
#line 205
  while (i < IOSIM_num_file) {
#line 206
    __cil_tmp___0 = strcmp((char const   *)absoluteName, (char const   *)IOSIM_file_name[i]);
#line 206
    if (__cil_tmp___0 == 0) {
#line 207
      free((void *)absoluteName);
#line 208
      free((void *)IOSIM_file_name[i]);
#line 209
      sym_file = IOSIM_file[i];
#line 211
      (sym_file->stat.st_nlink) --;
#line 213
      if (sym_file->stat.st_nlink == 0U) {
#line 214
        free((void *)sym_file->contents);
#line 215
        free((void *)sym_file);
      }
#line 219
      IOSIM_num_file --;
#line 220
      while (i < IOSIM_num_file) {
#line 221
        IOSIM_file[i] = IOSIM_file[i + 1];
#line 222
        IOSIM_file_name[i] = IOSIM_file_name[i + 1];
#line 220
        i ++;
      }
#line 225
      return (0);
    }
#line 205
    i ++;
  }
#line 228
  __cil_tmp___1 = __errno_location();
#line 228
  *__cil_tmp___1 = 2;
#line 229
  return (-1);
}
}
#line 232 "../../mockedFns/iosim.c"
int IOSIM_close(int fildes ) 
{ int *__cil_tmp ;

  {
#line 233
  if ((fildes < 0 || fildes >= IOSIM_num_fd) || (unsigned int )IOSIM_fd[fildes] == (unsigned int )((void *)0)) {
#line 234
    __cil_tmp = __errno_location();
#line 234
    *__cil_tmp = 9;
#line 235
    return (-1);
  }
#line 237
  IOSIM_fd[fildes] = (sym_file_stream_t *)((void *)0);
#line 238
  return (0);
}
}
#line 241 "../../mockedFns/iosim.c"
int IOSIM_read(int fildes , void *buf , size_t___0 nbyte ) 
{ size_t___0 n ;
  int cur ;
  int len ;
  char *cbuf ;
  sym_file_stream_t *in ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 244
  cbuf = (char *)buf;
#line 246
  if (nbyte == 0UL) {
#line 246
    return (0);
  }
#line 250
  in = IOSIM_fd[fildes];
#line 252
  cur = (int )in->offset;
#line 253
  len = (int )(in->sym_file)->stat.st_size;
#line 254
  if ((unsigned int )in->buffer == (unsigned int )((void *)0)) {
#line 255
    __cil_tmp = malloc((unsigned long )len);
#line 255
    __cil_tmp___0 = memcpy((void * __restrict  )__cil_tmp, (void const   * __restrict  )(in->sym_file)->contents,
                           (unsigned long )len);
#line 255
    in->buffer = (char *)__cil_tmp___0;
  }
#line 257
  n = 0UL;
#line 257
  while (n < nbyte) {
#line 258
    if (cur >= len) {
#line 259
      *(cbuf + n) = (char)-1;
#line 260
      break;
    }
#line 262
    *(cbuf + n) = *(in->buffer + cur);
#line 264
    cur ++;
#line 257
    n ++;
  }
#line 266
  in->offset = (long long )cur;
#line 267
  return ((int )n);
}
}
#line 270 "../../mockedFns/iosim.c"
int IOSIM_ungetc(int c , int fildes ) 
{ sym_file_stream_t *in ;

  {
#line 272
  in = IOSIM_fd[fildes];
#line 274
  (in->offset) --;
#line 275
  *(in->buffer + in->offset) = (char )c;
#line 277
  return (c);
}
}
#line 280 "../../mockedFns/iosim.c"
int IOSIM_write(int fildes , void const   *buf , size_t___0 nbyte ) 
{ int cur ;
  int len ;
  char *cbuf ;
  sym_file_stream_t *out ;
  void *__cil_tmp ;

  {
#line 282
  cbuf = (char *)buf;
#line 284
  if (nbyte == 0UL) {
#line 284
    return (0);
  }
#line 285
  if (fildes == 0) {
#line 286
    __COMMENT((char *)"Writing on fildes 0");
#line 287
    __EVALSTR((char *)buf, (int )nbyte);
#line 288
    return (-1);
  }
#line 291
  out = IOSIM_fd[fildes];
#line 292
  cur = (int )out->offset;
#line 293
  len = (int )(out->sym_file)->stat.st_size;
#line 296
  if ((size_t___0 )cur + nbyte > (size_t___0 )len) {
#line 297
    __cil_tmp = realloc((void *)(out->sym_file)->contents, (size_t___0 )cur + nbyte);
#line 297
    (out->sym_file)->contents = (char *)__cil_tmp;
#line 298
    (out->sym_file)->stat.st_size = (long long )((size_t___0 )cur + nbyte);
#line 299
    len = (int )((size_t___0 )cur + nbyte);
  }
#line 302
  memcpy((void * __restrict  )((out->sym_file)->contents + cur), (void const   * __restrict  )cbuf,
         nbyte);
#line 309
  __COMMENT((char *)"Writing on fildes");
#line 310
  __EVAL(fildes);
#line 311
  __EVALSTR((char *)buf, (int )nbyte);
#line 312
  __COMMENT((char *)"Done");
#line 315
  out->offset += (__quad_t )nbyte;
#line 317
  return ((int )nbyte);
}
}
#line 320 "../../mockedFns/iosim.c"
int IOSIM_eof(int fildes ) 
{ int cur ;
  int len ;
  sym_file_stream_t *in ;

  {
#line 323
  in = IOSIM_fd[fildes];
#line 325
  cur = (int )in->offset;
#line 326
  len = (int )(in->sym_file)->stat.st_size;
#line 328
  return (cur >= len);
}
}
#line 332 "../../mockedFns/iosim.c"
int IOSIM_chdir(char const   *path ) 
{ char newWorkingDir[4097] ;
  char *__cil_tmp ;

  {
#line 336
  __cil_tmp = realpath((char const   * __restrict  )path, (char * __restrict  )(newWorkingDir));
#line 336
  if (__cil_tmp) {
#line 337
    strcpy((char * __restrict  )(workingDir), (char const   * __restrict  )(newWorkingDir));
#line 338
    return (0);
  }
#line 340
  return (-1);
}
}
#line 359 "../../mockedFns/iosim.c"
void initDir(DIR *dir , int i ) 
{ void *__cil_tmp ;

  {
#line 360
  dir->index = i;
#line 361
  dir->filestream.fd = IOSIM_newfd();
#line 362
  __cil_tmp = malloc(sizeof(sym_file_t ));
#line 362
  dir->filestream.sym_file = (sym_file_t *)__cil_tmp;
#line 363
  (dir->filestream.sym_file)->stat.st_mode = (unsigned int )((256 >> 3) >> 3);
#line 364
  IOSIM_fd[dir->filestream.fd] = & dir->filestream;
#line 365
  return;
}
}
#line 367 "../../mockedFns/iosim.c"
DIR *IOSIM_opendir(char const   *dirname ) 
{ DIR *dir ;
  void *__cil_tmp ;
  char *__cil_tmp___0 ;
  int length ;
  size_t___0 __cil_tmp___1 ;
  int i ;
  char *filename ;
  int __cil_tmp___2 ;
  int *__cil_tmp___3 ;

  {
#line 368
  __cil_tmp = malloc(sizeof(DIR ));
#line 368
  dir = (DIR *)__cil_tmp;
#line 369
  __cil_tmp___0 = realpath((char const   * __restrict  )dirname, (char * __restrict  )(dir->dirname));
#line 369
  if (! __cil_tmp___0) {
#line 370
    free((void *)dir);
#line 371
    return ((DIR *)((void *)0));
  }
#line 373
  __cil_tmp___1 = strlen((char const   *)(dir->dirname));
#line 373
  length = (int )__cil_tmp___1;
#line 374
  if (length == 1) {
#line 375
    initDir(dir, 0);
#line 376
    return (dir);
  }
#line 378
  i = 0;
#line 378
  while (i < IOSIM_num_file) {
#line 379
    filename = IOSIM_file_name[i];
#line 388
    __cil_tmp___2 = strncmp((char const   *)(dir->dirname), (char const   *)filename,
                            (unsigned long )length);
#line 388
    if (__cil_tmp___2) {
      _L: /* CIL Label */ ;
    } else {
#line 388
      if ((int )*(filename + length) == 47) {
#line 391
        initDir(dir, i);
#line 392
        return (dir);
      } else {
#line 388
        goto _L;
      }
    }
#line 378
    i ++;
  }
#line 396
  __cil_tmp___3 = __errno_location();
#line 396
  *__cil_tmp___3 = 2;
#line 397
  free((void *)dir);
#line 398
  return ((DIR *)((void *)0));
}
}
#line 401 "../../mockedFns/iosim.c"
int IOSIM_closedir(DIR *dir ) 
{ 

  {
#line 402
  IOSIM_fd[dir->filestream.fd] = (sym_file_stream_t *)((void *)0);
#line 403
  free((void *)dir);
#line 404
  return (0);
}
}
#line 407 "../../mockedFns/iosim.c"
struct dirent *IOSIM_readdir(DIR *dir ) 
{ char *filename ;
  char *lastSlash ;
  char *__cil_tmp ;
  int dirContainsThisFile ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int *__cil_tmp___4 ;
  size_t___0 __cil_tmp___5 ;

  {
#line 408
  while (dir->index < IOSIM_num_file) {
#line 411
    filename = IOSIM_file_name[dir->index];
#line 412
    (dir->index) ++;
#line 413
    __cil_tmp = strrchr((char const   *)filename, '/');
#line 413
    lastSlash = __cil_tmp;
#line 415
    if ((unsigned int )lastSlash == (unsigned int )filename) {
#line 416
      __cil_tmp___0 = strcmp("/", (char const   *)(dir->dirname));
#line 416
      if (__cil_tmp___0) {
#line 416
        __cil_tmp___1 = 0;
      } else {
#line 416
        __cil_tmp___1 = 1;
      }
#line 416
      dirContainsThisFile = __cil_tmp___1;
    } else {
#line 418
      *lastSlash = (char)0;
#line 419
      __cil_tmp___2 = strcmp((char const   *)filename, (char const   *)(dir->dirname));
#line 419
      if (__cil_tmp___2) {
#line 419
        __cil_tmp___3 = 0;
      } else {
#line 419
        __cil_tmp___3 = 1;
      }
#line 419
      dirContainsThisFile = __cil_tmp___3;
#line 420
      *lastSlash = (char )'/';
    }
#line 422
    if (dirContainsThisFile) {
#line 423
      __cil_tmp___5 = strlen((char const   *)filename);
#line 423
      if (__cil_tmp___5 >= sizeof(dir->readdirRetval.d_name)) {
#line 424
        __cil_tmp___4 = __errno_location();
#line 424
        *__cil_tmp___4 = 75;
#line 425
        return ((struct dirent *)((void *)0));
      }
#line 427
      strcpy((char * __restrict  )(dir->readdirRetval.d_name), (char const   * __restrict  )(lastSlash + 1));
#line 428
      return (& dir->readdirRetval);
    }
  }
#line 431
  return ((struct dirent *)((void *)0));
}
}
#line 434 "../../mockedFns/iosim.c"
char *IOSIM_getcwd(char *buf , size_t___0 size ) 
{ int *__cil_tmp ;
  size_t___0 __cil_tmp___0 ;
  void *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int *__cil_tmp___3 ;
  size_t___0 __cil_tmp___4 ;
  void *__cil_tmp___5 ;
  char *__cil_tmp___6 ;

  {
#line 435
  if (size == 0UL) {
#line 436
    if (buf) {
#line 437
      __cil_tmp = __errno_location();
#line 437
      *__cil_tmp = 22;
#line 438
      return ((char *)((void *)0));
    }
#line 440
    __cil_tmp___0 = strlen((char const   *)(workingDir));
#line 440
    __cil_tmp___1 = malloc(__cil_tmp___0 + 1UL);
#line 440
    buf = (char *)__cil_tmp___1;
#line 441
    __cil_tmp___2 = strcpy((char * __restrict  )buf, (char const   * __restrict  )(workingDir));
#line 441
    return (__cil_tmp___2);
  }
#line 443
  __cil_tmp___4 = strlen((char const   *)(workingDir));
#line 443
  if (size <= __cil_tmp___4) {
#line 444
    __cil_tmp___3 = __errno_location();
#line 444
    *__cil_tmp___3 = 34;
#line 445
    return ((char *)((void *)0));
  }
#line 447
  if (! buf) {
#line 448
    __cil_tmp___5 = malloc(size);
#line 448
    buf = (char *)__cil_tmp___5;
  }
#line 450
  __cil_tmp___6 = strcpy((char * __restrict  )buf, (char const   * __restrict  )(workingDir));
#line 450
  return (__cil_tmp___6);
}
}
#line 453 "../../mockedFns/iosim.c"
int IOSIM_dirfd(DIR *dir ) 
{ 

  {
#line 454
  return (dir->filestream.fd);
}
}
#line 1 "cil-vVn44kP2.o"
#pragma merger(0,"/tmp/cil-7q84tWtX.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 4 "../../mockedFns/libintl.c"
char *directory  ;
#line 6 "../../mockedFns/libintl.c"
char *bindtextdomain(char const   *domainname , char const   *dirname ) 
{ void *__cil_tmp ;

  {
#line 8
  __cil_tmp = malloc(4112UL);
#line 8
  directory = (char *)__cil_tmp;
#line 9
  strcpy((char * __restrict  )directory, (char const   * __restrict  )dirname);
#line 11
  return ((char *)domainname);
}
}
#line 14 "../../mockedFns/libintl.c"
char *textdomain(char const   *domainname ) 
{ 

  {
#line 16
  return (directory);
}
}
#line 1 "cil-mJjaDjMy.o"
#pragma merger(0,"/tmp/cil-aFT8cBUr.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 66 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) void *memchr(void const   *s , int c , size_t___0 n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 3 "../../mockedFns/memchr.c"
 __attribute__((__nothrow__)) void *memchr(void const   *s , int c , size_t___0 n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 3 "../../mockedFns/memchr.c"
void *memchr(void const   *s , int c , size_t___0 n ) 
{ char *r ;

  {
#line 5
  r = (char *)((char const   *)s);
#line 7
  while (n) {
#line 8
    if ((int )*r == (int )((char )c)) {
#line 9
      return ((void *)r);
    }
#line 11
    r ++;
#line 12
    n --;
  }
#line 15
  return ((void *)0);
}
}
#line 1 "cil-iNtWUavr.o"
#pragma merger(0,"/tmp/cil-Qjrjee5V.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 12 "../../mockedFns/memswap.c"
void memswap(void *m1 , void *m2 , size_t___0 n ) 
{ char *p ;
  char *q ;
  char tmp ;
  size_t___0 __cil_tmp ;

  {
#line 14
  p = (char *)m1;
#line 15
  q = (char *)m2;
#line 18
  while (1) {
#line 18
    __cil_tmp = n;
#line 18
    n --;
#line 18
    if (! __cil_tmp) {
#line 18
      break;
    }
#line 19
    tmp = *p;
#line 20
    *p = *q;
#line 21
    *q = tmp;
#line 23
    p ++;
#line 24
    q ++;
  }
#line 26
  return;
}
}
#line 1 "cil-2r8HlJ97.o"
#pragma merger(0,"/tmp/cil-KeJQPCEG.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "../../mockedFns/mmap.c"
 __attribute__((__nothrow__)) void *mmap(void *start , size_t___0 length , int prot ,
                                         int flags , int fd , __quad_t offset )  __asm__("_mmap64")  ;
#line 7 "../../mockedFns/mmap.c"
void *mmap(void *start , size_t___0 length , int prot , int flags , int fd , __quad_t offset ) 
{ void *x ;
  void *__cil_tmp ;

  {
#line 8
  __cil_tmp = malloc(length);
#line 8
  x = __cil_tmp;
#line 9
  return (x);
}
}
#line 20
 __attribute__((__nothrow__)) int munmap(void *addr , size_t___0 len ) ;
#line 20 "../../mockedFns/mmap.c"
int munmap(void *addr , size_t___0 len ) 
{ 

  {
#line 21
  return (0);
}
}
#line 1 "cil-Ca1hAJrp.o"
#pragma merger(0,"/tmp/cil-dm9MBD3g.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 2 "../../mockedFns/mprotect.c"
 __attribute__((__nothrow__)) int mprotect(void *__addr , size_t___0 __len , int __prot ) ;
#line 2 "../../mockedFns/mprotect.c"
int mprotect(void *__addr , size_t___0 __len , int __prot ) 
{ 

  {
#line 3
  return (0);
}
}
#line 1 "cil-q9qCnj7H.o"
#pragma merger(0,"/tmp/cil-A9dfeAXj.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 3 "../../mockedFns/my_index.c"
char *my_index(char const   *s , int c ) 
{ char *__cil_tmp ;

  {
#line 5
  __cil_tmp = strchr(s, c);
#line 5
  return (__cil_tmp);
}
}
#line 1 "cil-Bde3arO3.o"
#pragma merger(0,"/tmp/cil-yi9liraB.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 354 "../../includes/usr/include/netinet/in.h"
 __attribute__((__nothrow__)) uint32_t ntohl(uint32_t netlong )  __attribute__((__const__)) ;
#line 355
 __attribute__((__nothrow__)) uint16_t ntohs(uint16_t netshort )  __attribute__((__const__)) ;
#line 357
 __attribute__((__nothrow__)) uint32_t htonl(uint32_t hostlong )  __attribute__((__const__)) ;
#line 359
 __attribute__((__nothrow__)) uint16_t htons(uint16_t hostshort )  __attribute__((__const__)) ;
#line 4 "../../mockedFns/netConv.c"
 __attribute__((__nothrow__)) uint32_t htonl(uint32_t hostlong )  __attribute__((__const__)) ;
#line 4 "../../mockedFns/netConv.c"
uint32_t htonl(uint32_t hostlong ) 
{ uint32_t retval ;
  char *p_out ;
  char *p_in ;

  {
#line 6
  p_out = (char *)(& retval);
#line 6
  p_in = (char *)(& hostlong);
#line 7
  *(p_out + 0) = *(p_in + 3);
#line 8
  *(p_out + 1) = *(p_in + 2);
#line 9
  *(p_out + 2) = *(p_in + 1);
#line 10
  *(p_out + 3) = *(p_in + 0);
#line 11
  return (retval);
}
}
#line 14
 __attribute__((__nothrow__)) uint16_t htons(uint16_t hostshort )  __attribute__((__const__)) ;
#line 14 "../../mockedFns/netConv.c"
uint16_t htons(uint16_t hostshort ) 
{ uint16_t retval ;
  char *p_out ;
  char *p_in ;

  {
#line 16
  p_out = (char *)(& retval);
#line 16
  p_in = (char *)(& hostshort);
#line 17
  *(p_out + 0) = *(p_in + 1);
#line 18
  *(p_out + 1) = *(p_in + 0);
#line 19
  return (retval);
}
}
#line 22
 __attribute__((__nothrow__)) uint32_t ntohl(uint32_t netlong )  __attribute__((__const__)) ;
#line 22 "../../mockedFns/netConv.c"
uint32_t ntohl(uint32_t netlong ) 
{ uint32_t retval ;
  char *p_out ;
  char *p_in ;

  {
#line 24
  p_out = (char *)(& retval);
#line 24
  p_in = (char *)(& netlong);
#line 25
  *(p_out + 0) = *(p_in + 3);
#line 26
  *(p_out + 1) = *(p_in + 2);
#line 27
  *(p_out + 2) = *(p_in + 1);
#line 28
  *(p_out + 3) = *(p_in + 0);
#line 29
  return (retval);
}
}
#line 32
 __attribute__((__nothrow__)) uint16_t ntohs(uint16_t netshort )  __attribute__((__const__)) ;
#line 32 "../../mockedFns/netConv.c"
uint16_t ntohs(uint16_t netshort ) 
{ uint16_t retval ;
  char *p_out ;
  char *p_in ;

  {
#line 34
  p_out = (char *)(& retval);
#line 34
  p_in = (char *)(& netshort);
#line 35
  *(p_out + 0) = *(p_in + 1);
#line 36
  *(p_out + 1) = *(p_in + 0);
#line 37
  return (retval);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "cil-6qX92rKV.o"
#pragma merger(0,"/tmp/cil-40a4RrRq.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "../../mockedFns/open.c"
int open(char const   *pathname , int flags  , ...)  __asm__("_open64") __attribute__((__nonnull__(1))) ;
#line 7 "../../mockedFns/open.c"
int open(char const   *pathname , int flags  , ...) 
{ va_list varargs ;
  mode_t mode ;
  mode_t __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 8
  if (flags & 64) {
#line 13
    __builtin_va_start(varargs, flags);
#line 14
    __cil_tmp = __builtin_va_arg(varargs, mode_t );
#line 14
    mode = __cil_tmp;
#line 15
    __builtin_va_end(varargs);
#line 16
    __cil_tmp___0 = IOSIM_openWithMode(pathname, flags, mode);
#line 16
    return (__cil_tmp___0);
  }
#line 18
  __cil_tmp___1 = IOSIM_open(pathname, flags);
#line 18
  return (__cil_tmp___1);
}
}
#line 1 "cil-nPmPlve1.o"
#pragma merger(0,"/tmp/cil-MdPFHhX7.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 27 "../../includes/usr/include/security/pam_appl.h"
int pam_start(char const   *service_name , char const   *user , struct pam_conv  const  *pam_conversation ,
              pam_handle_t **pamh ) ;
#line 2 "../../mockedFns/pam.c"
int pam_start(char const   *service_name , char const   *user , struct pam_conv  const  *pam_conversation ,
              pam_handle_t **pamh ) 
{ 

  {
#line 4
  return (-1);
}
}
#line 1 "cil-mlBOxFRz.o"
#pragma merger(0,"/tmp/cil-UpBw06jp.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 1 "../../mockedFns/prctl.c"
int prctl(int __option  , ...) 
{ 

  {
#line 2
  return (0);
}
}
#line 1 "cil-JDA4ccgp.o"
#pragma merger(0,"/tmp/cil-85gkqVT6.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 480 "../../includes/usr/include/stdio.h"
int putc(int c , FILE *stream ) ;
#line 5 "../../mockedFns/putc.c"
int putc(int c , FILE *stream ) 
{ 

  {
#line 7
  return (0);
}
}
#line 1 "cil-zR3WriEq.o"
#pragma merger(0,"/tmp/cil-6h4ghXTf.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 15 "../../mockedFns/qsort.c"
__inline static size_t___0 newgap(size_t___0 gap ) 
{ 

  {
#line 17
  gap = (gap * 10UL) / 13UL;
#line 18
  if (gap == 9UL || gap == 10UL) {
#line 19
    gap = 11UL;
  }
#line 21
  if (gap < 1UL) {
#line 22
    gap = 1UL;
  }
#line 23
  return (gap);
}
}
#line 26
void qsort(void *base , size_t___0 nmemb , size_t___0 size , int (*compar)(void const   * ,
                                                                           void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 26 "../../mockedFns/qsort.c"
void qsort(void *base , size_t___0 nmemb , size_t___0 size , int (*compar)(void const   * ,
                                                                           void const   * ) ) 
{ size_t___0 gap ;
  size_t___0 i ;
  size_t___0 j ;
  char *p1 ;
  char *p2 ;
  int swapped ;
  int __cil_tmp ;

  {
#line 29
  gap = nmemb;
#line 34
  if (! nmemb) {
#line 35
    return;
  }
#line 37
  while (1) {
#line 38
    gap = newgap(gap);
#line 39
    swapped = 0;
#line 41
    i = 0UL;
#line 41
    p1 = (char *)base;
#line 41
    while (i < nmemb - gap) {
#line 42
      j = i + gap;
#line 43
      p2 = (char *)base + j * size;
#line 43
      __cil_tmp = (*compar)((void const   *)p1, (void const   *)p2);
#line 43
      if (__cil_tmp > 0) {
#line 44
        memswap((void *)p1, (void *)p2, size);
#line 45
        swapped = 1;
      }
#line 41
      i ++;
#line 41
      p1 += size;
    }
#line 37
    if (! (gap > 1UL || swapped)) {
#line 37
      break;
    }
  }
#line 49
  return;
}
}
#line 1 "cil-p1lLb48d.o"
#pragma merger(0,"/tmp/cil-GcMegCl3.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 4 "../../mockedFns/realloc.c"
 __attribute__((__nothrow__)) void *realloc(void *ptr , size_t___0 size )  __attribute__((__malloc__)) ;
#line 4 "../../mockedFns/realloc.c"
void *realloc(void *ptr , size_t___0 size ) 
{ void *__cil_tmp ;

  {
#line 5
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 6
    __cil_tmp = malloc(size);
#line 6
    return (__cil_tmp);
  }
#line 9
  if (size == 0UL) {
#line 10
    free(ptr);
#line 11
    return ((void *)0);
  }
#line 19
  *((char *)ptr + (size - 1UL)) = (char)0;
#line 20
  return (ptr);
}
}
#line 1 "cil-470qiOCG.o"
#pragma merger(0,"/tmp/cil-B4OV9yJZ.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 450 "../../includes/usr/include/unistd.h"
 __attribute__((__nothrow__)) char *getcwd(char *buf , size_t___0 size ) ;
#line 9 "../../mockedFns/realpath.c"
 __attribute__((__nothrow__)) char *realpath(char const   * __restrict  path , char * __restrict  got_path ) ;
#line 9 "../../mockedFns/realpath.c"
char *realpath(char const   * __restrict  path , char * __restrict  got_path ) 
{ char copy_path[4096] ;
  char *max_path ;
  char *new_path ;
  size_t___0 path_len ;
  int readlinks ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  size_t___0 __cil_tmp___3 ;
  char *__cil_tmp___4 ;
  char *__cil_tmp___5 ;
  int *__cil_tmp___6 ;
  char *__cil_tmp___7 ;
  char const   * __restrict  __cil_tmp___8 ;
  char *__cil_tmp___9 ;

  {
#line 17
  readlinks = 0;
#line 22
  if ((unsigned int )path == (unsigned int )((void *)0)) {
#line 23
    __cil_tmp = __errno_location();
#line 23
    *__cil_tmp = 22;
#line 24
    return ((char *)((void *)0));
  }
#line 26
  if ((int const   )*path == 0) {
#line 27
    __cil_tmp___0 = __errno_location();
#line 27
    *__cil_tmp___0 = 2;
#line 28
    return ((char *)((void *)0));
  }
#line 31
  path_len = strlen((char const   *)path);
#line 32
  if (path_len >= 4094UL) {
#line 33
    __cil_tmp___1 = __errno_location();
#line 33
    *__cil_tmp___1 = 36;
#line 34
    return ((char *)((void *)0));
  }
#line 37
  strcpy((char * __restrict  )((copy_path + 4095) - path_len), path);
#line 38
  path = (char const   * __restrict  )((copy_path + 4095) - path_len);
#line 39
  max_path = (char *)((got_path + 4096) - 2);
#line 40
  new_path = (char *)got_path;
#line 41
  if ((int const   )*path != 47) {
#line 43
    __cil_tmp___2 = getcwd(new_path, 4095UL);
#line 43
    if (! __cil_tmp___2) {
#line 44
      return ((char *)((void *)0));
    }
#line 45
    __cil_tmp___3 = strlen((char const   *)new_path);
#line 45
    new_path += __cil_tmp___3;
#line 46
    if ((int )*(new_path + -1) != 47) {
#line 47
      __cil_tmp___4 = new_path;
#line 47
      new_path ++;
#line 47
      *__cil_tmp___4 = (char )'/';
    }
  } else {
#line 49
    __cil_tmp___5 = new_path;
#line 49
    new_path ++;
#line 49
    *__cil_tmp___5 = (char )'/';
#line 50
    path ++;
  }
#line 53
  while ((int const   )*path != 0) {
#line 55
    if ((int const   )*path == 47) {
#line 56
      path ++;
#line 57
      continue;
    }
#line 59
    if ((int const   )*path == 46) {
#line 61
      if ((int const   )*(path + 1) == 0 || (int const   )*(path + 1) == 47) {
#line 62
        path ++;
#line 63
        continue;
      }
#line 65
      if ((int const   )*(path + 1) == 46) {
#line 66
        if ((int const   )*(path + 2) == 0 || (int const   )*(path + 2) == 47) {
#line 67
          path += 2;
#line 69
          if ((unsigned int )new_path == (unsigned int )(got_path + 1)) {
#line 70
            continue;
          }
#line 72
          while (1) {
#line 72
            new_path --;
#line 72
            if (! ((int )*(new_path + -1) != 47)) {
#line 72
              break;
            }
          }
#line 73
          continue;
        }
      }
    }
#line 78
    while ((int const   )*path != 0 && (int const   )*path != 47) {
#line 79
      if ((unsigned int )new_path > (unsigned int )max_path) {
#line 80
        __cil_tmp___6 = __errno_location();
#line 80
        *__cil_tmp___6 = 36;
#line 81
        return ((char *)((void *)0));
      }
#line 83
      __cil_tmp___7 = new_path;
#line 83
      new_path ++;
#line 83
      __cil_tmp___8 = path;
#line 83
      path ++;
#line 83
      *__cil_tmp___7 = (char )*__cil_tmp___8;
    }
#line 123
    __cil_tmp___9 = new_path;
#line 123
    new_path ++;
#line 123
    *__cil_tmp___9 = (char )'/';
  }
#line 126
  if ((unsigned int )new_path != (unsigned int )(got_path + 1) && (int )*(new_path + -1) == 47) {
#line 127
    new_path --;
  }
#line 129
  *new_path = (char )'\000';
#line 130
  return ((char *)got_path);
}
}
#line 1 "cil-aDR9DvMe.o"
#pragma merger(0,"/tmp/cil-ou9g35ef.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 143 "../../includes/usr/include/sys/socket.h"
ssize_t recv(int sockfd , void *buf , size_t___0 len , int flags ) ;
#line 6 "../../mockedFns/recv.c"
ssize_t recv(int sockfd , void *buf , size_t___0 len , int flags ) 
{ int *__cil_tmp ;
  int num_chars_read ;
  int __cil_tmp___0 ;

  {
#line 7
  if ((sockfd < 0 || sockfd >= IOSIM_num_fd) || (unsigned int )IOSIM_fd[sockfd] == (unsigned int )((void *)0)) {
#line 8
    __cil_tmp = __errno_location();
#line 8
    *__cil_tmp = 9;
#line 9
    return (-1);
  }
#line 11
  __cil_tmp___0 = IOSIM_read(sockfd, buf, len);
#line 11
  num_chars_read = __cil_tmp___0;
#line 12
  if (flags & 2) {
#line 14
    (IOSIM_fd[sockfd])->offset -= (__quad_t )num_chars_read;
  }
#line 16
  return (num_chars_read);
}
}
#line 1 "cil-cYYE0eqV.o"
#pragma merger(0,"/tmp/cil-iOrdBg0b.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 161 "../../includes/usr/include/sys/socket.h"
ssize_t recvfrom(int sockfd , void * __restrict  buffer , size_t___0 len , int flags ,
                 struct sockaddr * __restrict  to , socklen_t * __restrict  tolen ) ;
#line 3 "../../mockedFns/recvfrom.c"
ssize_t recvfrom(int sockfd , void * __restrict  buffer , size_t___0 len , int flags ,
                 struct sockaddr * __restrict  to , socklen_t * __restrict  tolen ) 
{ ssize_t __cil_tmp ;

  {
#line 6
  __cil_tmp = recv(sockfd, (void *)buffer, len, flags);
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-Gg46kuXE.o"
#pragma merger(0,"/tmp/cil-wBPSpTw7.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 154 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int remove(char const   *filename ) ;
#line 3 "../../mockedFns/remove.c"
 __attribute__((__nothrow__)) int remove(char const   *filename ) ;
#line 3 "../../mockedFns/remove.c"
int remove(char const   *filename ) 
{ 

  {
#line 5
  return (0);
}
}
#line 1 "cil-kGKk6SzE.o"
#pragma merger(0,"/tmp/cil-4SvPnQhd.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 156 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int rename(char const   *old , char const   *new ) ;
#line 4 "../../mockedFns/rename.c"
 __attribute__((__nothrow__)) int rename(char const   *old , char const   *new ) ;
#line 4 "../../mockedFns/rename.c"
int rename(char const   *old , char const   *new ) 
{ int __cil_tmp ;

  {
#line 5
  __cil_tmp = IOSIM_rename(old, new);
#line 5
  return (__cil_tmp);
}
}
#line 1 "cil-kEsi27qd.o"
#pragma merger(0,"/tmp/cil-FWeIgATR.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 38 "../../includes/usr/include/sys/sendfile.h"
 __attribute__((__nothrow__)) ssize_t sendfile(int out_fd , int in_fd , __quad_t *offset ,
                                               size_t___0 count )  __asm__("_sendfile64")  ;
#line 314 "../../includes/usr/include/unistd.h"
ssize_t read(int fildes , void *buf , size_t___0 nbyte ) ;
#line 320
ssize_t write(int fildes , void const   *buf , size_t___0 nbyte ) ;
#line 9 "../../mockedFns/sendfile.c"
 __attribute__((__nothrow__)) ssize_t sendfile(int out_fd , int in_fd , __quad_t *offset ,
                                               size_t___0 count )  __asm__("_sendfile64")  ;
#line 9 "../../mockedFns/sendfile.c"
ssize_t sendfile(int out_fd , int in_fd , __quad_t *offset , size_t___0 count ) 
{ int *__cil_tmp ;
  sym_file_stream_t *inbuf ;
  int *__cil_tmp___0 ;
  ssize_t numSent ;
  char *tempBuf ;
  void *__cil_tmp___1 ;
  __quad_t origOffset ;

  {
#line 10
  if (((in_fd >= IOSIM_num_fd || in_fd < 0) || out_fd >= IOSIM_num_fd) || out_fd < 0) {
#line 11
    __cil_tmp = __errno_location();
#line 11
    *__cil_tmp = 9;
#line 12
    return (-1);
  }
#line 14
  inbuf = IOSIM_fd[in_fd];
#line 15
  if (! inbuf) {
#line 16
    __cil_tmp___0 = __errno_location();
#line 16
    *__cil_tmp___0 = 9;
#line 17
    return (-1);
  }
#line 21
  __cil_tmp___1 = malloc(count);
#line 21
  tempBuf = (char *)__cil_tmp___1;
#line 23
  if (offset) {
#line 26
    origOffset = inbuf->offset;
#line 28
    inbuf->offset = *offset;
#line 29
    numSent = read(in_fd, (void *)tempBuf, count);
#line 30
    *offset += (__quad_t )numSent;
#line 31
    inbuf->offset = origOffset;
  } else {
#line 35
    numSent = read(in_fd, (void *)tempBuf, count);
  }
#line 38
  if (numSent == -1) {
#line 39
    free((void *)tempBuf);
#line 40
    return (-1);
  }
#line 44
  numSent = write(out_fd, (void const   *)tempBuf, (unsigned long )numSent);
#line 46
  free((void *)tempBuf);
#line 48
  return (numSent);
}
}
#line 1 "cil-2Y9Onhie.o"
#pragma merger(0,"/tmp/cil-KbKp5TQK.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 150 "../../includes/usr/include/sys/socket.h"
int sendto(int s , void const   *msg , size_t___0 len , int flags , struct sockaddr  const  *to ,
           socklen_t tolen ) ;
#line 3 "../../mockedFns/sendto.c"
int sendto(int s , void const   *msg , size_t___0 len , int flags , struct sockaddr  const  *to ,
           socklen_t tolen ) 
{ 

  {
#line 5
  return (0);
}
}
#line 1 "cil-5T35PXmh.o"
#pragma merger(0,"/tmp/cil-SCkZ73EG.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 125 "../../includes/usr/include/locale.h"
 __attribute__((__nothrow__)) char *setlocale(int category , char const   *locale ) ;
#line 3 "../../mockedFns/setlocale.c"
 __attribute__((__nothrow__)) char *setlocale(int category , char const   *locale ) ;
#line 3 "../../mockedFns/setlocale.c"
char *setlocale(int category , char const   *locale ) 
{ 

  {
#line 5
  return ((char *)locale);
}
}
#line 1 "cil-s3frM3X9.o"
#pragma merger(0,"/tmp/cil-MWSvA8Ma.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 216 "../../includes/usr/include/signal.h"
 __attribute__((__nothrow__)) int sigemptyset(sigset_t *set )  __attribute__((__nonnull__(1))) ;
#line 219
 __attribute__((__nothrow__)) int sigfillset(sigset_t *set )  __attribute__((__nonnull__(1))) ;
#line 222
 __attribute__((__nothrow__)) int sigaddset(sigset_t *set , int signo )  __attribute__((__nonnull__(1))) ;
#line 249
 __attribute__((__nothrow__)) int sigprocmask(int how , sigset_t const   * __restrict  set ,
                                              sigset_t * __restrict  oset ) ;
#line 260
 __attribute__((__nothrow__)) int sigaction(int sig , struct sigaction  const  * __restrict  act ,
                                            struct sigaction * __restrict  oact ) ;
#line 2 "../../mockedFns/sig.c"
 __attribute__((__nothrow__)) int sigfillset(sigset_t *set )  __attribute__((__nonnull__(1))) ;
#line 2 "../../mockedFns/sig.c"
int sigfillset(sigset_t *set ) 
{ 

  {
#line 3
  return (0);
}
}
#line 6
 __attribute__((__nothrow__)) int sigaction(int sig , struct sigaction  const  * __restrict  act ,
                                            struct sigaction * __restrict  oact ) ;
#line 6 "../../mockedFns/sig.c"
int sigaction(int sig , struct sigaction  const  * __restrict  act , struct sigaction * __restrict  oact ) 
{ 

  {
#line 8
  return (0);
}
}
#line 11
 __attribute__((__nothrow__)) int sigemptyset(sigset_t *set )  __attribute__((__nonnull__(1))) ;
#line 11 "../../mockedFns/sig.c"
int sigemptyset(sigset_t *set ) 
{ 

  {
#line 12
  return (0);
}
}
#line 15
 __attribute__((__nothrow__)) int sigaddset(sigset_t *set , int signo )  __attribute__((__nonnull__(1))) ;
#line 15 "../../mockedFns/sig.c"
int sigaddset(sigset_t *set , int signo ) 
{ 

  {
#line 16
  return (0);
}
}
#line 19
 __attribute__((__nothrow__)) int sigprocmask(int how , sigset_t const   * __restrict  set ,
                                              sigset_t * __restrict  oset ) ;
#line 19 "../../mockedFns/sig.c"
int sigprocmask(int how , sigset_t const   * __restrict  set , sigset_t * __restrict  oset ) 
{ 

  {
#line 21
  return (0);
}
}
#line 1 "cil-g4mZQCiN.o"
#pragma merger(0,"/tmp/cil-ZvFK2pQ7.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 362 "../../includes/usr/include/signal.h"
 __attribute__((__nothrow__)) int sigaltstack(struct sigaltstack  const  * __restrict  ss ,
                                              struct sigaltstack * __restrict  oss ) ;
#line 3 "../../mockedFns/signal.c"
 __attribute__((__nothrow__)) int sigaltstack(struct sigaltstack  const  * __restrict  ss ,
                                              struct sigaltstack * __restrict  oss ) ;
#line 3 "../../mockedFns/signal.c"
int sigaltstack(struct sigaltstack  const  * __restrict  ss , struct sigaltstack * __restrict  oss ) 
{ 

  {
#line 5
  return (0);
}
}
#line 1 "cil-VzWQmY1Y.o"
#pragma merger(0,"/tmp/cil-J2MerQLy.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 109 "../../includes/usr/include/sys/select.h"
int select(int nfds , fd_set * __restrict  readfds , fd_set * __restrict  writefds ,
           fd_set * __restrict  errorfds , struct timeval * __restrict  timeout ) ;
#line 100 "../../includes/usr/include/sys/socket.h"
 __attribute__((__nothrow__)) int socket(int domain , int type , int protocol ) ;
#line 106
 __attribute__((__nothrow__)) int socketpair(int domain , int type , int protocol ,
                                             int *socket_vector ) ;
#line 110
 __attribute__((__nothrow__)) int bind(int socket___0 , struct sockaddr  const  *address ,
                                       socklen_t address_len ) ;
#line 114
 __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                              socklen_t * __restrict  __len ) ;
#line 124
int connect(int socket___0 , struct sockaddr  const  *address , socklen_t address_len ) ;
#line 192
 __attribute__((__nothrow__)) int setsockopt(int socket___0 , int level , int option_name ,
                                             void const   *option_value , socklen_t option_len ) ;
#line 199
 __attribute__((__nothrow__)) int listen(int socket___0 , int backlog ) ;
#line 209
int accept(int sockfd , struct sockaddr * __restrict  address , socklen_t * __restrict  address_len ) ;
#line 9 "../../mockedFns/socket.c"
 __attribute__((__nothrow__)) int setsockopt(int socket___0 , int level , int option_name ,
                                             void const   *option_value , socklen_t option_len ) ;
#line 9 "../../mockedFns/socket.c"
int setsockopt(int socket___0 , int level , int option_name , void const   *option_value ,
               socklen_t option_len ) 
{ 

  {
#line 11
  return (0);
}
}
#line 14
 __attribute__((__nothrow__)) int socket(int domain , int type , int protocol ) ;
#line 14 "../../mockedFns/socket.c"
int socket(int domain , int type , int protocol ) 
{ int __cil_tmp ;

  {
#line 15
  __cil_tmp = IOSIM_newfd();
#line 15
  return (__cil_tmp);
}
}
#line 29
 __attribute__((__nothrow__)) int bind(int socket___0 , struct sockaddr  const  *address ,
                                       socklen_t address_len ) ;
#line 29 "../../mockedFns/socket.c"
int bind(int socket___0 , struct sockaddr  const  *address , socklen_t address_len ) 
{ 

  {
#line 32
  return (0);
}
}
#line 35
 __attribute__((__nothrow__)) int listen(int socket___0 , int backlog ) ;
#line 35 "../../mockedFns/socket.c"
int listen(int socket___0 , int backlog ) 
{ 

  {
#line 36
  return (0);
}
}
#line 39
 __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                              socklen_t * __restrict  __len ) ;
#line 39 "../../mockedFns/socket.c"
int getsockname(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __len ) 
{ char fakeName[13] ;

  {
#line 40
  fakeName[0] = (char )'s';
#line 40
  fakeName[1] = (char )'o';
#line 40
  fakeName[2] = (char )'m';
#line 40
  fakeName[3] = (char )'e';
#line 40
  fakeName[4] = (char )'s';
#line 40
  fakeName[5] = (char )'o';
#line 40
  fakeName[6] = (char )'c';
#line 40
  fakeName[7] = (char )'k';
#line 40
  fakeName[8] = (char )'n';
#line 40
  fakeName[9] = (char )'a';
#line 40
  fakeName[10] = (char )'m';
#line 40
  fakeName[11] = (char )'e';
#line 40
  fakeName[12] = (char )'\000';
#line 41
  strcpy((char * __restrict  )(__addr->sa_data), (char const   * __restrict  )(fakeName));
#line 42
  __addr->sa_family = iosim_ip_version;
#line 43
  *__len = (unsigned int )(sizeof(__addr->sa_family) + sizeof(fakeName));
#line 44
  return (0);
}
}
#line 47 "../../mockedFns/socket.c"
int connect(int socket___0 , struct sockaddr  const  *address , socklen_t address_len ) 
{ 

  {
#line 49
  return (0);
}
}
#line 52 "../../mockedFns/socket.c"
int accept(int sockfd , struct sockaddr * __restrict  address , socklen_t * __restrict  address_len ) 
{ int __cil_tmp ;

  {
#line 54
  address->sa_family = iosim_ip_version;
#line 60
  address->sa_data[2] = (char)10;
#line 61
  address->sa_data[3] = (char)20;
#line 62
  address->sa_data[4] = (char)30;
#line 63
  address->sa_data[5] = (char)40;
#line 66
  __cil_tmp = IOSIM_newfd();
#line 66
  return (__cil_tmp);
}
}
#line 69
 __attribute__((__nothrow__)) int socketpair(int domain , int type , int protocol ,
                                             int *socket_vector ) ;
#line 69 "../../mockedFns/socket.c"
int socketpair(int domain , int type , int protocol , int *socket_vector ) 
{ int fd0 ;
  int __cil_tmp ;
  void *__cil_tmp___0 ;
  void *__cil_tmp___1 ;
  int fd1 ;
  int __cil_tmp___2 ;
  void *__cil_tmp___3 ;

  {
#line 71
  __cil_tmp = IOSIM_newfd();
#line 71
  fd0 = __cil_tmp;
#line 72
  __cil_tmp___0 = malloc(sizeof(sym_file_stream_t ));
#line 72
  IOSIM_fd[fd0] = (sym_file_stream_t *)__cil_tmp___0;
#line 73
  (IOSIM_fd[fd0])->offset = 0LL;
#line 75
  __cil_tmp___1 = malloc(sizeof(sym_file_t ));
#line 75
  (IOSIM_fd[fd0])->sym_file = (sym_file_t *)__cil_tmp___1;
#line 76
  ((IOSIM_fd[fd0])->sym_file)->contents = (char *)((void *)0);
#line 77
  ((IOSIM_fd[fd0])->sym_file)->stat.st_size = 0LL;
#line 78
  ((IOSIM_fd[fd0])->sym_file)->stat.st_mode = 49152U;
#line 81
  __cil_tmp___2 = IOSIM_newfd();
#line 81
  fd1 = __cil_tmp___2;
#line 82
  __cil_tmp___3 = malloc(sizeof(sym_file_stream_t ));
#line 82
  IOSIM_fd[fd1] = (sym_file_stream_t *)__cil_tmp___3;
#line 83
  (IOSIM_fd[fd1])->offset = 0LL;
#line 84
  (IOSIM_fd[fd1])->sym_file = (IOSIM_fd[fd0])->sym_file;
#line 86
  *(socket_vector + 0) = fd0;
#line 87
  *(socket_vector + 1) = fd1;
#line 89
  return (0);
}
}
#line 92 "../../mockedFns/socket.c"
int select(int nfds , fd_set * __restrict  readfds , fd_set * __restrict  writefds ,
           fd_set * __restrict  errorfds , struct timeval * __restrict  timeout ) 
{ 

  {
#line 95
  return (1);
}
}
#line 1 "cil-oDQ99WK7.o"
#pragma merger(0,"/tmp/cil-QLQSDk13.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 403 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int sscanf(char const   * __restrict  s , char const   * __restrict  format 
                                         , ...) ;
#line 598
int ungetc(int c , FILE *stream ) ;
#line 23 "../../mockedFns/sscanf.c"
static char Xtable[256]  ;
#line 24 "../../mockedFns/sscanf.c"
static char inp_buf[512]  ;
#line 25 "../../mockedFns/sscanf.c"
static int scanf_counter  =    33;
#line 65
int isdigit(int c ) ;
#line 65
int isxdigit(int c ) ;
#line 27 "../../mockedFns/sscanf.c"
static char *o_collect(int c , sym_file_stream_t *stream , char type , unsigned int width ,
                       int *basep ) 
{ register char *bufp ;
  register int base ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;

  {
#line 29
  bufp = inp_buf;
#line 32
  switch ((int )type) {
  case 105: 
  case 112: 
  case 120: 
  case 88: 
#line 36
  base = 16;
#line 36
  break;
  case 100: 
  case 117: 
#line 38
  base = 10;
#line 38
  break;
  case 111: 
#line 39
  base = 8;
#line 39
  break;
  case 98: 
#line 40
  base = 2;
#line 40
  break;
  }
#line 43
  if (c == 45 || c == 43) {
#line 44
    __cil_tmp = bufp;
#line 44
    bufp ++;
#line 44
    *__cil_tmp = (char )c;
#line 45
    width --;
#line 45
    if (width) {
#line 46
      c = _IO_getc((_IO_FILE *)stream);
    }
  }
#line 49
  if (((int )width && c == 48) && base == 16) {
#line 50
    __cil_tmp___0 = bufp;
#line 50
    bufp ++;
#line 50
    *__cil_tmp___0 = (char )c;
#line 51
    width --;
#line 51
    if (width) {
#line 52
      c = _IO_getc((_IO_FILE *)stream);
    }
#line 53
    if (c != 120 && c != 88) {
#line 54
      if ((int )type == 105) {
#line 54
        base = 8;
      }
    } else {
#line 56
      if (width) {
#line 57
        __cil_tmp___1 = bufp;
#line 57
        bufp ++;
#line 57
        *__cil_tmp___1 = (char )c;
#line 58
        width --;
#line 58
        if (width) {
#line 59
          c = _IO_getc((_IO_FILE *)stream);
        }
      }
    }
  } else {
#line 62
    if ((int )type == 105) {
#line 62
      base = 10;
    }
  }
#line 64
  while (width) {
#line 65
    if (base == 10) {
#line 65
      __cil_tmp___3 = isdigit(c);
#line 65
      if (__cil_tmp___3) {
#line 65
        goto _L___5;
      } else {
#line 65
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
#line 65
      if (base == 16) {
#line 65
        __cil_tmp___4 = isxdigit(c);
#line 65
        if (__cil_tmp___4) {
          _L___5: /* CIL Label */ 
#line 65
          goto _L___2;
        } else {
#line 65
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
#line 65
        if (base == 8) {
#line 65
          __cil_tmp___5 = isdigit(c);
#line 65
          if (__cil_tmp___5) {
#line 65
            if (c < 56) {
              _L___2: /* CIL Label */ 
#line 65
              goto _L;
            } else {
#line 65
              goto _L___4;
            }
          } else {
#line 65
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 65
          if (base == 2) {
#line 65
            __cil_tmp___6 = isdigit(c);
#line 65
            if (__cil_tmp___6) {
#line 65
              if (c < 50) {
                _L: /* CIL Label */ 
#line 69
                __cil_tmp___2 = bufp;
#line 69
                bufp ++;
#line 69
                *__cil_tmp___2 = (char )c;
#line 70
                width --;
#line 70
                if (width) {
#line 71
                  c = _IO_getc((_IO_FILE *)stream);
                }
              } else {
#line 65
                goto _L___1;
              }
            } else {
#line 65
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 73
            break;
          }
        }
      }
    }
  }
#line 76
  if ((int )width && c != -1) {
#line 76
    ungetc(c, (FILE *)stream);
  }
#line 77
  if ((int )type == 105) {
#line 77
    base = 0;
  }
#line 78
  *basep = base;
#line 79
  *bufp = (char )'\000';
#line 80
  return (bufp - 1);
}
}
#line 105
int isspace(int c ) ;
#line 178
extern int ( /* missing proto */  set_pointer)() ;
#line 205
 __attribute__((__nothrow__)) long strtol(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                          int base )  __attribute__((__nonnull__(1))) ;
#line 207
 __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  nptr ,
                                                    char ** __restrict  endptr , int base )  __attribute__((__nonnull__(1))) ;
#line 332
extern int ( /* missing proto */  f_collect)() ;
#line 346
extern int ( /* missing proto */  strtod)() ;
#line 83 "../../mockedFns/sscanf.c"
int _doscan(sym_file_stream_t *stream , char const   *format , va_list ap ) 
{ int done ;
  int nrchars ;
  int conv ;
  int base ;
  unsigned long val ;
  register char *str ;
  char *tmp_string ;
  unsigned int width ;
  int flags ;
  int reverse ;
  int kind ;
  register int ic ;
  long double ld_val ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  char const   *__cil_tmp___2 ;
  char const   *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  short *__cil_tmp___8 ;
  long *__cil_tmp___9 ;
  int *__cil_tmp___10 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  unsigned long *__cil_tmp___13 ;
  unsigned short *__cil_tmp___14 ;
  unsigned int *__cil_tmp___15 ;
  char *__cil_tmp___16 ;
  char *__cil_tmp___17 ;
  int __cil_tmp___18 ;
  char const   *__cil_tmp___19 ;
  char const   *__cil_tmp___20 ;
  int c ;
  char *__cil_tmp___21 ;
  int __cil_tmp___22 ;
  int __cil_tmp___23 ;
  long double *__cil_tmp___24 ;
  double *__cil_tmp___25 ;
  float *__cil_tmp___26 ;
  int __cil_tmp___27 ;

  {
#line 85
  done = 0;
#line 86
  nrchars = 0;
#line 87
  conv = 0;
#line 92
  width = 0U;
#line 96
  ic = -1;
#line 101
  if (! *format) {
#line 101
    return (0);
  }
#line 103
  while (1) {
#line 104
    __cil_tmp___1 = isspace(*format);
#line 104
    if (__cil_tmp___1) {
#line 105
      while (1) {
#line 105
        __cil_tmp = isspace(*format);
#line 105
        if (! __cil_tmp) {
#line 105
          break;
        }
#line 106
        format ++;
      }
#line 107
      ic = _IO_getc((_IO_FILE *)stream);
#line 108
      nrchars ++;
#line 109
      while (1) {
#line 109
        __cil_tmp___0 = isspace(ic);
#line 109
        if (! __cil_tmp___0) {
#line 109
          break;
        }
#line 110
        ic = _IO_getc((_IO_FILE *)stream);
#line 111
        nrchars ++;
      }
#line 113
      if (ic != -1) {
#line 113
        ungetc(ic, (FILE *)stream);
      }
#line 114
      nrchars --;
    }
#line 116
    if (! *format) {
#line 116
      break;
    }
#line 118
    if ((int const   )*format != 37) {
#line 119
      ic = _IO_getc((_IO_FILE *)stream);
#line 120
      nrchars ++;
#line 121
      __cil_tmp___2 = format;
#line 121
      format ++;
#line 121
      if (ic != (int )*__cil_tmp___2) {
#line 121
        break;
      }
#line 122
      continue;
    }
#line 124
    format ++;
#line 125
    if ((int const   )*format == 37) {
#line 126
      ic = _IO_getc((_IO_FILE *)stream);
#line 127
      nrchars ++;
#line 128
      if (ic == 37) {
#line 129
        format ++;
#line 130
        continue;
      } else {
#line 132
        break;
      }
    }
#line 134
    flags = 0;
#line 135
    if ((int const   )*format == 42) {
#line 136
      format ++;
#line 137
      flags |= 2048;
    }
#line 139
    __cil_tmp___5 = isdigit(*format);
#line 139
    if (__cil_tmp___5) {
#line 140
      flags |= 256;
#line 141
      width = 0U;
#line 141
      while (1) {
#line 141
        __cil_tmp___4 = isdigit(*format);
#line 141
        if (! __cil_tmp___4) {
#line 141
          break;
        }
#line 142
        __cil_tmp___3 = format;
#line 142
        format ++;
#line 142
        width = (width * 10U + (unsigned int )*__cil_tmp___3) - 48U;
      }
    }
#line 145
    switch ((int )*format) {
    case 104: 
#line 146
    flags |= 32;
#line 146
    format ++;
#line 146
    break;
    case 108: 
#line 147
    flags |= 64;
#line 147
    format ++;
#line 147
    break;
    case 76: 
#line 148
    flags |= 128;
#line 148
    format ++;
#line 148
    break;
    }
#line 150
    kind = (int )*format;
#line 151
    if ((kind != 99 && kind != 91) && kind != 110) {
#line 152
      while (1) {
#line 153
        ic = _IO_getc((_IO_FILE *)stream);
#line 154
        nrchars ++;
#line 152
        __cil_tmp___6 = isspace(ic);
#line 152
        if (! __cil_tmp___6) {
#line 152
          break;
        }
      }
#line 156
      if (ic == -1) {
#line 156
        break;
      }
    } else {
#line 157
      if (kind != 110) {
#line 158
        ic = _IO_getc((_IO_FILE *)stream);
#line 159
        if (ic == -1) {
#line 159
          break;
        }
#line 160
        nrchars ++;
      }
    }
#line 162
    switch (kind) {
    default: ;
#line 165
    if (conv || ic != -1) {
#line 165
      __cil_tmp___7 = done;
    } else {
#line 165
      __cil_tmp___7 = -1;
    }
#line 165
    return (__cil_tmp___7);
#line 166
    break;
    case 110: 
#line 168
    if (! (flags & 2048)) {
#line 169
      if (flags & 32) {
#line 170
        __cil_tmp___8 = __builtin_va_arg(ap, short *);
#line 170
        *__cil_tmp___8 = (short )nrchars;
      } else {
#line 171
        if (flags & 64) {
#line 172
          __cil_tmp___9 = __builtin_va_arg(ap, long *);
#line 172
          *__cil_tmp___9 = (long )nrchars;
        } else {
#line 174
          __cil_tmp___10 = __builtin_va_arg(ap, int *);
#line 174
          *__cil_tmp___10 = nrchars;
        }
      }
    }
#line 176
    break;
    case 112: 
#line 178
    set_pointer(flags);
    case 98: 
    case 100: 
    case 105: 
    case 111: 
    case 117: 
    case 120: 
    case 88: 
#line 187
    if (! (flags & 256) || width > 512U) {
#line 188
      width = 512U;
    }
#line 189
    if (! width) {
#line 189
      return (done);
    }
#line 191
    str = o_collect(ic, stream, (char )kind, width, & base);
#line 192
    if ((unsigned int )str < (unsigned int )(inp_buf) || ((unsigned int )str == (unsigned int )(inp_buf) && ((int )*str == 45 || (int )*str == 43))) {
#line 195
      return (done);
    }
#line 201
    nrchars += str - inp_buf;
#line 203
    if (! (flags & 2048)) {
#line 204
      if (kind == 100 || kind == 105) {
#line 205
        __cil_tmp___11 = (int )strtol(inp_buf, & tmp_string, base);
#line 205
        val = (unsigned long )__cil_tmp___11;
      } else {
#line 207
        __cil_tmp___12 = (int )strtoul(inp_buf, & tmp_string, base);
#line 207
        val = (unsigned long )__cil_tmp___12;
      }
#line 208
      if (flags & 64) {
#line 209
        __cil_tmp___13 = __builtin_va_arg(ap, unsigned long *);
#line 209
        *__cil_tmp___13 = val;
      } else {
#line 210
        if (flags & 32) {
#line 211
          __cil_tmp___14 = __builtin_va_arg(ap, unsigned short *);
#line 211
          *__cil_tmp___14 = (unsigned short )val;
        } else {
#line 213
          __cil_tmp___15 = __builtin_va_arg(ap, unsigned int *);
#line 213
          *__cil_tmp___15 = (unsigned int )val;
        }
      }
    }
#line 215
    break;
    case 99: 
#line 217
    if (! (flags & 256)) {
#line 218
      width = 1U;
    }
#line 219
    if (! (flags & 2048)) {
#line 220
      str = __builtin_va_arg(ap, char *);
    }
#line 221
    if (! width) {
#line 221
      return (done);
    }
#line 223
    while ((int )width && ic != -1) {
#line 224
      if (! (flags & 2048)) {
#line 225
        __cil_tmp___16 = str;
#line 225
        str ++;
#line 225
        *__cil_tmp___16 = (char )ic;
      }
#line 226
      width --;
#line 226
      if (width) {
#line 227
        ic = _IO_getc((_IO_FILE *)stream);
#line 228
        nrchars ++;
      }
    }
#line 232
    if (width) {
#line 233
      if (ic != -1) {
#line 233
        ungetc(ic, (FILE *)stream);
      }
#line 234
      nrchars --;
    }
#line 236
    break;
    case 115: 
#line 238
    if (! (flags & 256)) {
#line 239
      width = 65535U;
    }
#line 240
    if (! (flags & 2048)) {
#line 241
      str = __builtin_va_arg(ap, char *);
    }
#line 242
    if (! width) {
#line 242
      return (done);
    }
#line 244
    while (1) {
#line 244
      if ((int )width && ic != -1) {
#line 244
        __cil_tmp___18 = isspace(ic);
#line 244
        if (__cil_tmp___18) {
#line 244
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 244
        break;
      }
#line 245
      if (! (flags & 2048)) {
#line 246
        __cil_tmp___17 = str;
#line 246
        str ++;
#line 246
        *__cil_tmp___17 = (char )ic;
      }
#line 247
      width --;
#line 247
      if (width) {
#line 248
        ic = _IO_getc((_IO_FILE *)stream);
#line 249
        nrchars ++;
      }
    }
#line 253
    if (! (flags & 2048)) {
#line 254
      *str = (char )'\000';
    }
#line 255
    if (width) {
#line 256
      if (ic != -1) {
#line 256
        ungetc(ic, (FILE *)stream);
      }
#line 257
      nrchars --;
    }
#line 259
    break;
    case 91: 
#line 261
    if (! (flags & 256)) {
#line 262
      width = 65535U;
    }
#line 263
    if (! width) {
#line 263
      return (done);
    }
#line 265
    format ++;
#line 265
    if ((int const   )*format == 94) {
#line 266
      reverse = 1;
#line 267
      format ++;
    } else {
#line 269
      reverse = 0;
    }
#line 271
    str = Xtable;
#line 271
    while ((unsigned int )str < (unsigned int )(& Xtable[256])) {
#line 273
      *str = (char)0;
#line 271
      str ++;
    }
#line 275
    if ((int const   )*format == 93) {
#line 275
      __cil_tmp___19 = format;
#line 275
      format ++;
#line 275
      Xtable[*__cil_tmp___19] = (char)1;
    }
#line 277
    while ((int )*format && (int const   )*format != 93) {
#line 278
      __cil_tmp___20 = format;
#line 278
      format ++;
#line 278
      Xtable[*__cil_tmp___20] = (char)1;
#line 279
      if ((int const   )*format == 45) {
#line 280
        format ++;
#line 281
        if (((int )*format && (int const   )*format != 93) && (int const   )*format >= (int const   )*(format - 2)) {
#line 286
          c = (int )((int const   )*(format - 2) + 1);
#line 286
          while (c <= (int )*format) {
#line 288
            Xtable[c] = (char)1;
#line 286
            c ++;
          }
#line 289
          format ++;
        } else {
#line 291
          Xtable['-'] = (char)1;
        }
      }
    }
#line 294
    if (! *format) {
#line 294
      return (done);
    }
#line 296
    if (! ((int )Xtable[ic] ^ reverse)) {
#line 298
      ungetc(ic, (FILE *)stream);
#line 299
      return (done);
    }
#line 302
    if (! (flags & 2048)) {
#line 303
      str = __builtin_va_arg(ap, char *);
    }
#line 305
    while (1) {
#line 306
      if (! (flags & 2048)) {
#line 307
        __cil_tmp___21 = str;
#line 307
        str ++;
#line 307
        *__cil_tmp___21 = (char )ic;
      }
#line 308
      width --;
#line 308
      if (width) {
#line 309
        ic = _IO_getc((_IO_FILE *)stream);
#line 310
        nrchars ++;
      }
#line 305
      if (! (((int )width && ic != -1) && (int )Xtable[ic] ^ reverse)) {
#line 305
        break;
      }
    }
#line 314
    if (width) {
#line 315
      if (ic != -1) {
#line 315
        ungetc(ic, (FILE *)stream);
      }
#line 316
      nrchars --;
    }
#line 318
    if (! (flags & 2048)) {
#line 319
      *str = (char )'\000';
    }
#line 321
    break;
    case 101: 
    case 69: 
    case 102: 
    case 103: 
    case 71: 
#line 328
    if (! (flags & 256) || width > 512U) {
#line 329
      width = 512U;
    }
#line 331
    if (! width) {
#line 331
      return (done);
    }
#line 332
    __cil_tmp___22 = f_collect(ic, stream, width);
#line 332
    str = (char *)__cil_tmp___22;
#line 334
    if ((unsigned int )str < (unsigned int )(inp_buf) || ((unsigned int )str == (unsigned int )(inp_buf) && ((int )*str == 45 || (int )*str == 43))) {
#line 337
      return (done);
    }
#line 343
    nrchars += str - inp_buf;
#line 345
    if (! (flags & 2048)) {
#line 346
      __cil_tmp___23 = strtod(inp_buf, & tmp_string);
#line 346
      ld_val = (long double )__cil_tmp___23;
#line 347
      if (flags & 128) {
#line 348
        __cil_tmp___24 = __builtin_va_arg(ap, long double *);
#line 348
        *__cil_tmp___24 = ld_val;
      } else {
#line 350
        if (flags & 64) {
#line 351
          __cil_tmp___25 = __builtin_va_arg(ap, double *);
#line 351
          *__cil_tmp___25 = (double )ld_val;
        } else {
#line 353
          __cil_tmp___26 = __builtin_va_arg(ap, float *);
#line 353
          *__cil_tmp___26 = (float )ld_val;
        }
      }
    }
#line 355
    break;
    }
#line 358
    conv ++;
#line 359
    if (! (flags & 2048) && kind != 110) {
#line 359
      done ++;
    }
#line 360
    format ++;
  }
#line 362
  if (conv || ic != -1) {
#line 362
    __cil_tmp___27 = done;
  } else {
#line 362
    __cil_tmp___27 = -1;
  }
#line 362
  return (__cil_tmp___27);
}
}
#line 365
 __attribute__((__nothrow__)) int sscanf(char const   * __restrict  s , char const   * __restrict  format 
                                         , ...) ;
#line 365 "../../mockedFns/sscanf.c"
int sscanf(char const   * __restrict  s , char const   * __restrict  format  , ...) 
{ va_list ap ;
  int retval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  size_t___0 __cil_tmp___1 ;

  {
#line 370
  __cil_tmp = (int )malloc(sizeof(sym_file_stream_t ));
#line 370
  IOSIM_fd[scanf_counter] = (sym_file_stream_t *)__cil_tmp;
#line 371
  (IOSIM_fd[scanf_counter])->offset = 0LL;
#line 372
  (IOSIM_fd[scanf_counter])->fd = scanf_counter;
#line 373
  __cil_tmp___0 = (int )malloc(sizeof(sym_file_t ));
#line 373
  (IOSIM_fd[scanf_counter])->sym_file = (sym_file_t *)__cil_tmp___0;
#line 374
  ((IOSIM_fd[scanf_counter])->sym_file)->contents = (char *)s;
#line 375
  __cil_tmp___1 = strlen((char const   *)s);
#line 375
  ((IOSIM_fd[scanf_counter])->sym_file)->stat.st_size = (long long )__cil_tmp___1;
#line 377
  __builtin_va_start(ap, format);
#line 379
  retval = _doscan(IOSIM_fd[scanf_counter], (char const   *)format, ap);
#line 381
  __builtin_va_end(ap);
#line 383
  scanf_counter ++;
#line 385
  return (retval);
}
}
#line 1 "cil-KyzeQrax.o"
#pragma merger(0,"/tmp/cil-2JSZfL2a.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 332 "../../includes/usr/include/sys/stat.h"
 __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("___fxstat64") __attribute__((__nonnull__(3))) ;
#line 335
 __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __asm__("___xstat64") __attribute__((__nonnull__(2,3))) ;
#line 338
 __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                           struct stat *__stat_buf )  __asm__("___lxstat64") __attribute__((__nonnull__(2,3))) ;
#line 8 "../../mockedFns/stat.c"
 __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __asm__("___xstat64") __attribute__((__nonnull__(2,3))) ;
#line 8 "../../mockedFns/stat.c"
int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf ) 
{ char *absoluteName ;
  char *__cil_tmp ;
  sym_file_t *file ;
  sym_file_t *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 9
  __cil_tmp = IOSIM_toAbsolute(__filename);
#line 9
  absoluteName = __cil_tmp;
#line 10
  __cil_tmp___0 = IOSIM_findfile((char const   *)absoluteName);
#line 10
  file = __cil_tmp___0;
#line 11
  free((void *)absoluteName);
#line 12
  if (file) {
#line 13
    *__stat_buf = file->stat;
#line 14
    return (0);
  }
#line 16
  __cil_tmp___1 = __errno_location();
#line 16
  *__cil_tmp___1 = 2;
#line 17
  return (-1);
}
}
#line 20
 __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("___fxstat64") __attribute__((__nonnull__(3))) ;
#line 20 "../../mockedFns/stat.c"
int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) 
{ sym_file_stream_t *sym_stream ;
  int *__cil_tmp ;

  {
#line 27
  sym_stream = IOSIM_fd[__fildes];
#line 28
  if ((unsigned int )sym_stream == (unsigned int )((void *)0)) {
#line 29
    __COMMENT((char *)"Bad file descriptor in __fxstat");
#line 30
    __cil_tmp = __errno_location();
#line 30
    *__cil_tmp = 9;
#line 31
    return (-1);
  }
#line 35
  *__stat_buf = (sym_stream->sym_file)->stat;
#line 36
  return (0);
}
}
#line 39
 __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                           struct stat *__stat_buf )  __asm__("___lxstat64") __attribute__((__nonnull__(2,3))) ;
#line 39 "../../mockedFns/stat.c"
int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf ) 
{ int __cil_tmp ;

  {
#line 42
  __cil_tmp = __xstat(__ver, __filename, __stat_buf);
#line 42
  return (__cil_tmp);
}
}
#line 1 "cil-Pk8d1SOz.o"
#pragma merger(0,"/tmp/cil-VBW7ILFw.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 106 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) int strcoll(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 3 "../../mockedFns/strcoll.c"
 __attribute__((__nothrow__)) int strcoll(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 3 "../../mockedFns/strcoll.c"
int strcoll(char const   *s1 , char const   *s2 ) 
{ int __cil_tmp ;

  {
#line 5
  __cil_tmp = strcmp(s1, s2);
#line 5
  return (__cil_tmp);
}
}
#line 1 "cil-ydPSvH0E.o"
#pragma merger(0,"/tmp/cil-vCp3K2Sw.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 4 "../../mockedFns/strdup.c"
 __attribute__((__nothrow__)) char *strdup(char const   *p_str )  __attribute__((__nonnull__(1),
__malloc__)) ;
#line 4 "../../mockedFns/strdup.c"
char *strdup(char const   *p_str ) 
{ size_t___0 len ;
  size_t___0 __cil_tmp ;
  char *theCopy ;
  void *__cil_tmp___0 ;

  {
#line 6
  __cil_tmp = strlen(p_str);
#line 6
  len = __cil_tmp;
#line 7
  __cil_tmp___0 = malloc(len + 1UL);
#line 7
  theCopy = (char *)__cil_tmp___0;
#line 8
  if (theCopy) {
#line 9
    strcpy((char * __restrict  )theCopy, (char const   * __restrict  )p_str);
  }
#line 11
  return (theCopy);
}
}
#line 1 "cil-4RgXEdSu.o"
#pragma merger(0,"/tmp/cil-NmZmdTe3.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 256 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) char *strerror(int errnum ) ;
#line 9 "../../mockedFns/strerror.c"
static char message[32]  = {      (char )'e',      (char )'r',      (char )'r',      (char )'o', 
        (char )'r',      (char )' ',      (char )'\000'};
#line 7
 __attribute__((__nothrow__)) char *strerror(int errnum ) ;
#line 7 "../../mockedFns/strerror.c"
char *strerror(int errnum ) 
{ char numbuf[32] ;
  char *p ;
  unsigned int e ;

  {
#line 12
  e = (unsigned int )errnum;
#line 22
  p = numbuf + sizeof(numbuf);
#line 23
  p --;
#line 23
  *p = (char )'\000';
#line 25
  while (1) {
#line 26
    p --;
#line 26
    *p = (char )(e % 10U + 48U);
#line 27
    e /= 10U;
#line 25
    if (! e) {
#line 25
      break;
    }
  }
#line 30
  memcpy((void * __restrict  )(message + 6), (void const   * __restrict  )p, (unsigned long )((numbuf + sizeof(numbuf)) - p));
#line 32
  return (message);
}
}
#line 1 "cil-jTpoaLpz.o"
#pragma merger(0,"/tmp/cil-WzMLim9M.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 4 "../../mockedFns/strrchr.c"
 __attribute__((__nothrow__)) char *strrchr(char const   *s , int c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 4 "../../mockedFns/strrchr.c"
char *strrchr(char const   *s , int c ) 
{ char const   *p ;
  char const   *__cil_tmp ;

  {
#line 6
  p = (char const   *)((void *)0);
#line 8
  while (1) {
#line 9
    if ((int const   )*s == (int const   )((char )c)) {
#line 10
      p = s;
    }
#line 8
    __cil_tmp = s;
#line 8
    s ++;
#line 8
    if (! *__cil_tmp) {
#line 8
      break;
    }
  }
#line 14
  return ((char *)p);
}
}
#line 1 "cil-RmcyqOsM.o"
#pragma merger(0,"/tmp/cil-HGVPi44G.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 81 "../../includes/usr/include/ctype.h"
int table_inited = -1; 
unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) {
	static unsigned short* table = 0;
	__EVAL(table_inited);
	if(__TRUTH_VALUE(table_inited)==0 || table_inited==-1) { // workaround
		table = malloc(sizeof(unsigned short)*256);
		for(int i=0;i<256;i++)
			table[i] = i;
		table_inited = 1;
	}
	return &table;
	// maybe there's a bug in Otter
	// problem: to assert that addr returned by malloc != 0
	// problem: global init
}
#line 6 "../../mockedFns/strtol.c"
static unsigned long string2long(char const   *nptr , char **endptr , int base , int is_signed ) ;
#line 10
 __attribute__((__nothrow__)) long strtol(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                          int base )  __attribute__((__nonnull__(1))) ;
#line 10 "../../mockedFns/strtol.c"
long strtol(char const   * __restrict  nptr , char ** __restrict  endptr , int base ) 
{ unsigned long __cil_tmp ;

  {
#line 13
  __cil_tmp = string2long((char const   *)nptr, (char **)endptr, base, 1);
#line 13
  return ((long )__cil_tmp);
}
}
#line 16
 __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  nptr ,
                                                    char ** __restrict  endptr , int base )  __attribute__((__nonnull__(1))) ;
#line 16 "../../mockedFns/strtol.c"
unsigned long strtoul(char const   * __restrict  nptr , char ** __restrict  endptr ,
                      int base ) 
{ unsigned long __cil_tmp ;

  {
#line 19
  __cil_tmp = string2long((char const   *)nptr, (char **)endptr, base, 0);
#line 19
  return (__cil_tmp);
}
}
#line 24 "../../mockedFns/strtol.c"
static unsigned long string2long(char const   *nptr , char **endptr , int base , int is_signed ) 
{ register unsigned int v ;
  register unsigned long val ;
  register int c ;
  int ovfl ;
  int sign ;
  char const   *startnptr ;
  char const   *nrstart ;
  unsigned short const   **__cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 29
  val = 0UL;
#line 31
  ovfl = 0;
#line 31
  sign = 1;
#line 32
  startnptr = nptr;
#line 34
  if (endptr) {
#line 34
    *endptr = (char *)nptr;
  }
#line 35
  while (1) {
#line 35
    __cil_tmp = __ctype_b_loc();
#line 35
    if (! ((int const   )*(*__cil_tmp + (int )*nptr) & 8192)) {
#line 35
      break;
    }
#line 35
    nptr ++;
  }
#line 36
  c = (int )*nptr;
#line 38
  if (c == 45 || c == 43) {
#line 39
    if (c == 45) {
#line 39
      sign = -1;
    }
#line 40
    nptr ++;
  }
#line 42
  nrstart = nptr;
#line 45
  if (base == 0) {
#line 46
    if ((int const   )*nptr == 48) {
#line 47
      nptr ++;
#line 47
      if ((int const   )*nptr == 120 || (int const   )*nptr == 88) {
#line 48
        base = 16;
#line 49
        nptr ++;
      } else {
#line 51
        base = 8;
      }
    } else {
#line 52
      base = 10;
    }
  } else {
#line 53
    if (base == 16 && (int const   )*nptr == 48) {
#line 53
      nptr ++;
#line 53
      if ((int const   )*nptr == 120 || (int const   )*nptr == 88) {
#line 54
        nptr ++;
      } else {
#line 53
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
  }
#line 56
  while (1) {
#line 57
    c = (int )*nptr;
#line 58
    if ((unsigned int )(c - 48) <= 9U) {
#line 59
      v = (unsigned int )(c - 48);
    } else {
#line 61
      if ((unsigned int )(c - 97) <= 25U) {
#line 62
        v = (unsigned int )((c - 97) + 10);
      } else {
#line 64
        if ((unsigned int )(c - 65) <= 25U) {
#line 65
          v = (unsigned int )((c - 65) + 10);
        } else {
#line 67
          break;
        }
      }
    }
#line 69
    if (v >= (unsigned int )base) {
#line 69
      break;
    }
#line 70
    if (val > (4294967295UL - (unsigned long )v) / (unsigned long )base) {
#line 70
      ovfl ++;
    }
#line 71
    val = val * (unsigned long )base + (unsigned long )v;
#line 72
    nptr ++;
  }
#line 74
  if (endptr) {
#line 75
    if ((unsigned int )nrstart == (unsigned int )nptr) {
#line 75
      *endptr = (char *)startnptr;
    } else {
#line 76
      *endptr = (char *)nptr;
    }
  }
#line 79
  if (! ovfl) {
#line 81
    if (is_signed && ((sign < 0 && val > 2147483648UL) || (sign > 0 && val > 2147483647UL))) {
#line 84
      ovfl ++;
    }
  }
#line 87
  if (ovfl) {
#line 88
    __cil_tmp___0 = __errno_location();
#line 88
    *__cil_tmp___0 = 34;
#line 89
    if (is_signed) {
#line 90
      if (sign < 0) {
#line 90
        return (2147483648UL);
      } else {
#line 91
        return (2147483647UL);
      }
    } else {
#line 92
      return (4294967295UL);
    }
  }
#line 94
  return ((unsigned long )((long )sign) * val);
}
}
#line 1 "cil-brXtrFdK.o"
#pragma merger(0,"/tmp/cil-hCJyHnbA.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 184 "../../includes/usr/include/time.h"
 __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 191
 __attribute__((__nothrow__)) time_t mktime(struct tm *tm ) ;
#line 197
 __attribute__((__nothrow__)) size_t___0 strftime(char * __restrict  s , size_t___0 maxsize ,
                                                  char const   * __restrict  format ,
                                                  struct tm  const  * __restrict  timeptr ) ;
#line 229
 __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 233
 __attribute__((__nothrow__)) struct tm *localtime(time_t const   *timer ) ;
#line 283
 __attribute__((__nothrow__)) void tzset(void) ;
#line 324
int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 72 "../../includes/usr/include/sys/time.h"
 __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  tv , struct timezone * __restrict  tz ) ;
#line 6 "../../mockedFns/time.c"
 __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 6 "../../mockedFns/time.c"
time_t time(time_t *__timer ) 
{ 

  {
#line 7
  return (0L);
}
}
#line 10
 __attribute__((__nothrow__)) void tzset(void) ;
#line 10 "../../mockedFns/time.c"
void tzset(void) 
{ 

  {
#line 11
  return;
}
}
#line 13
 __attribute__((__nothrow__)) struct tm *localtime(time_t const   *timer ) ;
#line 13 "../../mockedFns/time.c"
struct tm *localtime(time_t const   *timer ) 
{ struct tm *x ;
  void *__cil_tmp ;

  {
#line 14
  __cil_tmp = malloc(sizeof(struct tm ));
#line 14
  x = (struct tm *)__cil_tmp;
#line 15
  x->tm_sec = 0;
#line 16
  x->tm_min = 1;
#line 17
  x->tm_hour = 2;
#line 18
  x->tm_mday = 3;
#line 19
  x->tm_mon = 4;
#line 20
  x->tm_year = 5;
#line 21
  x->tm_wday = 6;
#line 22
  x->tm_yday = 7;
#line 23
  x->tm_isdst = 8;
#line 24
  x->tm_gmtoff = 9L;
#line 25
  x->tm_zone = "my tz";
#line 26
  return (x);
}
}
#line 29
 __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 29 "../../mockedFns/time.c"
struct tm *gmtime(time_t const   *__timer ) 
{ struct tm *__cil_tmp ;

  {
#line 30
  __cil_tmp = localtime(__timer);
#line 30
  return (__cil_tmp);
}
}
#line 33
 __attribute__((__nothrow__)) size_t___0 strftime(char * __restrict  s , size_t___0 maxsize ,
                                                  char const   * __restrict  format ,
                                                  struct tm  const  * __restrict  timeptr ) ;
#line 33 "../../mockedFns/time.c"
size_t___0 strftime(char * __restrict  s , size_t___0 maxsize , char const   * __restrict  format ,
                    struct tm  const  * __restrict  timeptr ) 
{ 

  {
#line 35
  if (maxsize >= 6UL) {
#line 36
    strcpy(s, (char const   * __restrict  )"+0123");
#line 37
    return (5UL);
  }
#line 39
  return (0UL);
}
}
#line 42
 __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  tv , struct timezone * __restrict  tz ) ;
#line 42 "../../mockedFns/time.c"
int gettimeofday(struct timeval * __restrict  tv , struct timezone * __restrict  tz ) 
{ 

  {
#line 43
  tv->tv_sec = 123L;
#line 44
  tv->tv_usec = 456L;
#line 45
  return (0);
}
}
#line 48 "../../mockedFns/time.c"
int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) 
{ 

  {
#line 49
  __COMMENT((char *)"Sleeping");
#line 50
  return (0);
}
}
#line 53
 __attribute__((__nothrow__)) time_t mktime(struct tm *tm ) ;
#line 53 "../../mockedFns/time.c"
time_t mktime(struct tm *tm ) 
{ 

  {
#line 54
  return (0L);
}
}
#line 57
 __attribute__((__nothrow__)) int utime(char const   *path , struct utimbuf  const  *times )  __attribute__((__nonnull__(1))) ;
#line 57 "../../mockedFns/time.c"
int utime(char const   *path , struct utimbuf  const  *times ) 
{ 

  {
#line 58
  return (0);
}
}
#line 1 "cil-dxi1GqgK.o"
#pragma merger(0,"/tmp/cil-K1vMSJAa.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 4 "../../mockedFns/unget.c"
int ungetc(int c , FILE *stream ) 
{ sym_file_stream_t *streamAsSymStream ;
  int __cil_tmp ;

  {
#line 5
  streamAsSymStream = (sym_file_stream_t *)stream;
#line 6
  __cil_tmp = IOSIM_ungetc(c, streamAsSymStream->fd);
#line 6
  return (__cil_tmp);
}
}
#line 1 "cil-kDpvTpDy.o"
#pragma merger(0,"/tmp/cil-arrDslSZ.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 292 "../../includes/usr/include/unistd.h"
 __attribute__((__nothrow__)) __quad_t lseek(int fildes , __quad_t offset , int whence )  __asm__("_lseek64")  ;
#line 307
int close(int fildes ) ;
#line 471
 __attribute__((__nothrow__)) int dup2(int fildes , int fildes2 ) ;
#line 551
 __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 559
 __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 612
 __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 620
 __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
 __attribute__((__nothrow__)) int setuid(__uid_t uid ) ;
#line 662
 __attribute__((__nothrow__)) int setgid(__gid_t gid ) ;
#line 697
 __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 719
 __attribute__((__nothrow__)) int isatty(int fildes ) ;
#line 22 "../../mockedFns/unistd.c"
 __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 22 "../../mockedFns/unistd.c"
__pid_t fork(void) 
{ 

  {
#line 29
  __COMMENT((char *)"Forking to child");
#line 30
  return (0);
}
}
#line 35
 __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 35 "../../mockedFns/unistd.c"
__uid_t getuid(void) 
{ 

  {
#line 36
  return (0U);
}
}
#line 56 "../../mockedFns/unistd.c"
ssize_t read(int fildes , void *buf , size_t___0 nbyte ) 
{ int __cil_tmp ;

  {
#line 57
  __cil_tmp = IOSIM_read(fildes, buf, nbyte);
#line 57
  return (__cil_tmp);
}
}
#line 79 "../../mockedFns/unistd.c"
int close(int fildes ) 
{ 

  {
#line 80
  IOSIM_close(fildes);
#line 81
  return (0);
}
}
#line 86 "../../mockedFns/unistd.c"
ssize_t write(int fildes , void const   *buf , size_t___0 nbyte ) 
{ 

  {
#line 100
  IOSIM_write(fildes, buf, nbyte);
#line 101
  return ((int )nbyte);
}
}
#line 106
 __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 106 "../../mockedFns/unistd.c"
__pid_t setsid(void) 
{ 

  {
#line 107
  return (0);
}
}
#line 109
 __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 109 "../../mockedFns/unistd.c"
__pid_t getpid(void) 
{ 

  {
#line 110
  return (0);
}
}
#line 112
 __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 112 "../../mockedFns/unistd.c"
__pid_t getpgrp(void) 
{ 

  {
#line 113
  return (0);
}
}
#line 115
 __attribute__((__nothrow__)) int setgid(__gid_t gid ) ;
#line 115 "../../mockedFns/unistd.c"
int setgid(__gid_t gid ) 
{ 

  {
#line 116
  return (0);
}
}
#line 118
 __attribute__((__nothrow__)) int setuid(__uid_t uid ) ;
#line 118 "../../mockedFns/unistd.c"
int setuid(__uid_t uid ) 
{ 

  {
#line 119
  return (0);
}
}
#line 121
 __attribute__((__nothrow__)) char *getcwd(char *buf , size_t___0 size ) ;
#line 121 "../../mockedFns/unistd.c"
char *getcwd(char *buf , size_t___0 size ) 
{ char *__cil_tmp ;

  {
#line 122
  __cil_tmp = IOSIM_getcwd(buf, size);
#line 122
  return (__cil_tmp);
}
}
#line 124
 __attribute__((__nothrow__)) int dup2(int fildes , int fildes2 ) ;
#line 124 "../../mockedFns/unistd.c"
int dup2(int fildes , int fildes2 ) 
{ 

  {
#line 125
  IOSIM_fd[fildes2] = IOSIM_fd[fildes];
#line 126
  return (fildes2);
}
}
#line 129
 __attribute__((__nothrow__)) __quad_t lseek(int fildes , __quad_t offset , int whence )  __asm__("_lseek64")  ;
#line 129 "../../mockedFns/unistd.c"
__quad_t lseek(int fildes , __quad_t offset , int whence ) 
{ int *__cil_tmp ;
  sym_file_stream_t *sym_stream ;
  __quad_t newOffset ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 130
  if (fildes >= IOSIM_num_fd || fildes < 0) {
#line 131
    __cil_tmp = __errno_location();
#line 131
    *__cil_tmp = 9;
#line 132
    return (-1LL);
  }
#line 134
  sym_stream = IOSIM_fd[fildes];
#line 136
  if (! sym_stream) {
#line 137
    __cil_tmp___0 = __errno_location();
#line 137
    *__cil_tmp___0 = 9;
#line 138
    return (-1LL);
  }
#line 140
  switch (whence) {
  case 0: 
#line 142
  newOffset = offset;
#line 143
  break;
  case 1: 
#line 145
  newOffset = sym_stream->offset + offset;
#line 146
  break;
  case 2: 
#line 148
  newOffset = (sym_stream->sym_file)->stat.st_size + offset;
#line 149
  break;
  default: 
#line 151
  __cil_tmp___1 = __errno_location();
#line 151
  *__cil_tmp___1 = 22;
#line 152
  return (-1LL);
  }
#line 154
  if (newOffset < 0LL) {
#line 155
    __cil_tmp___2 = __errno_location();
#line 155
    *__cil_tmp___2 = 22;
#line 156
    return (-1LL);
  }
#line 158
  sym_stream->offset = newOffset;
#line 160
  free((void *)sym_stream->buffer);
#line 161
  sym_stream->buffer = (char *)((void *)0);
#line 163
  return (newOffset);
}
}
#line 166
 __attribute__((__nothrow__)) int isatty(int fildes ) ;
#line 166 "../../mockedFns/unistd.c"
int isatty(int fildes ) 
{ 

  {
#line 168
  return (1);
}
}
#line 1 "cil-JanBYmtk.o"
#pragma merger(0,"/tmp/cil-u0uN0atK.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 3 "../../mockedFns/unlink.c"
 __attribute__((__nothrow__)) int unlink(char const   *pathname )  __attribute__((__nonnull__(1))) ;
#line 3 "../../mockedFns/unlink.c"
int unlink(char const   *pathname ) 
{ int __cil_tmp ;

  {
#line 4
  __cil_tmp = IOSIM_unlink(pathname);
#line 4
  return (__cil_tmp);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#line 1 "cil-e9dHWLTC.o"
#pragma merger(0,"/tmp/cil-vq2r8OxN.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 1 "cil-D6lGTEQc.o"
#pragma merger(0,"/tmp/cil-CZUxsAxO.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 29 "../../libc/__random.c"
long __random(void) ;
#line 108 "../../libc/__random.c"
static int degrees[5]  = {      0,      7,      15,      31, 
        63};
#line 109 "../../libc/__random.c"
static int seps[5]  = {      0,      3,      1,      3, 
        1};
#line 122 "../../libc/__random.c"
static long randtbl[32]  = 
#line 122
  {      3L,      -851904987L,      -43806228L,      -2029755270L, 
        1390239686L,      -1912102820L,      -485608943L,      1969813258L, 
        -1590463333L,      -1944053249L,      455935928L,      508023712L, 
        -1714531963L,      1800685987L,      -2015299881L,      654595283L, 
        -1149023258L,      -1470005550L,      -1143256056L,      -1325577603L, 
        -1568001885L,      1275120390L,      -607508183L,      -205999574L, 
        -1696891592L,      1492211999L,      -1528267240L,      -952028296L, 
        -189082757L,      362343714L,      1424981831L,      2039449641L};
#line 143 "../../libc/__random.c"
static long *fptr  =    & randtbl[4];
#line 144 "../../libc/__random.c"
static long *rptr  =    & randtbl[1];
#line 158 "../../libc/__random.c"
static long *state  =    & randtbl[1];
#line 160 "../../libc/__random.c"
static int rand_type  =    3;
#line 161 "../../libc/__random.c"
static int rand_deg  =    31;
#line 162 "../../libc/__random.c"
static int rand_sep  =    3;
#line 164 "../../libc/__random.c"
static long *end_ptr  =    & randtbl[sizeof(randtbl) / sizeof(randtbl[0])];
#line 174 "../../libc/__random.c"
void __srandom(unsigned int x ) 
{ register long i ;

  {
#line 177
  *(state + 0) = (long )x;
#line 178
  if (rand_type != 0) {
#line 181
    i = 1L;
#line 181
    while (i < (long )rand_deg) {
#line 182
      *(state + i) = 1103515145L * *(state + (i - 1L)) + 12345L;
#line 181
      i ++;
    }
#line 183
    fptr = state + rand_sep;
#line 184
    rptr = state + 0;
#line 185
    i = 0L;
#line 185
    while (i < (long )(10 * rand_deg)) {
#line 186
      __random();
#line 185
      i ++;
    }
  }
#line 188
  return;
}
}
#line 201 "../../libc/__random.c"
void *__initstate(unsigned int seed , void *arg_state , size_t___0 n ) 
{ void *ostate ;
  int *__cil_tmp ;

  {
#line 205
  ostate = (void *)(state + -1);
#line 207
  if (rand_type == 0) {
#line 208
    *(state + -1) = (long )rand_type;
  } else {
#line 210
    *(state + -1) = (long )(5 * (rptr - state) + rand_type);
  }
#line 211
  if (n < 32UL) {
#line 213
    if (n < 8UL) {
#line 215
      __cil_tmp = __errno_location();
#line 215
      *__cil_tmp = 22;
#line 216
      return ((void *)0);
    }
#line 218
    rand_type = 0;
#line 219
    rand_deg = 0;
#line 220
    rand_sep = 0;
  } else {
#line 222
    if (n < 64UL) {
#line 224
      rand_type = 1;
#line 225
      rand_deg = 7;
#line 226
      rand_sep = 3;
    } else {
#line 228
      if (n < 128UL) {
#line 230
        rand_type = 2;
#line 231
        rand_deg = 15;
#line 232
        rand_sep = 1;
      } else {
#line 234
        if (n < 256UL) {
#line 236
          rand_type = 3;
#line 237
          rand_deg = 31;
#line 238
          rand_sep = 3;
        } else {
#line 242
          rand_type = 4;
#line 243
          rand_deg = 63;
#line 244
          rand_sep = 1;
        }
      }
    }
  }
#line 247
  state = (long *)arg_state + 1;
#line 249
  end_ptr = state + rand_deg;
#line 250
  __srandom(seed);
#line 251
  if (rand_type == 0) {
#line 252
    *(state + -1) = (long )rand_type;
  } else {
#line 254
    *(state + -1) = (long )(5 * (rptr - state) + rand_type);
  }
#line 256
  return (ostate);
}
}
#line 267 "../../libc/__random.c"
void *__setstate(void *arg_state ) 
{ register long *new_state ;
  register int type ;
  register int rear ;
  void *ostate ;
  int *__cil_tmp ;

  {
#line 270
  new_state = (long *)arg_state;
#line 271
  type = (int )(*(new_state + 0) % 5L);
#line 272
  rear = (int )(*(new_state + 0) / 5L);
#line 273
  ostate = (void *)(state + -1);
#line 275
  if (rand_type == 0) {
#line 276
    *(state + -1) = (long )rand_type;
  } else {
#line 278
    *(state + -1) = (long )(5 * (rptr - state) + rand_type);
  }
#line 280
  switch (type) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
#line 287
  rand_type = type;
#line 288
  rand_deg = degrees[type];
#line 289
  rand_sep = seps[type];
#line 290
  break;
  default: 
#line 293
  __cil_tmp = __errno_location();
#line 293
  *__cil_tmp = 22;
#line 294
  return ((void *)0);
  }
#line 297
  state = new_state + 1;
#line 298
  if (rand_type != 0) {
#line 300
    rptr = state + rear;
#line 301
    fptr = state + (rear + rand_sep) % rand_deg;
  }
#line 304
  end_ptr = state + rand_deg;
#line 306
  return (ostate);
}
}
#line 320 "../../libc/__random.c"
long __random(void) 
{ long i ;

  {
#line 323
  if (rand_type == 0) {
#line 325
    *(state + 0) = (*(state + 0) * 1103515245L + 12345L) & 2147483647L;
#line 326
    return (*(state + 0));
  } else {
#line 331
    *fptr += *rptr;
#line 333
    i = (*fptr >> 1) & 2147483647L;
#line 334
    fptr ++;
#line 335
    if ((unsigned int )fptr >= (unsigned int )end_ptr) {
#line 337
      fptr = state;
#line 338
      rptr ++;
    } else {
#line 342
      rptr ++;
#line 343
      if ((unsigned int )rptr >= (unsigned int )end_ptr) {
#line 344
        rptr = state;
      }
    }
#line 346
    return (i);
  }
}
}
#line 1 "cil-MG8QPSp3.o"
#pragma merger(0,"/tmp/cil-dA0l6URD.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 3 "../../libc/assert.c"
int assert(int expression ) 
{ 

  {
#line 4
  if (expression) {
#line 5
    return (1);
  } else {
#line 7
    exit(1);
  }
}
}
#line 1 "cil-kiI4DrMc.o"
#pragma merger(0,"/tmp/cil-bDYkLdZ1.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 11 "../../libc/strntoumax.c"
__inline static int digitval(int ch ) 
{ 

  {
#line 13
  if (ch >= 48 && ch <= 57) {
#line 14
    return (ch - 48);
  } else {
#line 15
    if (ch >= 65 && ch <= 90) {
#line 16
      return ((ch - 65) + 10);
    } else {
#line 17
      if (ch >= 97 && ch <= 122) {
#line 18
        return ((ch - 97) + 10);
      } else {
#line 20
        return (-1);
      }
    }
  }
}
}
#line 24 "../../libc/strntoumax.c"
uintmax_t strntoumax(char const   *nptr , char **endptr , int base , size_t___0 n ) 
{ int minus ;
  uintmax_t v ;
  int d ;
  int __cil_tmp ;
  char c ;
  uintmax_t __cil_tmp___0 ;

  {
#line 26
  minus = 0;
#line 27
  v = 0ULL;
#line 30
  while (1) {
#line 30
    if (n) {
#line 30
      __cil_tmp = isspace((int )((unsigned char )*nptr));
#line 30
      if (! __cil_tmp) {
#line 30
        goto _L;
      }
    } else {
      _L: 
#line 30
      break;
    }
#line 31
    nptr ++;
#line 32
    n --;
  }
#line 36
  if (n) {
#line 37
    c = (char )*nptr;
#line 38
    if ((int )c == 45 || (int )c == 43) {
#line 39
      minus = (int )c == 45;
#line 40
      nptr ++;
#line 41
      n --;
    }
  }
#line 45
  if (base == 0) {
#line 46
    if ((n >= 2UL && (int const   )*(nptr + 0) == 48) && ((int const   )*(nptr + 1) == 120 || (int const   )*(nptr + 1) == 88)) {
#line 48
      n -= 2UL;
#line 49
      nptr += 2;
#line 50
      base = 16;
    } else {
#line 51
      if (n >= 1UL && (int const   )*(nptr + 0) == 48) {
#line 52
        n --;
#line 53
        nptr ++;
#line 54
        base = 8;
      } else {
#line 56
        base = 10;
      }
    }
  } else {
#line 58
    if (base == 16) {
#line 59
      if ((n >= 2UL && (int const   )*(nptr + 0) == 48) && ((int const   )*(nptr + 1) == 120 || (int const   )*(nptr + 1) == 88)) {
#line 61
        n -= 2UL;
#line 62
        nptr += 2;
      }
    }
  }
#line 66
  while (1) {
#line 66
    if (n) {
#line 66
      d = digitval((int )*nptr);
#line 66
      if (d >= 0) {
#line 66
        if (! (d < base)) {
#line 66
          goto _L___1;
        }
      } else {
#line 66
        goto _L___1;
      }
    } else {
      _L___1: 
#line 66
      break;
    }
#line 67
    v = v * (unsigned long long )base + (unsigned long long )d;
#line 68
    n --;
#line 69
    nptr ++;
  }
#line 72
  if (endptr) {
#line 73
    *endptr = (char *)nptr;
  }
#line 75
  if (minus) {
#line 75
    __cil_tmp___0 = - v;
  } else {
#line 75
    __cil_tmp___0 = v;
  }
#line 75
  return (__cil_tmp___0);
}
}
#line 6 "../../libc/atoi.c"
 __attribute__((__nothrow__)) int atoi(char const   *nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 6 "../../libc/atoi.c"
int atoi(char const   *nptr ) 
{ uintmax_t __cil_tmp ;

  {
#line 8
  __cil_tmp = strntoumax(nptr, (char **)0, 10, ~ 0UL);
#line 8
  return ((int )__cil_tmp);
}
}
#line 1 "cil-2lCPDnV9.o"
#pragma merger(0,"/tmp/cil-2KivpGZl.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 151 "../../includes/usr/include/stdlib.h"
 __attribute__((__nothrow__)) long atol(char const   *nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 6 "../../libc/atol.c"
 __attribute__((__nothrow__)) long atol(char const   *nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 6 "../../libc/atol.c"
long atol(char const   *nptr ) 
{ uintmax_t __cil_tmp ;

  {
#line 8
  __cil_tmp = strntoumax(nptr, (char **)0, 10, ~ 0UL);
#line 8
  return ((long )__cil_tmp);
}
}
#line 1 "cil-Vy2hsu5N.o"
#pragma merger(0,"/tmp/cil-4kqfCBP3.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 31 "../../libc/ctype.h"
unsigned char const   __ctypes[257] ;
#line 10 "../../libc/ctypes.c"
unsigned char const   __ctypes[257]  = 
#line 10 "../../libc/ctypes.c"
  {      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )144,      (unsigned char const   )144,      (unsigned char const   )144, 
        (unsigned char const   )144,      (unsigned char const   )144,      (unsigned char const   )144,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )48,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )44,      (unsigned char const   )44,      (unsigned char const   )44, 
        (unsigned char const   )44,      (unsigned char const   )44,      (unsigned char const   )44,      (unsigned char const   )44, 
        (unsigned char const   )44,      (unsigned char const   )44,      (unsigned char const   )44,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )41,      (unsigned char const   )41, 
        (unsigned char const   )41,      (unsigned char const   )41,      (unsigned char const   )41,      (unsigned char const   )41, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )42,      (unsigned char const   )42, 
        (unsigned char const   )42,      (unsigned char const   )42,      (unsigned char const   )42,      (unsigned char const   )42, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128,      (unsigned char const   )128, 
        (unsigned char const   )128,      (unsigned char const   )48,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96,      (unsigned char const   )96, 
        (unsigned char const   )96,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )96,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33,      (unsigned char const   )33, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )96,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34,      (unsigned char const   )34, 
        (unsigned char const   )34};
#line 1 "cil-LPU10RLF.o"
#pragma merger(0,"/tmp/cil-FTsVbE41.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 208 "../../includes/usr/include/stdio.h"
int fclose(FILE *f ) ;
#line 11 "../../libc/fclose.c"
int fclose(FILE *f ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 13
  __cil_tmp = fileno(f);
#line 13
  __cil_tmp___0 = close(__cil_tmp);
#line 13
  return (__cil_tmp___0);
}
}
#line 1 "cil-f0pzXZPe.o"
#pragma merger(0,"/tmp/cil-ewlhgtwm.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 213 "../../includes/usr/include/stdio.h"
int fflush(FILE *stream ) ;
#line 3 "../../libc/fflush.c"
int fflush(FILE *stream ) 
{ 

  {
#line 5
  return (0);
}
}
#line 1 "cil-yiK7xl5M.o"
#pragma merger(0,"/tmp/cil-kDtzIvTP.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 437 "../../includes/usr/include/stdio.h"
int fgetc(FILE *f ) ;
#line 11 "../../libc/fgetc.c"
int fgetc(FILE *f ) 
{ int __cil_tmp ;

  {
#line 13
  __cil_tmp = _IO_getc(f);
#line 13
  return (__cil_tmp);
}
}
#line 1 "cil-qMo2aplL.o"
#pragma merger(0,"/tmp/cil-sjSDSsij.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 528 "../../includes/usr/include/stdio.h"
char *fgets(char * __restrict  s , int n , FILE * __restrict  f ) ;
#line 11 "../../libc/fgets.c"
char *fgets(char * __restrict  s , int n , FILE * __restrict  f ) 
{ int ch ;
  char *p ;
  char *__cil_tmp ;

  {
#line 14
  p = (char *)s;
#line 16
  while (n > 1) {
#line 17
    ch = _IO_getc((_IO_FILE *)f);
#line 18
    if (ch == -1) {
#line 19
      *p = (char )'\000';
#line 20
      return ((char *)((void *)0));
    }
#line 22
    __cil_tmp = p;
#line 22
    p ++;
#line 22
    *__cil_tmp = (char )ch;
#line 23
    n --;
#line 24
    if (ch == 10) {
#line 25
      break;
    }
  }
#line 27
  if (n) {
#line 28
    *p = (char )'\000';
  }
#line 30
  return ((char *)s);
}
}
#line 1 "cil-7R8fDCyu.o"
#pragma merger(0,"/tmp/cil-sncp4qtQ.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 338 "../../includes/usr/include/stdio.h"
int vfprintf(FILE * __restrict  file , char const   * __restrict  format , __gnuc_va_list ap ) ;
#line 10 "../../libc/fprintf.c"
int fprintf(FILE * __restrict  file , char const   * __restrict  format  , ...) 
{ va_list ap ;
  int rv ;

  {
#line 15
  __builtin_va_start(ap, format);
#line 16
  rv = vfprintf(file, format, ap);
#line 17
  __builtin_va_end(ap);
#line 18
  return (rv);
}
}
#line 1 "cil-14xCqgoD.o"
#pragma merger(0,"/tmp/cil-FNANNAo7.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 479 "../../includes/usr/include/stdio.h"
int fputc(int c , FILE *f ) ;
#line 9 "../../libc/fwrite.c"
size_t___0 _fwrite(void const   *buf , size_t___0 count , FILE *f ) 
{ size_t___0 bytes ;
  ssize_t rv ;
  char const   *p ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 11
  bytes = 0UL;
#line 13
  p = (char const   *)buf;
#line 15
  while (count) {
#line 16
    __cil_tmp = fileno(f);
#line 16
    rv = write(__cil_tmp, (void const   *)p, count);
#line 17
    if (rv == -1) {
#line 18
      __cil_tmp___1 = __errno_location();
#line 18
      if (*__cil_tmp___1 == 4) {
#line 19
        __cil_tmp___0 = __errno_location();
#line 19
        *__cil_tmp___0 = 0;
#line 20
        continue;
      } else {
#line 22
        break;
      }
    } else {
#line 23
      if (rv == 0) {
#line 24
        break;
      }
    }
#line 27
    p += rv;
#line 28
    bytes += (unsigned long )rv;
#line 29
    count -= (unsigned long )rv;
  }
#line 32
  return (bytes);
}
}
#line 10 "../../libc/fputc.c"
int fputc(int c , FILE *f ) 
{ unsigned char ch ;
  int __cil_tmp___0 ;
  size_t___0 __cil_tmp___1 ;

  {
#line 12
  ch = (unsigned char )c;
#line 14
  __cil_tmp___1 = _fwrite((void const   *)(& ch), 1UL, f);
#line 14
  if (__cil_tmp___1 == 1UL) {
#line 14
    __cil_tmp___0 = (int )ch;
  } else {
#line 14
    __cil_tmp___0 = -1;
  }
#line 14
  return (__cil_tmp___0);
}
}
#line 1 "cil-s57NMVJx.o"
#pragma merger(0,"/tmp/cil-hDtZ8qma.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 585 "../../includes/usr/include/stdio.h"
int fputs(char const   * __restrict  s , FILE * __restrict  file ) ;
#line 13 "../../libc/fputs.c"
int fputs(char const   * __restrict  s , FILE * __restrict  file ) 
{ size_t___0 __cil_tmp ;
  size_t___0 __cil_tmp___0 ;

  {
#line 15
  __cil_tmp = strlen((char const   *)s);
#line 15
  __cil_tmp___0 = _fwrite((void const   *)s, __cil_tmp, (FILE *)file);
#line 15
  return ((int )__cil_tmp___0);
}
}
#line 1 "cil-FiSRlZXc.o"
#pragma merger(0,"/tmp/cil-CgpFzgZF.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 9 "../../libc/fread.c"
size_t___0 _fread(void *buf , size_t___0 count , FILE *f ) 
{ size_t___0 bytes ;
  ssize_t rv ;
  char *p ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;
  int *__cil_tmp___1 ;

  {
#line 11
  bytes = 0UL;
#line 13
  p = (char *)buf;
#line 15
  while (count) {
#line 16
    __cil_tmp = fileno(f);
#line 16
    rv = read(__cil_tmp, (void *)p, count);
#line 17
    if (rv == -1) {
#line 18
      __cil_tmp___1 = __errno_location();
#line 18
      if (*__cil_tmp___1 == 4) {
#line 19
        __cil_tmp___0 = __errno_location();
#line 19
        *__cil_tmp___0 = 0;
#line 20
        continue;
      } else {
#line 22
        break;
      }
    } else {
#line 23
      if (rv == 0) {
#line 24
        break;
      }
    }
#line 27
    p += rv;
#line 28
    bytes += (unsigned long )rv;
#line 29
    count -= (unsigned long )rv;
  }
#line 32
  return (bytes);
}
}
#line 1 "cil-saxpxCoM.o"
#pragma merger(0,"/tmp/cil-ce3nWnCR.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 605 "../../includes/usr/include/stdio.h"
size_t___0 fread(void * __restrict  ptr , size_t___0 size , size_t___0 nmemb , FILE * __restrict  f ) ;
#line 11 "../../libc/fread2.c"
size_t___0 fread(void * __restrict  ptr , size_t___0 size , size_t___0 nmemb , FILE * __restrict  f ) 
{ size_t___0 __cil_tmp ;

  {
#line 13
  __cil_tmp = _fread((void *)ptr, size * nmemb, (FILE *)f);
#line 13
  return (__cil_tmp / size);
}
}
#line 1 "cil-cqQNEtYN.o"
#pragma merger(0,"/tmp/cil-rgrW8i0N.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 1 "cil-Gb9e8cQa.o"
#pragma merger(0,"/tmp/cil-xaQ2L80S.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 611 "../../includes/usr/include/stdio.h"
size_t___0 fwrite(void const   * __restrict  ptr , size_t___0 size , size_t___0 nmemb ,
                  FILE * __restrict  f ) ;
#line 11 "../../libc/fwrite2.c"
size_t___0 fwrite(void const   * __restrict  ptr , size_t___0 size , size_t___0 nmemb ,
                  FILE * __restrict  f ) 
{ size_t___0 __cil_tmp ;

  {
#line 13
  __cil_tmp = _fwrite((void const   *)ptr, size * nmemb, (FILE *)f);
#line 13
  return (__cil_tmp / size);
}
}
#line 1 "cil-1ELfKpyd.o"
#pragma merger(0,"/tmp/cil-JJ9rTWVe.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 33 "../../libc/ctype.h"
__inline static int __ctype_isalnum(int __c ) 
{ 

  {
#line 35
  return ((int )((int const   )__ctypes[__c + 1] & 7));
}
}
#line 126
int isalnum(int c ) ;
#line 2 "../../libc/isalnum.c"
int isalnum(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isalnum(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-ntDCNIsj.o"
#pragma merger(0,"/tmp/cil-PCWWtZf0.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 39 "../../libc/ctype.h"
__inline static int __ctype_isalpha(int __c ) 
{ 

  {
#line 41
  return ((int )((int const   )__ctypes[__c + 1] & 3));
}
}
#line 127
int isalpha(int c ) ;
#line 2 "../../libc/isalpha.c"
int isalpha(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isalpha(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-5YsBsJO0.o"
#pragma merger(0,"/tmp/cil-Zh25xWEM.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 44 "../../libc/ctype.h"
__inline static int __ctype_isascii(int __c ) 
{ 

  {
#line 46
  return (! (__c & -128));
}
}
#line 128
int isascii(int c ) ;
#line 2 "../../libc/isascii.c"
int isascii(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isascii(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-PLfIDtkx.o"
#pragma merger(0,"/tmp/cil-QYUtPns6.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 49 "../../libc/ctype.h"
__inline static int __ctype_isblank(int __c ) 
{ 

  {
#line 51
  return (__c == 9 || __c == 32);
}
}
#line 129
int isblank(int c ) ;
#line 2 "../../libc/isblank.c"
int isblank(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isblank(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-5uQQt6Wb.o"
#pragma merger(0,"/tmp/cil-DKoiCSjG.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 54 "../../libc/ctype.h"
__inline static int __ctype_iscntrl(int __c ) 
{ 

  {
#line 56
  return ((int )((int const   )__ctypes[__c + 1] & 128));
}
}
#line 130
int iscntrl(int c ) ;
#line 2 "../../libc/iscntrl.c"
int iscntrl(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_iscntrl(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-mDrYDSGB.o"
#pragma merger(0,"/tmp/cil-Nu9nZPuR.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 59 "../../libc/ctype.h"
__inline static int __ctype_isdigit(int __c ) 
{ 

  {
#line 61
  return ((unsigned int )__c - 48U <= 9U);
}
}
#line 2 "../../libc/isdigit.c"
int isdigit(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isdigit(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-qo1jjHtR.o"
#pragma merger(0,"/tmp/cil-enzV0FPN.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 64 "../../libc/ctype.h"
__inline static int __ctype_isgraph(int __c ) 
{ 

  {
#line 66
  return ((int )((int const   )__ctypes[__c + 1] & 71));
}
}
#line 132
int isgraph(int c ) ;
#line 2 "../../libc/isgraph.c"
int isgraph(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isgraph(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-XqWbpFZF.o"
#pragma merger(0,"/tmp/cil-oyGTZbe2.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 70 "../../libc/ctype.h"
__inline static int __ctype_islower(int __c ) 
{ 

  {
#line 72
  return ((int )((int const   )__ctypes[__c + 1] & 2));
}
}
#line 133
int islower(int c ) ;
#line 2 "../../libc/islower.c"
int islower(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_islower(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-gt2tEcCX.o"
#pragma merger(0,"/tmp/cil-vS7OWm7g.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 75 "../../libc/ctype.h"
__inline static int __ctype_isprint(int __c ) 
{ 

  {
#line 77
  return ((int )((int const   )__ctypes[__c + 1] & 32));
}
}
#line 134
int isprint(int c ) ;
#line 2 "../../libc/isprint.c"
int isprint(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isprint(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-KeEzUpjG.o"
#pragma merger(0,"/tmp/cil-NKS4BMPB.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 80 "../../libc/ctype.h"
__inline static int __ctype_ispunct(int __c ) 
{ 

  {
#line 82
  return ((int )((int const   )__ctypes[__c + 1] & 64));
}
}
#line 135
int ispunct(int c ) ;
#line 2 "../../libc/ispunct.c"
int ispunct(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_ispunct(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-O87JUSka.o"
#pragma merger(0,"/tmp/cil-RjVEjKTR.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 85 "../../libc/ctype.h"
__inline static int __ctype_isspace(int __c ) 
{ 

  {
#line 87
  return ((int )((int const   )__ctypes[__c + 1] & 16));
}
}
#line 2 "../../libc/isspace.c"
int isspace(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isspace(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-TfV2hqFY.o"
#pragma merger(0,"/tmp/cil-rUI79FX4.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 90 "../../libc/ctype.h"
__inline static int __ctype_isupper(int __c ) 
{ 

  {
#line 92
  return ((int )((int const   )__ctypes[__c + 1] & 1));
}
}
#line 137
int isupper(int c ) ;
#line 2 "../../libc/isupper.c"
int isupper(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isupper(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-Ax0gjXUF.o"
#pragma merger(0,"/tmp/cil-wLI5Y6XH.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 95 "../../libc/ctype.h"
__inline static int __ctype_isxdigit(int __c ) 
{ 

  {
#line 97
  return ((int )((int const   )__ctypes[__c + 1] & 8));
}
}
#line 2 "../../libc/isxdigit.c"
int isxdigit(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_isxdigit(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-iBtGJwId.o"
#pragma merger(0,"/tmp/cil-uQ4cgdch.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 62 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) int memcmp(void const   *s1 , void const   *s2 , size_t___0 n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 7 "../../libc/memcmp.c"
 __attribute__((__nothrow__)) int memcmp(void const   *s1 , void const   *s2 , size_t___0 n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 7 "../../libc/memcmp.c"
int memcmp(void const   *s1 , void const   *s2 , size_t___0 n ) 
{ unsigned char const   *c1 ;
  unsigned char const   *c2 ;
  int d ;
  unsigned char const   *__cil_tmp ;
  unsigned char const   *__cil_tmp___0 ;
  size_t___0 __cil_tmp___1 ;

  {
#line 9
  c1 = (unsigned char const   *)s1;
#line 9
  c2 = (unsigned char const   *)s2;
#line 10
  d = 0;
#line 12
  while (1) {
#line 12
    __cil_tmp___1 = n;
#line 12
    n --;
#line 12
    if (! __cil_tmp___1) {
#line 12
      break;
    }
#line 13
    __cil_tmp = c1;
#line 13
    c1 ++;
#line 13
    __cil_tmp___0 = c2;
#line 13
    c2 ++;
#line 13
    d = (int )*__cil_tmp - (int )*__cil_tmp___0;
#line 14
    if (d) {
#line 15
      break;
    }
  }
#line 18
  return (d);
}
}
#line 1 "cil-jZcJjBE0.o"
#pragma merger(0,"/tmp/cil-ZxWNDE9t.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 8 "../../libc/memcpy.c"
 __attribute__((__nothrow__)) void *memcpy(void * __restrict  dst , void const   * __restrict  src ,
                                           size_t___0 n )  __attribute__((__nonnull__(1,2))) ;
#line 8 "../../libc/memcpy.c"
void *memcpy(void * __restrict  dst , void const   * __restrict  src , size_t___0 n ) 
{ char const   *p ;
  char *q ;
  char *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  size_t___0 __cil_tmp___1 ;

  {
#line 10
  p = (char const   *)src;
#line 11
  q = (char *)dst;
#line 12
  while (1) {
#line 12
    __cil_tmp___1 = n;
#line 12
    n --;
#line 12
    if (! __cil_tmp___1) {
#line 12
      break;
    }
#line 13
    __cil_tmp = q;
#line 13
    q ++;
#line 13
    __cil_tmp___0 = p;
#line 13
    p ++;
#line 13
    *__cil_tmp = (char )*__cil_tmp;
    *__cil_tmp = (char )*__cil_tmp___0;
  }
#line 15
  return ((void *)dst);
}
}
#line 1 "cil-M7joeSSn.o"
#pragma merger(0,"/tmp/cil-pfoOIlYO.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 14 "../../libc/memmem.c"
void *memmem(void const   *haystack , size_t___0 n , void const   *needle , size_t___0 m ) 
{ unsigned char const   *y ;
  unsigned char const   *x ;
  size_t___0 j ;
  size_t___0 k ;
  size_t___0 l ;
  int __cil_tmp ;

  {
#line 16
  y = (unsigned char const   *)haystack;
#line 17
  x = (unsigned char const   *)needle;
#line 21
  if ((m > n || ! m) || ! n) {
#line 22
    return ((void *)0);
  }
#line 24
  if (1UL != m) {
#line 25
    if ((int const   )*(x + 0) == (int const   )*(x + 1)) {
#line 26
      k = 2UL;
#line 27
      l = 1UL;
    } else {
#line 29
      k = 1UL;
#line 30
      l = 2UL;
    }
#line 33
    j = 0UL;
#line 34
    while (j <= n - m) {
#line 35
      if ((int const   )*(x + 1) != (int const   )*(y + (j + 1UL))) {
#line 36
        j += k;
      } else {
#line 38
        __cil_tmp = memcmp((void const   *)(x + 2), (void const   *)((y + j) + 2),
                           m - 2UL);
#line 38
        if (__cil_tmp) {
          _L: ;
        } else {
#line 38
          if ((int const   )*(x + 0) == (int const   )*(y + j)) {
#line 40
            return ((void *)(y + j));
          } else {
#line 38
            goto _L;
          }
        }
#line 41
        j += l;
      }
    }
  } else {
#line 45
    while (1) {
#line 46
      if ((int const   )*y == (int const   )*x) {
#line 47
        return ((void *)y);
      }
#line 48
      y ++;
#line 45
      n --;
#line 45
      if (! n) {
#line 45
        break;
      }
    }
  }
#line 51
  return ((void *)0);
}
}
#line 1 "cil-BOuoKSPi.o"
#pragma merger(0,"/tmp/cil-72cQFwSj.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 43 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) void *memmove(void *dst , void const   *src , size_t___0 n )  __attribute__((__nonnull__(1,2))) ;
#line 7 "../../libc/memmove.c"
 __attribute__((__nothrow__)) void *memmove(void *dst , void const   *src , size_t___0 n )  __attribute__((__nonnull__(1,2))) ;
#line 7 "../../libc/memmove.c"
void *memmove(void *dst , void const   *src , size_t___0 n ) 
{ char const   *p ;
  char *q ;
  char *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  size_t___0 __cil_tmp___1 ;
  size_t___0 __cil_tmp___2 ;

  {
#line 9
  p = (char const   *)src;
#line 10
  q = (char *)dst;
#line 11
  if ((unsigned int )q < (unsigned int )p) {
#line 12
    while (1) {
#line 12
      __cil_tmp___1 = n;
#line 12
      n --;
#line 12
      if (! __cil_tmp___1) {
#line 12
        break;
      }
#line 13
      __cil_tmp = q;
#line 13
      q ++;
#line 13
      __cil_tmp___0 = p;
#line 13
      p ++;
#line 13
      *__cil_tmp = (char )*__cil_tmp___0;
    }
  } else {
#line 16
    p += n;
#line 17
    q += n;
#line 18
    while (1) {
#line 18
      __cil_tmp___2 = n;
#line 18
      n --;
#line 18
      if (! __cil_tmp___2) {
#line 18
        break;
      }
#line 19
      q --;
#line 19
      p --;
#line 19
      *q = (char )*p;
    }
  }
#line 22
  return (dst);
}
}
#line 1 "cil-WSmT5EEv.o"
#pragma merger(0,"/tmp/cil-8noyd3Hi.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "../../libc/memset.c"
 __attribute__((__nothrow__)) void *memset(void *dst , int c , size_t___0 n )  __attribute__((__nonnull__(1))) ;
#line 7 "../../libc/memset.c"
void *memset(void *dst , int c , size_t___0 n ) 
{ char *q ;
  char *__cil_tmp ;
  size_t___0 __cil_tmp___0 ;

  {
#line 9
  q = (char *)dst;
#line 30
  while (1) {
#line 30
    __cil_tmp___0 = n;
#line 30
    n --;
#line 30
    if (! __cil_tmp___0) {
#line 30
      break;
    }
#line 31
    __cil_tmp = q;
#line 31
    q ++;
#line 31
    *__cil_tmp = (char )c;
  }
#line 34
  return (dst);
}
}
#line 1 "cil-Cd6WTuyY.o"
#pragma merger(0,"/tmp/cil-M0oqnAG2.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 143 "../../includes/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 329
int printf(char const   * __restrict  format  , ...) ;
#line 10 "../../libc/printf.c"
int printf(char const   * __restrict  format  , ...) 
{ va_list ap ;
  int rv ;

  {
#line 15
  __builtin_va_start(ap, format);
#line 16
  rv = vfprintf((FILE * __restrict  )stdout, format, ap);
#line 17
  __builtin_va_end(ap);
#line 18
  return (rv);
}
}
#line 1 "cil-pHXeH9sg.o"
#pragma merger(0,"/tmp/cil-9bVkoEMt.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 493 "../../includes/usr/include/stdlib.h"
 __attribute__((__nothrow__)) int rand(void) ;
#line 26 "../../libc/rand.c"
 __attribute__((__nothrow__)) int rand(void) ;
#line 26 "../../libc/rand.c"
int rand(void) 
{ long __cil_tmp ;

  {
#line 29
  __cil_tmp = __random();
#line 29
  return ((int )__cil_tmp);
}
}
#line 1 "cil-yzfAU1ym.o"
#pragma merger(0,"/tmp/cil-cWyZWPd0.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 353 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  buffer ,
                                                                      size_t___0 n ,
                                                                      char const   * __restrict  format 
                                                                      , ...) ;
#line 357
 __attribute__((__nothrow__)) int vsnprintf(char * __restrict  buffer , size_t___0 n ,
                                            char const   * __restrict  format , __gnuc_va_list ap ) ;
#line 8 "../../libc/snprintf.c"
 __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  buffer ,
                                                                      size_t___0 n ,
                                                                      char const   * __restrict  format 
                                                                      , ...) ;
#line 8 "../../libc/snprintf.c"
int ( /* format attribute */  snprintf)(char * __restrict  buffer , size_t___0 n ,
                                        char const   * __restrict  format  , ...) 
{ va_list ap ;
  int rv ;

  {
#line 13
  __builtin_va_start(ap, format);
#line 14
  rv = vsnprintf(buffer, n, format, ap);
#line 15
  __builtin_va_end(ap);
#line 16
  return (rv);
}
}
#line 1 "cil-C0YxspHz.o"
#pragma merger(0,"/tmp/cil-HUvefs6f.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 10 "../../libc/sprintf.c"
 __attribute__((__nothrow__)) int sprintf(char * __restrict  buffer , char const   * __restrict  format 
                                          , ...) ;
#line 10 "../../libc/sprintf.c"
int sprintf(char * __restrict  buffer , char const   * __restrict  format  , ...) 
{ va_list ap ;
  int rv ;

  {
#line 15
  __builtin_va_start(ap, format);
#line 16
  rv = vsnprintf(buffer, ~ 0UL, format, ap);
#line 17
  __builtin_va_end(ap);
#line 19
  return (rv);
}
}
#line 1 "cil-PVZWkD3y.o"
#pragma merger(0,"/tmp/cil-OEIUqu6H.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 495 "../../includes/usr/include/stdlib.h"
 __attribute__((__nothrow__)) void srand(unsigned int seed ) ;
#line 26 "../../libc/srand.c"
 __attribute__((__nothrow__)) void srand(unsigned int seed ) ;
#line 26 "../../libc/srand.c"
void srand(unsigned int seed ) 
{ 

  {
#line 26
  __srandom(seed);
#line 26
  return;
}
}
#line 1 "cil-BBLnz6w1.o"
#pragma merger(0,"/tmp/cil-ShMCReei.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 325 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) int strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 139 "../../libc/ctype.h"
 __attribute__((__nothrow__)) int toupper(int c ) ;
#line 8 "../../libc/strcasecmp.c"
 __attribute__((__nothrow__)) int strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 8 "../../libc/strcasecmp.c"
int strcasecmp(char const   *s1 , char const   *s2 ) 
{ unsigned char const   *c1 ;
  unsigned char const   *c2 ;
  unsigned char ch ;
  int d ;
  unsigned char const   *__cil_tmp ;
  int __cil_tmp___0 ;
  unsigned char const   *__cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 10
  c1 = (unsigned char const   *)s1;
#line 11
  c2 = (unsigned char const   *)s2;
#line 13
  d = 0;
#line 15
  while (1) {
#line 18
    __cil_tmp = c1;
#line 18
    c1 ++;
#line 18
    ch = (unsigned char )*__cil_tmp;
#line 18
    __cil_tmp___0 = toupper((int )ch);
#line 18
    __cil_tmp___1 = c2;
#line 18
    c2 ++;
#line 18
    __cil_tmp___2 = toupper((int )*__cil_tmp___1);
#line 18
    d = __cil_tmp___0 - __cil_tmp___2;
#line 19
    if (d || ! ch) {
#line 20
      break;
    }
  }
#line 23
  return (d);
}
}
#line 1 "cil-5PO0Zsqt.o"
#pragma merger(0,"/tmp/cil-DWZhnBHU.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 92 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) char *strcat(char * __restrict  dst , char const   * __restrict  src )  __attribute__((__nonnull__(1,2))) ;
#line 7 "../../libc/strcat.c"
 __attribute__((__nothrow__)) char *strcat(char * __restrict  dst , char const   * __restrict  src )  __attribute__((__nonnull__(1,2))) ;
#line 7 "../../libc/strcat.c"
char *strcat(char * __restrict  dst , char const   * __restrict  src ) 
{ char *__cil_tmp ;

  {
#line 9
  __cil_tmp = strchr((char const   *)dst, '\000');
#line 9
  strcpy((char * __restrict  )__cil_tmp, src);
#line 10
  return ((char *)dst);
}
}
#line 1 "cil-6WHT2Y5H.o"
#pragma merger(0,"/tmp/cil-Blg1RsaO.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "../../libc/strchr.c"
 __attribute__((__nothrow__)) char *strchr(char const   *s , int c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 7 "../../libc/strchr.c"
char *strchr(char const   *s , int c ) 
{ 

  {
#line 9
  while ((int const   )*s != (int const   )((char )c)) {
#line 10
    if (! *s) {
#line 11
      return ((char *)((void *)0));
    }
#line 12
    s ++;
  }
#line 15
  return ((char *)s);
}
}
#line 1 "cil-WQkSdhBy.o"
#pragma merger(0,"/tmp/cil-WmDd1q6J.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "../../libc/strcmp.c"
 __attribute__((__nothrow__)) int strcmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 7 "../../libc/strcmp.c"
int strcmp(char const   *s1 , char const   *s2 ) 
{ unsigned char const   *c1 ;
  unsigned char const   *c2 ;
  unsigned char ch ;
  int d ;
  unsigned char const   *__cil_tmp ;
  unsigned char const   *__cil_tmp___0 ;

  {
#line 9
  c1 = (unsigned char const   *)s1;
#line 10
  c2 = (unsigned char const   *)s2;
#line 12
  d = 0;
#line 14
  while (1) {
#line 15
    __cil_tmp = c1;
#line 15
    c1 ++;
#line 15
    ch = (unsigned char )*__cil_tmp;
#line 15
    __cil_tmp___0 = c2;
#line 15
    c2 ++;
#line 15
    d = (int )ch - (int )*__cil_tmp___0;
#line 16
    if (d || ! ch) {
#line 17
      break;
    }
  }
#line 20
  return (d);
}
}
#line 1 "cil-3O3MJoxK.o"
#pragma merger(0,"/tmp/cil-lfsYC5V9.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 9 "../../libc/strcpy.c"
 __attribute__((__nothrow__)) char *strcpy(char * __restrict  dst , char const   * __restrict  src )  __attribute__((__nonnull__(1,2))) ;
#line 9 "../../libc/strcpy.c"
char *strcpy(char * __restrict  dst , char const   * __restrict  src ) 
{ char *q ;
  char const   *p ;
  char ch ;
  char *__cil_tmp ;
  char const   *__cil_tmp___0 ;

  {
#line 11
  q = (char *)dst;
#line 12
  p = (char const   *)src;
#line 15
  while (1) {
#line 16
    __cil_tmp = q;
#line 16
    q ++;
#line 16
    __cil_tmp___0 = p;
#line 16
    p ++;
#line 16
    ch = (char )*__cil_tmp___0;
#line 16
    *__cil_tmp = ch;
#line 15
    if (! ch) {
#line 15
      break;
    }
  }
#line 19
  return ((char *)dst);
}
}
#line 1 "cil-BhPpRyCK.o"
#pragma merger(0,"/tmp/cil-pdrWijJL.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 184 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) size_t___0 strcspn(char const   *s , char const   *reject )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 9 "../../libc/strcspn.c"
 __attribute__((__nothrow__)) size_t___0 strcspn(char const   *s , char const   *reject )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 9 "../../libc/strcspn.c"
size_t___0 strcspn(char const   *s , char const   *reject ) 
{ char *r ;
  int count ;

  {
#line 12
  count = 0;
#line 13
  while ((int const   )*s != 0) {
#line 14
    r = (char *)reject;
#line 14
    while ((int )*r != 0) {
#line 15
      if ((int const   )*s == (int const   )*r) {
#line 15
        goto FAIL;
      }
#line 14
      r ++;
    }
#line 13
    s ++;
#line 13
    count ++;
  }
  FAIL: 
#line 17
  return ((unsigned long )count);
}
}
#line 1 "cil-bZGb67zW.o"
#pragma merger(0,"/tmp/cil-9J9YWa78.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 4 "../../libc/strlcpy.c"
size_t___0 strlcat(char *dst , char const   *src , size_t___0 size ) 
{ size_t___0 len1 ;
  size_t___0 __cil_tmp ;
  size_t___0 len2 ;
  size_t___0 __cil_tmp___0 ;
  size_t___0 ret___0 ;

  {
#line 10
  __cil_tmp = strlen((char const   *)dst);
#line 10
  len1 = __cil_tmp;
#line 11
  __cil_tmp___0 = strlen(src);
#line 11
  len2 = __cil_tmp___0;
#line 12
  ret___0 = len1 + len2;
#line 14
  if ((int )size && len1 < size - 1UL) {
#line 15
    if (len2 >= size - len1) {
#line 16
      len2 = (size - len1) - 1UL;
    }
#line 17
    memcpy((void * __restrict  )(dst + len1), (void const   * __restrict  )src, len2);
#line 18
    *(dst + (len1 + len2)) = (char)0;
  }
#line 20
  return (ret___0);
}
}
#line 24 "../../libc/strlcpy.c"
size_t___0 strlcpy(char *dst , char const   *src , size_t___0 size ) 
{ size_t___0 len ;
  size_t___0 __cil_tmp ;
  size_t___0 ret___0 ;

  {
#line 30
  __cil_tmp = strlen(src);
#line 30
  len = __cil_tmp;
#line 31
  ret___0 = len;
#line 33
  if (size > 0UL) {
#line 34
    if (len >= size) {
#line 34
      len = size - 1UL;
    }
#line 35
    memcpy((void * __restrict  )dst, (void const   * __restrict  )src, len);
#line 36
    *(dst + len) = (char)0;
  }
#line 38
  return (ret___0);
}
}
#line 1 "cil-jQrzSPHR.o"
#pragma merger(0,"/tmp/cil-vlnqTPke.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "../../libc/strlen.c"
 __attribute__((__nothrow__)) size_t___0 strlen(char const   *s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 7 "../../libc/strlen.c"
size_t___0 strlen(char const   *s ) 
{ char const   *ss ;

  {
#line 9
  ss = s;
#line 10
  while (*ss) {
#line 11
    ss ++;
  }
#line 12
  return ((unsigned long )(ss - s));
}
}
#line 1 "cil-CdQnMORV.o"
#pragma merger(0,"/tmp/cil-xlOa38Gd.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 95 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) char *strncat(char * __restrict  dst , char const   * __restrict  src ,
                                            size_t___0 n )  __attribute__((__nonnull__(1,2))) ;
#line 8 "../../libc/strncat.c"
 __attribute__((__nothrow__)) char *strncat(char * __restrict  dst , char const   * __restrict  src ,
                                            size_t___0 n )  __attribute__((__nonnull__(1,2))) ;
#line 8 "../../libc/strncat.c"
char *strncat(char * __restrict  dst , char const   * __restrict  src , size_t___0 n ) 
{ char *q ;
  char *__cil_tmp ;
  char const   *p ;
  char ch ;
  char *__cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  size_t___0 __cil_tmp___2 ;

  {
#line 10
  __cil_tmp = strchr((char const   *)dst, '\000');
#line 10
  q = __cil_tmp;
#line 11
  p = (char const   *)src;
#line 14
  while (1) {
#line 14
    __cil_tmp___2 = n;
#line 14
    n --;
#line 14
    if (! __cil_tmp___2) {
#line 14
      break;
    }
#line 15
    __cil_tmp___0 = q;
#line 15
    q ++;
#line 15
    __cil_tmp___1 = p;
#line 15
    p ++;
#line 15
    ch = (char )*__cil_tmp___1;
#line 15
    *__cil_tmp___0 = ch;
#line 16
    if (! ch) {
#line 17
      return ((char *)dst);
    }
  }
#line 19
  *q = (char )'\000';
#line 21
  return ((char *)dst);
}
}
#line 1 "cil-95aVErrS.o"
#pragma merger(0,"/tmp/cil-JeqC8pr7.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "../../libc/strncmp.c"
 __attribute__((__nothrow__)) int strncmp(char const   *s1 , char const   *s2 , size_t___0 n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 7 "../../libc/strncmp.c"
int strncmp(char const   *s1 , char const   *s2 , size_t___0 n ) 
{ unsigned char const   *c1 ;
  unsigned char const   *c2 ;
  unsigned char ch ;
  int d ;
  unsigned char const   *__cil_tmp ;
  unsigned char const   *__cil_tmp___0 ;
  size_t___0 __cil_tmp___1 ;

  {
#line 9
  c1 = (unsigned char const   *)s1;
#line 10
  c2 = (unsigned char const   *)s2;
#line 12
  d = 0;
#line 14
  while (1) {
#line 14
    __cil_tmp___1 = n;
#line 14
    n --;
#line 14
    if (! __cil_tmp___1) {
#line 14
      break;
    }
#line 15
    __cil_tmp = c1;
#line 15
    c1 ++;
#line 15
    ch = (unsigned char )*__cil_tmp;
#line 15
    __cil_tmp___0 = c2;
#line 15
    c2 ++;
#line 15
    d = (int )ch - (int )*__cil_tmp___0;
#line 16
    if (d || ! ch) {
#line 17
      break;
    }
  }
#line 20
  return (d);
}
}
#line 1 "cil-ZMBLwipd.o"
#pragma merger(0,"/tmp/cil-4eAHloQd.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "../../libc/strncpy.c"
 __attribute__((__nothrow__)) char *strncpy(char * __restrict  dst , char const   * __restrict  src ,
                                            size_t___0 n )  __attribute__((__nonnull__(1,2))) ;
#line 7 "../../libc/strncpy.c"
char *strncpy(char * __restrict  dst , char const   * __restrict  src , size_t___0 n ) 
{ char *q ;
  char const   *p ;
  char ch ;
  char *__cil_tmp ;
  char const   *__cil_tmp___0 ;

  {
#line 9
  q = (char *)dst;
#line 10
  p = (char const   *)src;
#line 13
  while (n) {
#line 14
    n --;
#line 15
    __cil_tmp = q;
#line 15
    q ++;
#line 15
    __cil_tmp___0 = p;
#line 15
    p ++;
#line 15
    ch = (char )*__cil_tmp___0;
#line 15
    *__cil_tmp = ch;
#line 16
    if (! ch) {
#line 17
      break;
    }
  }
#line 21
  memset((void *)q, 0, n);
#line 23
  return ((char *)dst);
}
}
#line 1 "cil-zFaVCOCv.o"
#pragma merger(0,"/tmp/cil-cn9xYbpQ.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 1 "cil-WuufaIg3.o"
#pragma merger(0,"/tmp/cil-TQrgtbN8.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 10 "../../libc/strxspn.h"
size_t___0 __strxspn(char const   *s , char const   *map , int parity ) ;
#line 7 "../../libc/strpbrk.c"
 __attribute__((__nothrow__)) char *strpbrk(char const   *s , char const   *accept___0 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 7
 __attribute__((__nothrow__)) char *strpbrk(char const   *s , char const   *accept___0 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 7 "../../libc/strpbrk.c"
char *strpbrk(char const   *s , char const   *accept___0 ) 
{ char const   *ss ;
  size_t___0 __cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 9
  __cil_tmp = __strxspn(s, accept___0, 1);
#line 9
  ss = s + __cil_tmp;
#line 11
  if (*ss) {
#line 11
    __cil_tmp___0 = (char *)ss;
  } else {
#line 11
    __cil_tmp___0 = (char *)((void *)0);
  }
#line 11
  return (__cil_tmp___0);
}
}
#line 1 "cil-X5uZSUkP.o"
#pragma merger(0,"/tmp/cil-R7SULEAm.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 348 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) char *strsep(char ** __restrict  stringp , char const   * __restrict  delim )  __attribute__((__nonnull__(1,2))) ;
#line 7 "../../libc/strsep.c"
 __attribute__((__nothrow__)) char *strsep(char ** __restrict  stringp , char const   * __restrict  delim )  __attribute__((__nonnull__(1,2))) ;
#line 7 "../../libc/strsep.c"
char *strsep(char ** __restrict  stringp , char const   * __restrict  delim ) 
{ char *s ;
  char *e ;
  char *__cil_tmp ;

  {
#line 9
  s = *stringp;
#line 12
  if (! s) {
#line 13
    return ((char *)((void *)0));
  }
#line 15
  e = strpbrk((char const   *)s, (char const   *)delim);
#line 16
  if (e) {
#line 17
    __cil_tmp = e;
#line 17
    e ++;
#line 17
    *__cil_tmp = (char )'\000';
  }
#line 19
  *stringp = e;
#line 20
  return (s);
}
}
#line 1 "cil-0wV78mIv.o"
#pragma merger(0,"/tmp/cil-glhNrV5h.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 194 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) char *strstr(char const   *haystack , char const   *needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 8 "../../libc/strstr.c"
 __attribute__((__nothrow__)) char *strstr(char const   *haystack , char const   *needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 8 "../../libc/strstr.c"
char *strstr(char const   *haystack , char const   *needle ) 
{ size_t___0 __cil_tmp ;
  size_t___0 __cil_tmp___0 ;
  void *__cil_tmp___1 ;

  {
#line 10
  __cil_tmp = strlen(needle);
#line 10
  __cil_tmp___0 = strlen(haystack);
#line 10
  __cil_tmp___1 = memmem((void const   *)haystack, __cil_tmp___0, (void const   *)needle,
                         __cil_tmp);
#line 10
  return ((char *)__cil_tmp___1);
}
}
#line 1 "cil-5TCbDVnM.o"
#pragma merger(0,"/tmp/cil-0cGEbxmN.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 199 "../../includes/usr/include/string.h"
 __attribute__((__nothrow__)) char *strtok(char * __restrict  s , char const   * __restrict  delim )  __attribute__((__nonnull__(2))) ;
#line 9 "../../libc/strtok.c"
static char *holder  ;
#line 7
 __attribute__((__nothrow__)) char *strtok(char * __restrict  s , char const   * __restrict  delim )  __attribute__((__nonnull__(2))) ;
#line 7 "../../libc/strtok.c"
char *strtok(char * __restrict  s , char const   * __restrict  delim ) 
{ char *__cil_tmp ;

  {
#line 11
  if (s) {
#line 12
    holder = (char *)s;
  }
#line 14
  while (1) {
#line 15
    __cil_tmp = strsep((char ** __restrict  )(& holder), delim);
#line 15
    s = (char * __restrict  )__cil_tmp;
#line 14
    if (! ((int )s && ! *s)) {
#line 14
      break;
    }
  }
#line 18
  return ((char *)s);
}
}
#line 1 "cil-Odemo8cB.o"
#pragma merger(0,"/tmp/cil-JufbdJmj.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 12 "../../libc/strxspn.c"
size_t___0 __strxspn(char const   *s , char const   *map , int parity ) 
{ char matchmap[257] ;
  size_t___0 n ;
  char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;

  {
#line 15
  n = 0UL;
#line 18
  memset((void *)(matchmap), 0, sizeof(matchmap));
#line 19
  while (*map) {
#line 20
    __cil_tmp = map;
#line 20
    map ++;
#line 20
    matchmap[(unsigned char )*__cil_tmp] = (char)1;
  }
#line 23
  matchmap[0] = (char )parity;
#line 26
  while (1) {
#line 26
    __cil_tmp___0 = s;
#line 26
    s ++;
#line 26
    if (! ((int )matchmap[(unsigned char )*__cil_tmp___0] ^ parity)) {
#line 26
      break;
    }
#line 27
    n ++;
  }
#line 29
  return (n);
}
}
#line 1 "cil-8kJrI9Tv.o"
#pragma merger(0,"/tmp/cil-FFN7XgYf.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 181 "../../includes/usr/include/sys/syslog.h"
void openlog(char const   *ident , int option , int facility ) ;
#line 190
void ( /* format attribute */  syslog)(int prio , char const   *format  , ...) ;
#line 200
void vsyslog(int prio , char const   *format , __gnuc_va_list ap ) ;
#line 23 "../../libc/syslog.c"
int __syslog_fd  =    -1;
#line 24 "../../libc/syslog.c"
static char id[32]  ;
#line 25 "../../libc/syslog.c"
static int syslog_flags  =    0;
#line 27 "../../libc/syslog.c"
void openlog(char const   *ident , int option , int facility ) 
{ int fd ;
  char const   *__cil_tmp ;

  {
#line 34
  if (__syslog_fd == -1) {
#line 35
    fd = open("/dev/kmsg", 1);
#line 35
    __syslog_fd = fd;
#line 36
    if (fd == -1) {
#line 37
      return;
    }
#line 38
    fcntl(fd, 2, 1L);
  }
#line 41
  syslog_flags = option;
#line 43
  if (ident) {
#line 43
    __cil_tmp = ident;
  } else {
#line 43
    __cil_tmp = "";
  }
#line 43
  strncpy((char * __restrict  )(id), (char const   * __restrict  )__cil_tmp, 31UL);
#line 44
  return;
}
}
#line 46 "../../libc/syslog.c"
void vsyslog(int prio , char const   *format , __gnuc_va_list ap ) 
{ char buf[1024] ;
  int len ;
  int fd ;
  __pid_t __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 52
  if (__syslog_fd == -1) {
#line 53
    openlog((char const   *)((void *)0), 0, 0);
  }
#line 55
  buf[0] = (char )'<';
#line 56
  buf[1] = (char )((prio & 7) + 48);
#line 57
  buf[2] = (char )'>';
#line 58
  len = 3;
#line 60
  if (syslog_flags & 1) {
#line 61
    __cil_tmp = getpid();
#line 61
    __cil_tmp___0 = sprintf((char * __restrict  )(buf + 3), (char const   * __restrict  )"%s[%u]: ",
                            id, __cil_tmp);
#line 61
    len += __cil_tmp___0;
  } else {
#line 62
    if (id[0]) {
#line 63
      __cil_tmp___1 = sprintf((char * __restrict  )(buf + 3), (char const   * __restrict  )"%s: ",
                              id);
#line 63
      len += __cil_tmp___1;
    }
  }
#line 65
  __cil_tmp___2 = vsnprintf((char * __restrict  )(buf + len), (unsigned long )(1024 - len),
                            (char const   * __restrict  )format, ap);
#line 65
  len += __cil_tmp___2;
#line 67
  if (len > 1023) {
#line 68
    len = 1023;
  }
#line 69
  if ((int )buf[len - 1] != 10) {
#line 70
    __cil_tmp___3 = len;
#line 70
    len ++;
#line 70
    buf[__cil_tmp___3] = (char )'\n';
  }
#line 72
  fd = __syslog_fd;
#line 73
  if (fd == -1) {
#line 74
    fd = 2;
  }
#line 76
  write(fd, (void const   *)(buf), (unsigned long )len);
#line 78
  if (syslog_flags & 32) {
#line 79
    _fwrite((void const   *)(buf + 3), (unsigned long )(len - 3), stderr);
  }
#line 80
  return;
}
}
#line 82 "../../libc/syslog.c"
void ( /* format attribute */  syslog)(int prio , char const   *format  , ...) 
{ va_list ap ;

  {
#line 86
  __builtin_va_start(ap, format);
#line 87
  __COMMENT("Call vsyslog(prio, format, ap)");
  //vsyslog(prio, format, ap);
#line 88
  __builtin_va_end(ap);
#line 89
  return;
}
}
#line 1 "cil-2X6tbsJT.o"
#pragma merger(0,"/tmp/cil-GzMD5kQt.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 109 "../../libc/ctype.h"
__inline static int __ctype_tolower(int __c ) 
{ int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 111
  __cil_tmp___1 = __ctype_isupper(__c);
#line 111
  if (__cil_tmp___1) {
#line 111
    __cil_tmp___0 = __c | 32;
  } else {
#line 111
    __cil_tmp___0 = __c;
  }
#line 111
  return (__cil_tmp___0);
}
}
#line 140
int tolower(int c ) ;
#line 2 "../../libc/tolower.c"
int tolower(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_tolower(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-m12oCSA3.o"
#pragma merger(0,"/tmp/cil-o8Rx8UO7.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 104 "../../libc/ctype.h"
__inline static int __ctype_toupper(int __c ) 
{ int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 106
  __cil_tmp___1 = __ctype_islower(__c);
#line 106
  if (__cil_tmp___1) {
#line 106
    __cil_tmp___0 = __c & -33;
  } else {
#line 106
    __cil_tmp___0 = __c;
  }
#line 106
  return (__cil_tmp___0);
}
}
#line 2 "../../libc/toupper.c"
 __attribute__((__nothrow__)) int toupper(int c ) ;
#line 2 "../../libc/toupper.c"
int toupper(int c ) 
{ int __cil_tmp ;

  {
#line 2
  __cil_tmp = __ctype_toupper(c);
#line 2
  return (__cil_tmp);
}
}
#line 1 "cil-DEfJYprY.o"
#pragma merger(0,"/tmp/cil-CPqbgPGO.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 9 "../../libc/vasprintf.c"
int vasprintf(char **bufp , char const   *format , va_list ap ) 
{ va_list ap1 ;
  int bytes ;
  char *p ;
  int __cil_tmp ;
  void *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 15
  __builtin_va_copy(ap1, ap);
#line 17
  __cil_tmp = vsnprintf((char * __restrict  )((void *)0), 0UL, (char const   * __restrict  )format,
                        ap1);
#line 17
  bytes = __cil_tmp + 1;
#line 18
  __builtin_va_end(ap1);
#line 20
  __cil_tmp___0 = malloc((unsigned long )bytes);
#line 20
  p = (char *)__cil_tmp___0;
#line 20
  *bufp = p;
#line 21
  if (! p) {
#line 22
    return (-1);
  }
#line 24
  __cil_tmp___1 = vsnprintf((char * __restrict  )p, (unsigned long )bytes, (char const   * __restrict  )format,
                            ap);
#line 24
  return (__cil_tmp___1);
}
}
#line 1 "cil-qFiJFbGT.o"
#pragma merger(0,"/tmp/cil-TvuKb8l1.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 13 "../../libc/vfprintf.c"
int vfprintf(FILE * __restrict  file , char const   * __restrict  format , __gnuc_va_list ap ) 
{ int rv ;
  char buffer[32768] ;
  size_t___0 __cil_tmp ;

  {
#line 21
  rv = vsnprintf((char * __restrict  )(buffer), 32768UL, format, ap);
#line 23
  if (rv < 0) {
#line 24
    return (rv);
  }
#line 26
  if (rv > 32767) {
#line 27
    rv = 32767;
  }
#line 29
  __cil_tmp = _fwrite((void const   *)(buffer), (unsigned long )rv, (FILE *)file);
#line 29
  return ((int )__cil_tmp);
}
}
#line 1 "cil-684VT8lt.o"
#pragma merger(0,"/tmp/cil-QCCUM3gO.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 344 "../../includes/usr/include/stdio.h"
int vprintf(char const   * __restrict  format , __gnuc_va_list ap ) ;
#line 8 "../../libc/vprintf.c"
int vprintf(char const   * __restrict  format , __gnuc_va_list ap ) 
{ int __cil_tmp ;

  {
#line 10
  __cil_tmp = vfprintf((FILE * __restrict  )stdout, format, ap);
#line 10
  return (__cil_tmp);
}
}
#line 1 "cil-OmBXMCCx.o"
#pragma merger(0,"/tmp/cil-IYr85Clg.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 48 "../../libc/vsnprintf.c"
static size_t___0 format_int(char *q , size_t___0 n , uintmax_t val , enum flags flags ,
                             int base , int width , int prec ) ;
#line 48 "../../libc/vsnprintf.c"
static char const   lcdigits[17]  = 
#line 48
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 49 "../../libc/vsnprintf.c"
static char const   ucdigits[17]  = 
#line 49
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
#line 42 "../../libc/vsnprintf.c"
static size_t___0 format_int(char *q , size_t___0 n , uintmax_t val , enum flags flags ,
                             int base , int width , int prec ) 
{ char *qq ;
  size_t___0 o ;
  size_t___0 oo ;
  char const   *digits ;
  uintmax_t tmpval ;
  int minus ;
  int ndigits ;
  int nchars ;
  int tickskip ;
  int b4tick ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;
  char *__cil_tmp___1 ;
  char *__cil_tmp___2 ;
  char *__cil_tmp___3 ;
  char *__cil_tmp___4 ;
  char *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  char *__cil_tmp___7 ;

  {
#line 47
  o = 0UL;
#line 52
  minus = 0;
#line 53
  ndigits = 0;
#line 57
  if ((int )flags & 128) {
#line 57
    digits = ucdigits;
  } else {
#line 57
    digits = lcdigits;
  }
#line 60
  if ((int )flags & 64 && (long long )val < 0LL) {
#line 61
    minus = 1;
#line 62
    val = (unsigned long long )(- ((long long )val));
  }
#line 66
  tmpval = val;
#line 67
  while (tmpval) {
#line 68
    tmpval /= (unsigned long long )base;
#line 69
    ndigits ++;
  }
#line 74
  if ((int )flags & 32 && base == 8) {
#line 75
    if (prec < ndigits + 1) {
#line 76
      prec = ndigits + 1;
    }
  }
#line 79
  if (ndigits < prec) {
#line 80
    ndigits = prec;
  } else {
#line 81
    if (val == 0ULL) {
#line 82
      ndigits = 1;
    }
  }
#line 86
  if ((int )flags & 8) {
#line 87
    if (base == 16) {
#line 87
      tickskip = 4;
    } else {
#line 87
      tickskip = 3;
    }
  } else {
#line 89
    tickskip = ndigits;
  }
#line 93
  ndigits += (ndigits - 1) / tickskip;
#line 96
  nchars = ndigits;
#line 98
  if (minus || (int )flags & 20) {
#line 99
    nchars ++;
  }
#line 100
  if ((int )flags & 32 && base == 16) {
#line 101
    nchars += 2;
  }
#line 105
  if (! ((int )flags & 3) && width > nchars) {
#line 106
    while (width > nchars) {
#line 107
      if (o < n) {
#line 107
        __cil_tmp = q;
#line 107
        q ++;
#line 107
        *__cil_tmp = (char )' ';
      }
#line 107
      o ++;
#line 108
      width --;
    }
  }
#line 113
  if (minus) {
#line 114
    if (o < n) {
#line 114
      __cil_tmp___0 = q;
#line 114
      q ++;
#line 114
      *__cil_tmp___0 = (char )'-';
    }
#line 114
    o ++;
  } else {
#line 115
    if ((int )flags & 4) {
#line 116
      if (o < n) {
#line 116
        __cil_tmp___1 = q;
#line 116
        q ++;
#line 116
        *__cil_tmp___1 = (char )'+';
      }
#line 116
      o ++;
    } else {
#line 117
      if ((int )flags & 16) {
#line 118
        if (o < n) {
#line 118
          __cil_tmp___2 = q;
#line 118
          q ++;
#line 118
          *__cil_tmp___2 = (char )' ';
        }
#line 118
        o ++;
      }
    }
  }
#line 120
  if ((int )flags & 32 && base == 16) {
#line 121
    if (o < n) {
#line 121
      __cil_tmp___3 = q;
#line 121
      q ++;
#line 121
      *__cil_tmp___3 = (char )'0';
    }
#line 121
    o ++;
#line 122
    if (o < n) {
#line 122
      __cil_tmp___4 = q;
#line 122
      q ++;
#line 122
      if ((int )flags & 128) {
#line 122
        *__cil_tmp___4 = (char )'X';
      } else {
#line 122
        *__cil_tmp___4 = (char )'x';
      }
    }
#line 122
    o ++;
  }
#line 126
  if (((int )flags & 3) == 1 && width > ndigits) {
#line 127
    while (width > nchars) {
#line 128
      if (o < n) {
#line 128
        __cil_tmp___5 = q;
#line 128
        q ++;
#line 128
        *__cil_tmp___5 = (char )'0';
      }
#line 128
      o ++;
#line 129
      width --;
    }
  }
#line 134
  q += ndigits;
#line 135
  o += (unsigned long )ndigits;
#line 136
  qq = q;
#line 137
  oo = o;
#line 139
  b4tick = tickskip;
#line 140
  while (ndigits > 0) {
#line 141
    __cil_tmp___6 = b4tick;
#line 141
    b4tick --;
#line 141
    if (! __cil_tmp___6) {
#line 142
      qq --;
#line 143
      oo --;
#line 144
      ndigits --;
#line 145
      if (oo < n) {
#line 146
        *qq = (char )'_';
      }
#line 147
      b4tick = tickskip - 1;
    }
#line 149
    qq --;
#line 150
    oo --;
#line 151
    ndigits --;
#line 152
    if (oo < n) {
#line 153
      *qq = (char )*(digits + val % (unsigned long long )base);
    }
#line 154
    val /= (unsigned long long )base;
  }
#line 158
  while ((int )flags & 2 && width > nchars) {
#line 159
    if (o < n) {
#line 159
      __cil_tmp___7 = q;
#line 159
      q ++;
#line 159
      *__cil_tmp___7 = (char )' ';
    }
#line 159
    o ++;
#line 160
    width --;
  }
#line 163
  return (o);
}
}
#line 166
 __attribute__((__nothrow__)) int vsnprintf(char * __restrict  buffer , size_t___0 n ,
                                            char const   * __restrict  format , __gnuc_va_list ap ) ;
#line 166 "../../libc/vsnprintf.c"
int vsnprintf(char * __restrict  buffer , size_t___0 n , char const   * __restrict  format ,
              __gnuc_va_list ap ) 
{ char const   *p ;
  char ch ;
  char *q ;
  size_t___0 o ;
  uintmax_t val ;
  int rank ;
  int width ;
  int prec ;
  int base ;
  size_t___0 sz ;
  enum flags flags ;
  enum __anonenum_state_11 state___2 ;
  char const   *sarg ;
  char carg ;
  int slen ;
  char *__cil_tmp ;
  void *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  long __cil_tmp___4 ;
  long long __cil_tmp___5 ;
  unsigned int __cil_tmp___6 ;
  unsigned int __cil_tmp___7 ;
  unsigned int __cil_tmp___8 ;
  unsigned long __cil_tmp___9 ;
  unsigned long long __cil_tmp___10 ;
  size_t___0 __cil_tmp___11 ;
  int __cil_tmp___12 ;
  size_t___0 __cil_tmp___13 ;
  char sch ;
  int i ;
  char pad ;
  int __cil_tmp___14 ;
  char *__cil_tmp___15 ;
  char const   *__cil_tmp___16 ;
  char *__cil_tmp___17 ;
  char *__cil_tmp___18 ;
  signed char *__cil_tmp___19 ;
  short *__cil_tmp___20 ;
  int *__cil_tmp___21 ;
  long *__cil_tmp___22 ;
  long long *__cil_tmp___23 ;
  char *__cil_tmp___24 ;
  char const   *__cil_tmp___25 ;

  {
#line 171
  p = (char const   *)format;
#line 173
  q = (char *)buffer;
#line 174
  o = 0UL;
#line 175
  val = 0ULL;
#line 176
  rank = 0;
#line 177
  width = 0;
#line 178
  prec = -1;
#line 181
  flags = (enum flags )0;
#line 182
  state___2 = (enum __anonenum_state_11 )0;
#line 193
  while (1) {
#line 193
    __cil_tmp___25 = p;
#line 193
    p ++;
#line 193
    ch = (char )*__cil_tmp___25;
#line 193
    if (! ch) {
#line 193
      break;
    }
#line 194
    switch ((int )state___2) {
    case 0: 
#line 196
    if ((int )ch == 37) {
#line 197
      state___2 = (enum __anonenum_state_11 )1;
#line 198
      flags = (enum flags )0;
#line 199
      rank = 0;
#line 200
      width = 0;
#line 201
      prec = -1;
    } else {
#line 203
      if (o < n) {
#line 203
        __cil_tmp = q;
#line 203
        q ++;
#line 203
        *__cil_tmp = ch;
      }
#line 203
      o ++;
    }
#line 205
    break;
    case 1: 
#line 208
    switch ((int )ch) {
    case 45: 
#line 210
    flags = (enum flags )((int )flags | 2);
#line 211
    break;
    case 43: 
#line 213
    flags = (enum flags )((int )flags | 4);
#line 214
    break;
    case 39: 
#line 216
    flags = (enum flags )((int )flags | 8);
#line 217
    break;
    case 32: 
#line 219
    flags = (enum flags )((int )flags | 16);
#line 220
    break;
    case 35: 
#line 222
    flags = (enum flags )((int )flags | 32);
#line 223
    break;
    case 48: 
#line 225
    flags = (enum flags )((int )flags | 1);
#line 226
    break;
    default: 
#line 228
    state___2 = (enum __anonenum_state_11 )2;
#line 229
    p --;
#line 230
    break;
    }
#line 232
    break;
    case 2: 
#line 235
    if ((int )ch >= 48 && (int )ch <= 57) {
#line 236
      width = width * 10 + ((int )ch - 48);
    } else {
#line 237
      if ((int )ch == 42) {
#line 238
        width = __builtin_va_arg(ap, int );
#line 239
        if (width < 0) {
#line 240
          width = - width;
#line 241
          flags = (enum flags )((int )flags | 2);
        }
      } else {
#line 243
        if ((int )ch == 46) {
#line 244
          prec = 0;
#line 245
          state___2 = (enum __anonenum_state_11 )3;
        } else {
#line 247
          state___2 = (enum __anonenum_state_11 )4;
#line 248
          p --;
        }
      }
    }
#line 250
    break;
    case 3: 
#line 253
    if ((int )ch >= 48 && (int )ch <= 57) {
#line 254
      prec = prec * 10 + ((int )ch - 48);
    } else {
#line 255
      if ((int )ch == 42) {
#line 256
        prec = __builtin_va_arg(ap, int );
#line 257
        if (prec < 0) {
#line 258
          prec = -1;
        }
      } else {
#line 260
        state___2 = (enum __anonenum_state_11 )4;
#line 261
        p --;
      }
    }
#line 263
    break;
    case 4: 
#line 266
    switch ((int )ch) {
    case 104: 
#line 269
    rank --;
#line 270
    break;
    case 108: 
#line 272
    rank ++;
#line 273
    break;
    case 106: 
#line 275
    rank = 2;
#line 276
    break;
    case 122: 
#line 278
    rank = 1;
#line 279
    break;
    case 116: 
#line 281
    rank = 1;
#line 282
    break;
    case 76: 
    case 113: 
#line 285
    rank += 2;
#line 286
    break;
    default: 
#line 291
    state___2 = (enum __anonenum_state_11 )0;
#line 294
    if (rank < -2) {
#line 295
      rank = -2;
    } else {
#line 296
      if (rank > 2) {
#line 297
        rank = 2;
      }
    }
#line 299
    switch ((int )ch) {
    case 80: 
#line 301
    flags = (enum flags )((int )flags | 128);
    case 112: 
#line 304
    base = 16;
#line 305
    prec = (int )((8UL * sizeof(void *) + 3UL) / 4UL);
#line 306
    flags = (enum flags )((int )flags | 32);
#line 307
    __cil_tmp___0 = __builtin_va_arg(ap, void *);
#line 307
    val = (unsigned long long )((unsigned int )__cil_tmp___0);
#line 309
    goto is_integer;
    case 100: 
    case 105: 
#line 313
    base = 10;
#line 314
    flags = (enum flags )((int )flags | 64);
#line 315
    switch (rank) {
    case -2: 
#line 319
    __cil_tmp___1 = __builtin_va_arg(ap, int );
#line 319
    val = (unsigned long long )((long long )((signed char )__cil_tmp___1));
#line 322
    break;
    case -1: 
#line 324
    __cil_tmp___2 = __builtin_va_arg(ap, int );
#line 324
    val = (unsigned long long )((long long )((short )__cil_tmp___2));
#line 327
    break;
    case 0: 
#line 329
    __cil_tmp___3 = __builtin_va_arg(ap, int );
#line 329
    val = (unsigned long long )((long long )__cil_tmp___3);
#line 331
    break;
    case 1: 
#line 333
    __cil_tmp___4 = __builtin_va_arg(ap, long );
#line 333
    val = (unsigned long long )((long long )__cil_tmp___4);
#line 335
    break;
    case 2: 
#line 337
    __cil_tmp___5 = __builtin_va_arg(ap, long long );
#line 337
    val = (unsigned long long )__cil_tmp___5;
#line 340
    break;
    }
#line 342
    goto is_integer;
    case 111: 
#line 344
    base = 8;
#line 345
    goto is_unsigned;
    case 117: 
#line 347
    base = 10;
#line 348
    goto is_unsigned;
    case 88: 
#line 350
    flags = (enum flags )((int )flags | 128);
    case 120: 
#line 353
    base = 16;
#line 354
    goto is_unsigned;
    is_unsigned: 
#line 357
    switch (rank) {
    case -2: 
#line 359
    __cil_tmp___6 = __builtin_va_arg(ap, unsigned int );
#line 359
    val = (unsigned long long )((unsigned char )__cil_tmp___6);
#line 363
    break;
    case -1: 
#line 365
    __cil_tmp___7 = __builtin_va_arg(ap, unsigned int );
#line 365
    val = (unsigned long long )((unsigned short )__cil_tmp___7);
#line 369
    break;
    case 0: 
#line 371
    __cil_tmp___8 = __builtin_va_arg(ap, unsigned int );
#line 371
    val = (unsigned long long )__cil_tmp___8;
#line 374
    break;
    case 1: 
#line 376
    __cil_tmp___9 = __builtin_va_arg(ap, unsigned long );
#line 376
    val = (unsigned long long )__cil_tmp___9;
#line 379
    break;
    case 2: 
#line 381
    __cil_tmp___10 = __builtin_va_arg(ap, unsigned long long );
#line 381
    val = __cil_tmp___10;
#line 384
    break;
    }
    is_integer: 
#line 389
    if (o < n) {
#line 389
      __cil_tmp___11 = n - o;
    } else {
#line 389
      __cil_tmp___11 = 0UL;
    }
#line 389
    sz = format_int(q, __cil_tmp___11, val, flags, base, width, prec);
#line 392
    q += sz;
#line 393
    o += sz;
#line 394
    break;
    case 99: 
#line 397
    __cil_tmp___12 = __builtin_va_arg(ap, int );
#line 397
    carg = (char )__cil_tmp___12;
#line 398
    sarg = (char const   *)(& carg);
#line 399
    slen = 1;
#line 400
    goto is_string;
    case 115: 
#line 402
    sarg = __builtin_va_arg(ap, char const   *);
#line 403
    if (sarg) {
#line 403
      sarg = sarg;
    } else {
#line 403
      sarg = "(null)";
    }
#line 404
    __cil_tmp___13 = strlen(sarg);
#line 404
    slen = (int )__cil_tmp___13;
#line 405
    goto is_string;
    is_string: 
#line 412
    if (prec != -1 && slen > prec) {
#line 413
      slen = prec;
    }
#line 415
    if (width > slen && ! ((int )flags & 2)) {
#line 417
      if ((int )flags & 1) {
#line 417
        __cil_tmp___14 = '0';
      } else {
#line 417
        __cil_tmp___14 = ' ';
      }
#line 417
      pad = (char )__cil_tmp___14;
#line 420
      while (width > slen) {
#line 421
        if (o < n) {
#line 421
          __cil_tmp___15 = q;
#line 421
          q ++;
#line 421
          *__cil_tmp___15 = pad;
        }
#line 421
        o ++;
#line 422
        width --;
      }
    }
#line 425
    i = slen;
#line 425
    while (i) {
#line 426
      __cil_tmp___16 = sarg;
#line 426
      sarg ++;
#line 426
      sch = (char )*__cil_tmp___16;
#line 427
      if (o < n) {
#line 427
        __cil_tmp___17 = q;
#line 427
        q ++;
#line 427
        *__cil_tmp___17 = sch;
      }
#line 427
      o ++;
#line 425
      i --;
    }
#line 429
    if (width > slen && (int )flags & 2) {
#line 431
      while (width > slen) {
#line 432
        if (o < n) {
#line 432
          __cil_tmp___18 = q;
#line 432
          q ++;
#line 432
          *__cil_tmp___18 = (char )' ';
        }
#line 432
        o ++;
#line 433
        width --;
      }
    }
#line 437
    break;
    case 110: 
#line 444
    switch (rank) {
    case -2: 
#line 446
    __cil_tmp___19 = __builtin_va_arg(ap, signed char *);
#line 446
    *__cil_tmp___19 = (signed char )o;
#line 449
    break;
    case -1: 
#line 451
    __cil_tmp___20 = __builtin_va_arg(ap, short *);
#line 451
    *__cil_tmp___20 = (short )o;
#line 454
    break;
    case 0: 
#line 456
    __cil_tmp___21 = __builtin_va_arg(ap, int *);
#line 456
    *__cil_tmp___21 = (int )o;
#line 459
    break;
    case 1: 
#line 461
    __cil_tmp___22 = __builtin_va_arg(ap, long *);
#line 461
    *__cil_tmp___22 = (long )o;
#line 464
    break;
    case 2: 
#line 466
    __cil_tmp___23 = __builtin_va_arg(ap, long long *);
#line 466
    *__cil_tmp___23 = (long long )o;
#line 469
    break;
    }
#line 472
    break;
    default: ;
#line 475
    if (o < n) {
#line 475
      __cil_tmp___24 = q;
#line 475
      q ++;
#line 475
      *__cil_tmp___24 = ch;
    }
#line 475
    o ++;
#line 476
    break;
    }
    }
    }
  }
#line 483
  if (o < n) {
#line 484
    *q = (char )'\000';
  } else {
#line 485
    if (n > 0UL) {
#line 486
      *(buffer + (n - 1UL)) = (char )'\000';
    }
  }
#line 488
  return ((int )o);
}
}
#line 1 "cil-GmTVN02t.o"
#pragma merger(0,"/tmp/cil-7JPgafI8.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 346 "../../includes/usr/include/stdio.h"
 __attribute__((__nothrow__)) int vsprintf(char * __restrict  buffer , char const   * __restrict  format ,
                                           __gnuc_va_list ap ) ;
#line 9 "../../libc/vsprintf.c"
 __attribute__((__nothrow__)) int vsprintf(char * __restrict  buffer , char const   * __restrict  format ,
                                           __gnuc_va_list ap ) ;
#line 9 "../../libc/vsprintf.c"
int vsprintf(char * __restrict  buffer , char const   * __restrict  format , __gnuc_va_list ap ) 
{ int __cil_tmp ;

  {
#line 11
  __cil_tmp = vsnprintf(buffer, ~ 0UL, format, ap);
#line 11
  return (__cil_tmp);
}
}
#line 1 "cil-XKgL5bW5.o"
#pragma merger(0,"/tmp/cil-d7hKRlVc.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 27 "str.h"
void str_alloc_text(struct mystr *p_str , char const   *p_src ) ;
#line 13 "utility.h"
void die(char const   *p_text ) ;
#line 23
void die2(char const   *p_text1 , char const   *p_text2 ) ;
#line 32
void bug(char const   *p_text ) ;
#line 41
void vsf_exit(char const   *p_text ) ;
#line 6 "tunables.h"
int tunable_anonymous_enable ;
#line 7
int tunable_local_enable ;
#line 15
int tunable_chown_uploads ;
#line 16
int tunable_connect_from_port_20 ;
#line 23
int tunable_one_process_model ;
#line 26
int tunable_deny_email_enable ;
#line 28
int tunable_setproctitle_enable ;
#line 32
int tunable_guest_enable ;
#line 38
int tunable_listen ;
#line 42
int tunable_tcp_wrappers ;
#line 45
int tunable_listen_ipv6 ;
#line 54
int tunable_secure_email_list_enable ;
#line 55
int tunable_run_as_launching_user ;
#line 57
int tunable_ssl_enable ;
#line 69
int tunable_pasv_addr_resolve ;
#line 102
char const   *tunable_ftp_username ;
#line 103
char const   *tunable_chown_username ;
#line 109
char const   *tunable_banned_email_file ;
#line 112
char const   *tunable_guest_username ;
#line 116
char const   *tunable_banner_file ;
#line 117
char const   *tunable_pasv_address ;
#line 125
char const   *tunable_email_password_file ;
#line 32 "logging.h"
void vsf_log_init(struct vsf_session *p_sess ) ;
#line 22 "filestr.h"
int str_fileread(struct mystr *p_str , char const   *p_filename , unsigned int maxsize ) ;
#line 12 "ftpcmdio.h"
void vsf_cmdio_sock_setup(void) ;
#line 11 "sysutil.h"
int vsf_sysutil_retval_is_error(int retval ) ;
#line 42
void vsf_sysutil_install_null_sighandler(enum EVSFSysUtilSignal sig ) ;
#line 107
int vsf_sysutil_stat(char const   *p_name , struct vsf_sysutil_statbuf **p_ptr ) ;
#line 109
void vsf_sysutil_fstat(int fd , struct vsf_sysutil_statbuf **p_ptr ) ;
#line 114
int vsf_sysutil_statbuf_is_socket(struct vsf_sysutil_statbuf  const  *p_stat ) ;
#line 159
void vsf_sysutil_free(void *p_ptr ) ;
#line 182
char *vsf_sysutil_strdup(char const   *p_str ) ;
#line 189
int vsf_sysutil_strcmp(char const   *p_src1 , char const   *p_src2 ) ;
#line 243
void vsf_sysutil_getsockname(int fd , struct vsf_sysutil_sockaddr **p_sockptr ) ;
#line 244
void vsf_sysutil_getpeername(int fd , struct vsf_sysutil_sockaddr **p_sockptr ) ;
#line 250
void vsf_sysutil_dns_resolve(struct vsf_sysutil_sockaddr **p_sockptr , char const   *p_name ) ;
#line 269
char const   *vsf_sysutil_inet_ntop(struct vsf_sysutil_sockaddr  const  *p_sockptr ) ;
#line 280
struct vsf_sysutil_user *vsf_sysutil_getpwnam(char const   *p_user ) ;
#line 284
int vsf_sysutil_user_getuid(struct vsf_sysutil_user  const  *p_user ) ;
#line 294
void vsf_sysutil_set_umask(unsigned int new_umask ) ;
#line 295
void vsf_sysutil_make_session_leader(void) ;
#line 296
void vsf_sysutil_tzset(void) ;
#line 301
char *vsf_sysutil_getenv(char const   *p_var ) ;
#line 310
int vsf_sysutil_running_as_root(void) ;
#line 24 "sysdeputil.h"
int vsf_sysdep_has_capabilities_as_non_root(void) ;
#line 45
void vsf_sysutil_setproctitle_init(int argc , char const   **argv ) ;
#line 46
void vsf_sysutil_setproctitle(char const   *p_text ) ;
#line 48
void vsf_sysutil_set_proctitle_prefix(struct mystr  const  *p_str ) ;
#line 51
void vsf_sysutil_map_anon_pages_init(void) ;
#line 18 "parseconf.h"
void vsf_parseconf_load_file(char const   *p_filename , int errs_fatal ) ;
#line 14 "oneprocess.h"
void vsf_one_process_start(struct vsf_session *p_sess ) ;
#line 14 "twoprocess.h"
void vsf_two_process_start(struct vsf_session *p_sess ) ;
#line 20 "standalone.h"
struct vsf_client_launch vsf_standalone_main(void) ;
#line 4 "tcpwrap.h"
int vsf_tcp_wrapper_ok(int remote_fd ) ;
#line 12 "ssl.h"
void ssl_init(struct vsf_session *p_sess ) ;
#line 29 "main.c"
static void die_unless_privileged(void) ;
#line 30
static void do_sanity_checks(void) ;
#line 31
static void session_init(struct vsf_session *p_sess ) ;
#line 32
static void env_init(void) ;
#line 35
extern void symtest_initialize(void) ;
#line 38
extern void addfile(char const   *filename , char const   *contents , unsigned int len ) ;
#line 39 "main.c"
char confFileContents[191]  = 
#line 39
  {      (char )'c',      (char )'h',      (char )'o',      (char )'w', 
        (char )'n',      (char )'_',      (char )'u',      (char )'p', 
        (char )'l',      (char )'o',      (char )'a',      (char )'d', 
        (char )'_',      (char )'m',      (char )'o',      (char )'d', 
        (char )'e',      (char )'=',      (char )'0',      (char )'0', 
        (char )'6',      (char )'0',      (char )'0',      (char )'\n', 
        (char )'m',      (char )'a',      (char )'x',      (char )'_', 
        (char )'l',      (char )'o',      (char )'g',      (char )'i', 
        (char )'n',      (char )'_',      (char )'f',      (char )'a', 
        (char )'i',      (char )'l',      (char )'s',      (char )'=', 
        (char )'3',      (char )'\n',      (char )'\n',      (char )'a', 
        (char )'n',      (char )'o',      (char )'n',      (char )'y', 
        (char )'m',      (char )'o',      (char )'u',      (char )'s', 
        (char )'_',      (char )'e',      (char )'n',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'=', 
        (char )'1',      (char )'\n',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'_',      (char )'e', 
        (char )'n',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )'=',      (char )'T',      (char )'R', 
        (char )'U',      (char )'E',      (char )'\n',      (char )'p', 
        (char )'a',      (char )'s',      (char )'v',      (char )'_', 
        (char )'e',      (char )'n',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )'=',      (char )'Y', 
        (char )'E',      (char )'S',      (char )'\n',      (char )'l', 
        (char )'o',      (char )'c',      (char )'a',      (char )'l', 
        (char )'_',      (char )'e',      (char )'n',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'=', 
        (char )'0',      (char )'\n',      (char )'c',      (char )'h', 
        (char )'r',      (char )'o',      (char )'o',      (char )'t', 
        (char )'_',      (char )'l',      (char )'o',      (char )'c', 
        (char )'a',      (char )'l',      (char )'_',      (char )'u', 
        (char )'s',      (char )'e',      (char )'r',      (char )'=', 
        (char )'F',      (char )'A',      (char )'L',      (char )'S', 
        (char )'E',      (char )'\n',      (char )'w',      (char )'r', 
        (char )'i',      (char )'t',      (char )'e',      (char )'_', 
        (char )'e',      (char )'n',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )'=',      (char )'N', 
        (char )'O',      (char )'\n',      (char )'#',      (char )'\n', 
        (char )'p',      (char )'a',      (char )'m',      (char )'_', 
        (char )'s',      (char )'e',      (char )'r',      (char )'v', 
        (char )'i',      (char )'c',      (char )'e',      (char )'_', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )'=',      (char )'f',      (char )'t',      (char )'p', 
        (char )'\n',      (char )'l',      (char )'i',      (char )'s', 
        (char )'t',      (char )'e',      (char )'n',      (char )'_', 
        (char )'a',      (char )'d',      (char )'d',      (char )'r', 
        (char )'e',      (char )'s',      (char )'s',      (char )'6', 
        (char )'=',      (char )'\n',      (char )'\000'};
#line 40 "main.c"
unsigned int confFileSize  =    (unsigned int )(sizeof(confFileContents) - 1UL);
#line 42 "main.c"
int main(int argc , char const   **argv ) 
{ struct vsf_session the_session ;
  int config_specified ;
  char const   *p_config_name ;
  int __cil_tmp ;
  struct vsf_sysutil_statbuf *p_statbuf___0 ;
  int retval ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  struct vsf_sysutil_sockaddr *p_addr ;
  char const   *p_numeric_addr ;
  char *__cil_tmp___2 ;
  struct vsf_client_launch ret___0 ;
  struct vsf_client_launch __cil_tmp___3 ;
  char const   *p_load_conf ;
  char *__cil_tmp___4 ;
  char const   *__cil_tmp___5 ;
  int retval___0 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int retval___1 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int retval___2 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;

  {
#line 45
  addfile("/etc/vsftpd.conf", (char const   *)(confFileContents), confFileSize);
#line 46
  the_session.p_local_addr = (struct vsf_sysutil_sockaddr *)0;
#line 46
  the_session.p_remote_addr = (struct vsf_sysutil_sockaddr *)0;
#line 46
  the_session.p_control_line_buf = (char *)0;
#line 46
  the_session.pasv_listen_fd = -1;
#line 46
  the_session.p_port_sockaddr = (struct vsf_sysutil_sockaddr *)0;
#line 46
  the_session.data_fd = -1;
#line 46
  the_session.data_progress = 0;
#line 46
  the_session.bw_rate_max = 0U;
#line 46
  the_session.bw_send_start_sec = 0L;
#line 46
  the_session.bw_send_start_usec = 0L;
#line 46
  the_session.is_anonymous = 1;
#line 46
  the_session.is_guest = 0;
#line 46
  the_session.user_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.user_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.user_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.anon_pass_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.anon_pass_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.anon_pass_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.restart_pos = (filesize_t )0;
#line 46
  the_session.is_ascii = 1;
#line 46
  the_session.rnfr_filename_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.rnfr_filename_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.rnfr_filename_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.abor_received = 0;
#line 46
  the_session.epsv_all = 0;
#line 46
  the_session.p_visited_dir_list = (struct mystr_list *)0;
#line 46
  the_session.anon_ftp_uid = -1;
#line 46
  the_session.guest_user_uid = -1;
#line 46
  the_session.anon_upload_chown_uid = -1;
#line 46
  the_session.banned_email_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.banned_email_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.banned_email_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.email_passwords_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.email_passwords_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.email_passwords_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.userlist_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.userlist_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.userlist_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.banner_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.banner_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.banner_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.tcp_wrapper_ok = 1;
#line 46
  the_session.xferlog_fd = -1;
#line 46
  the_session.vsftpd_log_fd = -1;
#line 46
  the_session.remote_ip_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.remote_ip_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.remote_ip_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.log_type = 0UL;
#line 46
  the_session.log_start_sec = 0L;
#line 46
  the_session.log_start_usec = 0L;
#line 46
  the_session.log_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.log_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.log_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.transfer_size = (filesize_t )0;
#line 46
  the_session.ftp_cmd_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.ftp_cmd_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.ftp_cmd_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.ftp_arg_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.ftp_arg_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.ftp_arg_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.parent_fd = -1;
#line 46
  the_session.child_fd = -1;
#line 46
  the_session.num_clients = 0U;
#line 46
  the_session.num_this_ip = 0U;
#line 46
  the_session.home_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.home_str.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.home_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.control_use_ssl = 0;
#line 46
  the_session.data_use_ssl = 0;
#line 46
  the_session.p_ssl_ctx = (void *)0;
#line 46
  the_session.p_control_ssl = (void *)0;
#line 46
  the_session.p_data_ssl = (void *)0;
#line 46
  the_session.control_cert_digest.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 46
  the_session.control_cert_digest.PRIVATE_HANDS_OFF_len = 0U;
#line 46
  the_session.control_cert_digest.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 46
  the_session.ssl_slave_active = 0;
#line 46
  the_session.ssl_slave_fd = -1;
#line 46
  the_session.ssl_consumer_fd = -1;
#line 46
  the_session.login_fails = 0U;
#line 77
  config_specified = 0;
#line 78
  p_config_name = "/etc/vsftpd.conf";
#line 82
  if (argc > 2) {
#line 84
    die("vsftpd: too many arguments (I take an optional config file only)");
  } else {
#line 86
    if (argc == 0) {
#line 88
      die("vsftpd: missing argv[0]");
    }
  }
#line 90
  if (argc == 2) {
#line 92
    __cil_tmp = vsf_sysutil_strcmp(*(argv + 1), "-v");
#line 92
    if (! __cil_tmp) {
#line 94
      vsf_exit("vsftpd: version 2.0.7\n");
    }
#line 96
    p_config_name = *(argv + 1);
#line 97
    config_specified = 1;
  }
#line 103
  vsf_sysutil_map_anon_pages_init();
#line 106
  p_statbuf___0 = (struct vsf_sysutil_statbuf *)0;
#line 107
  __cil_tmp___0 = vsf_sysutil_stat(p_config_name, & p_statbuf___0);
#line 107
  retval = __cil_tmp___0;
#line 108
  __cil_tmp___1 = vsf_sysutil_retval_is_error(retval);
#line 108
  if (__cil_tmp___1) {
#line 112
    if (config_specified) {
#line 114
      die2("vsftpd: cannot open config file:", p_config_name);
    }
  } else {
#line 110
    vsf_parseconf_load_file(p_config_name, 1);
  }
#line 116
  vsf_sysutil_free((void *)p_statbuf___0);
#line 119
  symtest_initialize();
#line 122
  if ((int )tunable_pasv_address && tunable_pasv_addr_resolve) {
#line 124
    p_addr = (struct vsf_sysutil_sockaddr *)0;
#line 126
    vsf_sysutil_dns_resolve(& p_addr, tunable_pasv_address);
#line 127
    vsf_sysutil_free((void *)((char *)tunable_pasv_address));
#line 128
    p_numeric_addr = vsf_sysutil_inet_ntop((struct vsf_sysutil_sockaddr  const  *)p_addr);
#line 129
    __cil_tmp___2 = vsf_sysutil_strdup(p_numeric_addr);
#line 129
    tunable_pasv_address = (char const   *)__cil_tmp___2;
#line 130
    vsf_sysutil_free((void *)p_addr);
  }
#line 132
  if (! tunable_run_as_launching_user) {
#line 135
    die_unless_privileged();
  }
#line 137
  if (tunable_setproctitle_enable) {
#line 140
    vsf_sysutil_setproctitle_init(argc, argv);
  }
#line 145
  if (tunable_ssl_enable) {
#line 147
    ssl_init(& the_session);
  }
#line 149
  if (tunable_listen || tunable_listen_ipv6) {
#line 152
    __cil_tmp___3 = vsf_standalone_main();
#line 152
    ret___0 = __cil_tmp___3;
#line 153
    the_session.num_clients = ret___0.num_children;
#line 154
    the_session.num_this_ip = ret___0.num_this_ip;
  } else {
#line 156
    socket(0, 0, 0);
#line 156
    socket(0, 0, 0);
#line 156
    dup2(5, 0);
  }
#line 157
  if (tunable_tcp_wrappers) {
#line 159
    the_session.tcp_wrapper_ok = vsf_tcp_wrapper_ok(0);
  }
#line 162
  __cil_tmp___4 = vsf_sysutil_getenv("VSFTPD_LOAD_CONF");
#line 162
  p_load_conf = (char const   *)__cil_tmp___4;
#line 163
  if (p_load_conf) {
#line 165
    vsf_parseconf_load_file(p_load_conf, 1);
  }
#line 171
  do_sanity_checks();
#line 173
  session_init(& the_session);
#line 175
  env_init();
#line 179
  vsf_log_init(& the_session);
#line 180
  __cil_tmp___5 = vsf_sysutil_inet_ntop((struct vsf_sysutil_sockaddr  const  *)the_session.p_remote_addr);
#line 180
  str_alloc_text(& the_session.remote_ip_str, __cil_tmp___5);
#line 183
  vsf_cmdio_sock_setup();
#line 184
  if (tunable_setproctitle_enable) {
#line 186
    vsf_sysutil_set_proctitle_prefix((struct mystr  const  *)(& the_session.remote_ip_str));
#line 187
    vsf_sysutil_setproctitle("connected");
  }
#line 193
  if (tunable_ssl_enable) {
#line 195
    ssl_init(& the_session);
  }
#line 197
  if (tunable_deny_email_enable) {
#line 199
    __cil_tmp___6 = str_fileread(& the_session.banned_email_str, tunable_banned_email_file,
                                 100000U);
#line 199
    retval___0 = __cil_tmp___6;
#line 201
    __cil_tmp___7 = vsf_sysutil_retval_is_error(retval___0);
#line 201
    if (__cil_tmp___7) {
#line 203
      die2("cannot open anon e-mail list file:", tunable_banned_email_file);
    }
  }
#line 206
  if (tunable_banner_file) {
#line 208
    __cil_tmp___8 = str_fileread(& the_session.banner_str, tunable_banner_file, 100000U);
#line 208
    retval___1 = __cil_tmp___8;
#line 210
    __cil_tmp___9 = vsf_sysutil_retval_is_error(retval___1);
#line 210
    if (__cil_tmp___9) {
#line 212
      die2("cannot open banner file:", tunable_banner_file);
    }
  }
#line 215
  if (tunable_secure_email_list_enable) {
#line 217
    __cil_tmp___10 = str_fileread(& the_session.email_passwords_str, tunable_email_password_file,
                                  100000U);
#line 217
    retval___2 = __cil_tmp___10;
#line 220
    __cil_tmp___11 = vsf_sysutil_retval_is_error(retval___2);
#line 220
    if (__cil_tmp___11) {
#line 222
      die2("cannot open email passwords file:", tunable_email_password_file);
    }
  }
#line 228
  if ((! tunable_local_enable && ! tunable_connect_from_port_20) && ! tunable_chown_uploads) {
#line 231
    tunable_one_process_model = 1;
  }
#line 233
  if (tunable_run_as_launching_user) {
#line 235
    tunable_one_process_model = 1;
#line 236
    __cil_tmp___12 = vsf_sysutil_running_as_root();
#line 236
    if (! __cil_tmp___12) {
#line 238
      tunable_connect_from_port_20 = 0;
#line 239
      tunable_chown_uploads = 0;
    }
  }
#line 242
  if (tunable_one_process_model) {
#line 244
    vsf_one_process_start(& the_session);
  } else {
#line 248
    vsf_two_process_start(& the_session);
  }
#line 251
  bug("should not get here: main");
#line 252
  return (1);
}
}
#line 255 "main.c"
static void die_unless_privileged(void) 
{ int __cil_tmp ;

  {
#line 258
  __cil_tmp = vsf_sysutil_running_as_root();
#line 258
  if (! __cil_tmp) {
#line 260
    die("vsftpd: must be started as root (see run_as_launching_user option)");
  }
#line 262
  return;
}
}
#line 264 "main.c"
static void do_sanity_checks(void) 
{ struct vsf_sysutil_statbuf *p_statbuf___0 ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 268
  p_statbuf___0 = (struct vsf_sysutil_statbuf *)0;
#line 269
  vsf_sysutil_fstat(0, & p_statbuf___0);
#line 270
  __cil_tmp = vsf_sysutil_statbuf_is_socket((struct vsf_sysutil_statbuf  const  *)p_statbuf___0);
#line 270
  if (! __cil_tmp) {
#line 272
    die("vsftpd: not configured for standalone, must be started from inetd");
  }
#line 274
  vsf_sysutil_free((void *)p_statbuf___0);
#line 276
  if (tunable_one_process_model) {
#line 278
    if (tunable_local_enable) {
#line 280
      die("vsftpd: security: \'one_process_model\' is anonymous only");
    }
#line 282
    __cil_tmp___0 = vsf_sysdep_has_capabilities_as_non_root();
#line 282
    if (! __cil_tmp___0) {
#line 284
      die("vsftpd: security: \'one_process_model\' needs a better OS");
    }
#line 286
    if (tunable_ssl_enable) {
#line 288
      die("vsftpd: SSL mode not compatible with \'one_process_model\'");
    }
  }
#line 291
  if (! tunable_local_enable && ! tunable_anonymous_enable) {
#line 293
    die("vsftpd: both local and anonymous access disabled!");
  }
#line 295
  return;
}
}
#line 297 "main.c"
static void env_init(void) 
{ 

  {
#line 300
  vsf_sysutil_make_session_leader();
#line 302
  vsf_sysutil_set_umask(63U);
#line 304
  vsf_sysutil_tzset();
#line 306
  vsf_sysutil_install_null_sighandler(4);
#line 307
  return;
}
}
#line 309 "main.c"
static void session_init(struct vsf_session *p_sess ) 
{ struct vsf_sysutil_user  const  *p_user ;
  struct vsf_sysutil_user *__cil_tmp ;
  struct vsf_sysutil_user  const  *p_user___0 ;
  struct vsf_sysutil_user *__cil_tmp___0 ;
  struct vsf_sysutil_user  const  *p_user___1 ;
  struct vsf_sysutil_user *__cil_tmp___1 ;

  {
#line 313
  vsf_sysutil_getpeername(0, & p_sess->p_remote_addr);
#line 314
  vsf_sysutil_getsockname(0, & p_sess->p_local_addr);
#line 316
  if (tunable_anonymous_enable) {
#line 318
    __cil_tmp = vsf_sysutil_getpwnam(tunable_ftp_username);
#line 318
    p_user = (struct vsf_sysutil_user  const  *)__cil_tmp;
#line 320
    if ((unsigned int )p_user == (unsigned int )((struct vsf_sysutil_user  const  *)0)) {
#line 322
      die2("vsftpd: cannot locate user specified in \'ftp_username\':", tunable_ftp_username);
    }
#line 325
    p_sess->anon_ftp_uid = vsf_sysutil_user_getuid(p_user);
  }
#line 327
  if (tunable_guest_enable) {
#line 329
    __cil_tmp___0 = vsf_sysutil_getpwnam(tunable_guest_username);
#line 329
    p_user___0 = (struct vsf_sysutil_user  const  *)__cil_tmp___0;
#line 331
    if ((unsigned int )p_user___0 == (unsigned int )((struct vsf_sysutil_user  const  *)0)) {
#line 333
      die2("vsftpd: cannot locate user specified in \'guest_username\':", tunable_guest_username);
    }
#line 336
    p_sess->guest_user_uid = vsf_sysutil_user_getuid(p_user___0);
  }
#line 338
  if (tunable_chown_uploads) {
#line 340
    __cil_tmp___1 = vsf_sysutil_getpwnam(tunable_chown_username);
#line 340
    p_user___1 = (struct vsf_sysutil_user  const  *)__cil_tmp___1;
#line 342
    if ((unsigned int )p_user___1 == (unsigned int )((struct vsf_sysutil_user  const  *)0)) {
#line 344
      die2("vsftpd: cannot locate user specified in \'chown_username\':", tunable_chown_username);
    }
#line 347
    p_sess->anon_upload_chown_uid = vsf_sysutil_user_getuid(p_user___1);
  }
#line 349
  return;
}
}
#line 1 "cil-YvMUGsSC.o"
#pragma merger(0,"/tmp/cil-QbYuBV2F.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 104 "sysutil.h"
int vsf_sysutil_write_loop(int fd , void const   *p_buf , unsigned int size ) ;
#line 165
void vsf_sysutil_exit(int exit_code ) ;
#line 181
unsigned int vsf_sysutil_strlen(char const   *p_text ) ;
#line 261
void vsf_sysutil_activate_noblock(int fd ) ;
#line 41 "str.h"
char const   *str_getbuf(struct mystr  const  *p_str ) ;
#line 48
void str_append_text(struct mystr *p_str , char const   *p_src ) ;
#line 15 "utility.c"
void die(char const   *p_text ) 
{ 

  {
#line 19
  bug(p_text);
#line 21
  vsf_sysutil_exit(1);
#line 22
  return;
}
}
#line 24 "utility.c"
void die2(char const   *p_text1 , char const   *p_text2 ) 
{ struct mystr die_str ;
  char const   *__cil_tmp ;

  {
#line 27
  die_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 27
  die_str.PRIVATE_HANDS_OFF_len = 0U;
#line 27
  die_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 28
  str_alloc_text(& die_str, p_text1);
#line 29
  str_append_text(& die_str, p_text2);
#line 30
  __cil_tmp = str_getbuf((struct mystr  const  *)(& die_str));
#line 30
  die(__cil_tmp);
#line 31
  return;
}
}
#line 33 "utility.c"
void bug(char const   *p_text ) 
{ unsigned int __cil_tmp ;

  {
#line 37
  vsf_sysutil_activate_noblock(0);
#line 38
  vsf_sysutil_write_loop(0, (void const   *)"500 OOPS: ", 10U);
#line 39
  __cil_tmp = vsf_sysutil_strlen(p_text);
#line 39
  vsf_sysutil_write_loop(0, (void const   *)p_text, __cil_tmp);
#line 41
  vsf_sysutil_write_loop(0, (void const   *)"\r\n", 2U);
#line 42
  vsf_sysutil_exit(1);
#line 43
  return;
}
}
#line 45 "utility.c"
void vsf_exit(char const   *p_text ) 
{ unsigned int __cil_tmp ;

  {
#line 48
  __cil_tmp = vsf_sysutil_strlen(p_text);
#line 48
  vsf_sysutil_write_loop(0, (void const   *)p_text, __cil_tmp);
#line 50
  vsf_sysutil_exit(0);
#line 51
  return;
}
}
#line 1 "cil-PKhmz6BY.o"
#pragma merger(0,"/tmp/cil-aUQ01CRP.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 14 "prelogin.h"
void init_connection(struct vsf_session *p_sess ) ;
#line 22 "ftpcmdio.h"
void vsf_cmdio_write(struct vsf_session *p_sess , int status , char const   *p_text ) ;
#line 53
void vsf_cmdio_write_exit(struct vsf_session *p_sess , int status , char const   *p_text ) ;
#line 81
void vsf_cmdio_set_alarm(struct vsf_session *p_sess ) ;
#line 92
void vsf_cmdio_get_cmd_and_arg(struct vsf_session *p_sess , struct mystr *p_cmd_str ,
                               struct mystr *p_arg_str , int set_alarm ) ;
#line 32 "str.h"
void str_copy(struct mystr *p_dest , struct mystr  const  *p_src ) ;
#line 34
void str_empty(struct mystr *p_str ) ;
#line 35
void str_free(struct mystr *p_str ) ;
#line 39
int str_isempty(struct mystr  const  *p_str ) ;
#line 45
int str_equal_text(struct mystr  const  *p_str , char const   *p_text ) ;
#line 54
void str_upper(struct mystr *p_str ) ;
#line 120
int str_contains_line(struct mystr  const  *p_str , struct mystr  const  *p_line_str ) ;
#line 33 "tunables.h"
int tunable_userlist_enable ;
#line 34
int tunable_userlist_deny ;
#line 41
int tunable_no_anon_password ;
#line 58
int tunable_allow_anon_ssl ;
#line 59
int tunable_force_local_logins_ssl ;
#line 65
int tunable_force_anon_logins_ssl ;
#line 91
unsigned int tunable_max_clients ;
#line 93
unsigned int tunable_max_per_ip ;
#line 97
unsigned int tunable_max_login_fails ;
#line 108
char const   *tunable_ftpd_banner ;
#line 24 "oneprocess.h"
void vsf_one_process_login(struct vsf_session *p_sess , struct mystr  const  *p_pass_str ) ;
#line 23 "twoprocess.h"
void vsf_two_process_login(struct vsf_session *p_sess , struct mystr  const  *p_pass_str ) ;
#line 29 "banner.h"
void vsf_banner_write(struct vsf_session *p_sess , struct mystr *p_str , int ftpcode ) ;
#line 80 "logging.h"
void vsf_log_line(struct vsf_session *p_sess , enum EVSFLogEntryType what , struct mystr *p_str ) ;
#line 16 "ssl.h"
void handle_auth(struct vsf_session *p_sess ) ;
#line 17
void handle_pbsz(struct vsf_session *p_sess ) ;
#line 18
void handle_prot(struct vsf_session *p_sess ) ;
#line 6 "features.h"
void handle_feat(struct vsf_session *p_sess ) ;
#line 6 "opts.h"
void handle_opts(struct vsf_session *p_sess ) ;
#line 29 "prelogin.c"
static void emit_greeting(struct vsf_session *p_sess ) ;
#line 30
static void parse_username_password(struct vsf_session *p_sess ) ;
#line 31
static void handle_user_command(struct vsf_session *p_sess ) ;
#line 32
static void handle_pass_command(struct vsf_session *p_sess ) ;
#line 34 "prelogin.c"
void init_connection(struct vsf_session *p_sess ) 
{ 

  {
#line 37
  if (tunable_setproctitle_enable) {
#line 39
    vsf_sysutil_setproctitle("not logged in");
  }
#line 44
  vsf_cmdio_set_alarm(p_sess);
#line 45
  emit_greeting(p_sess);
#line 46
  parse_username_password(p_sess);
#line 47
  return;
}
}
#line 49 "prelogin.c"
static void emit_greeting(struct vsf_session *p_sess ) 
{ struct mystr str_log_line ;
  int __cil_tmp ;

  {
#line 52
  str_log_line.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 52
  str_log_line.PRIVATE_HANDS_OFF_len = 0U;
#line 52
  str_log_line.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 54
  if (tunable_max_clients > 0U && p_sess->num_clients > tunable_max_clients) {
#line 57
    str_alloc_text(& str_log_line, "Connection refused: too many sessions.");
#line 58
    vsf_log_line(p_sess, 8, & str_log_line);
#line 59
    vsf_cmdio_write_exit(p_sess, 421, "There are too many connected users, please try later.");
  }
#line 62
  if (tunable_max_per_ip > 0U && p_sess->num_this_ip > tunable_max_per_ip) {
#line 65
    str_alloc_text(& str_log_line, "Connection refused: too many sessions for this address.");
#line 67
    vsf_log_line(p_sess, 8, & str_log_line);
#line 68
    vsf_cmdio_write_exit(p_sess, 421, "There are too many connections from your internet address.");
  }
#line 71
  if (! p_sess->tcp_wrapper_ok) {
#line 73
    str_alloc_text(& str_log_line, "Connection refused: tcp_wrappers denial.");
#line 75
    vsf_log_line(p_sess, 8, & str_log_line);
#line 76
    vsf_cmdio_write_exit(p_sess, 421, "Service not available.");
  }
#line 78
  vsf_log_line(p_sess, 8, & str_log_line);
#line 79
  __cil_tmp = str_isempty((struct mystr  const  *)(& p_sess->banner_str));
#line 79
  if (__cil_tmp) {
#line 85
    if ((unsigned int )tunable_ftpd_banner == (unsigned int )((char const   *)0)) {
#line 87
      vsf_cmdio_write(p_sess, 220, "(vsFTPd 2.0.7)");
    } else {
#line 92
      vsf_cmdio_write(p_sess, 220, tunable_ftpd_banner);
    }
  } else {
#line 81
    vsf_banner_write(p_sess, & p_sess->banner_str, 220);
#line 82
    str_free(& p_sess->banner_str);
#line 83
    vsf_cmdio_write(p_sess, 220, "");
  }
#line 94
  return;
}
}
#line 96 "prelogin.c"
static void parse_username_password(struct vsf_session *p_sess ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;

  {
#line 99
  while (1) {
#line 101
    vsf_cmdio_get_cmd_and_arg(p_sess, & p_sess->ftp_cmd_str, & p_sess->ftp_arg_str,
                              1);
#line 103
    __cil_tmp___6 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                   "USER");
#line 103
    if (__cil_tmp___6) {
#line 105
      handle_user_command(p_sess);
    } else {
#line 107
      __cil_tmp___5 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                     "PASS");
#line 107
      if (__cil_tmp___5) {
#line 109
        handle_pass_command(p_sess);
      } else {
#line 111
        __cil_tmp___4 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                       "QUIT");
#line 111
        if (__cil_tmp___4) {
#line 113
          vsf_cmdio_write(p_sess, 221, "Goodbye.");
#line 114
          vsf_sysutil_exit(0);
        } else {
#line 116
          __cil_tmp___3 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                         "FEAT");
#line 116
          if (__cil_tmp___3) {
#line 118
            handle_feat(p_sess);
          } else {
#line 120
            __cil_tmp___2 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                           "OPTS");
#line 120
            if (__cil_tmp___2) {
#line 122
              handle_opts(p_sess);
            } else {
#line 124
              if (tunable_ssl_enable) {
#line 124
                __cil_tmp___1 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                               "AUTH");
#line 124
                if (__cil_tmp___1) {
#line 126
                  handle_auth(p_sess);
                } else {
#line 124
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
#line 128
                if (tunable_ssl_enable) {
#line 128
                  __cil_tmp___0 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                 "PBSZ");
#line 128
                  if (__cil_tmp___0) {
#line 130
                    handle_pbsz(p_sess);
                  } else {
#line 128
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ 
#line 132
                  if (tunable_ssl_enable) {
#line 132
                    __cil_tmp = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                               "PROT");
#line 132
                    if (__cil_tmp) {
#line 134
                      handle_prot(p_sess);
                    } else {
#line 132
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
#line 138
                    vsf_cmdio_write(p_sess, 530, "Please login with USER and PASS.");
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
#line 144 "prelogin.c"
static void handle_user_command(struct vsf_session *p_sess ) 
{ int is_anon ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int located ;
  int __cil_tmp___1 ;

  {
#line 151
  is_anon = 1;
#line 152
  str_copy(& p_sess->user_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 153
  str_upper(& p_sess->ftp_arg_str);
#line 154
  __cil_tmp = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str), "FTP");
#line 154
  if (__cil_tmp) {
    _L: /* CIL Label */ ;
  } else {
#line 154
    __cil_tmp___0 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                   "ANONYMOUS");
#line 154
    if (__cil_tmp___0) {
#line 154
      goto _L;
    } else {
#line 157
      is_anon = 0;
    }
  }
#line 159
  if (! tunable_local_enable && ! is_anon) {
#line 161
    vsf_cmdio_write(p_sess, 530, "This FTP server is anonymous only.");
#line 163
    str_empty(& p_sess->user_str);
#line 164
    return;
  }
#line 166
  if (((is_anon && p_sess->control_use_ssl) && ! tunable_allow_anon_ssl) && ! tunable_force_anon_logins_ssl) {
#line 169
    vsf_cmdio_write(p_sess, 530, "Anonymous sessions may not use encryption.");
#line 171
    str_empty(& p_sess->user_str);
#line 172
    return;
  }
#line 174
  if (((tunable_ssl_enable && ! is_anon) && ! p_sess->control_use_ssl) && tunable_force_local_logins_ssl) {
#line 177
    vsf_cmdio_write(p_sess, 530, "Non-anonymous sessions must use encryption.");
#line 179
    str_empty(& p_sess->user_str);
#line 180
    return;
  }
#line 182
  if (((tunable_ssl_enable && is_anon) && ! p_sess->control_use_ssl) && tunable_force_anon_logins_ssl) {
#line 185
    vsf_cmdio_write(p_sess, 530, "Anonymous sessions must use encryption.");
#line 187
    str_empty(& p_sess->user_str);
#line 188
    return;
  }
#line 190
  if (tunable_userlist_enable) {
#line 192
    __cil_tmp___1 = str_contains_line((struct mystr  const  *)(& p_sess->userlist_str),
                                      (struct mystr  const  *)(& p_sess->user_str));
#line 192
    located = __cil_tmp___1;
#line 193
    if ((located && tunable_userlist_deny) || (! located && ! tunable_userlist_deny)) {
#line 196
      vsf_cmdio_write(p_sess, 530, "Permission denied.");
#line 197
      str_empty(& p_sess->user_str);
#line 198
      return;
    }
  }
#line 201
  if (is_anon && tunable_no_anon_password) {
#line 204
    str_alloc_text(& p_sess->ftp_arg_str, "<no password>");
#line 205
    handle_pass_command(p_sess);
  } else {
#line 209
    vsf_cmdio_write(p_sess, 331, "Please specify the password.");
  }
#line 211
  return;
}
}
#line 213 "prelogin.c"
static void handle_pass_command(struct vsf_session *p_sess ) 
{ int __cil_tmp ;

  {
#line 216
  __cil_tmp = str_isempty((struct mystr  const  *)(& p_sess->user_str));
#line 216
  if (__cil_tmp) {
#line 218
    vsf_cmdio_write(p_sess, 503, "Login with USER first.");
#line 219
    return;
  }
#line 222
  if (tunable_one_process_model) {
#line 224
    vsf_one_process_login(p_sess, (struct mystr  const  *)(& p_sess->ftp_arg_str));
  } else {
#line 228
    vsf_two_process_login(p_sess, (struct mystr  const  *)(& p_sess->ftp_arg_str));
  }
#line 230
  vsf_cmdio_write(p_sess, 530, "Login incorrect.");
#line 231
  (p_sess->login_fails) ++;
#line 231
  if (p_sess->login_fails >= tunable_max_login_fails) {
#line 233
    vsf_sysutil_exit(0);
  }
#line 235
  str_empty(& p_sess->user_str);
#line 237
  return;
}
}
#line 1 "cil-fuhOuRqF.o"
#pragma merger(0,"/tmp/cil-N08gwDjq.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 34 "ftpcmdio.h"
void vsf_cmdio_write_hyphen(struct vsf_session *p_sess , int status , char const   *p_text ) ;
#line 46
void vsf_cmdio_write_raw(struct vsf_session *p_sess , char const   *p_text ) ;
#line 61
void vsf_cmdio_write_str(struct vsf_session *p_sess , int status , struct mystr  const  *p_str ) ;
#line 70
void vsf_cmdio_write_str_hyphen(struct vsf_session *p_sess , int status , struct mystr  const  *p_str ) ;
#line 30 "str.h"
void str_alloc_ulong(struct mystr *p_str , unsigned long the_long ) ;
#line 36
void str_trunc(struct mystr *p_str , unsigned int trunc_len ) ;
#line 40
unsigned int str_getlen(struct mystr  const  *p_str ) ;
#line 47
void str_append_str(struct mystr *p_str , struct mystr  const  *p_other ) ;
#line 51
void str_append_char(struct mystr *p_str , char the_char ) ;
#line 57
void str_replace_char(struct mystr *p_str , char from , char to ) ;
#line 58
void str_replace_text(struct mystr *p_str , char const   *p_from , char const   *p_to ) ;
#line 61
void str_split_char(struct mystr *p_src , struct mystr *p_rhs , char c ) ;
#line 95
char str_get_char_at(struct mystr  const  *p_str , unsigned int indexx ) ;
#line 43 "sysutil.h"
void vsf_sysutil_install_sighandler(enum EVSFSysUtilSignal sig , void (*handler)(void * ) ,
                                    void *p_private ) ;
#line 56
void vsf_sysutil_set_alarm(unsigned int trigger_seconds ) ;
#line 253
void vsf_sysutil_activate_keepalive(int fd ) ;
#line 256
void vsf_sysutil_set_nodelay(int fd ) ;
#line 258
void vsf_sysutil_activate_oobinline(int fd ) ;
#line 262
void vsf_sysutil_deactivate_noblock(int fd ) ;
#line 266
void vsf_sysutil_shutdown_read_failok(int fd ) ;
#line 31 "tunables.h"
int tunable_log_ftp_protocol ;
#line 84
unsigned int tunable_idle_session_timeout ;
#line 15 "secbuf.h"
void vsf_secbuf_alloc(char **p_ptr , unsigned int size ) ;
#line 13 "readwrite.h"
int ftp_write_str(struct vsf_session  const  *p_sess , struct mystr  const  *p_str ,
                  enum EVSFRWTarget target ) ;
#line 18
void ftp_getline(struct vsf_session  const  *p_sess , struct mystr *p_str , char *p_buf ) ;
#line 24 "ftpcmdio.c"
static void control_getline(struct mystr *p_str , struct vsf_session *p_sess ) ;
#line 25
static void ftp_write_text_common(struct vsf_session *p_sess , int status , char const   *p_text ,
                                  int noblock , char sep ) ;
#line 27
static void ftp_write_str_common(struct vsf_session *p_sess , int status , char sep ,
                                 struct mystr  const  *p_str , int noblock ) ;
#line 30
static void handle_alarm_timeout(void *p_private ) ;
#line 32 "ftpcmdio.c"
void vsf_cmdio_sock_setup(void) 
{ 

  {
#line 35
  vsf_sysutil_activate_keepalive(0);
#line 36
  vsf_sysutil_set_nodelay(0);
#line 37
  vsf_sysutil_activate_oobinline(0);
#line 38
  return;
}
}
#line 40 "ftpcmdio.c"
static void handle_alarm_timeout(void *p_private ) 
{ struct vsf_session *p_sess ;

  {
#line 43
  p_sess = (struct vsf_session *)p_private;
#line 44
  vsf_cmdio_write_exit(p_sess, 421, "Timeout.");
#line 45
  return;
}
}
#line 47 "ftpcmdio.c"
void vsf_cmdio_write(struct vsf_session *p_sess , int status , char const   *p_text ) 
{ 

  {
#line 50
  ftp_write_text_common(p_sess, status, p_text, 0, (char )' ');
#line 51
  return;
}
}
#line 53 "ftpcmdio.c"
void vsf_cmdio_write_hyphen(struct vsf_session *p_sess , int status , char const   *p_text ) 
{ 

  {
#line 57
  ftp_write_text_common(p_sess, status, p_text, 0, (char )'-');
#line 58
  return;
}
}
#line 63 "ftpcmdio.c"
static struct mystr s_the_str  ;
#line 60 "ftpcmdio.c"
void vsf_cmdio_write_raw(struct vsf_session *p_sess , char const   *p_text ) 
{ int retval ;

  {
#line 65
  str_alloc_text(& s_the_str, p_text);
#line 66
  if (tunable_log_ftp_protocol) {
#line 68
    vsf_log_line(p_sess, 7, & s_the_str);
  }
#line 70
  retval = ftp_write_str((struct vsf_session  const  *)p_sess, (struct mystr  const  *)(& s_the_str),
                         1);
#line 71
  if (retval != 0) {
#line 73
    die("ftp_write_str");
  }
#line 75
  return;
}
}
#line 77 "ftpcmdio.c"
void vsf_cmdio_write_exit(struct vsf_session *p_sess , int status , char const   *p_text ) 
{ 

  {
#line 84
  vsf_sysutil_shutdown_read_failok(0);
#line 85
  ftp_write_text_common(p_sess, status, p_text, 1, (char )' ');
#line 86
  vsf_sysutil_exit(0);
#line 87
  return;
}
}
#line 94 "ftpcmdio.c"
struct mystr s_the_str___0  ;
//static struct mystr s_the_str___0  ;
#line 89 "ftpcmdio.c"
static void ftp_write_text_common(struct vsf_session *p_sess , int status , char const   *p_text ,
                                  int noblock , char sep ) 
{ 

  {
#line 95
  str_alloc_text(& s_the_str___0, p_text);
#line 96
  ftp_write_str_common(p_sess, status, sep, (struct mystr  const  *)(& s_the_str___0),
                       noblock);
#line 97
  return;
}
}
#line 99 "ftpcmdio.c"
void vsf_cmdio_write_str_hyphen(struct vsf_session *p_sess , int status , struct mystr  const  *p_str ) 
{ 

  {
#line 103
  ftp_write_str_common(p_sess, status, (char )'-', p_str, 0);
#line 104
  return;
}
}
#line 106 "ftpcmdio.c"
void vsf_cmdio_write_str(struct vsf_session *p_sess , int status , struct mystr  const  *p_str ) 
{ 

  {
#line 110
  ftp_write_str_common(p_sess, status, (char )' ', p_str, 0);
#line 111
  return;
}
}
#line 117 "ftpcmdio.c"
struct mystr s_write_buf_str  ;
//static struct mystr s_write_buf_str  ;
#line 118 "ftpcmdio.c"
struct mystr s_text_mangle_str  ;
//static struct mystr s_text_mangle_str  ;
#line 113 "ftpcmdio.c"
static void ftp_write_str_common(struct vsf_session *p_sess , int status , char sep ,
                                 struct mystr  const  *p_str , int noblock ) 
{ int retval ;

  {
#line 120
  if (tunable_log_ftp_protocol) {
#line 122
    str_alloc_ulong(& s_write_buf_str, (unsigned long )status);
#line 123
    str_append_char(& s_write_buf_str, sep);
#line 124
    str_append_str(& s_write_buf_str, p_str);
#line 125
    vsf_log_line(p_sess, 7, & s_write_buf_str);
  }
#line 127
  str_copy(& s_text_mangle_str, p_str);
#line 130
  str_replace_text(& s_text_mangle_str, "\377", "\377\377");
#line 132
  str_replace_char(& s_text_mangle_str, (char )'\n', (char )'\000');
#line 134
  str_alloc_ulong(& s_write_buf_str, (unsigned long )status);
#line 135
  str_append_char(& s_write_buf_str, sep);
#line 136
  str_append_str(& s_write_buf_str, (struct mystr  const  *)(& s_text_mangle_str));
#line 137
  str_append_text(& s_write_buf_str, "\r\n");
#line 138
  if (noblock) {
#line 140
    vsf_sysutil_activate_noblock(0);
  }
#line 142
  retval = ftp_write_str((struct vsf_session  const  *)p_sess, (struct mystr  const  *)(& s_write_buf_str),
                         1);
#line 143
  if (retval != 0 && ! noblock) {
#line 145
    die("ftp_write");
  }
#line 147
  if (noblock) {
#line 149
    vsf_sysutil_deactivate_noblock(0);
  }
#line 151
  return;
}
}
#line 153 "ftpcmdio.c"
void vsf_cmdio_set_alarm(struct vsf_session *p_sess ) 
{ 

  {
#line 156
  if (tunable_idle_session_timeout > 0U) {
#line 158
    vsf_sysutil_install_sighandler(1, & handle_alarm_timeout, (void *)p_sess);
#line 160
    vsf_sysutil_set_alarm(tunable_idle_session_timeout);
  }
#line 162
  return;
}
}
#line 179 "ftpcmdio.c"
static struct mystr s_log_str  ;
#line 164 "ftpcmdio.c"
void vsf_cmdio_get_cmd_and_arg(struct vsf_session *p_sess , struct mystr *p_cmd_str ,
                               struct mystr *p_arg_str , int set_alarm ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 169
  if (set_alarm) {
#line 171
    vsf_cmdio_set_alarm(p_sess);
  }
#line 174
  control_getline(p_cmd_str, p_sess);
#line 175
  str_split_char(p_cmd_str, p_arg_str, (char )' ');
#line 176
  str_upper(p_cmd_str);
#line 177
  if (tunable_log_ftp_protocol) {
#line 180
    __cil_tmp___0 = str_equal_text((struct mystr  const  *)p_cmd_str, "PASS");
#line 180
    if (__cil_tmp___0) {
#line 182
      str_alloc_text(& s_log_str, "PASS <password>");
    } else {
#line 186
      str_copy(& s_log_str, (struct mystr  const  *)p_cmd_str);
#line 187
      __cil_tmp = str_isempty((struct mystr  const  *)p_arg_str);
#line 187
      if (! __cil_tmp) {
#line 189
        str_append_char(& s_log_str, (char )' ');
#line 190
        str_append_str(& s_log_str, (struct mystr  const  *)p_arg_str);
      }
    }
#line 193
    vsf_log_line(p_sess, 6, & s_log_str);
  }
#line 195
  return;
}
}
#line 197 "ftpcmdio.c"
static void control_getline(struct mystr *p_str , struct vsf_session *p_sess ) 
{ unsigned int len ;
  unsigned int __cil_tmp ;
  char __cil_tmp___0 ;

  {
#line 200
  if ((unsigned int )p_sess->p_control_line_buf == (unsigned int )((char *)0)) {
#line 202
    vsf_secbuf_alloc(& p_sess->p_control_line_buf, 4096U);
  }
#line 204
  ftp_getline((struct vsf_session  const  *)p_sess, p_str, p_sess->p_control_line_buf);
#line 206
  str_replace_char(p_str, (char )'\000', (char )'\n');
#line 209
  __cil_tmp = str_getlen((struct mystr  const  *)p_str);
#line 209
  len = __cil_tmp;
#line 210
  while (1) {
#line 210
    if (len > 0U) {
#line 210
      __cil_tmp___0 = str_get_char_at((struct mystr  const  *)p_str, len - 1U);
#line 210
      if (! ((int )__cil_tmp___0 == 13)) {
#line 210
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 210
      break;
    }
#line 212
    str_trunc(p_str, len - 1U);
#line 213
    len --;
  }
#line 216
  return;
}
}
#line 1 "cil-WkAmwLLJ.o"
#pragma merger(0,"/tmp/cil-30XeHHq0.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 12 "postlogin.h"
void process_post_login(struct vsf_session *p_sess ) ;
#line 31 "str.h"
void str_alloc_filesize_t(struct mystr *p_str , filesize_t the_filesize ) ;
#line 44
int str_equal(struct mystr  const  *p_str1 , struct mystr  const  *p_str2 ) ;
#line 49
void str_append_ulong(struct mystr *p_str , unsigned long the_ulong ) ;
#line 50
void str_append_filesize_t(struct mystr *p_str , filesize_t the_filesize ) ;
#line 62
void str_split_char_reverse(struct mystr *p_src , struct mystr *p_rhs , char c ) ;
#line 75
struct str_locate_result str_locate_char(struct mystr  const  *p_str , char look_char ) ;
#line 90
void str_right(struct mystr  const  *p_str , struct mystr *p_out , unsigned int chars ) ;
#line 92
void str_mid_to_end(struct mystr  const  *p_str , struct mystr *p_out , unsigned int indexx ) ;
#line 98
void str_replace_unprintable(struct mystr *p_str , char new_char ) ;
#line 99
int str_atoi(struct mystr  const  *p_str ) ;
#line 100
filesize_t str_a_to_filesize_t(struct mystr  const  *p_str ) ;
#line 101
unsigned int str_octal_to_uint(struct mystr  const  *p_str ) ;
#line 44 "oneprocess.h"
void vsf_one_process_chown_upload(struct vsf_session *p_sess , int fd ) ;
#line 43 "twoprocess.h"
void vsf_two_process_chown_upload(struct vsf_session *p_sess , int fd ) ;
#line 22 "ftpdataio.h"
int vsf_ftpdataio_dispose_transfer_fd(struct vsf_session *p_sess ) ;
#line 33
int vsf_ftpdataio_get_pasv_fd(struct vsf_session *p_sess ) ;
#line 44
int vsf_ftpdataio_get_port_fd(struct vsf_session *p_sess ) ;
#line 55
int vsf_ftpdataio_post_mark_connect(struct vsf_session *p_sess ) ;
#line 77
struct vsf_transfer_ret vsf_ftpdataio_transfer_file(struct vsf_session *p_sess , int remote_fd ,
                                                    int file_fd , int is_recv , int is_ascii ) ;
#line 94
int vsf_ftpdataio_transfer_dir(struct vsf_session *p_sess , int is_control , struct vsf_sysutil_dir *p_dir ,
                               struct mystr  const  *p_base_dir_str , struct mystr  const  *p_option_str ,
                               struct mystr  const  *p_filter_str , int is_verbose ) ;
#line 8 "tunables.h"
int tunable_pasv_enable ;
#line 9
int tunable_port_enable ;
#line 11
int tunable_write_enable ;
#line 12
int tunable_anon_upload_enable ;
#line 13
int tunable_anon_mkdir_write_enable ;
#line 14
int tunable_anon_other_write_enable ;
#line 19
int tunable_anon_world_readable_only ;
#line 20
int tunable_async_abor_enable ;
#line 21
int tunable_ascii_upload_enable ;
#line 22
int tunable_ascii_download_enable ;
#line 35
int tunable_use_localtime ;
#line 39
int tunable_port_promiscuous ;
#line 51
int tunable_download_enable ;
#line 52
int tunable_dirlist_enable ;
#line 53
int tunable_chmod_enable ;
#line 60
int tunable_force_local_data_ssl ;
#line 64
int tunable_tilde_user_enable ;
#line 66
int tunable_force_anon_data_ssl ;
#line 67
int tunable_mdtm_write ;
#line 68
int tunable_lock_upload_files ;
#line 76
int tunable_delete_failed_uploads ;
#line 81
unsigned int tunable_local_umask ;
#line 82
unsigned int tunable_anon_umask ;
#line 86
unsigned int tunable_pasv_min_port ;
#line 87
unsigned int tunable_pasv_max_port ;
#line 88
unsigned int tunable_anon_max_rate ;
#line 89
unsigned int tunable_local_max_rate ;
#line 98
unsigned int tunable_chown_upload_mode ;
#line 121
char const   *tunable_cmds_allowed ;
#line 10 "sysstr.h"
void str_getcwd(struct mystr *p_str ) ;
#line 14
int str_mkdir(struct mystr  const  *p_str , unsigned int mode ) ;
#line 15
int str_rmdir(struct mystr  const  *p_str ) ;
#line 16
int str_unlink(struct mystr  const  *p_str ) ;
#line 17
int str_chdir(struct mystr  const  *p_str ) ;
#line 23
int str_open(struct mystr  const  *p_str , enum EVSFSysStrOpenMode mode ) ;
#line 24
int str_create_append(struct mystr  const  *p_str ) ;
#line 25
int str_create(struct mystr  const  *p_str ) ;
#line 26
int str_create_overwrite(struct mystr  const  *p_str ) ;
#line 27
int str_chmod(struct mystr  const  *p_str , unsigned int mode ) ;
#line 28
int str_stat(struct mystr  const  *p_str , struct vsf_sysutil_statbuf **p_ptr ) ;
#line 30
int str_rename(struct mystr  const  *p_from_str , struct mystr  const  *p_to_str ) ;
#line 31
struct vsf_sysutil_dir *str_opendir(struct mystr  const  *p_str ) ;
#line 35
struct vsf_sysutil_user *str_getpwnam(struct mystr  const  *p_user_str ) ;
#line 18 "banner.h"
void vsf_banner_dir_changed(struct vsf_session *p_sess , int ftpcode ) ;
#line 21 "sysutil.h"
enum EVSFSysUtilError vsf_sysutil_get_error(void) ;
#line 68
void vsf_sysutil_closedir(struct vsf_sysutil_dir *p_dir ) ;
#line 89
void vsf_sysutil_close(int fd ) ;
#line 95
void vsf_sysutil_lseek_to(int fd , filesize_t seek_pos ) ;
#line 110
void vsf_sysutil_dir_stat(struct vsf_sysutil_dir  const  *p_dir , struct vsf_sysutil_statbuf **p_ptr ) ;
#line 112
int vsf_sysutil_statbuf_is_regfile(struct vsf_sysutil_statbuf  const  *p_stat ) ;
#line 115
int vsf_sysutil_statbuf_is_dir(struct vsf_sysutil_statbuf  const  *p_stat ) ;
#line 116
filesize_t vsf_sysutil_statbuf_get_size(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) ;
#line 122
char const   *vsf_sysutil_statbuf_get_numeric_date(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ,
                                                   int use_localtime ) ;
#line 128
int vsf_sysutil_statbuf_is_readable_other(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) ;
#line 135
void vsf_sysutil_fchmod(int fd , unsigned int mode ) ;
#line 142
int vsf_sysutil_lock_file_write(int fd ) ;
#line 143
int vsf_sysutil_lock_file_read(int fd ) ;
#line 190
int vsf_sysutil_atoi(char const   *p_str ) ;
#line 192
char const   *vsf_sysutil_ulong_to_str(unsigned long the_ulong ) ;
#line 195
char const   *vsf_sysutil_uint_to_octal(unsigned int the_uint ) ;
#line 201
int vsf_sysutil_isdigit(int the_char ) ;
#line 211
void vsf_sysutil_sockaddr_clear(struct vsf_sysutil_sockaddr **p_sockptr ) ;
#line 214
void vsf_sysutil_sockaddr_clone(struct vsf_sysutil_sockaddr **p_sockptr , struct vsf_sysutil_sockaddr  const  *p_src ) ;
#line 217
int vsf_sysutil_sockaddr_addr_equal(struct vsf_sysutil_sockaddr  const  *p1 , struct vsf_sysutil_sockaddr  const  *p2 ) ;
#line 219
int vsf_sysutil_sockaddr_is_ipv6(struct vsf_sysutil_sockaddr  const  *p_sockaddr___0 ) ;
#line 221
void vsf_sysutil_sockaddr_set_ipv4addr(struct vsf_sysutil_sockaddr *p_sockptr , unsigned char const   *p_raw ) ;
#line 223
void vsf_sysutil_sockaddr_set_ipv6addr(struct vsf_sysutil_sockaddr *p_sockptr , unsigned char const   *p_raw ) ;
#line 226
void vsf_sysutil_sockaddr_set_port(struct vsf_sysutil_sockaddr *p_sockptr , unsigned short the_port ) ;
#line 228
int vsf_sysutil_is_port_reserved(unsigned short the_port ) ;
#line 233
void const   *vsf_sysutil_sockaddr_ipv6_v4(struct vsf_sysutil_sockaddr  const  *p_addr ) ;
#line 237
int vsf_sysutil_get_ipv4_sock(void) ;
#line 238
int vsf_sysutil_get_ipv6_sock(void) ;
#line 241
int vsf_sysutil_bind(int fd , struct vsf_sysutil_sockaddr  const  *p_sockptr ) ;
#line 242
int vsf_sysutil_listen(int fd , unsigned int backlog ) ;
#line 255
void vsf_sysutil_activate_reuseaddr(int fd ) ;
#line 257
void vsf_sysutil_activate_sigurg(int fd ) ;
#line 264
void vsf_sysutil_shutdown_failok(int fd ) ;
#line 271
char const   *vsf_sysutil_inet_ntoa(void const   *p_raw_addr ) ;
#line 272
int vsf_sysutil_inet_aton(char const   *p_text , struct vsf_sysutil_sockaddr *p_addr ) ;
#line 282
char const   *vsf_sysutil_user_get_homedir(struct vsf_sysutil_user  const  *p_user ) ;
#line 292
unsigned char vsf_sysutil_get_random_byte(void) ;
#line 293
unsigned int vsf_sysutil_get_umask(void) ;
#line 329
long vsf_sysutil_parse_time(char const   *p_text ) ;
#line 331
int vsf_sysutil_setmodtime(char const   *p_file , long the_time , int is_localtime ) ;
#line 42 "logging.h"
void vsf_log_start_entry(struct vsf_session *p_sess , enum EVSFLogEntryType what ) ;
#line 51
int vsf_log_entry_pending(struct vsf_session *p_sess ) ;
#line 57
void vsf_log_clear_entry(struct vsf_session *p_sess ) ;
#line 67
void vsf_log_do_log(struct vsf_session *p_sess , int succeeded ) ;
#line 47 "sysdeputil.h"
void vsf_sysutil_setproctitle_str(struct mystr  const  *p_str ) ;
#line 11 "ipaddrparse.h"
unsigned char const   *vsf_sysutil_parse_ipv6(struct mystr  const  *p_str ) ;
#line 13
unsigned char const   *vsf_sysutil_parse_ipv4(struct mystr  const  *p_str ) ;
#line 15
unsigned char const   *vsf_sysutil_parse_uchar_string_sep(struct mystr  const  *p_str ,
                                                          char sep , unsigned char *p_items ,
                                                          unsigned int items___0 ) ;
#line 15 "access.h"
int vsf_access_check_file(struct mystr  const  *p_filename_str ) ;
#line 32 "postlogin.c"
static void handle_pwd(struct vsf_session *p_sess ) ;
#line 33
static void handle_cwd(struct vsf_session *p_sess ) ;
#line 34
static void handle_pasv(struct vsf_session *p_sess , int is_epsv ) ;
#line 35
static void handle_retr(struct vsf_session *p_sess ) ;
#line 36
static void handle_cdup(struct vsf_session *p_sess ) ;
#line 37
static void handle_list(struct vsf_session *p_sess ) ;
#line 38
static void handle_type(struct vsf_session *p_sess ) ;
#line 39
static void handle_port(struct vsf_session *p_sess ) ;
#line 40
static void handle_stor(struct vsf_session *p_sess ) ;
#line 41
static void handle_mkd(struct vsf_session *p_sess ) ;
#line 42
static void handle_rmd(struct vsf_session *p_sess ) ;
#line 43
static void handle_dele(struct vsf_session *p_sess ) ;
#line 44
static void handle_rest(struct vsf_session *p_sess ) ;
#line 45
static void handle_rnfr(struct vsf_session *p_sess ) ;
#line 46
static void handle_rnto(struct vsf_session *p_sess ) ;
#line 47
static void handle_nlst(struct vsf_session *p_sess ) ;
#line 48
static void handle_size(struct vsf_session *p_sess ) ;
#line 49
static void handle_site(struct vsf_session *p_sess ) ;
#line 50
static void handle_appe(struct vsf_session *p_sess ) ;
#line 51
static void handle_mdtm(struct vsf_session *p_sess ) ;
#line 52
static void handle_site_chmod(struct vsf_session *p_sess , struct mystr *p_arg_str ) ;
#line 54
static void handle_site_umask(struct vsf_session *p_sess , struct mystr *p_arg_str ) ;
#line 56
static void handle_eprt(struct vsf_session *p_sess ) ;
#line 57
static void handle_help(struct vsf_session *p_sess ) ;
#line 58
static void handle_stou(struct vsf_session *p_sess ) ;
#line 59
static void handle_stat(struct vsf_session *p_sess ) ;
#line 60
static void handle_stat_file(struct vsf_session *p_sess ) ;
#line 61
static void handle_logged_in_user(struct vsf_session *p_sess ) ;
#line 62
static void handle_logged_in_pass(struct vsf_session *p_sess ) ;
#line 64
static int pasv_active(struct vsf_session *p_sess ) ;
#line 65
static int port_active(struct vsf_session *p_sess ) ;
#line 66
static void pasv_cleanup(struct vsf_session *p_sess ) ;
#line 67
static void port_cleanup(struct vsf_session *p_sess ) ;
#line 68
static void handle_dir_common(struct vsf_session *p_sess , int full_details , int stat_cmd ) ;
#line 70
static void prepend_path_to_filename(struct mystr *p_str ) ;
#line 71
static int get_remote_transfer_fd(struct vsf_session *p_sess , char const   *p_status_msg ) ;
#line 73
static void check_abor(struct vsf_session *p_sess ) ;
#line 74
static void handle_sigurg(void *p_private ) ;
#line 75
static void handle_upload_common(struct vsf_session *p_sess , int is_append , int is_unique ) ;
#line 77
static void get_unique_filename(struct mystr *p_outstr , struct mystr  const  *p_base_str ) ;
#line 79
static int data_transfer_checks_ok(struct vsf_session *p_sess ) ;
#line 80
static void resolve_tilde(struct mystr *p_str , struct vsf_session *p_sess ) ;
#line 131 "postlogin.c"
static struct mystr s_src_str  ;
#line 132 "postlogin.c"
static struct mystr s_rhs_str  ;
#line 82 "postlogin.c"
void process_post_login(struct vsf_session *p_sess ) 
{ int cmd_ok ;
  struct mystr proctitle_str ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  int __cil_tmp___17 ;
  int __cil_tmp___18 ;
  int __cil_tmp___19 ;
  int __cil_tmp___20 ;
  int __cil_tmp___21 ;
  int __cil_tmp___22 ;
  int __cil_tmp___23 ;
  int __cil_tmp___24 ;
  int __cil_tmp___25 ;
  int __cil_tmp___26 ;
  int __cil_tmp___27 ;
  int __cil_tmp___28 ;
  int __cil_tmp___29 ;
  int __cil_tmp___30 ;
  int __cil_tmp___31 ;
  int __cil_tmp___32 ;
  int __cil_tmp___33 ;
  int __cil_tmp___34 ;
  int __cil_tmp___35 ;
  int __cil_tmp___36 ;
  int __cil_tmp___37 ;
  int __cil_tmp___38 ;
  int __cil_tmp___39 ;
  int __cil_tmp___40 ;
  int __cil_tmp___41 ;
  int __cil_tmp___42 ;
  int __cil_tmp___43 ;
  int __cil_tmp___44 ;
  int __cil_tmp___45 ;
  int __cil_tmp___46 ;
  int __cil_tmp___47 ;
  int __cil_tmp___48 ;
  int __cil_tmp___49 ;
  int __cil_tmp___50 ;
  int __cil_tmp___51 ;
  int __cil_tmp___52 ;
  int __cil_tmp___53 ;
  int __cil_tmp___54 ;
  int __cil_tmp___55 ;
  int __cil_tmp___56 ;
  int __cil_tmp___57 ;
  int __cil_tmp___58 ;
  int __cil_tmp___59 ;
  int __cil_tmp___60 ;
  int __cil_tmp___61 ;
  int __cil_tmp___62 ;
  int __cil_tmp___63 ;
  int __cil_tmp___64 ;
  int __cil_tmp___65 ;
  int __cil_tmp___66 ;
  int __cil_tmp___67 ;
  int __cil_tmp___68 ;
  int __cil_tmp___69 ;
  int __cil_tmp___70 ;
  int __cil_tmp___71 ;
  int __cil_tmp___72 ;
  int __cil_tmp___73 ;
  int __cil_tmp___74 ;
  int __cil_tmp___75 ;
  int __cil_tmp___76 ;
  int __cil_tmp___77 ;
  int __cil_tmp___78 ;
  int __cil_tmp___79 ;
  int __cil_tmp___80 ;
  int __cil_tmp___81 ;

  {
#line 85
  str_getcwd(& p_sess->home_str);
#line 86
  if (p_sess->is_anonymous) {
#line 88
    vsf_sysutil_set_umask(tunable_anon_umask);
#line 89
    p_sess->bw_rate_max = tunable_anon_max_rate;
  } else {
#line 93
    vsf_sysutil_set_umask(tunable_local_umask);
#line 94
    p_sess->bw_rate_max = tunable_local_max_rate;
  }
#line 96
  if (tunable_async_abor_enable) {
#line 98
    vsf_sysutil_install_sighandler(5, & handle_sigurg, (void *)p_sess);
#line 99
    vsf_sysutil_activate_sigurg(0);
  }
#line 102
  vsf_banner_dir_changed(p_sess, 230);
#line 103
  vsf_cmdio_write(p_sess, 230, "Login successful.");
#line 104
  while (1) {
#line 106
    cmd_ok = 1;
#line 107
    if (tunable_setproctitle_enable) {
#line 109
      vsf_sysutil_setproctitle("IDLE");
    }
#line 112
    vsf_cmdio_get_cmd_and_arg(p_sess, & p_sess->ftp_cmd_str, & p_sess->ftp_arg_str,
                              1);
#line 114
    if (tunable_setproctitle_enable) {
#line 116
      proctitle_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 116
      proctitle_str.PRIVATE_HANDS_OFF_len = 0U;
#line 116
      proctitle_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 117
      str_copy(& proctitle_str, (struct mystr  const  *)(& p_sess->ftp_cmd_str));
#line 118
      __cil_tmp = str_isempty((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 118
      if (! __cil_tmp) {
#line 120
        str_append_char(& proctitle_str, (char )' ');
#line 121
        str_append_str(& proctitle_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
      }
#line 124
      str_replace_unprintable(& proctitle_str, (char )'?');
#line 125
      vsf_sysutil_setproctitle_str((struct mystr  const  *)(& proctitle_str));
#line 126
      str_free(& proctitle_str);
    }
#line 129
    if (tunable_cmds_allowed) {
#line 133
      str_alloc_text(& s_src_str, tunable_cmds_allowed);
#line 134
      while (1) {
#line 136
        str_split_char(& s_src_str, & s_rhs_str, (char )',');
#line 137
        __cil_tmp___1 = str_isempty((struct mystr  const  *)(& s_src_str));
#line 137
        if (__cil_tmp___1) {
#line 139
          cmd_ok = 0;
#line 140
          break;
        } else {
#line 142
          __cil_tmp___0 = str_equal((struct mystr  const  *)(& s_src_str), (struct mystr  const  *)(& p_sess->ftp_cmd_str));
#line 142
          if (__cil_tmp___0) {
#line 144
            break;
          }
        }
#line 146
        str_copy(& s_src_str, (struct mystr  const  *)(& s_rhs_str));
      }
    }
#line 149
    if (! cmd_ok) {
#line 151
      vsf_cmdio_write(p_sess, 550, "Permission denied.");
    } else {
#line 153
      __cil_tmp___80 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                      "QUIT");
#line 153
      if (__cil_tmp___80) {
#line 155
        vsf_cmdio_write(p_sess, 221, "Goodbye.");
#line 156
        vsf_sysutil_exit(0);
      } else {
#line 158
        __cil_tmp___78 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                        "PWD");
#line 158
        if (__cil_tmp___78) {
#line 158
          goto _L___50;
        } else {
#line 158
          __cil_tmp___79 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                          "XPWD");
#line 158
          if (__cil_tmp___79) {
            _L___50: /* CIL Label */ 
#line 161
            handle_pwd(p_sess);
          } else {
#line 163
            __cil_tmp___76 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                            "CWD");
#line 163
            if (__cil_tmp___76) {
#line 163
              goto _L___49;
            } else {
#line 163
              __cil_tmp___77 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                              "XCWD");
#line 163
              if (__cil_tmp___77) {
                _L___49: /* CIL Label */ 
#line 166
                handle_cwd(p_sess);
              } else {
#line 168
                __cil_tmp___74 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                "CDUP");
#line 168
                if (__cil_tmp___74) {
#line 168
                  goto _L___48;
                } else {
#line 168
                  __cil_tmp___75 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                  "XCUP");
#line 168
                  if (__cil_tmp___75) {
                    _L___48: /* CIL Label */ 
#line 171
                    handle_cdup(p_sess);
                  } else {
#line 173
                    if (tunable_pasv_enable && ! p_sess->epsv_all) {
#line 173
                      __cil_tmp___72 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                      "PASV");
#line 173
                      if (__cil_tmp___72) {
#line 173
                        goto _L___47;
                      } else {
#line 173
                        __cil_tmp___73 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                        "P@SW");
#line 173
                        if (__cil_tmp___73) {
                          _L___47: /* CIL Label */ 
#line 178
                          handle_pasv(p_sess, 0);
                        } else {
#line 173
                          goto _L___46;
                        }
                      }
                    } else {
                      _L___46: /* CIL Label */ 
#line 180
                      if (tunable_pasv_enable) {
#line 180
                        __cil_tmp___71 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                        "EPSV");
#line 180
                        if (__cil_tmp___71) {
#line 183
                          handle_pasv(p_sess, 1);
                        } else {
#line 180
                          goto _L___45;
                        }
                      } else {
                        _L___45: /* CIL Label */ 
#line 185
                        if (tunable_download_enable) {
#line 185
                          __cil_tmp___70 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                          "RETR");
#line 185
                          if (__cil_tmp___70) {
#line 188
                            handle_retr(p_sess);
                          } else {
#line 185
                            goto _L___44;
                          }
                        } else {
                          _L___44: /* CIL Label */ 
#line 190
                          __cil_tmp___69 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                          "NOOP");
#line 190
                          if (__cil_tmp___69) {
#line 192
                            vsf_cmdio_write(p_sess, 200, "NOOP ok.");
                          } else {
#line 194
                            __cil_tmp___68 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                            "SYST");
#line 194
                            if (__cil_tmp___68) {
#line 196
                              vsf_cmdio_write(p_sess, 215, "UNIX Type: L8");
                            } else {
#line 198
                              __cil_tmp___67 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                              "HELP");
#line 198
                              if (__cil_tmp___67) {
#line 200
                                handle_help(p_sess);
                              } else {
#line 202
                                if (tunable_dirlist_enable) {
#line 202
                                  __cil_tmp___66 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                  "LIST");
#line 202
                                  if (__cil_tmp___66) {
#line 205
                                    handle_list(p_sess);
                                  } else {
#line 202
                                    goto _L___43;
                                  }
                                } else {
                                  _L___43: /* CIL Label */ 
#line 207
                                  __cil_tmp___65 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                  "TYPE");
#line 207
                                  if (__cil_tmp___65) {
#line 209
                                    handle_type(p_sess);
                                  } else {
#line 211
                                    if (tunable_port_enable && ! p_sess->epsv_all) {
#line 211
                                      __cil_tmp___64 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                      "PORT");
#line 211
                                      if (__cil_tmp___64) {
#line 215
                                        handle_port(p_sess);
                                      } else {
#line 211
                                        goto _L___42;
                                      }
                                    } else {
                                      _L___42: /* CIL Label */ 
#line 217
                                      if (tunable_write_enable && (tunable_anon_upload_enable || ! p_sess->is_anonymous)) {
#line 217
                                        __cil_tmp___63 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                        "STOR");
#line 217
                                        if (__cil_tmp___63) {
#line 221
                                          handle_stor(p_sess);
                                        } else {
#line 217
                                          goto _L___41;
                                        }
                                      } else {
                                        _L___41: /* CIL Label */ 
#line 223
                                        if (tunable_write_enable && (tunable_anon_mkdir_write_enable || ! p_sess->is_anonymous)) {
#line 223
                                          __cil_tmp___61 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                          "MKD");
#line 223
                                          if (__cil_tmp___61) {
#line 223
                                            goto _L___40;
                                          } else {
#line 223
                                            __cil_tmp___62 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                            "XMKD");
#line 223
                                            if (__cil_tmp___62) {
                                              _L___40: /* CIL Label */ 
#line 228
                                              handle_mkd(p_sess);
                                            } else {
#line 223
                                              goto _L___39;
                                            }
                                          }
                                        } else {
                                          _L___39: /* CIL Label */ 
#line 230
                                          if (tunable_write_enable && (tunable_anon_other_write_enable || ! p_sess->is_anonymous)) {
#line 230
                                            __cil_tmp___59 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                            "RMD");
#line 230
                                            if (__cil_tmp___59) {
#line 230
                                              goto _L___38;
                                            } else {
#line 230
                                              __cil_tmp___60 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                              "XRMD");
#line 230
                                              if (__cil_tmp___60) {
                                                _L___38: /* CIL Label */ 
#line 235
                                                handle_rmd(p_sess);
                                              } else {
#line 230
                                                goto _L___37;
                                              }
                                            }
                                          } else {
                                            _L___37: /* CIL Label */ 
#line 237
                                            if (tunable_write_enable && (tunable_anon_other_write_enable || ! p_sess->is_anonymous)) {
#line 237
                                              __cil_tmp___58 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                              "DELE");
#line 237
                                              if (__cil_tmp___58) {
#line 241
                                                handle_dele(p_sess);
                                              } else {
#line 237
                                                goto _L___36;
                                              }
                                            } else {
                                              _L___36: /* CIL Label */ 
#line 243
                                              __cil_tmp___57 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                              "REST");
#line 243
                                              if (__cil_tmp___57) {
#line 245
                                                handle_rest(p_sess);
                                              } else {
#line 247
                                                if (tunable_write_enable && (tunable_anon_other_write_enable || ! p_sess->is_anonymous)) {
#line 247
                                                  __cil_tmp___56 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                  "RNFR");
#line 247
                                                  if (__cil_tmp___56) {
#line 251
                                                    handle_rnfr(p_sess);
                                                  } else {
#line 247
                                                    goto _L___35;
                                                  }
                                                } else {
                                                  _L___35: /* CIL Label */ 
#line 253
                                                  if (tunable_write_enable && (tunable_anon_other_write_enable || ! p_sess->is_anonymous)) {
#line 253
                                                    __cil_tmp___55 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                    "RNTO");
#line 253
                                                    if (__cil_tmp___55) {
#line 257
                                                      handle_rnto(p_sess);
                                                    } else {
#line 253
                                                      goto _L___34;
                                                    }
                                                  } else {
                                                    _L___34: /* CIL Label */ 
#line 259
                                                    if (tunable_dirlist_enable) {
#line 259
                                                      __cil_tmp___54 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                      "NLST");
#line 259
                                                      if (__cil_tmp___54) {
#line 262
                                                        handle_nlst(p_sess);
                                                      } else {
#line 259
                                                        goto _L___33;
                                                      }
                                                    } else {
                                                      _L___33: /* CIL Label */ 
#line 264
                                                      __cil_tmp___53 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                      "SIZE");
#line 264
                                                      if (__cil_tmp___53) {
#line 266
                                                        handle_size(p_sess);
                                                      } else {
#line 268
                                                        if (! p_sess->is_anonymous) {
#line 268
                                                          __cil_tmp___52 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                          "SITE");
#line 268
                                                          if (__cil_tmp___52) {
#line 271
                                                            handle_site(p_sess);
                                                          } else {
#line 268
                                                            goto _L___32;
                                                          }
                                                        } else {
                                                          _L___32: /* CIL Label */ 
#line 276
                                                          __cil_tmp___50 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                          "ABOR");
#line 276
                                                          if (__cil_tmp___50) {
#line 276
                                                            goto _L___31;
                                                          } else {
#line 276
                                                            __cil_tmp___51 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                            "\377\364\377\362ABOR");
#line 276
                                                            if (__cil_tmp___51) {
                                                              _L___31: /* CIL Label */ 
#line 279
                                                              vsf_cmdio_write(p_sess,
                                                                              225,
                                                                              "No transfer to ABOR.");
                                                            } else {
#line 281
                                                              if (tunable_write_enable && (tunable_anon_other_write_enable || ! p_sess->is_anonymous)) {
#line 281
                                                                __cil_tmp___49 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                "APPE");
#line 281
                                                                if (__cil_tmp___49) {
#line 285
                                                                  handle_appe(p_sess);
                                                                } else {
#line 281
                                                                  goto _L___30;
                                                                }
                                                              } else {
                                                                _L___30: /* CIL Label */ 
#line 287
                                                                __cil_tmp___48 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                "MDTM");
#line 287
                                                                if (__cil_tmp___48) {
#line 289
                                                                  handle_mdtm(p_sess);
                                                                } else {
#line 291
                                                                  if (tunable_port_enable) {
#line 291
                                                                    __cil_tmp___47 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                    "EPRT");
#line 291
                                                                    if (__cil_tmp___47) {
#line 294
                                                                      handle_eprt(p_sess);
                                                                    } else {
#line 291
                                                                      goto _L___29;
                                                                    }
                                                                  } else {
                                                                    _L___29: /* CIL Label */ 
#line 296
                                                                    __cil_tmp___46 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                    "STRU");
#line 296
                                                                    if (__cil_tmp___46) {
#line 298
                                                                      str_upper(& p_sess->ftp_arg_str);
#line 299
                                                                      __cil_tmp___2 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                                                                                     "F");
#line 299
                                                                      if (__cil_tmp___2) {
#line 301
                                                                        vsf_cmdio_write(p_sess,
                                                                                        200,
                                                                                        "Structure set to F.");
                                                                      } else {
#line 305
                                                                        vsf_cmdio_write(p_sess,
                                                                                        504,
                                                                                        "Bad STRU command.");
                                                                      }
                                                                    } else {
#line 308
                                                                      __cil_tmp___45 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                      "MODE");
#line 308
                                                                      if (__cil_tmp___45) {
#line 310
                                                                        str_upper(& p_sess->ftp_arg_str);
#line 311
                                                                        __cil_tmp___3 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                                                                                       "S");
#line 311
                                                                        if (__cil_tmp___3) {
#line 313
                                                                          vsf_cmdio_write(p_sess,
                                                                                          200,
                                                                                          "Mode set to S.");
                                                                        } else {
#line 317
                                                                          vsf_cmdio_write(p_sess,
                                                                                          504,
                                                                                          "Bad MODE command.");
                                                                        }
                                                                      } else {
#line 320
                                                                        __cil_tmp___44 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                        "STOU");
#line 320
                                                                        if (__cil_tmp___44) {
#line 322
                                                                          handle_stou(p_sess);
                                                                        } else {
#line 324
                                                                          __cil_tmp___43 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                          "ALLO");
#line 324
                                                                          if (__cil_tmp___43) {
#line 326
                                                                            vsf_cmdio_write(p_sess,
                                                                                            202,
                                                                                            "ALLO command ignored.");
                                                                          } else {
#line 328
                                                                            __cil_tmp___42 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                            "REIN");
#line 328
                                                                            if (__cil_tmp___42) {
#line 330
                                                                              vsf_cmdio_write(p_sess,
                                                                                              502,
                                                                                              "REIN not implemented.");
                                                                            } else {
#line 332
                                                                              __cil_tmp___41 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                              "ACCT");
#line 332
                                                                              if (__cil_tmp___41) {
#line 334
                                                                                vsf_cmdio_write(p_sess,
                                                                                                502,
                                                                                                "ACCT not implemented.");
                                                                              } else {
#line 336
                                                                                __cil_tmp___40 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                "SMNT");
#line 336
                                                                                if (__cil_tmp___40) {
#line 338
                                                                                  vsf_cmdio_write(p_sess,
                                                                                                  502,
                                                                                                  "SMNT not implemented.");
                                                                                } else {
#line 340
                                                                                  __cil_tmp___39 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                  "FEAT");
#line 340
                                                                                  if (__cil_tmp___39) {
#line 342
                                                                                    handle_feat(p_sess);
                                                                                  } else {
#line 344
                                                                                    __cil_tmp___38 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                    "OPTS");
#line 344
                                                                                    if (__cil_tmp___38) {
#line 346
                                                                                      handle_opts(p_sess);
                                                                                    } else {
#line 348
                                                                                      __cil_tmp___36 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                      "STAT");
#line 348
                                                                                      if (__cil_tmp___36) {
#line 348
                                                                                        __cil_tmp___37 = str_isempty((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 348
                                                                                        if (__cil_tmp___37) {
#line 351
                                                                                          handle_stat(p_sess);
                                                                                        } else {
#line 348
                                                                                          goto _L___28;
                                                                                        }
                                                                                      } else {
                                                                                        _L___28: /* CIL Label */ 
#line 353
                                                                                        if (tunable_dirlist_enable) {
#line 353
                                                                                          __cil_tmp___35 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                          "STAT");
#line 353
                                                                                          if (__cil_tmp___35) {
#line 356
                                                                                            handle_stat_file(p_sess);
                                                                                          } else {
#line 353
                                                                                            goto _L___27;
                                                                                          }
                                                                                        } else {
                                                                                          _L___27: /* CIL Label */ 
#line 358
                                                                                          if (tunable_ssl_enable) {
#line 358
                                                                                            __cil_tmp___34 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                            "PBSZ");
#line 358
                                                                                            if (__cil_tmp___34) {
#line 360
                                                                                              handle_pbsz(p_sess);
                                                                                            } else {
#line 358
                                                                                              goto _L___26;
                                                                                            }
                                                                                          } else {
                                                                                            _L___26: /* CIL Label */ 
#line 362
                                                                                            if (tunable_ssl_enable) {
#line 362
                                                                                              __cil_tmp___33 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                              "PROT");
#line 362
                                                                                              if (__cil_tmp___33) {
#line 364
                                                                                                handle_prot(p_sess);
                                                                                              } else {
#line 362
                                                                                                goto _L___25;
                                                                                              }
                                                                                            } else {
                                                                                              _L___25: /* CIL Label */ 
#line 366
                                                                                              __cil_tmp___32 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                              "USER");
#line 366
                                                                                              if (__cil_tmp___32) {
#line 368
                                                                                                handle_logged_in_user(p_sess);
                                                                                              } else {
#line 370
                                                                                                __cil_tmp___31 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                "PASS");
#line 370
                                                                                                if (__cil_tmp___31) {
#line 372
                                                                                                  handle_logged_in_pass(p_sess);
                                                                                                } else {
#line 374
                                                                                                  __cil_tmp___4 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                 "PASV");
#line 374
                                                                                                  if (__cil_tmp___4) {
#line 374
                                                                                                    goto _L___24;
                                                                                                  } else {
#line 374
                                                                                                    __cil_tmp___5 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                   "PORT");
#line 374
                                                                                                    if (__cil_tmp___5) {
                                                                                                      _L___24: /* CIL Label */ 
#line 374
                                                                                                      goto _L___23;
                                                                                                    } else {
#line 374
                                                                                                      __cil_tmp___6 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                     "STOR");
#line 374
                                                                                                      if (__cil_tmp___6) {
                                                                                                        _L___23: /* CIL Label */ 
#line 374
                                                                                                        goto _L___22;
                                                                                                      } else {
#line 374
                                                                                                        __cil_tmp___7 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                       "MKD");
#line 374
                                                                                                        if (__cil_tmp___7) {
                                                                                                          _L___22: /* CIL Label */ 
#line 374
                                                                                                          goto _L___21;
                                                                                                        } else {
#line 374
                                                                                                          __cil_tmp___8 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                         "XMKD");
#line 374
                                                                                                          if (__cil_tmp___8) {
                                                                                                            _L___21: /* CIL Label */ 
#line 374
                                                                                                            goto _L___20;
                                                                                                          } else {
#line 374
                                                                                                            __cil_tmp___9 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                           "RMD");
#line 374
                                                                                                            if (__cil_tmp___9) {
                                                                                                              _L___20: /* CIL Label */ 
#line 374
                                                                                                              goto _L___19;
                                                                                                            } else {
#line 374
                                                                                                              __cil_tmp___10 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                              "XRMD");
#line 374
                                                                                                              if (__cil_tmp___10) {
                                                                                                                _L___19: /* CIL Label */ 
#line 374
                                                                                                                goto _L___18;
                                                                                                              } else {
#line 374
                                                                                                                __cil_tmp___11 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                "DELE");
#line 374
                                                                                                                if (__cil_tmp___11) {
                                                                                                                  _L___18: /* CIL Label */ 
#line 374
                                                                                                                  goto _L___17;
                                                                                                                } else {
#line 374
                                                                                                                  __cil_tmp___12 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                  "RNFR");
#line 374
                                                                                                                  if (__cil_tmp___12) {
                                                                                                                    _L___17: /* CIL Label */ 
#line 374
                                                                                                                    goto _L___16;
                                                                                                                  } else {
#line 374
                                                                                                                    __cil_tmp___13 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                    "RNTO");
#line 374
                                                                                                                    if (__cil_tmp___13) {
                                                                                                                      _L___16: /* CIL Label */ 
#line 374
                                                                                                                      goto _L___15;
                                                                                                                    } else {
#line 374
                                                                                                                      __cil_tmp___14 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                      "SITE");
#line 374
                                                                                                                      if (__cil_tmp___14) {
                                                                                                                        _L___15: /* CIL Label */ 
#line 374
                                                                                                                        goto _L___14;
                                                                                                                      } else {
#line 374
                                                                                                                        __cil_tmp___15 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                        "APPE");
#line 374
                                                                                                                        if (__cil_tmp___15) {
                                                                                                                          _L___14: /* CIL Label */ 
#line 374
                                                                                                                          goto _L___13;
                                                                                                                        } else {
#line 374
                                                                                                                          __cil_tmp___16 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                          "EPSV");
#line 374
                                                                                                                          if (__cil_tmp___16) {
                                                                                                                            _L___13: /* CIL Label */ 
#line 374
                                                                                                                            goto _L___12;
                                                                                                                          } else {
#line 374
                                                                                                                            __cil_tmp___17 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                            "EPRT");
#line 374
                                                                                                                            if (__cil_tmp___17) {
                                                                                                                              _L___12: /* CIL Label */ 
#line 374
                                                                                                                              goto _L___11;
                                                                                                                            } else {
#line 374
                                                                                                                              __cil_tmp___18 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                              "RETR");
#line 374
                                                                                                                              if (__cil_tmp___18) {
                                                                                                                                _L___11: /* CIL Label */ 
#line 374
                                                                                                                                goto _L___10;
                                                                                                                              } else {
#line 374
                                                                                                                                __cil_tmp___19 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                "LIST");
#line 374
                                                                                                                                if (__cil_tmp___19) {
                                                                                                                                  _L___10: /* CIL Label */ 
#line 374
                                                                                                                                  goto _L___9;
                                                                                                                                } else {
#line 374
                                                                                                                                  __cil_tmp___20 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                  "NLST");
#line 374
                                                                                                                                  if (__cil_tmp___20) {
                                                                                                                                    _L___9: /* CIL Label */ 
#line 374
                                                                                                                                    goto _L___8;
                                                                                                                                  } else {
#line 374
                                                                                                                                    __cil_tmp___21 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                    "STOU");
#line 374
                                                                                                                                    if (__cil_tmp___21) {
                                                                                                                                      _L___8: /* CIL Label */ 
#line 374
                                                                                                                                      goto _L___7;
                                                                                                                                    } else {
#line 374
                                                                                                                                      __cil_tmp___22 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                      "ALLO");
#line 374
                                                                                                                                      if (__cil_tmp___22) {
                                                                                                                                        _L___7: /* CIL Label */ 
#line 374
                                                                                                                                        goto _L___6;
                                                                                                                                      } else {
#line 374
                                                                                                                                        __cil_tmp___23 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                        "REIN");
#line 374
                                                                                                                                        if (__cil_tmp___23) {
                                                                                                                                          _L___6: /* CIL Label */ 
#line 374
                                                                                                                                          goto _L___5;
                                                                                                                                        } else {
#line 374
                                                                                                                                          __cil_tmp___24 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                          "ACCT");
#line 374
                                                                                                                                          if (__cil_tmp___24) {
                                                                                                                                            _L___5: /* CIL Label */ 
#line 374
                                                                                                                                            goto _L___4;
                                                                                                                                          } else {
#line 374
                                                                                                                                            __cil_tmp___25 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                            "SMNT");
#line 374
                                                                                                                                            if (__cil_tmp___25) {
                                                                                                                                              _L___4: /* CIL Label */ 
#line 374
                                                                                                                                              goto _L___3;
                                                                                                                                            } else {
#line 374
                                                                                                                                              __cil_tmp___26 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                              "FEAT");
#line 374
                                                                                                                                              if (__cil_tmp___26) {
                                                                                                                                                _L___3: /* CIL Label */ 
#line 374
                                                                                                                                                goto _L___2;
                                                                                                                                              } else {
#line 374
                                                                                                                                                __cil_tmp___27 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                                "OPTS");
#line 374
                                                                                                                                                if (__cil_tmp___27) {
                                                                                                                                                  _L___2: /* CIL Label */ 
#line 374
                                                                                                                                                  goto _L___1;
                                                                                                                                                } else {
#line 374
                                                                                                                                                  __cil_tmp___28 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                                  "STAT");
#line 374
                                                                                                                                                  if (__cil_tmp___28) {
                                                                                                                                                    _L___1: /* CIL Label */ 
#line 374
                                                                                                                                                    goto _L___0;
                                                                                                                                                  } else {
#line 374
                                                                                                                                                    __cil_tmp___29 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                                    "PBSZ");
#line 374
                                                                                                                                                    if (__cil_tmp___29) {
                                                                                                                                                      _L___0: /* CIL Label */ 
#line 374
                                                                                                                                                      goto _L;
                                                                                                                                                    } else {
#line 374
                                                                                                                                                      __cil_tmp___30 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_cmd_str),
                                                                                                                                                                                      "PROT");
#line 374
                                                                                                                                                      if (__cil_tmp___30) {
                                                                                                                                                        _L: /* CIL Label */ 
#line 402
                                                                                                                                                        vsf_cmdio_write(p_sess,
                                                                                                                                                                        550,
                                                                                                                                                                        "Permission denied.");
                                                                                                                                                      } else {
#line 406
                                                                                                                                                        vsf_cmdio_write(p_sess,
                                                                                                                                                                        500,
                                                                                                                                                                        "Unknown command.");
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                }
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 408
    __cil_tmp___81 = vsf_log_entry_pending(p_sess);
#line 408
    if (__cil_tmp___81) {
#line 410
      vsf_log_do_log(p_sess, 0);
    }
  }
}
}
#line 418 "postlogin.c"
static struct mystr s_cwd_buf_mangle_str  ;
#line 419 "postlogin.c"
static struct mystr s_pwd_res_str  ;
#line 415 "postlogin.c"
static void handle_pwd(struct vsf_session *p_sess ) 
{ 

  {
#line 420
  str_getcwd(& s_cwd_buf_mangle_str);
#line 422
  str_replace_text(& s_cwd_buf_mangle_str, "\"", "\"\"");
#line 424
  str_alloc_text(& s_pwd_res_str, "\"");
#line 425
  str_append_str(& s_pwd_res_str, (struct mystr  const  *)(& s_cwd_buf_mangle_str));
#line 426
  str_append_text(& s_pwd_res_str, "\"");
#line 427
  vsf_cmdio_write_str(p_sess, 257, (struct mystr  const  *)(& s_pwd_res_str));
#line 428
  return;
}
}
#line 430 "postlogin.c"
static void handle_cwd(struct vsf_session *p_sess ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 434
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 435
  __cil_tmp = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 435
  if (! __cil_tmp) {
#line 437
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 438
    return;
  }
#line 440
  retval = str_chdir((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 441
  if (retval == 0) {
#line 444
    vsf_banner_dir_changed(p_sess, 250);
#line 445
    vsf_cmdio_write(p_sess, 250, "Directory successfully changed.");
  } else {
#line 449
    vsf_cmdio_write(p_sess, 550, "Failed to change directory.");
  }
#line 451
  return;
}
}
#line 453 "postlogin.c"
static void handle_cdup(struct vsf_session *p_sess ) 
{ 

  {
#line 456
  str_alloc_text(& p_sess->ftp_arg_str, "..");
#line 457
  handle_cwd(p_sess);
#line 458
  return;
}
}
#line 460 "postlogin.c"
static int port_active(struct vsf_session *p_sess ) 
{ int ret___0 ;
  int __cil_tmp ;

  {
#line 463
  ret___0 = 0;
#line 464
  if ((unsigned int )p_sess->p_port_sockaddr != (unsigned int )((struct vsf_sysutil_sockaddr *)0)) {
#line 466
    ret___0 = 1;
#line 467
    __cil_tmp = pasv_active(p_sess);
#line 467
    if (__cil_tmp) {
#line 469
      bug("port and pasv both active");
    }
  }
#line 472
  return (ret___0);
}
}
#line 475 "postlogin.c"
static int pasv_active(struct vsf_session *p_sess ) 
{ int ret___0 ;
  int __cil_tmp ;

  {
#line 478
  ret___0 = 0;
#line 479
  if (p_sess->pasv_listen_fd != -1) {
#line 481
    ret___0 = 1;
#line 482
    __cil_tmp = port_active(p_sess);
#line 482
    if (__cil_tmp) {
#line 484
      bug("pasv and port both active");
    }
  }
#line 487
  return (ret___0);
}
}
#line 490 "postlogin.c"
static void port_cleanup(struct vsf_session *p_sess ) 
{ 

  {
#line 493
  vsf_sysutil_sockaddr_clear(& p_sess->p_port_sockaddr);
#line 494
  return;
}
}
#line 496 "postlogin.c"
static void pasv_cleanup(struct vsf_session *p_sess ) 
{ 

  {
#line 499
  if (p_sess->pasv_listen_fd != -1) {
#line 501
    vsf_sysutil_close(p_sess->pasv_listen_fd);
#line 502
    p_sess->pasv_listen_fd = -1;
  }
#line 504
  return;
}
}
#line 509 "postlogin.c"
static struct mystr s_pasv_res_str  ;
#line 510 "postlogin.c"
static struct vsf_sysutil_sockaddr *s_p_sockaddr  ;
#line 506 "postlogin.c"
static void handle_pasv(struct vsf_session *p_sess , int is_epsv ) 
{ int bind_retries ;
  unsigned short the_port ;
  unsigned short min_port ;
  unsigned short max_port ;
  int is_ipv6 ;
  int __cil_tmp ;
  int argval ;
  int __cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int retval ;
  double scaled_port ;
  unsigned char __cil_tmp___3 ;
  unsigned char __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  enum EVSFSysUtilError __cil_tmp___7 ;
  int __cil_tmp___8 ;
  char const   *__cil_tmp___9 ;
  void const   *p_v4addr ;
  void const   *__cil_tmp___10 ;
  char const   *__cil_tmp___11 ;

  {
#line 511
  bind_retries = 10;
#line 512
  the_port = (unsigned short)0;
#line 514
  min_port = (unsigned short)1024;
#line 515
  max_port = (unsigned short)65535;
#line 516
  __cil_tmp = vsf_sysutil_sockaddr_is_ipv6((struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 516
  is_ipv6 = __cil_tmp;
#line 517
  if (is_epsv) {
#line 517
    __cil_tmp___2 = str_isempty((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 517
    if (__cil_tmp___2) {
#line 517
      goto _L;
    } else {
#line 520
      str_upper(& p_sess->ftp_arg_str);
#line 521
      __cil_tmp___0 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                     "ALL");
#line 521
      if (__cil_tmp___0) {
#line 523
        p_sess->epsv_all = 1;
#line 524
        vsf_cmdio_write(p_sess, 200, "EPSV ALL ok.");
#line 525
        return;
      }
#line 527
      __cil_tmp___1 = str_getbuf((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 527
      argval = vsf_sysutil_atoi(__cil_tmp___1);
#line 528
      if ((argval < 1 || argval > 2) || (! is_ipv6 && argval == 2)) {
#line 530
        vsf_cmdio_write(p_sess, 522, "Bad network protocol.");
#line 531
        return;
      }
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 534
  pasv_cleanup(p_sess);
#line 535
  port_cleanup(p_sess);
#line 536
  if (is_ipv6) {
#line 538
    p_sess->pasv_listen_fd = vsf_sysutil_get_ipv6_sock();
  } else {
#line 542
    p_sess->pasv_listen_fd = vsf_sysutil_get_ipv4_sock();
  }
#line 544
  vsf_sysutil_activate_reuseaddr(p_sess->pasv_listen_fd);
#line 546
  if (tunable_pasv_min_port > (unsigned int )min_port && tunable_pasv_min_port <= (unsigned int )max_port) {
#line 548
    min_port = (unsigned short )tunable_pasv_min_port;
  }
#line 550
  if (tunable_pasv_max_port >= (unsigned int )min_port && tunable_pasv_max_port < (unsigned int )max_port) {
#line 552
    max_port = (unsigned short )tunable_pasv_max_port;
  }
#line 555
  while (1) {
#line 555
    bind_retries --;
#line 555
    if (! bind_retries) {
#line 555
      break;
    }
#line 559
    __cil_tmp___3 = vsf_sysutil_get_random_byte();
#line 559
    the_port = (unsigned short )__cil_tmp___3;
#line 560
    the_port = (unsigned short )((int )the_port << 8);
#line 561
    __cil_tmp___4 = vsf_sysutil_get_random_byte();
#line 561
    the_port = (unsigned short )((int )the_port | (int )__cil_tmp___4);
#line 562
    scaled_port = (double )min_port;
#line 563
    scaled_port += ((double )the_port / (double )65536) * (((double )max_port - (double )min_port) + (double )1);
#line 565
    the_port = (unsigned short )scaled_port;
#line 566
    vsf_sysutil_sockaddr_clone(& s_p_sockaddr, (struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 567
    vsf_sysutil_sockaddr_set_port(s_p_sockaddr, the_port);
#line 568
    retval = vsf_sysutil_bind(p_sess->pasv_listen_fd, (struct vsf_sysutil_sockaddr  const  *)s_p_sockaddr);
#line 569
    __cil_tmp___6 = vsf_sysutil_retval_is_error(retval);
#line 569
    if (! __cil_tmp___6) {
#line 571
      retval = vsf_sysutil_listen(p_sess->pasv_listen_fd, 1U);
#line 572
      __cil_tmp___5 = vsf_sysutil_retval_is_error(retval);
#line 572
      if (! __cil_tmp___5) {
#line 574
        break;
      }
    }
#line 577
    __cil_tmp___7 = vsf_sysutil_get_error();
#line 577
    if ((int )__cil_tmp___7 == 2) {
#line 579
      continue;
    }
#line 581
    die("vsf_sysutil_bind / listen");
  }
#line 583
  if (! bind_retries) {
#line 585
    die("vsf_sysutil_bind");
  }
#line 587
  if (is_epsv) {
#line 589
    str_alloc_text(& s_pasv_res_str, "Entering Extended Passive Mode (|||");
#line 590
    str_append_ulong(& s_pasv_res_str, (unsigned long )the_port);
#line 591
    str_append_text(& s_pasv_res_str, "|)");
#line 592
    vsf_cmdio_write_str(p_sess, 229, (struct mystr  const  *)(& s_pasv_res_str));
#line 593
    return;
  }
#line 595
  if ((unsigned int )tunable_pasv_address != (unsigned int )((char const   *)0)) {
#line 598
    __cil_tmp___8 = vsf_sysutil_inet_aton(tunable_pasv_address, s_p_sockaddr);
#line 598
    if (__cil_tmp___8 == 0) {
#line 600
      die("invalid pasv_address");
    }
  }
#line 603
  str_alloc_text(& s_pasv_res_str, "Entering Passive Mode (");
#line 604
  if (! is_ipv6) {
#line 606
    __cil_tmp___9 = vsf_sysutil_inet_ntop((struct vsf_sysutil_sockaddr  const  *)s_p_sockaddr);
#line 606
    str_append_text(& s_pasv_res_str, __cil_tmp___9);
  } else {
#line 610
    __cil_tmp___10 = vsf_sysutil_sockaddr_ipv6_v4((struct vsf_sysutil_sockaddr  const  *)s_p_sockaddr);
#line 610
    p_v4addr = __cil_tmp___10;
#line 611
    if (p_v4addr) {
#line 613
      __cil_tmp___11 = vsf_sysutil_inet_ntoa(p_v4addr);
#line 613
      str_append_text(& s_pasv_res_str, __cil_tmp___11);
    } else {
#line 617
      str_append_text(& s_pasv_res_str, "0,0,0,0");
    }
  }
#line 620
  str_replace_char(& s_pasv_res_str, (char )'.', (char )',');
#line 621
  str_append_text(& s_pasv_res_str, ",");
#line 622
  str_append_ulong(& s_pasv_res_str, (unsigned long )((int )the_port >> 8));
#line 623
  str_append_text(& s_pasv_res_str, ",");
#line 624
  str_append_ulong(& s_pasv_res_str, (unsigned long )((int )the_port & 255));
#line 625
  str_append_text(& s_pasv_res_str, ")");
#line 626
  vsf_cmdio_write_str(p_sess, 227, (struct mystr  const  *)(& s_pasv_res_str));
#line 627
  return;
}
}
#line 632 "postlogin.c"
static struct mystr s_mark_str  ;
#line 633 "postlogin.c"
static struct vsf_sysutil_statbuf *s_p_statbuf  ;
#line 629 "postlogin.c"
static void handle_retr(struct vsf_session *p_sess ) 
{ struct vsf_transfer_ret trans_ret ;
  int remote_fd ;
  int opened_file ;
  int is_ascii ;
  filesize_t offset ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  filesize_t __cil_tmp___5 ;
  char const   *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;

  {
#line 637
  is_ascii = 0;
#line 638
  offset = p_sess->restart_pos;
#line 639
  p_sess->restart_pos = 0LL;
#line 640
  __cil_tmp = data_transfer_checks_ok(p_sess);
#line 640
  if (! __cil_tmp) {
#line 642
    return;
  }
#line 644
  if (p_sess->is_ascii && offset != 0LL) {
#line 646
    vsf_cmdio_write(p_sess, 550, "No support for resume of ASCII transfer.");
#line 648
    return;
  }
#line 650
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 651
  vsf_log_start_entry(p_sess, 2);
#line 652
  str_copy(& p_sess->log_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 653
  prepend_path_to_filename(& p_sess->log_str);
#line 654
  __cil_tmp___0 = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 654
  if (! __cil_tmp___0) {
#line 656
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 657
    return;
  }
#line 659
  opened_file = str_open((struct mystr  const  *)(& p_sess->ftp_arg_str), 1);
#line 660
  __cil_tmp___1 = vsf_sysutil_retval_is_error(opened_file);
#line 660
  if (__cil_tmp___1) {
#line 662
    vsf_cmdio_write(p_sess, 550, "Failed to open file.");
#line 663
    return;
  }
#line 666
  if (tunable_lock_upload_files) {
#line 668
    vsf_sysutil_lock_file_read(opened_file);
  }
#line 670
  vsf_sysutil_fstat(opened_file, & s_p_statbuf);
#line 672
  __cil_tmp___3 = vsf_sysutil_statbuf_is_regfile((struct vsf_sysutil_statbuf  const  *)s_p_statbuf);
#line 672
  if (! __cil_tmp___3) {
#line 675
    vsf_cmdio_write(p_sess, 550, "Failed to open file.");
#line 679
    __cil_tmp___2 = vsf_sysutil_statbuf_is_dir((struct vsf_sysutil_statbuf  const  *)s_p_statbuf);
#line 679
    if (__cil_tmp___2) {
#line 681
      vsf_log_clear_entry(p_sess);
    }
#line 683
    goto file_close_out;
  }
#line 688
  vsf_sysutil_deactivate_noblock(opened_file);
#line 690
  if (p_sess->is_anonymous && tunable_anon_world_readable_only) {
#line 690
    __cil_tmp___4 = vsf_sysutil_statbuf_is_readable_other((struct vsf_sysutil_statbuf  const  *)s_p_statbuf);
#line 690
    if (__cil_tmp___4) {
#line 690
      goto _L;
    } else {
#line 693
      vsf_cmdio_write(p_sess, 550, "Failed to open file.");
#line 694
      goto file_close_out;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 697
  if (offset != 0LL) {
#line 699
    vsf_sysutil_lseek_to(opened_file, offset);
  }
#line 701
  str_alloc_text(& s_mark_str, "Opening ");
#line 702
  if (tunable_ascii_download_enable && p_sess->is_ascii) {
#line 704
    str_append_text(& s_mark_str, "ASCII");
#line 705
    is_ascii = 1;
  } else {
#line 709
    str_append_text(& s_mark_str, "BINARY");
  }
#line 711
  str_append_text(& s_mark_str, " mode data connection for ");
#line 712
  str_append_str(& s_mark_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 713
  str_append_text(& s_mark_str, " (");
#line 714
  __cil_tmp___5 = vsf_sysutil_statbuf_get_size((struct vsf_sysutil_statbuf  const  *)s_p_statbuf);
#line 714
  str_append_filesize_t(& s_mark_str, __cil_tmp___5);
#line 716
  str_append_text(& s_mark_str, " bytes).");
#line 717
  __cil_tmp___6 = str_getbuf((struct mystr  const  *)(& s_mark_str));
#line 717
  remote_fd = get_remote_transfer_fd(p_sess, __cil_tmp___6);
#line 718
  __cil_tmp___7 = vsf_sysutil_retval_is_error(remote_fd);
#line 718
  if (__cil_tmp___7) {
#line 720
    goto port_pasv_cleanup_out;
  }
#line 722
  trans_ret = vsf_ftpdataio_transfer_file(p_sess, remote_fd, opened_file, 0, is_ascii);
#line 724
  __cil_tmp___8 = vsf_ftpdataio_dispose_transfer_fd(p_sess);
#line 724
  if (__cil_tmp___8 != 1 && trans_ret.retval == 0) {
#line 726
    trans_ret.retval = -2;
  }
#line 728
  p_sess->transfer_size = trans_ret.transferred;
#line 730
  if (trans_ret.retval == 0) {
#line 732
    vsf_log_do_log(p_sess, 1);
  }
#line 737
  if (trans_ret.retval == -1) {
#line 739
    vsf_cmdio_write(p_sess, 451, "Failure reading local file.");
  } else {
#line 741
    if (trans_ret.retval == -2) {
#line 743
      vsf_cmdio_write(p_sess, 426, "Failure writing network stream.");
    } else {
#line 747
      vsf_cmdio_write(p_sess, 226, "File send OK.");
    }
  }
#line 749
  check_abor(p_sess);
  port_pasv_cleanup_out: 
#line 751
  port_cleanup(p_sess);
#line 752
  pasv_cleanup(p_sess);
  file_close_out: 
#line 754
  vsf_sysutil_close(opened_file);
#line 755
  return;
}
}
#line 757 "postlogin.c"
static void handle_list(struct vsf_session *p_sess ) 
{ 

  {
#line 760
  handle_dir_common(p_sess, 1, 0);
#line 761
  return;
}
}
#line 766 "postlogin.c"
static struct mystr s_option_str  ;
#line 767 "postlogin.c"
static struct mystr s_filter_str  ;
#line 768 "postlogin.c"
static struct mystr s_dir_name_str  ;
#line 769 "postlogin.c"
static struct vsf_sysutil_statbuf *s_p_dirstat  ;
#line 763 "postlogin.c"
static void handle_dir_common(struct vsf_session *p_sess , int full_details , int stat_cmd ) 
{ int dir_allow_read ;
  struct vsf_sysutil_dir *p_dir ;
  int retval ;
  int use_control ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  char __cil_tmp___1 ;
  int __cil_tmp___2 ;
  struct str_locate_result locate_result ;
  struct str_locate_result __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int remote_fd ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;

  {
#line 770
  dir_allow_read = 1;
#line 771
  p_dir = (struct vsf_sysutil_dir *)0;
#line 772
  retval = 0;
#line 773
  use_control = 0;
#line 774
  str_empty(& s_option_str);
#line 775
  str_empty(& s_filter_str);
#line 777
  str_alloc_text(& s_dir_name_str, ".");
#line 778
  if (! stat_cmd) {
#line 778
    __cil_tmp = data_transfer_checks_ok(p_sess);
#line 778
    if (__cil_tmp) {
#line 778
      goto _L;
    } else {
#line 780
      return;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 785
  __cil_tmp___0 = str_isempty((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 785
  if (__cil_tmp___0) {
    _L___0: /* CIL Label */ 
#line 796
    str_copy(& s_filter_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
  } else {
#line 785
    __cil_tmp___1 = str_get_char_at((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                    0U);
#line 785
    if ((int )__cil_tmp___1 == 45) {
#line 789
      str_mid_to_end((struct mystr  const  *)(& p_sess->ftp_arg_str), & s_option_str,
                     1U);
#line 791
      str_split_char(& s_option_str, & s_filter_str, (char )' ');
    } else {
#line 785
      goto _L___0;
    }
  }
#line 798
  __cil_tmp___5 = str_isempty((struct mystr  const  *)(& s_filter_str));
#line 798
  if (! __cil_tmp___5) {
#line 800
    resolve_tilde(& s_filter_str, p_sess);
#line 801
    __cil_tmp___2 = vsf_access_check_file((struct mystr  const  *)(& s_filter_str));
#line 801
    if (! __cil_tmp___2) {
#line 803
      vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 804
      return;
    }
#line 807
    p_dir = str_opendir((struct mystr  const  *)(& s_filter_str));
#line 808
    if ((unsigned int )p_dir != (unsigned int )((struct vsf_sysutil_dir *)0)) {
#line 811
      str_copy(& s_dir_name_str, (struct mystr  const  *)(& s_filter_str));
#line 812
      str_free(& s_filter_str);
    } else {
#line 816
      __cil_tmp___3 = str_locate_char((struct mystr  const  *)(& s_filter_str), (char )'/');
#line 816
      locate_result = __cil_tmp___3;
#line 818
      if (locate_result.found) {
#line 823
        str_copy(& s_dir_name_str, (struct mystr  const  *)(& s_filter_str));
#line 824
        str_split_char_reverse(& s_dir_name_str, & s_filter_str, (char )'/');
#line 828
        __cil_tmp___4 = str_isempty((struct mystr  const  *)(& s_dir_name_str));
#line 828
        if (__cil_tmp___4) {
#line 830
          str_alloc_text(& s_dir_name_str, "/");
        }
      }
    }
  }
#line 835
  if ((unsigned int )p_dir == (unsigned int )((struct vsf_sysutil_dir *)0)) {
#line 838
    p_dir = str_opendir((struct mystr  const  *)(& s_dir_name_str));
  }
#line 841
  if (stat_cmd) {
#line 843
    use_control = 1;
#line 844
    str_append_char(& s_option_str, (char )'a');
#line 845
    vsf_cmdio_write_hyphen(p_sess, 213, "Status follows:");
  } else {
#line 849
    __cil_tmp___6 = get_remote_transfer_fd(p_sess, "Here comes the directory listing.");
#line 849
    remote_fd = __cil_tmp___6;
#line 851
    __cil_tmp___7 = vsf_sysutil_retval_is_error(remote_fd);
#line 851
    if (__cil_tmp___7) {
#line 853
      goto dir_close_out;
    }
  }
#line 856
  if ((p_sess->is_anonymous && (int )p_dir) && tunable_anon_world_readable_only) {
#line 858
    vsf_sysutil_dir_stat((struct vsf_sysutil_dir  const  *)p_dir, & s_p_dirstat);
#line 859
    __cil_tmp___8 = vsf_sysutil_statbuf_is_readable_other((struct vsf_sysutil_statbuf  const  *)s_p_dirstat);
#line 859
    if (! __cil_tmp___8) {
#line 861
      dir_allow_read = 0;
    }
  }
#line 864
  if ((unsigned int )p_dir != (unsigned int )((struct vsf_sysutil_dir *)0) && dir_allow_read) {
#line 866
    retval = vsf_ftpdataio_transfer_dir(p_sess, use_control, p_dir, (struct mystr  const  *)(& s_dir_name_str),
                                        (struct mystr  const  *)(& s_option_str),
                                        (struct mystr  const  *)(& s_filter_str),
                                        full_details);
  }
#line 870
  if (! stat_cmd) {
#line 872
    __cil_tmp___9 = vsf_ftpdataio_dispose_transfer_fd(p_sess);
#line 872
    if (__cil_tmp___9 != 1 && retval == 0) {
#line 874
      retval = -1;
    }
  }
#line 877
  if (stat_cmd) {
#line 879
    vsf_cmdio_write(p_sess, 213, "End of status");
  } else {
#line 881
    if ((unsigned int )p_dir == (unsigned int )((struct vsf_sysutil_dir *)0) || ! dir_allow_read) {
#line 883
      vsf_cmdio_write(p_sess, 226, "Transfer done (but failed to open directory).");
    } else {
#line 886
      if (retval == 0) {
#line 888
        vsf_cmdio_write(p_sess, 226, "Directory send OK.");
      } else {
#line 892
        vsf_cmdio_write(p_sess, 426, "Failure writing network stream.");
      }
    }
  }
#line 894
  check_abor(p_sess);
  dir_close_out: 
#line 896
  if (p_dir) {
#line 898
    vsf_sysutil_closedir(p_dir);
  }
#line 900
  if (! stat_cmd) {
#line 902
    port_cleanup(p_sess);
#line 903
    pasv_cleanup(p_sess);
  }
#line 905
  return;
}
}
#line 907 "postlogin.c"
static void handle_type(struct vsf_session *p_sess ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 910
  str_upper(& p_sess->ftp_arg_str);
#line 911
  __cil_tmp___1 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                 "I");
#line 911
  if (__cil_tmp___1) {
#line 911
    goto _L___1;
  } else {
#line 911
    __cil_tmp___2 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                   "L8");
#line 911
    if (__cil_tmp___2) {
      _L___1: /* CIL Label */ 
#line 911
      goto _L___0;
    } else {
#line 911
      __cil_tmp___3 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                     "L 8");
#line 911
      if (__cil_tmp___3) {
        _L___0: /* CIL Label */ 
#line 915
        p_sess->is_ascii = 0;
#line 916
        vsf_cmdio_write(p_sess, 200, "Switching to Binary mode.");
      } else {
#line 918
        __cil_tmp = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                   "A");
#line 918
        if (__cil_tmp) {
#line 918
          goto _L;
        } else {
#line 918
          __cil_tmp___0 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                         "A N");
#line 918
          if (__cil_tmp___0) {
            _L: /* CIL Label */ 
#line 921
            p_sess->is_ascii = 1;
#line 922
            vsf_cmdio_write(p_sess, 200, "Switching to ASCII mode.");
          } else {
#line 926
            vsf_cmdio_write(p_sess, 500, "Unrecognised TYPE command.");
          }
        }
      }
    }
  }
#line 928
  return;
}
}
#line 930 "postlogin.c"
static void handle_port(struct vsf_session *p_sess ) 
{ unsigned short the_port ;
  unsigned char vals[6] ;
  unsigned char const   *p_raw ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 936
  pasv_cleanup(p_sess);
#line 937
  port_cleanup(p_sess);
#line 938
  p_raw = vsf_sysutil_parse_uchar_string_sep((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                             (char )',', vals, (unsigned int )sizeof(vals));
#line 940
  if ((unsigned int )p_raw == (unsigned int )((unsigned char const   *)0)) {
#line 942
    vsf_cmdio_write(p_sess, 500, "Illegal PORT command.");
#line 943
    return;
  }
#line 945
  the_port = (unsigned short )((int )vals[4] << 8);
#line 946
  the_port = (unsigned short )((int )the_port | (int )vals[5]);
#line 947
  vsf_sysutil_sockaddr_clone(& p_sess->p_port_sockaddr, (struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 948
  vsf_sysutil_sockaddr_set_ipv4addr(p_sess->p_port_sockaddr, (unsigned char const   *)(vals));
#line 949
  vsf_sysutil_sockaddr_set_port(p_sess->p_port_sockaddr, the_port);
#line 954
  if (! tunable_port_promiscuous) {
#line 956
    __cil_tmp = vsf_sysutil_sockaddr_addr_equal((struct vsf_sysutil_sockaddr  const  *)p_sess->p_remote_addr,
                                                (struct vsf_sysutil_sockaddr  const  *)p_sess->p_port_sockaddr);
#line 956
    if (__cil_tmp) {
#line 956
      __cil_tmp___0 = vsf_sysutil_is_port_reserved(the_port);
#line 956
      if (__cil_tmp___0) {
        _L: /* CIL Label */ 
#line 960
        vsf_cmdio_write(p_sess, 500, "Illegal PORT command.");
#line 961
        port_cleanup(p_sess);
#line 962
        return;
      }
    } else {
#line 956
      goto _L;
    }
  }
#line 965
  vsf_cmdio_write(p_sess, 200, "PORT command successful. Consider using PASV.");
#line 967
  return;
}
}
#line 969 "postlogin.c"
static void handle_stor(struct vsf_session *p_sess ) 
{ 

  {
#line 972
  handle_upload_common(p_sess, 0, 0);
#line 973
  return;
}
}
#line 978 "postlogin.c"
static struct vsf_sysutil_statbuf *s_p_statbuf___0  ;
#line 979 "postlogin.c"
static struct mystr s_filename  ;
#line 975 "postlogin.c"
static void handle_upload_common(struct vsf_session *p_sess , int is_append , int is_unique ) 
{ struct mystr *p_filename ;
  struct vsf_transfer_ret trans_ret ;
  int new_file_fd ;
  int remote_fd ;
  int success ;
  int created ;
  filesize_t offset ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  struct mystr resp_str ;
  char const   *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;

  {
#line 984
  success = 0;
#line 985
  created = 0;
#line 986
  offset = p_sess->restart_pos;
#line 987
  p_sess->restart_pos = 0LL;
#line 988
  __cil_tmp = data_transfer_checks_ok(p_sess);
#line 988
  if (! __cil_tmp) {
#line 990
    return;
  }
#line 992
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 993
  p_filename = & p_sess->ftp_arg_str;
#line 994
  if (is_unique) {
#line 996
    get_unique_filename(& s_filename, (struct mystr  const  *)p_filename);
#line 997
    p_filename = & s_filename;
  }
#line 999
  vsf_log_start_entry(p_sess, 3);
#line 1000
  str_copy(& p_sess->log_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1001
  prepend_path_to_filename(& p_sess->log_str);
#line 1002
  __cil_tmp___0 = vsf_access_check_file((struct mystr  const  *)p_filename);
#line 1002
  if (! __cil_tmp___0) {
#line 1004
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1005
    return;
  }
#line 1011
  if (is_unique || (p_sess->is_anonymous && ! tunable_anon_other_write_enable)) {
#line 1013
    new_file_fd = str_create((struct mystr  const  *)p_filename);
  } else {
#line 1018
    if (! is_append && offset == 0LL) {
#line 1020
      new_file_fd = str_create_overwrite((struct mystr  const  *)p_filename);
    } else {
#line 1024
      new_file_fd = str_create_append((struct mystr  const  *)p_filename);
    }
  }
#line 1027
  __cil_tmp___1 = vsf_sysutil_retval_is_error(new_file_fd);
#line 1027
  if (__cil_tmp___1) {
#line 1029
    vsf_cmdio_write(p_sess, 553, "Could not create file.");
#line 1030
    return;
  }
#line 1032
  created = 1;
#line 1033
  vsf_sysutil_fstat(new_file_fd, & s_p_statbuf___0);
#line 1034
  __cil_tmp___2 = vsf_sysutil_statbuf_is_regfile((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___0);
#line 1034
  if (__cil_tmp___2) {
#line 1039
    vsf_sysutil_deactivate_noblock(new_file_fd);
  }
#line 1042
  if (p_sess->is_anonymous && tunable_chown_uploads) {
#line 1044
    vsf_sysutil_fchmod(new_file_fd, tunable_chown_upload_mode);
#line 1045
    if (tunable_one_process_model) {
#line 1047
      vsf_one_process_chown_upload(p_sess, new_file_fd);
    } else {
#line 1051
      vsf_two_process_chown_upload(p_sess, new_file_fd);
    }
  }
#line 1055
  if (tunable_lock_upload_files) {
#line 1057
    vsf_sysutil_lock_file_write(new_file_fd);
  }
#line 1059
  if (! is_append && offset != 0LL) {
#line 1062
    vsf_sysutil_lseek_to(new_file_fd, offset);
  }
#line 1064
  if (is_unique) {
#line 1066
    resp_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 1066
    resp_str.PRIVATE_HANDS_OFF_len = 0U;
#line 1066
    resp_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 1067
    str_alloc_text(& resp_str, "FILE: ");
#line 1068
    str_append_str(& resp_str, (struct mystr  const  *)p_filename);
#line 1069
    __cil_tmp___3 = str_getbuf((struct mystr  const  *)(& resp_str));
#line 1069
    remote_fd = get_remote_transfer_fd(p_sess, __cil_tmp___3);
#line 1070
    str_free(& resp_str);
  } else {
#line 1074
    remote_fd = get_remote_transfer_fd(p_sess, "Ok to send data.");
  }
#line 1076
  __cil_tmp___4 = vsf_sysutil_retval_is_error(remote_fd);
#line 1076
  if (__cil_tmp___4) {
#line 1078
    goto port_pasv_cleanup_out;
  }
#line 1080
  if (tunable_ascii_upload_enable && p_sess->is_ascii) {
#line 1082
    trans_ret = vsf_ftpdataio_transfer_file(p_sess, remote_fd, new_file_fd, 1, 1);
  } else {
#line 1087
    trans_ret = vsf_ftpdataio_transfer_file(p_sess, remote_fd, new_file_fd, 1, 0);
  }
#line 1090
  __cil_tmp___5 = vsf_ftpdataio_dispose_transfer_fd(p_sess);
#line 1090
  if (__cil_tmp___5 != 1 && trans_ret.retval == 0) {
#line 1092
    trans_ret.retval = -2;
  }
#line 1094
  p_sess->transfer_size = trans_ret.transferred;
#line 1095
  if (trans_ret.retval == 0) {
#line 1097
    success = 1;
#line 1098
    vsf_log_do_log(p_sess, 1);
  }
#line 1100
  if (trans_ret.retval == -1) {
#line 1102
    vsf_cmdio_write(p_sess, 451, "Failure writing to local file.");
  } else {
#line 1104
    if (trans_ret.retval == -2) {
#line 1106
      vsf_cmdio_write(p_sess, 426, "Failure reading network stream.");
    } else {
#line 1110
      vsf_cmdio_write(p_sess, 226, "File receive OK.");
    }
  }
#line 1112
  check_abor(p_sess);
  port_pasv_cleanup_out: 
#line 1114
  port_cleanup(p_sess);
#line 1115
  pasv_cleanup(p_sess);
#line 1116
  if ((tunable_delete_failed_uploads && created) && ! success) {
#line 1118
    str_unlink((struct mystr  const  *)p_filename);
  }
#line 1120
  vsf_sysutil_close(new_file_fd);
#line 1121
  return;
}
}
#line 1146 "postlogin.c"
static struct mystr s_mkd_res  ;
#line 1147 "postlogin.c"
static struct mystr s_tmp_str  ;
#line 1123 "postlogin.c"
static void handle_mkd(struct vsf_session *p_sess ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 1127
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 1128
  vsf_log_start_entry(p_sess, 4);
#line 1129
  str_copy(& p_sess->log_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1130
  prepend_path_to_filename(& p_sess->log_str);
#line 1131
  __cil_tmp = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1131
  if (! __cil_tmp) {
#line 1133
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1134
    return;
  }
#line 1137
  retval = str_mkdir((struct mystr  const  *)(& p_sess->ftp_arg_str), 511U);
#line 1138
  if (retval != 0) {
#line 1140
    vsf_cmdio_write(p_sess, 550, "Create directory operation failed.");
#line 1142
    return;
  }
#line 1144
  vsf_log_do_log(p_sess, 1);
#line 1148
  str_copy(& s_tmp_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1149
  prepend_path_to_filename(& s_tmp_str);
#line 1151
  str_replace_text(& s_tmp_str, "\"", "\"\"");
#line 1153
  str_alloc_text(& s_mkd_res, "\"");
#line 1154
  str_append_str(& s_mkd_res, (struct mystr  const  *)(& s_tmp_str));
#line 1155
  str_append_text(& s_mkd_res, "\" created");
#line 1156
  vsf_cmdio_write_str(p_sess, 257, (struct mystr  const  *)(& s_mkd_res));
#line 1158
  return;
}
}
#line 1160 "postlogin.c"
static void handle_rmd(struct vsf_session *p_sess ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 1164
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 1165
  vsf_log_start_entry(p_sess, 11);
#line 1166
  str_copy(& p_sess->log_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1167
  prepend_path_to_filename(& p_sess->log_str);
#line 1168
  __cil_tmp = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1168
  if (! __cil_tmp) {
#line 1170
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1171
    return;
  }
#line 1173
  retval = str_rmdir((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1174
  if (retval != 0) {
#line 1176
    vsf_cmdio_write(p_sess, 550, "Remove directory operation failed.");
  } else {
#line 1181
    vsf_log_do_log(p_sess, 1);
#line 1182
    vsf_cmdio_write(p_sess, 250, "Remove directory operation successful.");
  }
#line 1185
  return;
}
}
#line 1187 "postlogin.c"
static void handle_dele(struct vsf_session *p_sess ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 1191
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 1192
  vsf_log_start_entry(p_sess, 9);
#line 1193
  str_copy(& p_sess->log_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1194
  prepend_path_to_filename(& p_sess->log_str);
#line 1195
  __cil_tmp = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1195
  if (! __cil_tmp) {
#line 1197
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1198
    return;
  }
#line 1200
  retval = str_unlink((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1201
  if (retval != 0) {
#line 1203
    vsf_cmdio_write(p_sess, 550, "Delete operation failed.");
  } else {
#line 1207
    vsf_log_do_log(p_sess, 1);
#line 1208
    vsf_cmdio_write(p_sess, 250, "Delete operation successful.");
  }
#line 1210
  return;
}
}
#line 1215 "postlogin.c"
static struct mystr s_rest_str  ;
#line 1212 "postlogin.c"
static void handle_rest(struct vsf_session *p_sess ) 
{ filesize_t val ;
  filesize_t __cil_tmp ;

  {
#line 1216
  __cil_tmp = str_a_to_filesize_t((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1216
  val = __cil_tmp;
#line 1217
  if (val < 0LL) {
#line 1219
    val = 0LL;
  }
#line 1221
  p_sess->restart_pos = val;
#line 1222
  str_alloc_text(& s_rest_str, "Restart position accepted (");
#line 1223
  str_append_filesize_t(& s_rest_str, val);
#line 1224
  str_append_text(& s_rest_str, ").");
#line 1225
  vsf_cmdio_write_str(p_sess, 350, (struct mystr  const  *)(& s_rest_str));
#line 1226
  return;
}
}
#line 1231 "postlogin.c"
static struct vsf_sysutil_statbuf *p_statbuf  ;
#line 1228 "postlogin.c"
static void handle_rnfr(struct vsf_session *p_sess ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 1234
  str_free(& p_sess->rnfr_filename_str);
#line 1235
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 1236
  __cil_tmp = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1236
  if (! __cil_tmp) {
#line 1238
    vsf_log_start_entry(p_sess, 10);
#line 1239
    str_copy(& p_sess->log_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1240
    prepend_path_to_filename(& p_sess->log_str);
#line 1241
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1242
    return;
  }
#line 1245
  retval = str_stat((struct mystr  const  *)(& p_sess->ftp_arg_str), & p_statbuf);
#line 1246
  if (retval == 0) {
#line 1249
    str_copy(& p_sess->rnfr_filename_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1250
    vsf_cmdio_write(p_sess, 350, "Ready for RNTO.");
  } else {
#line 1254
    vsf_log_start_entry(p_sess, 10);
#line 1255
    str_copy(& p_sess->log_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1256
    prepend_path_to_filename(& p_sess->log_str);
#line 1257
    vsf_cmdio_write(p_sess, 550, "RNFR command failed.");
  }
#line 1259
  return;
}
}
#line 1264 "postlogin.c"
static struct mystr s_tmp_str___0  ;
#line 1261 "postlogin.c"
static void handle_rnto(struct vsf_session *p_sess ) 
{ int retval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 1267
  __cil_tmp = str_isempty((struct mystr  const  *)(& p_sess->rnfr_filename_str));
#line 1267
  if (__cil_tmp) {
#line 1269
    vsf_cmdio_write(p_sess, 503, "RNFR required first.");
#line 1271
    return;
  }
#line 1273
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 1274
  vsf_log_start_entry(p_sess, 10);
#line 1275
  str_copy(& p_sess->log_str, (struct mystr  const  *)(& p_sess->rnfr_filename_str));
#line 1276
  prepend_path_to_filename(& p_sess->log_str);
#line 1277
  str_append_char(& p_sess->log_str, (char )' ');
#line 1278
  str_copy(& s_tmp_str___0, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1279
  prepend_path_to_filename(& s_tmp_str___0);
#line 1280
  str_append_str(& p_sess->log_str, (struct mystr  const  *)(& s_tmp_str___0));
#line 1281
  __cil_tmp___0 = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1281
  if (! __cil_tmp___0) {
#line 1283
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1284
    return;
  }
#line 1289
  retval = str_rename((struct mystr  const  *)(& p_sess->rnfr_filename_str), (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1291
  str_free(& p_sess->rnfr_filename_str);
#line 1292
  if (retval == 0) {
#line 1294
    vsf_log_do_log(p_sess, 1);
#line 1295
    vsf_cmdio_write(p_sess, 250, "Rename successful.");
  } else {
#line 1299
    vsf_cmdio_write(p_sess, 550, "Rename failed.");
  }
#line 1301
  return;
}
}
#line 1303 "postlogin.c"
static void handle_nlst(struct vsf_session *p_sess ) 
{ 

  {
#line 1306
  handle_dir_common(p_sess, 0, 0);
#line 1307
  return;
}
}
#line 1312 "postlogin.c"
static struct mystr s_tmp_str___1  ;
#line 1309 "postlogin.c"
static void prepend_path_to_filename(struct mystr *p_str ) 
{ int __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  char __cil_tmp___1 ;
  int __cil_tmp___2 ;
  char __cil_tmp___3 ;

  {
#line 1316
  str_empty(& s_tmp_str___1);
#line 1317
  __cil_tmp___2 = str_isempty((struct mystr  const  *)p_str);
#line 1317
  if (__cil_tmp___2) {
#line 1317
    goto _L___0;
  } else {
#line 1317
    __cil_tmp___3 = str_get_char_at((struct mystr  const  *)p_str, 0U);
#line 1317
    if ((int )__cil_tmp___3 != 47) {
      _L___0: /* CIL Label */ 
#line 1319
      str_getcwd(& s_tmp_str___1);
#line 1321
      __cil_tmp = str_isempty((struct mystr  const  *)(& s_tmp_str___1));
#line 1321
      if (__cil_tmp) {
#line 1321
        goto _L;
      } else {
#line 1321
        __cil_tmp___0 = str_getlen((struct mystr  const  *)(& s_tmp_str___1));
#line 1321
        __cil_tmp___1 = str_get_char_at((struct mystr  const  *)(& s_tmp_str___1),
                                        __cil_tmp___0 - 1U);
#line 1321
        if ((int )__cil_tmp___1 != 47) {
          _L: /* CIL Label */ 
#line 1324
          str_append_char(& s_tmp_str___1, (char )'/');
        }
      }
    }
  }
#line 1327
  str_append_str(& s_tmp_str___1, (struct mystr  const  *)p_str);
#line 1328
  str_copy(p_str, (struct mystr  const  *)(& s_tmp_str___1));
#line 1329
  return;
}
}
#line 1332 "postlogin.c"
static void handle_sigurg(void *p_private ) 
{ struct mystr async_cmd_str ;
  struct mystr async_arg_str ;
  struct mystr real_cmd_str ;
  unsigned int len ;
  struct vsf_session *p_sess ;
  int __cil_tmp ;

  {
#line 1335
  async_cmd_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 1335
  async_cmd_str.PRIVATE_HANDS_OFF_len = 0U;
#line 1335
  async_cmd_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 1336
  async_arg_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 1336
  async_arg_str.PRIVATE_HANDS_OFF_len = 0U;
#line 1336
  async_arg_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 1337
  real_cmd_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 1337
  real_cmd_str.PRIVATE_HANDS_OFF_len = 0U;
#line 1337
  real_cmd_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 1339
  p_sess = (struct vsf_session *)p_private;
#line 1341
  if (p_sess->data_fd == -1) {
#line 1343
    return;
  }
#line 1346
  vsf_cmdio_get_cmd_and_arg(p_sess, & async_cmd_str, & async_arg_str, 0);
#line 1351
  len = str_getlen((struct mystr  const  *)(& async_cmd_str));
#line 1352
  if (len >= 4U) {
#line 1354
    str_right((struct mystr  const  *)(& async_cmd_str), & real_cmd_str, len - 4U);
  }
#line 1356
  __cil_tmp = str_equal_text((struct mystr  const  *)(& real_cmd_str), "ABOR");
#line 1356
  if (__cil_tmp) {
#line 1358
    p_sess->abor_received = 1;
#line 1363
    vsf_sysutil_shutdown_failok(p_sess->data_fd);
  } else {
#line 1368
    vsf_cmdio_write(p_sess, 500, "Unknown command.");
  }
#line 1370
  str_free(& async_cmd_str);
#line 1371
  str_free(& async_arg_str);
#line 1372
  str_free(& real_cmd_str);
#line 1373
  return;
}
}
#line 1375 "postlogin.c"
static int get_remote_transfer_fd(struct vsf_session *p_sess , char const   *p_status_msg ) 
{ int remote_fd ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 1379
  __cil_tmp = pasv_active(p_sess);
#line 1379
  if (__cil_tmp) {
    _L: /* CIL Label */ ;
  } else {
#line 1379
    __cil_tmp___0 = port_active(p_sess);
#line 1379
    if (__cil_tmp___0) {
#line 1379
      goto _L;
    } else {
#line 1381
      bug("neither PORT nor PASV active in get_remote_transfer_fd");
    }
  }
#line 1383
  p_sess->abor_received = 0;
#line 1384
  __cil_tmp___1 = pasv_active(p_sess);
#line 1384
  if (__cil_tmp___1) {
#line 1386
    remote_fd = vsf_ftpdataio_get_pasv_fd(p_sess);
  } else {
#line 1390
    remote_fd = vsf_ftpdataio_get_port_fd(p_sess);
  }
#line 1392
  __cil_tmp___2 = vsf_sysutil_retval_is_error(remote_fd);
#line 1392
  if (__cil_tmp___2) {
#line 1394
    return (remote_fd);
  }
#line 1396
  vsf_cmdio_write(p_sess, 150, p_status_msg);
#line 1397
  __cil_tmp___3 = vsf_ftpdataio_post_mark_connect(p_sess);
#line 1397
  if (__cil_tmp___3 != 1) {
#line 1399
    vsf_ftpdataio_dispose_transfer_fd(p_sess);
#line 1400
    return (-1);
  }
#line 1402
  return (remote_fd);
}
}
#line 1405 "postlogin.c"
static void check_abor(struct vsf_session *p_sess ) 
{ 

  {
#line 1409
  if (p_sess->abor_received) {
#line 1411
    p_sess->abor_received = 0;
#line 1412
    vsf_cmdio_write(p_sess, 226, "ABOR successful.");
  }
#line 1414
  return;
}
}
#line 1424 "postlogin.c"
static struct vsf_sysutil_statbuf *s_p_statbuf___1  ;
#line 1439 "postlogin.c"
static struct mystr s_size_res_str  ;
#line 1416 "postlogin.c"
static void handle_size(struct vsf_session *p_sess ) 
{ int retval ;
  int __cil_tmp ;
  filesize_t __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 1426
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 1427
  __cil_tmp = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1427
  if (! __cil_tmp) {
#line 1429
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1430
    return;
  }
#line 1432
  retval = str_stat((struct mystr  const  *)(& p_sess->ftp_arg_str), & s_p_statbuf___1);
#line 1433
  if (retval != 0) {
#line 1433
    goto _L;
  } else {
#line 1433
    __cil_tmp___1 = vsf_sysutil_statbuf_is_regfile((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___1);
#line 1433
    if (__cil_tmp___1) {
#line 1440
      __cil_tmp___0 = vsf_sysutil_statbuf_get_size((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___1);
#line 1440
      str_alloc_filesize_t(& s_size_res_str, __cil_tmp___0);
#line 1442
      vsf_cmdio_write_str(p_sess, 213, (struct mystr  const  *)(& s_size_res_str));
    } else {
      _L: /* CIL Label */ 
#line 1435
      vsf_cmdio_write(p_sess, 550, "Could not get file size.");
    }
  }
#line 1444
  return;
}
}
#line 1449 "postlogin.c"
static struct mystr s_site_args_str  ;
#line 1446 "postlogin.c"
static void handle_site(struct vsf_session *p_sess ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 1451
  str_split_char(& p_sess->ftp_arg_str, & s_site_args_str, (char )' ');
#line 1452
  str_upper(& p_sess->ftp_arg_str);
#line 1453
  if (tunable_write_enable && tunable_chmod_enable) {
#line 1453
    __cil_tmp___1 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                   "CHMOD");
#line 1453
    if (__cil_tmp___1) {
#line 1457
      handle_site_chmod(p_sess, & s_site_args_str);
    } else {
#line 1453
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1459
    __cil_tmp___0 = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                   "UMASK");
#line 1459
    if (__cil_tmp___0) {
#line 1461
      handle_site_umask(p_sess, & s_site_args_str);
    } else {
#line 1463
      __cil_tmp = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                 "HELP");
#line 1463
      if (__cil_tmp) {
#line 1465
        vsf_cmdio_write(p_sess, 214, "CHMOD UMASK HELP");
      } else {
#line 1469
        vsf_cmdio_write(p_sess, 500, "Unknown SITE command.");
      }
    }
  }
#line 1471
  return;
}
}
#line 1476 "postlogin.c"
static struct mystr s_chmod_file_str  ;
#line 1473 "postlogin.c"
static void handle_site_chmod(struct vsf_session *p_sess , struct mystr *p_arg_str ) 
{ unsigned int perms___0 ;
  int retval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 1479
  __cil_tmp = str_isempty((struct mystr  const  *)p_arg_str);
#line 1479
  if (__cil_tmp) {
#line 1481
    vsf_cmdio_write(p_sess, 500, "SITE CHMOD needs 2 arguments.");
#line 1482
    return;
  }
#line 1484
  str_split_char(p_arg_str, & s_chmod_file_str, (char )' ');
#line 1485
  __cil_tmp___0 = str_isempty((struct mystr  const  *)(& s_chmod_file_str));
#line 1485
  if (__cil_tmp___0) {
#line 1487
    vsf_cmdio_write(p_sess, 500, "SITE CHMOD needs 2 arguments.");
#line 1488
    return;
  }
#line 1490
  resolve_tilde(& s_chmod_file_str, p_sess);
#line 1491
  vsf_log_start_entry(p_sess, 12);
#line 1492
  str_copy(& p_sess->log_str, (struct mystr  const  *)(& s_chmod_file_str));
#line 1493
  prepend_path_to_filename(& p_sess->log_str);
#line 1494
  str_append_char(& p_sess->log_str, (char )' ');
#line 1495
  str_append_str(& p_sess->log_str, (struct mystr  const  *)p_arg_str);
#line 1496
  __cil_tmp___1 = vsf_access_check_file((struct mystr  const  *)(& s_chmod_file_str));
#line 1496
  if (! __cil_tmp___1) {
#line 1498
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1499
    return;
  }
#line 1502
  perms___0 = str_octal_to_uint((struct mystr  const  *)p_arg_str);
#line 1503
  retval = str_chmod((struct mystr  const  *)(& s_chmod_file_str), perms___0);
#line 1504
  __cil_tmp___2 = vsf_sysutil_retval_is_error(retval);
#line 1504
  if (__cil_tmp___2) {
#line 1506
    vsf_cmdio_write(p_sess, 550, "SITE CHMOD command failed.");
  } else {
#line 1510
    vsf_log_do_log(p_sess, 1);
#line 1511
    vsf_cmdio_write(p_sess, 200, "SITE CHMOD command ok.");
  }
#line 1513
  return;
}
}
#line 1518 "postlogin.c"
static struct mystr s_umask_resp_str  ;
#line 1515 "postlogin.c"
static void handle_site_umask(struct vsf_session *p_sess , struct mystr *p_arg_str ) 
{ unsigned int __cil_tmp ;
  char const   *__cil_tmp___0 ;
  unsigned int new_umask ;
  unsigned int __cil_tmp___1 ;
  unsigned int __cil_tmp___2 ;
  char const   *__cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 1519
  __cil_tmp___4 = str_isempty((struct mystr  const  *)p_arg_str);
#line 1519
  if (__cil_tmp___4) {
#line 1522
    str_alloc_text(& s_umask_resp_str, "Your current UMASK is ");
#line 1523
    __cil_tmp = vsf_sysutil_get_umask();
#line 1523
    __cil_tmp___0 = vsf_sysutil_uint_to_octal(__cil_tmp);
#line 1523
    str_append_text(& s_umask_resp_str, __cil_tmp___0);
  } else {
#line 1529
    __cil_tmp___1 = str_octal_to_uint((struct mystr  const  *)p_arg_str);
#line 1529
    new_umask = __cil_tmp___1;
#line 1530
    vsf_sysutil_set_umask(new_umask);
#line 1531
    str_alloc_text(& s_umask_resp_str, "UMASK set to ");
#line 1532
    __cil_tmp___2 = vsf_sysutil_get_umask();
#line 1532
    __cil_tmp___3 = vsf_sysutil_uint_to_octal(__cil_tmp___2);
#line 1532
    str_append_text(& s_umask_resp_str, __cil_tmp___3);
  }
#line 1535
  vsf_cmdio_write_str(p_sess, 200, (struct mystr  const  *)(& s_umask_resp_str));
#line 1536
  return;
}
}
#line 1538 "postlogin.c"
static void handle_appe(struct vsf_session *p_sess ) 
{ 

  {
#line 1541
  handle_upload_common(p_sess, 1, 0);
#line 1542
  return;
}
}
#line 1547 "postlogin.c"
static struct mystr s_filename_str  ;
#line 1548 "postlogin.c"
static struct vsf_sysutil_statbuf *s_p_statbuf___2  ;
#line 1608 "postlogin.c"
static struct mystr s_mdtm_res_str  ;
#line 1544 "postlogin.c"
static void handle_mdtm(struct vsf_session *p_sess ) 
{ int do_write ;
  long modtime ;
  struct str_locate_result loc ;
  struct str_locate_result __cil_tmp ;
  int retval ;
  int __cil_tmp___0 ;
  char __cil_tmp___1 ;
  char __cil_tmp___2 ;
  int __cil_tmp___3 ;
  char const   *__cil_tmp___4 ;
  int __cil_tmp___5 ;
  char const   *__cil_tmp___6 ;
  int __cil_tmp___7 ;
  char const   *__cil_tmp___8 ;
  int __cil_tmp___9 ;

  {
#line 1549
  do_write = 0;
#line 1550
  modtime = 0L;
#line 1551
  __cil_tmp = str_locate_char((struct mystr  const  *)(& p_sess->ftp_arg_str), (char )' ');
#line 1551
  loc = __cil_tmp;
#line 1552
  __cil_tmp___0 = str_stat((struct mystr  const  *)(& p_sess->ftp_arg_str), & s_p_statbuf___2);
#line 1552
  retval = __cil_tmp___0;
#line 1553
  if ((tunable_mdtm_write && retval != 0) && loc.found) {
#line 1553
    __cil_tmp___2 = str_get_char_at((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                    0U);
#line 1553
    __cil_tmp___3 = vsf_sysutil_isdigit((int )__cil_tmp___2);
#line 1553
    if (__cil_tmp___3) {
#line 1556
      if (loc.index == 8U || loc.index == 14U) {
#line 1556
        goto _L;
      } else {
#line 1556
        if (loc.index > 15U) {
#line 1556
          __cil_tmp___1 = str_get_char_at((struct mystr  const  *)(& p_sess->ftp_arg_str),
                                          14U);
#line 1556
          if ((int )__cil_tmp___1 == 46) {
            _L: /* CIL Label */ 
#line 1559
            do_write = 1;
          } else {
#line 1556
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ ;
        }
      }
    } else {
#line 1553
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ ;
  }
#line 1562
  if (do_write != 0) {
#line 1564
    str_split_char(& p_sess->ftp_arg_str, & s_filename_str, (char )' ');
#line 1565
    __cil_tmp___4 = str_getbuf((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1565
    modtime = vsf_sysutil_parse_time(__cil_tmp___4);
#line 1566
    str_copy(& p_sess->ftp_arg_str, (struct mystr  const  *)(& s_filename_str));
  }
#line 1568
  resolve_tilde(& p_sess->ftp_arg_str, p_sess);
#line 1569
  __cil_tmp___5 = vsf_access_check_file((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1569
  if (! __cil_tmp___5) {
#line 1571
    vsf_cmdio_write(p_sess, 550, "Permission denied.");
#line 1572
    return;
  }
#line 1574
  if ((do_write && tunable_write_enable) && (tunable_anon_other_write_enable || ! p_sess->is_anonymous)) {
#line 1577
    retval = str_stat((struct mystr  const  *)(& p_sess->ftp_arg_str), & s_p_statbuf___2);
#line 1578
    if (retval != 0) {
#line 1578
      goto _L___2;
    } else {
#line 1578
      __cil_tmp___7 = vsf_sysutil_statbuf_is_regfile((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___2);
#line 1578
      if (__cil_tmp___7) {
#line 1585
        __cil_tmp___6 = str_getbuf((struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1585
        retval = vsf_sysutil_setmodtime(__cil_tmp___6, modtime, tunable_use_localtime);
#line 1587
        if (retval != 0) {
#line 1589
          vsf_cmdio_write(p_sess, 550, "Could not set file modification time.");
        } else {
#line 1594
          vsf_cmdio_write(p_sess, 213, "File modification time set.");
        }
      } else {
        _L___2: /* CIL Label */ 
#line 1580
        vsf_cmdio_write(p_sess, 550, "Could not set file modification time.");
      }
    }
  } else {
#line 1601
    if (retval != 0) {
#line 1601
      goto _L___3;
    } else {
#line 1601
      __cil_tmp___9 = vsf_sysutil_statbuf_is_regfile((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___2);
#line 1601
      if (__cil_tmp___9) {
#line 1609
        __cil_tmp___8 = vsf_sysutil_statbuf_get_numeric_date((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___2,
                                                             tunable_use_localtime);
#line 1609
        str_alloc_text(& s_mdtm_res_str, __cil_tmp___8);
#line 1612
        vsf_cmdio_write_str(p_sess, 213, (struct mystr  const  *)(& s_mdtm_res_str));
      } else {
        _L___3: /* CIL Label */ 
#line 1603
        vsf_cmdio_write(p_sess, 550, "Could not get file modification time.");
      }
    }
  }
#line 1615
  return;
}
}
#line 1620 "postlogin.c"
static struct mystr s_part1_str  ;
#line 1621 "postlogin.c"
static struct mystr s_part2_str  ;
#line 1617 "postlogin.c"
static void handle_eprt(struct vsf_session *p_sess ) 
{ int proto ;
  int port ;
  unsigned char const   *p_raw_addr ;
  int is_ipv6 ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 1625
  __cil_tmp = vsf_sysutil_sockaddr_is_ipv6((struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 1625
  is_ipv6 = __cil_tmp;
#line 1626
  port_cleanup(p_sess);
#line 1627
  pasv_cleanup(p_sess);
#line 1628
  str_copy(& s_part1_str, (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1629
  str_split_char(& s_part1_str, & s_part2_str, (char )'|');
#line 1630
  __cil_tmp___0 = str_isempty((struct mystr  const  *)(& s_part1_str));
#line 1630
  if (! __cil_tmp___0) {
#line 1632
    goto bad_eprt;
  }
#line 1635
  str_split_char(& s_part2_str, & s_part1_str, (char )'|');
#line 1636
  proto = str_atoi((struct mystr  const  *)(& s_part2_str));
#line 1637
  if ((proto < 1 || proto > 2) || (! is_ipv6 && proto == 2)) {
#line 1639
    vsf_cmdio_write(p_sess, 500, "Bad EPRT protocol.");
#line 1640
    return;
  }
#line 1643
  str_split_char(& s_part1_str, & s_part2_str, (char )'|');
#line 1644
  if (proto == 2) {
#line 1646
    p_raw_addr = vsf_sysutil_parse_ipv6((struct mystr  const  *)(& s_part1_str));
  } else {
#line 1650
    p_raw_addr = vsf_sysutil_parse_ipv4((struct mystr  const  *)(& s_part1_str));
  }
#line 1652
  if (! p_raw_addr) {
#line 1654
    goto bad_eprt;
  }
#line 1657
  str_split_char(& s_part2_str, & s_part1_str, (char )'|');
#line 1658
  __cil_tmp___1 = str_isempty((struct mystr  const  *)(& s_part1_str));
#line 1658
  if (__cil_tmp___1) {
#line 1658
    __cil_tmp___2 = str_isempty((struct mystr  const  *)(& s_part2_str));
#line 1658
    if (__cil_tmp___2) {
      _L: /* CIL Label */ 
#line 1660
      goto bad_eprt;
    }
  } else {
#line 1658
    goto _L;
  }
#line 1662
  port = str_atoi((struct mystr  const  *)(& s_part2_str));
#line 1663
  if (port < 0 || port > 65535) {
#line 1665
    goto bad_eprt;
  }
#line 1667
  vsf_sysutil_sockaddr_clone(& p_sess->p_port_sockaddr, (struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 1668
  if (proto == 2) {
#line 1670
    vsf_sysutil_sockaddr_set_ipv6addr(p_sess->p_port_sockaddr, p_raw_addr);
  } else {
#line 1674
    vsf_sysutil_sockaddr_set_ipv4addr(p_sess->p_port_sockaddr, p_raw_addr);
  }
#line 1676
  vsf_sysutil_sockaddr_set_port(p_sess->p_port_sockaddr, (unsigned short )port);
#line 1681
  if (! tunable_port_promiscuous) {
#line 1683
    __cil_tmp___3 = vsf_sysutil_sockaddr_addr_equal((struct vsf_sysutil_sockaddr  const  *)p_sess->p_remote_addr,
                                                    (struct vsf_sysutil_sockaddr  const  *)p_sess->p_port_sockaddr);
#line 1683
    if (__cil_tmp___3) {
#line 1683
      __cil_tmp___4 = vsf_sysutil_is_port_reserved((unsigned short )port);
#line 1683
      if (__cil_tmp___4) {
        _L___0: /* CIL Label */ 
#line 1687
        vsf_cmdio_write(p_sess, 500, "Illegal EPRT command.");
#line 1688
        port_cleanup(p_sess);
#line 1689
        return;
      }
    } else {
#line 1683
      goto _L___0;
    }
  }
#line 1692
  vsf_cmdio_write(p_sess, 200, "EPRT command successful. Consider using EPSV.");
#line 1694
  return;
  bad_eprt: 
#line 1696
  vsf_cmdio_write(p_sess, 500, "Bad EPRT command.");
#line 1697
  return;
}
}
#line 1700 "postlogin.c"
static void handle_help(struct vsf_session *p_sess ) 
{ 

  {
#line 1703
  vsf_cmdio_write_hyphen(p_sess, 214, "The following commands are recognized.");
#line 1705
  vsf_cmdio_write_raw(p_sess, " ABOR ACCT ALLO APPE CDUP CWD  DELE EPRT EPSV FEAT HELP LIST MDTM MKD\r\n");
#line 1707
  vsf_cmdio_write_raw(p_sess, " MODE NLST NOOP OPTS PASS PASV PORT PWD  QUIT REIN REST RETR RMD  RNFR\r\n");
#line 1709
  vsf_cmdio_write_raw(p_sess, " RNTO SITE SIZE SMNT STAT STOR STOU STRU SYST TYPE USER XCUP XCWD XMKD\r\n");
#line 1711
  vsf_cmdio_write_raw(p_sess, " XPWD XRMD\r\n");
#line 1713
  vsf_cmdio_write(p_sess, 214, "Help OK.");
#line 1714
  return;
}
}
#line 1716 "postlogin.c"
static void handle_stou(struct vsf_session *p_sess ) 
{ 

  {
#line 1719
  handle_upload_common(p_sess, 0, 1);
#line 1720
  return;
}
}
#line 1728 "postlogin.c"
static struct vsf_sysutil_statbuf *s_p_statbuf___3  ;
#line 1722 "postlogin.c"
static void get_unique_filename(struct mystr *p_outstr , struct mystr  const  *p_base_str ) 
{ unsigned int suffix ;
  int retval ;
  int __cil_tmp ;

  {
#line 1729
  suffix = 1U;
#line 1731
  while (1) {
#line 1733
    str_copy(p_outstr, p_base_str);
#line 1734
    str_append_char(p_outstr, (char )'.');
#line 1735
    str_append_ulong(p_outstr, (unsigned long )suffix);
#line 1736
    retval = str_stat((struct mystr  const  *)p_outstr, & s_p_statbuf___3);
#line 1737
    __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 1737
    if (__cil_tmp) {
#line 1739
      return;
    }
#line 1741
    suffix ++;
  }
}
}
#line 1745 "postlogin.c"
static void handle_stat(struct vsf_session *p_sess ) 
{ char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  char const   *__cil_tmp___2 ;
  char const   *__cil_tmp___3 ;

  {
#line 1748
  vsf_cmdio_write_hyphen(p_sess, 211, "FTP server status:");
#line 1749
  vsf_cmdio_write_raw(p_sess, "     Connected to ");
#line 1750
  __cil_tmp = str_getbuf((struct mystr  const  *)(& p_sess->remote_ip_str));
#line 1750
  vsf_cmdio_write_raw(p_sess, __cil_tmp);
#line 1751
  vsf_cmdio_write_raw(p_sess, "\r\n");
#line 1752
  vsf_cmdio_write_raw(p_sess, "     Logged in as ");
#line 1753
  __cil_tmp___0 = str_getbuf((struct mystr  const  *)(& p_sess->user_str));
#line 1753
  vsf_cmdio_write_raw(p_sess, __cil_tmp___0);
#line 1754
  vsf_cmdio_write_raw(p_sess, "\r\n");
#line 1755
  vsf_cmdio_write_raw(p_sess, "     TYPE: ");
#line 1756
  if (p_sess->is_ascii) {
#line 1758
    vsf_cmdio_write_raw(p_sess, "ASCII\r\n");
  } else {
#line 1762
    vsf_cmdio_write_raw(p_sess, "BINARY\r\n");
  }
#line 1764
  if (p_sess->bw_rate_max == 0U) {
#line 1766
    vsf_cmdio_write_raw(p_sess, "     No session bandwidth limit\r\n");
  } else {
#line 1770
    vsf_cmdio_write_raw(p_sess, "     Session bandwidth limit in byte/s is ");
#line 1771
    __cil_tmp___1 = vsf_sysutil_ulong_to_str((unsigned long )p_sess->bw_rate_max);
#line 1771
    vsf_cmdio_write_raw(p_sess, __cil_tmp___1);
#line 1772
    vsf_cmdio_write_raw(p_sess, "\r\n");
  }
#line 1774
  if (tunable_idle_session_timeout == 0U) {
#line 1776
    vsf_cmdio_write_raw(p_sess, "     No session timeout\r\n");
  } else {
#line 1780
    vsf_cmdio_write_raw(p_sess, "     Session timeout in seconds is ");
#line 1781
    __cil_tmp___2 = vsf_sysutil_ulong_to_str((unsigned long )tunable_idle_session_timeout);
#line 1781
    vsf_cmdio_write_raw(p_sess, __cil_tmp___2);
#line 1783
    vsf_cmdio_write_raw(p_sess, "\r\n");
  }
#line 1785
  if (p_sess->control_use_ssl) {
#line 1787
    vsf_cmdio_write_raw(p_sess, "     Control connection is encrypted\r\n");
  } else {
#line 1791
    vsf_cmdio_write_raw(p_sess, "     Control connection is plain text\r\n");
  }
#line 1793
  if (p_sess->data_use_ssl) {
#line 1795
    vsf_cmdio_write_raw(p_sess, "     Data connections will be encrypted\r\n");
  } else {
#line 1799
    vsf_cmdio_write_raw(p_sess, "     Data connections will be plain text\r\n");
  }
#line 1801
  if (p_sess->num_clients > 0U) {
#line 1803
    vsf_cmdio_write_raw(p_sess, "     At session startup, client count was ");
#line 1804
    __cil_tmp___3 = vsf_sysutil_ulong_to_str((unsigned long )p_sess->num_clients);
#line 1804
    vsf_cmdio_write_raw(p_sess, __cil_tmp___3);
#line 1805
    vsf_cmdio_write_raw(p_sess, "\r\n");
  }
#line 1807
  vsf_cmdio_write_raw(p_sess, "     vsFTPd 2.0.7 - secure, fast, stable\r\n");
#line 1809
  vsf_cmdio_write(p_sess, 211, "End of status");
#line 1810
  return;
}
}
#line 1812 "postlogin.c"
static void handle_stat_file(struct vsf_session *p_sess ) 
{ 

  {
#line 1815
  handle_dir_common(p_sess, 1, 1);
#line 1816
  return;
}
}
#line 1818 "postlogin.c"
static int data_transfer_checks_ok(struct vsf_session *p_sess ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 1821
  __cil_tmp = pasv_active(p_sess);
#line 1821
  if (__cil_tmp) {
    _L: /* CIL Label */ ;
  } else {
#line 1821
    __cil_tmp___0 = port_active(p_sess);
#line 1821
    if (__cil_tmp___0) {
#line 1821
      goto _L;
    } else {
#line 1823
      vsf_cmdio_write(p_sess, 425, "Use PORT or PASV first.");
#line 1824
      return (0);
    }
  }
#line 1826
  if ((tunable_ssl_enable && ! p_sess->data_use_ssl) && ((tunable_force_local_data_ssl && ! p_sess->is_anonymous) || (tunable_force_anon_data_ssl && p_sess->is_anonymous))) {
#line 1830
    vsf_cmdio_write(p_sess, 522, "Data connections must be encrypted.");
#line 1832
    return (0);
  }
#line 1834
  return (1);
}
}
#line 1843 "postlogin.c"
static struct mystr s_rhs_str___0  ;
#line 1852 "postlogin.c"
static struct mystr s_user_str  ;
#line 1837 "postlogin.c"
static void resolve_tilde(struct mystr *p_str , struct vsf_session *p_sess ) 
{ unsigned int len ;
  unsigned int __cil_tmp ;
  struct vsf_sysutil_user *p_user ;
  char const   *__cil_tmp___0 ;
  int __cil_tmp___1 ;
  char __cil_tmp___2 ;
  char __cil_tmp___3 ;

  {
#line 1840
  __cil_tmp = str_getlen((struct mystr  const  *)p_str);
#line 1840
  len = __cil_tmp;
#line 1841
  if (len > 0U) {
#line 1841
    __cil_tmp___3 = str_get_char_at((struct mystr  const  *)p_str, 0U);
#line 1841
    if ((int )__cil_tmp___3 == 126) {
#line 1844
      if (len == 1U) {
#line 1844
        goto _L;
      } else {
#line 1844
        __cil_tmp___2 = str_get_char_at((struct mystr  const  *)p_str, 1U);
#line 1844
        if ((int )__cil_tmp___2 == 47) {
          _L: /* CIL Label */ 
#line 1846
          str_split_char(p_str, & s_rhs_str___0, (char )'~');
#line 1847
          str_copy(p_str, (struct mystr  const  *)(& p_sess->home_str));
#line 1848
          str_append_str(p_str, (struct mystr  const  *)(& s_rhs_str___0));
        } else {
#line 1850
          if (tunable_tilde_user_enable && len > 1U) {
#line 1854
            str_copy(& s_rhs_str___0, (struct mystr  const  *)p_str);
#line 1855
            str_split_char(& s_rhs_str___0, & s_user_str, (char )'~');
#line 1856
            str_split_char(& s_user_str, & s_rhs_str___0, (char )'/');
#line 1857
            p_user = str_getpwnam((struct mystr  const  *)(& s_user_str));
#line 1858
            if ((unsigned int )p_user != (unsigned int )((struct vsf_sysutil_user *)0)) {
#line 1860
              __cil_tmp___0 = vsf_sysutil_user_get_homedir((struct vsf_sysutil_user  const  *)p_user);
#line 1860
              str_alloc_text(p_str, __cil_tmp___0);
#line 1861
              __cil_tmp___1 = str_isempty((struct mystr  const  *)(& s_rhs_str___0));
#line 1861
              if (! __cil_tmp___1) {
#line 1863
                str_append_char(p_str, (char )'/');
#line 1864
                str_append_str(p_str, (struct mystr  const  *)(& s_rhs_str___0));
              }
            }
          }
        }
      }
    } else {
#line 1841
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 1869
  return;
}
}
#line 1871 "postlogin.c"
static void handle_logged_in_user(struct vsf_session *p_sess ) 
{ int __cil_tmp ;

  {
#line 1873
  if (p_sess->is_anonymous) {
#line 1875
    vsf_cmdio_write(p_sess, 530, "Can\'t change from guest user.");
  } else {
#line 1877
    __cil_tmp = str_equal((struct mystr  const  *)(& p_sess->user_str), (struct mystr  const  *)(& p_sess->ftp_arg_str));
#line 1877
    if (__cil_tmp) {
#line 1879
      vsf_cmdio_write(p_sess, 331, "Any password will do.");
    } else {
#line 1883
      vsf_cmdio_write(p_sess, 530, "Can\'t change to another user.");
    }
  }
#line 1885
  return;
}
}
#line 1887 "postlogin.c"
static void handle_logged_in_pass(struct vsf_session *p_sess ) 
{ 

  {
#line 1889
  vsf_cmdio_write(p_sess, 230, "Already logged in.");
#line 1890
  return;
}
}
#line 1 "cil-cEU84no8.o"
#pragma merger(0,"/tmp/cil-DfjsliNZ.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 13 "privsock.h"
void priv_sock_init(struct vsf_session *p_sess ) ;
#line 22
void priv_sock_send_cmd(int fd , char cmd ) ;
#line 31
void priv_sock_send_str(int fd , struct mystr  const  *p_str ) ;
#line 41
char priv_sock_get_result(int fd ) ;
#line 51
char priv_sock_get_cmd(int fd ) ;
#line 60
void priv_sock_get_str(int fd , struct mystr *p_dest ) ;
#line 69
void priv_sock_send_result(int fd , char res ) ;
#line 78
void priv_sock_send_fd(int fd , int send_fd ) ;
#line 88
int priv_sock_recv_fd(int fd ) ;
#line 97
void priv_sock_send_int(int fd , int the_int ) ;
#line 107
int priv_sock_get_int(int fd ) ;
#line 38 "netstr.h"
int str_netfd_read(struct mystr *p_str , int fd , unsigned int len ) ;
#line 51
int str_netfd_write(struct mystr  const  *p_str , int fd ) ;
#line 103 "sysutil.h"
int vsf_sysutil_read_loop(int fd , void *p_buf , unsigned int size ) ;
#line 239
struct vsf_sysutil_socketpair_retval vsf_sysutil_unix_stream_socketpair(void) ;
#line 55 "sysdeputil.h"
void vsf_sysutil_send_fd(int sock_fd , int send_fd ) ;
#line 56
int vsf_sysutil_recv_fd(int sock_fd ) ;
#line 23 "privsock.c"
void priv_sock_init(struct vsf_session *p_sess ) 
{ struct vsf_sysutil_socketpair_retval retval ;
  struct vsf_sysutil_socketpair_retval __cil_tmp ;

  {
#line 26
  __cil_tmp = vsf_sysutil_unix_stream_socketpair();
#line 26
  retval = __cil_tmp;
#line 28
  p_sess->parent_fd = retval.socket_one;
#line 29
  p_sess->child_fd = retval.socket_two;
#line 30
  return;
}
}
#line 32 "privsock.c"
void priv_sock_send_cmd(int fd , char cmd ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 35
  __cil_tmp = vsf_sysutil_write_loop(fd, (void const   *)(& cmd), (unsigned int )sizeof(cmd));
#line 35
  retval = __cil_tmp;
#line 36
  if ((unsigned long )retval != sizeof(cmd)) {
#line 38
    die("priv_sock_send_cmd");
  }
#line 40
  return;
}
}
#line 42 "privsock.c"
void priv_sock_send_str(int fd , struct mystr  const  *p_str ) 
{ unsigned int len ;
  unsigned int __cil_tmp ;

  {
#line 45
  __cil_tmp = str_getlen(p_str);
#line 45
  len = __cil_tmp;
#line 46
  priv_sock_send_int(fd, (int )len);
#line 47
  if (len > 0U) {
#line 49
    str_netfd_write(p_str, fd);
  }
#line 51
  return;
}
}
#line 53 "privsock.c"
char priv_sock_get_result(int fd ) 
{ char res ;
  int retval ;
  int __cil_tmp ;

  {
#line 57
  __cil_tmp = vsf_sysutil_read_loop(fd, (void *)(& res), (unsigned int )sizeof(res));
#line 57
  retval = __cil_tmp;
#line 58
  if ((unsigned long )retval != sizeof(res)) {
#line 60
    die("priv_sock_get_result");
  }
#line 62
  return (res);
}
}
#line 65 "privsock.c"
char priv_sock_get_cmd(int fd ) 
{ char res ;
  int retval ;
  int __cil_tmp ;

  {
#line 69
  __cil_tmp = vsf_sysutil_read_loop(fd, (void *)(& res), (unsigned int )sizeof(res));
#line 69
  retval = __cil_tmp;
#line 70
  if ((unsigned long )retval != sizeof(res)) {
#line 72
    die("priv_sock_get_cmd");
  }
#line 74
  return (res);
}
}
#line 77 "privsock.c"
void priv_sock_get_str(int fd , struct mystr *p_dest ) 
{ unsigned int len ;
  int __cil_tmp ;
  int retval ;
  int __cil_tmp___0 ;

  {
#line 80
  __cil_tmp = priv_sock_get_int(fd);
#line 80
  len = (unsigned int )__cil_tmp;
#line 81
  if (len > 16384U) {
#line 83
    die("priv_sock_get_str: too big");
  }
#line 85
  str_empty(p_dest);
#line 86
  if (len > 0U) {
#line 88
    __cil_tmp___0 = str_netfd_read(p_dest, fd, len);
#line 88
    retval = __cil_tmp___0;
#line 89
    if ((unsigned int )retval != len) {
#line 91
      die("priv_sock_get_str: read error");
    }
  }
#line 94
  return;
}
}
#line 96 "privsock.c"
void priv_sock_send_result(int fd , char res ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 99
  __cil_tmp = vsf_sysutil_write_loop(fd, (void const   *)(& res), (unsigned int )sizeof(res));
#line 99
  retval = __cil_tmp;
#line 100
  if ((unsigned long )retval != sizeof(res)) {
#line 102
    die("priv_sock_send_result");
  }
#line 104
  return;
}
}
#line 106 "privsock.c"
void priv_sock_send_fd(int fd , int send_fd ) 
{ 

  {
#line 109
  vsf_sysutil_send_fd(fd, send_fd);
#line 110
  return;
}
}
#line 112 "privsock.c"
int priv_sock_recv_fd(int fd ) 
{ int __cil_tmp ;

  {
#line 115
  __cil_tmp = vsf_sysutil_recv_fd(fd);
#line 115
  return (__cil_tmp);
}
}
#line 118 "privsock.c"
void priv_sock_send_int(int fd , int the_int ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 121
  __cil_tmp = vsf_sysutil_write_loop(fd, (void const   *)(& the_int), (unsigned int )sizeof(the_int));
#line 121
  retval = __cil_tmp;
#line 122
  if ((unsigned long )retval != sizeof(the_int)) {
#line 124
    die("priv_sock_send_int");
  }
#line 126
  return;
}
}
#line 128 "privsock.c"
int priv_sock_get_int(int fd ) 
{ int the_int ;
  int retval ;
  int __cil_tmp ;

  {
#line 132
  __cil_tmp = vsf_sysutil_read_loop(fd, (void *)(& the_int), (unsigned int )sizeof(the_int));
#line 132
  retval = __cil_tmp;
#line 133
  if ((unsigned long )retval != sizeof(the_int)) {
#line 135
    die("priv_sock_get_int");
  }
#line 137
  return (the_int);
}
}
#line 1 "cil-2qY5qD7O.o"
#pragma merger(0,"/tmp/cil-UTTbgW05.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 10 "tunables.h"
int tunable_chroot_local_user ;
#line 17
int tunable_xferlog_enable ;
#line 18
int tunable_dirmessage_enable ;
#line 24
int tunable_xferlog_std_format ;
#line 25
int tunable_pasv_promiscuous ;
#line 27
int tunable_chroot_list_enable ;
#line 29
int tunable_text_userdb_names ;
#line 30
int tunable_ls_recurse_enable ;
#line 36
int tunable_check_shell ;
#line 37
int tunable_hide_ids ;
#line 40
int tunable_passwd_chroot_enable ;
#line 43
int tunable_use_sendfile ;
#line 44
int tunable_force_dot_files ;
#line 46
int tunable_dual_log_enable ;
#line 47
int tunable_syslog_enable ;
#line 48
int tunable_background ;
#line 49
int tunable_virtual_use_local_privs ;
#line 50
int tunable_session_support ;
#line 56
int tunable_no_log_lock ;
#line 61
int tunable_sslv2 ;
#line 62
int tunable_sslv3 ;
#line 63
int tunable_tlsv1 ;
#line 70
int tunable_debug_ssl ;
#line 71
int tunable_require_cert ;
#line 72
int tunable_validate_cert ;
#line 73
int tunable_strict_ssl_read_eof ;
#line 74
int tunable_strict_ssl_write_shutdown ;
#line 75
int tunable_ssl_request_cert ;
#line 79
unsigned int tunable_accept_timeout ;
#line 80
unsigned int tunable_connect_timeout ;
#line 83
unsigned int tunable_ftp_data_port ;
#line 85
unsigned int tunable_data_connection_timeout ;
#line 90
unsigned int tunable_listen_port ;
#line 92
unsigned int tunable_file_open_mode ;
#line 94
unsigned int tunable_trans_chunk_size ;
#line 95
unsigned int tunable_delay_failed_login ;
#line 96
unsigned int tunable_delay_successful_login ;
#line 101
char const   *tunable_secure_chroot_dir ;
#line 104
char const   *tunable_xferlog_file ;
#line 105
char const   *tunable_vsftpd_log_file ;
#line 106
char const   *tunable_message_file ;
#line 107
char const   *tunable_nopriv_user ;
#line 110
char const   *tunable_chroot_list_file ;
#line 111
char const   *tunable_pam_service_name ;
#line 113
char const   *tunable_userlist_file ;
#line 114
char const   *tunable_anon_root ;
#line 115
char const   *tunable_local_root ;
#line 118
char const   *tunable_listen_address ;
#line 119
char const   *tunable_user_config_dir ;
#line 120
char const   *tunable_listen_address6 ;
#line 122
char const   *tunable_hide_file ;
#line 123
char const   *tunable_deny_file ;
#line 124
char const   *tunable_user_sub_token ;
#line 126
char const   *tunable_rsa_cert_file ;
#line 127
char const   *tunable_dsa_cert_file ;
#line 128
char const   *tunable_ssl_ciphers ;
#line 129
char const   *tunable_rsa_private_key_file ;
#line 130
char const   *tunable_dsa_private_key_file ;
#line 131
char const   *tunable_ca_certs_file ;
#line 10 "tunables.c"
int tunable_anonymous_enable  =    1;
#line 11 "tunables.c"
int tunable_local_enable  =    0;
#line 12 "tunables.c"
int tunable_pasv_enable  =    1;
#line 13 "tunables.c"
int tunable_port_enable  =    1;
#line 14 "tunables.c"
int tunable_chroot_local_user  =    0;
#line 15 "tunables.c"
int tunable_write_enable  =    0;
#line 16 "tunables.c"
int tunable_anon_upload_enable  =    0;
#line 17 "tunables.c"
int tunable_anon_mkdir_write_enable  =    0;
#line 18 "tunables.c"
int tunable_anon_other_write_enable  =    0;
#line 19 "tunables.c"
int tunable_chown_uploads  =    0;
#line 20 "tunables.c"
int tunable_connect_from_port_20  =    0;
#line 21 "tunables.c"
int tunable_xferlog_enable  =    0;
#line 22 "tunables.c"
int tunable_dirmessage_enable  =    0;
#line 23 "tunables.c"
int tunable_anon_world_readable_only  =    1;
#line 24 "tunables.c"
int tunable_async_abor_enable  =    0;
#line 25 "tunables.c"
int tunable_ascii_upload_enable  =    0;
#line 26 "tunables.c"
int tunable_ascii_download_enable  =    0;
#line 27 "tunables.c"
int tunable_one_process_model  =    0;
#line 28 "tunables.c"
int tunable_xferlog_std_format  =    0;
#line 29 "tunables.c"
int tunable_pasv_promiscuous  =    0;
#line 30 "tunables.c"
int tunable_deny_email_enable  =    0;
#line 31 "tunables.c"
int tunable_chroot_list_enable  =    0;
#line 32 "tunables.c"
int tunable_setproctitle_enable  =    0;
#line 33 "tunables.c"
int tunable_text_userdb_names  =    0;
#line 34 "tunables.c"
int tunable_ls_recurse_enable  =    0;
#line 35 "tunables.c"
int tunable_log_ftp_protocol  =    0;
#line 36 "tunables.c"
int tunable_guest_enable  =    0;
#line 37 "tunables.c"
int tunable_userlist_enable  =    0;
#line 38 "tunables.c"
int tunable_userlist_deny  =    1;
#line 39 "tunables.c"
int tunable_use_localtime  =    0;
#line 40 "tunables.c"
int tunable_check_shell  =    1;
#line 41 "tunables.c"
int tunable_hide_ids  =    0;
#line 42 "tunables.c"
int tunable_listen  =    0;
#line 43 "tunables.c"
int tunable_port_promiscuous  =    0;
#line 44 "tunables.c"
int tunable_passwd_chroot_enable  =    0;
#line 45 "tunables.c"
int tunable_no_anon_password  =    0;
#line 46 "tunables.c"
int tunable_tcp_wrappers  =    0;
#line 47 "tunables.c"
int tunable_use_sendfile  =    1;
#line 48 "tunables.c"
int tunable_force_dot_files  =    0;
#line 49 "tunables.c"
int tunable_listen_ipv6  =    0;
#line 50 "tunables.c"
int tunable_dual_log_enable  =    0;
#line 51 "tunables.c"
int tunable_syslog_enable  =    0;
#line 52 "tunables.c"
int tunable_background  =    0;
#line 53 "tunables.c"
int tunable_virtual_use_local_privs  =    0;
#line 54 "tunables.c"
int tunable_session_support  =    0;
#line 55 "tunables.c"
int tunable_download_enable  =    1;
#line 56 "tunables.c"
int tunable_dirlist_enable  =    1;
#line 57 "tunables.c"
int tunable_chmod_enable  =    1;
#line 58 "tunables.c"
int tunable_secure_email_list_enable  =    0;
#line 59 "tunables.c"
int tunable_run_as_launching_user  =    0;
#line 60 "tunables.c"
int tunable_no_log_lock  =    0;
#line 61 "tunables.c"
int tunable_ssl_enable  =    0;
#line 62 "tunables.c"
int tunable_allow_anon_ssl  =    0;
#line 63 "tunables.c"
int tunable_force_local_logins_ssl  =    1;
#line 64 "tunables.c"
int tunable_force_local_data_ssl  =    1;
#line 65 "tunables.c"
int tunable_sslv2  =    0;
#line 66 "tunables.c"
int tunable_sslv3  =    0;
#line 67 "tunables.c"
int tunable_tlsv1  =    1;
#line 68 "tunables.c"
int tunable_tilde_user_enable  =    0;
#line 69 "tunables.c"
int tunable_force_anon_logins_ssl  =    0;
#line 70 "tunables.c"
int tunable_force_anon_data_ssl  =    0;
#line 71 "tunables.c"
int tunable_mdtm_write  =    1;
#line 72 "tunables.c"
int tunable_lock_upload_files  =    1;
#line 73 "tunables.c"
int tunable_pasv_addr_resolve  =    0;
#line 74 "tunables.c"
int tunable_debug_ssl  =    0;
#line 75 "tunables.c"
int tunable_require_cert  =    0;
#line 76 "tunables.c"
int tunable_validate_cert  =    0;
#line 77 "tunables.c"
int tunable_strict_ssl_read_eof  =    0;
#line 78 "tunables.c"
int tunable_strict_ssl_write_shutdown  =    0;
#line 79 "tunables.c"
int tunable_ssl_request_cert  =    1;
#line 80 "tunables.c"
int tunable_delete_failed_uploads  =    0;
#line 82 "tunables.c"
unsigned int tunable_accept_timeout  =    60U;
#line 83 "tunables.c"
unsigned int tunable_connect_timeout  =    60U;
#line 84 "tunables.c"
unsigned int tunable_local_umask  =    63U;
#line 85 "tunables.c"
unsigned int tunable_anon_umask  =    63U;
#line 86 "tunables.c"
unsigned int tunable_ftp_data_port  =    20U;
#line 87 "tunables.c"
unsigned int tunable_idle_session_timeout  =    300U;
#line 88 "tunables.c"
unsigned int tunable_data_connection_timeout  =    300U;
#line 90 "tunables.c"
unsigned int tunable_pasv_min_port  =    5001U;
#line 91 "tunables.c"
unsigned int tunable_pasv_max_port  =    0U;
#line 92 "tunables.c"
unsigned int tunable_anon_max_rate  =    0U;
#line 93 "tunables.c"
unsigned int tunable_local_max_rate  =    0U;
#line 95 "tunables.c"
unsigned int tunable_listen_port  =    21U;
#line 96 "tunables.c"
unsigned int tunable_max_clients  =    0U;
#line 98 "tunables.c"
unsigned int tunable_file_open_mode  =    438U;
#line 99 "tunables.c"
unsigned int tunable_max_per_ip  =    0U;
#line 100 "tunables.c"
unsigned int tunable_trans_chunk_size  =    0U;
#line 101 "tunables.c"
unsigned int tunable_delay_failed_login  =    1U;
#line 102 "tunables.c"
unsigned int tunable_delay_successful_login  =    0U;
#line 103 "tunables.c"
unsigned int tunable_max_login_fails  =    3U;
#line 105 "tunables.c"
unsigned int tunable_chown_upload_mode  =    384U;
#line 107 "tunables.c"
char const   *tunable_secure_chroot_dir  =    "/usr/share/empty";
#line 108 "tunables.c"
char const   *tunable_ftp_username  =    "ftp";
#line 109 "tunables.c"
char const   *tunable_chown_username  =    "root";
#line 110 "tunables.c"
char const   *tunable_xferlog_file  =    "/var/log/xferlog";
#line 111 "tunables.c"
char const   *tunable_vsftpd_log_file  =    "/var/log/vsftpd.log";
#line 112 "tunables.c"
char const   *tunable_message_file  =    ".message";
#line 113 "tunables.c"
char const   *tunable_nopriv_user  =    "nobody";
#line 114 "tunables.c"
char const   *tunable_ftpd_banner  =    (char const   *)0;
#line 115 "tunables.c"
char const   *tunable_banned_email_file  =    "/etc/vsftpd.banned_emails";
#line 116 "tunables.c"
char const   *tunable_chroot_list_file  =    "/etc/vsftpd.chroot_list";
#line 117 "tunables.c"
char const   *tunable_pam_service_name  =    "ftp";
#line 118 "tunables.c"
char const   *tunable_guest_username  =    "ftp";
#line 119 "tunables.c"
char const   *tunable_userlist_file  =    "/etc/vsftpd.user_list";
#line 120 "tunables.c"
char const   *tunable_anon_root  =    (char const   *)0;
#line 121 "tunables.c"
char const   *tunable_local_root  =    (char const   *)0;
#line 122 "tunables.c"
char const   *tunable_banner_file  =    (char const   *)0;
#line 123 "tunables.c"
char const   *tunable_pasv_address  =    (char const   *)0;
#line 124 "tunables.c"
char const   *tunable_listen_address  =    (char const   *)0;
#line 125 "tunables.c"
char const   *tunable_user_config_dir  =    (char const   *)0;
#line 126 "tunables.c"
char const   *tunable_listen_address6  =    (char const   *)0;
#line 127 "tunables.c"
char const   *tunable_cmds_allowed  =    (char const   *)0;
#line 128 "tunables.c"
char const   *tunable_hide_file  =    (char const   *)0;
#line 129 "tunables.c"
char const   *tunable_deny_file  =    (char const   *)0;
#line 130 "tunables.c"
char const   *tunable_user_sub_token  =    (char const   *)0;
#line 131 "tunables.c"
char const   *tunable_email_password_file  =    "/etc/vsftpd.email_passwords";
#line 132 "tunables.c"
char const   *tunable_rsa_cert_file  =    "/usr/share/ssl/certs/vsftpd.pem";
#line 133 "tunables.c"
char const   *tunable_dsa_cert_file  =    (char const   *)0;
#line 134 "tunables.c"
char const   *tunable_ssl_ciphers  =    "DES-CBC3-SHA";
#line 135 "tunables.c"
char const   *tunable_rsa_private_key_file  =    (char const   *)0;
#line 136 "tunables.c"
char const   *tunable_dsa_private_key_file  =    (char const   *)0;
#line 137 "tunables.c"
char const   *tunable_ca_certs_file  =    (char const   *)0;
#line 1 "cil-mVeXD0Db.o"
#pragma merger(0,"/tmp/cil-SA8xd2sC.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 37 "str.h"
void str_reserve(struct mystr *p_str , unsigned int res_len ) ;
#line 18 "strlist.h"
void str_list_free(struct mystr_list *p_list ) ;
#line 24
int str_list_get_length(struct mystr_list  const  *p_list ) ;
#line 28
struct mystr  const  *str_list_get_pstr(struct mystr_list  const  *p_list , unsigned int indexx ) ;
#line 48 "sysutil.h"
void vsf_sysutil_install_io_handler(void (*handler)(int  , int  , void * ) , void *p_private ) ;
#line 49
void vsf_sysutil_uninstall_io_handler(void) ;
#line 57
void vsf_sysutil_clear_alarm(void) ;
#line 90
int vsf_sysutil_close_failok(int fd ) ;
#line 96
filesize_t vsf_sysutil_get_file_offset(int file_fd ) ;
#line 97
int vsf_sysutil_read(int fd , void *p_buf , unsigned int size ) ;
#line 210
void vsf_sysutil_sockaddr_alloc(struct vsf_sysutil_sockaddr **p_sockptr ) ;
#line 229
int vsf_sysutil_get_ipsock(struct vsf_sysutil_sockaddr  const  *p_addr ) ;
#line 245
int vsf_sysutil_accept_timeout(int fd , struct vsf_sysutil_sockaddr *p_sockaddr___0 ,
                               unsigned int wait_seconds ) ;
#line 247
int vsf_sysutil_connect_timeout(int fd , struct vsf_sysutil_sockaddr  const  *p_addr ,
                                unsigned int wait_seconds ) ;
#line 254
void vsf_sysutil_set_iptos_throughput(int fd ) ;
#line 259
void vsf_sysutil_activate_linger(int fd ) ;
#line 260
void vsf_sysutil_deactivate_linger_failok(int fd ) ;
#line 326
void vsf_sysutil_update_cached_time(void) ;
#line 327
long vsf_sysutil_get_cached_time_sec(void) ;
#line 328
long vsf_sysutil_get_cached_time_usec(void) ;
#line 330
void vsf_sysutil_sleep(double seconds ) ;
#line 37 "sysdeputil.h"
int vsf_sysutil_sendfile(int out_fd , int in_fd , filesize_t *p_offset , filesize_t num_send ,
                         unsigned int max_chunk ) ;
#line 28 "ascii.h"
struct ascii_to_bin_ret vsf_ascii_ascii_to_bin(char *p_buf , unsigned int in_len ,
                                               int prev_cr ) ;
#line 44
unsigned int vsf_ascii_bin_to_ascii(char const   *p_in , char *p_out , unsigned int in_len ) ;
#line 35 "oneprocess.h"
int vsf_one_process_get_priv_data_sock(struct vsf_session *p_sess ) ;
#line 34 "twoprocess.h"
int vsf_two_process_get_priv_data_sock(struct vsf_session *p_sess ) ;
#line 22 "ls.h"
void vsf_ls_populate_dir_list(struct mystr_list *p_list , struct mystr_list *p_subdir_list ,
                              struct vsf_sysutil_dir *p_dir , struct mystr  const  *p_base_dir_str ,
                              struct mystr  const  *p_option_str , struct mystr  const  *p_filter_str ,
                              int is_verbose ) ;
#line 13 "ssl.h"
int ssl_accept(struct vsf_session *p_sess , int fd ) ;
#line 14
int ssl_data_close(struct vsf_session *p_sess ) ;
#line 15 "readwrite.h"
int ftp_read_data(struct vsf_session *p_sess , char *p_buf , unsigned int len ) ;
#line 16
int ftp_write_data(struct vsf_session  const  *p_sess , char const   *p_buf , unsigned int len ) ;
#line 33 "ftpdataio.c"
static void init_data_sock_params(struct vsf_session *p_sess , int sock_fd ) ;
#line 34
static filesize_t calc_num_send(int file_fd , filesize_t init_offset ) ;
#line 35
static struct vsf_transfer_ret do_file_send_sendfile(struct vsf_session *p_sess ,
                                                     int net_fd , int file_fd , filesize_t curr_file_offset ,
                                                     filesize_t bytes_to_send ) ;
#line 38
static struct vsf_transfer_ret do_file_send_rwloop(struct vsf_session *p_sess , int file_fd ,
                                                   int is_ascii ) ;
#line 40
static struct vsf_transfer_ret do_file_recv(struct vsf_session *p_sess , int file_fd ,
                                            int is_ascii ) ;
#line 42
static void handle_sigalrm(void *p_private ) ;
#line 43
static void start_data_alarm(struct vsf_session *p_sess ) ;
#line 44
static void handle_io(int retval , int fd , void *p_private ) ;
#line 45
static int transfer_dir_internal(struct vsf_session *p_sess , int is_control , struct vsf_sysutil_dir *p_dir ,
                                 struct mystr  const  *p_base_dir_str , struct mystr  const  *p_option_str ,
                                 struct mystr  const  *p_filter_str , int is_verbose ) ;
#line 49
static int write_dir_list(struct vsf_session *p_sess , struct mystr_list *p_dir_list ,
                          enum EVSFRWTarget target ) ;
#line 52
static unsigned int get_chunk_size(void) ;
#line 54 "ftpdataio.c"
int vsf_ftpdataio_dispose_transfer_fd(struct vsf_session *p_sess ) 
{ int dispose_ret ;
  int retval ;
  int __cil_tmp ;

  {
#line 57
  dispose_ret = 1;
#line 59
  if (p_sess->data_fd == -1) {
#line 61
    bug("no data descriptor in vsf_ftpdataio_dispose_transfer_fd");
  }
#line 64
  start_data_alarm(p_sess);
#line 65
  vsf_sysutil_uninstall_io_handler();
#line 66
  if ((unsigned int )p_sess->p_data_ssl != (unsigned int )((void *)0)) {
#line 68
    dispose_ret = ssl_data_close(p_sess);
  }
#line 71
  retval = vsf_sysutil_close_failok(p_sess->data_fd);
#line 72
  __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 72
  if (__cil_tmp) {
#line 75
    vsf_sysutil_deactivate_linger_failok(p_sess->data_fd);
#line 76
    vsf_sysutil_close_failok(p_sess->data_fd);
  }
#line 78
  vsf_sysutil_clear_alarm();
#line 79
  p_sess->data_fd = -1;
#line 80
  return (dispose_ret);
}
}
#line 83 "ftpdataio.c"
int vsf_ftpdataio_get_pasv_fd(struct vsf_session *p_sess ) 
{ int remote_fd ;
  struct vsf_sysutil_sockaddr *p_accept_addr ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 87
  p_accept_addr = (struct vsf_sysutil_sockaddr *)0;
#line 88
  vsf_sysutil_sockaddr_alloc(& p_accept_addr);
#line 89
  remote_fd = vsf_sysutil_accept_timeout(p_sess->pasv_listen_fd, p_accept_addr, tunable_accept_timeout);
#line 91
  __cil_tmp = vsf_sysutil_retval_is_error(remote_fd);
#line 91
  if (__cil_tmp) {
#line 93
    vsf_cmdio_write(p_sess, 425, "Failed to establish connection.");
#line 95
    vsf_sysutil_sockaddr_clear(& p_accept_addr);
#line 96
    return (remote_fd);
  }
#line 102
  if (! tunable_pasv_promiscuous) {
#line 104
    __cil_tmp___0 = vsf_sysutil_sockaddr_addr_equal((struct vsf_sysutil_sockaddr  const  *)p_sess->p_remote_addr,
                                                    (struct vsf_sysutil_sockaddr  const  *)p_accept_addr);
#line 104
    if (! __cil_tmp___0) {
#line 106
      vsf_cmdio_write(p_sess, 425, "Security: Bad IP connecting.");
#line 107
      vsf_sysutil_close(remote_fd);
#line 108
      vsf_sysutil_sockaddr_clear(& p_accept_addr);
#line 109
      return (-1);
    }
  }
#line 112
  vsf_sysutil_sockaddr_clear(& p_accept_addr);
#line 113
  init_data_sock_params(p_sess, remote_fd);
#line 114
  return (remote_fd);
}
}
#line 135 "ftpdataio.c"
static struct vsf_sysutil_sockaddr *s_p_addr  ;
#line 117 "ftpdataio.c"
int vsf_ftpdataio_get_port_fd(struct vsf_session *p_sess ) 
{ int retval ;
  int remote_fd ;
  int __cil_tmp ;

  {
#line 122
  if (tunable_connect_from_port_20) {
#line 124
    if (tunable_one_process_model) {
#line 126
      remote_fd = vsf_one_process_get_priv_data_sock(p_sess);
    } else {
#line 130
      remote_fd = vsf_two_process_get_priv_data_sock(p_sess);
    }
  } else {
#line 136
    remote_fd = vsf_sysutil_get_ipsock((struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 137
    vsf_sysutil_sockaddr_clone(& s_p_addr, (struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 138
    vsf_sysutil_sockaddr_set_port(s_p_addr, (unsigned short)0);
#line 139
    retval = vsf_sysutil_bind(remote_fd, (struct vsf_sysutil_sockaddr  const  *)s_p_addr);
#line 140
    if (retval != 0) {
#line 142
      die("vsf_sysutil_bind");
    }
  }
#line 145
  retval = vsf_sysutil_connect_timeout(remote_fd, (struct vsf_sysutil_sockaddr  const  *)p_sess->p_port_sockaddr,
                                       tunable_connect_timeout);
#line 147
  __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 147
  if (__cil_tmp) {
#line 149
    vsf_cmdio_write(p_sess, 425, "Failed to establish connection.");
#line 151
    vsf_sysutil_close(remote_fd);
#line 152
    return (-1);
  }
#line 154
  init_data_sock_params(p_sess, remote_fd);
#line 155
  return (remote_fd);
}
}
#line 158 "ftpdataio.c"
int vsf_ftpdataio_post_mark_connect(struct vsf_session *p_sess ) 
{ int __cil_tmp ;

  {
#line 161
  if (p_sess->data_use_ssl) {
#line 163
    __cil_tmp = ssl_accept(p_sess, p_sess->data_fd);
#line 163
    if (! __cil_tmp) {
#line 165
      vsf_cmdio_write(p_sess, 522, "Secure connection negotiation failed.");
#line 167
      return (0);
    }
  }
#line 170
  return (1);
}
}
#line 173 "ftpdataio.c"
static void handle_sigalrm(void *p_private ) 
{ struct vsf_session *p_sess ;

  {
#line 176
  p_sess = (struct vsf_session *)p_private;
#line 177
  if (! p_sess->data_progress) {
#line 179
    vsf_cmdio_write_exit(p_sess, 421, "Data timeout. Reconnect. Sorry.");
  }
#line 182
  p_sess->data_progress = 0;
#line 183
  start_data_alarm(p_sess);
#line 184
  return;
}
}
#line 186 "ftpdataio.c"
static void start_data_alarm(struct vsf_session *p_sess ) 
{ 

  {
#line 189
  if (tunable_data_connection_timeout > 0U) {
#line 191
    vsf_sysutil_install_sighandler(1, & handle_sigalrm, (void *)p_sess);
#line 192
    vsf_sysutil_set_alarm(tunable_data_connection_timeout);
  }
#line 194
  return;
}
}
#line 196 "ftpdataio.c"
static void init_data_sock_params(struct vsf_session *p_sess , int sock_fd ) 
{ 

  {
#line 199
  if (p_sess->data_fd != -1) {
#line 201
    bug("data descriptor still present in init_data_sock_params");
  }
#line 203
  p_sess->data_fd = sock_fd;
#line 204
  p_sess->data_progress = 0;
#line 205
  vsf_sysutil_activate_keepalive(sock_fd);
#line 207
  vsf_sysutil_set_iptos_throughput(sock_fd);
#line 211
  vsf_sysutil_activate_linger(sock_fd);
#line 213
  vsf_sysutil_install_io_handler(& handle_io, (void *)p_sess);
#line 214
  start_data_alarm(p_sess);
#line 215
  return;
}
}
#line 217 "ftpdataio.c"
static void handle_io(int retval , int fd , void *p_private ) 
{ long curr_sec ;
  long curr_usec ;
  unsigned int bw_rate ;
  double elapsed ;
  double pause_time ;
  double rate_ratio ;
  struct vsf_session *p_sess ;
  int __cil_tmp ;

  {
#line 226
  p_sess = (struct vsf_session *)p_private;
#line 227
  if (p_sess->data_fd != fd) {
#line 227
    goto _L___0;
  } else {
#line 227
    __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 227
    if (__cil_tmp) {
      _L___0: /* CIL Label */ 
#line 227
      goto _L;
    } else {
#line 227
      if (retval == 0) {
        _L: /* CIL Label */ 
#line 230
        return;
      }
    }
  }
#line 233
  p_sess->data_progress = 1;
#line 235
  if (p_sess->bw_rate_max == 0U) {
#line 237
    return;
  }
#line 240
  vsf_sysutil_update_cached_time();
#line 241
  curr_sec = vsf_sysutil_get_cached_time_sec();
#line 242
  curr_usec = vsf_sysutil_get_cached_time_usec();
#line 243
  elapsed = (double )(curr_sec - p_sess->bw_send_start_sec);
#line 244
  elapsed += (double )(curr_usec - p_sess->bw_send_start_usec) / (double )1000000;
#line 246
  if (elapsed <= (double )0) {
#line 248
    elapsed = 0.01;
  }
#line 250
  bw_rate = (unsigned int )((double )retval / elapsed);
#line 251
  if (bw_rate <= p_sess->bw_rate_max) {
#line 253
    p_sess->bw_send_start_sec = curr_sec;
#line 254
    p_sess->bw_send_start_usec = curr_usec;
#line 255
    return;
  }
#line 258
  rate_ratio = (double )bw_rate / (double )p_sess->bw_rate_max;
#line 259
  pause_time = (rate_ratio - (double )1) * elapsed;
#line 260
  vsf_sysutil_sleep(pause_time);
#line 261
  vsf_sysutil_update_cached_time();
#line 262
  p_sess->bw_send_start_sec = vsf_sysutil_get_cached_time_sec();
#line 263
  p_sess->bw_send_start_usec = vsf_sysutil_get_cached_time_usec();
#line 264
  return;
}
}
#line 266 "ftpdataio.c"
int vsf_ftpdataio_transfer_dir(struct vsf_session *p_sess , int is_control , struct vsf_sysutil_dir *p_dir ,
                               struct mystr  const  *p_base_dir_str , struct mystr  const  *p_option_str ,
                               struct mystr  const  *p_filter_str , int is_verbose ) 
{ int __cil_tmp ;

  {
#line 274
  __cil_tmp = transfer_dir_internal(p_sess, is_control, p_dir, p_base_dir_str, p_option_str,
                                    p_filter_str, is_verbose);
#line 274
  return (__cil_tmp);
}
}
#line 278 "ftpdataio.c"
static int transfer_dir_internal(struct vsf_session *p_sess , int is_control , struct vsf_sysutil_dir *p_dir ,
                                 struct mystr  const  *p_base_dir_str , struct mystr  const  *p_option_str ,
                                 struct mystr  const  *p_filter_str , int is_verbose ) 
{ struct mystr_list dir_list ;
  struct mystr_list subdir_list ;
  struct mystr dir_prefix_str ;
  struct mystr_list *p_subdir_list ;
  struct str_locate_result loc_result ;
  struct str_locate_result __cil_tmp ;
  int failed ;
  enum EVSFRWTarget target ;
  int retval ;
  struct mystr sub_str ;
  unsigned int num_subdirs ;
  int __cil_tmp___0 ;
  unsigned int subdir_index ;
  int retval___0 ;
  struct vsf_sysutil_dir *p_subdir ;
  struct mystr  const  *p_subdir_str ;
  struct mystr  const  *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 286
  dir_list.PRIVATE_HANDS_OFF_alloc_len = 0U;
#line 286
  dir_list.PRIVATE_HANDS_OFF_list_len = 0U;
#line 286
  dir_list.PRIVATE_HANDS_OFF_p_nodes = (struct mystr_list_node *)((void *)0);
#line 287
  subdir_list.PRIVATE_HANDS_OFF_alloc_len = 0U;
#line 287
  subdir_list.PRIVATE_HANDS_OFF_list_len = 0U;
#line 287
  subdir_list.PRIVATE_HANDS_OFF_p_nodes = (struct mystr_list_node *)((void *)0);
#line 288
  dir_prefix_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 288
  dir_prefix_str.PRIVATE_HANDS_OFF_len = 0U;
#line 288
  dir_prefix_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 289
  p_subdir_list = (struct mystr_list *)0;
#line 290
  __cil_tmp = str_locate_char(p_option_str, (char )'R');
#line 290
  loc_result = __cil_tmp;
#line 291
  failed = 0;
#line 292
  target = 2;
#line 293
  if (is_control) {
#line 295
    target = 1;
  }
#line 297
  if (loc_result.found && tunable_ls_recurse_enable) {
#line 299
    p_subdir_list = & subdir_list;
  }
#line 301
  vsf_ls_populate_dir_list(& dir_list, p_subdir_list, p_dir, p_base_dir_str, p_option_str,
                           p_filter_str, is_verbose);
#line 303
  if (p_subdir_list) {
#line 306
    str_copy(& dir_prefix_str, p_base_dir_str);
#line 307
    str_append_text(& dir_prefix_str, ":\r\n");
#line 308
    retval = ftp_write_str((struct vsf_session  const  *)p_sess, (struct mystr  const  *)(& dir_prefix_str),
                           target);
#line 309
    if (retval != 0) {
#line 311
      failed = 1;
    }
  }
#line 314
  if (! failed) {
#line 316
    failed = write_dir_list(p_sess, & dir_list, target);
  }
#line 319
  if (! failed) {
#line 321
    sub_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 321
    sub_str.PRIVATE_HANDS_OFF_len = 0U;
#line 321
    sub_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 322
    __cil_tmp___0 = str_list_get_length((struct mystr_list  const  *)(& subdir_list));
#line 322
    num_subdirs = (unsigned int )__cil_tmp___0;
#line 324
    subdir_index = 0U;
#line 324
    while (subdir_index < num_subdirs) {
#line 328
      __cil_tmp___1 = str_list_get_pstr((struct mystr_list  const  *)(& subdir_list),
                                        subdir_index);
#line 328
      p_subdir_str = __cil_tmp___1;
#line 330
      __cil_tmp___2 = str_equal_text(p_subdir_str, ".");
#line 330
      if (__cil_tmp___2) {
#line 330
        goto _L;
      } else {
#line 330
        __cil_tmp___3 = str_equal_text(p_subdir_str, "..");
#line 330
        if (__cil_tmp___3) {
          _L: /* CIL Label */ 
#line 333
          goto __Cont;
        }
      }
#line 335
      str_copy(& sub_str, p_base_dir_str);
#line 336
      str_append_char(& sub_str, (char )'/');
#line 337
      str_append_str(& sub_str, p_subdir_str);
#line 338
      p_subdir = str_opendir((struct mystr  const  *)(& sub_str));
#line 339
      if ((unsigned int )p_subdir == (unsigned int )((struct vsf_sysutil_dir *)0)) {
#line 342
        goto __Cont;
      }
#line 344
      str_alloc_text(& dir_prefix_str, "\r\n");
#line 345
      retval___0 = ftp_write_str((struct vsf_session  const  *)p_sess, (struct mystr  const  *)(& dir_prefix_str),
                                 target);
#line 346
      if (retval___0 != 0) {
#line 348
        failed = 1;
#line 349
        break;
      }
#line 351
      retval___0 = transfer_dir_internal(p_sess, is_control, p_subdir, (struct mystr  const  *)(& sub_str),
                                         p_option_str, p_filter_str, is_verbose);
#line 353
      vsf_sysutil_closedir(p_subdir);
#line 354
      if (retval___0 != 0) {
#line 356
        failed = 1;
#line 357
        break;
      }
      __Cont: /* CIL Label */ 
#line 324
      subdir_index ++;
    }
#line 360
    str_free(& sub_str);
  }
#line 362
  str_list_free(& dir_list);
#line 363
  str_list_free(& subdir_list);
#line 364
  str_free(& dir_prefix_str);
#line 365
  if (! failed) {
#line 367
    return (0);
  } else {
#line 371
    return (-1);
  }
}
}
#line 376 "ftpdataio.c"
static int write_dir_list(struct vsf_session *p_sess , struct mystr_list *p_dir_list ,
                          enum EVSFRWTarget target ) 
{ int retval ;
  unsigned int dir_index_max ;
  int __cil_tmp ;
  unsigned int dir_index ;
  struct mystr buf_str ;
  struct mystr  const  *__cil_tmp___0 ;
  int writeret ;
  int __cil_tmp___1 ;
  unsigned int __cil_tmp___2 ;
  struct mystr  const  *__cil_tmp___3 ;
  unsigned int __cil_tmp___4 ;

  {
#line 384
  retval = 0;
#line 385
  __cil_tmp = str_list_get_length((struct mystr_list  const  *)p_dir_list);
#line 385
  dir_index_max = (unsigned int )__cil_tmp;
#line 387
  buf_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 387
  buf_str.PRIVATE_HANDS_OFF_len = 0U;
#line 387
  buf_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 388
  str_reserve(& buf_str, 16384U);
#line 389
  dir_index = 0U;
#line 389
  while (dir_index < dir_index_max) {
#line 391
    __cil_tmp___0 = str_list_get_pstr((struct mystr_list  const  *)p_dir_list, dir_index);
#line 391
    str_append_str(& buf_str, __cil_tmp___0);
#line 392
    if (dir_index == dir_index_max - 1U) {
#line 392
      goto _L;
    } else {
#line 392
      __cil_tmp___2 = str_getlen((struct mystr  const  *)(& buf_str));
#line 392
      __cil_tmp___3 = str_list_get_pstr((struct mystr_list  const  *)p_dir_list, dir_index + 1U);
#line 392
      __cil_tmp___4 = str_getlen(__cil_tmp___3);
#line 392
      if (__cil_tmp___2 + __cil_tmp___4 > 16384U) {
        _L: /* CIL Label */ 
#line 398
        __cil_tmp___1 = ftp_write_str((struct vsf_session  const  *)p_sess, (struct mystr  const  *)(& buf_str),
                                      target);
#line 398
        writeret = __cil_tmp___1;
#line 399
        if (writeret != 0) {
#line 401
          retval = 1;
#line 402
          break;
        }
#line 404
        str_empty(& buf_str);
      }
    }
#line 389
    dir_index ++;
  }
#line 407
  str_free(& buf_str);
#line 408
  return (retval);
}
}
#line 411 "ftpdataio.c"
struct vsf_transfer_ret vsf_ftpdataio_transfer_file(struct vsf_session *p_sess , int remote_fd ,
                                                    int file_fd , int is_recv , int is_ascii ) 
{ struct vsf_transfer_ret __cil_tmp ;
  filesize_t curr_offset ;
  filesize_t __cil_tmp___0 ;
  filesize_t num_send ;
  filesize_t __cil_tmp___1 ;
  struct vsf_transfer_ret __cil_tmp___2 ;
  struct vsf_transfer_ret __cil_tmp___3 ;

  {
#line 415
  if (! is_recv) {
#line 417
    if (is_ascii || p_sess->data_use_ssl) {
#line 419
      __cil_tmp = do_file_send_rwloop(p_sess, file_fd, is_ascii);
#line 419
      return (__cil_tmp);
    } else {
#line 423
      __cil_tmp___0 = vsf_sysutil_get_file_offset(file_fd);
#line 423
      curr_offset = __cil_tmp___0;
#line 424
      __cil_tmp___1 = calc_num_send(file_fd, curr_offset);
#line 424
      num_send = __cil_tmp___1;
#line 425
      __cil_tmp___2 = do_file_send_sendfile(p_sess, remote_fd, file_fd, curr_offset,
                                            num_send);
#line 425
      return (__cil_tmp___2);
    }
  } else {
#line 431
    __cil_tmp___3 = do_file_recv(p_sess, file_fd, is_ascii);
#line 431
    return (__cil_tmp___3);
  }
}
}
#line 438 "ftpdataio.c"
static char *p_readbuf  ;
#line 439 "ftpdataio.c"
static char *p_asciibuf  ;
#line 435 "ftpdataio.c"
static struct vsf_transfer_ret do_file_send_rwloop(struct vsf_session *p_sess , int file_fd ,
                                                   int is_ascii ) 
{ struct vsf_transfer_ret ret_struct ;
  unsigned int chunk_size ;
  unsigned int __cil_tmp ;
  char *p_writefrom_buf ;
  unsigned int num_to_write ;
  int retval ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 440
  ret_struct.retval = 0;
#line 440
  ret_struct.transferred = (filesize_t )0;
#line 441
  __cil_tmp = get_chunk_size();
#line 441
  chunk_size = __cil_tmp;
#line 443
  if ((unsigned int )p_readbuf == (unsigned int )((char *)0)) {
#line 448
    vsf_secbuf_alloc(& p_asciibuf, 131072U);
#line 449
    vsf_secbuf_alloc(& p_readbuf, 65536U);
  }
#line 451
  if (is_ascii) {
#line 453
    p_writefrom_buf = p_asciibuf;
  } else {
#line 457
    p_writefrom_buf = p_readbuf;
  }
#line 459
  while (1) {
#line 462
    __cil_tmp___0 = vsf_sysutil_read(file_fd, (void *)p_readbuf, chunk_size);
#line 462
    retval = __cil_tmp___0;
#line 463
    __cil_tmp___1 = vsf_sysutil_retval_is_error(retval);
#line 463
    if (__cil_tmp___1) {
#line 465
      ret_struct.retval = -1;
#line 466
      return (ret_struct);
    } else {
#line 468
      if (retval == 0) {
#line 471
        return (ret_struct);
      }
    }
#line 473
    if (is_ascii) {
#line 475
      num_to_write = vsf_ascii_bin_to_ascii((char const   *)p_readbuf, p_asciibuf,
                                            (unsigned int )retval);
    } else {
#line 480
      num_to_write = (unsigned int )retval;
    }
#line 482
    retval = ftp_write_data((struct vsf_session  const  *)p_sess, (char const   *)p_writefrom_buf,
                            num_to_write);
#line 483
    __cil_tmp___2 = vsf_sysutil_retval_is_error(retval);
#line 483
    if (! __cil_tmp___2) {
#line 485
      ret_struct.transferred += (filesize_t )((unsigned int )retval);
    }
#line 487
    __cil_tmp___3 = vsf_sysutil_retval_is_error(retval);
#line 487
    if (__cil_tmp___3 || (unsigned int )retval != num_to_write) {
#line 490
      ret_struct.retval = -2;
#line 491
      return (ret_struct);
    }
  }
}
}
#line 496 "ftpdataio.c"
static struct vsf_transfer_ret do_file_send_sendfile(struct vsf_session *p_sess ,
                                                     int net_fd , int file_fd , filesize_t curr_file_offset ,
                                                     filesize_t bytes_to_send ) 
{ int retval ;
  unsigned int chunk_size ;
  struct vsf_transfer_ret ret_struct ;
  filesize_t init_file_offset ;
  filesize_t bytes_sent ;
  int __cil_tmp ;

  {
#line 501
  chunk_size = 0U;
#line 502
  ret_struct.retval = 0;
#line 502
  ret_struct.transferred = (filesize_t )0;
#line 503
  init_file_offset = curr_file_offset;
#line 505
  if (p_sess->bw_rate_max) {
#line 507
    chunk_size = get_chunk_size();
  }
#line 510
  retval = vsf_sysutil_sendfile(net_fd, file_fd, & curr_file_offset, bytes_to_send,
                                chunk_size);
#line 512
  bytes_sent = curr_file_offset - init_file_offset;
#line 513
  ret_struct.transferred = bytes_sent;
#line 514
  __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 514
  if (__cil_tmp) {
#line 516
    ret_struct.retval = -2;
#line 517
    return (ret_struct);
  } else {
#line 519
    if (bytes_sent != bytes_to_send) {
#line 521
      ret_struct.retval = -2;
#line 522
      return (ret_struct);
    }
  }
#line 524
  return (ret_struct);
}
}
#line 530 "ftpdataio.c"
static struct vsf_sysutil_statbuf *s_p_statbuf___4  ;
#line 527 "ftpdataio.c"
static filesize_t calc_num_send(int file_fd , filesize_t init_offset ) 
{ filesize_t bytes_to_send ;

  {
#line 533
  vsf_sysutil_fstat(file_fd, & s_p_statbuf___4);
#line 534
  bytes_to_send = vsf_sysutil_statbuf_get_size((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___4);
#line 535
  if (init_offset < 0LL || bytes_to_send < 0LL) {
#line 537
    die("calc_num_send: negative file offset or send count");
  }
#line 540
  if (init_offset > bytes_to_send) {
#line 542
    bytes_to_send = 0LL;
  } else {
#line 546
    bytes_to_send -= init_offset;
  }
#line 548
  return (bytes_to_send);
}
}
#line 554 "ftpdataio.c"
static char *p_recvbuf  ;
#line 551 "ftpdataio.c"
static struct vsf_transfer_ret do_file_recv(struct vsf_session *p_sess , int file_fd ,
                                            int is_ascii ) 
{ unsigned int num_to_write ;
  struct vsf_transfer_ret ret_struct ;
  unsigned int chunk_size ;
  unsigned int __cil_tmp ;
  int prev_cr ;
  char const   *p_writebuf ;
  int retval ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  struct ascii_to_bin_ret ret___0 ;
  struct ascii_to_bin_ret __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 556
  ret_struct.retval = 0;
#line 556
  ret_struct.transferred = (filesize_t )0;
#line 557
  __cil_tmp = get_chunk_size();
#line 557
  chunk_size = __cil_tmp;
#line 558
  prev_cr = 0;
#line 559
  if ((unsigned int )p_recvbuf == (unsigned int )((char *)0)) {
#line 566
    vsf_secbuf_alloc(& p_recvbuf, 65537U);
  }
#line 568
  while (1) {
#line 570
    p_writebuf = (char const   *)(p_recvbuf + 1);
#line 571
    __cil_tmp___0 = ftp_read_data(p_sess, p_recvbuf + 1, chunk_size);
#line 571
    retval = __cil_tmp___0;
#line 572
    __cil_tmp___1 = vsf_sysutil_retval_is_error(retval);
#line 572
    if (__cil_tmp___1) {
#line 574
      ret_struct.retval = -2;
#line 575
      return (ret_struct);
    } else {
#line 577
      if (retval == 0 && ! prev_cr) {
#line 580
        return (ret_struct);
      }
    }
#line 582
    num_to_write = (unsigned int )retval;
#line 583
    ret_struct.transferred += (filesize_t )num_to_write;
#line 584
    if (is_ascii) {
#line 590
      __cil_tmp___2 = vsf_ascii_ascii_to_bin(p_recvbuf, num_to_write, prev_cr);
#line 590
      ret___0 = __cil_tmp___2;
#line 592
      num_to_write = ret___0.stored;
#line 593
      prev_cr = ret___0.last_was_cr;
#line 594
      p_writebuf = (char const   *)ret___0.p_buf;
    }
#line 596
    retval = vsf_sysutil_write_loop(file_fd, (void const   *)p_writebuf, num_to_write);
#line 597
    __cil_tmp___3 = vsf_sysutil_retval_is_error(retval);
#line 597
    if (__cil_tmp___3 || (unsigned int )retval != num_to_write) {
#line 600
      ret_struct.retval = -1;
#line 601
      return (ret_struct);
    }
  }
}
}
#line 606 "ftpdataio.c"
static unsigned int get_chunk_size(void) 
{ unsigned int ret___0 ;

  {
#line 609
  ret___0 = 65536U;
#line 610
  if (tunable_trans_chunk_size < 65536U && tunable_trans_chunk_size > 0U) {
#line 613
    ret___0 = tunable_trans_chunk_size;
#line 614
    if (ret___0 < 4096U) {
#line 616
      ret___0 = 4096U;
    }
  }
#line 619
  return (ret___0);
}
}
#line 1 "cil-kFWAmFif.o"
#pragma merger(0,"/tmp/cil-7CrgA7Dz.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 24 "secbuf.h"
void vsf_secbuf_free(char **p_ptr ) ;
#line 152 "sysutil.h"
void vsf_sysutil_memprotect(void *p_addr , unsigned int len , enum EVSFSysUtilMapPermission perm ) ;
#line 154
void vsf_sysutil_memunmap(void *p_start , unsigned int length ) ;
#line 291
unsigned int vsf_sysutil_getpagesize(void) ;
#line 52 "sysdeputil.h"
void *vsf_sysutil_map_anon_pages(unsigned int length ) ;
#line 17 "secbuf.c"
void vsf_secbuf_alloc(char **p_ptr , unsigned int size ) 
{ unsigned int page_offset ;
  unsigned int round_up ;
  char *p_mmap ;
  char *p_no_access_page ;
  unsigned int page_size ;
  unsigned int __cil_tmp ;
  unsigned int num_pages ;
  void *__cil_tmp___0 ;

  {
#line 24
  __cil_tmp = vsf_sysutil_getpagesize();
#line 24
  page_size = __cil_tmp;
#line 27
  vsf_secbuf_free(p_ptr);
#line 29
  page_offset = size % page_size;
#line 30
  if (page_offset) {
#line 32
    num_pages = size / page_size;
#line 33
    num_pages ++;
#line 34
    round_up = num_pages * page_size;
  } else {
#line 39
    round_up = size;
  }
#line 42
  round_up += page_size * 2U;
#line 44
  __cil_tmp___0 = vsf_sysutil_map_anon_pages(round_up);
#line 44
  p_mmap = (char *)__cil_tmp___0;
#line 46
  p_no_access_page = (p_mmap + round_up) - page_size;
#line 47
  vsf_sysutil_memprotect((void *)p_no_access_page, page_size, 2);
#line 52
  *((unsigned int *)p_mmap) = round_up;
#line 53
  p_no_access_page = p_mmap;
#line 54
  vsf_sysutil_memprotect((void *)p_no_access_page, page_size, 2);
#line 56
  p_mmap += page_size;
#line 57
  if (page_offset) {
#line 59
    p_mmap += page_size - page_offset;
  }
#line 61
  *p_ptr = p_mmap;
#line 62
  return;
}
}
#line 64 "secbuf.c"
void vsf_secbuf_free(char **p_ptr ) 
{ unsigned int map_size ;
  unsigned long page_offset ;
  char *p_mmap ;
  unsigned int page_size ;
  unsigned int __cil_tmp ;

  {
#line 69
  p_mmap = *p_ptr;
#line 70
  __cil_tmp = vsf_sysutil_getpagesize();
#line 70
  page_size = __cil_tmp;
#line 71
  if ((unsigned int )p_mmap == (unsigned int )((char *)0)) {
#line 73
    return;
  }
#line 76
  page_offset = (unsigned long )p_mmap % (unsigned long )page_size;
#line 77
  if (page_offset) {
#line 79
    p_mmap -= page_offset;
  }
#line 81
  p_mmap -= page_size;
#line 83
  vsf_sysutil_memprotect((void *)p_mmap, page_size, 1);
#line 85
  map_size = *((unsigned int *)p_mmap);
#line 87
  vsf_sysutil_memunmap((void *)p_mmap, map_size);
#line 88
  return;
}
}
#line 1 "cil-gpB3jW71.o"
#pragma merger(0,"/tmp/cil-a0ZYgVux.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 41 "ls.h"
int vsf_filename_passes_filter(struct mystr  const  *p_filename_str , struct mystr  const  *p_filter_str ) ;
#line 26 "access.h"
int vsf_access_check_file_visible(struct mystr  const  *p_filename_str ) ;
#line 55 "str.h"
void str_rpad(struct mystr *p_str , unsigned int min_width ) ;
#line 56
void str_lpad(struct mystr *p_str , unsigned int min_width ) ;
#line 77
struct str_locate_result str_locate_str(struct mystr  const  *p_str , struct mystr  const  *p_look_str ) ;
#line 85
struct str_locate_result str_locate_chars(struct mystr  const  *p_str , char const   *p_chars ) ;
#line 88
void str_left(struct mystr  const  *p_str , struct mystr *p_out , unsigned int chars ) ;
#line 20 "strlist.h"
void str_list_add(struct mystr_list *p_list , struct mystr  const  *p_str , struct mystr  const  *p_sort_key_str ) ;
#line 22
void str_list_sort(struct mystr_list *p_list , int reverse ) ;
#line 11 "sysstr.h"
int str_readlink(struct mystr *p_str , struct mystr  const  *p_filename_str ) ;
#line 29
int str_lstat(struct mystr  const  *p_str , struct vsf_sysutil_statbuf **p_ptr ) ;
#line 32
void str_next_dirent(struct mystr *p_filename_str , struct vsf_sysutil_dir *p_dir ) ;
#line 113 "sysutil.h"
int vsf_sysutil_statbuf_is_symlink(struct vsf_sysutil_statbuf  const  *p_stat ) ;
#line 118
char const   *vsf_sysutil_statbuf_get_perms(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) ;
#line 120
char const   *vsf_sysutil_statbuf_get_date(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ,
                                           int use_localtime ) ;
#line 124
unsigned int vsf_sysutil_statbuf_get_links(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) ;
#line 126
int vsf_sysutil_statbuf_get_uid(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) ;
#line 127
int vsf_sysutil_statbuf_get_gid(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) ;
#line 130
char const   *vsf_sysutil_statbuf_get_sortkey_mtime(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) ;
#line 279
struct vsf_sysutil_user *vsf_sysutil_getpwuid(int uid ) ;
#line 281
char const   *vsf_sysutil_user_getname(struct vsf_sysutil_user  const  *p_user ) ;
#line 287
struct vsf_sysutil_group *vsf_sysutil_getgrgid(int gid ) ;
#line 288
char const   *vsf_sysutil_group_getname(struct vsf_sysutil_group  const  *p_group ) ;
#line 18 "ls.c"
static void build_dir_line(struct mystr *p_str , struct mystr  const  *p_filename_str ,
                           struct vsf_sysutil_statbuf  const  *p_stat ) ;
#line 89 "ls.c"
static struct mystr s_next_filename_str  ;
#line 90 "ls.c"
static struct mystr s_next_path_and_filename_str  ;
#line 91 "ls.c"
static struct vsf_sysutil_statbuf *s_p_statbuf___5  ;
#line 143 "ls.c"
static struct mystr s_final_file_str  ;
#line 148 "ls.c"
static struct mystr s_temp_str  ;
#line 186 "ls.c"
static struct mystr s_temp_str___0  ;
#line 22 "ls.c"
void vsf_ls_populate_dir_list(struct mystr_list *p_list , struct mystr_list *p_subdir_list ,
                              struct vsf_sysutil_dir *p_dir , struct mystr  const  *p_base_dir_str ,
                              struct mystr  const  *p_option_str , struct mystr  const  *p_filter_str ,
                              int is_verbose ) 
{ struct mystr dirline_str ;
  struct mystr normalised_base_dir_str ;
  struct str_locate_result loc_result ;
  int a_option ;
  int r_option ;
  int t_option ;
  int F_option ;
  int do_stat ;
  int __cil_tmp ;
  char __cil_tmp___0 ;
  int __cil_tmp___1 ;
  unsigned int len ;
  unsigned int __cil_tmp___2 ;
  char __cil_tmp___3 ;
  int __cil_tmp___4 ;
  int len___0 ;
  int __cil_tmp___5 ;
  unsigned int __cil_tmp___6 ;
  char __cil_tmp___7 ;
  char __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  int __cil_tmp___11 ;
  int retval ;
  int __cil_tmp___12 ;
  int __cil_tmp___13 ;
  int retval___0 ;
  int __cil_tmp___14 ;
  int __cil_tmp___15 ;
  int __cil_tmp___16 ;
  int __cil_tmp___17 ;
  int __cil_tmp___18 ;
  int __cil_tmp___19 ;
  struct mystr  const  *p_sort_str ;
  struct mystr  const  *p_sort_subdir_str ;
  char const   *__cil_tmp___20 ;
  int __cil_tmp___21 ;

  {
#line 31
  dirline_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 31
  dirline_str.PRIVATE_HANDS_OFF_len = 0U;
#line 31
  dirline_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 32
  normalised_base_dir_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 32
  normalised_base_dir_str.PRIVATE_HANDS_OFF_len = 0U;
#line 32
  normalised_base_dir_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 38
  do_stat = 0;
#line 39
  loc_result = str_locate_char(p_option_str, (char )'a');
#line 40
  a_option = loc_result.found;
#line 41
  loc_result = str_locate_char(p_option_str, (char )'r');
#line 42
  r_option = loc_result.found;
#line 43
  loc_result = str_locate_char(p_option_str, (char )'t');
#line 44
  t_option = loc_result.found;
#line 45
  loc_result = str_locate_char(p_option_str, (char )'F');
#line 46
  F_option = loc_result.found;
#line 47
  loc_result = str_locate_char(p_option_str, (char )'l');
#line 48
  if (loc_result.found) {
#line 50
    is_verbose = 1;
  }
#line 53
  if (t_option) {
#line 55
    r_option = ! r_option;
  }
#line 57
  if (((is_verbose || t_option) || F_option) || (unsigned int )p_subdir_list != (unsigned int )((struct mystr_list *)0)) {
#line 59
    do_stat = 1;
  }
#line 62
  __cil_tmp = str_isempty(p_filter_str);
#line 62
  if (__cil_tmp) {
    _L: /* CIL Label */ ;
  } else {
#line 62
    __cil_tmp___0 = str_get_char_at(p_filter_str, 0U);
#line 62
    if ((int )__cil_tmp___0 == 46) {
#line 64
      a_option = 1;
    } else {
#line 62
      goto _L;
    }
  }
#line 69
  __cil_tmp___1 = str_equal_text(p_base_dir_str, ".");
#line 69
  if (! __cil_tmp___1) {
#line 71
    str_copy(& normalised_base_dir_str, p_base_dir_str);
  }
#line 73
  __cil_tmp___4 = str_isempty((struct mystr  const  *)(& normalised_base_dir_str));
#line 73
  if (! __cil_tmp___4) {
#line 75
    __cil_tmp___2 = str_getlen((struct mystr  const  *)(& normalised_base_dir_str));
#line 75
    len = __cil_tmp___2;
#line 76
    __cil_tmp___3 = str_get_char_at((struct mystr  const  *)(& normalised_base_dir_str),
                                    len - 1U);
#line 76
    if ((int )__cil_tmp___3 != 47) {
#line 78
      str_append_char(& normalised_base_dir_str, (char )'/');
    }
  }
#line 82
  if (is_verbose) {
#line 84
    vsf_sysutil_update_cached_time();
  }
#line 86
  while (1) {
#line 92
    str_next_dirent(& s_next_filename_str, p_dir);
#line 93
    __cil_tmp___5 = str_isempty((struct mystr  const  *)(& s_next_filename_str));
#line 93
    if (__cil_tmp___5) {
#line 95
      break;
    }
#line 97
    __cil_tmp___6 = str_getlen((struct mystr  const  *)(& s_next_filename_str));
#line 97
    len___0 = (int )__cil_tmp___6;
#line 98
    if (len___0 > 0) {
#line 98
      __cil_tmp___8 = str_get_char_at((struct mystr  const  *)(& s_next_filename_str),
                                      0U);
#line 98
      if ((int )__cil_tmp___8 == 46) {
#line 100
        if (! a_option && ! tunable_force_dot_files) {
#line 102
          continue;
        }
#line 104
        if (! a_option) {
#line 104
          if (len___0 == 2) {
#line 104
            __cil_tmp___7 = str_get_char_at((struct mystr  const  *)(& s_next_filename_str),
                                            1U);
#line 104
            if ((int )__cil_tmp___7 == 46) {
#line 104
              goto _L___1;
            } else {
#line 104
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 104
            if (len___0 == 1) {
              _L___1: /* CIL Label */ 
#line 108
              continue;
            } else {
#line 104
              goto _L___0;
            }
          }
        } else {
          _L___0: /* CIL Label */ ;
        }
      } else {
#line 98
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ ;
    }
#line 112
    __cil_tmp___9 = vsf_access_check_file_visible((struct mystr  const  *)(& s_next_filename_str));
#line 112
    if (! __cil_tmp___9) {
#line 114
      continue;
    }
#line 117
    __cil_tmp___11 = str_isempty(p_filter_str);
#line 117
    if (! __cil_tmp___11) {
#line 119
      __cil_tmp___10 = vsf_filename_passes_filter((struct mystr  const  *)(& s_next_filename_str),
                                                  p_filter_str);
#line 119
      if (! __cil_tmp___10) {
#line 121
        continue;
      }
    }
#line 127
    str_copy(& s_next_path_and_filename_str, (struct mystr  const  *)(& normalised_base_dir_str));
#line 128
    str_append_str(& s_next_path_and_filename_str, (struct mystr  const  *)(& s_next_filename_str));
#line 129
    if (do_stat) {
#line 135
      __cil_tmp___12 = str_lstat((struct mystr  const  *)(& s_next_path_and_filename_str),
                                 & s_p_statbuf___5);
#line 135
      retval = __cil_tmp___12;
#line 136
      __cil_tmp___13 = vsf_sysutil_retval_is_error(retval);
#line 136
      if (__cil_tmp___13) {
#line 138
        continue;
      }
    }
#line 141
    if (is_verbose) {
#line 145
      str_copy(& s_final_file_str, (struct mystr  const  *)(& s_next_filename_str));
#line 146
      __cil_tmp___16 = vsf_sysutil_statbuf_is_symlink((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___5);
#line 146
      if (__cil_tmp___16) {
#line 149
        __cil_tmp___14 = str_readlink(& s_temp_str, (struct mystr  const  *)(& s_next_path_and_filename_str));
#line 149
        retval___0 = __cil_tmp___14;
#line 150
        if (retval___0 == 0) {
#line 150
          __cil_tmp___15 = str_isempty((struct mystr  const  *)(& s_temp_str));
#line 150
          if (__cil_tmp___15) {
#line 150
            goto _L___4;
          } else {
#line 152
            str_append_text(& s_final_file_str, " -> ");
#line 153
            str_append_str(& s_final_file_str, (struct mystr  const  *)(& s_temp_str));
          }
        } else {
          _L___4: /* CIL Label */ ;
        }
      }
#line 156
      if (F_option) {
#line 156
        __cil_tmp___17 = vsf_sysutil_statbuf_is_dir((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___5);
#line 156
        if (__cil_tmp___17) {
#line 158
          str_append_char(& s_final_file_str, (char )'/');
        } else {
#line 156
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ ;
      }
#line 160
      build_dir_line(& dirline_str, (struct mystr  const  *)(& s_final_file_str),
                     (struct vsf_sysutil_statbuf  const  *)s_p_statbuf___5);
    } else {
#line 167
      str_copy(& dirline_str, (struct mystr  const  *)(& s_next_path_and_filename_str));
#line 168
      if (F_option) {
#line 170
        __cil_tmp___19 = vsf_sysutil_statbuf_is_dir((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___5);
#line 170
        if (__cil_tmp___19) {
#line 172
          str_append_char(& dirline_str, (char )'/');
        } else {
#line 174
          __cil_tmp___18 = vsf_sysutil_statbuf_is_symlink((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___5);
#line 174
          if (__cil_tmp___18) {
#line 176
            str_append_char(& dirline_str, (char )'@');
          }
        }
      }
#line 179
      str_append_text(& dirline_str, "\r\n");
    }
#line 187
    p_sort_str = (struct mystr  const  *)0;
#line 188
    p_sort_subdir_str = (struct mystr  const  *)0;
#line 189
    if (! t_option) {
#line 191
      p_sort_str = (struct mystr  const  *)(& s_next_filename_str);
    } else {
#line 195
      __cil_tmp___20 = vsf_sysutil_statbuf_get_sortkey_mtime((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___5);
#line 195
      str_alloc_text(& s_temp_str___0, __cil_tmp___20);
#line 197
      p_sort_str = (struct mystr  const  *)(& s_temp_str___0);
#line 198
      p_sort_subdir_str = (struct mystr  const  *)(& s_temp_str___0);
    }
#line 200
    str_list_add(p_list, (struct mystr  const  *)(& dirline_str), p_sort_str);
#line 201
    if ((unsigned int )p_subdir_list != (unsigned int )((struct mystr_list *)0)) {
#line 201
      __cil_tmp___21 = vsf_sysutil_statbuf_is_dir((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___5);
#line 201
      if (__cil_tmp___21) {
#line 203
        str_list_add(p_subdir_list, (struct mystr  const  *)(& s_next_filename_str),
                     p_sort_subdir_str);
      } else {
#line 201
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ ;
    }
  }
#line 207
  str_list_sort(p_list, r_option);
#line 208
  if ((unsigned int )p_subdir_list != (unsigned int )((struct mystr_list *)0)) {
#line 210
    str_list_sort(p_subdir_list, r_option);
  }
#line 212
  str_free(& dirline_str);
#line 213
  str_free(& normalised_base_dir_str);
#line 214
  return;
}
}
#line 247 "ls.c"
static struct mystr s_match_needed_str  ;
#line 216 "ls.c"
int vsf_filename_passes_filter(struct mystr  const  *p_filename_str , struct mystr  const  *p_filter_str ) 
{ struct mystr filter_remain_str ;
  struct mystr name_remain_str ;
  struct mystr temp_str ;
  struct mystr brace_list_str ;
  struct mystr new_filter_str ;
  int ret___0 ;
  char last_token ;
  int must_match_at_current_pos ;
  struct str_locate_result locate_result ;
  struct str_locate_result __cil_tmp ;
  unsigned int indexx ;
  unsigned int indexx___0 ;
  unsigned int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  unsigned int __cil_tmp___3 ;
  struct str_locate_result end_brace ;
  struct str_locate_result __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  unsigned int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  char __cil_tmp___9 ;
  int __cil_tmp___10 ;
  unsigned int __cil_tmp___11 ;

  {
#line 234
  filter_remain_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 234
  filter_remain_str.PRIVATE_HANDS_OFF_len = 0U;
#line 234
  filter_remain_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 235
  name_remain_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 235
  name_remain_str.PRIVATE_HANDS_OFF_len = 0U;
#line 235
  name_remain_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 236
  temp_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 236
  temp_str.PRIVATE_HANDS_OFF_len = 0U;
#line 236
  temp_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 237
  brace_list_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 237
  brace_list_str.PRIVATE_HANDS_OFF_len = 0U;
#line 237
  brace_list_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 238
  new_filter_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 238
  new_filter_str.PRIVATE_HANDS_OFF_len = 0U;
#line 238
  new_filter_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 239
  ret___0 = 0;
#line 240
  last_token = (char)0;
#line 241
  must_match_at_current_pos = 1;
#line 242
  str_copy(& filter_remain_str, p_filter_str);
#line 243
  str_copy(& name_remain_str, p_filename_str);
#line 245
  while (1) {
#line 245
    __cil_tmp___10 = str_isempty((struct mystr  const  *)(& filter_remain_str));
#line 245
    if (__cil_tmp___10) {
#line 245
      break;
    }
#line 249
    __cil_tmp = str_locate_chars((struct mystr  const  *)(& filter_remain_str), "*?{");
#line 249
    locate_result = __cil_tmp;
#line 252
    if (locate_result.found) {
#line 254
      indexx = locate_result.index;
#line 255
      str_left((struct mystr  const  *)(& filter_remain_str), & s_match_needed_str,
               indexx);
#line 256
      str_mid_to_end((struct mystr  const  *)(& filter_remain_str), & temp_str, indexx + 1U);
#line 257
      str_copy(& filter_remain_str, (struct mystr  const  *)(& temp_str));
#line 258
      last_token = locate_result.char_found;
    } else {
#line 263
      str_copy(& s_match_needed_str, (struct mystr  const  *)(& filter_remain_str));
#line 264
      str_empty(& filter_remain_str);
#line 265
      last_token = (char)0;
    }
#line 267
    __cil_tmp___1 = str_isempty((struct mystr  const  *)(& s_match_needed_str));
#line 267
    if (! __cil_tmp___1) {
#line 273
      locate_result = str_locate_str((struct mystr  const  *)(& name_remain_str),
                                     (struct mystr  const  *)(& s_match_needed_str));
#line 274
      if (! locate_result.found) {
#line 277
        goto out;
      }
#line 279
      indexx___0 = locate_result.index;
#line 280
      if (must_match_at_current_pos && indexx___0 > 0U) {
#line 282
        goto out;
      }
#line 285
      __cil_tmp___0 = str_getlen((struct mystr  const  *)(& s_match_needed_str));
#line 285
      str_mid_to_end((struct mystr  const  *)(& name_remain_str), & temp_str, indexx___0 + __cil_tmp___0);
#line 287
      str_copy(& name_remain_str, (struct mystr  const  *)(& temp_str));
    }
#line 289
    if ((int )last_token == 63) {
#line 291
      __cil_tmp___2 = str_isempty((struct mystr  const  *)(& name_remain_str));
#line 291
      if (__cil_tmp___2) {
#line 293
        goto out;
      }
#line 295
      __cil_tmp___3 = str_getlen((struct mystr  const  *)(& name_remain_str));
#line 295
      str_right((struct mystr  const  *)(& name_remain_str), & temp_str, __cil_tmp___3 - 1U);
#line 296
      str_copy(& name_remain_str, (struct mystr  const  *)(& temp_str));
#line 297
      must_match_at_current_pos = 1;
    } else {
#line 299
      if ((int )last_token == 123) {
#line 301
        __cil_tmp___4 = str_locate_char((struct mystr  const  *)(& filter_remain_str),
                                        (char )'}');
#line 301
        end_brace = __cil_tmp___4;
#line 303
        must_match_at_current_pos = 1;
#line 304
        if (end_brace.found) {
#line 306
          str_split_char(& filter_remain_str, & temp_str, (char )'}');
#line 307
          str_copy(& brace_list_str, (struct mystr  const  *)(& filter_remain_str));
#line 308
          str_copy(& filter_remain_str, (struct mystr  const  *)(& temp_str));
#line 309
          str_split_char(& brace_list_str, & temp_str, (char )',');
#line 310
          while (1) {
#line 310
            __cil_tmp___6 = str_isempty((struct mystr  const  *)(& brace_list_str));
#line 310
            if (__cil_tmp___6) {
#line 310
              break;
            }
#line 312
            str_copy(& new_filter_str, (struct mystr  const  *)(& brace_list_str));
#line 313
            str_append_str(& new_filter_str, (struct mystr  const  *)(& filter_remain_str));
#line 314
            __cil_tmp___5 = vsf_filename_passes_filter((struct mystr  const  *)(& name_remain_str),
                                                       (struct mystr  const  *)(& new_filter_str));
#line 314
            if (__cil_tmp___5) {
#line 316
              ret___0 = 1;
#line 317
              goto out;
            }
#line 319
            str_copy(& brace_list_str, (struct mystr  const  *)(& temp_str));
#line 320
            str_split_char(& brace_list_str, & temp_str, (char )',');
          }
#line 322
          goto out;
        } else {
#line 324
          __cil_tmp___8 = str_isempty((struct mystr  const  *)(& name_remain_str));
#line 324
          if (__cil_tmp___8) {
#line 324
            goto _L;
          } else {
#line 324
            __cil_tmp___9 = str_get_char_at((struct mystr  const  *)(& name_remain_str),
                                            0U);
#line 324
            if ((int )__cil_tmp___9 != 123) {
              _L: /* CIL Label */ 
#line 327
              goto out;
            } else {
#line 331
              __cil_tmp___7 = str_getlen((struct mystr  const  *)(& name_remain_str));
#line 331
              str_right((struct mystr  const  *)(& name_remain_str), & temp_str, __cil_tmp___7 - 1U);
#line 333
              str_copy(& name_remain_str, (struct mystr  const  *)(& temp_str));
            }
          }
        }
      } else {
#line 338
        must_match_at_current_pos = 0;
      }
    }
  }
#line 344
  __cil_tmp___11 = str_getlen((struct mystr  const  *)(& name_remain_str));
#line 344
  if (__cil_tmp___11 > 0U && (int )last_token != 42) {
#line 346
    goto out;
  }
#line 349
  ret___0 = 1;
  out: 
#line 351
  str_free(& filter_remain_str);
#line 352
  str_free(& name_remain_str);
#line 353
  str_free(& temp_str);
#line 354
  str_free(& brace_list_str);
#line 355
  str_free(& new_filter_str);
#line 356
  return (ret___0);
}
}
#line 363 "ls.c"
static struct mystr s_tmp_str___2  ;
#line 359 "ls.c"
static void build_dir_line(struct mystr *p_str , struct mystr  const  *p_filename_str ,
                           struct vsf_sysutil_statbuf  const  *p_stat ) 
{ filesize_t size ;
  filesize_t __cil_tmp ;
  char const   *__cil_tmp___0 ;
  unsigned int __cil_tmp___1 ;
  int uid ;
  int __cil_tmp___2 ;
  struct vsf_sysutil_user *p_user ;
  char const   *__cil_tmp___3 ;
  int gid ;
  int __cil_tmp___4 ;
  struct vsf_sysutil_group *p_group ;
  char const   *__cil_tmp___5 ;
  char const   *__cil_tmp___6 ;

  {
#line 364
  __cil_tmp = vsf_sysutil_statbuf_get_size(p_stat);
#line 364
  size = __cil_tmp;
#line 366
  __cil_tmp___0 = vsf_sysutil_statbuf_get_perms(p_stat);
#line 366
  str_alloc_text(p_str, __cil_tmp___0);
#line 367
  str_append_char(p_str, (char )' ');
#line 369
  __cil_tmp___1 = vsf_sysutil_statbuf_get_links(p_stat);
#line 369
  str_alloc_ulong(& s_tmp_str___2, (unsigned long )__cil_tmp___1);
#line 370
  str_lpad(& s_tmp_str___2, 4U);
#line 371
  str_append_str(p_str, (struct mystr  const  *)(& s_tmp_str___2));
#line 372
  str_append_char(p_str, (char )' ');
#line 374
  if (tunable_hide_ids) {
#line 376
    str_alloc_text(& s_tmp_str___2, "ftp");
  } else {
#line 380
    __cil_tmp___2 = vsf_sysutil_statbuf_get_uid(p_stat);
#line 380
    uid = __cil_tmp___2;
#line 381
    p_user = (struct vsf_sysutil_user *)0;
#line 382
    if (tunable_text_userdb_names) {
#line 384
      p_user = vsf_sysutil_getpwuid(uid);
    }
#line 386
    if ((unsigned int )p_user == (unsigned int )((struct vsf_sysutil_user *)0)) {
#line 388
      str_alloc_ulong(& s_tmp_str___2, (unsigned long )uid);
    } else {
#line 392
      __cil_tmp___3 = vsf_sysutil_user_getname((struct vsf_sysutil_user  const  *)p_user);
#line 392
      str_alloc_text(& s_tmp_str___2, __cil_tmp___3);
    }
  }
#line 395
  str_rpad(& s_tmp_str___2, 8U);
#line 396
  str_append_str(p_str, (struct mystr  const  *)(& s_tmp_str___2));
#line 397
  str_append_char(p_str, (char )' ');
#line 399
  if (tunable_hide_ids) {
#line 401
    str_alloc_text(& s_tmp_str___2, "ftp");
  } else {
#line 405
    __cil_tmp___4 = vsf_sysutil_statbuf_get_gid(p_stat);
#line 405
    gid = __cil_tmp___4;
#line 406
    p_group = (struct vsf_sysutil_group *)0;
#line 407
    if (tunable_text_userdb_names) {
#line 409
      p_group = vsf_sysutil_getgrgid(gid);
    }
#line 411
    if ((unsigned int )p_group == (unsigned int )((struct vsf_sysutil_group *)0)) {
#line 413
      str_alloc_ulong(& s_tmp_str___2, (unsigned long )gid);
    } else {
#line 417
      __cil_tmp___5 = vsf_sysutil_group_getname((struct vsf_sysutil_group  const  *)p_group);
#line 417
      str_alloc_text(& s_tmp_str___2, __cil_tmp___5);
    }
  }
#line 420
  str_rpad(& s_tmp_str___2, 8U);
#line 421
  str_append_str(p_str, (struct mystr  const  *)(& s_tmp_str___2));
#line 422
  str_append_char(p_str, (char )' ');
#line 424
  str_alloc_filesize_t(& s_tmp_str___2, size);
#line 425
  str_lpad(& s_tmp_str___2, 8U);
#line 426
  str_append_str(p_str, (struct mystr  const  *)(& s_tmp_str___2));
#line 427
  str_append_char(p_str, (char )' ');
#line 429
  __cil_tmp___6 = vsf_sysutil_statbuf_get_date(p_stat, tunable_use_localtime);
#line 429
  str_append_text(p_str, __cil_tmp___6);
#line 431
  str_append_char(p_str, (char )' ');
#line 433
  str_append_str(p_str, p_filename_str);
#line 434
  str_append_text(p_str, "\r\n");
#line 435
  return;
}
}
#line 1 "cil-gtjDm7WN.o"
#pragma merger(0,"/tmp/cil-fC5c9Nnr.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 13 "postprivparent.h"
void vsf_priv_parent_postlogin(struct vsf_session *p_sess ) ;
#line 15 "privops.h"
int vsf_privop_get_ftp_port_sock(struct vsf_session *p_sess ) ;
#line 25
void vsf_privop_do_file_chown(struct vsf_session *p_sess , int fd ) ;
#line 52 "sysutil.h"
void vsf_sysutil_block_sig(enum EVSFSysUtilSignal sig ) ;
#line 53
void vsf_sysutil_unblock_sig(enum EVSFSysUtilSignal sig ) ;
#line 32 "secutil.h"
void vsf_secutil_change_credentials(struct mystr  const  *p_user_str , struct mystr  const  *p_dir_str ,
                                    struct mystr  const  *p_ext_dir_str , unsigned int caps ,
                                    unsigned int options ) ;
#line 25 "postprivparent.c"
static void minimize_privilege(struct vsf_session *p_sess ) ;
#line 26
static void process_post_login_req(struct vsf_session *p_sess ) ;
#line 27
static void cmd_process_chown(struct vsf_session *p_sess ) ;
#line 28
static void cmd_process_get_data_sock(struct vsf_session *p_sess ) ;
#line 30 "postprivparent.c"
void vsf_priv_parent_postlogin(struct vsf_session *p_sess ) 
{ 

  {
#line 33
  minimize_privilege(p_sess);
#line 35
  while (1) {
#line 37
    process_post_login_req(p_sess);
  }
}
}
#line 41 "postprivparent.c"
static void process_post_login_req(struct vsf_session *p_sess ) 
{ char cmd ;

  {
#line 45
  vsf_sysutil_unblock_sig(3);
#line 47
  cmd = priv_sock_get_cmd(p_sess->parent_fd);
#line 48
  vsf_sysutil_block_sig(3);
#line 49
  if (tunable_chown_uploads && (int )cmd == 2) {
#line 51
    cmd_process_chown(p_sess);
  } else {
#line 53
    if (tunable_connect_from_port_20 && (int )cmd == 3) {
#line 55
      cmd_process_get_data_sock(p_sess);
    } else {
#line 59
      die("bad request in process_post_login_req");
    }
  }
#line 61
  return;
}
}
#line 63 "postprivparent.c"
static void minimize_privilege(struct vsf_session *p_sess ) 
{ unsigned int caps ;
  struct mystr user_str ;
  struct mystr dir_str ;

  {
#line 73
  if (! p_sess->is_anonymous && tunable_session_support) {
#line 77
    return;
  }
#line 79
  if (((! tunable_chown_uploads && ! tunable_connect_from_port_20) && ! tunable_max_per_ip) && ! tunable_max_clients) {
#line 83
    vsf_sysutil_exit(0);
  }
#line 86
  caps = 0U;
#line 87
  user_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 87
  user_str.PRIVATE_HANDS_OFF_len = 0U;
#line 87
  user_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 88
  dir_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 88
  dir_str.PRIVATE_HANDS_OFF_len = 0U;
#line 88
  dir_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 89
  str_alloc_text(& user_str, tunable_nopriv_user);
#line 90
  str_alloc_text(& dir_str, tunable_secure_chroot_dir);
#line 91
  if (tunable_chown_uploads) {
#line 93
    caps |= 1U;
  }
#line 95
  if (tunable_connect_from_port_20) {
#line 97
    caps |= 2U;
  }
#line 99
  vsf_secutil_change_credentials((struct mystr  const  *)(& user_str), (struct mystr  const  *)(& dir_str),
                                 (struct mystr  const  *)0, caps, 1U);
#line 101
  str_free(& user_str);
#line 102
  str_free(& dir_str);
#line 104
  return;
}
}
#line 106 "postprivparent.c"
static void cmd_process_chown(struct vsf_session *p_sess ) 
{ int the_fd ;
  int __cil_tmp ;

  {
#line 109
  __cil_tmp = priv_sock_recv_fd(p_sess->parent_fd);
#line 109
  the_fd = __cil_tmp;
#line 110
  vsf_privop_do_file_chown(p_sess, the_fd);
#line 111
  vsf_sysutil_close(the_fd);
#line 112
  priv_sock_send_result(p_sess->parent_fd, (char)1);
#line 113
  return;
}
}
#line 115 "postprivparent.c"
static void cmd_process_get_data_sock(struct vsf_session *p_sess ) 
{ int sock_fd ;
  int __cil_tmp ;

  {
#line 118
  __cil_tmp = vsf_privop_get_ftp_port_sock(p_sess);
#line 118
  sock_fd = __cil_tmp;
#line 119
  priv_sock_send_result(p_sess->parent_fd, (char)1);
#line 120
  priv_sock_send_fd(p_sess->parent_fd, sock_fd);
#line 121
  vsf_sysutil_close(sock_fd);
#line 122
  return;
}
}
#line 1 "cil-Nd7D7Bpv.o"
#pragma merger(0,"/tmp/cil-KHeBR5Ad.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 52 "str.h"
void str_append_double(struct mystr *p_str , double the_double ) ;
#line 87 "sysutil.h"
int vsf_sysutil_create_or_open_file(char const   *p_filename , unsigned int mode ) ;
#line 144
void vsf_sysutil_unlock_file(int fd ) ;
#line 162
unsigned int vsf_sysutil_getpid(void) ;
#line 297
char const   *vsf_sysutil_get_current_date(void) ;
#line 306
void vsf_sysutil_openlog(void) ;
#line 12 "sysstr.h"
int str_write_loop(struct mystr  const  *p_str , int fd ) ;
#line 37
void str_syslog(struct mystr  const  *p_str , int severe ) ;
#line 18 "logging.c"
static int vsf_log_type_is_transfer(enum EVSFLogEntryType type ) ;
#line 19
static void vsf_log_common(struct vsf_session *p_sess , int succeeded , enum EVSFLogEntryType what ,
                           struct mystr  const  *p_str ) ;
#line 22
static void vsf_log_do_log_vsftpd_format(struct vsf_session *p_sess , struct mystr *p_str ,
                                         int succeeded , enum EVSFLogEntryType what ,
                                         struct mystr  const  *p_log_str ) ;
#line 26
static void vsf_log_do_log_wuftpd_format(struct vsf_session *p_sess , struct mystr *p_str ,
                                         int succeeded ) ;
#line 28
static void vsf_log_do_log_to_file(int fd , struct mystr *p_str ) ;
#line 30 "logging.c"
void vsf_log_init(struct vsf_session *p_sess ) 
{ int retval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 34
  if (tunable_syslog_enable || tunable_tcp_wrappers) {
#line 36
    vsf_sysutil_openlog();
  }
#line 38
  if (! tunable_xferlog_enable && ! tunable_dual_log_enable) {
#line 40
    return;
  }
#line 42
  if (tunable_dual_log_enable || tunable_xferlog_std_format) {
#line 44
    retval = vsf_sysutil_create_or_open_file(tunable_xferlog_file, 384U);
#line 45
    __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 45
    if (__cil_tmp) {
#line 47
      die2("failed to open xferlog log file:", tunable_xferlog_file);
    }
#line 49
    p_sess->xferlog_fd = retval;
  }
#line 51
  if (tunable_dual_log_enable || ! tunable_xferlog_std_format) {
#line 53
    if (! tunable_syslog_enable) {
#line 55
      retval = vsf_sysutil_create_or_open_file(tunable_vsftpd_log_file, 384U);
#line 56
      __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 56
      if (__cil_tmp___0) {
#line 58
        die2("failed to open vsftpd log file:", tunable_vsftpd_log_file);
      }
#line 60
      p_sess->vsftpd_log_fd = retval;
    }
  }
#line 63
  return;
}
}
#line 65 "logging.c"
static int vsf_log_type_is_transfer(enum EVSFLogEntryType type ) 
{ 

  {
#line 68
  return ((int )type == 2 || (int )type == 3);
}
}
#line 71 "logging.c"
void vsf_log_start_entry(struct vsf_session *p_sess , enum EVSFLogEntryType what ) 
{ int __cil_tmp ;

  {
#line 74
  if (p_sess->log_type != 0UL) {
#line 76
    bug("non null log_type in vsf_log_start_entry");
  }
#line 78
  p_sess->log_type = (unsigned long )what;
#line 79
  p_sess->log_start_sec = 0L;
#line 80
  p_sess->log_start_usec = 0L;
#line 81
  p_sess->transfer_size = 0LL;
#line 82
  str_empty(& p_sess->log_str);
#line 83
  __cil_tmp = vsf_log_type_is_transfer(what);
#line 83
  if (__cil_tmp) {
#line 85
    vsf_sysutil_update_cached_time();
#line 86
    p_sess->log_start_sec = vsf_sysutil_get_cached_time_sec();
#line 87
    p_sess->log_start_usec = vsf_sysutil_get_cached_time_usec();
  }
#line 89
  return;
}
}
#line 91 "logging.c"
void vsf_log_line(struct vsf_session *p_sess , enum EVSFLogEntryType what , struct mystr *p_str ) 
{ 

  {
#line 95
  vsf_log_common(p_sess, 1, what, (struct mystr  const  *)p_str);
#line 96
  return;
}
}
#line 98 "logging.c"
int vsf_log_entry_pending(struct vsf_session *p_sess ) 
{ 

  {
#line 101
  if (p_sess->log_type == 0UL) {
#line 103
    return (0);
  }
#line 105
  return (1);
}
}
#line 108 "logging.c"
void vsf_log_clear_entry(struct vsf_session *p_sess ) 
{ 

  {
#line 111
  p_sess->log_type = 0UL;
#line 112
  return;
}
}
#line 114 "logging.c"
void vsf_log_do_log(struct vsf_session *p_sess , int succeeded ) 
{ 

  {
#line 117
  vsf_log_common(p_sess, succeeded, (enum EVSFLogEntryType )p_sess->log_type, (struct mystr  const  *)(& p_sess->log_str));
#line 119
  p_sess->log_type = 0UL;
#line 120
  return;
}
}
#line 126 "logging.c"
struct mystr s_log_str___0  ;
//static struct mystr s_log_str___0  ;
#line 122 "logging.c"
static void vsf_log_common(struct vsf_session *p_sess , int succeeded , enum EVSFLogEntryType what ,
                           struct mystr  const  *p_str ) 
{ int __cil_tmp ;
  int severe ;

  {
#line 128
  if (p_sess->xferlog_fd != -1) {
#line 128
    __cil_tmp = vsf_log_type_is_transfer(what);
#line 128
    if (__cil_tmp) {
#line 130
      vsf_log_do_log_wuftpd_format(p_sess, & s_log_str___0, succeeded);
#line 131
      vsf_log_do_log_to_file(p_sess->xferlog_fd, & s_log_str___0);
    } else {
#line 128
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 134
  if (p_sess->vsftpd_log_fd != -1) {
#line 136
    vsf_log_do_log_vsftpd_format(p_sess, & s_log_str___0, succeeded, what, p_str);
#line 137
    vsf_log_do_log_to_file(p_sess->vsftpd_log_fd, & s_log_str___0);
  }
#line 140
  if (tunable_syslog_enable) {
#line 142
    severe = 0;
#line 143
    vsf_log_do_log_vsftpd_format(p_sess, & s_log_str___0, succeeded, what, p_str);
#line 144
    if ((int )what == 5 && ! succeeded) {
#line 146
      severe = 1;
    }
#line 148
    str_syslog((struct mystr  const  *)(& s_log_str___0), severe);
  }
#line 150
  return;
}
}
#line 152 "logging.c"
static void vsf_log_do_log_to_file(int fd , struct mystr *p_str ) 
{ int retval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 155
  if (! tunable_no_log_lock) {
#line 157
    __cil_tmp = vsf_sysutil_lock_file_write(fd);
#line 157
    retval = __cil_tmp;
#line 158
    __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 158
    if (__cil_tmp___0) {
#line 160
      return;
    }
  }
#line 163
  str_replace_unprintable(p_str, (char )'?');
#line 164
  str_append_char(p_str, (char )'\n');
#line 166
  str_write_loop((struct mystr  const  *)p_str, fd);
#line 167
  if (! tunable_no_log_lock) {
#line 169
    vsf_sysutil_unlock_file(fd);
  }
#line 171
  return;
}
}
#line 173 "logging.c"
static void vsf_log_do_log_wuftpd_format(struct vsf_session *p_sess , struct mystr *p_str ,
                                         int succeeded ) 
{ long delta_sec ;
  enum EVSFLogEntryType what ;
  char const   *__cil_tmp ;
  long __cil_tmp___0 ;

  {
#line 178
  what = (enum EVSFLogEntryType )p_sess->log_type;
#line 180
  __cil_tmp = vsf_sysutil_get_current_date();
#line 180
  str_alloc_text(p_str, __cil_tmp);
#line 181
  str_append_char(p_str, (char )' ');
#line 183
  __cil_tmp___0 = vsf_sysutil_get_cached_time_sec();
#line 183
  delta_sec = __cil_tmp___0 - p_sess->log_start_sec;
#line 184
  if (delta_sec <= 0L) {
#line 186
    delta_sec = 1L;
  }
#line 188
  str_append_ulong(p_str, (unsigned long )delta_sec);
#line 189
  str_append_char(p_str, (char )' ');
#line 191
  str_append_str(p_str, (struct mystr  const  *)(& p_sess->remote_ip_str));
#line 192
  str_append_char(p_str, (char )' ');
#line 194
  str_append_filesize_t(p_str, p_sess->transfer_size);
#line 195
  str_append_char(p_str, (char )' ');
#line 197
  str_append_str(p_str, (struct mystr  const  *)(& p_sess->log_str));
#line 198
  str_append_char(p_str, (char )' ');
#line 200
  if (p_sess->is_ascii) {
#line 202
    str_append_text(p_str, "a ");
  } else {
#line 206
    str_append_text(p_str, "b ");
  }
#line 209
  str_append_text(p_str, "_ ");
#line 211
  if ((int )what == 3) {
#line 213
    str_append_text(p_str, "i ");
  } else {
#line 217
    str_append_text(p_str, "o ");
  }
#line 220
  if (p_sess->is_anonymous && ! p_sess->is_guest) {
#line 222
    str_append_text(p_str, "a ");
#line 223
    str_append_str(p_str, (struct mystr  const  *)(& p_sess->anon_pass_str));
  } else {
#line 227
    if (p_sess->is_guest) {
#line 229
      str_append_text(p_str, "g ");
    } else {
#line 233
      str_append_text(p_str, "r ");
    }
#line 235
    str_append_str(p_str, (struct mystr  const  *)(& p_sess->user_str));
  }
#line 237
  str_append_char(p_str, (char )' ');
#line 239
  str_append_text(p_str, "ftp 0 * ");
#line 241
  if (succeeded) {
#line 243
    str_append_char(p_str, (char )'c');
  } else {
#line 247
    str_append_char(p_str, (char )'i');
  }
#line 249
  return;
}
}
#line 251 "logging.c"
static void vsf_log_do_log_vsftpd_format(struct vsf_session *p_sess , struct mystr *p_str ,
                                         int succeeded , enum EVSFLogEntryType what ,
                                         struct mystr  const  *p_log_str ) 
{ char const   *__cil_tmp ;
  unsigned int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  long delta_sec ;
  long __cil_tmp___4 ;
  long delta_usec ;
  long __cil_tmp___5 ;
  double time_delta ;
  double kbyte_rate ;
  int __cil_tmp___6 ;

  {
#line 257
  __cil_tmp = vsf_sysutil_get_current_date();
#line 257
  str_alloc_text(p_str, __cil_tmp);
#line 259
  str_append_text(p_str, " [pid ");
#line 260
  __cil_tmp___0 = vsf_sysutil_getpid();
#line 260
  str_append_ulong(p_str, (unsigned long )__cil_tmp___0);
#line 261
  str_append_text(p_str, "] ");
#line 263
  __cil_tmp___1 = str_isempty((struct mystr  const  *)(& p_sess->user_str));
#line 263
  if (! __cil_tmp___1) {
#line 265
    str_append_char(p_str, (char )'[');
#line 266
    str_append_str(p_str, (struct mystr  const  *)(& p_sess->user_str));
#line 267
    str_append_text(p_str, "] ");
  }
#line 270
  if ((((int )what != 6 && (int )what != 7) && (int )what != 8) && (int )what != 13) {
#line 273
    if (succeeded) {
#line 275
      str_append_text(p_str, "OK ");
    } else {
#line 279
      str_append_text(p_str, "FAIL ");
    }
  }
#line 282
  switch ((int )what) {
  case 2: 
#line 285
  str_append_text(p_str, "DOWNLOAD");
#line 286
  break;
  case 3: 
#line 288
  str_append_text(p_str, "UPLOAD");
#line 289
  break;
  case 4: 
#line 291
  str_append_text(p_str, "MKDIR");
#line 292
  break;
  case 5: 
#line 294
  str_append_text(p_str, "LOGIN");
#line 295
  break;
  case 6: 
#line 297
  str_append_text(p_str, "FTP command");
#line 298
  break;
  case 7: 
#line 300
  str_append_text(p_str, "FTP response");
#line 301
  break;
  case 8: 
#line 303
  str_append_text(p_str, "CONNECT");
#line 304
  break;
  case 9: 
#line 306
  str_append_text(p_str, "DELETE");
#line 307
  break;
  case 10: 
#line 309
  str_append_text(p_str, "RENAME");
#line 310
  break;
  case 11: 
#line 312
  str_append_text(p_str, "RMDIR");
#line 313
  break;
  case 12: 
#line 315
  str_append_text(p_str, "CHMOD");
#line 316
  break;
  case 13: 
#line 318
  str_append_text(p_str, "DEBUG");
#line 319
  break;
  default: 
#line 321
  bug("bad entry_type in vsf_log_do_log");
#line 322
  break;
  }
#line 324
  str_append_text(p_str, ": Client \"");
#line 325
  str_append_str(p_str, (struct mystr  const  *)(& p_sess->remote_ip_str));
#line 326
  str_append_char(p_str, (char )'\"');
#line 327
  if ((int )what == 5) {
#line 327
    __cil_tmp___2 = str_isempty((struct mystr  const  *)(& p_sess->anon_pass_str));
#line 327
    if (__cil_tmp___2) {
#line 327
      goto _L;
    } else {
#line 329
      str_append_text(p_str, ", anon password \"");
#line 330
      str_append_str(p_str, (struct mystr  const  *)(& p_sess->anon_pass_str));
#line 331
      str_append_char(p_str, (char )'\"');
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 333
  __cil_tmp___3 = str_isempty(p_log_str);
#line 333
  if (! __cil_tmp___3) {
#line 335
    str_append_text(p_str, ", \"");
#line 336
    str_append_str(p_str, p_log_str);
#line 337
    str_append_char(p_str, (char )'\"');
  }
#line 339
  if (((int )what != 6 && (int )what != 7) && (int )what != 13) {
#line 342
    if (p_sess->transfer_size) {
#line 344
      str_append_text(p_str, ", ");
#line 345
      str_append_filesize_t(p_str, p_sess->transfer_size);
#line 346
      str_append_text(p_str, " bytes");
    }
#line 348
    __cil_tmp___6 = vsf_log_type_is_transfer(what);
#line 348
    if (__cil_tmp___6) {
#line 350
      __cil_tmp___4 = vsf_sysutil_get_cached_time_sec();
#line 350
      delta_sec = __cil_tmp___4 - p_sess->log_start_sec;
#line 352
      __cil_tmp___5 = vsf_sysutil_get_cached_time_usec();
#line 352
      delta_usec = __cil_tmp___5 - p_sess->log_start_usec;
#line 354
      time_delta = (double )delta_sec + (double )delta_usec / (double )1000000;
#line 357
      if (time_delta <= (double )0) {
#line 359
        time_delta = 0.1;
      }
#line 361
      kbyte_rate = ((double )p_sess->transfer_size / time_delta) / (double )1024;
#line 363
      str_append_text(p_str, ", ");
#line 364
      str_append_double(p_str, kbyte_rate);
#line 365
      str_append_text(p_str, "Kbyte/sec");
    }
  }
#line 368
  return;
}
}
#line 1 "cil-hyUzzGko.o"
#pragma merger(0,"/tmp/cil-ihLEZIMn.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 24 "str.h"
void private_str_alloc_memchunk(struct mystr *p_str , char const   *p_src , unsigned int len ) ;
#line 29
void str_alloc_alt_term(struct mystr *p_str , char const   *p_src , char term ) ;
#line 33
char const   *str_strdup(struct mystr  const  *p_str ) ;
#line 43
int str_strcmp(struct mystr  const  *p_str1 , struct mystr  const  *p_str2 ) ;
#line 63
void str_split_text(struct mystr *p_src , struct mystr *p_rhs , char const   *p_text ) ;
#line 65
void str_split_text_reverse(struct mystr *p_src , struct mystr *p_rhs , char const   *p_text ) ;
#line 79
struct str_locate_result str_locate_str_reverse(struct mystr  const  *p_str , struct mystr  const  *p_look_str ) ;
#line 81
struct str_locate_result str_locate_text(struct mystr  const  *p_str , char const   *p_text ) ;
#line 83
struct str_locate_result str_locate_text_reverse(struct mystr  const  *p_str , char const   *p_text ) ;
#line 96
int str_contains_space(struct mystr  const  *p_str ) ;
#line 97
int str_contains_unprintable(struct mystr  const  *p_str ) ;
#line 112
int str_getline(struct mystr  const  *p_str , struct mystr *p_line_str , unsigned int *p_pos ) ;
#line 157 "sysutil.h"
void *vsf_sysutil_malloc(unsigned int size ) ;
#line 158
void *vsf_sysutil_realloc(void *p_ptr , unsigned int size ) ;
#line 184
void vsf_sysutil_memcpy(void *p_dest , void const   *p_src , unsigned int size ) ;
#line 187
int vsf_sysutil_memcmp(void const   *p_src1 , void const   *p_src2 , unsigned int size ) ;
#line 191
filesize_t vsf_sysutil_a_to_filesize_t(char const   *p_str ) ;
#line 193
char const   *vsf_sysutil_filesize_t_to_str(filesize_t the_filesize ) ;
#line 194
char const   *vsf_sysutil_double_to_str(double the_double ) ;
#line 196
unsigned int vsf_sysutil_octal_to_uint(char const   *p_str ) ;
#line 197
int vsf_sysutil_toupper(int the_char ) ;
#line 198
int vsf_sysutil_isspace(int the_char ) ;
#line 199
int vsf_sysutil_isprint(int the_char ) ;
#line 24 "str.c"
static void str_split_text_common(struct mystr *p_src , struct mystr *p_rhs , char const   *p_text ,
                                  int is_reverse ) ;
#line 26
static int str_equal_internal(char const   *p_buf1 , unsigned int buf1_len , char const   *p_buf2 ,
                              unsigned int buf2_len ) ;
#line 30 "str.c"
static void s_setbuf(struct mystr *p_str , char *p_newbuf ) 
{ 

  {
#line 33
  if ((unsigned int )p_str->PRIVATE_HANDS_OFF_p_buf != (unsigned int )((char *)0)) {
#line 35
    bug("p_buf not NULL when setting it");
  }
#line 37
  p_str->PRIVATE_HANDS_OFF_p_buf = p_newbuf;
#line 38
  return;
}
}
#line 40 "str.c"
void private_str_alloc_memchunk(struct mystr *p_str , char const   *p_src , unsigned int len ) 
{ unsigned int buf_needed ;
  void *__cil_tmp ;

  {
#line 45
  buf_needed = len + 1U;
#line 46
  if (buf_needed > p_str->PRIVATE_HANDS_OFF_alloc_bytes) {
#line 48
    str_free(p_str);
#line 49
    __cil_tmp = vsf_sysutil_malloc(buf_needed);
#line 49
    s_setbuf(p_str, (char *)__cil_tmp);
#line 50
    p_str->PRIVATE_HANDS_OFF_alloc_bytes = buf_needed;
  }
#line 52
  vsf_sysutil_memcpy((void *)p_str->PRIVATE_HANDS_OFF_p_buf, (void const   *)p_src,
                     len);
#line 53
  *(p_str->PRIVATE_HANDS_OFF_p_buf + len) = (char )'\000';
#line 54
  p_str->PRIVATE_HANDS_OFF_len = len;
#line 55
  return;
}
}
#line 57 "str.c"
void private_str_append_memchunk(struct mystr *p_str , char const   *p_src , unsigned int len ) 
{ unsigned int buf_needed ;
  void *__cil_tmp ;

  {
#line 61
  buf_needed = (p_str->PRIVATE_HANDS_OFF_len + len) + 1U;
#line 62
  if (buf_needed > p_str->PRIVATE_HANDS_OFF_alloc_bytes) {
#line 64
    __cil_tmp = vsf_sysutil_realloc((void *)p_str->PRIVATE_HANDS_OFF_p_buf, buf_needed);
#line 64
    p_str->PRIVATE_HANDS_OFF_p_buf = (char *)__cil_tmp;
#line 65
    p_str->PRIVATE_HANDS_OFF_alloc_bytes = buf_needed;
  }
#line 67
  vsf_sysutil_memcpy((void *)(p_str->PRIVATE_HANDS_OFF_p_buf + p_str->PRIVATE_HANDS_OFF_len),
                     (void const   *)p_src, len);
#line 68
  *(p_str->PRIVATE_HANDS_OFF_p_buf + (p_str->PRIVATE_HANDS_OFF_len + len)) = (char )'\000';
#line 69
  p_str->PRIVATE_HANDS_OFF_len += len;
#line 70
  return;
}
}
#line 73 "str.c"
void str_alloc_text(struct mystr *p_str , char const   *p_src ) 
{ unsigned int len ;
  unsigned int __cil_tmp ;

  {
#line 76
  __cil_tmp = vsf_sysutil_strlen(p_src);
#line 76
  len = __cil_tmp;
#line 77
  private_str_alloc_memchunk(p_str, p_src, len);
#line 78
  return;
}
}
#line 80 "str.c"
void str_copy(struct mystr *p_dest , struct mystr  const  *p_src ) 
{ 

  {
#line 83
  private_str_alloc_memchunk(p_dest, (char const   *)p_src->PRIVATE_HANDS_OFF_p_buf,
                             (unsigned int )p_src->PRIVATE_HANDS_OFF_len);
#line 84
  return;
}
}
#line 86 "str.c"
char const   *str_strdup(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 89
  __cil_tmp = str_getbuf(p_str);
#line 89
  __cil_tmp___0 = vsf_sysutil_strdup(__cil_tmp);
#line 89
  return ((char const   *)__cil_tmp___0);
}
}
#line 92 "str.c"
void str_alloc_alt_term(struct mystr *p_str , char const   *p_src , char term ) 
{ char const   *p_search ;
  unsigned int len ;

  {
#line 95
  p_search = p_src;
#line 96
  len = 0U;
#line 97
  while ((int const   )*p_search != (int const   )term) {
#line 99
    p_search ++;
#line 100
    len ++;
  }
#line 102
  private_str_alloc_memchunk(p_str, p_src, len);
#line 103
  return;
}
}
#line 105 "str.c"
void str_alloc_ulong(struct mystr *p_str , unsigned long the_long ) 
{ char const   *__cil_tmp ;

  {
#line 108
  __cil_tmp = vsf_sysutil_ulong_to_str(the_long);
#line 108
  str_alloc_text(p_str, __cil_tmp);
#line 109
  return;
}
}
#line 111 "str.c"
void str_alloc_filesize_t(struct mystr *p_str , filesize_t the_filesize ) 
{ char const   *__cil_tmp ;

  {
#line 114
  __cil_tmp = vsf_sysutil_filesize_t_to_str(the_filesize);
#line 114
  str_alloc_text(p_str, __cil_tmp);
#line 115
  return;
}
}
#line 117 "str.c"
void str_free(struct mystr *p_str ) 
{ 

  {
#line 120
  if ((unsigned int )p_str->PRIVATE_HANDS_OFF_p_buf != (unsigned int )((char *)0)) {
#line 122
    vsf_sysutil_free((void *)p_str->PRIVATE_HANDS_OFF_p_buf);
  }
#line 124
  p_str->PRIVATE_HANDS_OFF_p_buf = (char *)0;
#line 125
  p_str->PRIVATE_HANDS_OFF_len = 0U;
#line 126
  p_str->PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 127
  return;
}
}
#line 129 "str.c"
void str_empty(struct mystr *p_str ) 
{ 

  {
#line 133
  str_getbuf((struct mystr  const  *)p_str);
#line 134
  str_trunc(p_str, 0U);
#line 135
  return;
}
}
#line 137 "str.c"
void str_trunc(struct mystr *p_str , unsigned int trunc_len ) 
{ 

  {
#line 140
  if (trunc_len >= p_str->PRIVATE_HANDS_OFF_alloc_bytes) {
#line 142
    bug("trunc_len not smaller than alloc_bytes in str_trunc");
  }
#line 144
  p_str->PRIVATE_HANDS_OFF_len = trunc_len;
#line 145
  *(p_str->PRIVATE_HANDS_OFF_p_buf + p_str->PRIVATE_HANDS_OFF_len) = (char )'\000';
#line 146
  return;
}
}
#line 148 "str.c"
void str_reserve(struct mystr *p_str , unsigned int res_len ) 
{ void *__cil_tmp ;

  {
#line 152
  res_len ++;
#line 153
  if (res_len > p_str->PRIVATE_HANDS_OFF_alloc_bytes) {
#line 155
    __cil_tmp = vsf_sysutil_realloc((void *)p_str->PRIVATE_HANDS_OFF_p_buf, res_len);
#line 155
    p_str->PRIVATE_HANDS_OFF_p_buf = (char *)__cil_tmp;
#line 156
    p_str->PRIVATE_HANDS_OFF_alloc_bytes = res_len;
  }
#line 158
  *(p_str->PRIVATE_HANDS_OFF_p_buf + (res_len - 1U)) = (char )'\000';
#line 159
  return;
}
}
#line 161 "str.c"
int str_isempty(struct mystr  const  *p_str ) 
{ 

  {
#line 164
  return (p_str->PRIVATE_HANDS_OFF_len == 0U);
}
}
#line 167 "str.c"
unsigned int str_getlen(struct mystr  const  *p_str ) 
{ 

  {
#line 170
  return ((unsigned int )p_str->PRIVATE_HANDS_OFF_len);
}
}
#line 173 "str.c"
char const   *str_getbuf(struct mystr  const  *p_str ) 
{ 

  {
#line 176
  if ((unsigned int )p_str->PRIVATE_HANDS_OFF_p_buf == (unsigned int )((char * const  )0)) {
#line 178
    if (p_str->PRIVATE_HANDS_OFF_len != 0U || p_str->PRIVATE_HANDS_OFF_alloc_bytes != 0U) {
#line 180
      bug("p_buf NULL and len or alloc_bytes != 0 in str_getbuf");
    }
#line 182
    private_str_alloc_memchunk((struct mystr *)p_str, (char const   *)0, 0U);
  }
#line 184
  return ((char const   *)p_str->PRIVATE_HANDS_OFF_p_buf);
}
}
#line 187 "str.c"
int str_strcmp(struct mystr  const  *p_str1 , struct mystr  const  *p_str2 ) 
{ int __cil_tmp ;

  {
#line 190
  __cil_tmp = str_equal_internal((char const   *)p_str1->PRIVATE_HANDS_OFF_p_buf,
                                 (unsigned int )p_str1->PRIVATE_HANDS_OFF_len, (char const   *)p_str2->PRIVATE_HANDS_OFF_p_buf,
                                 (unsigned int )p_str2->PRIVATE_HANDS_OFF_len);
#line 190
  return (__cil_tmp);
}
}
#line 194 "str.c"
static int str_equal_internal(char const   *p_buf1 , unsigned int buf1_len , char const   *p_buf2 ,
                              unsigned int buf2_len ) 
{ int retval ;
  unsigned int minlen ;

  {
#line 199
  minlen = buf1_len;
#line 200
  if (buf2_len < minlen) {
#line 202
    minlen = buf2_len;
  }
#line 204
  retval = vsf_sysutil_memcmp((void const   *)p_buf1, (void const   *)p_buf2, minlen);
#line 205
  if (retval != 0 || buf1_len == buf2_len) {
#line 207
    return (retval);
  }
#line 210
  return ((int )(buf1_len - buf2_len));
}
}
#line 213 "str.c"
int str_equal(struct mystr  const  *p_str1 , struct mystr  const  *p_str2 ) 
{ int __cil_tmp ;

  {
#line 216
  __cil_tmp = str_strcmp(p_str1, p_str2);
#line 216
  return (__cil_tmp == 0);
}
}
#line 219 "str.c"
int str_equal_text(struct mystr  const  *p_str , char const   *p_text ) 
{ unsigned int cmplen ;
  unsigned int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 222
  __cil_tmp = vsf_sysutil_strlen(p_text);
#line 222
  cmplen = __cil_tmp;
#line 223
  __cil_tmp___0 = str_equal_internal((char const   *)p_str->PRIVATE_HANDS_OFF_p_buf,
                                     (unsigned int )p_str->PRIVATE_HANDS_OFF_len,
                                     p_text, cmplen);
#line 223
  return (__cil_tmp___0 == 0);
}
}
#line 226 "str.c"
void str_append_str(struct mystr *p_str , struct mystr  const  *p_other ) 
{ 

  {
#line 229
  private_str_append_memchunk(p_str, (char const   *)p_other->PRIVATE_HANDS_OFF_p_buf,
                              (unsigned int )p_other->PRIVATE_HANDS_OFF_len);
#line 230
  return;
}
}
#line 232 "str.c"
void str_append_text(struct mystr *p_str , char const   *p_src ) 
{ unsigned int len ;
  unsigned int __cil_tmp ;

  {
#line 235
  __cil_tmp = vsf_sysutil_strlen(p_src);
#line 235
  len = __cil_tmp;
#line 236
  private_str_append_memchunk(p_str, p_src, len);
#line 237
  return;
}
}
#line 239 "str.c"
void str_append_char(struct mystr *p_str , char the_char ) 
{ 

  {
#line 242
  private_str_append_memchunk(p_str, (char const   *)(& the_char), (unsigned int )sizeof(the_char));
#line 243
  return;
}
}
#line 245 "str.c"
void str_append_ulong(struct mystr *p_str , unsigned long the_ulong ) 
{ char const   *__cil_tmp ;

  {
#line 248
  __cil_tmp = vsf_sysutil_ulong_to_str(the_ulong);
#line 248
  str_append_text(p_str, __cil_tmp);
#line 249
  return;
}
}
#line 251 "str.c"
void str_append_filesize_t(struct mystr *p_str , filesize_t the_filesize ) 
{ char const   *__cil_tmp ;

  {
#line 254
  __cil_tmp = vsf_sysutil_filesize_t_to_str(the_filesize);
#line 254
  str_append_text(p_str, __cil_tmp);
#line 255
  return;
}
}
#line 257 "str.c"
void str_append_double(struct mystr *p_str , double the_double ) 
{ char const   *__cil_tmp ;

  {
#line 260
  __cil_tmp = vsf_sysutil_double_to_str(the_double);
#line 260
  str_append_text(p_str, __cil_tmp);
#line 261
  return;
}
}
#line 263 "str.c"
void str_upper(struct mystr *p_str ) 
{ unsigned int i ;
  int __cil_tmp ;

  {
#line 267
  i = 0U;
#line 267
  while (i < p_str->PRIVATE_HANDS_OFF_len) {
#line 269
    __cil_tmp = vsf_sysutil_toupper((int )*(p_str->PRIVATE_HANDS_OFF_p_buf + i));
#line 269
    *(p_str->PRIVATE_HANDS_OFF_p_buf + i) = (char )__cil_tmp;
#line 267
    i ++;
  }
#line 271
  return;
}
}
#line 273 "str.c"
void str_rpad(struct mystr *p_str , unsigned int min_width ) 
{ unsigned int to_pad ;
  unsigned int __cil_tmp ;

  {
#line 277
  if (p_str->PRIVATE_HANDS_OFF_len >= min_width) {
#line 279
    return;
  }
#line 281
  to_pad = min_width - p_str->PRIVATE_HANDS_OFF_len;
#line 282
  while (1) {
#line 282
    __cil_tmp = to_pad;
#line 282
    to_pad --;
#line 282
    if (! __cil_tmp) {
#line 282
      break;
    }
#line 284
    str_append_char(p_str, (char )' ');
  }
#line 286
  return;
}
}
#line 291 "str.c"
static struct mystr s_tmp_str___3  ;
#line 288 "str.c"
void str_lpad(struct mystr *p_str , unsigned int min_width ) 
{ unsigned int to_pad ;
  unsigned int __cil_tmp ;

  {
#line 293
  if (p_str->PRIVATE_HANDS_OFF_len >= min_width) {
#line 295
    return;
  }
#line 297
  to_pad = min_width - p_str->PRIVATE_HANDS_OFF_len;
#line 298
  str_empty(& s_tmp_str___3);
#line 299
  while (1) {
#line 299
    __cil_tmp = to_pad;
#line 299
    to_pad --;
#line 299
    if (! __cil_tmp) {
#line 299
      break;
    }
#line 301
    str_append_char(& s_tmp_str___3, (char )' ');
  }
#line 303
  str_append_str(& s_tmp_str___3, (struct mystr  const  *)p_str);
#line 304
  str_copy(p_str, (struct mystr  const  *)(& s_tmp_str___3));
#line 305
  return;
}
}
#line 307 "str.c"
void str_replace_char(struct mystr *p_str , char from , char to ) 
{ unsigned int i ;

  {
#line 311
  i = 0U;
#line 311
  while (i < p_str->PRIVATE_HANDS_OFF_len) {
#line 313
    if ((int )*(p_str->PRIVATE_HANDS_OFF_p_buf + i) == (int )from) {
#line 315
      *(p_str->PRIVATE_HANDS_OFF_p_buf + i) = to;
    }
#line 311
    i ++;
  }
#line 318
  return;
}
}
#line 323 "str.c"
struct mystr s_lhs_chunk_str  ;
//static struct mystr s_lhs_chunk_str  ;
#line 324 "str.c"
struct mystr s_rhs_chunk_str  ;
//static struct mystr s_rhs_chunk_str  ;
#line 320 "str.c"
void str_replace_text(struct mystr *p_str , char const   *p_from , char const   *p_to ) 
{ unsigned int lhs_len ;
  unsigned int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 326
  str_copy(& s_lhs_chunk_str, (struct mystr  const  *)p_str);
#line 327
  str_free(p_str);
#line 328
  while (1) {
#line 330
    lhs_len = str_getlen((struct mystr  const  *)(& s_lhs_chunk_str));
#line 331
    str_split_text(& s_lhs_chunk_str, & s_rhs_chunk_str, p_from);
#line 333
    str_append_str(p_str, (struct mystr  const  *)(& s_lhs_chunk_str));
#line 335
    __cil_tmp = str_getlen((struct mystr  const  *)(& s_lhs_chunk_str));
#line 335
    if (__cil_tmp < lhs_len) {
#line 337
      str_append_text(p_str, p_to);
    }
#line 340
    str_copy(& s_lhs_chunk_str, (struct mystr  const  *)(& s_rhs_chunk_str));
#line 328
    __cil_tmp___0 = str_isempty((struct mystr  const  *)(& s_lhs_chunk_str));
#line 328
    if (__cil_tmp___0) {
#line 328
      break;
    }
  }
#line 342
  return;
}
}
#line 344 "str.c"
void str_split_char(struct mystr *p_src , struct mystr *p_rhs , char c ) 
{ char ministr[2] ;

  {
#line 349
  ministr[0] = c;
#line 350
  ministr[1] = (char )'\000';
#line 351
  str_split_text(p_src, p_rhs, (char const   *)(ministr));
#line 352
  return;
}
}
#line 354 "str.c"
void str_split_char_reverse(struct mystr *p_src , struct mystr *p_rhs , char c ) 
{ char ministr[2] ;

  {
#line 359
  ministr[0] = c;
#line 360
  ministr[1] = (char )'\000';
#line 361
  str_split_text_reverse(p_src, p_rhs, (char const   *)(ministr));
#line 362
  return;
}
}
#line 364 "str.c"
void str_split_text(struct mystr *p_src , struct mystr *p_rhs , char const   *p_text ) 
{ 

  {
#line 367
  str_split_text_common(p_src, p_rhs, p_text, 0);
#line 368
  return;
}
}
#line 370 "str.c"
void str_split_text_reverse(struct mystr *p_src , struct mystr *p_rhs , char const   *p_text ) 
{ 

  {
#line 374
  str_split_text_common(p_src, p_rhs, p_text, 1);
#line 375
  return;
}
}
#line 377 "str.c"
static void str_split_text_common(struct mystr *p_src , struct mystr *p_rhs , char const   *p_text ,
                                  int is_reverse ) 
{ struct str_locate_result locate_result ;
  unsigned int indexx ;
  unsigned int search_len ;
  unsigned int __cil_tmp ;

  {
#line 383
  __cil_tmp = vsf_sysutil_strlen(p_text);
#line 383
  search_len = __cil_tmp;
#line 384
  if (is_reverse) {
#line 386
    locate_result = str_locate_text_reverse((struct mystr  const  *)p_src, p_text);
  } else {
#line 390
    locate_result = str_locate_text((struct mystr  const  *)p_src, p_text);
  }
#line 393
  if (! locate_result.found) {
#line 395
    str_empty(p_rhs);
#line 396
    return;
  }
#line 398
  indexx = locate_result.index;
#line 399
  if (indexx + search_len > p_src->PRIVATE_HANDS_OFF_len) {
#line 401
    bug("indexx invalid in str_split_text");
  }
#line 404
  private_str_alloc_memchunk(p_rhs, (char const   *)((p_src->PRIVATE_HANDS_OFF_p_buf + indexx) + search_len),
                             (p_src->PRIVATE_HANDS_OFF_len - indexx) - search_len);
#line 407
  str_trunc(p_src, indexx);
#line 408
  return;
}
}
#line 410 "str.c"
struct str_locate_result str_locate_str(struct mystr  const  *p_str , struct mystr  const  *p_look_str ) 
{ char const   *__cil_tmp ;
  struct str_locate_result __cil_tmp___0 ;

  {
#line 413
  __cil_tmp = str_getbuf(p_look_str);
#line 413
  __cil_tmp___0 = str_locate_text(p_str, __cil_tmp);
#line 413
  return (__cil_tmp___0);
}
}
#line 416 "str.c"
struct str_locate_result str_locate_str_reverse(struct mystr  const  *p_str , struct mystr  const  *p_look_str ) 
{ char const   *__cil_tmp ;
  struct str_locate_result __cil_tmp___0 ;

  {
#line 420
  __cil_tmp = str_getbuf(p_look_str);
#line 420
  __cil_tmp___0 = str_locate_text_reverse(p_str, __cil_tmp);
#line 420
  return (__cil_tmp___0);
}
}
#line 423 "str.c"
struct str_locate_result str_locate_char(struct mystr  const  *p_str , char look_char ) 
{ char look_str[2] ;
  struct str_locate_result __cil_tmp ;

  {
#line 427
  look_str[0] = look_char;
#line 428
  look_str[1] = (char )'\000';
#line 429
  __cil_tmp = str_locate_text(p_str, (char const   *)(look_str));
#line 429
  return (__cil_tmp);
}
}
#line 432 "str.c"
struct str_locate_result str_locate_chars(struct mystr  const  *p_str , char const   *p_chars ) 
{ struct str_locate_result retval ;
  unsigned int num_chars ;
  unsigned int __cil_tmp ;
  unsigned int i ;
  unsigned int j ;
  char this_char ;

  {
#line 436
  __cil_tmp = vsf_sysutil_strlen(p_chars);
#line 436
  num_chars = __cil_tmp;
#line 437
  i = 0U;
#line 438
  retval.found = 0;
#line 439
  retval.char_found = (char)0;
#line 440
  retval.index = 0U;
#line 441
  while (i < (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 443
    j = 0U;
#line 444
    this_char = *(p_str->PRIVATE_HANDS_OFF_p_buf + i);
#line 445
    while (j < num_chars) {
#line 447
      if ((int const   )*(p_chars + j) == (int const   )this_char) {
#line 449
        retval.found = 1;
#line 450
        retval.index = i;
#line 451
        retval.char_found = (char )*(p_chars + j);
#line 452
        return (retval);
      }
#line 445
      j ++;
    }
#line 441
    i ++;
  }
#line 456
  return (retval);
}
}
#line 459 "str.c"
struct str_locate_result str_locate_text(struct mystr  const  *p_str , char const   *p_text ) 
{ struct str_locate_result retval ;
  unsigned int i ;
  unsigned int text_len ;
  unsigned int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 464
  __cil_tmp = vsf_sysutil_strlen(p_text);
#line 464
  text_len = __cil_tmp;
#line 465
  retval.found = 0;
#line 466
  retval.char_found = (char)0;
#line 467
  retval.index = 0U;
#line 468
  if (text_len == 0U || text_len > (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 471
    return (retval);
  }
#line 473
  i = 0U;
#line 473
  while (i <= (unsigned int )(p_str->PRIVATE_HANDS_OFF_len - (unsigned int const   )text_len)) {
#line 475
    __cil_tmp___0 = vsf_sysutil_memcmp((void const   *)(p_str->PRIVATE_HANDS_OFF_p_buf + i),
                                       (void const   *)p_text, text_len);
#line 475
    if (__cil_tmp___0 == 0) {
#line 477
      retval.found = 1;
#line 478
      retval.index = i;
#line 479
      return (retval);
    }
#line 473
    i ++;
  }
#line 483
  return (retval);
}
}
#line 486 "str.c"
struct str_locate_result str_locate_text_reverse(struct mystr  const  *p_str , char const   *p_text ) 
{ struct str_locate_result retval ;
  unsigned int i ;
  unsigned int text_len ;
  unsigned int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 491
  __cil_tmp = vsf_sysutil_strlen(p_text);
#line 491
  text_len = __cil_tmp;
#line 492
  retval.found = 0;
#line 493
  retval.char_found = (char)0;
#line 494
  retval.index = 0U;
#line 495
  if (text_len == 0U || text_len > (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 497
    return (retval);
  }
#line 499
  i = (unsigned int )(p_str->PRIVATE_HANDS_OFF_len - (unsigned int const   )text_len);
#line 501
  while (1) {
#line 503
    __cil_tmp___0 = vsf_sysutil_memcmp((void const   *)(p_str->PRIVATE_HANDS_OFF_p_buf + i),
                                       (void const   *)p_text, text_len);
#line 503
    if (__cil_tmp___0 == 0) {
#line 505
      retval.found = 1;
#line 506
      retval.index = i;
#line 507
      return (retval);
    }
#line 509
    if (i == 0U) {
#line 511
      break;
    }
#line 513
    i --;
  }
#line 516
  return (retval);
}
}
#line 519 "str.c"
void str_left(struct mystr  const  *p_str , struct mystr *p_out , unsigned int chars ) 
{ 

  {
#line 522
  if (chars > (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 524
    bug("chars invalid in str_left");
  }
#line 526
  private_str_alloc_memchunk(p_out, (char const   *)p_str->PRIVATE_HANDS_OFF_p_buf,
                             chars);
#line 527
  return;
}
}
#line 529 "str.c"
void str_right(struct mystr  const  *p_str , struct mystr *p_out , unsigned int chars ) 
{ unsigned int indexx ;

  {
#line 532
  indexx = (unsigned int )(p_str->PRIVATE_HANDS_OFF_len - (unsigned int const   )chars);
#line 533
  if (chars > (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 535
    bug("chars invalid in str_right");
  }
#line 537
  private_str_alloc_memchunk(p_out, (char const   *)(p_str->PRIVATE_HANDS_OFF_p_buf + indexx),
                             chars);
#line 538
  return;
}
}
#line 540 "str.c"
void str_mid_to_end(struct mystr  const  *p_str , struct mystr *p_out , unsigned int indexx ) 
{ 

  {
#line 544
  if (indexx > (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 546
    bug("invalid indexx in str_mid_to_end");
  }
#line 548
  private_str_alloc_memchunk(p_out, (char const   *)(p_str->PRIVATE_HANDS_OFF_p_buf + indexx),
                             (unsigned int )(p_str->PRIVATE_HANDS_OFF_len - (unsigned int const   )indexx));
#line 550
  return;
}
}
#line 552 "str.c"
char str_get_char_at(struct mystr  const  *p_str , unsigned int indexx ) 
{ 

  {
#line 555
  if (indexx >= (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 557
    bug("bad indexx in str_get_char_at");
  }
#line 559
  return (*(p_str->PRIVATE_HANDS_OFF_p_buf + indexx));
}
}
#line 562 "str.c"
int str_contains_space(struct mystr  const  *p_str ) 
{ unsigned int i ;
  int __cil_tmp ;

  {
#line 566
  i = 0U;
#line 566
  while (i < (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 568
    __cil_tmp = vsf_sysutil_isspace((int )*(p_str->PRIVATE_HANDS_OFF_p_buf + i));
#line 568
    if (__cil_tmp) {
#line 570
      return (1);
    }
#line 566
    i ++;
  }
#line 573
  return (0);
}
}
#line 576 "str.c"
int str_contains_unprintable(struct mystr  const  *p_str ) 
{ unsigned int i ;
  int __cil_tmp ;

  {
#line 580
  i = 0U;
#line 580
  while (i < (unsigned int )p_str->PRIVATE_HANDS_OFF_len) {
#line 582
    __cil_tmp = vsf_sysutil_isprint((int )*(p_str->PRIVATE_HANDS_OFF_p_buf + i));
#line 582
    if (! __cil_tmp) {
#line 584
      return (1);
    }
#line 580
    i ++;
  }
#line 587
  return (0);
}
}
#line 590 "str.c"
int str_atoi(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 593
  __cil_tmp = str_getbuf(p_str);
#line 593
  __cil_tmp___0 = vsf_sysutil_atoi(__cil_tmp);
#line 593
  return (__cil_tmp___0);
}
}
#line 596 "str.c"
filesize_t str_a_to_filesize_t(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  filesize_t __cil_tmp___0 ;

  {
#line 599
  __cil_tmp = str_getbuf(p_str);
#line 599
  __cil_tmp___0 = vsf_sysutil_a_to_filesize_t(__cil_tmp);
#line 599
  return (__cil_tmp___0);
}
}
#line 602 "str.c"
unsigned int str_octal_to_uint(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  unsigned int __cil_tmp___0 ;

  {
#line 605
  __cil_tmp = str_getbuf(p_str);
#line 605
  __cil_tmp___0 = vsf_sysutil_octal_to_uint(__cil_tmp);
#line 605
  return (__cil_tmp___0);
}
}
#line 608 "str.c"
int str_getline(struct mystr  const  *p_str , struct mystr *p_line_str , unsigned int *p_pos ) 
{ unsigned int start_pos ;
  unsigned int curr_pos ;
  unsigned int buf_len ;
  unsigned int __cil_tmp ;
  char const   *p_buf ;
  char const   *__cil_tmp___0 ;
  unsigned int out_len ;

  {
#line 612
  start_pos = *p_pos;
#line 613
  curr_pos = start_pos;
#line 614
  __cil_tmp = str_getlen(p_str);
#line 614
  buf_len = __cil_tmp;
#line 615
  __cil_tmp___0 = str_getbuf(p_str);
#line 615
  p_buf = __cil_tmp___0;
#line 617
  if (start_pos > buf_len) {
#line 619
    bug("p_pos out of range in str_getline");
  }
#line 621
  str_empty(p_line_str);
#line 622
  if (start_pos == buf_len) {
#line 624
    return (0);
  }
#line 626
  while (curr_pos < buf_len && (int const   )*(p_buf + curr_pos) != 10) {
#line 628
    curr_pos ++;
  }
#line 630
  out_len = curr_pos - start_pos;
#line 632
  if (curr_pos < buf_len && (int const   )*(p_buf + curr_pos) == 10) {
#line 634
    curr_pos ++;
  }
#line 636
  private_str_alloc_memchunk(p_line_str, p_buf + start_pos, out_len);
#line 637
  *p_pos = curr_pos;
#line 638
  return (1);
}
}
#line 644 "str.c"
static struct mystr s_curr_line_str  ;
#line 641 "str.c"
int str_contains_line(struct mystr  const  *p_str , struct mystr  const  *p_line_str ) 
{ unsigned int pos ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 645
  pos = 0U;
#line 646
  while (1) {
#line 646
    __cil_tmp___0 = str_getline(p_str, & s_curr_line_str, & pos);
#line 646
    if (! __cil_tmp___0) {
#line 646
      break;
    }
#line 648
    __cil_tmp = str_equal((struct mystr  const  *)(& s_curr_line_str), p_line_str);
#line 648
    if (__cil_tmp) {
#line 650
      return (1);
    }
  }
#line 653
  return (0);
}
}
#line 656 "str.c"
void str_replace_unprintable(struct mystr *p_str , char new_char ) 
{ unsigned int i ;
  int __cil_tmp ;

  {
#line 660
  i = 0U;
#line 660
  while (i < p_str->PRIVATE_HANDS_OFF_len) {
#line 662
    __cil_tmp = vsf_sysutil_isprint((int )*(p_str->PRIVATE_HANDS_OFF_p_buf + i));
#line 662
    if (! __cil_tmp) {
#line 664
      *(p_str->PRIVATE_HANDS_OFF_p_buf + i) = new_char;
    }
#line 660
    i ++;
  }
#line 667
  return;
}
}
#line 1 "cil-yzjjfe2x.o"
#pragma merger(0,"/tmp/cil-h6Mt5TZB.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 23 "netstr.h"
void str_netfd_alloc(struct mystr *p_str , int fd , char term , char *p_readbuf___0 ,
                     unsigned int maxlen ) ;
#line 13 "sysstr.h"
int str_read_loop(struct mystr *p_str , int fd ) ;
#line 267 "sysutil.h"
int vsf_sysutil_recv_peek(int fd , void *p_buf , unsigned int len ) ;
#line 18 "netstr.c"
void str_netfd_alloc(struct mystr *p_str , int fd , char term , char *p_readbuf___0 ,
                     unsigned int maxlen ) 
{ int retval ;
  unsigned int bytes_read ;
  unsigned int i ;
  char *p_readpos ;
  unsigned int left ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 25
  p_readpos = p_readbuf___0;
#line 26
  left = maxlen;
#line 27
  while (1) {
#line 29
    if ((unsigned int )(p_readpos + left) != (unsigned int )(p_readbuf___0 + maxlen)) {
#line 31
      bug("poor buffer accounting in str_netfd_alloc");
    }
#line 34
    if (left == 0U) {
#line 36
      str_empty(p_str);
#line 37
      return;
    }
#line 39
    retval = vsf_sysutil_recv_peek(fd, (void *)p_readpos, left);
#line 40
    __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 40
    if (__cil_tmp) {
#line 42
      die("vsf_sysutil_recv_peek");
    } else {
#line 44
      if (retval == 0) {
#line 46
        die("vsf_sysutil_recv_peek: no data");
      }
    }
#line 48
    bytes_read = (unsigned int )retval;
#line 50
    i = 0U;
#line 50
    while (i < bytes_read) {
#line 52
      if ((int )*(p_readpos + i) == (int )term) {
#line 55
        retval = vsf_sysutil_read_loop(fd, (void *)p_readpos, i + 1U);
#line 56
        __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 56
        if (__cil_tmp___0 || (unsigned int )retval != i + 1U) {
#line 59
          die("vsf_sysutil_read_loop");
        }
#line 61
        if ((int )*(p_readpos + i) != (int )term) {
#line 63
          die("missing terminator in str_netfd_alloc");
        }
#line 65
        str_alloc_alt_term(p_str, (char const   *)p_readbuf___0, term);
#line 66
        return;
      }
#line 50
      i ++;
    }
#line 70
    if (bytes_read > left) {
#line 72
      bug("bytes_read > left in str_netfd_alloc");
    }
#line 74
    left -= bytes_read;
#line 75
    retval = vsf_sysutil_read_loop(fd, (void *)p_readpos, bytes_read);
#line 76
    __cil_tmp___1 = vsf_sysutil_retval_is_error(retval);
#line 76
    if (__cil_tmp___1 || (unsigned int )retval != bytes_read) {
#line 79
      die("vsf_sysutil_read_loop");
    }
#line 81
    p_readpos += bytes_read;
  }
}
}
#line 85 "netstr.c"
int str_netfd_write(struct mystr  const  *p_str , int fd ) 
{ int ret___0 ;
  int retval ;
  unsigned int str_len ;
  unsigned int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 88
  ret___0 = 0;
#line 90
  __cil_tmp = str_getlen(p_str);
#line 90
  str_len = __cil_tmp;
#line 91
  if (str_len == 0U) {
#line 93
    bug("zero str_len in str_netfd_write");
  }
#line 95
  retval = str_write_loop(p_str, fd);
#line 96
  __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 96
  if (__cil_tmp___0 || (unsigned int )retval != str_len) {
#line 98
    ret___0 = -1;
  }
#line 100
  return (ret___0);
}
}
#line 103 "netstr.c"
int str_netfd_read(struct mystr *p_str , int fd , unsigned int len ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 107
  str_reserve(p_str, len);
#line 108
  str_trunc(p_str, len);
#line 109
  retval = str_read_loop(p_str, fd);
#line 110
  __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 110
  if (__cil_tmp || (unsigned int )retval != len) {
#line 112
    return (-1);
  }
#line 114
  return (retval);
}
}
#line 1 "cil-df6NcFjc.o"
#pragma merger(0,"/tmp/cil-IP3jE5My.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 60 "sysutil.h"
char *vsf_sysutil_getcwd(char *p_dest , unsigned int buf_size ) ;
#line 61
int vsf_sysutil_mkdir(char const   *p_dirname , unsigned int mode ) ;
#line 62
int vsf_sysutil_rmdir(char const   *p_dirname ) ;
#line 63
int vsf_sysutil_chdir(char const   *p_dirname ) ;
#line 64
int vsf_sysutil_rename(char const   *p_from , char const   *p_to ) ;
#line 67
struct vsf_sysutil_dir *vsf_sysutil_opendir(char const   *p_dirname ) ;
#line 69
char const   *vsf_sysutil_next_dirent(struct vsf_sysutil_dir *p_dir ) ;
#line 78
int vsf_sysutil_open_file(char const   *p_filename , enum EVSFSysUtilOpenMode mode ) ;
#line 81
int vsf_sysutil_create_file(char const   *p_filename ) ;
#line 83
int vsf_sysutil_create_overwrite_file(char const   *p_filename ) ;
#line 91
int vsf_sysutil_unlink(char const   *p_dead ) ;
#line 108
int vsf_sysutil_lstat(char const   *p_name , struct vsf_sysutil_statbuf **p_ptr ) ;
#line 133
int vsf_sysutil_chmod(char const   *p_filename , unsigned int mode ) ;
#line 136
int vsf_sysutil_readlink(char const   *p_filename , char *p_dest , unsigned int bufsiz ) ;
#line 307
void vsf_sysutil_syslog(char const   *p_text , int severe ) ;
#line 22 "sysstr.c"
static char *p_getcwd_buf  ;
#line 19 "sysstr.c"
void str_getcwd(struct mystr *p_str ) 
{ char *p_ret ;

  {
#line 24
  if ((unsigned int )p_getcwd_buf == (unsigned int )((char *)0)) {
#line 26
    vsf_secbuf_alloc(& p_getcwd_buf, 4096U);
  }
#line 29
  str_empty(p_str);
#line 30
  p_ret = vsf_sysutil_getcwd(p_getcwd_buf, 4096U);
#line 31
  if ((unsigned int )p_ret != (unsigned int )((char *)0)) {
#line 33
    str_alloc_text(p_str, (char const   *)p_getcwd_buf);
  }
#line 35
  return;
}
}
#line 37 "sysstr.c"
int str_write_loop(struct mystr  const  *p_str , int fd ) 
{ unsigned int __cil_tmp ;
  char const   *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 40
  __cil_tmp = str_getlen(p_str);
#line 40
  __cil_tmp___0 = str_getbuf(p_str);
#line 40
  __cil_tmp___1 = vsf_sysutil_write_loop(fd, (void const   *)__cil_tmp___0, __cil_tmp);
#line 40
  return (__cil_tmp___1);
}
}
#line 43 "sysstr.c"
int str_read_loop(struct mystr *p_str , int fd ) 
{ unsigned int __cil_tmp ;
  char const   *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 46
  __cil_tmp = str_getlen((struct mystr  const  *)p_str);
#line 46
  __cil_tmp___0 = str_getbuf((struct mystr  const  *)p_str);
#line 46
  __cil_tmp___1 = vsf_sysutil_read_loop(fd, (void *)((char *)__cil_tmp___0), __cil_tmp);
#line 46
  return (__cil_tmp___1);
}
}
#line 50 "sysstr.c"
int str_mkdir(struct mystr  const  *p_str , unsigned int mode ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 53
  __cil_tmp = str_getbuf(p_str);
#line 53
  __cil_tmp___0 = vsf_sysutil_mkdir(__cil_tmp, mode);
#line 53
  return (__cil_tmp___0);
}
}
#line 56 "sysstr.c"
int str_rmdir(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 59
  __cil_tmp = str_getbuf(p_str);
#line 59
  __cil_tmp___0 = vsf_sysutil_rmdir(__cil_tmp);
#line 59
  return (__cil_tmp___0);
}
}
#line 62 "sysstr.c"
int str_unlink(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 65
  __cil_tmp = str_getbuf(p_str);
#line 65
  __cil_tmp___0 = vsf_sysutil_unlink(__cil_tmp);
#line 65
  return (__cil_tmp___0);
}
}
#line 68 "sysstr.c"
int str_chdir(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 71
  __cil_tmp = str_getbuf(p_str);
#line 71
  __cil_tmp___0 = vsf_sysutil_chdir(__cil_tmp);
#line 71
  return (__cil_tmp___0);
}
}
#line 74 "sysstr.c"
int str_open(struct mystr  const  *p_str , enum EVSFSysStrOpenMode mode ) 
{ enum EVSFSysUtilOpenMode open_mode ;
  char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 77
  open_mode = (enum EVSFSysUtilOpenMode )0;
#line 78
  switch ((int )mode) {
  case 1: 
#line 81
  open_mode = 1;
#line 82
  break;
  default: 
#line 84
  bug("unknown mode value in str_open");
#line 85
  break;
  }
#line 87
  __cil_tmp = str_getbuf(p_str);
#line 87
  __cil_tmp___0 = vsf_sysutil_open_file(__cil_tmp, open_mode);
#line 87
  return (__cil_tmp___0);
}
}
#line 90 "sysstr.c"
int str_stat(struct mystr  const  *p_str , struct vsf_sysutil_statbuf **p_ptr ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 93
  __cil_tmp = str_getbuf(p_str);
#line 93
  __cil_tmp___0 = vsf_sysutil_stat(__cil_tmp, p_ptr);
#line 93
  return (__cil_tmp___0);
}
}
#line 96 "sysstr.c"
int str_lstat(struct mystr  const  *p_str , struct vsf_sysutil_statbuf **p_ptr ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 99
  __cil_tmp = str_getbuf(p_str);
#line 99
  __cil_tmp___0 = vsf_sysutil_lstat(__cil_tmp, p_ptr);
#line 99
  return (__cil_tmp___0);
}
}
#line 102 "sysstr.c"
int str_create(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 105
  __cil_tmp = str_getbuf(p_str);
#line 105
  __cil_tmp___0 = vsf_sysutil_create_file(__cil_tmp);
#line 105
  return (__cil_tmp___0);
}
}
#line 108 "sysstr.c"
int str_create_overwrite(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 111
  __cil_tmp = str_getbuf(p_str);
#line 111
  __cil_tmp___0 = vsf_sysutil_create_overwrite_file(__cil_tmp);
#line 111
  return (__cil_tmp___0);
}
}
#line 114 "sysstr.c"
int str_create_append(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 117
  __cil_tmp = str_getbuf(p_str);
#line 117
  __cil_tmp___0 = vsf_sysutil_create_or_open_file(__cil_tmp, tunable_file_open_mode);
#line 117
  return (__cil_tmp___0);
}
}
#line 121 "sysstr.c"
int str_chmod(struct mystr  const  *p_str , unsigned int mode ) 
{ char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 124
  __cil_tmp = str_getbuf(p_str);
#line 124
  __cil_tmp___0 = vsf_sysutil_chmod(__cil_tmp, mode);
#line 124
  return (__cil_tmp___0);
}
}
#line 127 "sysstr.c"
int str_rename(struct mystr  const  *p_from_str , struct mystr  const  *p_to_str ) 
{ char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 130
  __cil_tmp = str_getbuf(p_to_str);
#line 130
  __cil_tmp___0 = str_getbuf(p_from_str);
#line 130
  __cil_tmp___1 = vsf_sysutil_rename(__cil_tmp___0, __cil_tmp);
#line 130
  return (__cil_tmp___1);
}
}
#line 133 "sysstr.c"
struct vsf_sysutil_dir *str_opendir(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;
  struct vsf_sysutil_dir *__cil_tmp___0 ;

  {
#line 136
  __cil_tmp = str_getbuf(p_str);
#line 136
  __cil_tmp___0 = vsf_sysutil_opendir(__cil_tmp);
#line 136
  return (__cil_tmp___0);
}
}
#line 139 "sysstr.c"
void str_next_dirent(struct mystr *p_filename_str , struct vsf_sysutil_dir *p_dir ) 
{ char const   *p_filename ;
  char const   *__cil_tmp ;

  {
#line 142
  __cil_tmp = vsf_sysutil_next_dirent(p_dir);
#line 142
  p_filename = __cil_tmp;
#line 143
  str_empty(p_filename_str);
#line 144
  if ((unsigned int )p_filename != (unsigned int )((char const   *)0)) {
#line 146
    str_alloc_text(p_filename_str, p_filename);
  }
#line 148
  return;
}
}
#line 153 "sysstr.c"
static char *p_readlink_buf  ;
#line 150 "sysstr.c"
int str_readlink(struct mystr *p_str , struct mystr  const  *p_filename_str ) 
{ int retval ;
  char const   *__cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 155
  if ((unsigned int )p_readlink_buf == (unsigned int )((char *)0)) {
#line 157
    vsf_secbuf_alloc(& p_readlink_buf, 4096U);
  }
#line 160
  str_empty(p_str);
#line 162
  __cil_tmp = str_getbuf(p_filename_str);
#line 162
  retval = vsf_sysutil_readlink(__cil_tmp, p_readlink_buf, 4096U);
#line 164
  __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 164
  if (__cil_tmp___0) {
#line 166
    return (retval);
  }
#line 168
  str_alloc_text(p_str, (char const   *)p_readlink_buf);
#line 169
  return (0);
}
}
#line 172 "sysstr.c"
struct vsf_sysutil_user *str_getpwnam(struct mystr  const  *p_user_str ) 
{ char const   *__cil_tmp ;
  struct vsf_sysutil_user *__cil_tmp___0 ;

  {
#line 175
  __cil_tmp = str_getbuf(p_user_str);
#line 175
  __cil_tmp___0 = vsf_sysutil_getpwnam(__cil_tmp);
#line 175
  return (__cil_tmp___0);
}
}
#line 178 "sysstr.c"
void str_syslog(struct mystr  const  *p_str , int severe ) 
{ char const   *__cil_tmp ;

  {
#line 181
  __cil_tmp = str_getbuf(p_str);
#line 181
  vsf_sysutil_syslog(__cil_tmp, severe);
#line 182
  return;
}
}
#line 1 "cil-xlUuLqcX.o"
#pragma merger(0,"/tmp/cil-brLPh8UE.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 25 "strlist.h"
int str_list_contains_str(struct mystr_list  const  *p_list , struct mystr  const  *p_str ) ;
#line 298 "sysutil.h"
void vsf_sysutil_qsort(void *p_base , unsigned int num_elem , unsigned int elem_size ,
                       int (*p_compar)(void const   * , void const   * ) ) ;
#line 25 "strlist.c"
static struct mystr s_null_str  ;
#line 27
static int sort_compare_func(void const   *p1 , void const   *p2 ) ;
#line 28
static int sort_compare_func_reverse(void const   *p1 , void const   *p2 ) ;
#line 29
static int sort_compare_common(void const   *p1 , void const   *p2 , int reverse ) ;
#line 31 "strlist.c"
void str_list_free(struct mystr_list *p_list ) 
{ unsigned int i ;

  {
#line 35
  i = 0U;
#line 35
  while (i < p_list->PRIVATE_HANDS_OFF_list_len) {
#line 37
    str_free(& (p_list->PRIVATE_HANDS_OFF_p_nodes + i)->str);
#line 38
    str_free(& (p_list->PRIVATE_HANDS_OFF_p_nodes + i)->sort_key_str);
#line 35
    i ++;
  }
#line 40
  p_list->PRIVATE_HANDS_OFF_list_len = 0U;
#line 41
  p_list->PRIVATE_HANDS_OFF_alloc_len = 0U;
#line 42
  if (p_list->PRIVATE_HANDS_OFF_p_nodes) {
#line 44
    vsf_sysutil_free((void *)p_list->PRIVATE_HANDS_OFF_p_nodes);
#line 45
    p_list->PRIVATE_HANDS_OFF_p_nodes = (struct mystr_list_node *)0;
  }
#line 47
  return;
}
}
#line 49 "strlist.c"
int str_list_get_length(struct mystr_list  const  *p_list ) 
{ 

  {
#line 52
  return ((int )p_list->PRIVATE_HANDS_OFF_list_len);
}
}
#line 55 "strlist.c"
int str_list_contains_str(struct mystr_list  const  *p_list , struct mystr  const  *p_str ) 
{ unsigned int i ;
  int __cil_tmp ;

  {
#line 60
  i = 0U;
#line 60
  while (i < (unsigned int )p_list->PRIVATE_HANDS_OFF_list_len) {
#line 62
    __cil_tmp = str_equal(p_str, (struct mystr  const  *)(& (p_list->PRIVATE_HANDS_OFF_p_nodes + i)->str));
#line 62
    if (__cil_tmp) {
#line 64
      return (1);
    }
#line 60
    i ++;
  }
#line 67
  return (0);
}
}
#line 70 "strlist.c"
void str_list_add(struct mystr_list *p_list , struct mystr  const  *p_str , struct mystr  const  *p_sort_key_str ) 
{ struct mystr_list_node *p_node ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 76
  if (p_list->PRIVATE_HANDS_OFF_list_len == p_list->PRIVATE_HANDS_OFF_alloc_len) {
#line 78
    if (p_list->PRIVATE_HANDS_OFF_alloc_len == 0U) {
#line 80
      p_list->PRIVATE_HANDS_OFF_alloc_len = 32U;
#line 81
      __cil_tmp = vsf_sysutil_malloc((unsigned int )((unsigned long )p_list->PRIVATE_HANDS_OFF_alloc_len * sizeof(struct mystr_list_node )));
#line 81
      p_list->PRIVATE_HANDS_OFF_p_nodes = (struct mystr_list_node *)__cil_tmp;
    } else {
#line 86
      p_list->PRIVATE_HANDS_OFF_alloc_len *= 2U;
#line 87
      __cil_tmp___0 = vsf_sysutil_realloc((void *)p_list->PRIVATE_HANDS_OFF_p_nodes,
                                          (unsigned int )((unsigned long )p_list->PRIVATE_HANDS_OFF_alloc_len * sizeof(struct mystr_list_node )));
#line 87
      p_list->PRIVATE_HANDS_OFF_p_nodes = (struct mystr_list_node *)__cil_tmp___0;
    }
  }
#line 92
  p_node = p_list->PRIVATE_HANDS_OFF_p_nodes + p_list->PRIVATE_HANDS_OFF_list_len;
#line 93
  p_node->str = s_null_str;
#line 94
  p_node->sort_key_str = s_null_str;
#line 95
  str_copy(& p_node->str, p_str);
#line 96
  if (p_sort_key_str) {
#line 98
    str_copy(& p_node->sort_key_str, p_sort_key_str);
  }
#line 100
  (p_list->PRIVATE_HANDS_OFF_list_len) ++;
#line 101
  return;
}
}
#line 103 "strlist.c"
void str_list_sort(struct mystr_list *p_list , int reverse ) 
{ 

  {
#line 106
  if (! reverse) {
#line 108
    vsf_sysutil_qsort((void *)p_list->PRIVATE_HANDS_OFF_p_nodes, p_list->PRIVATE_HANDS_OFF_list_len,
                      (unsigned int )sizeof(struct mystr_list_node ), & sort_compare_func);
  } else {
#line 113
    vsf_sysutil_qsort((void *)p_list->PRIVATE_HANDS_OFF_p_nodes, p_list->PRIVATE_HANDS_OFF_list_len,
                      (unsigned int )sizeof(struct mystr_list_node ), & sort_compare_func_reverse);
  }
#line 117
  return;
}
}
#line 119 "strlist.c"
static int sort_compare_func(void const   *p1 , void const   *p2 ) 
{ int __cil_tmp ;

  {
#line 122
  __cil_tmp = sort_compare_common(p1, p2, 0);
#line 122
  return (__cil_tmp);
}
}
#line 125 "strlist.c"
static int sort_compare_func_reverse(void const   *p1 , void const   *p2 ) 
{ int __cil_tmp ;

  {
#line 128
  __cil_tmp = sort_compare_common(p1, p2, 1);
#line 128
  return (__cil_tmp);
}
}
#line 131 "strlist.c"
static int sort_compare_common(void const   *p1 , void const   *p2 , int reverse ) 
{ struct mystr  const  *p_cmp1 ;
  struct mystr  const  *p_cmp2 ;
  struct mystr_list_node  const  *p_node1 ;
  struct mystr_list_node  const  *p_node2 ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 136
  p_node1 = (struct mystr_list_node  const  *)p1;
#line 137
  p_node2 = (struct mystr_list_node  const  *)p2;
#line 138
  __cil_tmp = str_isempty(& p_node1->sort_key_str);
#line 138
  if (__cil_tmp) {
#line 144
    p_cmp1 = & p_node1->str;
  } else {
#line 140
    p_cmp1 = & p_node1->sort_key_str;
  }
#line 146
  __cil_tmp___0 = str_isempty(& p_node2->sort_key_str);
#line 146
  if (__cil_tmp___0) {
#line 152
    p_cmp2 = & p_node2->str;
  } else {
#line 148
    p_cmp2 = & p_node2->sort_key_str;
  }
#line 155
  if (reverse) {
#line 157
    __cil_tmp___1 = str_strcmp(p_cmp2, p_cmp1);
#line 157
    return (__cil_tmp___1);
  } else {
#line 161
    __cil_tmp___2 = str_strcmp(p_cmp1, p_cmp2);
#line 161
    return (__cil_tmp___2);
  }
}
}
#line 165 "strlist.c"
struct mystr  const  *str_list_get_pstr(struct mystr_list  const  *p_list , unsigned int indexx ) 
{ 

  {
#line 168
  if (indexx >= (unsigned int )p_list->PRIVATE_HANDS_OFF_list_len) {
#line 170
    bug("indexx out of range in str_list_get_str");
  }
#line 172
  return ((struct mystr  const  *)(& (p_list->PRIVATE_HANDS_OFF_p_nodes + indexx)->str));
}
}
#line 1 "cil-PrAmEJr5.o"
#pragma merger(0,"/tmp/cil-w4lhHwrh.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 26 "banner.c"
void vsf_banner_dir_changed(struct vsf_session *p_sess , int ftpcode ) 
{ struct mystr dir_str ;
  struct mystr_list the_list ;
  void *__cil_tmp ;
  int __cil_tmp___0 ;
  struct mystr msg_file_str ;
  int __cil_tmp___1 ;

  {
#line 29
  dir_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 29
  dir_str.PRIVATE_HANDS_OFF_len = 0U;
#line 29
  dir_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 31
  if (! tunable_dirmessage_enable) {
#line 33
    return;
  }
#line 35
  if ((unsigned int )p_sess->p_visited_dir_list == (unsigned int )((struct mystr_list *)0)) {
#line 37
    the_list.PRIVATE_HANDS_OFF_alloc_len = 0U;
#line 37
    the_list.PRIVATE_HANDS_OFF_list_len = 0U;
#line 37
    the_list.PRIVATE_HANDS_OFF_p_nodes = (struct mystr_list_node *)((void *)0);
#line 38
    __cil_tmp = vsf_sysutil_malloc((unsigned int )sizeof(struct mystr_list ));
#line 38
    p_sess->p_visited_dir_list = (struct mystr_list *)__cil_tmp;
#line 39
    *(p_sess->p_visited_dir_list) = the_list;
  }
#line 41
  str_getcwd(& dir_str);
#line 43
  __cil_tmp___1 = str_list_contains_str((struct mystr_list  const  *)p_sess->p_visited_dir_list,
                                        (struct mystr  const  *)(& dir_str));
#line 43
  if (! __cil_tmp___1) {
#line 46
    __cil_tmp___0 = str_list_get_length((struct mystr_list  const  *)p_sess->p_visited_dir_list);
#line 46
    if (__cil_tmp___0 < 100) {
#line 49
      str_list_add(p_sess->p_visited_dir_list, (struct mystr  const  *)(& dir_str),
                   (struct mystr  const  *)0);
    }
#line 55
    msg_file_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 55
    msg_file_str.PRIVATE_HANDS_OFF_len = 0U;
#line 55
    msg_file_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 56
    str_fileread(& msg_file_str, tunable_message_file, 4000U);
#line 58
    vsf_banner_write(p_sess, & msg_file_str, ftpcode);
#line 59
    str_free(& msg_file_str);
  }
#line 62
  str_free(& dir_str);
#line 63
  return;
}
}
#line 65 "banner.c"
void vsf_banner_write(struct vsf_session *p_sess , struct mystr *p_str , int ftpcode ) 
{ struct mystr msg_line_str ;
  unsigned int str_pos ;
  int __cil_tmp ;

  {
#line 68
  msg_line_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 68
  msg_line_str.PRIVATE_HANDS_OFF_len = 0U;
#line 68
  msg_line_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 69
  str_pos = 0U;
#line 70
  while (1) {
#line 70
    __cil_tmp = str_getline((struct mystr  const  *)p_str, & msg_line_str, & str_pos);
#line 70
    if (! __cil_tmp) {
#line 70
      break;
    }
#line 72
    vsf_cmdio_write_str_hyphen(p_sess, ftpcode, (struct mystr  const  *)(& msg_line_str));
  }
#line 74
  str_free(& msg_line_str);
#line 75
  return;
}
}
#line 1 "cil-l9Qv9kY4.o"
#pragma merger(0,"/tmp/cil-G4C2U0q5.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 18 "filestr.c"
int str_fileread(struct mystr *p_str , char const   *p_filename , unsigned int maxsize ) 
{ int fd ;
  int retval ;
  filesize_t size ;
  char *p_sec_buf ;
  struct vsf_sysutil_statbuf *p_stat ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 24
  p_sec_buf = (char *)0;
#line 25
  p_stat = (struct vsf_sysutil_statbuf *)0;
#line 27
  str_empty(p_str);
#line 28
  fd = vsf_sysutil_open_file(p_filename, 1);
#line 29
  __cil_tmp = vsf_sysutil_retval_is_error(fd);
#line 29
  if (__cil_tmp) {
#line 31
    return (fd);
  }
#line 33
  vsf_sysutil_fstat(fd, & p_stat);
#line 34
  __cil_tmp___1 = vsf_sysutil_statbuf_is_regfile((struct vsf_sysutil_statbuf  const  *)p_stat);
#line 34
  if (__cil_tmp___1) {
#line 36
    size = vsf_sysutil_statbuf_get_size((struct vsf_sysutil_statbuf  const  *)p_stat);
#line 37
    if (size > (filesize_t )maxsize) {
#line 39
      size = (long long )maxsize;
    }
#line 41
    vsf_secbuf_alloc(& p_sec_buf, (unsigned int )size);
#line 43
    retval = vsf_sysutil_read_loop(fd, (void *)p_sec_buf, (unsigned int )size);
#line 44
    __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 44
    if (__cil_tmp___0) {
      _L: /* CIL Label */ ;
    } else {
#line 44
      if ((filesize_t )((unsigned int )retval) == size) {
#line 46
        private_str_alloc_memchunk(p_str, (char const   *)p_sec_buf, (unsigned int )size);
      } else {
#line 44
        goto _L;
      }
    }
  }
#line 49
  vsf_sysutil_free((void *)p_stat);
#line 50
  vsf_secbuf_free(& p_sec_buf);
#line 51
  vsf_sysutil_close(fd);
#line 52
  return (0);
}
}
#line 1 "cil-kZTMtgy8.o"
#pragma merger(0,"/tmp/cil-8dMA2jPU.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 19 "parseconf.c"
static char const   *s_p_saved_filename  ;
#line 20 "parseconf.c"
static int s_strings_copied  ;
#line 23
static void handle_config_setting(struct mystr *p_setting_str , struct mystr *p_value_str ,
                                  int errs_fatal ) ;
#line 27
static void copy_string_settings(void) ;
#line 31 "parseconf.c"
static struct parseconf_bool_setting parseconf_bool_array[72]  = 
#line 31
  {      {"anonymous_enable", & tunable_anonymous_enable}, 
        {"local_enable", & tunable_local_enable}, 
        {"pasv_enable", & tunable_pasv_enable}, 
        {"port_enable", & tunable_port_enable}, 
        {"chroot_local_user", & tunable_chroot_local_user}, 
        {"write_enable", & tunable_write_enable}, 
        {"anon_upload_enable", & tunable_anon_upload_enable}, 
        {"anon_mkdir_write_enable", & tunable_anon_mkdir_write_enable}, 
        {"anon_other_write_enable", & tunable_anon_other_write_enable}, 
        {"chown_uploads", & tunable_chown_uploads}, 
        {"connect_from_port_20", & tunable_connect_from_port_20}, 
        {"xferlog_enable", & tunable_xferlog_enable}, 
        {"dirmessage_enable", & tunable_dirmessage_enable}, 
        {"anon_world_readable_only", & tunable_anon_world_readable_only}, 
        {"async_abor_enable", & tunable_async_abor_enable}, 
        {"ascii_upload_enable", & tunable_ascii_upload_enable}, 
        {"ascii_download_enable", & tunable_ascii_download_enable}, 
        {"one_process_model", & tunable_one_process_model}, 
        {"xferlog_std_format", & tunable_xferlog_std_format}, 
        {"pasv_promiscuous", & tunable_pasv_promiscuous}, 
        {"deny_email_enable", & tunable_deny_email_enable}, 
        {"chroot_list_enable", & tunable_chroot_list_enable}, 
        {"setproctitle_enable", & tunable_setproctitle_enable}, 
        {"text_userdb_names", & tunable_text_userdb_names}, 
        {"ls_recurse_enable", & tunable_ls_recurse_enable}, 
        {"log_ftp_protocol", & tunable_log_ftp_protocol}, 
        {"guest_enable", & tunable_guest_enable}, 
        {"userlist_enable", & tunable_userlist_enable}, 
        {"userlist_deny", & tunable_userlist_deny}, 
        {"use_localtime", & tunable_use_localtime}, 
        {"check_shell", & tunable_check_shell}, 
        {"hide_ids", & tunable_hide_ids}, 
        {"listen", & tunable_listen}, 
        {"port_promiscuous", & tunable_port_promiscuous}, 
        {"passwd_chroot_enable", & tunable_passwd_chroot_enable}, 
        {"no_anon_password", & tunable_no_anon_password}, 
        {"tcp_wrappers", & tunable_tcp_wrappers}, 
        {"use_sendfile", & tunable_use_sendfile}, 
        {"force_dot_files", & tunable_force_dot_files}, 
        {"listen_ipv6", & tunable_listen_ipv6}, 
        {"dual_log_enable", & tunable_dual_log_enable}, 
        {"syslog_enable", & tunable_syslog_enable}, 
        {"background", & tunable_background}, 
        {"virtual_use_local_privs", & tunable_virtual_use_local_privs}, 
        {"session_support", & tunable_session_support}, 
        {"download_enable", & tunable_download_enable}, 
        {"dirlist_enable", & tunable_dirlist_enable}, 
        {"chmod_enable", & tunable_chmod_enable}, 
        {"secure_email_list_enable", & tunable_secure_email_list_enable}, 
        {"run_as_launching_user", & tunable_run_as_launching_user}, 
        {"no_log_lock", & tunable_no_log_lock}, 
        {"ssl_enable", & tunable_ssl_enable}, 
        {"allow_anon_ssl", & tunable_allow_anon_ssl}, 
        {"force_local_logins_ssl", & tunable_force_local_logins_ssl}, 
        {"force_local_data_ssl", & tunable_force_local_data_ssl}, 
        {"ssl_sslv2", & tunable_sslv2}, 
        {"ssl_sslv3", & tunable_sslv3}, 
        {"ssl_tlsv1", & tunable_tlsv1}, 
        {"tilde_user_enable", & tunable_tilde_user_enable}, 
        {"force_anon_logins_ssl", & tunable_force_anon_logins_ssl}, 
        {"force_anon_data_ssl", & tunable_force_anon_data_ssl}, 
        {"mdtm_write", & tunable_mdtm_write}, 
        {"lock_upload_files", & tunable_lock_upload_files}, 
        {"pasv_addr_resolve", & tunable_pasv_addr_resolve}, 
        {"debug_ssl", & tunable_debug_ssl}, 
        {"require_cert", & tunable_require_cert}, 
        {"validate_cert", & tunable_validate_cert}, 
        {"strict_ssl_read_eof", & tunable_strict_ssl_read_eof}, 
        {"strict_ssl_write_shutdown", & tunable_strict_ssl_write_shutdown}, 
        {"ssl_request_cert", & tunable_ssl_request_cert}, 
        {"delete_failed_uploads", & tunable_delete_failed_uploads}, 
        {(char const   *)0, (int *)0}};
#line 112 "parseconf.c"
static struct parseconf_uint_setting parseconf_uint_array[21]  = 
#line 112
  {      {"accept_timeout", & tunable_accept_timeout}, 
        {"connect_timeout", & tunable_connect_timeout}, 
        {"local_umask", & tunable_local_umask}, 
        {"anon_umask", & tunable_anon_umask}, 
        {"ftp_data_port", & tunable_ftp_data_port}, 
        {"idle_session_timeout", & tunable_idle_session_timeout}, 
        {"data_connection_timeout", & tunable_data_connection_timeout}, 
        {"pasv_min_port", & tunable_pasv_min_port}, 
        {"pasv_max_port", & tunable_pasv_max_port}, 
        {"anon_max_rate", & tunable_anon_max_rate}, 
        {"local_max_rate", & tunable_local_max_rate}, 
        {"listen_port", & tunable_listen_port}, 
        {"max_clients", & tunable_max_clients}, 
        {"file_open_mode", & tunable_file_open_mode}, 
        {"max_per_ip", & tunable_max_per_ip}, 
        {"trans_chunk_size", & tunable_trans_chunk_size}, 
        {"delay_failed_login", & tunable_delay_failed_login}, 
        {"delay_successful_login", & tunable_delay_successful_login}, 
        {"max_login_fails", & tunable_max_login_fails}, 
        {"chown_upload_mode", & tunable_chown_upload_mode}, 
        {(char const   *)0, (unsigned int *)0}};
#line 142 "parseconf.c"
static struct parseconf_str_setting parseconf_str_array[32]  = 
#line 142
  {      {"secure_chroot_dir", & tunable_secure_chroot_dir}, 
        {"ftp_username", & tunable_ftp_username}, 
        {"chown_username", & tunable_chown_username}, 
        {"xferlog_file", & tunable_xferlog_file}, 
        {"vsftpd_log_file", & tunable_vsftpd_log_file}, 
        {"message_file", & tunable_message_file}, 
        {"nopriv_user", & tunable_nopriv_user}, 
        {"ftpd_banner", & tunable_ftpd_banner}, 
        {"banned_email_file", & tunable_banned_email_file}, 
        {"chroot_list_file", & tunable_chroot_list_file}, 
        {"pam_service_name", & tunable_pam_service_name}, 
        {"guest_username", & tunable_guest_username}, 
        {"userlist_file", & tunable_userlist_file}, 
        {"anon_root", & tunable_anon_root}, 
        {"local_root", & tunable_local_root}, 
        {"banner_file", & tunable_banner_file}, 
        {"pasv_address", & tunable_pasv_address}, 
        {"listen_address", & tunable_listen_address}, 
        {"user_config_dir", & tunable_user_config_dir}, 
        {"listen_address6", & tunable_listen_address6}, 
        {"cmds_allowed", & tunable_cmds_allowed}, 
        {"hide_file", & tunable_hide_file}, 
        {"deny_file", & tunable_deny_file}, 
        {"user_sub_token", & tunable_user_sub_token}, 
        {"email_password_file", & tunable_email_password_file}, 
        {"rsa_cert_file", & tunable_rsa_cert_file}, 
        {"dsa_cert_file", & tunable_dsa_cert_file}, 
        {"ssl_ciphers", & tunable_ssl_ciphers}, 
        {"rsa_private_key_file", & tunable_rsa_private_key_file}, 
        {"dsa_private_key_file", & tunable_dsa_private_key_file}, 
        {"ca_certs_file", & tunable_ca_certs_file}, 
        {(char const   *)0, (char const   **)0}};
#line 183 "parseconf.c"
void vsf_parseconf_load_file(char const   *p_filename , int errs_fatal ) 
{ struct mystr config_file_str ;
  struct mystr config_setting_str ;
  struct mystr config_value_str ;
  unsigned int str_pos ;
  int retval ;
  char *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  char __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 186
  config_file_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 186
  config_file_str.PRIVATE_HANDS_OFF_len = 0U;
#line 186
  config_file_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 187
  config_setting_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 187
  config_setting_str.PRIVATE_HANDS_OFF_len = 0U;
#line 187
  config_setting_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 188
  config_value_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 188
  config_value_str.PRIVATE_HANDS_OFF_len = 0U;
#line 188
  config_value_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 189
  str_pos = 0U;
#line 191
  if (! p_filename) {
#line 193
    p_filename = s_p_saved_filename;
  } else {
#line 197
    if (s_p_saved_filename) {
#line 199
      vsf_sysutil_free((void *)((char *)s_p_saved_filename));
    }
#line 201
    __cil_tmp = vsf_sysutil_strdup(p_filename);
#line 201
    s_p_saved_filename = (char const   *)__cil_tmp;
  }
#line 203
  if (! p_filename) {
#line 205
    bug("null filename in vsf_parseconf_load_file");
  }
#line 207
  if (! s_strings_copied) {
#line 209
    s_strings_copied = 1;
#line 214
    copy_string_settings();
  }
#line 216
  retval = str_fileread(& config_file_str, p_filename, 100000U);
#line 217
  __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 217
  if (__cil_tmp___0) {
#line 219
    if (errs_fatal) {
#line 221
      die2("cannot open config file:", p_filename);
    } else {
#line 225
      return;
    }
  }
#line 228
  while (1) {
#line 228
    __cil_tmp___3 = str_getline((struct mystr  const  *)(& config_file_str), & config_setting_str,
                                & str_pos);
#line 228
    if (! __cil_tmp___3) {
#line 228
      break;
    }
#line 230
    __cil_tmp___1 = str_isempty((struct mystr  const  *)(& config_setting_str));
#line 230
    if (__cil_tmp___1) {
#line 230
      goto _L;
    } else {
#line 230
      __cil_tmp___2 = str_get_char_at((struct mystr  const  *)(& config_setting_str),
                                      0U);
#line 230
      if ((int )__cil_tmp___2 == 35) {
        _L: /* CIL Label */ 
#line 233
        continue;
      }
    }
#line 236
    str_split_char(& config_setting_str, & config_value_str, (char )'=');
#line 237
    handle_config_setting(& config_setting_str, & config_value_str, errs_fatal);
  }
#line 239
  str_free(& config_file_str);
#line 240
  str_free(& config_setting_str);
#line 241
  str_free(& config_value_str);
#line 242
  return;
}
}
#line 244 "parseconf.c"
static void handle_config_setting(struct mystr *p_setting_str , struct mystr *p_value_str ,
                                  int errs_fatal ) 
{ struct parseconf_str_setting  const  *p_str_setting ;
  char const   **p_curr_setting ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  struct parseconf_bool_setting  const  *p_bool_setting ;
  char const   *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;
  int __cil_tmp___8 ;
  int __cil_tmp___9 ;
  int __cil_tmp___10 ;
  struct parseconf_uint_setting  const  *p_uint_setting ;
  int __cil_tmp___11 ;
  int __cil_tmp___12 ;
  char __cil_tmp___13 ;
  int __cil_tmp___14 ;
  char const   *__cil_tmp___15 ;

  {
#line 250
  p_str_setting = (struct parseconf_str_setting  const  *)(parseconf_str_array);
#line 251
  while ((unsigned int )p_str_setting->p_setting_name != (unsigned int )((char const   * const  )0)) {
#line 253
    __cil_tmp___0 = str_equal_text((struct mystr  const  *)p_setting_str, (char const   *)p_str_setting->p_setting_name);
#line 253
    if (__cil_tmp___0) {
#line 256
      p_curr_setting = (char const   **)p_str_setting->p_variable;
#line 257
      if (*p_curr_setting) {
#line 259
        vsf_sysutil_free((void *)((char *)*p_curr_setting));
      }
#line 261
      __cil_tmp = str_isempty((struct mystr  const  *)p_value_str);
#line 261
      if (__cil_tmp) {
#line 263
        *p_curr_setting = (char const   *)0;
      } else {
#line 267
        *p_curr_setting = str_strdup((struct mystr  const  *)p_value_str);
      }
#line 269
      return;
    }
#line 271
    p_str_setting ++;
  }
#line 274
  __cil_tmp___2 = str_isempty((struct mystr  const  *)p_value_str);
#line 274
  if (__cil_tmp___2) {
#line 276
    if (errs_fatal) {
#line 278
      __cil_tmp___1 = str_getbuf((struct mystr  const  *)p_setting_str);
#line 278
      die2("missing value in config file for: ", __cil_tmp___1);
    } else {
#line 282
      return;
    }
  }
#line 287
  p_bool_setting = (struct parseconf_bool_setting  const  *)(parseconf_bool_array);
#line 288
  while ((unsigned int )p_bool_setting->p_setting_name != (unsigned int )((char const   * const  )0)) {
#line 290
    __cil_tmp___10 = str_equal_text((struct mystr  const  *)p_setting_str, (char const   *)p_bool_setting->p_setting_name);
#line 290
    if (__cil_tmp___10) {
#line 293
      str_upper(p_value_str);
#line 294
      __cil_tmp___7 = str_equal_text((struct mystr  const  *)p_value_str, "YES");
#line 294
      if (__cil_tmp___7) {
#line 294
        goto _L___2;
      } else {
#line 294
        __cil_tmp___8 = str_equal_text((struct mystr  const  *)p_value_str, "TRUE");
#line 294
        if (__cil_tmp___8) {
          _L___2: /* CIL Label */ 
#line 294
          goto _L___1;
        } else {
#line 294
          __cil_tmp___9 = str_equal_text((struct mystr  const  *)p_value_str, "1");
#line 294
          if (__cil_tmp___9) {
            _L___1: /* CIL Label */ 
#line 298
            *(p_bool_setting->p_variable) = 1;
          } else {
#line 300
            __cil_tmp___4 = str_equal_text((struct mystr  const  *)p_value_str, "NO");
#line 300
            if (__cil_tmp___4) {
#line 300
              goto _L___0;
            } else {
#line 300
              __cil_tmp___5 = str_equal_text((struct mystr  const  *)p_value_str,
                                             "FALSE");
#line 300
              if (__cil_tmp___5) {
                _L___0: /* CIL Label */ 
#line 300
                goto _L;
              } else {
#line 300
                __cil_tmp___6 = str_equal_text((struct mystr  const  *)p_value_str,
                                               "0");
#line 300
                if (__cil_tmp___6) {
                  _L: /* CIL Label */ 
#line 304
                  *(p_bool_setting->p_variable) = 0;
                } else {
#line 306
                  if (errs_fatal) {
#line 308
                    __cil_tmp___3 = str_getbuf((struct mystr  const  *)p_setting_str);
#line 308
                    die2("bad bool value in config file for: ", __cil_tmp___3);
                  }
                }
              }
            }
          }
        }
      }
#line 311
      return;
    }
#line 313
    p_bool_setting ++;
  }
#line 318
  p_uint_setting = (struct parseconf_uint_setting  const  *)(parseconf_uint_array);
#line 319
  while ((unsigned int )p_uint_setting->p_setting_name != (unsigned int )((char const   * const  )0)) {
#line 321
    __cil_tmp___14 = str_equal_text((struct mystr  const  *)p_setting_str, (char const   *)p_uint_setting->p_setting_name);
#line 321
    if (__cil_tmp___14) {
#line 325
      __cil_tmp___12 = str_isempty((struct mystr  const  *)p_value_str);
#line 325
      if (__cil_tmp___12) {
        _L___3: /* CIL Label */ 
#line 332
        __cil_tmp___11 = str_atoi((struct mystr  const  *)p_value_str);
#line 332
        *(p_uint_setting->p_variable) = (unsigned int )__cil_tmp___11;
      } else {
#line 325
        __cil_tmp___13 = str_get_char_at((struct mystr  const  *)p_value_str, 0U);
#line 325
        if ((int )__cil_tmp___13 == 48) {
#line 328
          *(p_uint_setting->p_variable) = str_octal_to_uint((struct mystr  const  *)p_value_str);
        } else {
#line 325
          goto _L___3;
        }
      }
#line 334
      return;
    }
#line 336
    p_uint_setting ++;
  }
#line 339
  if (errs_fatal) {
#line 341
    __cil_tmp___15 = str_getbuf((struct mystr  const  *)p_setting_str);
#line 341
    die2("unrecognised variable in config file: ", __cil_tmp___15);
  }
#line 343
  return;
}
}
#line 345 "parseconf.c"
static void copy_string_settings(void) 
{ struct parseconf_str_setting  const  *p_str_setting ;
  char *__cil_tmp ;

  {
#line 348
  p_str_setting = (struct parseconf_str_setting  const  *)(parseconf_str_array);
#line 349
  while ((unsigned int )p_str_setting->p_setting_name != (unsigned int )((char const   * const  )0)) {
#line 351
    if ((unsigned int )*(p_str_setting->p_variable) != (unsigned int )((char const   *)0)) {
#line 353
      __cil_tmp = vsf_sysutil_strdup(*(p_str_setting->p_variable));
#line 353
      *(p_str_setting->p_variable) = (char const   *)__cil_tmp;
    }
#line 356
    p_str_setting ++;
  }
#line 358
  return;
}
}
#line 1 "cil-C4DFa9Nm.o"
#pragma merger(0,"/tmp/cil-zGBAp7Pg.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 311 "sysutil.h"
void vsf_sysutil_setuid(struct vsf_sysutil_user  const  *p_user ) ;
#line 312
void vsf_sysutil_setgid(struct vsf_sysutil_user  const  *p_user ) ;
#line 315
int vsf_sysutil_geteuid(void) ;
#line 316
int vsf_sysutil_getegid(void) ;
#line 317
void vsf_sysutil_seteuid(struct vsf_sysutil_user  const  *p_user ) ;
#line 318
void vsf_sysutil_setegid(struct vsf_sysutil_user  const  *p_user ) ;
#line 319
void vsf_sysutil_seteuid_numeric(int uid ) ;
#line 320
void vsf_sysutil_setegid_numeric(int gid ) ;
#line 321
void vsf_sysutil_clear_supp_groups(void) ;
#line 322
void vsf_sysutil_initgroups(struct vsf_sysutil_user  const  *p_user ) ;
#line 323
void vsf_sysutil_chroot(char const   *p_root_path ) ;
#line 23 "sysdeputil.h"
int vsf_sysdep_has_capabilities(void) ;
#line 25
void vsf_sysdep_keep_capabilities(void) ;
#line 32
void vsf_sysdep_adopt_capabilities(unsigned int caps ) ;
#line 15 "secutil.c"
void vsf_secutil_change_credentials(struct mystr  const  *p_user_str , struct mystr  const  *p_dir_str ,
                                    struct mystr  const  *p_ext_dir_str , unsigned int caps ,
                                    unsigned int options ) 
{ struct vsf_sysutil_user *p_user ;
  int __cil_tmp ;
  char const   *__cil_tmp___0 ;
  struct mystr dir_str ;
  char const   *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int saved_euid ;
  int saved_egid ;
  int retval ;
  char const   *__cil_tmp___3 ;
  int __cil_tmp___4 ;
  char const   *__cil_tmp___5 ;
  int __cil_tmp___6 ;
  int __cil_tmp___7 ;

  {
#line 22
  __cil_tmp = vsf_sysutil_running_as_root();
#line 22
  if (! __cil_tmp) {
#line 24
    bug("vsf_secutil_change_credentials: not running as root");
  }
#line 26
  p_user = str_getpwnam(p_user_str);
#line 27
  if ((unsigned int )p_user == (unsigned int )((struct vsf_sysutil_user *)0)) {
#line 29
    __cil_tmp___0 = str_getbuf(p_user_str);
#line 29
    die2("cannot locate user entry:", __cil_tmp___0);
  }
#line 32
  dir_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 32
  dir_str.PRIVATE_HANDS_OFF_len = 0U;
#line 32
  dir_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 34
  if ((unsigned int )p_dir_str == (unsigned int )((struct mystr  const  *)0)) {
#line 34
    goto _L;
  } else {
#line 34
    __cil_tmp___2 = str_isempty(p_dir_str);
#line 34
    if (__cil_tmp___2) {
      _L: /* CIL Label */ 
#line 36
      __cil_tmp___1 = vsf_sysutil_user_get_homedir((struct vsf_sysutil_user  const  *)p_user);
#line 36
      str_alloc_text(& dir_str, __cil_tmp___1);
    } else {
#line 40
      str_copy(& dir_str, p_dir_str);
    }
  }
#line 45
  if (options & 2U) {
#line 47
    vsf_sysutil_initgroups((struct vsf_sysutil_user  const  *)p_user);
  } else {
#line 51
    vsf_sysutil_clear_supp_groups();
  }
#line 58
  saved_euid = 0;
#line 59
  saved_egid = 0;
#line 61
  if (options & 4U) {
#line 63
    saved_euid = vsf_sysutil_geteuid();
#line 64
    saved_egid = vsf_sysutil_getegid();
#line 65
    vsf_sysutil_setegid((struct vsf_sysutil_user  const  *)p_user);
#line 66
    vsf_sysutil_seteuid((struct vsf_sysutil_user  const  *)p_user);
  }
#line 68
  retval = str_chdir((struct mystr  const  *)(& dir_str));
#line 69
  if (retval != 0) {
#line 71
    __cil_tmp___3 = str_getbuf((struct mystr  const  *)(& dir_str));
#line 71
    die2("cannot change directory:", __cil_tmp___3);
  }
#line 73
  if (p_ext_dir_str) {
#line 73
    __cil_tmp___4 = str_isempty(p_ext_dir_str);
#line 73
    if (__cil_tmp___4) {
#line 73
      goto _L___0;
    } else {
#line 75
      retval = str_chdir(p_ext_dir_str);
#line 79
      if (retval != 0 && ! (options & 1U)) {
#line 81
        retval = 0;
      }
    }
  } else {
    _L___0: /* CIL Label */ ;
  }
#line 84
  if (retval != 0) {
#line 86
    __cil_tmp___5 = str_getbuf(p_ext_dir_str);
#line 86
    die2("cannot change directory:", __cil_tmp___5);
  }
#line 88
  if (options & 4U) {
#line 90
    vsf_sysutil_seteuid_numeric(saved_euid);
#line 91
    vsf_sysutil_setegid_numeric(saved_egid);
  }
#line 94
  if (options & 1U) {
#line 96
    vsf_sysutil_chroot(".");
  }
#line 99
  str_free(& dir_str);
#line 102
  if (caps) {
#line 104
    __cil_tmp___6 = vsf_sysdep_has_capabilities();
#line 104
    if (! __cil_tmp___6) {
#line 107
      return;
    }
#line 109
    __cil_tmp___7 = vsf_sysdep_has_capabilities_as_non_root();
#line 109
    if (! __cil_tmp___7) {
#line 111
      vsf_sysdep_adopt_capabilities(caps);
#line 112
      return;
    }
#line 114
    vsf_sysdep_keep_capabilities();
  }
#line 117
  vsf_sysutil_setgid((struct vsf_sysutil_user  const  *)p_user);
#line 119
  vsf_sysutil_setuid((struct vsf_sysutil_user  const  *)p_user);
#line 120
  if (caps) {
#line 122
    vsf_sysdep_adopt_capabilities(caps);
  }
#line 124
  return;
}
}
#line 1 "cil-qT0qashO.o"
#pragma merger(0,"/tmp/cil-9uxTkoS8.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 12 "ascii.c"
struct ascii_to_bin_ret vsf_ascii_ascii_to_bin(char *p_buf , unsigned int in_len ,
                                               int prev_cr ) 
{ struct ascii_to_bin_ret ret___0 ;
  unsigned int indexx ;
  unsigned int written ;
  char *p_out ;
  char the_char ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 19
  indexx = 0U;
#line 20
  written = 0U;
#line 21
  p_out = p_buf + 1;
#line 22
  ret___0.last_was_cr = 0;
#line 23
  if (prev_cr && (! in_len || (int )*(p_out + 0) != 10)) {
#line 25
    *(p_buf + 0) = (char )'\r';
#line 26
    ret___0.p_buf = p_buf;
#line 27
    written ++;
  } else {
#line 31
    ret___0.p_buf = p_out;
  }
#line 33
  while (indexx < in_len) {
#line 35
    the_char = *(p_buf + (indexx + 1U));
#line 36
    if ((int )the_char != 13) {
#line 38
      __cil_tmp = p_out;
#line 38
      p_out ++;
#line 38
      *__cil_tmp = the_char;
#line 39
      written ++;
    } else {
#line 41
      if (indexx == in_len - 1U) {
#line 43
        ret___0.last_was_cr = 1;
      } else {
#line 45
        if ((int )*(p_buf + (indexx + 2U)) != 10) {
#line 47
          __cil_tmp___0 = p_out;
#line 47
          p_out ++;
#line 47
          *__cil_tmp___0 = the_char;
#line 48
          written ++;
        }
      }
    }
#line 50
    indexx ++;
  }
#line 52
  ret___0.stored = written;
#line 53
  return (ret___0);
}
}
#line 56 "ascii.c"
unsigned int vsf_ascii_bin_to_ascii(char const   *p_in , char *p_out , unsigned int in_len ) 
{ unsigned int indexx ;
  unsigned int written ;
  char the_char ;
  char *__cil_tmp ;
  char *__cil_tmp___0 ;

  {
#line 62
  indexx = 0U;
#line 63
  written = 0U;
#line 64
  while (indexx < in_len) {
#line 66
    the_char = (char )*(p_in + indexx);
#line 67
    if ((int )the_char == 10) {
#line 69
      __cil_tmp = p_out;
#line 69
      p_out ++;
#line 69
      *__cil_tmp = (char )'\r';
#line 70
      written ++;
    }
#line 72
    __cil_tmp___0 = p_out;
#line 72
    p_out ++;
#line 72
    *__cil_tmp___0 = the_char;
#line 73
    written ++;
#line 74
    indexx ++;
  }
#line 76
  return (written);
}
}
#line 1 "cil-3wZwjwp4.o"
#pragma merger(0,"/tmp/cil-zEoQSxq9.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 46 "privops.h"
enum EVSFPrivopLoginResult vsf_privop_do_login(struct vsf_session *p_sess , struct mystr  const  *p_pass_str ) ;
#line 26 "oneprocess.c"
void vsf_one_process_start(struct vsf_session *p_sess ) 
{ unsigned int caps ;
  struct mystr user_name ;
  struct mystr chdir_str ;
  int __cil_tmp ;

  {
#line 29
  caps = 0U;
#line 30
  if (tunable_chown_uploads) {
#line 32
    caps |= 1U;
  }
#line 34
  if (tunable_connect_from_port_20) {
#line 36
    caps |= 2U;
  }
#line 39
  user_name.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 39
  user_name.PRIVATE_HANDS_OFF_len = 0U;
#line 39
  user_name.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 40
  chdir_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 40
  chdir_str.PRIVATE_HANDS_OFF_len = 0U;
#line 40
  chdir_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 41
  str_alloc_text(& user_name, tunable_ftp_username);
#line 42
  if (tunable_anon_root) {
#line 44
    str_alloc_text(& chdir_str, tunable_anon_root);
  }
#line 46
  if (tunable_run_as_launching_user) {
#line 48
    __cil_tmp = str_isempty((struct mystr  const  *)(& chdir_str));
#line 48
    if (! __cil_tmp) {
#line 50
      str_chdir((struct mystr  const  *)(& chdir_str));
    }
  } else {
#line 55
    vsf_secutil_change_credentials((struct mystr  const  *)(& user_name), (struct mystr  const  *)0,
                                   (struct mystr  const  *)(& chdir_str), caps, 3U);
  }
#line 58
  str_free(& user_name);
#line 59
  str_free(& chdir_str);
#line 61
  init_connection(p_sess);
#line 62
  return;
}
}
#line 64 "oneprocess.c"
void vsf_one_process_login(struct vsf_session *p_sess , struct mystr  const  *p_pass_str ) 
{ enum EVSFPrivopLoginResult login_result ;
  enum EVSFPrivopLoginResult __cil_tmp ;

  {
#line 68
  __cil_tmp = vsf_privop_do_login(p_sess, p_pass_str);
#line 68
  login_result = __cil_tmp;
#line 70
  switch ((int )login_result) {
  case 1: 
#line 73
  return;
#line 74
  break;
  case 2: 
#line 76
  p_sess->is_anonymous = 1;
#line 77
  process_post_login(p_sess);
#line 78
  break;
  default: 
#line 80
  bug("bad state in vsf_one_process_login");
#line 81
  break;
  }
#line 83
  return;
}
}
#line 85 "oneprocess.c"
int vsf_one_process_get_priv_data_sock(struct vsf_session *p_sess ) 
{ int __cil_tmp ;

  {
#line 88
  __cil_tmp = vsf_privop_get_ftp_port_sock(p_sess);
#line 88
  return (__cil_tmp);
}
}
#line 91 "oneprocess.c"
void vsf_one_process_chown_upload(struct vsf_session *p_sess , int fd ) 
{ 

  {
#line 94
  vsf_privop_do_file_chown(p_sess, fd);
#line 95
  return;
}
}
#line 1 "cil-X6MPawvo.o"
#pragma merger(0,"/tmp/cil-FjpCvvec.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 15 "ssl.h"
void ssl_comm_channel_init(struct vsf_session *p_sess ) ;
#line 45 "sysutil.h"
void vsf_sysutil_install_async_sighandler(enum EVSFSysUtilSignal sig , void (*handler)(int  ) ) ;
#line 92
int vsf_sysutil_write_access(char const   *p_filename ) ;
#line 163
int vsf_sysutil_fork(void) ;
#line 171
struct vsf_sysutil_wait_retval vsf_sysutil_wait(void) ;
#line 173
int vsf_sysutil_wait_get_retval(struct vsf_sysutil_wait_retval  const  *p_waitret ) ;
#line 175
int vsf_sysutil_wait_exited_normally(struct vsf_sysutil_wait_retval  const  *p_waitret ) ;
#line 177
int vsf_sysutil_wait_get_exitcode(struct vsf_sysutil_wait_retval  const  *p_waitret ) ;
#line 30 "twoprocess.c"
static void drop_all_privs(void) ;
#line 31
static void handle_sigchld(int duff ) ;
#line 32
static void process_login_req(struct vsf_session *p_sess ) ;
#line 33
static void process_ssl_slave_req(struct vsf_session *p_sess ) ;
#line 34
static void common_do_login(struct vsf_session *p_sess , struct mystr  const  *p_user_str ,
                            int do_chroot , int anon ) ;
#line 37
static void handle_per_user_config(struct mystr  const  *p_user_str ) ;
#line 38
static void calculate_chdir_dir(int anon_login , struct mystr *p_userdir_str , struct mystr *p_chroot_str ,
                                struct mystr *p_chdir_str , struct mystr  const  *p_user_str ,
                                struct mystr  const  *p_orig_user_str ) ;
#line 44 "twoprocess.c"
static void handle_sigchld(int duff ) 
{ struct vsf_sysutil_wait_retval wait_retval ;
  struct vsf_sysutil_wait_retval __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 47
  __cil_tmp = vsf_sysutil_wait();
#line 47
  wait_retval = __cil_tmp;
#line 52
  __cil_tmp___0 = vsf_sysutil_wait_get_retval((struct vsf_sysutil_wait_retval  const  *)(& wait_retval));
#line 52
  __cil_tmp___1 = vsf_sysutil_retval_is_error(__cil_tmp___0);
#line 52
  if (__cil_tmp___1) {
#line 52
    goto _L___0;
  } else {
#line 52
    __cil_tmp___2 = vsf_sysutil_wait_exited_normally((struct vsf_sysutil_wait_retval  const  *)(& wait_retval));
#line 52
    if (__cil_tmp___2) {
#line 52
      __cil_tmp___3 = vsf_sysutil_wait_get_exitcode((struct vsf_sysutil_wait_retval  const  *)(& wait_retval));
#line 52
      if (__cil_tmp___3 != 0) {
        _L: /* CIL Label */ 
#line 56
        die("child died");
      } else {
#line 60
        vsf_sysutil_exit(0);
      }
    } else {
      _L___0: /* CIL Label */ 
#line 52
      goto _L;
    }
  }
#line 62
  return;
}
}
#line 64 "twoprocess.c"
void vsf_two_process_start(struct vsf_session *p_sess ) 
{ int newpid ;
  int __cil_tmp ;
  int retval ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 68
  priv_sock_init(p_sess);
#line 69
  if (tunable_ssl_enable) {
#line 74
    ssl_comm_channel_init(p_sess);
  }
#line 76
  vsf_sysutil_install_async_sighandler(3, & handle_sigchld);
#line 78
  __cil_tmp = vsf_sysutil_fork();
#line 78
  newpid = __cil_tmp;
#line 79
  if (newpid != 0) {
#line 82
    while (1) {
#line 84
      process_login_req(p_sess);
    }
  }
#line 91
  vsf_sysutil_close(p_sess->parent_fd);
#line 92
  if (tunable_ssl_enable) {
#line 94
    vsf_sysutil_close(p_sess->ssl_consumer_fd);
  }
#line 96
  if (tunable_local_enable && tunable_userlist_enable) {
#line 98
    __cil_tmp___0 = str_fileread(& p_sess->userlist_str, tunable_userlist_file, 100000U);
#line 98
    retval = __cil_tmp___0;
#line 100
    __cil_tmp___1 = vsf_sysutil_retval_is_error(retval);
#line 100
    if (__cil_tmp___1) {
#line 102
      die2("cannot open user list file:", tunable_userlist_file);
    }
  }
#line 105
  drop_all_privs();
#line 106
  init_connection(p_sess);
#line 108
  return;
}
}
#line 110 "twoprocess.c"
static void drop_all_privs(void) 
{ struct mystr user_str ;
  struct mystr dir_str ;
  struct vsf_sysutil_statbuf *p_statbuf___0 ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 113
  user_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 113
  user_str.PRIVATE_HANDS_OFF_len = 0U;
#line 113
  user_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 114
  dir_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 114
  dir_str.PRIVATE_HANDS_OFF_len = 0U;
#line 114
  dir_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 115
  str_alloc_text(& user_str, tunable_nopriv_user);
#line 116
  str_alloc_text(& dir_str, tunable_secure_chroot_dir);
#line 119
  p_statbuf___0 = (struct vsf_sysutil_statbuf *)0;
#line 120
  __cil_tmp = str_lstat((struct mystr  const  *)(& dir_str), & p_statbuf___0);
#line 120
  __cil_tmp___0 = vsf_sysutil_retval_is_error(__cil_tmp);
#line 120
  if (__cil_tmp___0) {
#line 122
    die2("vsftpd: not found: directory given in \'secure_chroot_dir\':", tunable_secure_chroot_dir);
  }
#line 125
  vsf_sysutil_free((void *)p_statbuf___0);
#line 127
  vsf_secutil_change_credentials((struct mystr  const  *)(& user_str), (struct mystr  const  *)(& dir_str),
                                 (struct mystr  const  *)0, 0U, 1U);
#line 129
  str_free(& user_str);
#line 130
  str_free(& dir_str);
#line 131
  return;
}
}
#line 133 "twoprocess.c"
void vsf_two_process_login(struct vsf_session *p_sess , struct mystr  const  *p_pass_str ) 
{ char result ;

  {
#line 138
  priv_sock_send_cmd(p_sess->child_fd, (char)1);
#line 139
  priv_sock_send_str(p_sess->child_fd, (struct mystr  const  *)(& p_sess->user_str));
#line 140
  priv_sock_send_str(p_sess->child_fd, p_pass_str);
#line 141
  priv_sock_send_int(p_sess->child_fd, p_sess->control_use_ssl);
#line 142
  priv_sock_send_int(p_sess->child_fd, p_sess->data_use_ssl);
#line 143
  result = priv_sock_get_result(p_sess->child_fd);
#line 144
  if ((int )result == 1) {
#line 150
    if (! p_sess->control_use_ssl) {
#line 152
      vsf_sysutil_exit(0);
    } else {
#line 156
      vsf_sysutil_clear_alarm();
#line 157
      vsf_sysutil_close(p_sess->child_fd);
#line 158
      if (tunable_setproctitle_enable) {
#line 160
        vsf_sysutil_setproctitle("SSL handler");
      }
#line 162
      process_ssl_slave_req(p_sess);
    }
  } else {
#line 166
    if ((int )result == 2) {
#line 169
      return;
    } else {
#line 173
      die("priv_sock_get_result");
    }
  }
#line 175
  return;
}
}
#line 177 "twoprocess.c"
int vsf_two_process_get_priv_data_sock(struct vsf_session *p_sess ) 
{ char res ;
  int __cil_tmp ;

  {
#line 181
  priv_sock_send_cmd(p_sess->child_fd, (char)3);
#line 182
  res = priv_sock_get_result(p_sess->child_fd);
#line 183
  if ((int )res != 1) {
#line 185
    die("could not get privileged socket");
  }
#line 187
  __cil_tmp = priv_sock_recv_fd(p_sess->child_fd);
#line 187
  return (__cil_tmp);
}
}
#line 190 "twoprocess.c"
void vsf_two_process_chown_upload(struct vsf_session *p_sess , int fd ) 
{ char res ;

  {
#line 194
  priv_sock_send_cmd(p_sess->child_fd, (char)2);
#line 195
  priv_sock_send_fd(p_sess->child_fd, fd);
#line 196
  res = priv_sock_get_result(p_sess->child_fd);
#line 197
  if ((int )res != 1) {
#line 199
    die("unexpected failure in vsf_two_process_chown_upload");
  }
#line 201
  return;
}
}
#line 203 "twoprocess.c"
static void process_login_req(struct vsf_session *p_sess ) 
{ enum EVSFPrivopLoginResult e_login_result ;
  char cmd ;
  struct mystr password_str ;
  int do_chroot ;
  struct mystr chroot_list_file ;
  int retval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 206
  e_login_result = 0;
#line 208
  vsf_sysutil_unblock_sig(3);
#line 210
  cmd = priv_sock_get_cmd(p_sess->parent_fd);
#line 211
  vsf_sysutil_block_sig(3);
#line 212
  if ((int )cmd != 1) {
#line 214
    die("bad request");
  }
#line 218
  password_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 218
  password_str.PRIVATE_HANDS_OFF_len = 0U;
#line 218
  password_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 219
  priv_sock_get_str(p_sess->parent_fd, & p_sess->user_str);
#line 220
  priv_sock_get_str(p_sess->parent_fd, & password_str);
#line 221
  p_sess->control_use_ssl = priv_sock_get_int(p_sess->parent_fd);
#line 222
  p_sess->data_use_ssl = priv_sock_get_int(p_sess->parent_fd);
#line 223
  if (! tunable_ssl_enable) {
#line 225
    p_sess->control_use_ssl = 0;
#line 226
    p_sess->data_use_ssl = 0;
  }
#line 228
  e_login_result = vsf_privop_do_login(p_sess, (struct mystr  const  *)(& password_str));
#line 229
  str_free(& password_str);
#line 231
  switch ((int )e_login_result) {
  case 1: 
#line 234
  priv_sock_send_result(p_sess->parent_fd, (char)2);
#line 235
  return;
#line 236
  break;
  case 2: 
#line 238
  str_alloc_text(& p_sess->user_str, tunable_ftp_username);
#line 239
  common_do_login(p_sess, (struct mystr  const  *)(& p_sess->user_str), 1, 1);
#line 240
  break;
  case 3: 
#line 243
  do_chroot = 0;
#line 244
  if (tunable_chroot_local_user) {
#line 246
    do_chroot = 1;
  }
#line 248
  if (tunable_chroot_list_enable) {
#line 250
    chroot_list_file.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 250
    chroot_list_file.PRIVATE_HANDS_OFF_len = 0U;
#line 250
    chroot_list_file.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 251
    __cil_tmp = str_fileread(& chroot_list_file, tunable_chroot_list_file, 100000U);
#line 251
    retval = __cil_tmp;
#line 254
    __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 254
    if (__cil_tmp___0) {
#line 256
      die2("could not open chroot() list file:", tunable_chroot_list_file);
    }
#line 259
    __cil_tmp___1 = str_contains_line((struct mystr  const  *)(& chroot_list_file),
                                      (struct mystr  const  *)(& p_sess->user_str));
#line 259
    if (__cil_tmp___1) {
#line 261
      if (do_chroot) {
#line 263
        do_chroot = 0;
      } else {
#line 267
        do_chroot = 1;
      }
    }
#line 270
    str_free(& chroot_list_file);
  }
#line 272
  common_do_login(p_sess, (struct mystr  const  *)(& p_sess->user_str), do_chroot,
                  0);
#line 274
  break;
  default: 
#line 276
  bug("weird state in process_login_request");
#line 277
  break;
  }
#line 280
  return;
}
}
#line 282 "twoprocess.c"
static void process_ssl_slave_req(struct vsf_session *p_sess ) 
{ char cmd ;
  char __cil_tmp ;
  int retval ;

  {
#line 285
  priv_sock_send_str(p_sess->ssl_slave_fd, (struct mystr  const  *)(& p_sess->control_cert_digest));
#line 286
  while (1) {
#line 288
    __cil_tmp = priv_sock_get_cmd(p_sess->ssl_slave_fd);
#line 288
    cmd = __cil_tmp;
#line 290
    if ((int )cmd == 4) {
#line 292
      ftp_getline((struct vsf_session  const  *)p_sess, & p_sess->ftp_cmd_str, p_sess->p_control_line_buf);
#line 293
      priv_sock_send_str(p_sess->ssl_slave_fd, (struct mystr  const  *)(& p_sess->ftp_cmd_str));
    } else {
#line 295
      if ((int )cmd == 5) {
#line 297
        priv_sock_get_str(p_sess->ssl_slave_fd, & p_sess->ftp_cmd_str);
#line 298
        retval = ftp_write_str((struct vsf_session  const  *)p_sess, (struct mystr  const  *)(& p_sess->ftp_cmd_str),
                               1);
#line 299
        priv_sock_send_int(p_sess->ssl_slave_fd, retval);
      } else {
#line 303
        die("bad request in process_ssl_slave_req");
      }
    }
  }
}
}
#line 308 "twoprocess.c"
static void common_do_login(struct vsf_session *p_sess , struct mystr  const  *p_user_str ,
                            int do_chroot , int anon ) 
{ int was_anon ;
  struct mystr  const  *p_orig_user_str ;
  int newpid ;
  struct mystr guest_user_str ;
  struct mystr chroot_str ;
  struct mystr chdir_str ;
  struct mystr userdir_str ;
  unsigned int secutil_option ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 312
  was_anon = anon;
#line 313
  p_orig_user_str = p_user_str;
#line 315
  vsf_sysutil_install_null_sighandler(3);
#line 317
  priv_sock_send_result(p_sess->parent_fd, (char)1);
#line 318
  if (! p_sess->control_use_ssl) {
#line 320
    vsf_sysutil_wait();
  } else {
#line 324
    p_sess->ssl_slave_active = 1;
  }
#line 327
  vsf_sysutil_unblock_sig(3);
#line 329
  handle_per_user_config(p_user_str);
#line 331
  p_sess->is_anonymous = anon;
#line 332
  vsf_sysutil_install_async_sighandler(3, & handle_sigchld);
#line 333
  newpid = vsf_sysutil_fork();
#line 334
  if (newpid == 0) {
#line 336
    guest_user_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 336
    guest_user_str.PRIVATE_HANDS_OFF_len = 0U;
#line 336
    guest_user_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 337
    chroot_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 337
    chroot_str.PRIVATE_HANDS_OFF_len = 0U;
#line 337
    chroot_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 338
    chdir_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 338
    chdir_str.PRIVATE_HANDS_OFF_len = 0U;
#line 338
    chdir_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 339
    userdir_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 339
    userdir_str.PRIVATE_HANDS_OFF_len = 0U;
#line 339
    userdir_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 340
    secutil_option = 2U;
#line 342
    vsf_sysutil_close(p_sess->parent_fd);
#line 343
    if (tunable_ssl_enable) {
#line 345
      vsf_sysutil_close(p_sess->ssl_slave_fd);
#line 346
      if (p_sess->ssl_slave_active) {
#line 348
        priv_sock_get_str(p_sess->ssl_consumer_fd, & p_sess->control_cert_digest);
      }
    }
#line 352
    if (tunable_guest_enable && ! anon) {
#line 354
      p_sess->is_guest = 1;
#line 356
      str_alloc_text(& guest_user_str, tunable_guest_username);
#line 357
      p_user_str = (struct mystr  const  *)(& guest_user_str);
#line 358
      if (! tunable_virtual_use_local_privs) {
#line 360
        anon = 1;
#line 361
        do_chroot = 1;
      }
    }
#line 364
    if (do_chroot) {
#line 366
      secutil_option |= 1U;
    }
#line 368
    if (! anon) {
#line 370
      secutil_option |= 4U;
    }
#line 372
    calculate_chdir_dir(was_anon, & userdir_str, & chroot_str, & chdir_str, p_user_str,
                        p_orig_user_str);
#line 374
    vsf_secutil_change_credentials(p_user_str, (struct mystr  const  *)(& userdir_str),
                                   (struct mystr  const  *)(& chroot_str), 0U, secutil_option);
#line 376
    __cil_tmp = str_isempty((struct mystr  const  *)(& chdir_str));
#line 376
    if (! __cil_tmp) {
#line 378
      str_chdir((struct mystr  const  *)(& chdir_str));
    }
#line 380
    str_free(& guest_user_str);
#line 381
    str_free(& chroot_str);
#line 382
    str_free(& chdir_str);
#line 383
    str_free(& userdir_str);
#line 387
    if (was_anon) {
#line 387
      __cil_tmp___0 = vsf_sysutil_write_access("/");
#line 387
      if (__cil_tmp___0) {
#line 389
        die("vsftpd: refusing to run with writable anonymous root");
      } else {
#line 387
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 391
    p_sess->is_anonymous = anon;
#line 392
    process_post_login(p_sess);
#line 393
    bug("should not get here: common_do_login");
  }
#line 396
  if (tunable_ssl_enable) {
#line 398
    vsf_sysutil_close(p_sess->ssl_consumer_fd);
  }
#line 401
  vsf_priv_parent_postlogin(p_sess);
#line 402
  bug("should not get here in common_do_login");
#line 403
  return;
}
}
#line 405 "twoprocess.c"
static void handle_per_user_config(struct mystr  const  *p_user_str ) 
{ struct mystr filename_str ;
  struct vsf_sysutil_statbuf *p_statbuf___0 ;
  struct str_locate_result loc_result ;
  int retval ;
  char const   *__cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 408
  filename_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 408
  filename_str.PRIVATE_HANDS_OFF_len = 0U;
#line 408
  filename_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 409
  p_statbuf___0 = (struct vsf_sysutil_statbuf *)0;
#line 412
  if (! tunable_user_config_dir) {
#line 414
    return;
  }
#line 417
  loc_result = str_locate_char(p_user_str, (char )'/');
#line 418
  if (loc_result.found) {
#line 420
    return;
  }
#line 422
  str_alloc_text(& filename_str, tunable_user_config_dir);
#line 423
  str_append_char(& filename_str, (char )'/');
#line 424
  str_append_str(& filename_str, p_user_str);
#line 425
  retval = str_stat((struct mystr  const  *)(& filename_str), & p_statbuf___0);
#line 427
  __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 427
  if (__cil_tmp___0) {
    _L: /* CIL Label */ ;
  } else {
#line 427
    __cil_tmp___1 = vsf_sysutil_statbuf_get_uid((struct vsf_sysutil_statbuf  const  *)p_statbuf___0);
#line 427
    if (__cil_tmp___1 == 0) {
#line 430
      __cil_tmp = str_getbuf((struct mystr  const  *)(& filename_str));
#line 430
      vsf_parseconf_load_file(__cil_tmp, 1);
    } else {
#line 427
      goto _L;
    }
  }
#line 432
  str_free(& filename_str);
#line 433
  vsf_sysutil_free((void *)p_statbuf___0);
#line 434
  return;
}
}
#line 436 "twoprocess.c"
static void calculate_chdir_dir(int anon_login , struct mystr *p_userdir_str , struct mystr *p_chroot_str ,
                                struct mystr *p_chdir_str , struct mystr  const  *p_user_str ,
                                struct mystr  const  *p_orig_user_str ) 
{ struct vsf_sysutil_user  const  *p_user ;
  struct vsf_sysutil_user *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  char const   *__cil_tmp___2 ;
  char const   *__cil_tmp___3 ;
  struct str_locate_result loc_result ;

  {
#line 443
  if (! anon_login) {
#line 445
    __cil_tmp = str_getpwnam(p_user_str);
#line 445
    p_user = (struct vsf_sysutil_user  const  *)__cil_tmp;
#line 446
    if ((unsigned int )p_user == (unsigned int )((struct vsf_sysutil_user  const  *)0)) {
#line 448
      __cil_tmp___0 = str_getbuf(p_user_str);
#line 448
      die2("cannot locate user entry:", __cil_tmp___0);
    }
#line 450
    __cil_tmp___1 = vsf_sysutil_user_get_homedir(p_user);
#line 450
    str_alloc_text(p_userdir_str, __cil_tmp___1);
#line 451
    if (tunable_user_sub_token) {
#line 453
      __cil_tmp___2 = str_getbuf(p_orig_user_str);
#line 453
      str_replace_text(p_userdir_str, tunable_user_sub_token, __cil_tmp___2);
    }
  }
#line 457
  if (anon_login && (int )tunable_anon_root) {
#line 459
    str_alloc_text(p_chroot_str, tunable_anon_root);
  } else {
#line 461
    if (! anon_login && (int )tunable_local_root) {
#line 463
      str_alloc_text(p_chroot_str, tunable_local_root);
#line 464
      if (tunable_user_sub_token) {
#line 466
        __cil_tmp___3 = str_getbuf(p_orig_user_str);
#line 466
        str_replace_text(p_chroot_str, tunable_user_sub_token, __cil_tmp___3);
      }
    }
  }
#line 473
  if (! anon_login && tunable_passwd_chroot_enable) {
#line 476
    loc_result = str_locate_text((struct mystr  const  *)p_userdir_str, "/./");
#line 477
    if (loc_result.found) {
#line 479
      str_split_text(p_userdir_str, p_chdir_str, "/./");
#line 480
      str_copy(p_chroot_str, (struct mystr  const  *)p_userdir_str);
    }
  }
#line 483
  return;
}
}
#line 1 "cil-SORGQC5b.o"
#pragma merger(0,"/tmp/cil-NPvZTly6.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 18 "sysdeputil.h"
int vsf_sysdep_check_auth(struct mystr  const  *p_user_str , struct mystr  const  *p_pass_str ,
                          struct mystr  const  *p_remote_host ) ;
#line 134 "sysutil.h"
void vsf_sysutil_fchown(int fd , int uid , int gid ) ;
#line 200
int vsf_sysutil_isalnum(int the_char ) ;
#line 23 "privops.c"
static enum EVSFPrivopLoginResult handle_anonymous_login(struct vsf_session *p_sess ,
                                                         struct mystr  const  *p_pass_str ) ;
#line 25
static enum EVSFPrivopLoginResult handle_local_login(struct vsf_session *p_sess ,
                                                     struct mystr  const  *p_user_str ,
                                                     struct mystr  const  *p_pass_str ) ;
#line 28
static void setup_username_globals(struct vsf_session *p_sess , struct mystr  const  *p_str ) ;
#line 30
static enum EVSFPrivopLoginResult handle_login(struct vsf_session *p_sess , struct mystr  const  *p_user_str ,
                                               struct mystr  const  *p_pass_str ) ;
#line 37 "privops.c"
static struct vsf_sysutil_sockaddr *p_sockaddr  ;
#line 34 "privops.c"
int vsf_privop_get_ftp_port_sock(struct vsf_session *p_sess ) 
{ int retval ;
  int i ;
  int s ;
  int __cil_tmp ;
  double sleep_for ;
  enum EVSFSysUtilError __cil_tmp___0 ;
  unsigned char __cil_tmp___1 ;

  {
#line 40
  __cil_tmp = vsf_sysutil_get_ipsock((struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 40
  s = __cil_tmp;
#line 41
  vsf_sysutil_activate_reuseaddr(s);
#line 45
  i = 0;
#line 45
  while (i < 2) {
#line 48
    vsf_sysutil_sockaddr_clone(& p_sockaddr, (struct vsf_sysutil_sockaddr  const  *)p_sess->p_local_addr);
#line 49
    vsf_sysutil_sockaddr_set_port(p_sockaddr, (unsigned short )tunable_ftp_data_port);
#line 50
    retval = vsf_sysutil_bind(s, (struct vsf_sysutil_sockaddr  const  *)p_sockaddr);
#line 51
    if (retval == 0) {
#line 53
      return (s);
    }
#line 55
    __cil_tmp___0 = vsf_sysutil_get_error();
#line 55
    if ((int )__cil_tmp___0 != 2 || i == 1) {
#line 57
      die("vsf_sysutil_bind");
    }
#line 59
    __cil_tmp___1 = vsf_sysutil_get_random_byte();
#line 59
    sleep_for = (double )__cil_tmp___1;
#line 60
    sleep_for /= 256.0;
#line 61
    sleep_for += 1.0;
#line 62
    vsf_sysutil_sleep(sleep_for);
#line 45
    i ++;
  }
#line 64
  return (s);
}
}
#line 70 "privops.c"
static struct vsf_sysutil_statbuf *s_p_statbuf___6  ;
#line 67 "privops.c"
void vsf_privop_do_file_chown(struct vsf_session *p_sess , int fd ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 71
  vsf_sysutil_fstat(fd, & s_p_statbuf___6);
#line 73
  __cil_tmp = vsf_sysutil_statbuf_get_uid((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___6);
#line 73
  if (__cil_tmp == p_sess->anon_upload_chown_uid) {
#line 76
    return;
  }
#line 81
  if (p_sess->anon_upload_chown_uid == -1) {
#line 81
    goto _L___1;
  } else {
#line 81
    __cil_tmp___0 = vsf_sysutil_statbuf_is_regfile((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___6);
#line 81
    if (__cil_tmp___0) {
#line 81
      __cil_tmp___1 = vsf_sysutil_statbuf_get_uid((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___6);
#line 81
      if (__cil_tmp___1 != p_sess->anon_ftp_uid) {
#line 81
        __cil_tmp___2 = vsf_sysutil_statbuf_get_uid((struct vsf_sysutil_statbuf  const  *)s_p_statbuf___6);
#line 81
        if (__cil_tmp___2 != p_sess->guest_user_uid) {
          _L: /* CIL Label */ 
#line 86
          die("invalid fd in cmd_process_chown");
        } else {
#line 81
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 81
      goto _L;
    }
  }
#line 92
  vsf_sysutil_fchown(fd, p_sess->anon_upload_chown_uid, -1);
#line 93
  return;
}
}
#line 95 "privops.c"
enum EVSFPrivopLoginResult vsf_privop_do_login(struct vsf_session *p_sess , struct mystr  const  *p_pass_str ) 
{ enum EVSFPrivopLoginResult result ;
  enum EVSFPrivopLoginResult __cil_tmp ;

  {
#line 99
  __cil_tmp = handle_login(p_sess, (struct mystr  const  *)(& p_sess->user_str), p_pass_str);
#line 99
  result = __cil_tmp;
#line 101
  vsf_log_start_entry(p_sess, 5);
#line 102
  if ((int )result == 1) {
#line 104
    vsf_log_do_log(p_sess, 0);
#line 105
    if (tunable_delay_failed_login) {
#line 107
      vsf_sysutil_sleep((double )tunable_delay_failed_login);
    }
  } else {
#line 112
    vsf_log_do_log(p_sess, 1);
#line 113
    if (tunable_delay_successful_login) {
#line 115
      vsf_sysutil_sleep((double )tunable_delay_successful_login);
    }
  }
#line 118
  return (result);
}
}
#line 121 "privops.c"
static enum EVSFPrivopLoginResult handle_login(struct vsf_session *p_sess , struct mystr  const  *p_user_str ,
                                               struct mystr  const  *p_pass_str ) 
{ int anonymous_login ;
  unsigned int len ;
  unsigned int __cil_tmp ;
  char __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  struct mystr upper_str ;
  int __cil_tmp___4 ;
  int __cil_tmp___5 ;
  enum EVSFPrivopLoginResult result ;

  {
#line 128
  anonymous_login = 0;
#line 129
  __cil_tmp = str_getlen(p_user_str);
#line 129
  len = __cil_tmp;
#line 130
  if (len == 0U || len > 32U) {
#line 132
    return (1);
  }
#line 135
  __cil_tmp___0 = str_get_char_at(p_user_str, 0U);
#line 135
  __cil_tmp___1 = vsf_sysutil_isalnum((int )__cil_tmp___0);
#line 135
  if (! __cil_tmp___1) {
#line 137
    return (1);
  }
#line 140
  __cil_tmp___2 = str_contains_space(p_user_str);
#line 140
  if (__cil_tmp___2) {
#line 140
    goto _L;
  } else {
#line 140
    __cil_tmp___3 = str_contains_unprintable(p_user_str);
#line 140
    if (__cil_tmp___3) {
      _L: /* CIL Label */ 
#line 143
      return (1);
    }
  }
#line 146
  len = str_getlen(p_pass_str);
#line 147
  if (len > 128U) {
#line 149
    return (1);
  }
#line 152
  if (tunable_anonymous_enable) {
#line 154
    upper_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 154
    upper_str.PRIVATE_HANDS_OFF_len = 0U;
#line 154
    upper_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 155
    str_copy(& upper_str, p_user_str);
#line 156
    str_upper(& upper_str);
#line 157
    __cil_tmp___4 = str_equal_text((struct mystr  const  *)(& upper_str), "FTP");
#line 157
    if (__cil_tmp___4) {
#line 157
      goto _L___0;
    } else {
#line 157
      __cil_tmp___5 = str_equal_text((struct mystr  const  *)(& upper_str), "ANONYMOUS");
#line 157
      if (__cil_tmp___5) {
        _L___0: /* CIL Label */ 
#line 160
        anonymous_login = 1;
      }
    }
#line 162
    str_free(& upper_str);
  }
#line 165
  result = 1;
#line 166
  if (anonymous_login) {
#line 168
    result = handle_anonymous_login(p_sess, p_pass_str);
  } else {
#line 172
    if (! tunable_local_enable) {
#line 174
      die("unexpected local login in handle_login");
    }
#line 176
    result = handle_local_login(p_sess, p_user_str, p_pass_str);
  }
#line 178
  return (result);
}
}
#line 182 "privops.c"
static enum EVSFPrivopLoginResult handle_anonymous_login(struct vsf_session *p_sess ,
                                                         struct mystr  const  *p_pass_str ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;
  struct mystr ftp_username_str ;

  {
#line 186
  __cil_tmp = str_isempty((struct mystr  const  *)(& p_sess->banned_email_str));
#line 186
  if (__cil_tmp) {
    _L: /* CIL Label */ ;
  } else {
#line 186
    __cil_tmp___0 = str_contains_line((struct mystr  const  *)(& p_sess->banned_email_str),
                                      p_pass_str);
#line 186
    if (__cil_tmp___0) {
#line 189
      return (1);
    } else {
#line 186
      goto _L;
    }
  }
#line 191
  __cil_tmp___1 = str_isempty((struct mystr  const  *)(& p_sess->email_passwords_str));
#line 191
  if (__cil_tmp___1) {
    _L___0: /* CIL Label */ ;
  } else {
#line 191
    __cil_tmp___2 = str_contains_line((struct mystr  const  *)(& p_sess->email_passwords_str),
                                      p_pass_str);
#line 191
    if (__cil_tmp___2) {
#line 191
      __cil_tmp___3 = str_isempty(p_pass_str);
#line 191
      if (__cil_tmp___3) {
        _L___1: /* CIL Label */ 
#line 195
        return (1);
      } else {
#line 191
        goto _L___0;
      }
    } else {
#line 191
      goto _L___1;
    }
  }
#line 198
  str_copy(& p_sess->anon_pass_str, p_pass_str);
#line 199
  __cil_tmp___4 = str_isempty((struct mystr  const  *)(& p_sess->anon_pass_str));
#line 199
  if (__cil_tmp___4) {
#line 201
    str_alloc_text(& p_sess->anon_pass_str, "?");
  }
#line 204
  str_replace_char(& p_sess->anon_pass_str, (char )' ', (char )'_');
#line 205
  str_replace_char(& p_sess->anon_pass_str, (char )'\n', (char )'?');
#line 207
  ftp_username_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 207
  ftp_username_str.PRIVATE_HANDS_OFF_len = 0U;
#line 207
  ftp_username_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 208
  str_alloc_text(& ftp_username_str, tunable_ftp_username);
#line 209
  setup_username_globals(p_sess, (struct mystr  const  *)(& ftp_username_str));
#line 210
  str_free(& ftp_username_str);
#line 212
  str_free(& p_sess->banned_email_str);
#line 213
  str_free(& p_sess->email_passwords_str);
#line 214
  return (2);
}
}
#line 217 "privops.c"
static enum EVSFPrivopLoginResult handle_local_login(struct vsf_session *p_sess ,
                                                     struct mystr  const  *p_user_str ,
                                                     struct mystr  const  *p_pass_str ) 
{ int __cil_tmp ;

  {
#line 222
  __cil_tmp = vsf_sysdep_check_auth(p_user_str, p_pass_str, (struct mystr  const  *)(& p_sess->remote_ip_str));
#line 222
  if (! __cil_tmp) {
#line 224
    return (1);
  }
#line 226
  setup_username_globals(p_sess, p_user_str);
#line 227
  return (3);
}
}
#line 230 "privops.c"
static void setup_username_globals(struct vsf_session *p_sess , struct mystr  const  *p_str ) 
{ struct mystr prefix_str ;

  {
#line 233
  str_copy(& p_sess->user_str, p_str);
#line 234
  if (tunable_setproctitle_enable) {
#line 236
    prefix_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 236
    prefix_str.PRIVATE_HANDS_OFF_len = 0U;
#line 236
    prefix_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 237
    str_copy(& prefix_str, (struct mystr  const  *)(& p_sess->remote_ip_str));
#line 238
    str_append_char(& prefix_str, (char )'/');
#line 239
    str_append_str(& prefix_str, p_str);
#line 240
    vsf_sysutil_set_proctitle_prefix((struct mystr  const  *)(& prefix_str));
#line 241
    str_free(& prefix_str);
  }
#line 243
  return;
}
}
#line 1 "cil-b7K5ygOP.o"
#pragma merger(0,"/tmp/cil-LWCiX5jC.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 88 "sysutil.h"
void vsf_sysutil_dupfd2(int old_fd , int new_fd ) ;
#line 164
int vsf_sysutil_fork_failok(void) ;
#line 172
int vsf_sysutil_wait_reap_one(void) ;
#line 212
void vsf_sysutil_sockaddr_alloc_ipv4(struct vsf_sysutil_sockaddr **p_sockptr ) ;
#line 213
void vsf_sysutil_sockaddr_alloc_ipv6(struct vsf_sysutil_sockaddr **p_sockptr ) ;
#line 225
void vsf_sysutil_sockaddr_set_any(struct vsf_sysutil_sockaddr *p_sockaddr___0 ) ;
#line 230
unsigned int vsf_sysutil_get_ipaddr_size(void) ;
#line 231
void *vsf_sysutil_sockaddr_get_raw_addr(struct vsf_sysutil_sockaddr *p_sockptr ) ;
#line 8 "hash.h"
struct hash *hash_alloc(unsigned int buckets , unsigned int key_size , unsigned int value_size ,
                        unsigned int (*hash_func)(unsigned int  , void * ) ) ;
#line 10
void *hash_lookup_entry(struct hash *p_hash , void *p_key ) ;
#line 11
void hash_add_entry(struct hash *p_hash , void *p_key , void *p_value ) ;
#line 12
void hash_free_entry(struct hash *p_hash , void *p_key ) ;
#line 22 "standalone.c"
static unsigned int s_children  ;
#line 23 "standalone.c"
static struct hash *s_p_ip_count_hash  ;
#line 24 "standalone.c"
static struct hash *s_p_pid_ip_hash  ;
#line 25 "standalone.c"
static unsigned int s_ipaddr_size  ;
#line 27
static void handle_sigchld___0(int duff ) ;
#line 28
static void handle_sighup(int duff ) ;
#line 29
static void prepare_child(int new_client_sock ) ;
#line 30
static unsigned int handle_ip_count(void *p_ipaddr ) ;
#line 31
static void drop_ip_count(void *p_raw_addr ) ;
#line 33
static unsigned int hash_ip(unsigned int buckets , void *p_key ) ;
#line 34
static unsigned int hash_pid(unsigned int buckets , void *p_key ) ;
#line 36 "standalone.c"
struct vsf_client_launch vsf_standalone_main(void) 
{ struct vsf_sysutil_sockaddr *p_accept_addr ;
  int listen_sock ;
  int retval ;
  int forkret ;
  int __cil_tmp ;
  struct vsf_sysutil_sockaddr *p_sockaddr___0 ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  struct vsf_sysutil_sockaddr *p_sockaddr___1 ;
  struct mystr addr_str ;
  unsigned char const   *p_raw_addr ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  struct vsf_client_launch child_info ;
  void *p_raw_addr___0 ;
  int new_child ;
  int new_client_sock ;
  int __cil_tmp___4 ;

  {
#line 39
  p_accept_addr = (struct vsf_sysutil_sockaddr *)0;
#line 40
  listen_sock = -1;
#line 42
  s_ipaddr_size = vsf_sysutil_get_ipaddr_size();
#line 43
  if (tunable_listen && tunable_listen_ipv6) {
#line 45
    die("run two copies of vsftpd for IPv4 and IPv6");
  }
#line 47
  if (tunable_background) {
#line 49
    __cil_tmp = vsf_sysutil_fork();
#line 49
    forkret = __cil_tmp;
#line 50
    if (forkret > 0) {
#line 53
      vsf_sysutil_exit(0);
    }
#line 56
    vsf_sysutil_close_failok(0);
#line 57
    vsf_sysutil_close_failok(1);
#line 58
    vsf_sysutil_close_failok(2);
#line 59
    vsf_sysutil_make_session_leader();
  }
#line 61
  if (tunable_listen) {
#line 63
    listen_sock = vsf_sysutil_get_ipv4_sock();
  } else {
#line 67
    listen_sock = vsf_sysutil_get_ipv6_sock();
  }
#line 69
  vsf_sysutil_activate_reuseaddr(listen_sock);
#line 71
  s_p_ip_count_hash = hash_alloc(256U, s_ipaddr_size, (unsigned int )sizeof(unsigned int ),
                                 & hash_ip);
#line 73
  s_p_pid_ip_hash = hash_alloc(256U, (unsigned int )sizeof(int ), s_ipaddr_size, & hash_pid);
#line 75
  if (tunable_setproctitle_enable) {
#line 77
    vsf_sysutil_setproctitle("LISTENER");
  }
#line 79
  vsf_sysutil_install_async_sighandler(3, & handle_sigchld___0);
#line 80
  vsf_sysutil_install_async_sighandler(6, & handle_sighup);
#line 81
  if (tunable_listen) {
#line 83
    p_sockaddr___0 = (struct vsf_sysutil_sockaddr *)0;
#line 84
    vsf_sysutil_sockaddr_alloc_ipv4(& p_sockaddr___0);
#line 85
    vsf_sysutil_sockaddr_set_port(p_sockaddr___0, (unsigned short )tunable_listen_port);
#line 86
    if (! tunable_listen_address) {
#line 88
      vsf_sysutil_sockaddr_set_any(p_sockaddr___0);
    } else {
#line 92
      __cil_tmp___0 = vsf_sysutil_inet_aton(tunable_listen_address, p_sockaddr___0);
#line 92
      if (! __cil_tmp___0) {
#line 94
        die2("bad listen_address: ", tunable_listen_address);
      }
    }
#line 97
    retval = vsf_sysutil_bind(listen_sock, (struct vsf_sysutil_sockaddr  const  *)p_sockaddr___0);
#line 98
    vsf_sysutil_free((void *)p_sockaddr___0);
#line 99
    __cil_tmp___1 = vsf_sysutil_retval_is_error(retval);
#line 99
    if (__cil_tmp___1) {
#line 101
      die("could not bind listening IPv4 socket");
    }
  } else {
#line 106
    p_sockaddr___1 = (struct vsf_sysutil_sockaddr *)0;
#line 107
    vsf_sysutil_sockaddr_alloc_ipv6(& p_sockaddr___1);
#line 108
    vsf_sysutil_sockaddr_set_port(p_sockaddr___1, (unsigned short )tunable_listen_port);
#line 109
    if (! tunable_listen_address6) {
#line 111
      vsf_sysutil_sockaddr_set_any(p_sockaddr___1);
    } else {
#line 115
      addr_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 115
      addr_str.PRIVATE_HANDS_OFF_len = 0U;
#line 115
      addr_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 117
      str_alloc_text(& addr_str, tunable_listen_address6);
#line 118
      p_raw_addr = vsf_sysutil_parse_ipv6((struct mystr  const  *)(& addr_str));
#line 119
      str_free(& addr_str);
#line 120
      if (! p_raw_addr) {
#line 122
        die2("bad listen_address6: ", tunable_listen_address6);
      }
#line 124
      vsf_sysutil_sockaddr_set_ipv6addr(p_sockaddr___1, p_raw_addr);
    }
#line 126
    retval = vsf_sysutil_bind(listen_sock, (struct vsf_sysutil_sockaddr  const  *)p_sockaddr___1);
#line 127
    vsf_sysutil_free((void *)p_sockaddr___1);
#line 128
    __cil_tmp___2 = vsf_sysutil_retval_is_error(retval);
#line 128
    if (__cil_tmp___2) {
#line 130
      die("could not bind listening IPv6 socket");
    }
  }
#line 133
  retval = vsf_sysutil_listen(listen_sock, 32U);
#line 134
  __cil_tmp___3 = vsf_sysutil_retval_is_error(retval);
#line 134
  if (__cil_tmp___3) {
#line 136
    die("could not listen");
  }
#line 138
  vsf_sysutil_sockaddr_alloc(& p_accept_addr);
#line 139
  while (1) {
#line 145
    vsf_sysutil_unblock_sig(3);
#line 146
    vsf_sysutil_unblock_sig(6);
#line 147
    new_client_sock = vsf_sysutil_accept_timeout(listen_sock, p_accept_addr, 0U);
#line 149
    vsf_sysutil_block_sig(3);
#line 150
    vsf_sysutil_block_sig(6);
#line 151
    __cil_tmp___4 = vsf_sysutil_retval_is_error(new_client_sock);
#line 151
    if (__cil_tmp___4) {
#line 153
      continue;
    }
#line 155
    s_children ++;
#line 156
    child_info.num_children = s_children;
#line 157
    child_info.num_this_ip = 0U;
#line 158
    p_raw_addr___0 = vsf_sysutil_sockaddr_get_raw_addr(p_accept_addr);
#line 159
    child_info.num_this_ip = handle_ip_count(p_raw_addr___0);
#line 160
    new_child = vsf_sysutil_fork_failok();
#line 161
    if (new_child != 0) {
#line 164
      vsf_sysutil_close(new_client_sock);
#line 165
      if (new_child > 0) {
#line 167
        hash_add_entry(s_p_pid_ip_hash, (void *)(& new_child), p_raw_addr___0);
      } else {
#line 172
        s_children --;
#line 173
        drop_ip_count(p_raw_addr___0);
      }
    } else {
#line 180
      vsf_sysutil_close(listen_sock);
#line 181
      prepare_child(new_client_sock);
#line 185
      return (child_info);
    }
  }
}
}
#line 190 "standalone.c"
static void prepare_child(int new_client_sock ) 
{ 

  {
#line 194
  vsf_sysutil_dupfd2(new_client_sock, 0);
#line 195
  vsf_sysutil_dupfd2(new_client_sock, 1);
#line 196
  vsf_sysutil_dupfd2(new_client_sock, 2);
#line 197
  if (new_client_sock > 2) {
#line 199
    vsf_sysutil_close(new_client_sock);
  }
#line 201
  return;
}
}
#line 203 "standalone.c"
static void drop_ip_count(void *p_raw_addr ) 
{ unsigned int count ;
  unsigned int *p_count ;
  void *__cil_tmp ;

  {
#line 207
  __cil_tmp = hash_lookup_entry(s_p_ip_count_hash, p_raw_addr);
#line 207
  p_count = (unsigned int *)__cil_tmp;
#line 209
  if (! p_count) {
#line 211
    bug("IP address missing from hash");
  }
#line 213
  count = *p_count;
#line 214
  if (! count) {
#line 216
    bug("zero count for IP address");
  }
#line 218
  count --;
#line 219
  *p_count = count;
#line 220
  if (! count) {
#line 222
    hash_free_entry(s_p_ip_count_hash, p_raw_addr);
  }
#line 224
  return;
}
}
#line 226 "standalone.c"
static void handle_sigchld___0(int duff ) 
{ unsigned int reap_one ;
  int __cil_tmp ;
  struct vsf_sysutil_ipaddr *p_ip ;
  void *__cil_tmp___0 ;

  {
#line 229
  reap_one = 1U;
#line 231
  while (reap_one) {
#line 233
    __cil_tmp = vsf_sysutil_wait_reap_one();
#line 233
    reap_one = (unsigned int )__cil_tmp;
#line 234
    if (reap_one) {
#line 238
      s_children --;
#line 240
      __cil_tmp___0 = hash_lookup_entry(s_p_pid_ip_hash, (void *)(& reap_one));
#line 240
      p_ip = (struct vsf_sysutil_ipaddr *)__cil_tmp___0;
#line 242
      drop_ip_count((void *)p_ip);
#line 243
      hash_free_entry(s_p_pid_ip_hash, (void *)(& reap_one));
    }
  }
#line 246
  return;
}
}
#line 248 "standalone.c"
static void handle_sighup(int duff ) 
{ 

  {
#line 253
  vsf_parseconf_load_file((char const   *)0, 0);
#line 254
  return;
}
}
#line 256 "standalone.c"
static unsigned int hash_ip(unsigned int buckets , void *p_key ) 
{ unsigned char const   *p_raw_ip ;
  unsigned int val ;
  int shift ;
  unsigned int i ;

  {
#line 259
  p_raw_ip = (unsigned char const   *)p_key;
#line 260
  val = 0U;
#line 261
  shift = 24;
#line 263
  i = 0U;
#line 263
  while (i < s_ipaddr_size) {
#line 265
    val ^= (unsigned int )((int const   )*(p_raw_ip + i) << shift);
#line 266
    shift -= 8;
#line 267
    if (shift < 0) {
#line 269
      shift = 24;
    }
#line 263
    i ++;
  }
#line 272
  return (val % buckets);
}
}
#line 275 "standalone.c"
static unsigned int hash_pid(unsigned int buckets , void *p_key ) 
{ unsigned int *p_pid ;

  {
#line 278
  p_pid = (unsigned int *)p_key;
#line 279
  return (*p_pid % buckets);
}
}
#line 282 "standalone.c"
static unsigned int handle_ip_count(void *p_ipaddr ) 
{ unsigned int *p_count ;
  void *__cil_tmp ;
  unsigned int count ;

  {
#line 285
  __cil_tmp = hash_lookup_entry(s_p_ip_count_hash, p_ipaddr);
#line 285
  p_count = (unsigned int *)__cil_tmp;
#line 288
  if (! p_count) {
#line 290
    count = 1U;
#line 291
    hash_add_entry(s_p_ip_count_hash, p_ipaddr, (void *)(& count));
  } else {
#line 295
    count = *p_count;
#line 296
    count ++;
#line 297
    *p_count = count;
  }
#line 299
  return (count);
}
}
#line 1 "cil-cGZyvm7t.o"
#pragma merger(0,"/tmp/cil-HidxPSne.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 183 "sysutil.h"
void vsf_sysutil_memclr(void *p_dest , unsigned int size ) ;
#line 32 "hash.c"
struct hash_node **hash_get_bucket(struct hash *p_hash , void *p_key ) ;
#line 33
struct hash_node *hash_get_node_by_key(struct hash *p_hash , void *p_key ) ;
#line 35 "hash.c"
struct hash *hash_alloc(unsigned int buckets , unsigned int key_size , unsigned int value_size ,
                        unsigned int (*hash_func)(unsigned int  , void * ) ) 
{ unsigned int size ;
  struct hash *p_hash ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 40
  __cil_tmp = vsf_sysutil_malloc((unsigned int )sizeof(*p_hash));
#line 40
  p_hash = (struct hash *)__cil_tmp;
#line 41
  p_hash->buckets = buckets;
#line 42
  p_hash->key_size = key_size;
#line 43
  p_hash->value_size = value_size;
#line 44
  p_hash->hash_func = hash_func;
#line 45
  size = (unsigned int )(sizeof(struct hash_node *) * (unsigned long )buckets);
#line 46
  __cil_tmp___0 = vsf_sysutil_malloc(size);
#line 46
  p_hash->p_nodes = (struct hash_node **)__cil_tmp___0;
#line 47
  vsf_sysutil_memclr((void *)p_hash->p_nodes, size);
#line 48
  return (p_hash);
}
}
#line 51 "hash.c"
void *hash_lookup_entry(struct hash *p_hash , void *p_key ) 
{ struct hash_node *p_node ;
  struct hash_node *__cil_tmp ;

  {
#line 54
  __cil_tmp = hash_get_node_by_key(p_hash, p_key);
#line 54
  p_node = __cil_tmp;
#line 55
  if (! p_node) {
#line 57
    return ((void *)p_node);
  }
#line 59
  return (p_node->p_value);
}
}
#line 62 "hash.c"
void hash_add_entry(struct hash *p_hash , void *p_key , void *p_value ) 
{ struct hash_node **p_bucket ;
  struct hash_node *p_new_node ;
  void *__cil_tmp ;
  void *__cil_tmp___0 ;

  {
#line 67
  __cil_tmp = hash_lookup_entry(p_hash, p_key);
#line 67
  if (__cil_tmp) {
#line 69
    bug("duplicate hash key");
  }
#line 71
  p_bucket = hash_get_bucket(p_hash, p_key);
#line 72
  __cil_tmp___0 = vsf_sysutil_malloc((unsigned int )sizeof(*p_new_node));
#line 72
  p_new_node = (struct hash_node *)__cil_tmp___0;
#line 73
  p_new_node->p_prev = (struct hash_node *)0;
#line 74
  p_new_node->p_next = (struct hash_node *)0;
#line 75
  p_new_node->p_key = vsf_sysutil_malloc(p_hash->key_size);
#line 76
  vsf_sysutil_memcpy(p_new_node->p_key, (void const   *)p_key, p_hash->key_size);
#line 77
  p_new_node->p_value = vsf_sysutil_malloc(p_hash->value_size);
#line 78
  vsf_sysutil_memcpy(p_new_node->p_value, (void const   *)p_value, p_hash->value_size);
#line 80
  if (! *p_bucket) {
#line 82
    *p_bucket = p_new_node;
  } else {
#line 86
    p_new_node->p_next = *p_bucket;
#line 87
    (*p_bucket)->p_prev = p_new_node;
#line 88
    *p_bucket = p_new_node;
  }
#line 90
  return;
}
}
#line 92 "hash.c"
void hash_free_entry(struct hash *p_hash , void *p_key ) 
{ struct hash_node *p_node ;
  struct hash_node *__cil_tmp ;
  struct hash_node **p_bucket ;
  struct hash_node **__cil_tmp___0 ;

  {
#line 95
  __cil_tmp = hash_get_node_by_key(p_hash, p_key);
#line 95
  p_node = __cil_tmp;
#line 96
  if (! p_node) {
#line 98
    bug("hash node not found");
  }
#line 100
  vsf_sysutil_free(p_node->p_key);
#line 101
  vsf_sysutil_free(p_node->p_value);
#line 103
  if (p_node->p_prev) {
#line 105
    (p_node->p_prev)->p_next = p_node->p_next;
  } else {
#line 109
    __cil_tmp___0 = hash_get_bucket(p_hash, p_key);
#line 109
    p_bucket = __cil_tmp___0;
#line 110
    *p_bucket = p_node->p_next;
  }
#line 112
  if (p_node->p_next) {
#line 114
    (p_node->p_next)->p_prev = p_node->p_prev;
  }
#line 117
  vsf_sysutil_free((void *)p_node);
#line 118
  return;
}
}
#line 120 "hash.c"
struct hash_node **hash_get_bucket(struct hash *p_hash , void *p_key ) 
{ unsigned int bucket ;
  unsigned int __cil_tmp ;

  {
#line 123
  __cil_tmp = (*(p_hash->hash_func))(p_hash->buckets, p_key);
#line 123
  bucket = __cil_tmp;
#line 124
  if (bucket >= p_hash->buckets) {
#line 126
    bug("bad bucket lookup");
  }
#line 128
  return (p_hash->p_nodes + bucket);
}
}
#line 131 "hash.c"
struct hash_node *hash_get_node_by_key(struct hash *p_hash , void *p_key ) 
{ struct hash_node **p_bucket ;
  struct hash_node **__cil_tmp ;
  struct hash_node *p_node ;
  int __cil_tmp___0 ;

  {
#line 134
  __cil_tmp = hash_get_bucket(p_hash, p_key);
#line 134
  p_bucket = __cil_tmp;
#line 135
  p_node = *p_bucket;
#line 136
  if (! p_node) {
#line 138
    return (p_node);
  }
#line 140
  while (1) {
#line 140
    if ((unsigned int )p_node != (unsigned int )((struct hash_node *)0)) {
#line 140
      __cil_tmp___0 = vsf_sysutil_memcmp((void const   *)p_key, (void const   *)p_node->p_key,
                                         p_hash->key_size);
#line 140
      if (! (__cil_tmp___0 != 0)) {
#line 140
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 140
      break;
    }
#line 143
    p_node = p_node->p_next;
  }
#line 145
  return (p_node);
}
}
#line 1 "cil-RDzAAkVg.o"
#pragma merger(0,"/tmp/cil-xb23ffEI.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 40 "tcpwrap.c"
int vsf_tcp_wrapper_ok(int remote_fd ) 
{ 

  {
#line 44
  die("tcp_wrappers is set to YES but no tcp wrapper support compiled in");
#line 45
  return (0);
}
}
#line 1 "cil-Gbk1nvcU.o"
#pragma merger(0,"/tmp/cil-7Rlg6ckD.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 15 "ipaddrparse.c"
static int ipv6_parse_main(struct mystr *p_out_str , struct mystr  const  *p_in_str ) ;
#line 17
static int ipv6_parse_hex(struct mystr *p_out_str , struct mystr  const  *p_in_str ) ;
#line 19
static int ipv4_parse_dotquad(struct mystr *p_out_str , struct mystr  const  *p_in_str ) ;
#line 25 "ipaddrparse.c"
static struct mystr s_ret  ;
#line 26 "ipaddrparse.c"
static struct mystr s_rhs_ret  ;
#line 27 "ipaddrparse.c"
static struct mystr s_lhs_str  ;
#line 28 "ipaddrparse.c"
static struct mystr s_rhs_str___1  ;
#line 22 "ipaddrparse.c"
unsigned char const   *vsf_sysutil_parse_ipv6(struct mystr  const  *p_str ) 
{ unsigned int lhs_len ;
  unsigned int rhs_len ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  unsigned int add_nulls ;
  unsigned int __cil_tmp___1 ;
  char const   *__cil_tmp___2 ;

  {
#line 31
  str_empty(& s_ret);
#line 32
  str_empty(& s_rhs_ret);
#line 33
  str_copy(& s_lhs_str, p_str);
#line 34
  str_split_text(& s_lhs_str, & s_rhs_str___1, "::");
#line 35
  __cil_tmp = ipv6_parse_main(& s_ret, (struct mystr  const  *)(& s_lhs_str));
#line 35
  if (! __cil_tmp) {
#line 37
    return ((unsigned char const   *)0);
  }
#line 39
  __cil_tmp___0 = ipv6_parse_main(& s_rhs_ret, (struct mystr  const  *)(& s_rhs_str___1));
#line 39
  if (! __cil_tmp___0) {
#line 41
    return ((unsigned char const   *)0);
  }
#line 43
  lhs_len = str_getlen((struct mystr  const  *)(& s_ret));
#line 44
  rhs_len = str_getlen((struct mystr  const  *)(& s_rhs_ret));
#line 45
  if (lhs_len + rhs_len > 16U) {
#line 47
    return ((unsigned char const   *)0);
  }
#line 49
  if (rhs_len > 0U) {
#line 51
    add_nulls = 16U - (lhs_len + rhs_len);
#line 52
    while (1) {
#line 52
      __cil_tmp___1 = add_nulls;
#line 52
      add_nulls --;
#line 52
      if (! __cil_tmp___1) {
#line 52
        break;
      }
#line 54
      str_append_char(& s_ret, (char )'\000');
    }
#line 56
    str_append_str(& s_ret, (struct mystr  const  *)(& s_rhs_ret));
  }
#line 58
  __cil_tmp___2 = str_getbuf((struct mystr  const  *)(& s_ret));
#line 58
  return ((unsigned char const   *)__cil_tmp___2);
}
}
#line 64 "ipaddrparse.c"
static unsigned char items[4]  ;
#line 61 "ipaddrparse.c"
unsigned char const   *vsf_sysutil_parse_ipv4(struct mystr  const  *p_str ) 
{ unsigned char const   *__cil_tmp ;

  {
#line 65
  __cil_tmp = vsf_sysutil_parse_uchar_string_sep(p_str, (char )'.', items, (unsigned int )sizeof(items));
#line 65
  return (__cil_tmp);
}
}
#line 73 "ipaddrparse.c"
static struct mystr s_tmp_str___4  ;
#line 78 "ipaddrparse.c"
static struct mystr s_rhs_sep_str  ;
#line 68 "ipaddrparse.c"
unsigned char const   *vsf_sysutil_parse_uchar_string_sep(struct mystr  const  *p_str ,
                                                          char sep , unsigned char *p_items ,
                                                          unsigned int items___0 ) 
{ unsigned int i ;
  int this_number ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 75
  str_copy(& s_tmp_str___4, p_str);
#line 76
  i = 0U;
#line 76
  while (i < items___0) {
#line 81
    str_split_char(& s_tmp_str___4, & s_rhs_sep_str, sep);
#line 83
    if (i < items___0 - 1U) {
#line 83
      __cil_tmp = str_isempty((struct mystr  const  *)(& s_rhs_sep_str));
#line 83
      if (__cil_tmp) {
#line 83
        goto _L;
      } else {
#line 83
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 83
      if (i == items___0 - 1U) {
#line 83
        __cil_tmp___0 = str_isempty((struct mystr  const  *)(& s_rhs_sep_str));
#line 83
        if (__cil_tmp___0) {
#line 83
          goto _L___0;
        } else {
          _L: /* CIL Label */ 
#line 86
          return ((unsigned char const   *)0);
        }
      } else {
        _L___0: /* CIL Label */ ;
      }
    }
#line 88
    this_number = str_atoi((struct mystr  const  *)(& s_tmp_str___4));
#line 89
    if (this_number < 0 || this_number > 255) {
#line 91
      return ((unsigned char const   *)0);
    }
#line 94
    *(p_items + i) = (unsigned char )this_number;
#line 98
    str_copy(& s_tmp_str___4, (struct mystr  const  *)(& s_rhs_sep_str));
#line 76
    i ++;
  }
#line 100
  return ((unsigned char const   *)p_items);
}
}
#line 106 "ipaddrparse.c"
static struct mystr s_lhs_str___0  ;
#line 107 "ipaddrparse.c"
static struct mystr s_rhs_str___2  ;
#line 103 "ipaddrparse.c"
static int ipv6_parse_main(struct mystr *p_out_str , struct mystr  const  *p_in_str ) 
{ struct str_locate_result loc_ret ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;

  {
#line 109
  str_copy(& s_lhs_str___0, p_in_str);
#line 110
  while (1) {
#line 110
    __cil_tmp___2 = str_isempty((struct mystr  const  *)(& s_lhs_str___0));
#line 110
    if (__cil_tmp___2) {
#line 110
      break;
    }
#line 112
    str_split_char(& s_lhs_str___0, & s_rhs_str___2, (char )':');
#line 113
    __cil_tmp = str_isempty((struct mystr  const  *)(& s_lhs_str___0));
#line 113
    if (__cil_tmp) {
#line 115
      return (0);
    }
#line 117
    loc_ret = str_locate_char((struct mystr  const  *)(& s_lhs_str___0), (char )'.');
#line 118
    if (loc_ret.found) {
#line 120
      __cil_tmp___0 = ipv4_parse_dotquad(p_out_str, (struct mystr  const  *)(& s_lhs_str___0));
#line 120
      if (! __cil_tmp___0) {
#line 122
        return (0);
      }
    } else {
#line 125
      __cil_tmp___1 = ipv6_parse_hex(p_out_str, (struct mystr  const  *)(& s_lhs_str___0));
#line 125
      if (! __cil_tmp___1) {
#line 127
        return (0);
      }
    }
#line 129
    str_copy(& s_lhs_str___0, (struct mystr  const  *)(& s_rhs_str___2));
  }
#line 131
  return (1);
}
}
#line 134 "ipaddrparse.c"
static int ipv6_parse_hex(struct mystr *p_out_str , struct mystr  const  *p_in_str ) 
{ unsigned int len ;
  unsigned int __cil_tmp ;
  unsigned int i ;
  unsigned int val ;
  int ch ;
  char __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 137
  __cil_tmp = str_getlen(p_in_str);
#line 137
  len = __cil_tmp;
#line 139
  val = 0U;
#line 140
  i = 0U;
#line 140
  while (i < len) {
#line 142
    __cil_tmp___0 = str_get_char_at(p_in_str, i);
#line 142
    __cil_tmp___1 = vsf_sysutil_toupper((int )__cil_tmp___0);
#line 142
    ch = __cil_tmp___1;
#line 143
    if (ch >= 48 && ch <= 57) {
#line 145
      ch -= 48;
    } else {
#line 147
      if (ch >= 65 && ch <= 70) {
#line 149
        ch -= 65;
#line 150
        ch += 10;
      } else {
#line 154
        return (0);
      }
    }
#line 156
    val <<= 4;
#line 157
    val |= (unsigned int )ch;
#line 158
    if (val > 65535U) {
#line 160
      return (0);
    }
#line 140
    i ++;
  }
#line 163
  str_append_char(p_out_str, (char )(val >> 8));
#line 164
  str_append_char(p_out_str, (char )(val & 255U));
#line 165
  return (1);
}
}
#line 168 "ipaddrparse.c"
static int ipv4_parse_dotquad(struct mystr *p_out_str , struct mystr  const  *p_in_str ) 
{ unsigned int len ;
  unsigned int __cil_tmp ;
  unsigned int i ;
  unsigned int val ;
  unsigned int final_val ;
  int seen_char ;
  int dots ;
  int ch ;
  char __cil_tmp___0 ;

  {
#line 171
  __cil_tmp = str_getlen(p_in_str);
#line 171
  len = __cil_tmp;
#line 173
  val = 0U;
#line 174
  final_val = 0U;
#line 175
  seen_char = 0;
#line 176
  dots = 0;
#line 177
  i = 0U;
#line 177
  while (i < len) {
#line 179
    __cil_tmp___0 = str_get_char_at(p_in_str, i);
#line 179
    ch = (int )__cil_tmp___0;
#line 180
    if (ch == 46) {
#line 182
      if (! seen_char || dots == 3) {
#line 184
        return (0);
      }
#line 186
      seen_char = 0;
#line 187
      dots ++;
#line 188
      final_val <<= 8;
#line 189
      final_val |= val;
#line 190
      val = 0U;
    } else {
#line 192
      if (ch >= 48 && ch <= 57) {
#line 194
        ch -= 48;
#line 195
        val *= 10U;
#line 196
        val += (unsigned int )ch;
#line 197
        if (val > 255U) {
#line 199
          return (0);
        }
#line 201
        seen_char = 1;
      } else {
#line 205
        return (0);
      }
    }
#line 177
    i ++;
  }
#line 208
  if (dots != 3 || ! seen_char) {
#line 210
    return (0);
  }
#line 212
  final_val <<= 8;
#line 213
  final_val |= val;
#line 214
  str_append_char(p_out_str, (char )(final_val >> 24));
#line 215
  str_append_char(p_out_str, (char )((final_val >> 16) & 255U));
#line 216
  str_append_char(p_out_str, (char )((final_val >> 8) & 255U));
#line 217
  str_append_char(p_out_str, (char )(final_val & 255U));
#line 218
  return (1);
}
}
#line 1 "cil-sEqDhl0z.o"
#pragma merger(0,"/tmp/cil-jhfDCPvP.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 18 "access.c"
static struct mystr s_access_str  ;
#line 15 "access.c"
int vsf_access_check_file(struct mystr  const  *p_filename_str ) 
{ int __cil_tmp ;
  struct str_locate_result loc_res ;
  struct str_locate_result __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 20
  if (! tunable_deny_file) {
#line 22
    return (1);
  }
#line 24
  __cil_tmp = str_isempty((struct mystr  const  *)(& s_access_str));
#line 24
  if (__cil_tmp) {
#line 26
    str_alloc_text(& s_access_str, tunable_deny_file);
  }
#line 28
  __cil_tmp___1 = vsf_filename_passes_filter(p_filename_str, (struct mystr  const  *)(& s_access_str));
#line 28
  if (__cil_tmp___1) {
#line 30
    return (0);
  } else {
#line 34
    __cil_tmp___0 = str_locate_str(p_filename_str, (struct mystr  const  *)(& s_access_str));
#line 34
    loc_res = __cil_tmp___0;
#line 36
    if (loc_res.found) {
#line 38
      return (0);
    }
  }
#line 41
  return (1);
}
}
#line 47 "access.c"
static struct mystr s_access_str___0  ;
#line 44 "access.c"
int vsf_access_check_file_visible(struct mystr  const  *p_filename_str ) 
{ int __cil_tmp ;
  struct str_locate_result loc_res ;
  struct str_locate_result __cil_tmp___0 ;
  int __cil_tmp___1 ;

  {
#line 49
  if (! tunable_hide_file) {
#line 51
    return (1);
  }
#line 53
  __cil_tmp = str_isempty((struct mystr  const  *)(& s_access_str___0));
#line 53
  if (__cil_tmp) {
#line 55
    str_alloc_text(& s_access_str___0, tunable_hide_file);
  }
#line 57
  __cil_tmp___1 = vsf_filename_passes_filter(p_filename_str, (struct mystr  const  *)(& s_access_str___0));
#line 57
  if (__cil_tmp___1) {
#line 59
    return (0);
  } else {
#line 63
    __cil_tmp___0 = str_locate_str(p_filename_str, (struct mystr  const  *)(& s_access_str___0));
#line 63
    loc_res = __cil_tmp___0;
#line 65
    if (loc_res.found) {
#line 67
      return (0);
    }
  }
#line 70
  return (1);
}
}
#line 1 "cil-GpTwCC8m.o"
#pragma merger(0,"/tmp/cil-3VAVk1hr.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 15 "features.c"
void handle_feat(struct vsf_session *p_sess ) 
{ 

  {
#line 18
  vsf_cmdio_write_hyphen(p_sess, 211, "Features:");
#line 19
  if (tunable_ssl_enable) {
#line 21
    vsf_cmdio_write_raw(p_sess, " AUTH SSL\r\n");
#line 22
    vsf_cmdio_write_raw(p_sess, " AUTH TLS\r\n");
  }
#line 24
  if (tunable_port_enable) {
#line 26
    vsf_cmdio_write_raw(p_sess, " EPRT\r\n");
  }
#line 28
  if (tunable_pasv_enable) {
#line 30
    vsf_cmdio_write_raw(p_sess, " EPSV\r\n");
  }
#line 32
  vsf_cmdio_write_raw(p_sess, " MDTM\r\n");
#line 33
  if (tunable_pasv_enable) {
#line 35
    vsf_cmdio_write_raw(p_sess, " PASV\r\n");
  }
#line 37
  if (tunable_ssl_enable) {
#line 39
    vsf_cmdio_write_raw(p_sess, " PBSZ\r\n");
#line 40
    vsf_cmdio_write_raw(p_sess, " PROT\r\n");
  }
#line 42
  vsf_cmdio_write_raw(p_sess, " REST STREAM\r\n");
#line 43
  vsf_cmdio_write_raw(p_sess, " SIZE\r\n");
#line 44
  vsf_cmdio_write_raw(p_sess, " TVFS\r\n");
#line 45
  vsf_cmdio_write_raw(p_sess, " UTF8\r\n");
#line 46
  vsf_cmdio_write(p_sess, 211, "End");
#line 47
  return;
}
}
#line 1 "cil-RkYzpE3a.o"
#pragma merger(0,"/tmp/cil-6GTsrZ20.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 7 "ssl.h"
void ssl_getline(struct vsf_session  const  *p_sess , struct mystr *p_str , char end_char ,
                 char *p_buf , unsigned int buflen ) ;
#line 9
int ssl_read(struct vsf_session *p_sess , char *p_buf , unsigned int len ) ;
#line 10
int ssl_write(void *p_ssl , char const   *p_buf , unsigned int len ) ;
#line 11
int ssl_write_str(void *p_ssl , struct mystr  const  *p_str ) ;
#line 19 "readwrite.c"
int ftp_write_str(struct vsf_session  const  *p_sess , struct mystr  const  *p_str ,
                  enum EVSFRWTarget target ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;

  {
#line 23
  if ((int )target == 2) {
#line 25
    if (p_sess->data_use_ssl) {
#line 27
      __cil_tmp = ssl_write_str((void *)p_sess->p_data_ssl, p_str);
#line 27
      return (__cil_tmp);
    } else {
#line 31
      __cil_tmp___0 = str_netfd_write(p_str, (int )p_sess->data_fd);
#line 31
      return (__cil_tmp___0);
    }
  } else {
#line 36
    if ((int )p_sess->control_use_ssl && (int )p_sess->ssl_slave_active) {
#line 38
      priv_sock_send_cmd((int )p_sess->ssl_consumer_fd, (char)5);
#line 39
      priv_sock_send_str((int )p_sess->ssl_consumer_fd, p_str);
#line 40
      __cil_tmp___1 = priv_sock_get_int((int )p_sess->ssl_consumer_fd);
#line 40
      return (__cil_tmp___1);
    } else {
#line 42
      if (p_sess->control_use_ssl) {
#line 44
        __cil_tmp___2 = ssl_write_str((void *)p_sess->p_control_ssl, p_str);
#line 44
        return (__cil_tmp___2);
      } else {
#line 48
        __cil_tmp___3 = str_netfd_write(p_str, 0);
#line 48
        return (__cil_tmp___3);
      }
    }
  }
}
}
#line 53 "readwrite.c"
int ftp_read_data(struct vsf_session *p_sess , char *p_buf , unsigned int len ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 56
  if (p_sess->data_use_ssl) {
#line 58
    __cil_tmp = ssl_read(p_sess, p_buf, len);
#line 58
    return (__cil_tmp);
  } else {
#line 62
    __cil_tmp___0 = vsf_sysutil_read(p_sess->data_fd, (void *)p_buf, len);
#line 62
    return (__cil_tmp___0);
  }
}
}
#line 66 "readwrite.c"
int ftp_write_data(struct vsf_session  const  *p_sess , char const   *p_buf , unsigned int len ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 70
  if (p_sess->data_use_ssl) {
#line 72
    __cil_tmp = ssl_write((void *)p_sess->p_data_ssl, p_buf, len);
#line 72
    return (__cil_tmp);
  } else {
#line 76
    __cil_tmp___0 = vsf_sysutil_write_loop((int )p_sess->data_fd, (void const   *)p_buf,
                                           len);
#line 76
    return (__cil_tmp___0);
  }
}
}
#line 80 "readwrite.c"
void ftp_getline(struct vsf_session  const  *p_sess , struct mystr *p_str , char *p_buf ) 
{ 

  {
#line 83
  if ((int )p_sess->control_use_ssl && (int )p_sess->ssl_slave_active) {
#line 85
    priv_sock_send_cmd((int )p_sess->ssl_consumer_fd, (char)4);
#line 86
    priv_sock_get_str((int )p_sess->ssl_consumer_fd, p_str);
  } else {
#line 88
    if (p_sess->control_use_ssl) {
#line 90
      ssl_getline(p_sess, p_str, (char )'\n', p_buf, 4096U);
    } else {
#line 94
      str_netfd_alloc(p_str, 0, (char )'\n', p_buf, 4096U);
    }
  }
#line 97
  return;
}
}
#line 1 "cil-F6IXTPdS.o"
#pragma merger(0,"/tmp/cil-YwQBeF8i.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 14 "opts.c"
void handle_opts(struct vsf_session *p_sess ) 
{ int __cil_tmp ;

  {
#line 17
  str_upper(& p_sess->ftp_arg_str);
#line 18
  __cil_tmp = str_equal_text((struct mystr  const  *)(& p_sess->ftp_arg_str), "UTF8 ON");
#line 18
  if (__cil_tmp) {
#line 20
    vsf_cmdio_write(p_sess, 200, "Always in UTF8 mode.");
  } else {
#line 24
    vsf_cmdio_write(p_sess, 501, "Option not understood.");
  }
#line 26
  return;
}
}
#line 1 "cil-c0b7TfCp.o"
#pragma merger(0,"/tmp/cil-bzIaIA4V.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 618 "ssl.c"
void ssl_init(struct vsf_session *p_sess ) 
{ 

  {
#line 622
  die("SSL: ssl_enable is set but SSL support not compiled in");
#line 623
  return;
}
}
#line 625 "ssl.c"
void handle_auth(struct vsf_session *p_sess ) 
{ 

  {
#line 629
  return;
}
}
#line 631 "ssl.c"
void handle_pbsz(struct vsf_session *p_sess ) 
{ 

  {
#line 635
  return;
}
}
#line 637 "ssl.c"
void handle_prot(struct vsf_session *p_sess ) 
{ 

  {
#line 641
  return;
}
}
#line 643 "ssl.c"
void ssl_getline(struct vsf_session  const  *p_sess , struct mystr *p_str , char end_char ,
                 char *p_buf , unsigned int buflen ) 
{ 

  {
#line 652
  return;
}
}
#line 654 "ssl.c"
int ssl_read(struct vsf_session *p_sess , char *p_buf , unsigned int len ) 
{ 

  {
#line 660
  return (-1);
}
}
#line 663 "ssl.c"
int ssl_write(void *p_ssl , char const   *p_buf , unsigned int len ) 
{ 

  {
#line 669
  return (-1);
}
}
#line 672 "ssl.c"
int ssl_write_str(void *p_ssl , struct mystr  const  *p_str ) 
{ 

  {
#line 677
  return (-1);
}
}
#line 680 "ssl.c"
int ssl_accept(struct vsf_session *p_sess , int fd ) 
{ 

  {
#line 685
  return (-1);
}
}
#line 688 "ssl.c"
int ssl_data_close(struct vsf_session *p_sess ) 
{ 

  {
#line 692
  return (1);
}
}
#line 695 "ssl.c"
void ssl_comm_channel_init(struct vsf_session *p_sess ) 
{ 

  {
#line 699
  return;
}
}
#line 1 "cil-FkbP8yUR.o"
#pragma merger(0,"/tmp/cil-0dbkDrDb.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 47 "sysutil.h"
void vsf_sysutil_default_sig(enum EVSFSysUtilSignal sig ) ;
#line 50
void vsf_sysutil_check_pending_actions(enum EVSFSysUtilInterruptContext context ,
                                       int retval , int fd ) ;
#line 98
int vsf_sysutil_write(int fd , void const   *p_buf , unsigned int size ) ;
#line 186
void vsf_sysutil_strcpy(char *p_dest , char const   *p_src , unsigned int maxsize ) ;
#line 235
void const   *vsf_sysutil_sockaddr_ipv4_v6(struct vsf_sysutil_sockaddr  const  *p_addr ) ;
#line 285
int vsf_sysutil_user_getgid(struct vsf_sysutil_user  const  *p_user ) ;
#line 303
void vsf_sysutil_set_exit_func(void (*exitfunc)(void) ) ;
#line 313
void vsf_sysutil_setuid_numeric(int uid ) ;
#line 314
void vsf_sysutil_setgid_numeric(int gid ) ;
#line 185 "../../includes/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 218
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 258 "../../includes/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 425
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 623
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 629
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 650
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 667
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 741
extern  __attribute__((__nothrow__)) int readlink(char const   * __restrict  __path ,
                                                  char * __restrict  __buf , size_t___0 __len )  __attribute__((__nonnull__(1,2))) ;
#line 215 "../../includes/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("_stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("_fstat64") __attribute__((__nonnull__(2))) ;
#line 239
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("_lstat64") __attribute__((__nonnull__(1,2))) ;
#line 256
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 269
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 363
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("_stat64") __attribute__((__nonnull__(1,2))) ;
#line 363 "../../includes/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int __cil_tmp ;

  {
#line 366
  __cil_tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 366
  return (__cil_tmp);
}
}
#line 370
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("_lstat64") __attribute__((__nonnull__(1,2))) ;
#line 370 "../../includes/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int __cil_tmp ;

  {
#line 373
  __cil_tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 373
  return (__cil_tmp);
}
}
#line 377
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("_fstat64") __attribute__((__nonnull__(2))) ;
#line 377 "../../includes/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int __cil_tmp ;

  {
#line 380
  __cil_tmp = __fxstat(3, __fd, __statbuf);
#line 380
  return (__cil_tmp);
}
}
#line 111 "../../includes/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 103 "../../includes/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 115 "../../includes/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 138
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 138 "../../includes/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 59 "sysutil.c"
static unsigned int s_current_umask  ;
#line 61 "sysutil.c"
static struct timeval s_current_time  ;
#line 63 "sysutil.c"
static int s_current_pid  =    -1;
#line 65 "sysutil.c"
static void (*s_exit_func)(void)  ;
#line 67 "sysutil.c"
static long s_timezone  ;
#line 70 "sysutil.c"
struct vsf_sysutil_sig_details s_sig_details[65]  ;
//static struct vsf_sysutil_sig_details s_sig_details[65]  ;
#line 78 "sysutil.c"
static void (*s_io_handler)(int  , int  , void * )  ;
#line 79 "sysutil.c"
static void *s_p_io_handler_private  ;
#line 80 "sysutil.c"
static int s_io_handler_running  ;
#line 93
static void vsf_sysutil_common_sighandler(int signum ) ;
#line 94
static int vsf_sysutil_translate_sig(enum EVSFSysUtilSignal sig ) ;
#line 95
static void vsf_sysutil_set_sighandler(int sig , void (*p_handlefunc)(int  ) ) ;
#line 96
static int vsf_sysutil_translate_memprot(enum EVSFSysUtilMapPermission perm ) ;
#line 98
static int vsf_sysutil_translate_openmode(enum EVSFSysUtilOpenMode mode ) ;
#line 100
static void vsf_sysutil_alloc_statbuf(struct vsf_sysutil_statbuf **p_ptr ) ;
#line 102
static int lock_internal(int fd , int lock_type ) ;
#line 104 "sysutil.c"
static void vsf_sysutil_common_sighandler(int signum ) 
{ 

  {
#line 107
  if (signum < 0 || signum >= 65) {
#line 109
    bug("signal out of range in vsf_sysutil_common_sighandler");
  }
#line 111
  if (s_sig_details[signum].sync_sig_handler) {
#line 113
    s_sig_details[signum].pending = 1;
  }
#line 115
  return;
}
}
#line 129 "sysutil.c"
void vsf_sysutil_check_pending_actions(enum EVSFSysUtilInterruptContext context ,
                                       int retval , int fd ) 
{ unsigned int i ;

  {
#line 135
  if (((int )s_io_handler && ! s_io_handler_running) && (int )context == 1) {
#line 137
    s_io_handler_running = 1;
#line 138
    (*s_io_handler)(retval, fd, s_p_io_handler_private);
#line 139
    s_io_handler_running = 0;
  }
#line 141
  i = 0U;
#line 141
  while (i < 65U) {
#line 143
    if (s_sig_details[i].pending && ! s_sig_details[i].running) {
#line 145
      s_sig_details[i].running = 1;
#line 146
      if (s_sig_details[i].sync_sig_handler) {
#line 148
        s_sig_details[i].pending = 0;
#line 149
        (*(s_sig_details[i].sync_sig_handler))(s_sig_details[i].p_private);
      }
#line 151
      s_sig_details[i].running = 0;
    }
#line 141
    i ++;
  }
#line 154
  return;
}
}
#line 156 "sysutil.c"
static int vsf_sysutil_translate_sig(enum EVSFSysUtilSignal sig ) 
{ int realsig ;

  {
#line 159
  realsig = 0;
#line 160
  switch ((int )sig) {
  case 1: 
#line 163
  realsig = 14;
#line 164
  break;
  case 2: 
#line 166
  realsig = 15;
#line 167
  break;
  case 3: 
#line 169
  realsig = 17;
#line 170
  break;
  case 4: 
#line 172
  realsig = 13;
#line 173
  break;
  case 5: 
#line 175
  realsig = 23;
#line 176
  break;
  case 6: 
#line 178
  realsig = 1;
#line 179
  break;
  default: 
#line 181
  bug("unknown signal in vsf_sysutil_translate_sig");
#line 182
  break;
  }
#line 184
  if (realsig < 0 || realsig >= 65) {
#line 186
    bug("signal out of range in vsf_sysutil_translate_sig");
  }
#line 188
  return (realsig);
}
}
#line 191 "sysutil.c"
void vsf_sysutil_install_sighandler(enum EVSFSysUtilSignal sig , void (*handler)(void * ) ,
                                    void *p_private ) 
{ int realsig ;
  int __cil_tmp ;

  {
#line 195
  __cil_tmp = vsf_sysutil_translate_sig(sig);
#line 195
  realsig = __cil_tmp;
#line 196
  s_sig_details[realsig].p_private = p_private;
#line 197
  s_sig_details[realsig].sync_sig_handler = handler;
#line 198
  vsf_sysutil_set_sighandler(realsig, & vsf_sysutil_common_sighandler);
#line 199
  return;
}
}
#line 201 "sysutil.c"
void vsf_sysutil_default_sig(enum EVSFSysUtilSignal sig ) 
{ int realsig ;
  int __cil_tmp ;

  {
#line 204
  __cil_tmp = vsf_sysutil_translate_sig(sig);
#line 204
  realsig = __cil_tmp;
#line 205
  vsf_sysutil_set_sighandler(realsig, (void (*)(int  ))0);
#line 206
  s_sig_details[realsig].p_private = (void *)0;
#line 207
  s_sig_details[realsig].sync_sig_handler = (void (*)(void * ))((void *)0);
#line 208
  return;
}
}
#line 210 "sysutil.c"
void vsf_sysutil_install_null_sighandler(enum EVSFSysUtilSignal sig ) 
{ int realsig ;
  int __cil_tmp ;

  {
#line 213
  __cil_tmp = vsf_sysutil_translate_sig(sig);
#line 213
  realsig = __cil_tmp;
#line 214
  s_sig_details[realsig].p_private = (void *)0;
#line 215
  s_sig_details[realsig].sync_sig_handler = (void (*)(void * ))((void *)0);
#line 216
  vsf_sysutil_set_sighandler(realsig, & vsf_sysutil_common_sighandler);
#line 217
  return;
}
}
#line 219 "sysutil.c"
void vsf_sysutil_install_async_sighandler(enum EVSFSysUtilSignal sig , void (*handler)(int  ) ) 
{ int realsig ;
  int __cil_tmp ;

  {
#line 223
  __cil_tmp = vsf_sysutil_translate_sig(sig);
#line 223
  realsig = __cil_tmp;
#line 224
  s_sig_details[realsig].p_private = (void *)0;
#line 225
  s_sig_details[realsig].sync_sig_handler = (void (*)(void * ))((void *)0);
#line 226
  vsf_sysutil_block_sig(sig);
#line 227
  vsf_sysutil_set_sighandler(realsig, handler);
#line 228
  return;
}
}
#line 230 "sysutil.c"
static void vsf_sysutil_set_sighandler(int sig , void (*p_handlefunc)(int  ) ) 
{ int retval ;
  struct sigaction sigact ;

  {
#line 235
  vsf_sysutil_memclr((void *)(& sigact), (unsigned int )sizeof(sigact));
#line 236
  sigact.__sigaction_handler.sa_handler = p_handlefunc;
#line 237
  retval = sigfillset(& sigact.sa_mask);
#line 238
  if (retval != 0) {
#line 240
    die("sigfillset");
  }
#line 242
  retval = sigaction(sig, (struct sigaction  const  * __restrict  )(& sigact), (struct sigaction * __restrict  )((void *)0));
#line 243
  if (retval != 0) {
#line 245
    die("sigaction");
  }
#line 247
  return;
}
}
#line 249 "sysutil.c"
void vsf_sysutil_block_sig(enum EVSFSysUtilSignal sig ) 
{ sigset_t sset ;
  int retval ;
  int realsig ;
  int __cil_tmp ;

  {
#line 254
  __cil_tmp = vsf_sysutil_translate_sig(sig);
#line 254
  realsig = __cil_tmp;
#line 255
  retval = sigemptyset(& sset);
#line 256
  if (retval != 0) {
#line 258
    die("sigemptyset");
  }
#line 260
  retval = sigaddset(& sset, realsig);
#line 261
  if (retval != 0) {
#line 263
    die("sigaddset");
  }
#line 265
  retval = sigprocmask(0, (sigset_t const   * __restrict  )(& sset), (sigset_t * __restrict  )((void *)0));
#line 266
  if (retval != 0) {
#line 268
    die("sigprocmask");
  }
#line 270
  return;
}
}
#line 272 "sysutil.c"
void vsf_sysutil_unblock_sig(enum EVSFSysUtilSignal sig ) 
{ sigset_t sset ;
  int retval ;
  int realsig ;
  int __cil_tmp ;

  {
#line 277
  __cil_tmp = vsf_sysutil_translate_sig(sig);
#line 277
  realsig = __cil_tmp;
#line 278
  retval = sigemptyset(& sset);
#line 279
  if (retval != 0) {
#line 281
    die("sigemptyset");
  }
#line 283
  retval = sigaddset(& sset, realsig);
#line 284
  if (retval != 0) {
#line 286
    die("sigaddset");
  }
#line 288
  retval = sigprocmask(1, (sigset_t const   * __restrict  )(& sset), (sigset_t * __restrict  )((void *)0));
#line 289
  if (retval != 0) {
#line 291
    die("sigprocmask");
  }
#line 293
  return;
}
}
#line 294 "sysutil.c"
void vsf_sysutil_install_io_handler(void (*handler)(int  , int  , void * ) , void *p_private ) 
{ 

  {
#line 297
  if ((unsigned int )s_io_handler != (unsigned int )((void *)0)) {
#line 299
    bug("double register of i/o handler");
  }
#line 301
  s_io_handler = handler;
#line 302
  s_p_io_handler_private = p_private;
#line 303
  return;
}
}
#line 305 "sysutil.c"
void vsf_sysutil_uninstall_io_handler(void) 
{ 

  {
#line 308
  if ((unsigned int )s_io_handler == (unsigned int )((void *)0)) {
#line 310
    bug("no i/o handler to unregister!");
  }
#line 312
  s_io_handler = (void (*)(int  , int  , void * ))((void *)0);
#line 313
  s_p_io_handler_private = (void *)0;
#line 314
  return;
}
}
#line 316 "sysutil.c"
void vsf_sysutil_set_alarm(unsigned int trigger_seconds ) 
{ 

  {
#line 319
  alarm(trigger_seconds);
#line 320
  return;
}
}
#line 322 "sysutil.c"
void vsf_sysutil_clear_alarm(void) 
{ 

  {
#line 325
  vsf_sysutil_set_alarm(0U);
#line 326
  return;
}
}
#line 328 "sysutil.c"
int vsf_sysutil_read(int fd , void *p_buf , unsigned int size ) 
{ int retval ;
  ssize_t __cil_tmp ;
  int saved_errno ;
  int *__cil_tmp___0 ;

  {
#line 331
  while (1) {
#line 333
    __cil_tmp = read(fd, p_buf, (unsigned long )size);
#line 333
    retval = __cil_tmp;
#line 334
    __cil_tmp___0 = __errno_location();
#line 334
    saved_errno = *__cil_tmp___0;
#line 335
    vsf_sysutil_check_pending_actions(1, retval, fd);
#line 336
    if (retval < 0 && saved_errno == 4) {
#line 338
      continue;
    }
#line 340
    return (retval);
  }
}
}
#line 344 "sysutil.c"
int vsf_sysutil_write(int fd , void const   *p_buf , unsigned int size ) 
{ int retval ;
  ssize_t __cil_tmp ;
  int saved_errno ;
  int *__cil_tmp___0 ;

  {
#line 347
  while (1) {
#line 349
    __cil_tmp = write(fd, p_buf, (unsigned long )size);
#line 349
    retval = __cil_tmp;
#line 350
    __cil_tmp___0 = __errno_location();
#line 350
    saved_errno = *__cil_tmp___0;
#line 351
    vsf_sysutil_check_pending_actions(1, retval, fd);
#line 352
    if (retval < 0 && saved_errno == 4) {
#line 354
      continue;
    }
#line 356
    return (retval);
  }
}
}
#line 360 "sysutil.c"
int vsf_sysutil_read_loop(int fd , void *p_buf , unsigned int size ) 
{ int retval ;
  int num_read ;

  {
#line 364
  num_read = 0;
#line 365
  if (size > 2147483647U) {
#line 367
    die("size too big in vsf_sysutil_read_loop");
  }
#line 369
  while (1) {
#line 371
    retval = vsf_sysutil_read(fd, (void *)((char *)p_buf + num_read), size);
#line 372
    if (retval < 0) {
#line 374
      return (retval);
    } else {
#line 376
      if (retval == 0) {
#line 379
        return (num_read);
      }
    }
#line 381
    if ((unsigned int )retval > size) {
#line 383
      die("retval too big in vsf_sysutil_read_loop");
    }
#line 385
    num_read += retval;
#line 386
    size -= (unsigned int )retval;
#line 387
    if (size == 0U) {
#line 390
      return (num_read);
    }
  }
}
}
#line 395 "sysutil.c"
int vsf_sysutil_write_loop(int fd , void const   *p_buf , unsigned int size ) 
{ int retval ;
  int num_written ;

  {
#line 399
  num_written = 0;
#line 400
  if (size > 2147483647U) {
#line 402
    die("size too big in vsf_sysutil_write_loop");
  }
#line 404
  while (1) {
#line 406
    retval = vsf_sysutil_write(fd, (void const   *)((char const   *)p_buf + num_written),
                               size);
#line 407
    if (retval < 0) {
#line 410
      return (retval);
    } else {
#line 412
      if (retval == 0) {
#line 415
        return (num_written);
      }
    }
#line 417
    if ((unsigned int )retval > size) {
#line 419
      die("retval too big in vsf_sysutil_read_loop");
    }
#line 421
    num_written += retval;
#line 422
    size -= (unsigned int )retval;
#line 423
    if (size == 0U) {
#line 426
      return (num_written);
    }
  }
}
}
#line 431 "sysutil.c"
filesize_t vsf_sysutil_get_file_offset(int file_fd ) 
{ filesize_t retval ;
  __quad_t __cil_tmp ;

  {
#line 434
  __cil_tmp = lseek(file_fd, 0LL, 1);
#line 434
  retval = __cil_tmp;
#line 435
  if (retval < 0LL) {
#line 437
    die("lseek");
  }
#line 439
  return (retval);
}
}
#line 442 "sysutil.c"
void vsf_sysutil_lseek_to(int fd , filesize_t seek_pos ) 
{ filesize_t retval ;

  {
#line 446
  if (seek_pos < 0LL) {
#line 448
    die("negative seek_pos in vsf_sysutil_lseek_to");
  }
#line 450
  retval = lseek(fd, seek_pos, 0);
#line 451
  if (retval < 0LL) {
#line 453
    die("lseek");
  }
#line 455
  return;
}
}
#line 457 "sysutil.c"
void *vsf_sysutil_malloc(unsigned int size ) 
{ void *p_ret ;

  {
#line 462
  if (size == 0U || size > 2147483647U) {
#line 464
    bug("zero or big size in vsf_sysutil_malloc");
  }
#line 466
  p_ret = malloc((unsigned long )size);
#line 467
  if ((unsigned int )p_ret == (unsigned int )((void *)0)) {
#line 469
    die("malloc");
  }
#line 471
  return (p_ret);
}
}
#line 474 "sysutil.c"
void *vsf_sysutil_realloc(void *p_ptr , unsigned int size ) 
{ void *p_ret ;

  {
#line 478
  if (size == 0U || size > 2147483647U) {
#line 480
    bug("zero or big size in vsf_sysutil_realloc");
  }
#line 482
  p_ret = realloc(p_ptr, (unsigned long )size);
#line 483
  if ((unsigned int )p_ret == (unsigned int )((void *)0)) {
#line 485
    die("realloc");
  }
#line 487
  return (p_ret);
}
}
#line 490 "sysutil.c"
void vsf_sysutil_free(void *p_ptr ) 
{ 

  {
#line 493
  if ((unsigned int )p_ptr == (unsigned int )((void *)0)) {
#line 495
    bug("vsf_sysutil_free got a null pointer");
  }
#line 497
  free(p_ptr);
#line 498
  return;
}
}
#line 500 "sysutil.c"
unsigned int vsf_sysutil_getpid(void) 
{ 

  {
#line 503
  if (s_current_pid == -1) {
#line 505
    s_current_pid = getpid();
  }
#line 507
  return ((unsigned int )s_current_pid);
}
}
#line 510 "sysutil.c"
int vsf_sysutil_fork(void) 
{ void (*curr_func)(void) ;
  int retval ;

  {
#line 514
  curr_func = s_exit_func;
#line 516
  s_exit_func = (void (*)(void))0;
#line 517
  retval = vsf_sysutil_fork_failok();
#line 518
  if (retval != 0) {
#line 520
    s_exit_func = curr_func;
  }
#line 522
  if (retval < 0) {
#line 524
    die("fork");
  }
#line 526
  return (retval);
}
}
#line 529 "sysutil.c"
int vsf_sysutil_fork_failok(void) 
{ int retval ;
  __pid_t __cil_tmp ;

  {
#line 532
  __cil_tmp = fork();
#line 532
  retval = __cil_tmp;
#line 533
  if (retval == 0) {
#line 535
    s_current_pid = -1;
  }
#line 537
  return (retval);
}
}
#line 540 "sysutil.c"
void vsf_sysutil_set_exit_func(void (*exitfunc)(void) ) 
{ 

  {
#line 543
  s_exit_func = exitfunc;
#line 544
  return;
}
}
#line 546 "sysutil.c"
void vsf_sysutil_exit(int exit_code ) 
{ void (*curr_func)(void) ;

  {
#line 549
  if (s_exit_func) {
#line 551
    curr_func = s_exit_func;
#line 553
    s_exit_func = (void (*)(void))0;
#line 554
    (*curr_func)();
  }
#line 556
  _exit(exit_code);
}
}
#line 559 "sysutil.c"
struct vsf_sysutil_wait_retval vsf_sysutil_wait(void) 
{ struct vsf_sysutil_wait_retval retval ;
  int sys_ret ;
  __pid_t __cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 563
  vsf_sysutil_memclr((void *)(& retval), (unsigned int )sizeof(retval));
#line 564
  while (1) {
#line 566
    __cil_tmp = wait((union wait *)(& retval.PRIVATE_HANDS_OFF_exit_status));
#line 566
    sys_ret = __cil_tmp;
#line 567
    if (sys_ret < 0) {
#line 567
      __cil_tmp___0 = __errno_location();
#line 567
      if (*__cil_tmp___0 == 4) {
#line 569
        vsf_sysutil_check_pending_actions(0, 0, 0);
#line 570
        continue;
      } else {
#line 567
        goto _L;
      }
    } else {
      _L: /* CIL Label */ ;
    }
#line 572
    retval.PRIVATE_HANDS_OFF_syscall_retval = sys_ret;
#line 573
    return (retval);
  }
}
}
#line 577 "sysutil.c"
int vsf_sysutil_wait_reap_one(void) 
{ int retval ;
  __pid_t __cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 580
  __cil_tmp = waitpid(-1, (int *)((void *)0), 1);
#line 580
  retval = __cil_tmp;
#line 581
  if (retval == 0) {
#line 581
    goto _L;
  } else {
#line 581
    if (retval < 0) {
#line 581
      __cil_tmp___0 = __errno_location();
#line 581
      if (*__cil_tmp___0 == 10) {
        _L: /* CIL Label */ 
#line 584
        return (0);
      } else {
#line 581
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ ;
    }
  }
#line 586
  if (retval < 0) {
#line 588
    die("waitpid");
  }
#line 591
  return (retval);
}
}
#line 594 "sysutil.c"
int vsf_sysutil_wait_get_retval(struct vsf_sysutil_wait_retval  const  *p_waitret ) 
{ 

  {
#line 597
  return ((int )p_waitret->PRIVATE_HANDS_OFF_syscall_retval);
}
}
#line 600 "sysutil.c"
int vsf_sysutil_wait_exited_normally(struct vsf_sysutil_wait_retval  const  *p_waitret ) 
{ union __anonunion___u_55 __u ;

  {
#line 604
  __u.__in = (int )p_waitret->PRIVATE_HANDS_OFF_exit_status;
#line 604
  return ((__u.__i & 127) == 0);
}
}
#line 607 "sysutil.c"
int vsf_sysutil_wait_get_exitcode(struct vsf_sysutil_wait_retval  const  *p_waitret ) 
{ int __cil_tmp ;
  union __anonunion___u_56 __u ;

  {
#line 610
  __cil_tmp = vsf_sysutil_wait_exited_normally(p_waitret);
#line 610
  if (! __cil_tmp) {
#line 612
    bug("not a normal exit in vsf_sysutil_wait_get_exitcode");
  }
#line 614
  __u.__in = (int )p_waitret->PRIVATE_HANDS_OFF_exit_status;
#line 614
  return ((__u.__i & 65280) >> 8);
}
}
#line 617 "sysutil.c"
void vsf_sysutil_activate_keepalive(int fd ) 
{ int keepalive ;
  int retval ;
  int __cil_tmp ;

  {
#line 620
  keepalive = 1;
#line 621
  __cil_tmp = setsockopt(fd, 1, 9, (void const   *)(& keepalive), (unsigned int )sizeof(keepalive));
#line 621
  retval = __cil_tmp;
#line 623
  if (retval != 0) {
#line 625
    die("setsockopt: keepalive");
  }
#line 627
  return;
}
}
#line 629 "sysutil.c"
void vsf_sysutil_activate_reuseaddr(int fd ) 
{ int reuseaddr ;
  int retval ;
  int __cil_tmp ;

  {
#line 632
  reuseaddr = 1;
#line 633
  __cil_tmp = setsockopt(fd, 1, 2, (void const   *)(& reuseaddr), (unsigned int )sizeof(reuseaddr));
#line 633
  retval = __cil_tmp;
#line 635
  if (retval != 0) {
#line 637
    die("setsockopt: reuseaddr");
  }
#line 639
  return;
}
}
#line 641 "sysutil.c"
void vsf_sysutil_set_nodelay(int fd ) 
{ int nodelay ;
  int retval ;
  int __cil_tmp ;

  {
#line 644
  nodelay = 1;
#line 645
  __cil_tmp = setsockopt(fd, 6, 1, (void const   *)(& nodelay), (unsigned int )sizeof(nodelay));
#line 645
  retval = __cil_tmp;
#line 647
  if (retval != 0) {
#line 649
    die("setsockopt: nodelay");
  }
#line 651
  return;
}
}
#line 653 "sysutil.c"
void vsf_sysutil_activate_sigurg(int fd ) 
{ int retval ;
  __pid_t __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 656
  __cil_tmp = getpid();
#line 656
  __cil_tmp___0 = fcntl(fd, 8, __cil_tmp);
#line 656
  retval = __cil_tmp___0;
#line 657
  if (retval != 0) {
#line 659
    die("fcntl");
  }
#line 661
  return;
}
}
#line 663 "sysutil.c"
void vsf_sysutil_activate_oobinline(int fd ) 
{ int oob_inline ;
  int retval ;
  int __cil_tmp ;

  {
#line 666
  oob_inline = 1;
#line 667
  __cil_tmp = setsockopt(fd, 1, 10, (void const   *)(& oob_inline), (unsigned int )sizeof(oob_inline));
#line 667
  retval = __cil_tmp;
#line 669
  if (retval != 0) {
#line 671
    die("setsockopt: oobinline");
  }
#line 673
  return;
}
}
#line 675 "sysutil.c"
void vsf_sysutil_set_iptos_throughput(int fd ) 
{ int tos ;

  {
#line 678
  tos = 8;
#line 680
  setsockopt(fd, 0, 1, (void const   *)(& tos), (unsigned int )sizeof(tos));
#line 681
  return;
}
}
#line 683 "sysutil.c"
void vsf_sysutil_activate_linger(int fd ) 
{ int retval ;
  struct linger the_linger ;

  {
#line 688
  vsf_sysutil_memclr((void *)(& the_linger), (unsigned int )sizeof(the_linger));
#line 689
  the_linger.l_onoff = 1;
#line 690
  the_linger.l_linger = 32767;
#line 691
  retval = setsockopt(fd, 1, 13, (void const   *)(& the_linger), (unsigned int )sizeof(the_linger));
#line 693
  if (retval != 0) {
#line 695
    die("setsockopt: linger");
  }
#line 697
  return;
}
}
#line 699 "sysutil.c"
void vsf_sysutil_deactivate_linger_failok(int fd ) 
{ struct linger the_linger ;

  {
#line 703
  the_linger.l_onoff = 0;
#line 704
  the_linger.l_linger = 0;
#line 705
  setsockopt(fd, 1, 13, (void const   *)(& the_linger), (unsigned int )sizeof(the_linger));
#line 706
  return;
}
}
#line 708 "sysutil.c"
void vsf_sysutil_activate_noblock(int fd ) 
{ int retval ;
  int curr_flags ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 712
  __cil_tmp = fcntl(fd, 3);
#line 712
  curr_flags = __cil_tmp;
#line 713
  __cil_tmp___0 = vsf_sysutil_retval_is_error(curr_flags);
#line 713
  if (__cil_tmp___0) {
#line 715
    die("fcntl");
  }
#line 717
  curr_flags |= 2048;
#line 718
  retval = fcntl(fd, 4, curr_flags);
#line 719
  if (retval != 0) {
#line 721
    die("fcntl");
  }
#line 723
  return;
}
}
#line 725 "sysutil.c"
void vsf_sysutil_deactivate_noblock(int fd ) 
{ int retval ;
  int curr_flags ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 729
  __cil_tmp = fcntl(fd, 3);
#line 729
  curr_flags = __cil_tmp;
#line 730
  __cil_tmp___0 = vsf_sysutil_retval_is_error(curr_flags);
#line 730
  if (__cil_tmp___0) {
#line 732
    die("fcntl");
  }
#line 734
  curr_flags &= -2049;
#line 735
  retval = fcntl(fd, 4, curr_flags);
#line 736
  if (retval != 0) {
#line 738
    die("fcntl");
  }
#line 740
  return;
}
}
#line 742 "sysutil.c"
int vsf_sysutil_recv_peek(int fd , void *p_buf , unsigned int len ) 
{ int retval ;
  ssize_t __cil_tmp ;
  int saved_errno ;
  int *__cil_tmp___0 ;

  {
#line 745
  while (1) {
#line 747
    __cil_tmp = recv(fd, p_buf, (unsigned long )len, 2);
#line 747
    retval = __cil_tmp;
#line 748
    __cil_tmp___0 = __errno_location();
#line 748
    saved_errno = *__cil_tmp___0;
#line 749
    vsf_sysutil_check_pending_actions(1, retval, fd);
#line 750
    if (retval < 0 && saved_errno == 4) {
#line 752
      continue;
    }
#line 754
    return (retval);
  }
}
}
#line 758 "sysutil.c"
int vsf_sysutil_atoi(char const   *p_str ) 
{ int __cil_tmp ;

  {
#line 761
  __cil_tmp = atoi(p_str);
#line 761
  return (__cil_tmp);
}
}
#line 764 "sysutil.c"
filesize_t vsf_sysutil_a_to_filesize_t(char const   *p_str ) 
{ filesize_t result ;
  filesize_t mult ;
  unsigned int len ;
  unsigned int __cil_tmp ;
  unsigned int i ;
  char the_char ;
  filesize_t val ;

  {
#line 770
  result = (filesize_t )0;
#line 771
  mult = (filesize_t )1;
#line 772
  __cil_tmp = vsf_sysutil_strlen(p_str);
#line 772
  len = __cil_tmp;
#line 775
  if (len > 15U) {
#line 777
    return (0LL);
  }
#line 779
  i = 0U;
#line 779
  while (i < len) {
#line 781
    the_char = (char )*(p_str + (len - (i + 1U)));
#line 783
    if ((int )the_char < 48 || (int )the_char > 57) {
#line 785
      return (0LL);
    }
#line 787
    val = (long long )((int )the_char - 48);
#line 788
    val *= mult;
#line 789
    result += val;
#line 790
    mult *= 10LL;
#line 779
    i ++;
  }
#line 792
  return (result);
}
}
#line 798 "sysutil.c"
static char ulong_buf[32]  ;
#line 795 "sysutil.c"
char const   *vsf_sysutil_ulong_to_str(unsigned long the_ulong ) 
{ 

  {
#line 799
  snprintf((char * __restrict  )(ulong_buf), sizeof(ulong_buf), (char const   * __restrict  )"%lu",
           the_ulong);
#line 800
  return ((char const   *)(ulong_buf));
}
}
#line 806 "sysutil.c"
static char filesize_buf[32]  ;
#line 803 "sysutil.c"
char const   *vsf_sysutil_filesize_t_to_str(filesize_t the_filesize ) 
{ 

  {
#line 807
  if (sizeof(long ) == 8UL) {
#line 810
    snprintf((char * __restrict  )(filesize_buf), sizeof(filesize_buf), (char const   * __restrict  )"%ld",
             (long )the_filesize);
  } else {
#line 815
    snprintf((char * __restrict  )(filesize_buf), sizeof(filesize_buf), (char const   * __restrict  )"%lld",
             the_filesize);
  }
#line 817
  return ((char const   *)(filesize_buf));
}
}
#line 823 "sysutil.c"
static char double_buf[32]  ;
#line 820 "sysutil.c"
char const   *vsf_sysutil_double_to_str(double the_double ) 
{ 

  {
#line 824
  snprintf((char * __restrict  )(double_buf), sizeof(double_buf), (char const   * __restrict  )"%.2f",
           the_double);
#line 825
  return ((char const   *)(double_buf));
}
}
#line 831 "sysutil.c"
static char octal_buf[32]  ;
#line 828 "sysutil.c"
char const   *vsf_sysutil_uint_to_octal(unsigned int the_uint ) 
{ 

  {
#line 832
  if (the_uint == 0U) {
#line 834
    octal_buf[0] = (char )'0';
#line 835
    octal_buf[1] = (char )'\000';
  } else {
#line 839
    snprintf((char * __restrict  )(octal_buf), sizeof(octal_buf), (char const   * __restrict  )"0%o",
             the_uint);
  }
#line 841
  return ((char const   *)(octal_buf));
}
}
#line 844 "sysutil.c"
unsigned int vsf_sysutil_octal_to_uint(char const   *p_str ) 
{ unsigned int result ;
  int seen_non_zero_digit ;
  int digit ;
  unsigned short const   **__cil_tmp ;

  {
#line 848
  result = 0U;
#line 849
  seen_non_zero_digit = 0;
#line 850
  while ((int const   )*p_str != 0) {
#line 852
    digit = (int )*p_str;
#line 853
    __cil_tmp = __ctype_b_loc();
#line 853
    if ((int const   )*(*__cil_tmp + digit) & 2048) {
#line 853
      if (digit > 55) {
        _L: /* CIL Label */ 
#line 855
        break;
      }
    } else {
#line 853
      goto _L;
    }
#line 857
    if (digit != 48) {
#line 859
      seen_non_zero_digit = 1;
    }
#line 861
    if (seen_non_zero_digit) {
#line 863
      result <<= 3;
#line 864
      result += (unsigned int )(digit - 48);
    }
#line 866
    p_str ++;
  }
#line 868
  return (result);
}
}
#line 871 "sysutil.c"
int vsf_sysutil_toupper(int the_char ) 
{ int __cil_tmp ;

  {
#line 874
  __cil_tmp = toupper(the_char);
#line 874
  return (__cil_tmp);
}
}
#line 877 "sysutil.c"
int vsf_sysutil_isspace(int the_char ) 
{ unsigned short const   **__cil_tmp ;

  {
#line 880
  __cil_tmp = __ctype_b_loc();
#line 880
  return ((int )((int const   )*(*__cil_tmp + the_char) & 8192));
}
}
#line 883 "sysutil.c"
int vsf_sysutil_isprint(int the_char ) 
{ unsigned char uc ;
  unsigned short const   **__cil_tmp ;

  {
#line 889
  uc = (unsigned char )the_char;
#line 890
  if ((int )uc <= 31) {
#line 892
    return (0);
  }
#line 894
  if ((int )uc == 177) {
#line 896
    return (0);
  }
#line 898
  if ((int )uc >= 128 && (int )uc <= 159) {
#line 900
    return (0);
  }
#line 902
  __cil_tmp = __ctype_b_loc();
#line 902
  // __EVAL(the_char);
  // __EVAL(__cil_tmp);
  // __EVAL(*__cil_tmp+the_char);
  // __EVAL(*(*__cil_tmp+the_char));
  return ((int )((int const   )*(*__cil_tmp + the_char) & 16384));
}
}
#line 905 "sysutil.c"
int vsf_sysutil_isalnum(int the_char ) 
{ unsigned short const   **__cil_tmp ;

  {
#line 908
  __cil_tmp = __ctype_b_loc();
#line 908
  return ((int )((int const   )*(*__cil_tmp + the_char) & 8));
}
}
#line 911 "sysutil.c"
int vsf_sysutil_isdigit(int the_char ) 
{ unsigned short const   **__cil_tmp ;

  {
#line 914
  __cil_tmp = __ctype_b_loc();
#line 914
  return ((int )((int const   )*(*__cil_tmp + the_char) & 2048));
}
}
#line 917 "sysutil.c"
char *vsf_sysutil_getcwd(char *p_dest , unsigned int buf_size ) 
{ char *p_retval ;

  {
#line 921
  if (buf_size == 0U) {
#line 922
    return (p_dest);
  }
#line 924
  p_retval = getcwd(p_dest, (unsigned long )buf_size);
#line 925
  *(p_dest + (buf_size - 1U)) = (char )'\000';
#line 926
  return (p_retval);
}
}
#line 929 "sysutil.c"
int vsf_sysutil_mkdir(char const   *p_dirname , unsigned int mode ) 
{ int __cil_tmp ;

  {
#line 932
  __cil_tmp = mkdir(p_dirname, mode);
#line 932
  return (__cil_tmp);
}
}
#line 935 "sysutil.c"
int vsf_sysutil_rmdir(char const   *p_dirname ) 
{ int __cil_tmp ;

  {
#line 938
  __cil_tmp = rmdir(p_dirname);
#line 938
  return (__cil_tmp);
}
}
#line 941 "sysutil.c"
int vsf_sysutil_chdir(char const   *p_dirname ) 
{ int __cil_tmp ;

  {
#line 944
  __cil_tmp = chdir(p_dirname);
#line 944
  return (__cil_tmp);
}
}
#line 947 "sysutil.c"
int vsf_sysutil_rename(char const   *p_from , char const   *p_to ) 
{ int __cil_tmp ;

  {
#line 950
  __cil_tmp = rename(p_from, p_to);
#line 950
  return (__cil_tmp);
}
}
#line 953 "sysutil.c"
struct vsf_sysutil_dir *vsf_sysutil_opendir(char const   *p_dirname ) 
{ DIR *__cil_tmp ;

  {
#line 956
  __cil_tmp = opendir(p_dirname);
#line 956
  return ((struct vsf_sysutil_dir *)__cil_tmp);
}
}
#line 959 "sysutil.c"
void vsf_sysutil_closedir(struct vsf_sysutil_dir *p_dir ) 
{ DIR *p_real_dir ;
  int retval ;
  int __cil_tmp ;

  {
#line 962
  p_real_dir = (DIR *)p_dir;
#line 963
  __cil_tmp = closedir(p_real_dir);
#line 963
  retval = __cil_tmp;
#line 964
  if (retval != 0) {
#line 966
    die("closedir");
  }
#line 968
  return;
}
}
#line 970 "sysutil.c"
char const   *vsf_sysutil_next_dirent(struct vsf_sysutil_dir *p_dir ) 
{ DIR *p_real_dir ;
  struct dirent *p_dirent ;
  struct dirent *__cil_tmp ;

  {
#line 973
  p_real_dir = (DIR *)p_dir;
#line 974
  __cil_tmp = readdir(p_real_dir);
#line 974
  p_dirent = __cil_tmp;
#line 975
  if ((unsigned int )p_dirent == (unsigned int )((void *)0)) {
#line 977
    return ((char const   *)((void *)0));
  }
#line 979
  return ((char const   *)(p_dirent->d_name));
}
}
#line 982 "sysutil.c"
unsigned int vsf_sysutil_strlen(char const   *p_text ) 
{ unsigned int ret___0 ;
  size_t___0 __cil_tmp ;

  {
#line 985
  __cil_tmp = strlen(p_text);
#line 985
  ret___0 = (unsigned int )__cil_tmp;
#line 987
  if (ret___0 > 268435455U) {
#line 989
    die("string suspiciously long");
  }
#line 991
  return (ret___0);
}
}
#line 994 "sysutil.c"
char *vsf_sysutil_strdup(char const   *p_str ) 
{ char *__cil_tmp ;

  {
#line 997
  __cil_tmp = strdup(p_str);
#line 997
  return (__cil_tmp);
}
}
#line 1000 "sysutil.c"
void vsf_sysutil_memclr(void *p_dest , unsigned int size ) 
{ 

  {
#line 1004
  if (size == 0U) {
#line 1006
    return;
  }
#line 1008
  memset(p_dest, '\000', (unsigned long )size);
#line 1009
  return;
}
}
#line 1011 "sysutil.c"
void vsf_sysutil_memcpy(void *p_dest , void const   *p_src , unsigned int size ) 
{ 

  {
#line 1015
  if (size == 0U) {
#line 1017
    return;
  }
#line 1020
  if (size > 2147483647U) {
#line 1022
    die("possible negative value to memcpy?");
  }
#line 1024
  memcpy((void * __restrict  )p_dest, (void const   * __restrict  )p_src, (unsigned long )size);
#line 1025
  return;
}
}
#line 1027 "sysutil.c"
void vsf_sysutil_strcpy(char *p_dest , char const   *p_src , unsigned int maxsize ) 
{ 

  {
#line 1030
  if (maxsize == 0U) {
#line 1032
    return;
  }
#line 1034
  strncpy((char * __restrict  )p_dest, (char const   * __restrict  )p_src, (unsigned long )maxsize);
#line 1035
  *(p_dest + (maxsize - 1U)) = (char )'\000';
#line 1036
  return;
}
}
#line 1038 "sysutil.c"
int vsf_sysutil_memcmp(void const   *p_src1 , void const   *p_src2 , unsigned int size ) 
{ int __cil_tmp ;

  {
#line 1042
  if (size == 0U) {
#line 1044
    return (0);
  }
#line 1046
  __cil_tmp = memcmp(p_src1, p_src2, (unsigned long )size);
#line 1046
  return (__cil_tmp);
}
}
#line 1049 "sysutil.c"
int vsf_sysutil_strcmp(char const   *p_src1 , char const   *p_src2 ) 
{ int __cil_tmp ;

  {
#line 1052
  __cil_tmp = strcmp(p_src1, p_src2);
#line 1052
  return (__cil_tmp);
}
}
#line 1058 "sysutil.c"
static unsigned int s_page_size  ;
#line 1055 "sysutil.c"
unsigned int vsf_sysutil_getpagesize(void) 
{ int __cil_tmp ;

  {
#line 1059
  if (s_page_size == 0U) {
#line 1061
    __cil_tmp = getpagesize();
#line 1061
    s_page_size = (unsigned int )__cil_tmp;
#line 1062
    if (s_page_size == 0U) {
#line 1064
      die("getpagesize");
    }
  }
#line 1067
  return (s_page_size);
}
}
#line 1070 "sysutil.c"
static int vsf_sysutil_translate_memprot(enum EVSFSysUtilMapPermission perm ) 
{ int retval ;

  {
#line 1073
  retval = 0;
#line 1074
  switch ((int )perm) {
  case 1: 
#line 1077
  retval = 1;
#line 1078
  break;
  case 2: 
#line 1080
  retval = 0;
#line 1081
  break;
  default: 
#line 1083
  bug("bad value in vsf_sysutil_translate_memprot");
#line 1084
  break;
  }
#line 1086
  return (retval);
}
}
#line 1089 "sysutil.c"
void vsf_sysutil_memprotect(void *p_addr , unsigned int len , enum EVSFSysUtilMapPermission perm ) 
{ int prot ;
  int __cil_tmp ;
  int retval ;
  int __cil_tmp___0 ;

  {
#line 1093
  __cil_tmp = vsf_sysutil_translate_memprot(perm);
#line 1093
  prot = __cil_tmp;
#line 1094
  __cil_tmp___0 = mprotect(p_addr, (unsigned long )len, prot);
#line 1094
  retval = __cil_tmp___0;
#line 1095
  if (retval != 0) {
#line 1097
    die("mprotect");
  }
#line 1099
  return;
}
}
#line 1101 "sysutil.c"
void vsf_sysutil_memunmap(void *p_start , unsigned int length ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 1104
  __cil_tmp = munmap(p_start, (unsigned long )length);
#line 1104
  retval = __cil_tmp;
#line 1105
  if (retval != 0) {
#line 1107
    die("munmap");
  }
#line 1109
  return;
}
}
#line 1111 "sysutil.c"
static int vsf_sysutil_translate_openmode(enum EVSFSysUtilOpenMode mode ) 
{ int retval ;

  {
#line 1114
  retval = 0;
#line 1115
  switch ((int )mode) {
  case 1: 
#line 1118
  retval = 0;
#line 1119
  break;
  case 2: 
#line 1121
  retval = 1;
#line 1122
  break;
  case 3: 
#line 1124
  retval = 2;
#line 1125
  break;
  default: 
#line 1127
  bug("bad mode in vsf_sysutil_translate_openmode");
#line 1128
  break;
  }
#line 1130
  return (retval);
}
}
#line 1133 "sysutil.c"
int vsf_sysutil_open_file(char const   *p_filename , enum EVSFSysUtilOpenMode mode ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 1137
  __cil_tmp = vsf_sysutil_translate_openmode(mode);
#line 1137
  __cil_tmp___0 = open(p_filename, __cil_tmp | 2048);
#line 1137
  return (__cil_tmp___0);
}
}
#line 1140 "sysutil.c"
int vsf_sysutil_create_file(char const   *p_filename ) 
{ int __cil_tmp ;

  {
#line 1144
  __cil_tmp = open(p_filename, 1217, tunable_file_open_mode);
#line 1144
  return (__cil_tmp);
}
}
#line 1148 "sysutil.c"
int vsf_sysutil_create_overwrite_file(char const   *p_filename ) 
{ int __cil_tmp ;

  {
#line 1151
  __cil_tmp = open(p_filename, 3649, tunable_file_open_mode);
#line 1151
  return (__cil_tmp);
}
}
#line 1156 "sysutil.c"
int vsf_sysutil_create_or_open_file(char const   *p_filename , unsigned int mode ) 
{ int __cil_tmp ;

  {
#line 1159
  __cil_tmp = open(p_filename, 3137, mode);
#line 1159
  return (__cil_tmp);
}
}
#line 1162 "sysutil.c"
void vsf_sysutil_dupfd2(int old_fd , int new_fd ) 
{ int retval ;

  {
#line 1166
  if (old_fd == new_fd) {
#line 1168
    return;
  }
#line 1170
  retval = dup2(old_fd, new_fd);
#line 1171
  if (retval != new_fd) {
#line 1173
    die("dup2");
  }
#line 1175
  return;
}
}
#line 1177 "sysutil.c"
void vsf_sysutil_close(int fd ) 
{ int retval ;
  int __cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 1180
  while (1) {
#line 1182
    __cil_tmp = close(fd);
#line 1182
    retval = __cil_tmp;
#line 1183
    if (retval != 0) {
#line 1185
      __cil_tmp___0 = __errno_location();
#line 1185
      if (*__cil_tmp___0 == 4) {
#line 1187
        vsf_sysutil_check_pending_actions(0, 0, 0);
#line 1188
        continue;
      }
#line 1190
      die("close");
    }
#line 1192
    return;
  }
}
}
#line 1196 "sysutil.c"
int vsf_sysutil_close_failok(int fd ) 
{ int __cil_tmp ;

  {
#line 1199
  __cil_tmp = close(fd);
#line 1199
  return (__cil_tmp);
}
}
#line 1202 "sysutil.c"
int vsf_sysutil_unlink(char const   *p_dead ) 
{ int __cil_tmp ;

  {
#line 1205
  __cil_tmp = unlink(p_dead);
#line 1205
  return (__cil_tmp);
}
}
#line 1208 "sysutil.c"
int vsf_sysutil_write_access(char const   *p_filename ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 1211
  __cil_tmp = access(p_filename, 2);
#line 1211
  retval = __cil_tmp;
#line 1212
  return (retval == 0);
}
}
#line 1215 "sysutil.c"
static void vsf_sysutil_alloc_statbuf(struct vsf_sysutil_statbuf **p_ptr ) 
{ void *__cil_tmp ;

  {
#line 1218
  if ((unsigned int )*p_ptr == (unsigned int )((void *)0)) {
#line 1220
    __cil_tmp = vsf_sysutil_malloc((unsigned int )sizeof(struct stat ));
#line 1220
    *p_ptr = (struct vsf_sysutil_statbuf *)__cil_tmp;
  }
#line 1222
  return;
}
}
#line 1224 "sysutil.c"
void vsf_sysutil_fstat(int fd , struct vsf_sysutil_statbuf **p_ptr ) 
{ int retval ;

  {
#line 1228
  vsf_sysutil_alloc_statbuf(p_ptr);
#line 1229
  retval = fstat(fd, (struct stat *)*p_ptr);
#line 1230
  if (retval != 0) {
#line 1232
    die("fstat");
  }
#line 1234
  return;
}
}
#line 1236 "sysutil.c"
int vsf_sysutil_stat(char const   *p_name , struct vsf_sysutil_statbuf **p_ptr ) 
{ int __cil_tmp ;

  {
#line 1239
  vsf_sysutil_alloc_statbuf(p_ptr);
#line 1240
  __cil_tmp = stat((char const   * __restrict  )p_name, (struct stat * __restrict  )((struct stat *)*p_ptr));
#line 1240
  return (__cil_tmp);
}
}
#line 1243 "sysutil.c"
int vsf_sysutil_lstat(char const   *p_name , struct vsf_sysutil_statbuf **p_ptr ) 
{ int __cil_tmp ;

  {
#line 1246
  vsf_sysutil_alloc_statbuf(p_ptr);
#line 1247
  __cil_tmp = lstat((char const   * __restrict  )p_name, (struct stat * __restrict  )((struct stat *)*p_ptr));
#line 1247
  return (__cil_tmp);
}
}
#line 1250 "sysutil.c"
void vsf_sysutil_dir_stat(struct vsf_sysutil_dir  const  *p_dir , struct vsf_sysutil_statbuf **p_ptr ) 
{ int fd ;
  int __cil_tmp ;

  {
#line 1254
  __cil_tmp = dirfd((DIR *)p_dir);
#line 1254
  fd = __cil_tmp;
#line 1255
  vsf_sysutil_fstat(fd, p_ptr);
#line 1256
  return;
}
}
#line 1258 "sysutil.c"
int vsf_sysutil_statbuf_is_regfile(struct vsf_sysutil_statbuf  const  *p_stat ) 
{ struct stat  const  *p_realstat ;

  {
#line 1261
  p_realstat = (struct stat  const  *)p_stat;
#line 1262
  return ((p_realstat->st_mode & 61440U) == 32768U);
}
}
#line 1265 "sysutil.c"
int vsf_sysutil_statbuf_is_symlink(struct vsf_sysutil_statbuf  const  *p_stat ) 
{ struct stat  const  *p_realstat ;

  {
#line 1268
  p_realstat = (struct stat  const  *)p_stat;
#line 1269
  return ((p_realstat->st_mode & 61440U) == 40960U);
}
}
#line 1272 "sysutil.c"
int vsf_sysutil_statbuf_is_socket(struct vsf_sysutil_statbuf  const  *p_stat ) 
{ struct stat  const  *p_realstat ;

  {
#line 1275
  p_realstat = (struct stat  const  *)p_stat;
#line 1276
  return ((p_realstat->st_mode & 61440U) == 49152U);
}
}
#line 1279 "sysutil.c"
int vsf_sysutil_statbuf_is_dir(struct vsf_sysutil_statbuf  const  *p_stat ) 
{ struct stat  const  *p_realstat ;

  {
#line 1282
  p_realstat = (struct stat  const  *)p_stat;
#line 1283
  return ((p_realstat->st_mode & 61440U) == 16384U);
}
}
#line 1289 "sysutil.c"
static char perms[11]  ;
#line 1286 "sysutil.c"
char const   *vsf_sysutil_statbuf_get_perms(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) 
{ int i ;
  struct stat  const  *p_stat ;

  {
#line 1291
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1292
  i = 0;
#line 1292
  while (i < 10) {
#line 1294
    perms[i] = (char )'-';
#line 1292
    i ++;
  }
#line 1296
  perms[0] = (char )'?';
#line 1297
  switch ((int )(p_stat->st_mode & 61440U)) {
  case 32768: 
#line 1299
  perms[0] = (char )'-';
#line 1299
  break;
  case 16384: 
#line 1300
  perms[0] = (char )'d';
#line 1300
  break;
  case 40960: 
#line 1301
  perms[0] = (char )'l';
#line 1301
  break;
  case 4096: 
#line 1302
  perms[0] = (char )'p';
#line 1302
  break;
  case 49152: 
#line 1303
  perms[0] = (char )'s';
#line 1303
  break;
  case 8192: 
#line 1304
  perms[0] = (char )'c';
#line 1304
  break;
  case 24576: 
#line 1305
  perms[0] = (char )'b';
#line 1305
  break;
  }
#line 1307
  if (p_stat->st_mode & 256U) {
#line 1307
    perms[1] = (char )'r';
  }
#line 1308
  if (p_stat->st_mode & 128U) {
#line 1308
    perms[2] = (char )'w';
  }
#line 1309
  if (p_stat->st_mode & 64U) {
#line 1309
    perms[3] = (char )'x';
  }
#line 1310
  if (p_stat->st_mode & (unsigned int const   )(256 >> 3)) {
#line 1310
    perms[4] = (char )'r';
  }
#line 1311
  if (p_stat->st_mode & (unsigned int const   )(128 >> 3)) {
#line 1311
    perms[5] = (char )'w';
  }
#line 1312
  if (p_stat->st_mode & (unsigned int const   )(64 >> 3)) {
#line 1312
    perms[6] = (char )'x';
  }
#line 1313
  if (p_stat->st_mode & (unsigned int const   )((256 >> 3) >> 3)) {
#line 1313
    perms[7] = (char )'r';
  }
#line 1314
  if (p_stat->st_mode & (unsigned int const   )((128 >> 3) >> 3)) {
#line 1314
    perms[8] = (char )'w';
  }
#line 1315
  if (p_stat->st_mode & (unsigned int const   )((64 >> 3) >> 3)) {
#line 1315
    perms[9] = (char )'x';
  }
#line 1316
  if (p_stat->st_mode & 2048U) {
#line 1316
    if ((int )perms[3] == 120) {
#line 1316
      perms[3] = (char )'s';
    } else {
#line 1316
      perms[3] = (char )'S';
    }
  }
#line 1317
  if (p_stat->st_mode & 1024U) {
#line 1317
    if ((int )perms[6] == 120) {
#line 1317
      perms[6] = (char )'s';
    } else {
#line 1317
      perms[6] = (char )'S';
    }
  }
#line 1318
  if (p_stat->st_mode & 512U) {
#line 1318
    if ((int )perms[9] == 120) {
#line 1318
      perms[9] = (char )'t';
    } else {
#line 1318
      perms[9] = (char )'T';
    }
  }
#line 1319
  perms[10] = (char )'\000';
#line 1320
  return ((char const   *)(perms));
}
}
#line 1327 "sysutil.c"
static char datebuf[64]  ;
#line 1323 "sysutil.c"
char const   *vsf_sysutil_statbuf_get_date(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ,
                                           int use_localtime ) 
{ int retval ;
  struct tm *p_tm ;
  struct stat  const  *p_stat ;
  long local_time ;
  long __cil_tmp ;
  char const   *p_date_format ;
  size_t___0 __cil_tmp___0 ;

  {
#line 1330
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1331
  __cil_tmp = vsf_sysutil_get_cached_time_sec();
#line 1331
  local_time = __cil_tmp;
#line 1332
  p_date_format = "%b %d %H:%M";
#line 1333
  if (! use_localtime) {
#line 1335
    p_tm = gmtime(& p_stat->st_mtim.tv_sec);
  } else {
#line 1339
    p_tm = localtime(& p_stat->st_mtim.tv_sec);
  }
#line 1342
  if (p_stat->st_mtim.tv_sec > (__time_t const   )local_time || local_time - (long )p_stat->st_mtim.tv_sec > 15724800L) {
#line 1345
    p_date_format = "%b %d  %Y";
  }
#line 1347
  __cil_tmp___0 = strftime((char * __restrict  )(datebuf), sizeof(datebuf), (char const   * __restrict  )p_date_format,
                           (struct tm  const  * __restrict  )p_tm);
#line 1347
  retval = (int )__cil_tmp___0;
#line 1348
  datebuf[sizeof(datebuf) - 1UL] = (char )'\000';
#line 1349
  if (retval == 0) {
#line 1351
    die("strftime");
  }
#line 1353
  return ((char const   *)(datebuf));
}
}
#line 1361 "sysutil.c"
static char datebuf___0[15]  ;
#line 1356 "sysutil.c"
char const   *vsf_sysutil_statbuf_get_numeric_date(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ,
                                                   int use_localtime ) 
{ struct stat  const  *p_stat ;
  struct tm *p_tm ;
  int retval ;
  size_t___0 __cil_tmp ;

  {
#line 1362
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1365
  if (! use_localtime) {
#line 1367
    p_tm = gmtime(& p_stat->st_mtim.tv_sec);
  } else {
#line 1371
    p_tm = localtime(& p_stat->st_mtim.tv_sec);
  }
#line 1373
  __cil_tmp = strftime((char * __restrict  )(datebuf___0), sizeof(datebuf___0), (char const   * __restrict  )"%Y%m%d%H%M%S",
                       (struct tm  const  * __restrict  )p_tm);
#line 1373
  retval = (int )__cil_tmp;
#line 1374
  if (retval == 0) {
#line 1376
    die("strftime");
  }
#line 1378
  return ((char const   *)(datebuf___0));
}
}
#line 1381 "sysutil.c"
filesize_t vsf_sysutil_statbuf_get_size(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) 
{ struct stat  const  *p_stat ;

  {
#line 1384
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1385
  if (p_stat->st_size < 0LL) {
#line 1387
    die("invalid inode size in vsf_sysutil_statbuf_get_size");
  }
#line 1389
  return ((long long )p_stat->st_size);
}
}
#line 1392 "sysutil.c"
int vsf_sysutil_statbuf_get_uid(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) 
{ struct stat  const  *p_stat ;

  {
#line 1395
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1396
  return ((int )p_stat->st_uid);
}
}
#line 1399 "sysutil.c"
int vsf_sysutil_statbuf_get_gid(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) 
{ struct stat  const  *p_stat ;

  {
#line 1402
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1403
  return ((int )p_stat->st_gid);
}
}
#line 1406 "sysutil.c"
unsigned int vsf_sysutil_statbuf_get_links(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) 
{ struct stat  const  *p_stat ;

  {
#line 1409
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1410
  return ((unsigned int )p_stat->st_nlink);
}
}
#line 1413 "sysutil.c"
int vsf_sysutil_statbuf_is_readable_other(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) 
{ struct stat  const  *p_stat ;

  {
#line 1417
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1418
  if (p_stat->st_mode & (unsigned int const   )((256 >> 3) >> 3)) {
#line 1420
    return (1);
  }
#line 1422
  return (0);
}
}
#line 1429 "sysutil.c"
static char intbuf[32]  ;
#line 1425 "sysutil.c"
char const   *vsf_sysutil_statbuf_get_sortkey_mtime(struct vsf_sysutil_statbuf  const  *p_statbuf___0 ) 
{ struct stat  const  *p_stat ;

  {
#line 1430
  p_stat = (struct stat  const  *)p_statbuf___0;
#line 1435
  snprintf((char * __restrict  )(intbuf), sizeof(intbuf), (char const   * __restrict  )"%030ld",
           (long )p_stat->st_mtim.tv_sec);
#line 1436
  return ((char const   *)(intbuf));
}
}
#line 1439 "sysutil.c"
void vsf_sysutil_fchown(int fd , int uid , int gid ) 
{ int __cil_tmp ;

  {
#line 1442
  __cil_tmp = fchown(fd, (unsigned int )uid, (unsigned int )gid);
#line 1442
  if (__cil_tmp != 0) {
#line 1444
    die("fchown");
  }
#line 1446
  return;
}
}
#line 1448 "sysutil.c"
void vsf_sysutil_fchmod(int fd , unsigned int mode ) 
{ int __cil_tmp ;

  {
#line 1451
  mode &= 511U;
#line 1452
  __cil_tmp = fchmod(fd, mode);
#line 1452
  if (__cil_tmp) {
#line 1454
    die("fchmod");
  }
#line 1456
  return;
}
}
#line 1458 "sysutil.c"
int vsf_sysutil_chmod(char const   *p_filename , unsigned int mode ) 
{ int __cil_tmp ;

  {
#line 1462
  mode &= 511U;
#line 1463
  __cil_tmp = chmod(p_filename, mode);
#line 1463
  return (__cil_tmp);
}
}
#line 1466 "sysutil.c"
int vsf_sysutil_lock_file_write(int fd ) 
{ int __cil_tmp ;

  {
#line 1469
  __cil_tmp = lock_internal(fd, 1);
#line 1469
  return (__cil_tmp);
}
}
#line 1472 "sysutil.c"
int vsf_sysutil_lock_file_read(int fd ) 
{ int __cil_tmp ;

  {
#line 1475
  __cil_tmp = lock_internal(fd, 0);
#line 1475
  return (__cil_tmp);
}
}
#line 1478 "sysutil.c"
static int lock_internal(int fd , int lock_type ) 
{ struct flock the_lock ;
  int retval ;
  int saved_errno ;
  int *__cil_tmp ;

  {
#line 1484
  vsf_sysutil_memclr((void *)(& the_lock), (unsigned int )sizeof(the_lock));
#line 1485
  the_lock.l_type = (short )lock_type;
#line 1486
  the_lock.l_whence = (short)0;
#line 1487
  the_lock.l_start = 0LL;
#line 1488
  the_lock.l_len = 0LL;
#line 1489
  while (1) {
#line 1491
    retval = fcntl(fd, 14, & the_lock);
#line 1492
    __cil_tmp = __errno_location();
#line 1492
    saved_errno = *__cil_tmp;
#line 1493
    vsf_sysutil_check_pending_actions(0, 0, 0);
#line 1489
    if (! (retval < 0 && saved_errno == 4)) {
#line 1489
      break;
    }
  }
#line 1496
  return (retval);
}
}
#line 1499 "sysutil.c"
void vsf_sysutil_unlock_file(int fd ) 
{ int retval ;
  struct flock the_lock ;

  {
#line 1504
  vsf_sysutil_memclr((void *)(& the_lock), (unsigned int )sizeof(the_lock));
#line 1505
  the_lock.l_type = (short)2;
#line 1506
  the_lock.l_whence = (short)0;
#line 1507
  the_lock.l_start = 0LL;
#line 1508
  the_lock.l_len = 0LL;
#line 1509
  retval = fcntl(fd, 13, & the_lock);
#line 1510
  if (retval != 0) {
#line 1512
    die("fcntl");
  }
#line 1514
  return;
}
}
#line 1516 "sysutil.c"
int vsf_sysutil_readlink(char const   *p_filename , char *p_dest , unsigned int bufsiz ) 
{ int retval ;

  {
#line 1520
  if (bufsiz == 0U) {
#line 1521
    return (-1);
  }
#line 1523
  retval = readlink((char const   * __restrict  )p_filename, (char * __restrict  )p_dest,
                    (unsigned long )(bufsiz - 1U));
#line 1524
  if (retval < 0) {
#line 1526
    return (retval);
  }
#line 1529
  *(p_dest + retval) = (char )'\000';
#line 1530
  return (retval);
}
}
#line 1533 "sysutil.c"
int vsf_sysutil_retval_is_error(int retval ) 
{ 

  {
#line 1536
  if (retval < 0) {
#line 1538
    return (1);
  }
#line 1540
  return (0);
}
}
#line 1543 "sysutil.c"
enum EVSFSysUtilError vsf_sysutil_get_error(void) 
{ enum EVSFSysUtilError retval ;
  int *__cil_tmp ;

  {
#line 1546
  retval = 1;
#line 1547
  __cil_tmp = __errno_location();
#line 1547
  switch (*__cil_tmp) {
  case 98: 
#line 1550
  retval = 2;
#line 1551
  break;
  case 38: 
#line 1553
  retval = 3;
#line 1554
  break;
  case 4: 
#line 1556
  retval = 4;
#line 1557
  break;
  case 22: 
#line 1559
  retval = 5;
#line 1560
  break;
  case 95: 
#line 1562
  retval = 6;
#line 1563
  break;
  }
#line 1565
  return (retval);
}
}
#line 1568 "sysutil.c"
int vsf_sysutil_get_ipv4_sock(void) 
{ int retval ;
  int __cil_tmp ;

  {
#line 1571
  __cil_tmp = socket(2, 1, 6);
#line 1571
  retval = __cil_tmp;
#line 1572
  if (retval < 0) {
#line 1574
    die("socket");
  }
#line 1576
  return (retval);
}
}
#line 1579 "sysutil.c"
int vsf_sysutil_get_ipv6_sock(void) 
{ int retval ;
  int __cil_tmp ;

  {
#line 1582
  __cil_tmp = socket(10, 1, 6);
#line 1582
  retval = __cil_tmp;
#line 1583
  if (retval < 0) {
#line 1585
    die("socket");
  }
#line 1587
  return (retval);
}
}
#line 1590 "sysutil.c"
struct vsf_sysutil_socketpair_retval vsf_sysutil_unix_stream_socketpair(void) 
{ struct vsf_sysutil_socketpair_retval retval ;
  int the_sockets[2] ;
  int sys_retval ;
  int __cil_tmp ;

  {
#line 1595
  __cil_tmp = socketpair(1, 1, 0, (int *)(the_sockets));
#line 1595
  sys_retval = __cil_tmp;
#line 1596
  if (sys_retval != 0) {
#line 1598
    die("socketpair");
  }
#line 1600
  retval.socket_one = the_sockets[0];
#line 1601
  retval.socket_two = the_sockets[1];
#line 1602
  return (retval);
}
}
#line 1605 "sysutil.c"
int vsf_sysutil_bind(int fd , struct vsf_sysutil_sockaddr  const  *p_sockptr ) 
{ struct sockaddr  const  *p_sockaddr___0 ;
  int len ;
  int __cil_tmp ;

  {
#line 1608
  p_sockaddr___0 = & p_sockptr->u.u_sockaddr;
#line 1609
  len = 0;
#line 1610
  if ((int const   )p_sockaddr___0->sa_family == 2) {
#line 1612
    len = (int )sizeof(struct sockaddr_in );
  } else {
#line 1614
    if ((int const   )p_sockaddr___0->sa_family == 10) {
#line 1616
      len = (int )sizeof(struct sockaddr_in6 );
    } else {
#line 1620
      die("can only support ipv4 and ipv6 currently");
    }
  }
#line 1622
  __cil_tmp = bind(fd, p_sockaddr___0, (unsigned int )len);
#line 1622
  return (__cil_tmp);
}
}
#line 1625 "sysutil.c"
int vsf_sysutil_listen(int fd , unsigned int backlog ) 
{ int retval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;
  enum EVSFSysUtilError __cil_tmp___1 ;

  {
#line 1628
  __cil_tmp = listen(fd, (int )backlog);
#line 1628
  retval = __cil_tmp;
#line 1629
  __cil_tmp___0 = vsf_sysutil_retval_is_error(retval);
#line 1629
  if (__cil_tmp___0) {
#line 1629
    __cil_tmp___1 = vsf_sysutil_get_error();
#line 1629
    if ((int )__cil_tmp___1 != 2) {
#line 1632
      die("listen");
    } else {
#line 1629
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1634
  return (retval);
}
}
#line 1640 "sysutil.c"
int vsf_sysutil_accept_timeout(int fd , struct vsf_sysutil_sockaddr *p_sockaddr___0 ,
                               unsigned int wait_seconds ) 
{ struct vsf_sysutil_sockaddr remote_addr ;
  int retval ;
  int saved_errno ;
  fd_set accept_fdset ;
  struct timeval timeout ;
  unsigned int socklen ;
  int __d0 ;
  int __d1 ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;

  {
#line 1649
  socklen = (unsigned int )sizeof(remote_addr);
#line 1650
  if (p_sockaddr___0) {
#line 1652
    vsf_sysutil_memclr((void *)p_sockaddr___0, (unsigned int )sizeof(*p_sockaddr___0));
  }
#line 1654
  if (wait_seconds > 0U) {
#line 1656
    while (1) {
#line 1656
      __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& accept_fdset.__fds_bits[0]): "memory");
#line 1656
      break;
    }
#line 1657
    __asm__  volatile   ("btsl %1,%0": "=m" (accept_fdset.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                         "memory");
#line 1658
    timeout.tv_sec = (long )wait_seconds;
#line 1659
    timeout.tv_usec = 0L;
#line 1660
    while (1) {
#line 1662
      retval = select(fd + 1, (fd_set * __restrict  )(& accept_fdset), (fd_set * __restrict  )((void *)0),
                      (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
#line 1663
      __cil_tmp = __errno_location();
#line 1663
      saved_errno = *__cil_tmp;
#line 1664
      vsf_sysutil_check_pending_actions(0, 0, 0);
#line 1660
      if (! (retval < 0 && saved_errno == 4)) {
#line 1660
        break;
      }
    }
#line 1666
    if (retval == 0) {
#line 1668
      __cil_tmp___0 = __errno_location();
#line 1668
      *__cil_tmp___0 = 11;
#line 1669
      return (-1);
    }
  }
#line 1672
  retval = accept(fd, (struct sockaddr * __restrict  )(& remote_addr.u.u_sockaddr),
                  (socklen_t * __restrict  )(& socklen));
#line 1673
  vsf_sysutil_check_pending_actions(0, 0, 0);
#line 1674
  if (retval < 0) {
#line 1676
    return (retval);
  }
#line 1679
  if (socklen == 0U) {
#line 1681
    return (-1);
  }
#line 1683
  if ((int )remote_addr.u.u_sockaddr.sa_family != 2 && (int )remote_addr.u.u_sockaddr.sa_family != 10) {
#line 1686
    die("can only support ipv4 and ipv6 currently");
  }
#line 1688
  if (p_sockaddr___0) {
#line 1690
    if ((int )remote_addr.u.u_sockaddr.sa_family == 2) {
#line 1692
      vsf_sysutil_memclr((void *)(& remote_addr.u.u_sockaddr_in.sin_zero), (unsigned int )sizeof(remote_addr.u.u_sockaddr_in.sin_zero));
#line 1694
      vsf_sysutil_memcpy((void *)p_sockaddr___0, (void const   *)(& remote_addr.u.u_sockaddr_in),
                         (unsigned int )sizeof(remote_addr.u.u_sockaddr_in));
    } else {
#line 1699
      vsf_sysutil_memcpy((void *)p_sockaddr___0, (void const   *)(& remote_addr.u.u_sockaddr_in6),
                         (unsigned int )sizeof(remote_addr.u.u_sockaddr_in6));
    }
  }
#line 1703
  return (retval);
}
}
#line 1706 "sysutil.c"
int vsf_sysutil_connect_timeout(int fd , struct vsf_sysutil_sockaddr  const  *p_addr ,
                                unsigned int wait_seconds ) 
{ struct sockaddr  const  *p_sockaddr___0 ;
  unsigned int addrlen ;
  int retval ;
  int saved_errno ;
  fd_set connect_fdset ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int *__cil_tmp ;
  int *__cil_tmp___0 ;
  socklen_t socklen ;
  int sockoptret ;
  int __cil_tmp___1 ;
  int *__cil_tmp___2 ;

  {
#line 1710
  p_sockaddr___0 = & p_addr->u.u_sockaddr;
#line 1711
  addrlen = 0U;
#line 1714
  if ((int const   )p_sockaddr___0->sa_family == 2) {
#line 1716
    addrlen = (unsigned int )sizeof(p_addr->u.u_sockaddr_in);
  } else {
#line 1718
    if ((int const   )p_sockaddr___0->sa_family == 10) {
#line 1720
      addrlen = (unsigned int )sizeof(p_addr->u.u_sockaddr_in6);
    } else {
#line 1724
      die("can only support ipv4 and ipv6 currently");
    }
  }
#line 1726
  if (wait_seconds > 0U) {
#line 1728
    vsf_sysutil_activate_noblock(fd);
  }
#line 1730
  retval = connect(fd, p_sockaddr___0, addrlen);
#line 1731
  if (retval < 0) {
#line 1731
    __cil_tmp___2 = __errno_location();
#line 1731
    if (*__cil_tmp___2 == 115) {
#line 1735
      while (1) {
#line 1735
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& connect_fdset.__fds_bits[0]): "memory");
#line 1735
        break;
      }
#line 1736
      __asm__  volatile   ("btsl %1,%0": "=m" (connect_fdset.__fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 1737
      timeout.tv_sec = (long )wait_seconds;
#line 1738
      timeout.tv_usec = 0L;
#line 1739
      while (1) {
#line 1741
        retval = select(fd + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& connect_fdset),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
#line 1742
        __cil_tmp = __errno_location();
#line 1742
        saved_errno = *__cil_tmp;
#line 1743
        vsf_sysutil_check_pending_actions(0, 0, 0);
#line 1739
        if (! (retval < 0 && saved_errno == 4)) {
#line 1739
          break;
        }
      }
#line 1746
      if (retval == 0) {
#line 1748
        retval = -1;
#line 1749
        __cil_tmp___0 = __errno_location();
#line 1749
        *__cil_tmp___0 = 11;
      } else {
#line 1753
        socklen = (socklen_t )sizeof(retval);
#line 1754
        __cil_tmp___1 = getsockopt(fd, 1, 4, (void * __restrict  )(& retval), (socklen_t * __restrict  )(& socklen));
#line 1754
        sockoptret = __cil_tmp___1;
#line 1755
        if (sockoptret != 0) {
#line 1757
          die("getsockopt");
        }
      }
    } else {
#line 1731
      goto _L;
    }
  } else {
    _L: /* CIL Label */ ;
  }
#line 1761
  if (wait_seconds > 0U) {
#line 1763
    vsf_sysutil_deactivate_noblock(fd);
  }
#line 1765
  return (retval);
}
}
#line 1768 "sysutil.c"
void vsf_sysutil_getsockname(int fd , struct vsf_sysutil_sockaddr **p_sockptr ) 
{ struct vsf_sysutil_sockaddr the_addr ;
  int retval ;
  unsigned int socklen ;

  {
#line 1773
  socklen = (unsigned int )sizeof(the_addr);
#line 1774
  vsf_sysutil_sockaddr_clear(p_sockptr);
#line 1775
  retval = getsockname(fd, (struct sockaddr * __restrict  )(& the_addr.u.u_sockaddr),
                       (socklen_t * __restrict  )(& socklen));
#line 1776
  if (retval != 0) {
#line 1778
    die("getsockname");
  }
#line 1780
  if ((int )the_addr.u.u_sockaddr.sa_family != 2 && (int )the_addr.u.u_sockaddr.sa_family != 10) {
#line 1783
    die("can only support ipv4 and ipv6 currently");
  }
#line 1785
  vsf_sysutil_sockaddr_alloc(p_sockptr);
#line 1786
  if ((unsigned long )socklen > sizeof(the_addr)) {
#line 1788
    socklen = (unsigned int )sizeof(the_addr);
  }
#line 1790
  vsf_sysutil_memcpy((void *)*p_sockptr, (void const   *)(& the_addr), socklen);
#line 1791
  return;
}
}
#line 1793 "sysutil.c"
void vsf_sysutil_getpeername(int fd , struct vsf_sysutil_sockaddr **p_sockptr ) 
{ struct vsf_sysutil_sockaddr the_addr ;
  int retval ;
  unsigned int socklen ;

  {
#line 1798
  socklen = (unsigned int )sizeof(the_addr);
#line 1799
  vsf_sysutil_sockaddr_clear(p_sockptr);
#line 1800
  retval = getpeername(fd, (struct sockaddr * __restrict  )(& the_addr.u.u_sockaddr),
                       (socklen_t * __restrict  )(& socklen));
#line 1801
  if (retval != 0) {
#line 1803
    die("getpeername");
  }
#line 1805
  if ((int )the_addr.u.u_sockaddr.sa_family != 2 && (int )the_addr.u.u_sockaddr.sa_family != 10) {
#line 1808
    die("can only support ipv4 and ipv6 currently");
  }
#line 1810
  vsf_sysutil_sockaddr_alloc(p_sockptr);
#line 1811
  if ((unsigned long )socklen > sizeof(the_addr)) {
#line 1813
    socklen = (unsigned int )sizeof(the_addr);
  }
#line 1815
  vsf_sysutil_memcpy((void *)*p_sockptr, (void const   *)(& the_addr), socklen);
#line 1816
  return;
}
}
#line 1818 "sysutil.c"
void vsf_sysutil_shutdown_failok(int fd ) 
{ 

  {
#line 1825
  shutdown(fd, 2);
#line 1826
  return;
}
}
#line 1828 "sysutil.c"
void vsf_sysutil_shutdown_read_failok(int fd ) 
{ 

  {
#line 1835
  shutdown(fd, 0);
#line 1836
  return;
}
}
#line 1838 "sysutil.c"
void vsf_sysutil_sockaddr_clear(struct vsf_sysutil_sockaddr **p_sockptr ) 
{ 

  {
#line 1841
  if ((unsigned int )*p_sockptr != (unsigned int )((void *)0)) {
#line 1843
    vsf_sysutil_free((void *)*p_sockptr);
#line 1844
    *p_sockptr = (struct vsf_sysutil_sockaddr *)((void *)0);
  }
#line 1846
  return;
}
}
#line 1848 "sysutil.c"
void vsf_sysutil_sockaddr_alloc(struct vsf_sysutil_sockaddr **p_sockptr ) 
{ void *__cil_tmp ;

  {
#line 1851
  vsf_sysutil_sockaddr_clear(p_sockptr);
#line 1852
  __cil_tmp = vsf_sysutil_malloc((unsigned int )sizeof(*(*p_sockptr)));
#line 1852
  *p_sockptr = (struct vsf_sysutil_sockaddr *)__cil_tmp;
#line 1853
  vsf_sysutil_memclr((void *)*p_sockptr, (unsigned int )sizeof(*(*p_sockptr)));
#line 1854
  return;
}
}
#line 1856 "sysutil.c"
void vsf_sysutil_sockaddr_alloc_ipv4(struct vsf_sysutil_sockaddr **p_sockptr ) 
{ 

  {
#line 1859
  vsf_sysutil_sockaddr_alloc(p_sockptr);
#line 1860
  (*p_sockptr)->u.u_sockaddr.sa_family = (unsigned short)2;
#line 1861
  return;
}
}
#line 1863 "sysutil.c"
void vsf_sysutil_sockaddr_alloc_ipv6(struct vsf_sysutil_sockaddr **p_sockptr ) 
{ 

  {
#line 1866
  vsf_sysutil_sockaddr_alloc(p_sockptr);
#line 1867
  (*p_sockptr)->u.u_sockaddr.sa_family = (unsigned short)10;
#line 1868
  return;
}
}
#line 1870 "sysutil.c"
void vsf_sysutil_sockaddr_clone(struct vsf_sysutil_sockaddr **p_sockptr , struct vsf_sysutil_sockaddr  const  *p_src ) 
{ struct vsf_sysutil_sockaddr *p_sockaddr___0 ;

  {
#line 1874
  p_sockaddr___0 = (struct vsf_sysutil_sockaddr *)0;
#line 1875
  vsf_sysutil_sockaddr_alloc(p_sockptr);
#line 1876
  p_sockaddr___0 = *p_sockptr;
#line 1877
  if ((int const   )p_src->u.u_sockaddr.sa_family == 2) {
#line 1879
    p_sockaddr___0->u.u_sockaddr.sa_family = (unsigned short)2;
#line 1880
    vsf_sysutil_memcpy((void *)(& p_sockaddr___0->u.u_sockaddr_in.sin_addr), (void const   *)(& p_src->u.u_sockaddr_in.sin_addr),
                       (unsigned int )sizeof(p_sockaddr___0->u.u_sockaddr_in.sin_addr));
  } else {
#line 1884
    if ((int const   )p_src->u.u_sockaddr.sa_family == 10) {
#line 1886
      p_sockaddr___0->u.u_sockaddr.sa_family = (unsigned short)10;
#line 1887
      vsf_sysutil_memcpy((void *)(& p_sockaddr___0->u.u_sockaddr_in6.sin6_addr), (void const   *)(& p_src->u.u_sockaddr_in6.sin6_addr),
                         (unsigned int )sizeof(p_sockaddr___0->u.u_sockaddr_in6.sin6_addr));
    } else {
#line 1893
      die("can only support ipv4 and ipv6 currently");
    }
  }
#line 1895
  return;
}
}
#line 1897 "sysutil.c"
int vsf_sysutil_sockaddr_addr_equal(struct vsf_sysutil_sockaddr  const  *p1 , struct vsf_sysutil_sockaddr  const  *p2 ) 
{ int family1 ;
  int family2 ;
  void const   *p_ipv4_addr ;
  void const   *__cil_tmp ;
  int __cil_tmp___0 ;
  void const   *p_ipv4_addr___0 ;
  void const   *__cil_tmp___1 ;
  int __cil_tmp___2 ;
  int __cil_tmp___3 ;
  int __cil_tmp___4 ;

  {
#line 1901
  family1 = (int )p1->u.u_sockaddr.sa_family;
#line 1902
  family2 = (int )p2->u.u_sockaddr.sa_family;
#line 1903
  if (family1 != family2) {
#line 1905
    if (family1 == 2 && family2 == 10) {
#line 1907
      __cil_tmp = vsf_sysutil_sockaddr_ipv6_v4(p2);
#line 1907
      p_ipv4_addr = __cil_tmp;
#line 1908
      if (p_ipv4_addr) {
#line 1908
        __cil_tmp___0 = vsf_sysutil_memcmp(p_ipv4_addr, (void const   *)(& p1->u.u_sockaddr_in.sin_addr),
                                           (unsigned int )sizeof(p1->u.u_sockaddr_in.sin_addr));
#line 1908
        if (__cil_tmp___0) {
#line 1908
          goto _L;
        } else {
#line 1912
          return (1);
        }
      } else {
        _L: /* CIL Label */ ;
      }
    } else {
#line 1915
      if (family1 == 10 && family2 == 2) {
#line 1917
        __cil_tmp___1 = vsf_sysutil_sockaddr_ipv6_v4(p1);
#line 1917
        p_ipv4_addr___0 = __cil_tmp___1;
#line 1918
        if (p_ipv4_addr___0) {
#line 1918
          __cil_tmp___2 = vsf_sysutil_memcmp(p_ipv4_addr___0, (void const   *)(& p2->u.u_sockaddr_in.sin_addr),
                                             (unsigned int )sizeof(p2->u.u_sockaddr_in.sin_addr));
#line 1918
          if (__cil_tmp___2) {
#line 1918
            goto _L___0;
          } else {
#line 1922
            return (1);
          }
        } else {
          _L___0: /* CIL Label */ ;
        }
      }
    }
#line 1925
    return (0);
  }
#line 1927
  if (family1 == 2) {
#line 1929
    __cil_tmp___3 = vsf_sysutil_memcmp((void const   *)(& p1->u.u_sockaddr_in.sin_addr),
                                       (void const   *)(& p2->u.u_sockaddr_in.sin_addr),
                                       (unsigned int )sizeof(p1->u.u_sockaddr_in.sin_addr));
#line 1929
    if (__cil_tmp___3 == 0) {
#line 1933
      return (1);
    }
  } else {
#line 1936
    if (family1 == 10) {
#line 1938
      __cil_tmp___4 = vsf_sysutil_memcmp((void const   *)(& p1->u.u_sockaddr_in6.sin6_addr),
                                         (void const   *)(& p2->u.u_sockaddr_in6.sin6_addr),
                                         (unsigned int )sizeof(p1->u.u_sockaddr_in6.sin6_addr));
#line 1938
      if (__cil_tmp___4 == 0) {
#line 1942
        return (1);
      }
    }
  }
#line 1945
  return (0);
}
}
#line 1948 "sysutil.c"
int vsf_sysutil_sockaddr_is_ipv6(struct vsf_sysutil_sockaddr  const  *p_sockaddr___0 ) 
{ 

  {
#line 1951
  if ((int const   )p_sockaddr___0->u.u_sockaddr.sa_family == 10) {
#line 1953
    return (1);
  }
#line 1955
  return (0);
}
}
#line 1969 "sysutil.c"
static struct vsf_sysutil_sockaddr *s_p_sockaddr___0  ;
#line 1958 "sysutil.c"
void vsf_sysutil_sockaddr_set_ipv4addr(struct vsf_sysutil_sockaddr *p_sockptr , unsigned char const   *p_raw ) 
{ void const   *__cil_tmp ;

  {
#line 1962
  if ((int )p_sockptr->u.u_sockaddr.sa_family == 2) {
#line 1964
    vsf_sysutil_memcpy((void *)(& p_sockptr->u.u_sockaddr_in.sin_addr), (void const   *)p_raw,
                       (unsigned int )sizeof(p_sockptr->u.u_sockaddr_in.sin_addr));
  } else {
#line 1967
    if ((int )p_sockptr->u.u_sockaddr.sa_family == 10) {
#line 1970
      vsf_sysutil_sockaddr_alloc_ipv4(& s_p_sockaddr___0);
#line 1971
      vsf_sysutil_memcpy((void *)(& s_p_sockaddr___0->u.u_sockaddr_in.sin_addr), (void const   *)p_raw,
                         (unsigned int )sizeof(& s_p_sockaddr___0->u.u_sockaddr_in.sin_addr));
#line 1973
      __cil_tmp = vsf_sysutil_sockaddr_ipv4_v6((struct vsf_sysutil_sockaddr  const  *)s_p_sockaddr___0);
#line 1973
      vsf_sysutil_memcpy((void *)(& p_sockptr->u.u_sockaddr_in6.sin6_addr), __cil_tmp,
                         (unsigned int )sizeof(p_sockptr->u.u_sockaddr_in6.sin6_addr));
    } else {
#line 1979
      bug("bad family");
    }
  }
#line 1981
  return;
}
}
#line 1983 "sysutil.c"
void vsf_sysutil_sockaddr_set_ipv6addr(struct vsf_sysutil_sockaddr *p_sockptr , unsigned char const   *p_raw ) 
{ 

  {
#line 1987
  if ((int )p_sockptr->u.u_sockaddr.sa_family == 10) {
#line 1989
    vsf_sysutil_memcpy((void *)(& p_sockptr->u.u_sockaddr_in6.sin6_addr), (void const   *)p_raw,
                       (unsigned int )sizeof(p_sockptr->u.u_sockaddr_in6.sin6_addr));
  } else {
#line 1994
    bug("bad family");
  }
#line 1996
  return;
}
}
#line 2001 "sysutil.c"
static char pattern[12]  = 
#line 2001
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)-1,      (char)-1};
#line 1998 "sysutil.c"
void const   *vsf_sysutil_sockaddr_ipv6_v4(struct vsf_sysutil_sockaddr  const  *p_addr ) 
{ unsigned char const   *p_addr_start ;
  int __cil_tmp ;

  {
#line 2003
  if ((int const   )p_addr->u.u_sockaddr.sa_family != 10) {
#line 2005
    return ((void const   *)0);
  }
#line 2007
  __cil_tmp = vsf_sysutil_memcmp((void const   *)(pattern), (void const   *)(& p_addr->u.u_sockaddr_in6.sin6_addr),
                                 12U);
#line 2007
  if (__cil_tmp) {
#line 2009
    return ((void const   *)0);
  }
#line 2011
  p_addr_start = (unsigned char const   *)(& p_addr->u.u_sockaddr_in6.sin6_addr);
#line 2012
  return ((void const   *)(p_addr_start + 12));
}
}
#line 2018 "sysutil.c"
static char ret[16]  = 
#line 2018
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)-1,      (char)-1, 
        (char)0,      (char)0,      (char)0,      (char)0};
#line 2015 "sysutil.c"
void const   *vsf_sysutil_sockaddr_ipv4_v6(struct vsf_sysutil_sockaddr  const  *p_addr ) 
{ 

  {
#line 2019
  if ((int const   )p_addr->u.u_sockaddr.sa_family != 2) {
#line 2021
    return ((void const   *)0);
  }
#line 2023
  vsf_sysutil_memcpy((void *)(& ret[12]), (void const   *)(& p_addr->u.u_sockaddr_in.sin_addr),
                     4U);
#line 2024
  return ((void const   *)(ret));
}
}
#line 2027 "sysutil.c"
void *vsf_sysutil_sockaddr_get_raw_addr(struct vsf_sysutil_sockaddr *p_sockptr ) 
{ 

  {
#line 2030
  if ((int )p_sockptr->u.u_sockaddr.sa_family == 2) {
#line 2032
    return ((void *)(& p_sockptr->u.u_sockaddr_in.sin_addr));
  } else {
#line 2034
    if ((int )p_sockptr->u.u_sockaddr.sa_family == 10) {
#line 2036
      return ((void *)(& p_sockptr->u.u_sockaddr_in6.sin6_addr));
    } else {
#line 2040
      bug("bad family");
    }
  }
#line 2042
  return ((void *)0);
}
}
#line 2045 "sysutil.c"
unsigned int vsf_sysutil_get_ipaddr_size(void) 
{ struct vsf_sysutil_sockaddr addr ;
  unsigned int size ;
  unsigned int size2 ;

  {
#line 2049
  size = (unsigned int )sizeof(addr.u.u_sockaddr_in.sin_addr);
#line 2050
  size2 = (unsigned int )sizeof(addr.u.u_sockaddr_in6.sin6_addr);
#line 2051
  if (size2 > size) {
#line 2053
    size = size2;
  }
#line 2055
  return (size);
}
}
#line 2058 "sysutil.c"
int vsf_sysutil_get_ipsock(struct vsf_sysutil_sockaddr  const  *p_addr ) 
{ int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 2061
  if ((int const   )p_addr->u.u_sockaddr.sa_family == 2) {
#line 2063
    __cil_tmp = vsf_sysutil_get_ipv4_sock();
#line 2063
    return (__cil_tmp);
  } else {
#line 2065
    if ((int const   )p_addr->u.u_sockaddr.sa_family == 10) {
#line 2067
      __cil_tmp___0 = vsf_sysutil_get_ipv6_sock();
#line 2067
      return (__cil_tmp___0);
    } else {
#line 2071
      bug("bad family");
    }
  }
#line 2073
  return (-1);
}
}
#line 2076 "sysutil.c"
void vsf_sysutil_sockaddr_set_any(struct vsf_sysutil_sockaddr *p_sockaddr___0 ) 
{ 

  {
#line 2079
  if ((int )p_sockaddr___0->u.u_sockaddr.sa_family == 2) {
#line 2081
    vsf_sysutil_memclr((void *)(& p_sockaddr___0->u.u_sockaddr_in.sin_addr), (unsigned int )sizeof(p_sockaddr___0->u.u_sockaddr_in.sin_addr));
  } else {
#line 2084
    if ((int )p_sockaddr___0->u.u_sockaddr.sa_family == 10) {
#line 2086
      vsf_sysutil_memclr((void *)(& p_sockaddr___0->u.u_sockaddr_in6.sin6_addr), (unsigned int )sizeof(p_sockaddr___0->u.u_sockaddr_in6.sin6_addr));
    } else {
#line 2091
      bug("bad family");
    }
  }
#line 2093
  return;
}
}
#line 2095 "sysutil.c"
void vsf_sysutil_sockaddr_set_port(struct vsf_sysutil_sockaddr *p_sockptr , unsigned short the_port ) 
{ 

  {
#line 2099
  if ((int )p_sockptr->u.u_sockaddr.sa_family == 2) {
#line 2101
    p_sockptr->u.u_sockaddr_in.sin_port = htons(the_port);
  } else {
#line 2103
    if ((int )p_sockptr->u.u_sockaddr.sa_family == 10) {
#line 2105
      p_sockptr->u.u_sockaddr_in6.sin6_port = htons(the_port);
    } else {
#line 2109
      bug("bad family");
    }
  }
#line 2111
  return;
}
}
#line 2113 "sysutil.c"
int vsf_sysutil_is_port_reserved(unsigned short the_port ) 
{ 

  {
#line 2116
  if ((int )the_port < 1024) {
#line 2118
    return (1);
  }
#line 2120
  return (0);
}
}
#line 2133 "sysutil.c"
static char inaddr_buf[64]  ;
#line 2123 "sysutil.c"
char const   *vsf_sysutil_inet_ntop(struct vsf_sysutil_sockaddr  const  *p_sockptr ) 
{ struct sockaddr  const  *p_sockaddr___0 ;
  char *__cil_tmp ;
  char const   *p_ret ;
  char const   *__cil_tmp___0 ;

  {
#line 2126
  p_sockaddr___0 = & p_sockptr->u.u_sockaddr;
#line 2127
  if ((int const   )p_sockaddr___0->sa_family == 2) {
#line 2129
    __cil_tmp = inet_ntoa((struct in_addr )p_sockptr->u.u_sockaddr_in.sin_addr);
#line 2129
    return ((char const   *)__cil_tmp);
  } else {
#line 2131
    if ((int const   )p_sockaddr___0->sa_family == 10) {
#line 2134
      __cil_tmp___0 = inet_ntop(10, (void const   * __restrict  )(& p_sockptr->u.u_sockaddr_in6.sin6_addr),
                                (char * __restrict  )(inaddr_buf), (unsigned int )sizeof(inaddr_buf));
#line 2134
      p_ret = __cil_tmp___0;
#line 2137
      inaddr_buf[sizeof(inaddr_buf) - 1UL] = (char )'\000';
#line 2138
      if ((unsigned int )p_ret == (unsigned int )((void *)0)) {
#line 2140
        inaddr_buf[0] = (char )'\000';
      }
#line 2142
      return ((char const   *)(inaddr_buf));
    } else {
#line 2146
      die("can only support ipv4 and ipv6 currently");
#line 2147
      return ((char const   *)0);
    }
  }
}
}
#line 2151 "sysutil.c"
char const   *vsf_sysutil_inet_ntoa(void const   *p_raw_addr ) 
{ char *__cil_tmp ;

  {
#line 2154
  __cil_tmp = inet_ntoa(*((struct in_addr *)p_raw_addr));
#line 2154
  return ((char const   *)__cil_tmp);
}
}
#line 2157 "sysutil.c"
int vsf_sysutil_inet_aton(char const   *p_text , struct vsf_sysutil_sockaddr *p_addr ) 
{ struct in_addr sin_addr ;
  int __cil_tmp ;

  {
#line 2161
  if ((int )p_addr->u.u_sockaddr.sa_family != 2) {
#line 2163
    bug("bad family");
  }
#line 2165
  __cil_tmp = inet_aton(p_text, & sin_addr);
#line 2165
  if (__cil_tmp) {
#line 2167
    vsf_sysutil_memcpy((void *)(& p_addr->u.u_sockaddr_in.sin_addr), (void const   *)(& sin_addr),
                       (unsigned int )sizeof(p_addr->u.u_sockaddr_in.sin_addr));
#line 2169
    return (1);
  } else {
#line 2173
    return (0);
  }
}
}
#line 2177 "sysutil.c"
void vsf_sysutil_dns_resolve(struct vsf_sysutil_sockaddr **p_sockptr , char const   *p_name ) 
{ struct hostent *hent ;
  struct hostent *__cil_tmp ;
  unsigned int len ;
  unsigned int len___0 ;

  {
#line 2181
  __cil_tmp = gethostbyname(p_name);
#line 2181
  hent = __cil_tmp;
#line 2182
  if ((unsigned int )hent == (unsigned int )((void *)0)) {
#line 2184
    die2("cannot resolve host:", p_name);
  }
#line 2186
  vsf_sysutil_sockaddr_clear(p_sockptr);
#line 2187
  if (hent->h_addrtype == 2) {
#line 2189
    len = (unsigned int )hent->h_length;
#line 2190
    if ((unsigned long )len > sizeof((*p_sockptr)->u.u_sockaddr_in.sin_addr)) {
#line 2192
      len = (unsigned int )sizeof((*p_sockptr)->u.u_sockaddr_in.sin_addr);
    }
#line 2194
    vsf_sysutil_sockaddr_alloc_ipv4(p_sockptr);
#line 2195
    vsf_sysutil_memcpy((void *)(& (*p_sockptr)->u.u_sockaddr_in.sin_addr), (void const   *)*(hent->h_addr_list + 0),
                       len);
  } else {
#line 2198
    if (hent->h_addrtype == 10) {
#line 2200
      len___0 = (unsigned int )hent->h_length;
#line 2201
      if ((unsigned long )len___0 > sizeof((*p_sockptr)->u.u_sockaddr_in6.sin6_addr)) {
#line 2203
        len___0 = (unsigned int )sizeof((*p_sockptr)->u.u_sockaddr_in6.sin6_addr);
      }
#line 2205
      vsf_sysutil_sockaddr_alloc_ipv6(p_sockptr);
#line 2206
      vsf_sysutil_memcpy((void *)(& (*p_sockptr)->u.u_sockaddr_in6.sin6_addr), (void const   *)*(hent->h_addr_list + 0),
                         len___0);
    } else {
#line 2211
      die("gethostbyname(): neither IPv4 nor IPv6");
    }
  }
#line 2213
  return;
}
}
#line 2215 "sysutil.c"
struct vsf_sysutil_user *vsf_sysutil_getpwuid(int uid ) 
{ struct passwd *__cil_tmp ;

  {
#line 2218
  if (uid < 0) {
#line 2220
    bug("negative uid in vsf_sysutil_getpwuid");
  }
#line 2222
  __cil_tmp = getpwuid((unsigned int )uid);
#line 2222
  return ((struct vsf_sysutil_user *)__cil_tmp);
}
}
#line 2225 "sysutil.c"
struct vsf_sysutil_user *vsf_sysutil_getpwnam(char const   *p_user ) 
{ struct passwd *__cil_tmp ;

  {
#line 2228
  __cil_tmp = getpwnam(p_user);
#line 2228
  return ((struct vsf_sysutil_user *)__cil_tmp);
}
}
#line 2231 "sysutil.c"
char const   *vsf_sysutil_user_getname(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;

  {
#line 2234
  p_passwd = (struct passwd  const  *)p_user;
#line 2235
  return ((char const   *)p_passwd->pw_name);
}
}
#line 2238 "sysutil.c"
char const   *vsf_sysutil_user_get_homedir(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;

  {
#line 2241
  p_passwd = (struct passwd  const  *)p_user;
#line 2242
  return ((char const   *)p_passwd->pw_dir);
}
}
#line 2245 "sysutil.c"
int vsf_sysutil_user_getuid(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;

  {
#line 2248
  p_passwd = (struct passwd  const  *)p_user;
#line 2249
  return ((int )p_passwd->pw_uid);
}
}
#line 2252 "sysutil.c"
int vsf_sysutil_user_getgid(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;

  {
#line 2255
  p_passwd = (struct passwd  const  *)p_user;
#line 2256
  return ((int )p_passwd->pw_gid);
}
}
#line 2259 "sysutil.c"
struct vsf_sysutil_group *vsf_sysutil_getgrgid(int gid ) 
{ struct group *__cil_tmp ;

  {
#line 2262
  if (gid < 0) {
#line 2264
    die("negative gid in vsf_sysutil_getgrgid");
  }
#line 2266
  __cil_tmp = getgrgid((unsigned int )gid);
#line 2266
  return ((struct vsf_sysutil_group *)__cil_tmp);
}
}
#line 2269 "sysutil.c"
char const   *vsf_sysutil_group_getname(struct vsf_sysutil_group  const  *p_group ) 
{ struct group  const  *p_grp ;

  {
#line 2272
  p_grp = (struct group  const  *)p_group;
#line 2273
  return ((char const   *)p_grp->gr_name);
}
}
#line 2279 "sysutil.c"
static int seeded  ;
#line 2276 "sysutil.c"
unsigned char vsf_sysutil_get_random_byte(void) 
{ unsigned int uint_res ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  struct timeval tv ;
  int retval ;
  int __cil_tmp ;
  int __cil_tmp___0 ;

  {
#line 2282
  if (! seeded) {
#line 2285
    __cil_tmp = gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
#line 2285
    retval = __cil_tmp;
#line 2286
    if (retval != 0) {
#line 2288
      die("gettimeofday");
    }
#line 2290
    srand((unsigned int )tv.tv_usec);
#line 2291
    seeded = 1;
  }
#line 2293
  __cil_tmp___0 = rand();
#line 2293
  uint_res = (unsigned int )__cil_tmp___0;
#line 2294
  c1 = (unsigned char )(uint_res & 255U);
#line 2295
  c2 = (unsigned char )((uint_res >> 8) & 255U);
#line 2296
  c3 = (unsigned char )((uint_res >> 16) & 255U);
#line 2297
  c4 = (unsigned char )((uint_res >> 24) & 255U);
#line 2298
  return ((unsigned char )((((int )c1 ^ (int )c2) ^ (int )c3) ^ (int )c4));
}
}
#line 2301 "sysutil.c"
int vsf_sysutil_running_as_root(void) 
{ __uid_t __cil_tmp ;

  {
#line 2304
  __cil_tmp = getuid();
#line 2304
  return (__cil_tmp == 0U);
}
}
#line 2307 "sysutil.c"
void vsf_sysutil_setuid(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;

  {
#line 2310
  p_passwd = (struct passwd  const  *)p_user;
#line 2311
  vsf_sysutil_setuid_numeric((int )p_passwd->pw_uid);
#line 2312
  return;
}
}
#line 2314 "sysutil.c"
void vsf_sysutil_setuid_numeric(int uid ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 2317
  __cil_tmp = setuid((unsigned int )uid);
#line 2317
  retval = __cil_tmp;
#line 2318
  if (retval != 0) {
#line 2320
    die("setuid");
  }
#line 2322
  return;
}
}
#line 2324 "sysutil.c"
void vsf_sysutil_setgid(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;

  {
#line 2327
  p_passwd = (struct passwd  const  *)p_user;
#line 2328
  vsf_sysutil_setgid_numeric((int )p_passwd->pw_gid);
#line 2329
  return;
}
}
#line 2331 "sysutil.c"
void vsf_sysutil_setgid_numeric(int gid ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 2334
  __cil_tmp = setgid((unsigned int )gid);
#line 2334
  retval = __cil_tmp;
#line 2335
  if (retval != 0) {
#line 2337
    die("setgid");
  }
#line 2339
  return;
}
}
#line 2341 "sysutil.c"
int vsf_sysutil_geteuid(void) 
{ int retval ;
  __uid_t __cil_tmp ;

  {
#line 2344
  __cil_tmp = geteuid();
#line 2344
  retval = (int )__cil_tmp;
#line 2345
  if (retval < 0) {
#line 2347
    die("geteuid");
  }
#line 2349
  return (retval);
}
}
#line 2352 "sysutil.c"
int vsf_sysutil_getegid(void) 
{ int retval ;
  __gid_t __cil_tmp ;

  {
#line 2355
  __cil_tmp = getegid();
#line 2355
  retval = (int )__cil_tmp;
#line 2356
  if (retval < 0) {
#line 2358
    die("getegid");
  }
#line 2360
  return (retval);
}
}
#line 2363 "sysutil.c"
void vsf_sysutil_seteuid(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;

  {
#line 2366
  p_passwd = (struct passwd  const  *)p_user;
#line 2367
  vsf_sysutil_seteuid_numeric((int )p_passwd->pw_uid);
#line 2368
  return;
}
}
#line 2370 "sysutil.c"
void vsf_sysutil_setegid(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;

  {
#line 2373
  p_passwd = (struct passwd  const  *)p_user;
#line 2374
  vsf_sysutil_setegid_numeric((int )p_passwd->pw_gid);
#line 2375
  return;
}
}
#line 2377 "sysutil.c"
void vsf_sysutil_seteuid_numeric(int uid ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 2381
  __cil_tmp = setreuid(4294967295U, (unsigned int )uid);
#line 2381
  retval = __cil_tmp;
#line 2382
  if (retval != 0) {
#line 2384
    die("seteuid");
  }
#line 2386
  return;
}
}
#line 2388 "sysutil.c"
void vsf_sysutil_setegid_numeric(int gid ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 2392
  __cil_tmp = setregid(4294967295U, (unsigned int )gid);
#line 2392
  retval = __cil_tmp;
#line 2393
  if (retval != 0) {
#line 2395
    die("setegid");
  }
#line 2397
  return;
}
}
#line 2399 "sysutil.c"
void vsf_sysutil_clear_supp_groups(void) 
{ int retval ;
  int __cil_tmp ;

  {
#line 2402
  __cil_tmp = setgroups(0UL, (__gid_t const   *)((void *)0));
#line 2402
  retval = __cil_tmp;
#line 2403
  if (retval != 0) {
#line 2405
    die("setgroups");
  }
#line 2407
  return;
}
}
#line 2409 "sysutil.c"
void vsf_sysutil_initgroups(struct vsf_sysutil_user  const  *p_user ) 
{ struct passwd  const  *p_passwd ;
  int retval ;
  int __cil_tmp ;

  {
#line 2412
  p_passwd = (struct passwd  const  *)p_user;
#line 2413
  __cil_tmp = initgroups((char const   *)p_passwd->pw_name, (unsigned int )p_passwd->pw_gid);
#line 2413
  retval = __cil_tmp;
#line 2414
  if (retval != 0) {
#line 2416
    die("initgroups");
  }
#line 2418
  return;
}
}
#line 2420 "sysutil.c"
void vsf_sysutil_chroot(char const   *p_root_path ) 
{ int retval ;
  int __cil_tmp ;

  {
#line 2423
  __cil_tmp = chroot(p_root_path);
#line 2423
  retval = __cil_tmp;
#line 2424
  if (retval != 0) {
#line 2426
    die("chroot");
  }
#line 2428
  return;
}
}
#line 2430 "sysutil.c"
unsigned int vsf_sysutil_get_umask(void) 
{ 

  {
#line 2433
  return (s_current_umask);
}
}
#line 2436 "sysutil.c"
void vsf_sysutil_set_umask(unsigned int new_umask ) 
{ 

  {
#line 2439
  s_current_umask = new_umask & 511U;
#line 2440
  umask(s_current_umask);
#line 2441
  return;
}
}
#line 2443 "sysutil.c"
void vsf_sysutil_make_session_leader(void) 
{ __pid_t __cil_tmp ;
  __pid_t __cil_tmp___0 ;

  {
#line 2447
  setsid();
#line 2449
  __cil_tmp = getpid();
#line 2449
  __cil_tmp___0 = getpgrp();
#line 2449
  if (__cil_tmp != __cil_tmp___0) {
#line 2451
    die("not session leader");
  }
#line 2453
  return;
}
}
#line 2477 "sysutil.c"
static char envtz[13UL]  ;
#line 2455 "sysutil.c"
void vsf_sysutil_tzset(void) 
{ int retval ;
  char tzbuf[sizeof("+HHMM!")] ;
  time_t the_time ;
  time_t __cil_tmp ;
  struct tm *p_tm ;
  size_t___0 __cil_tmp___0 ;

  {
#line 2460
  __cil_tmp = time((time_t *)((void *)0));
#line 2460
  the_time = __cil_tmp;
#line 2462
  tzset();
#line 2463
  p_tm = localtime((time_t const   *)(& the_time));
#line 2464
  if ((unsigned int )p_tm == (unsigned int )((void *)0)) {
#line 2466
    die("localtime");
  }
#line 2472
  __cil_tmp___0 = strftime((char * __restrict  )(tzbuf), sizeof(tzbuf), (char const   * __restrict  )"%z",
                           (struct tm  const  * __restrict  )p_tm);
#line 2472
  retval = (int )__cil_tmp___0;
#line 2473
  tzbuf[sizeof(tzbuf) - 1UL] = (char )'\000';
#line 2474
  if (retval == 5) {
#line 2479
    tzbuf[5] = tzbuf[4];
#line 2480
    tzbuf[4] = tzbuf[3];
#line 2481
    tzbuf[3] = (char )':';
#line 2485
    if ((int )tzbuf[0] == 43) {
#line 2487
      tzbuf[0] = (char )'-';
    } else {
#line 2491
      tzbuf[0] = (char )'+';
    }
#line 2493
    snprintf((char * __restrict  )(envtz), sizeof(envtz), (char const   * __restrict  )"TZ=UTC%s",
             tzbuf);
#line 2494
    putenv(envtz);
#line 2495
    s_timezone = (long )(((((int )tzbuf[1] - 48) * 10 + ((int )tzbuf[2] - 48)) * 60) * 60);
#line 2496
    s_timezone += (long )((((int )tzbuf[4] - 48) * 10 + ((int )tzbuf[5] - 48)) * 60);
#line 2497
    if ((int )tzbuf[0] == 45) {
#line 2499
      s_timezone *= -1L;
    }
  }
#line 2502
  return;
}
}
#line 2507 "sysutil.c"
static char datebuf___1[64]  ;
#line 2504 "sysutil.c"
char const   *vsf_sysutil_get_current_date(void) 
{ time_t curr_time ;
  struct tm  const  *p_tm ;
  int i ;
  struct tm *__cil_tmp ;
  size_t___0 __cil_tmp___0 ;

  {
#line 2510
  i = 0;
#line 2511
  vsf_sysutil_update_cached_time();
#line 2512
  curr_time = vsf_sysutil_get_cached_time_sec();
#line 2513
  __cil_tmp = localtime((time_t const   *)(& curr_time));
#line 2513
  p_tm = (struct tm  const  *)__cil_tmp;
#line 2514
  __cil_tmp___0 = strftime((char * __restrict  )(datebuf___1), sizeof(datebuf___1),
                           (char const   * __restrict  )"%a %b!%d %H:%M:%S %Y", (struct tm  const  * __restrict  )p_tm);
#line 2514
  if (__cil_tmp___0 == 0UL) {
#line 2516
    die("strftime");
  }
#line 2518
  datebuf___1[sizeof(datebuf___1) - 1UL] = (char )'\000';
#line 2520
  while ((int )datebuf___1[i] != 33 && (int )datebuf___1[i] != 0) {
#line 2522
    i ++;
  }
#line 2524
  if ((int )datebuf___1[i] == 33) {
#line 2526
    datebuf___1[i] = (char )' ';
#line 2527
    if ((int )datebuf___1[i + 1] == 48) {
#line 2529
      datebuf___1[i + 1] = (char )' ';
    }
  }
#line 2532
  return ((char const   *)(datebuf___1));
}
}
#line 2535 "sysutil.c"
void vsf_sysutil_update_cached_time(void) 
{ int __cil_tmp ;

  {
#line 2538
  __cil_tmp = gettimeofday((struct timeval * __restrict  )(& s_current_time), (struct timezone * __restrict  )((void *)0));
#line 2538
  if (__cil_tmp != 0) {
#line 2540
    die("gettimeofday");
  }
#line 2542
  return;
}
}
#line 2544 "sysutil.c"
long vsf_sysutil_get_cached_time_sec(void) 
{ 

  {
#line 2547
  return (s_current_time.tv_sec);
}
}
#line 2550 "sysutil.c"
long vsf_sysutil_get_cached_time_usec(void) 
{ 

  {
#line 2553
  return (s_current_time.tv_usec);
}
}
#line 2556 "sysutil.c"
void vsf_sysutil_qsort(void *p_base , unsigned int num_elem , unsigned int elem_size ,
                       int (*p_compar)(void const   * , void const   * ) ) 
{ 

  {
#line 2560
  qsort(p_base, (unsigned long )num_elem, (unsigned long )elem_size, p_compar);
#line 2561
  return;
}
}
#line 2563 "sysutil.c"
void vsf_sysutil_sleep(double seconds ) 
{ int retval ;
  int saved_errno ;
  double fractional ;
  time_t secs ;
  struct timespec ts ;
  int *__cil_tmp ;

  {
#line 2571
  secs = (long )seconds;
#line 2572
  fractional = seconds - (double )secs;
#line 2573
  ts.tv_sec = secs;
#line 2574
  ts.tv_nsec = (long )(fractional * (double )1000000000);
#line 2575
  while (1) {
#line 2577
    retval = nanosleep((struct timespec  const  *)(& ts), & ts);
#line 2578
    __cil_tmp = __errno_location();
#line 2578
    saved_errno = *__cil_tmp;
#line 2579
    vsf_sysutil_check_pending_actions(0, 0, 0);
#line 2575
    if (! (retval == -1 && saved_errno == 4)) {
#line 2575
      break;
    }
  }
#line 2581
  return;
}
}
#line 2583 "sysutil.c"
char *vsf_sysutil_getenv(char const   *p_var ) 
{ char *__cil_tmp ;

  {
#line 2586
  __cil_tmp = getenv(p_var);
#line 2586
  return (__cil_tmp);
}
}
#line 2589 "sysutil.c"
void vsf_sysutil_openlog(void) 
{ int facility ;

  {
#line 2592
  facility = 3 << 3;
#line 2594
  facility = 11 << 3;
#line 2596
  openlog("vsftpd", 8, facility);
#line 2597
  return;
}
}
#line 2599 "sysutil.c"
void vsf_sysutil_syslog(char const   *p_text , int severe ) 
{ int prio ;

  {
#line 2602
  prio = 6;
#line 2603
  if (severe) {
#line 2605
    prio = 4;
  }
#line 2607
  syslog(prio, "%s", p_text);
#line 2608
  return;
}
}
#line 2610 "sysutil.c"
long vsf_sysutil_parse_time(char const   *p_text ) 
{ struct tm the_time ;
  unsigned int len ;
  unsigned int __cil_tmp ;
  char yr[5] ;
  char mon[3] ;
  char day[3] ;
  int __cil_tmp___0 ;
  int __cil_tmp___1 ;
  char hr[3] ;
  char mins[3] ;
  char sec[3] ;
  time_t __cil_tmp___2 ;

  {
#line 2614
  __cil_tmp = vsf_sysutil_strlen(p_text);
#line 2614
  len = __cil_tmp;
#line 2615
  vsf_sysutil_memclr((void *)(& the_time), (unsigned int )sizeof(the_time));
#line 2616
  if (len >= 8U) {
#line 2621
    vsf_sysutil_strcpy(yr, p_text, 5U);
#line 2622
    vsf_sysutil_strcpy(mon, p_text + 4, 3U);
#line 2623
    vsf_sysutil_strcpy(day, p_text + 6, 3U);
#line 2624
    __cil_tmp___0 = vsf_sysutil_atoi((char const   *)(yr));
#line 2624
    the_time.tm_year = __cil_tmp___0 - 1900;
#line 2625
    __cil_tmp___1 = vsf_sysutil_atoi((char const   *)(mon));
#line 2625
    the_time.tm_mon = __cil_tmp___1 - 1;
#line 2626
    the_time.tm_mday = vsf_sysutil_atoi((char const   *)(day));
  }
#line 2628
  if (len >= 14U) {
#line 2633
    vsf_sysutil_strcpy(hr, p_text + 8, 3U);
#line 2634
    vsf_sysutil_strcpy(mins, p_text + 10, 3U);
#line 2635
    vsf_sysutil_strcpy(sec, p_text + 12, 3U);
#line 2636
    the_time.tm_hour = vsf_sysutil_atoi((char const   *)(hr));
#line 2637
    the_time.tm_min = vsf_sysutil_atoi((char const   *)(mins));
#line 2638
    the_time.tm_sec = vsf_sysutil_atoi((char const   *)(sec));
  }
#line 2640
  __cil_tmp___2 = mktime(& the_time);
#line 2640
  return (__cil_tmp___2);
}
}
#line 2643 "sysutil.c"
int vsf_sysutil_setmodtime(char const   *p_file , long the_time , int is_localtime ) 
{ struct utimbuf new_times ;
  int __cil_tmp ;

  {
#line 2647
  if (! is_localtime) {
#line 2649
    the_time -= s_timezone;
  }
#line 2651
  vsf_sysutil_memclr((void *)(& new_times), (unsigned int )sizeof(new_times));
#line 2652
  new_times.actime = the_time;
#line 2653
  new_times.modtime = the_time;
#line 2654
  __cil_tmp = utime(p_file, (struct utimbuf  const  *)(& new_times));
#line 2654
  return (__cil_tmp);
}
}
#line 1 "cil-nCiU1Iaq.o"
#pragma merger(0,"/tmp/cil-O8yAaBZt.i","-fno-builtin,-Werror-implicit-function-declaration")
#line 171 "../../includes/usr/include/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 179
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 54 "../../includes/usr/include/utmpx.h"
extern void setutxent(void) ;
#line 60
extern void endutxent(void) ;
#line 84
extern struct utmpx *pututxline(struct utmpx  const  *__utmpx ) ;
#line 102
extern void updwtmpx(char const   *__wtmpx_file , struct utmpx  const  *__utmpx ) ;
#line 154 "../../includes/usr/include/security/_pam_types.h"
extern int pam_set_item(pam_handle_t *pamh , int item_type , void const   *item ) ;
#line 30 "../../includes/usr/include/security/pam_appl.h"
extern int pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 34
extern int pam_authenticate(pam_handle_t *pamh , int flags ) ;
#line 35
extern int pam_setcred(pam_handle_t *pamh , int flags ) ;
#line 39
extern int pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 43
extern int pam_open_session(pam_handle_t *pamh , int flags ) ;
#line 44
extern int pam_close_session(pam_handle_t *pamh , int flags ) ;
#line 78 "../../includes/usr/include/sys/capability.h"
extern cap_t cap_init(void) ;
#line 82
extern int cap_set_flag(cap_t  , cap_flag_t  , int  , cap_value_t * , cap_flag_value_t  ) ;
#line 93
extern int cap_set_proc(cap_t  ) ;
#line 200 "sysdeputil.c"
static int do_sendfile(int out_fd , int in_fd , unsigned int num_send , filesize_t start_pos ) ;
#line 202
static void vsf_sysutil_setproctitle_internal(char const   *p_buf ) ;
#line 203 "sysdeputil.c"
static struct mystr s_proctitle_prefix_str  ;
#line 206
void vsf_insert_uwtmp(struct mystr  const  *p_user_str , struct mystr  const  *p_host_str ) ;
#line 208
void vsf_remove_uwtmp(void) ;
#line 278 "sysdeputil.c"
static pam_handle_t *s_pamh  ;
#line 279 "sysdeputil.c"
static struct mystr s_pword_str  ;
#line 280
static int pam_conv_func(int nmsg , struct pam_message  const  **p_msg , struct pam_response **p_reply ,
                         void *p_addata ) ;
#line 282
static void vsf_auth_shutdown(void) ;
#line 284 "sysdeputil.c"
int vsf_sysdep_check_auth(struct mystr  const  *p_user_str , struct mystr  const  *p_pass_str ,
                          struct mystr  const  *p_remote_host ) 
{ int retval ;
  struct pam_conv the_conv ;
  char const   *__cil_tmp ;
  char const   *__cil_tmp___0 ;
  char const   *__cil_tmp___1 ;

  {
#line 290
  the_conv.conv = & pam_conv_func;
#line 290
  the_conv.appdata_ptr = (void *)0;
#line 295
  if ((unsigned int )s_pamh != (unsigned int )((pam_handle_t *)0)) {
#line 297
    bug("vsf_sysdep_check_auth");
  }
#line 299
  str_copy(& s_pword_str, p_pass_str);
#line 300
  __cil_tmp = str_getbuf(p_user_str);
#line 300
  retval = pam_start(tunable_pam_service_name, __cil_tmp, (struct pam_conv  const  *)(& the_conv),
                     & s_pamh);
#line 302
  if (retval != 0) {
#line 304
    s_pamh = (pam_handle_t *)0;
#line 305
    return (0);
  }
#line 308
  __cil_tmp___0 = str_getbuf(p_remote_host);
#line 308
  retval = pam_set_item(s_pamh, 4, (void const   *)__cil_tmp___0);
#line 309
  if (retval != 0) {
#line 311
    pam_end(s_pamh, 0);
#line 312
    s_pamh = (pam_handle_t *)0;
#line 313
    return (0);
  }
#line 317
  retval = pam_set_item(s_pamh, 3, (void const   *)"ftp");
#line 318
  if (retval != 0) {
#line 320
    pam_end(s_pamh, 0);
#line 321
    s_pamh = (pam_handle_t *)0;
#line 322
    return (0);
  }
#line 326
  __cil_tmp___1 = str_getbuf(p_user_str);
#line 326
  retval = pam_set_item(s_pamh, 8, (void const   *)__cil_tmp___1);
#line 327
  if (retval != 0) {
#line 329
    pam_end(s_pamh, 0);
#line 330
    s_pamh = (pam_handle_t *)0;
#line 331
    return (0);
  }
#line 334
  retval = pam_authenticate(s_pamh, 0);
#line 335
  if (retval != 0) {
#line 337
    pam_end(s_pamh, 0);
#line 338
    s_pamh = (pam_handle_t *)0;
#line 339
    return (0);
  }
#line 341
  retval = pam_acct_mgmt(s_pamh, 0);
#line 342
  if (retval != 0) {
#line 344
    pam_end(s_pamh, 0);
#line 345
    s_pamh = (pam_handle_t *)0;
#line 346
    return (0);
  }
#line 348
  retval = pam_setcred(s_pamh, 2);
#line 349
  if (retval != 0) {
#line 351
    pam_end(s_pamh, 0);
#line 352
    s_pamh = (pam_handle_t *)0;
#line 353
    return (0);
  }
#line 355
  if (! tunable_session_support) {
#line 358
    pam_end(s_pamh, 0);
#line 359
    s_pamh = (pam_handle_t *)0;
#line 360
    return (1);
  }
#line 363
  vsf_insert_uwtmp(p_user_str, p_remote_host);
#line 364
  retval = pam_open_session(s_pamh, 0);
#line 365
  if (retval != 0) {
#line 367
    vsf_remove_uwtmp();
#line 368
    pam_setcred(s_pamh, 4);
#line 369
    pam_end(s_pamh, 0);
#line 370
    s_pamh = (pam_handle_t *)0;
#line 371
    return (0);
  }
#line 376
  vsf_sysutil_set_exit_func(& vsf_auth_shutdown);
#line 378
  return (1);
}
}
#line 381 "sysdeputil.c"
static void vsf_auth_shutdown(void) 
{ 

  {
#line 384
  if ((unsigned int )s_pamh == (unsigned int )((pam_handle_t *)0)) {
#line 386
    bug("vsf_auth_shutdown");
  }
#line 388
  pam_close_session(s_pamh, 0);
#line 389
  pam_setcred(s_pamh, 4);
#line 390
  pam_end(s_pamh, 0);
#line 391
  s_pamh = (pam_handle_t *)0;
#line 392
  vsf_remove_uwtmp();
#line 393
  return;
}
}
#line 395 "sysdeputil.c"
static int pam_conv_func(int nmsg , struct pam_message  const  **p_msg , struct pam_response **p_reply ,
                         void *p_addata ) 
{ int i ;
  struct pam_response *p_resps ;
  void *__cil_tmp ;
  char const   *__cil_tmp___0 ;

  {
#line 400
  p_resps = (struct pam_response *)0;
#line 402
  if (nmsg < 0) {
#line 404
    bug("dodgy nmsg in pam_conv_func");
  }
#line 406
  __cil_tmp = vsf_sysutil_malloc((unsigned int )(sizeof(struct pam_response ) * (unsigned long )nmsg));
#line 406
  p_resps = (struct pam_response *)__cil_tmp;
#line 407
  i = 0;
#line 407
  while (i < nmsg) {
#line 409
    switch ((int )(*(p_msg + i))->msg_style) {
    case 1: 
#line 412
    (p_resps + i)->resp_retcode = 0;
#line 413
    __cil_tmp___0 = str_strdup((struct mystr  const  *)(& s_pword_str));
#line 413
    (p_resps + i)->resp = (char *)__cil_tmp___0;
#line 414
    break;
    case 4: 
    case 3: 
#line 417
    (p_resps + i)->resp_retcode = 0;
#line 418
    (p_resps + i)->resp = (char *)0;
#line 419
    break;
    case 2: 
    default: 
#line 422
    vsf_sysutil_free((void *)p_resps);
#line 423
    return (19);
#line 424
    break;
    }
#line 407
    i ++;
  }
#line 427
  *p_reply = p_resps;
#line 428
  return (0);
}
}
#line 434 "sysdeputil.c"
void vsf_sysdep_keep_capabilities(void) 
{ int __cil_tmp ;

  {
#line 437
  __cil_tmp = vsf_sysdep_has_capabilities_as_non_root();
#line 437
  if (! __cil_tmp) {
#line 439
    bug("asked to keep capabilities, but no support exists");
  }
#line 450
  return;
}
}
#line 474
static int do_checkcap(void) ;
#line 479 "sysdeputil.c"
static int s_prctl_checked  ;
#line 480 "sysdeputil.c"
static int s_runtime_prctl_works  ;
#line 476 "sysdeputil.c"
int vsf_sysdep_has_capabilities_as_non_root(void) 
{ 

  {
#line 481
  if (! s_prctl_checked) {
#line 490
    s_prctl_checked = 1;
  }
#line 492
  return (s_runtime_prctl_works);
}
}
#line 501 "sysdeputil.c"
static int s_caps_checked  ;
#line 502 "sysdeputil.c"
static int s_runtime_has_caps  ;
#line 495 "sysdeputil.c"
int vsf_sysdep_has_capabilities(void) 
{ 

  {
#line 503
  if (! s_caps_checked) {
#line 505
    s_runtime_has_caps = do_checkcap();
#line 506
    s_caps_checked = 1;
  }
#line 508
  return (s_runtime_has_caps);
}
}
#line 559 "sysdeputil.c"
static int do_checkcap(void) 
{ cap_t current_caps ;
  cap_t __cil_tmp ;

  {
#line 562
  __cil_tmp = cap_get_proc();
#line 562
  current_caps = __cil_tmp;
#line 563
  cap_free((void *)current_caps);
#line 564
  if ((unsigned int )current_caps != (unsigned int )((void *)0)) {
#line 566
    return (1);
  }
#line 568
  return (0);
}
}
#line 571 "sysdeputil.c"
void vsf_sysdep_adopt_capabilities(unsigned int caps ) 
{ int retval ;
  cap_value_t cap_value ;
  cap_t adopt_caps ;
  cap_t __cil_tmp ;

  {
#line 576
  __cil_tmp = cap_init();
#line 576
  adopt_caps = __cil_tmp;
#line 577
  if (caps & 1U) {
#line 579
    cap_value = 0;
#line 580
    cap_set_flag(adopt_caps, 0, 1, & cap_value, 1);
#line 581
    cap_set_flag(adopt_caps, 1, 1, & cap_value, 1);
  }
#line 583
  if (caps & 2U) {
#line 585
    cap_value = 10;
#line 586
    cap_set_flag(adopt_caps, 0, 1, & cap_value, 1);
#line 587
    cap_set_flag(adopt_caps, 1, 1, & cap_value, 1);
  }
#line 589
  retval = cap_set_proc(adopt_caps);
#line 590
  if (retval != 0) {
#line 592
    die("cap_set_proc");
  }
#line 594
  cap_free((void *)adopt_caps);
#line 595
  return;
}
}
#line 600 "sysdeputil.c"
int vsf_sysutil_sendfile(int out_fd , int in_fd , filesize_t *p_offset , filesize_t num_send ,
                         unsigned int max_chunk ) 
{ int retval ;
  unsigned int send_this_time ;
  int __cil_tmp ;

  {
#line 606
  if (*p_offset < 0LL || num_send < 0LL) {
#line 608
    die("invalid offset or send count in vsf_sysutil_sendfile");
  }
#line 610
  if (max_chunk == 0U) {
#line 612
    max_chunk = 2147483647U;
  }
#line 614
  while (num_send > 0LL) {
#line 618
    if (num_send > (filesize_t )max_chunk) {
#line 620
      send_this_time = max_chunk;
    } else {
#line 624
      send_this_time = (unsigned int )num_send;
    }
#line 627
    vsf_sysutil_lseek_to(in_fd, *p_offset);
#line 628
    retval = do_sendfile(out_fd, in_fd, send_this_time, *p_offset);
#line 629
    __cil_tmp = vsf_sysutil_retval_is_error(retval);
#line 629
    if (__cil_tmp || retval == 0) {
#line 631
      return (retval);
    }
#line 633
    num_send -= (filesize_t )retval;
#line 634
    *p_offset += (filesize_t )retval;
  }
#line 636
  return (0);
}
}
#line 643 "sysdeputil.c"
static char *p_recvbuf___0  ;
#line 639 "sysdeputil.c"
static int do_sendfile(int out_fd , int in_fd , unsigned int num_send , filesize_t start_pos ) 
{ unsigned int total_written ;
  int retval ;
  unsigned int num_read ;
  unsigned int num_written ;
  unsigned int num_read_this_time ;

  {
#line 644
  total_written = 0U;
#line 747
  if ((unsigned int )p_recvbuf___0 == (unsigned int )((char *)0)) {
#line 749
    vsf_secbuf_alloc(& p_recvbuf___0, 65536U);
  }
#line 751
  while (1) {
#line 755
    num_read_this_time = 65536U;
#line 756
    if (num_read_this_time > num_send) {
#line 758
      num_read_this_time = num_send;
    }
#line 760
    retval = vsf_sysutil_read(in_fd, (void *)p_recvbuf___0, num_read_this_time);
#line 761
    if (retval < 0) {
#line 763
      return (retval);
    } else {
#line 765
      if (retval == 0) {
#line 767
        return (-1);
      }
    }
#line 769
    num_read = (unsigned int )retval;
#line 770
    retval = vsf_sysutil_write_loop(out_fd, (void const   *)p_recvbuf___0, num_read);
#line 771
    if (retval < 0) {
#line 773
      return (retval);
    }
#line 775
    num_written = (unsigned int )retval;
#line 776
    total_written += num_written;
#line 777
    if (num_written != num_read) {
#line 779
      return ((int )num_written);
    }
#line 781
    if (num_written > num_send) {
#line 783
      bug("num_written bigger than num_send in do_sendfile");
    }
#line 785
    num_send -= num_written;
#line 786
    if (num_send == 0U) {
#line 789
      return ((int )total_written);
    }
  }
}
}
#line 794 "sysdeputil.c"
void vsf_sysutil_set_proctitle_prefix(struct mystr  const  *p_str ) 
{ 

  {
#line 797
  str_copy(& s_proctitle_prefix_str, p_str);
#line 798
  return;
}
}
#line 801 "sysdeputil.c"
void vsf_sysutil_setproctitle_str(struct mystr  const  *p_str ) 
{ char const   *__cil_tmp ;

  {
#line 804
  __cil_tmp = str_getbuf(p_str);
#line 804
  vsf_sysutil_setproctitle(__cil_tmp);
#line 805
  return;
}
}
#line 807 "sysdeputil.c"
void vsf_sysutil_setproctitle(char const   *p_text ) 
{ struct mystr proctitle_str ;
  int __cil_tmp ;
  char const   *__cil_tmp___0 ;

  {
#line 810
  proctitle_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 810
  proctitle_str.PRIVATE_HANDS_OFF_len = 0U;
#line 810
  proctitle_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 811
  str_copy(& proctitle_str, (struct mystr  const  *)(& s_proctitle_prefix_str));
#line 812
  __cil_tmp = str_isempty((struct mystr  const  *)(& proctitle_str));
#line 812
  if (! __cil_tmp) {
#line 814
    str_append_text(& proctitle_str, ": ");
  }
#line 816
  str_append_text(& proctitle_str, p_text);
#line 817
  __cil_tmp___0 = str_getbuf((struct mystr  const  *)(& proctitle_str));
#line 817
  vsf_sysutil_setproctitle_internal(__cil_tmp___0);
#line 818
  str_free(& proctitle_str);
#line 819
  return;
}
}
#line 913 "sysdeputil.c"
void vsf_sysutil_setproctitle_init(int argc , char const   **argv ) 
{ 

  {
#line 918
  return;
}
}
#line 920 "sysdeputil.c"
static void vsf_sysutil_setproctitle_internal(char const   *p_buf ) 
{ 

  {
#line 924
  return;
}
}
#line 928 "sysdeputil.c"
void vsf_sysutil_map_anon_pages_init(void) 
{ 

  {
#line 931
  return;
}
}
#line 933 "sysdeputil.c"
void *vsf_sysutil_map_anon_pages(unsigned int length ) 
{ char *retval ;
  void *__cil_tmp ;

  {
#line 936
  __cil_tmp = mmap((void *)0, (unsigned long )length, 3, 34, -1, 0LL);
#line 936
  retval = (char *)__cil_tmp;
#line 938
  if ((unsigned int )retval == (unsigned int )((void *)-1)) {
#line 940
    die("mmap");
  }
#line 942
  return ((void *)retval);
}
}
#line 974 "sysdeputil.c"
void vsf_sysutil_send_fd(int sock_fd , int send_fd ) 
{ int retval ;
  struct msghdr msg ;
  struct cmsghdr *p_cmsg ;
  struct iovec vec ;
  char cmsgbuf[(((sizeof(send_fd) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))] ;
  int *p_fds ;
  char sendchar ;

  {
#line 983
  sendchar = (char)0;
#line 984
  msg.msg_control = (void *)(cmsgbuf);
#line 985
  msg.msg_controllen = sizeof(cmsgbuf);
#line 986
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 986
    p_cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 986
    p_cmsg = (struct cmsghdr *)((void *)0);
  }
#line 987
  p_cmsg->cmsg_level = 1;
#line 988
  p_cmsg->cmsg_type = 1;
#line 989
  p_cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + sizeof(send_fd);
#line 990
  p_fds = (int *)(p_cmsg->__cmsg_data);
#line 991
  *p_fds = send_fd;
#line 992
  msg.msg_controllen = p_cmsg->cmsg_len;
#line 993
  msg.msg_name = (void *)0;
#line 994
  msg.msg_namelen = 0U;
#line 995
  msg.msg_iov = & vec;
#line 996
  msg.msg_iovlen = 1UL;
#line 997
  msg.msg_flags = 0;
#line 1001
  vec.iov_base = (void *)(& sendchar);
#line 1002
  vec.iov_len = sizeof(sendchar);
#line 1003
  retval = sendmsg(sock_fd, (struct msghdr  const  *)(& msg), 0);
#line 1004
  if (retval != 1) {
#line 1006
    die("sendmsg");
  }
#line 1008
  return;
}
}
#line 1010 "sysdeputil.c"
int vsf_sysutil_recv_fd(int sock_fd ) 
{ int retval ;
  struct msghdr msg ;
  char recvchar ;
  struct iovec vec ;
  int recv_fd ;
  char cmsgbuf[(((sizeof(recv_fd) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))] ;
  struct cmsghdr *p_cmsg ;
  int *p_fd ;
  struct cmsghdr *__cil_tmp ;

  {
#line 1021
  vec.iov_base = (void *)(& recvchar);
#line 1022
  vec.iov_len = sizeof(recvchar);
#line 1023
  msg.msg_name = (void *)0;
#line 1024
  msg.msg_namelen = 0U;
#line 1025
  msg.msg_iov = & vec;
#line 1026
  msg.msg_iovlen = 1UL;
#line 1027
  msg.msg_control = (void *)(cmsgbuf);
#line 1028
  msg.msg_controllen = sizeof(cmsgbuf);
#line 1029
  msg.msg_flags = 0;
#line 1031
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 1031
    __cil_tmp = (struct cmsghdr *)msg.msg_control;
  } else {
#line 1031
    __cil_tmp = (struct cmsghdr *)((void *)0);
  }
#line 1031
  p_fd = (int *)(__cil_tmp->__cmsg_data);
#line 1032
  *p_fd = -1;
#line 1033
  retval = recvmsg(sock_fd, & msg, 0);
#line 1034
  if (retval != 1) {
#line 1036
    die("recvmsg");
  }
#line 1038
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 1038
    p_cmsg = (struct cmsghdr *)msg.msg_control;
  } else {
#line 1038
    p_cmsg = (struct cmsghdr *)((void *)0);
  }
#line 1039
  if ((unsigned int )p_cmsg == (unsigned int )((void *)0)) {
#line 1041
    die("no passed fd");
  }
#line 1046
  p_fd = (int *)(p_cmsg->__cmsg_data);
#line 1047
  recv_fd = *p_fd;
#line 1048
  if (recv_fd == -1) {
#line 1050
    die("no passed fd");
  }
#line 1052
  return (recv_fd);
}
}
#line 1128 "sysdeputil.c"
static int s_uwtmp_inserted  ;
#line 1129 "sysdeputil.c"
static struct utmpx s_utent  ;
#line 1131 "sysdeputil.c"
void vsf_insert_uwtmp(struct mystr  const  *p_user_str , struct mystr  const  *p_host_str ) 
{ struct mystr line_str ;
  unsigned int __cil_tmp ;
  unsigned int __cil_tmp___0 ;
  char const   *__cil_tmp___1 ;
  unsigned int __cil_tmp___2 ;
  char const   *__cil_tmp___3 ;
  char const   *__cil_tmp___4 ;

  {
#line 1135
  if (sizeof(s_utent.ut_line) < 16UL) {
#line 1137
    return;
  }
#line 1139
  if (s_uwtmp_inserted) {
#line 1141
    bug("vsf_insert_uwtmp");
  }
#line 1144
  line_str.PRIVATE_HANDS_OFF_p_buf = (char *)((void *)0);
#line 1144
  line_str.PRIVATE_HANDS_OFF_len = 0U;
#line 1144
  line_str.PRIVATE_HANDS_OFF_alloc_bytes = 0U;
#line 1145
  str_alloc_text(& line_str, "vsftpd:");
#line 1146
  __cil_tmp = vsf_sysutil_getpid();
#line 1146
  str_append_ulong(& line_str, (unsigned long )__cil_tmp);
#line 1147
  __cil_tmp___0 = str_getlen((struct mystr  const  *)(& line_str));
#line 1147
  if ((unsigned long )__cil_tmp___0 >= sizeof(s_utent.ut_line)) {
#line 1149
    str_free(& line_str);
#line 1150
    return;
  }
#line 1152
  __cil_tmp___1 = str_getbuf((struct mystr  const  *)(& line_str));
#line 1152
  vsf_sysutil_strcpy(s_utent.ut_line, __cil_tmp___1, (unsigned int )sizeof(s_utent.ut_line));
#line 1154
  str_free(& line_str);
#line 1156
  s_uwtmp_inserted = 1;
#line 1157
  s_utent.ut_type = (short)7;
#line 1158
  __cil_tmp___2 = vsf_sysutil_getpid();
#line 1158
  s_utent.ut_pid = (int )__cil_tmp___2;
#line 1159
  __cil_tmp___3 = str_getbuf(p_user_str);
#line 1159
  vsf_sysutil_strcpy(s_utent.ut_user, __cil_tmp___3, (unsigned int )sizeof(s_utent.ut_user));
#line 1161
  __cil_tmp___4 = str_getbuf(p_host_str);
#line 1161
  vsf_sysutil_strcpy(s_utent.ut_host, __cil_tmp___4, (unsigned int )sizeof(s_utent.ut_host));
#line 1163
  vsf_sysutil_update_cached_time();
#line 1164
  s_utent.ut_tv.tv_sec = vsf_sysutil_get_cached_time_sec();
#line 1165
  setutxent();
#line 1166
  pututxline((struct utmpx  const  *)(& s_utent));
#line 1167
  endutxent();
#line 1168
  updwtmpx("/var/log/wtmp", (struct utmpx  const  *)(& s_utent));
#line 1169
  return;
}
}
#line 1171 "sysdeputil.c"
void vsf_remove_uwtmp(void) 
{ 

  {
#line 1174
  if (! s_uwtmp_inserted) {
#line 1176
    return;
  }
#line 1178
  s_uwtmp_inserted = 0;
#line 1179
  s_utent.ut_type = (short)8;
#line 1180
  vsf_sysutil_memclr((void *)(s_utent.ut_user), (unsigned int )sizeof(s_utent.ut_user));
#line 1181
  vsf_sysutil_memclr((void *)(s_utent.ut_host), (unsigned int )sizeof(s_utent.ut_host));
#line 1182
  s_utent.ut_tv.tv_sec = 0L;
#line 1183
  setutxent();
#line 1184
  pututxline((struct utmpx  const  *)(& s_utent));
#line 1185
  endutxent();
#line 1186
  vsf_sysutil_update_cached_time();
#line 1187
  s_utent.ut_tv.tv_sec = vsf_sysutil_get_cached_time_sec();
#line 1188
  updwtmpx("/var/log/wtmp", (struct utmpx  const  *)(& s_utent));
#line 1189
  return;
}
}
