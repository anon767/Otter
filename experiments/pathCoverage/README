This is a rather patched-together way of computing something
approximating minimal covering sets for path coverage, akin to what we
did for line, block, edge, and condition coverage.

Contents:

guaranteedCoverage_printPath{,.ml} - a modified version of guaranteedCoverage.ml which adds the facility to handle path coverage

Makefile - builds guaranteedCoverage_printPath, linking against CIL and Otter. To read the old data files, this needs to be done with Otter compiled at revision 8480 (the version at which the ICSE2010 tag was made).

pathCov.py - python script that invokes guaranteedCoverage_printPath and rewrites the output to be in the same format as that of the output of the other forms of coverage

run{Vsftpd,Ngircd,Grep} - invoke pathCov.py on each of the given program's data files, putting the results in <progName>/*.deps

outputs.tgz - tarball of the output files. The contents are:
	{vsftpd,ngircd,grep}/*.deps - the output generated by the run* scripts
	{vsftpd,ngircd,grep}/aggregated - guaranteed coverage aggregated across all tests
	{vsftpd,ngircd,grep}/minCov - the minimal covering set of configurations for path coverage

Comments:

The data is generated in three steps (using grep as the example):
./runGrep
python -u /fs/skoll/symexe/trunk/experiments/aggregateGuaranteedCoverage.py path -1 grep > grep/aggregated
python -u /fs/skoll/symexe/trunk/experiments/greedyMinCov.py grep/aggregated > grep/minCov

Step 1 iterates through all tests and, for each one, runs pathCov.py.
This, in turn, runs guaranteedCoverage_printPath and then formats the
output to be what aggregateGuaranteedCoverage.py expects. The reason
this reformatting is necessary is that I wanted to leave Otter
unchanged, but I didn't want to have to run the full guaranteed
coverage calculation, because we know that each path condition for a
given test leads to a distinct path. As a shortcut to the full
calculation, guaranteedCoverage_printPath calls Report.printPath to
print out a sample value for each path condition. The reformatting
then prints the path condition on a single line, to represent the
actual path. (This effectively assumes that each path condition leads
to a distinct path. This may lead to a larger minimal covering set
than the truth, but the assumption seems realistic---it is always true
within a single test, and I think it is violated only if you have two
tests which exercise the same path but with different path
conditions. Besides, we wouldn't be finding the minimum covering set
anyway, because we use a greedy algorithm.)

Note that this gives slightly different results than running the usual
guaranteed coverage: consider a path condition of 'x or y'. The old
guaranteedCoverage would give you two ways to cover this: x=1 and
y=1. printPath will just get a single satisfying assignment, setting
either one or both to 1. Also, this runs the risk of assigning the
same path condition (in different tests) two different sample values,
but this risk is hopefully mitigated by restricting the values the
configurations options can take based on the possibleValues files. Of
course, this isn't ideal, but it isn't worthwhile (at least for now)
to run the entire guaranteed coverage calculation, and this was a
simple approximation.

After step 1, we have something that looks just like our old
guaranteed coverage outputs, so we just aggregate them (step 2) and
compute the minimal covering set (step 3) using the same scripts as
before. After aggregation, ignore the fact that every configuration
says that it covered only one path; this is an artifact of our
treating path conditions as paths. In fact, the same path condition
will have often led to different paths in different tests. However,
since we will cover all path conditions, this will not underestimate
the size of the minimal covering set. (Since the covering set will
cover all path conditions, it will cover all paths, too.)
