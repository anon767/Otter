Quick-start Guide
=================

* Configure, build and test:

        (In the top directory)
        make otter
        make test-otter

* Build and test only Otter (after configuring):

        (In the top/otter directory)
        make
        make test

* Running Otter (after building):

        (In the top/otter directory)
        ./otter.pl [flags] <some c file>

* Adding a new module to Otter:

    1. Add your module `MyModule.ml` to `src/Otter`
    2. Edit `src/Otter.{mlpack,odocl}` and add a line `Otter/MyModule`

* Adding a new test module to Otter:

    1. Add your test module `TestMyModule.ml` to `test/TestOtter`
    2. Edit `test/TestOtter.mlpack` and add a line `TestOtter/TestMyModule`
    3. Edit `test/runtestotter.ml` and add your test module's testsuite to the
       list of tests to run:

            run_test_tt_main begin TestList [
                ...
                TestOtter.TestMyModule.testsuite;
                ...
            ] end

* Adding an integration test case to Otter (does not invoke `otter.pl`):

    1. Add your C file test case to one of the directories under
       `test/TestOtterIntegration`:

        * For single-process test cases, add it under `OtterCore`
        * For multi-process test cases, add it under `MultiprocessOtter`

    2. You may create additional directories under `OtterCore` or
       `MultiprocessOtter` to group your test cases.

* Adding an system test case to Otter (invokes `otter.pl`):

    * Similar to the integration tests, but in `test/TestOtterSystem`

* Building Otter's documentation:

    1. Either run `make doc-otter` in the top directory, or `make doc` in
       `otter`
    2. View the documentation in `doc/api`: ocamldoc documentation for various
       module packs will be in `*.docdir`, and a module dependency diagram
       in the `All.dot` GraphViz file

* Debugging Otter:

    1. Build a debug version of Otter:

            (In the top/otter directory)
            make debug

    2. Start the debugger in remote debugging mode:

            (In the top/otter directory)
            ocamldebug _product/runotter.d.byte

            (In the debugger)
            directory src/Otter
            set socket debugsocket
            set loadingmode manual
            step 0

    3. Start Otter in debug mode:

            (In the top/otter directory)
            env CAML_DEBUG_SOCKET=debugsocket \
                ./otter.pl --bytecode [flags] <some c file>


Building Otter
==============

The easiest way of building Otter is from the top directory (i.e., the directory
above the one this README file is in). From the top directory, type:

    make otter

This will configure and build Otter as well as the required libraries such as
Cil and STP. Subsequently, the above command will also automatically rebuild
libraries that are updated (e.g., from the code repository) and, for the most
part, it will also properly rebuild the dependent libraries as well as Otter.
So, this is the recommended way to build Otter.

After building, you should also run Otter's test suite:

    make test-otter

After the first build, which will configure Otter appropriately, Otter itself
may also be rebuilt locally in the `otter` directory:

    cd otter
    make

Likewise, the test suite may also be run locally:

    cd otter
    make test


Where are the build products?
-----------------------------

Otter is built using [Ocamlbuild][] that is driven by a Makefile. This build
system is set up to compile the source code in the `_build` directory, and
additionally, the actual Otter native code executable itself will be copied to
`_product/runotter.native`. Instead of running this executable directly however,
it is more convenient to run the wrapper script `otter.pl` described in the next
section.

A debug bytecode version of the Otter executable can also be built with the
command:

    make debug

It will be copied to `_product/runotter.d.byte`.


Running Otter
=============

Otter includes a convenient wrapper script `otter.pl` that provides a `gcc`-like
interface to Otter. The basic usage syntax is:

    ./otter.pl [flags] <input files>

For example:

    ./otter.pl --printLittle examples/test-mystrcmp.c

`otter.pl` will first run the input files through the C preprocessor (like
`gcc`), merge all input files, then call the Otter executable on the result.

By default, `otter.pl` will run the newer of the native code executable or the
bytecode executable. Alternatively, the bytecode executable may be invoked by:

    ./otter.pl --bytecode [other flags] <input files>

Additional options to Otter can be listed with:

    ./otter.pl --help

Furthermore, many `gcc`-style flags are also supported (although not listed in
the command line help), e.g.:

    ./otter.pl -DSOME_MACRO -include somefile.h -Isomedir


Developing Otter
================

The source code to Otter is organized into two directories:

* the `src` directory contains the source code to Otter;
* the `test` directory contains the source code to Otter's test suite.

Both these directories contain one or more directories of library modules to be
compiled into module packs (i.e., module of modules), as well as a driver module
to be compiled into an executable. For example:

* `src`
    * `Otter`
        * `_tags`
        * `Module1.ml`
        * `Module2.ml`
    * `Otter.mlpack`
    * `Otter.odocl`
    * `runotter.ml`

The `Otter` directory contains the source code to various Otter modules, and
`runotter.ml` is the driver module. In addition to the source files, there are
three meta files---`_tags`, `Otter.mlpack` and `Otter.odocl`---that instruct
Ocamlbuild to compile the directory into a module pack (e.g., `Otter.cma`).
The `_tags` file contain compilation directives for each `.ml` file in the
directory, while the `Otter.mlpack` file contains a list of modules to compile
into a module pack, whereas `Otter.odocl` contains a list of modules for which
to generate documentation, which may be a subset of `Otter.mlpack`.
(Unfortunately, these files are not very well documented in the [Ocamlbuild][]
user guide).

When writing a new module, e.g., `NewModule.ml`, put the file into a module
pack directory, and add a reference to it in the corresponding `.mlpack` and
`.odocl` files. Additionally, when writing a new test module in the `test`
directory, a reference to the new module's test suite should also be added to
the `runtestotter.ml` driver:

    (* in test/runtestotter.ml *)
    run_test_tt_main begin TestList [
        ...
        TestOtter.TestNewModule.testsuite;
        ...
    ] end


Note that when writing a module, references to modules in the same directory
should be unqualified:

    (* in Module1.ml *)
    let foo = Module2.bar;;

Whereas references to modules in other directories must be qualified:

    (* in Module1.ml *)
    let foo = OtherDirectory.Module.bar;;

New module packs may also be created by following the above guidelines.


Adding Integration or System Tests to Otter
===========================================

Otter also contains testing framework for integration testing in
`test/TestOtterIntegration` which invokes only Otter, as well as system testing
in `test/TestOtterSystem` which additionally invokes the `otter.pl` wrapper
for preprocessing.

The core of this testing framework is implemented in
`test/TestUtil/OtterPragmaTests.ml`. Test cases as simply written as C files
with special `#pragma` directives to specify test expectations. Please refer
to `OtterPragmaTests.ml` for documentation of these directives.

To add a new integration test case, simply add a C file to one of the
directories under `test/TestOtterIntegration`:

    * for test cases that are single-process, add the file to `OtterCore`;
    * for test cases that require multi-process capability, such as calling
      `fork()`, add the file to `MultiprocessOtter`.

You may also create additional directories under `OtterCore` or
`MultiprocessOtter` to group your test cases; the directories may even be
nested in other directories for convenience. The framework will recursively
traverse the entire directory structure to find test cases, and will label the
test cases by their path.

System tests are similarly organized in `test/TestOtterSystem`.


Generating Documentation for Otter
==================================

Other than this README file, Otter is mainly documented using `ocamldoc`
annotations in the source code. It is more convenient to peruse these
documentation as HTML documents, which may be generated from the top directory
by running:

    make doc-otter

or locally by running:

    cd otter
    make doc

This will generate HTML documentation in `otter/doc/api/*.docdir` for
each module pack in Otter. Additionally, this will also generate a module
dependency diagram between Otter's modules as a GraphViz file
`otter/doc/All.dot`.


Debugging Otter using the Ocaml debugger
========================================

It takes a few steps to use the Ocaml debugger to debug Otter when using the
`otter.pl` wrapper script. First, build a debug version of Otter:

    make debug

Then, start the Ocaml debugger, giving it the bytecode binary of Otter:

    ocamldebug _product/runotter.d.byte

Before debugging, it's useful to provide the debugger with a list of directories
to find source code files (e.g., `src/Otter`), by typing the following command
to the debugger:

    directory src/Otter [... list of other directories ...]

To allow Otter to be started separately using the `otter.pl` script, set up the
debugger in remote debugging mode with the commands:

    set socket <debug socket>
    set loadingmode manual
    step 0

where `debug socket` can be any file name which will be used to connect to
Otter. The last line `step 0` will cause the debugger to wait for Otter to be
launched, and immediately break at the first instruction.

Finally, in a different terminal, start Otter in debug mode, giving it the same
`debug socket` to connect to the debugger:

    env CAML_DEBUG_SOCKET=<debug socket> \
        ./otter.pl --bytecode [other flags] <input files>


References
==========

[Ocamlbuild]: <http://nicolaspouillard.fr/ocamlbuild/ocamlbuild-user-guide.html>
              "Ocamlbuild User Guide"


