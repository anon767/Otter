/*
 * Changed by Martin
 * 1. assert(1) -> assert(0)
 * 2. while_i_ -> original_while_i  (to avoid duplicate break/continue)
 *
 */
/* Generated by 'cilly --dodsum' in CIL output mode */
/* Generated by CIL v. 1.3.1 */
/* print_CIL_Input is false */

#line 1 "cheetah-7.o"
/* #pragma merger(0,"./cheetah-7.i","") */
#line 1 "cheetah-8.o"
/* #pragma merger(0,"./cheetah-8.i","") */
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 605 "/usr/include/unistd.h"
extern __pid_t setsid(void) ;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
struct _IO_FILE;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 323
extern int fprintf(FILE *__stream , char const   *__format  , ...) ;
#line 585 "cheetah.c"
static void warn(char *message ) 
{ 

  {
  {
  {
#line 586
  fprintf(stderr, "%s\n", message);
  }
  }
#line 587
  return;
}
}
#line 213 "/usr/lib/gcc-lib/i386-redhat-linux/3.2.3/include/stddef.h"
typedef unsigned int size_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 136 "/usr/include/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 230 "/usr/include/string.h"
extern size_t strlen(char const   *__s ) ;
#line 569 "/usr/include/stdlib.h"
extern void free(void *__ptr ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 213
extern int fflush(FILE *__stream ) ;
#line 329
extern int printf(char const   *__format  , ...) ;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 54 "/usr/include/arpa/inet.h"
extern char *inet_ntoa(struct in_addr __in ) ;
#line 162 "/usr/include/string.h"
extern char *strchr(char const   *__s , int __c ) ;
#line 612 "/usr/include/stdlib.h"
extern void exit(int __status ) ;
#line 580 "cheetah.c"
static void crit(char *message ) 
{ 

  {
  {
  {
#line 581
  fprintf(stderr, "%s\n", message);
  }
  {
#line 582
  exit(1);
  }
  }
}
}
#line 131 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 197
extern size_t strftime(char *__s , size_t __maxsize , char const   *__format , struct tm  const  *__tp ) ;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 229
extern struct tm *gmtime(time_t const   *__timer ) ;
#line 184
extern time_t time(time_t *__timer ) ;
#line 556 "/usr/include/stdlib.h"
extern void *malloc(size_t __size ) ;
#line 589 "cheetah.c"
static void *smalloc(size_t size ) 
{ void *rv ;
  void *tmp ;

  {
  {
  {
#line 590
  tmp = malloc(size);
  }
  {
#line 590
  rv = tmp;
  }
  }
#line 591
  if ((unsigned int )rv == (unsigned int )((void *)0)) {
    {
    {
#line 591
    crit((char *)"Memory allocation error.");
    }
    }
  }
#line 592
  return (rv);
}
}
#line 277 "cheetah.c"
static char *curtime(void) 
{ struct tm *gmt ;
  char *rv ;
  char *tmp ;
  time_t t ;
  time_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
  {
#line 279
  tmp = (char *)smalloc(100U);
  }
  {
#line 279
  rv = tmp;
  }
  {
#line 280
  tmp___0 = time((time_t *)((void *)0));
  }
  {
#line 280
  t = tmp___0;
  }
  {
#line 281
  gmt = gmtime((time_t const   *)(& t));
  }
  }
#line 281
  if ((unsigned int )gmt == (unsigned int )((void *)0)) {
    {
    {
#line 281
    crit((char *)"gmtime() error.");
    }
    }
  }
  {
  {
#line 282
  tmp___1 = strftime(rv, 95U, "%d/%b/%Y:%T +0000", (struct tm  const  *)gmt);
  }
  }
#line 282
  if (tmp___1 == 0U) {
    {
    {
#line 283
    crit((char *)"strftime() error.");
    }
    }
  }
#line 284
  return (rv);
}
}
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[(int )(((sizeof(struct sockaddr ) - sizeof(unsigned short )) -
                                  sizeof(in_port_t )) - sizeof(struct in_addr ))] ;
};
#line 303 "cheetah.c"
static void loghit(char *req , char *referrer , char *ua , int code , int size , struct sockaddr_in *remote ) 
{ char *t ;
  char *tmp ;
  char *i ;
  char *tmp___0 ;

  {
  {
  {
#line 304
  tmp = curtime();
  }
  {
#line 304
  t = tmp;
  }
  {
#line 305
  i = strchr((char const   *)referrer, ' ');
  }
  }
#line 305
  if ((unsigned int )i == (unsigned int )((void *)0)) {
    {
#line 305
    referrer = (char *)"-";
    }
  } else {
    {
#line 306
    referrer = i + 1;
    }
  }
  {
  {
#line 307
  i = strchr((char const   *)ua, ' ');
  }
  }
#line 307
  if ((unsigned int )i == (unsigned int )((void *)0)) {
    {
#line 307
    ua = (char *)"-";
    }
  } else {
    {
#line 308
    ua = i + 1;
    }
  }
  {
  {
#line 309
  tmp___0 = inet_ntoa(remote->sin_addr);
  }
  {
#line 309
  printf("%s - - [%s] - \"%s\" %d %d \"%s\" \"%s\"\n", tmp___0, t, req, code, size,
         referrer, ua);
  }
  {
#line 311
  fflush(stdout);
  }
  }
#line 312
  if ((int )(*(t + 0)) != 45) {
    {
    {
#line 312
    free((void *)t);
    }
    }
  }
#line 313
  return;
}
}
#line 54 "cheetah.c"
int loglevel  =    0;
#line 353 "/usr/include/stdio.h"
extern int snprintf(char *__s , size_t __maxlen , char const   *__format  , ...) ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 34 "/usr/include/sys/sendfile.h"
extern ssize_t sendfile(int __out_fd , int __in_fd , off_t *__offset , size_t __count ) ;
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void) ;
#line 72 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 268 "cheetah.c"
static char *last_modified(time_t *stmtime ) 
{ struct tm *gmt ;
  char *rv ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
  {
#line 270
  tmp = (char *)smalloc(100U);
  }
  {
#line 270
  rv = tmp;
  }
  {
#line 271
  gmt = gmtime((time_t const   *)stmtime);
  }
  }
#line 271
  if ((unsigned int )gmt == (unsigned int )((void *)0)) {
    {
    {
#line 271
    crit((char *)"gmtime() error.");
    }
    }
  }
  {
  {
#line 272
  tmp___0 = strftime(rv, 95U, "%a, %d %b %Y %T GMT", (struct tm  const  *)gmt);
  }
  }
#line 272
  if (tmp___0 == 0U) {
    {
    {
#line 273
    crit((char *)"strftime() error.");
    }
    }
  }
#line 274
  return (rv);
}
}
#line 48 "cheetah.c"
char *default_type  =    (char *)"text/plain";
#line 287 "/usr/include/string.h"
extern int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 562 "cheetah.c"
static char *get_mimetype(char *file ) 
{ char *comp ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 565
  tmp = strlen((char const   *)file);
  }
  {
#line 565
  comp = file + tmp;
  }
  }
  {
#line 565
  while (1) {
    original_while_15_continue: /* CIL Label */ ;
#line 565
    if (! ((unsigned int )comp > (unsigned int )file)) {
      goto original_while_15_break;
    }
#line 566
    if ((int )(*(comp + 0)) == 46) {
      {
      {
#line 567
      comp = comp + 1;
      }
      {
#line 568
      tmp___0 = strcasecmp((char const   *)comp, "html");
      }
      }
#line 568
      if (tmp___0 == 0) {
#line 568
        return ((char *)"text/html");
      }
      {
      {
#line 569
      tmp___1 = strcasecmp((char const   *)comp, "gif");
      }
      }
#line 569
      if (tmp___1 == 0) {
#line 569
        return ((char *)"image/gif");
      }
      {
      {
#line 570
      tmp___2 = strcasecmp((char const   *)comp, "jpg");
      }
      }
#line 570
      if (tmp___2 == 0) {
#line 570
        return ((char *)"image/jpeg");
      }
      {
      {
#line 571
      tmp___3 = strcasecmp((char const   *)comp, "png");
      }
      }
#line 571
      if (tmp___3 == 0) {
#line 571
        return ((char *)"image/png");
      }
      {
      {
#line 572
      tmp___4 = strcasecmp((char const   *)comp, "css");
      }
      }
#line 572
      if (tmp___4 == 0) {
#line 572
        return ((char *)"text/css");
      }
#line 573
      return (default_type);
    }
    {
#line 565
    comp = comp - 1;
    }
  }
  original_while_15_break: /* CIL Label */ ;
  }
#line 577
  return (default_type);
}
}
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 235 "/usr/include/sys/stat.h"
extern int lstat(char const   *__file , struct stat *__buf ) ;
#line 97 "cheetah.c"
char *msg404  =    (char *)"<html><head><title>404 Not Found</title></head><body><h1>404 Not Found</h1><h2>The document requested was not found.</h2></body></html>\n";
#line 60 "cheetah.c"
struct FSTRUCT {
   char *filename ;
   char *fullpath ;
   void *next ;
   char *content ;
   int content_length ;
   char *content_type ;
   char *last_modified ;
};
#line 60 "cheetah.c"
typedef struct FSTRUCT servable;
#line 99 "/usr/include/string.h"
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n ) ;
#line 71 "cheetah.c"
servable *files  =    (servable *)((void *)0);
#line 50 "cheetah.c"
int verbose  =    0;
#line 85 "/usr/include/string.h"
extern char *strncpy(char *__dest , char const   *__src , size_t __n ) ;
#line 72 "cheetah.c"
servable *index_page  =    (servable *)((void *)0);
#line 49 "cheetah.c"
int generate_index  =    0;
#line 96 "/usr/include/string.h"
extern int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 513 "cheetah.c"
static servable *match_request(char *req ) 
{ servable *rv ;
  char uri[1024] ;
  char *u ;
  int c ;
  int in ;
  int ptr ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 514
  rv = (servable *)((void *)0);
#line 516
  in = 0;
#line 516
  ptr = 0;
#line 519
  c = 0;
  }
  {
#line 519
  while (1) {
    original_while_13_continue: /* CIL Label */ ;
    {
    {
#line 519
    tmp___0 = strlen((char const   *)req);
    }
    }
#line 519
    if (! ((size_t )c < tmp___0)) {
      goto original_while_13_break;
    }
#line 520
    if (in == 1) {
      {
#line 520
      tmp = ptr;
#line 520
      ptr = ptr + 1;
#line 520
      uri[tmp] = (*(req + c));
      }
    }
#line 521
    if (in == 2) {
      goto original_while_13_break;
    } else {
#line 521
      if (ptr > 1000) {
        goto original_while_13_break;
      }
    }
#line 522
    if ((int )(*(req + c)) == 32) {
      {
#line 522
      in = in + 1;
      }
    }
    {
#line 519
    c = c + 1;
    }
  }
  original_while_13_break: /* CIL Label */ ;
  }
  {
  {
#line 524
  uri[ptr] = (char )'\000';
  }
  {
#line 524
  u = uri;
  }
  {
#line 526
  tmp___1 = strcmp((char const   *)(uri), "/ ");
  }
  }
#line 526
  if (tmp___1 == 0) {
#line 527
    if (generate_index == 1) {
#line 527
      return (index_page);
    } else {
      {
      {
#line 528
      strncpy(uri, "/index.html", sizeof(uri));
      }
      }
    }
  }
#line 530
  if ((int )uri[0] == 47) {
    {
#line 530
    u = u + 1;
    }
  }
#line 531
  if (verbose) {
    {
    {
#line 531
    printf("Checking for \"%s\"\n", u);
    }
    }
  }
#line 532
  if ((unsigned int )files == (unsigned int )((void *)0)) {
#line 532
    return ((servable *)((void *)0));
  }
  {
#line 534
  rv = files;
  }
  {
#line 535
  while (1) {
    original_while_14_continue: /* CIL Label */ ;
    {
    {
#line 536
    tmp___2 = strlen((char const   *)rv->filename);
    }
    {
#line 536
    tmp___3 = strncmp((char const   *)u, (char const   *)rv->filename, tmp___2);
    }
    }
#line 536
    if (tmp___3 == 0) {
#line 536
      return (rv);
    }
#line 537
    if ((unsigned int )rv->next == (unsigned int )((void *)0)) {
#line 537
      return ((servable *)((void *)0));
    }
    {
#line 538
    rv = (servable *)rv->next;
    }
  }
  original_while_14_break: /* CIL Label */ ;
  }
#line 541
  return ((servable *)((void *)0));
}
}
#line 291 "/usr/include/string.h"
extern int strncasecmp(char const   *__s1 , char const   *__s2 , size_t __n ) ;
#line 467 "cheetah.c"
static int get_method(char *req ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 468
  tmp = strncasecmp((char const   *)req, "GET", 3U);
  }
  }
#line 468
  if (tmp == 0) {
#line 468
    return (0);
  }
  {
  {
#line 469
  tmp___0 = strncasecmp((char const   *)req, "HEAD", 4U);
  }
  }
#line 469
  if (tmp___0 == 0) {
#line 469
    return (1);
  }
#line 470
  return (-1);
}
}
#line 53 "cheetah.c"
int print_headers  =    0;
#line 143 "/usr/include/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 320 "cheetah.c"

int __DSU_updated  =    0;
static void handle_request_old(int fd , struct sockaddr_in *remote ) 
{ int method ;
  struct stat curstat ;
  int rv ;
  int c ;
  int infd ;
  int h ;
  char inbuffer[2048] ;
  char *out ;
  char *lastmod ;
  char outb[1024] ;
  char *referrer ;
  char *ua ;
  char *request ;
  char *header ;
  servable *file ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  size_t tmp___9 ;
  ssize_t tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  ssize_t tmp___14 ;
  size_t tmp___15 ;
  ssize_t tmp___16 ;
  size_t tmp___17 ;
  ssize_t tmp___18 ;
  int *tmp___19 ;
  ssize_t tmp___20 ;
  size_t tmp___21 ;
  ssize_t tmp___22 ;
  size_t tmp___23 ;
  ssize_t tmp___24 ;
  ssize_t __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  servable *__cil_tmp49 ;
  size_t __cil_tmp50 ;
  ssize_t __cil_tmp51 ;
  size_t __cil_tmp52 ;
  ssize_t __cil_tmp53 ;
  size_t __cil_tmp54 ;
  size_t __cil_tmp55 ;
  ssize_t __cil_tmp56 ;
  size_t __cil_tmp57 ;
  ssize_t __cil_tmp58 ;
  size_t __cil_tmp59 ;
  ssize_t __cil_tmp60 ;
  int __cil_tmp61 ;
  char *__cil_tmp62 ;
  size_t __cil_tmp63 ;
  ssize_t __cil_tmp64 ;
  char *__cil_tmp65 ;
  size_t __cil_tmp66 ;
  ssize_t __cil_tmp67 ;
  size_t __cil_tmp68 ;
  ssize_t __cil_tmp69 ;
  int __cil_tmp70 ;
  int *__cil_tmp71 ;
  ssize_t __cil_tmp72 ;
  size_t __cil_tmp73 ;
  ssize_t __cil_tmp74 ;
  size_t __cil_tmp75 ;
  ssize_t __cil_tmp76 ;

  printf("old code request.");

  if (__DSU_updated == 1) {
  OLD1: assert(0);
  }


  {
  {
  {
#line 324
  h = 0;
  }
  {
#line 329
  referrer = (char *)"-";
  }
  {
#line 329
  ua = (char *)"";
  }
  {
#line 329
  request = (char *)((void *)0);
  }
  {
#line 333
  __cil_tmp45 = recv(fd, (void *)(inbuffer), sizeof(inbuffer), 0);
#line 333
  rv = __cil_tmp45;
  }
  }
#line 334
  if (rv == -1) {
    {
    {
#line 335
    warn((char *)"Error receiving request from client.");
    }
    }
#line 336
    return;
  }
  {
#line 340
  c = 0;
  }
  {
#line 340
  while (1) {
    original_while_3_continue: /* CIL Label */ ;
#line 340
    if (! (c < rv)) {
      goto original_while_3_break;
    }
#line 341
    if ((int )inbuffer[c] == 10) {
      {
#line 342
      inbuffer[c] = (char )'\000';
      }
#line 343
      if (c > 1) {
#line 343
        if ((int )inbuffer[c - 1] == 13) {
          {
#line 343
          inbuffer[c - 1] = (char )'\000';
          }
        }
      }
#line 344
      if (h != 0) {
        {
#line 345
        header = inbuffer + h;
        }
#line 346
        if (print_headers) {
          {
          {
#line 346
          printf("%s\n", header);
          }
          }
        }
        {
        {
#line 347
        __cil_tmp46 = strncmp((char const   *)header, "Referer:", 8U);
#line 347
        tmp = __cil_tmp46;
        }
        }
#line 347
        if (tmp == 0) {
          {
#line 347
          referrer = header;
          }
        }
        {
        {
#line 348
        __cil_tmp47 = strncmp((char const   *)header, "User-Agent:", 11U);
#line 348
        tmp___0 = __cil_tmp47;
        }
        }
#line 348
        if (tmp___0 == 0) {
          {
#line 348
          ua = header;
          }
        }
      } else {
        {
#line 350
        request = inbuffer;
        }
#line 351
        if (print_headers) {
          {
          {
#line 351
          printf("%s\n", request);
          }
          }
        }
      }
      {
#line 354
      h = c + 1;
      }
    }
    {
#line 340
    c = c + 1;
    }
  }
  original_while_3_break: /* CIL Label */ ;
  }
#line 358
  if ((unsigned int )request == (unsigned int )((void *)0)) {
#line 358
    return;
  }
#line 359
  if (verbose) {
    {
    {
#line 359
    printf("REQ: %s\n", request);
    }
    }
  }
  {
  {
#line 360
  __cil_tmp48 = get_method(request);
#line 360
  method = __cil_tmp48;
  }
  {
#line 363
  __cil_tmp49 = match_request(request);
#line 363
  file = __cil_tmp49;
  }
  }
#line 365
  if ((unsigned int )file == (unsigned int )((void *)0)) {
    {
    {
#line 366
    out = (char *)"HTTP/1.0 404 Not Found\r\n";
    }
    {
#line 367
    __cil_tmp50 = strlen((char const   *)out);
#line 367
    tmp___1 = __cil_tmp50;
    }
    {
#line 367
    __cil_tmp51 = send(fd, (void const   *)out, tmp___1, 0);
#line 367
    tmp___2 = __cil_tmp51;
    }
    }
#line 367
    if (tmp___2 == -1) {
      {
      {
#line 368
      warn((char *)"Error sending response to client.");
      }
      }
#line 368
      return;
    }
    {
    {
#line 371
    out = (char *)"Content-Type: text/html; charset=iso-8859-1\r\n";
    }
    {
#line 372
    __cil_tmp52 = strlen((char const   *)out);
#line 372
    tmp___3 = __cil_tmp52;
    }
    {
#line 372
    __cil_tmp53 = send(fd, (void const   *)out, tmp___3, 0);
#line 372
    tmp___4 = __cil_tmp53;
    }
    }
#line 372
    if (tmp___4 == -1) {
      {
      {
#line 373
      warn((char *)"Error sending response to client.");
      }
      }
#line 373
      return;
    }
    {
    {
#line 376
    __cil_tmp54 = strlen((char const   *)msg404);
#line 376
    tmp___5 = __cil_tmp54;
    }
    {
#line 376
    snprintf(outb, sizeof(outb), "Server: %s/%s\r\nContent-Length: %d\r\n\r\n", "Cheetah",
             "1.7", tmp___5);
    }
    {
#line 378
    __cil_tmp55 = strlen((char const   *)(outb));
#line 378
    tmp___6 = __cil_tmp55;
    }
    {
#line 378
    __cil_tmp56 = send(fd, (void const   *)(outb), tmp___6, 0);
#line 378
    tmp___7 = __cil_tmp56;
    }
    }
#line 378
    if (tmp___7 == -1) {
      {
      {
#line 379
      warn((char *)"Error sending response to client.");
      }
      }
#line 379
      return;
    }
    {
    {
#line 382
    __cil_tmp57 = strlen((char const   *)msg404);
#line 382
    c = (int )__cil_tmp57;
    }
    {
#line 384
    __cil_tmp58 = send(fd, (void const   *)msg404, (unsigned int )c, 0);
#line 384
    tmp___8 = __cil_tmp58;
    }
    }
#line 384
    if (tmp___8 == -1) {
      {
      {
#line 385
      warn((char *)"Error sending response to client.");
      }
      }
#line 385
      return;
    }
#line 388
    if (loglevel) {
      {
      {
#line 388
      loghit(request, referrer, ua, 404, c, remote);
      }
      }
    }
#line 389
    return;
  }
  {
  {
#line 393
  out = (char *)"HTTP/1.0 200 OK\r\n";
  }
  {
#line 395
  __cil_tmp59 = strlen((char const   *)out);
#line 395
  tmp___9 = __cil_tmp59;
  }
  {
#line 395
  __cil_tmp60 = send(fd, (void const   *)out, tmp___9, 0);
#line 395
  tmp___10 = __cil_tmp60;
  }
  }
#line 395
  if (tmp___10 == -1) {
    {
    {
#line 396
    warn((char *)"Error sending response to client.");
    }
    }
#line 396
    return;
  }
#line 399
  if ((unsigned int )file->filename != (unsigned int )((void *)0)) {
    {
    {
#line 401
    __cil_tmp61 = lstat((char const   *)file->fullpath, & curstat);
#line 401
    tmp___11 = __cil_tmp61;
    }
    }
#line 401
    if (tmp___11 == -1) {
      {
      {
#line 402
      warn((char *)"Error checking file.");
      }
      }
#line 402
      return;
    }
    {
    {
#line 406
    __cil_tmp62 = get_mimetype(file->filename);
#line 406
    tmp___12 = __cil_tmp62;
    }
    {
#line 406
    snprintf(outb, sizeof(outb), "Content-Type: %s\r\n", tmp___12);
    }
    {
#line 408
    __cil_tmp63 = strlen((char const   *)(outb));
#line 408
    tmp___13 = __cil_tmp63;
    }
    {
#line 408
    __cil_tmp64 = send(fd, (void const   *)(outb), tmp___13, 0);
#line 408
    tmp___14 = __cil_tmp64;
    }
    }
#line 408
    if (tmp___14 == -1) {
      {
      {
#line 409
      warn((char *)"Error sending response to client.");
      }
      }
#line 409
      return;
    }
    {
    {
#line 412
    __cil_tmp65 = last_modified(& curstat.st_mtim.tv_sec);
#line 412
    lastmod = __cil_tmp65;
    }
    }
#line 413
    if ((unsigned int )lastmod != (unsigned int )((void *)0)) {
      {
      {
#line 414
      snprintf(outb, sizeof(outb), "Last-modified: %s\r\n", lastmod);
      }
      {
#line 415
      __cil_tmp66 = strlen((char const   *)(outb));
#line 415
      tmp___15 = __cil_tmp66;
      }
      {
#line 415
      __cil_tmp67 = send(fd, (void const   *)(outb), tmp___15, 0);
#line 415
      tmp___16 = __cil_tmp67;
      }
      }
#line 415
      if (tmp___16 == -1) {
        {
        {
#line 416
        warn((char *)"Error sending response to client.");
        }
        }
#line 416
        return;
      }
      {
      {
#line 418
      free((void *)lastmod);
      }
      }
    }
    {
    {
#line 420
    snprintf(outb, sizeof(outb), "Content-Length: %d\r\nServer: %s/%s\r\n\r\n", (int )curstat.st_size,
             "Cheetah", "1.7");
    }
    {
#line 422
    __cil_tmp68 = strlen((char const   *)(outb));
#line 422
    tmp___17 = __cil_tmp68;
    }
    {
#line 422
    __cil_tmp69 = send(fd, (void const   *)(outb), tmp___17, 0);
#line 422
    tmp___18 = __cil_tmp69;
    }
    }
#line 422
    if (tmp___18 == -1) {
      {
      {
#line 423
      warn((char *)"Error sending response to client.");
      }
      }
#line 423
      return;
    }
#line 427
    if (method == 0) {
      {
      {
#line 428
      __cil_tmp70 = open((char const   *)file->fullpath, 0);
#line 428
      infd = __cil_tmp70;
      }
      }
#line 429
      if (infd == -1) {
        {
        {
#line 430
        __cil_tmp71 = __errno_location();
#line 430
        tmp___19 = __cil_tmp71;
        }
        {
#line 430
        printf("Couldn\'t open %s, error %d\n", file->fullpath, (*tmp___19));
        }
        }
#line 432
        return;
      }
      {
      {
#line 435
      __cil_tmp72 = sendfile(fd, infd, (off_t *)0, (unsigned int )curstat.st_size);
#line 435
      tmp___20 = __cil_tmp72;
      }
      }
#line 435
      if (tmp___20 == -1) {
        {
        {
#line 436
        warn((char *)"Error sending response to client.");
        }
        }
#line 436
        return;
      }
      {
      {
#line 445
      close(infd);
      }
      }
#line 446
      if (loglevel) {
        {
        {
#line 446
        loghit(request, referrer, ua, 200, (int )curstat.st_size, remote);
        }
        }
      }
    }
  } else {
#line 450
    if ((unsigned int )file->last_modified != (unsigned int )((char *)0)) {
      {
      {
#line 451
      snprintf(outb, sizeof(outb), "Last-Modified: %s\r\nContent-Type: %s\r\nContent-Length: %d\r\n\r\n",
               file->last_modified, file->content_type, file->content_length);
      }
      }
    } else {
      {
      {
#line 454
      snprintf(outb, sizeof(outb), "Content-Type: %s\r\nContent-Length: %d\r\n\r\n",
               file->content_type, file->content_length);
      }
      }
    }
#line 458
    if (loglevel) {
      {
      {
#line 458
      loghit(request, referrer, ua, 200, file->content_length, remote);
      }
      }
    }
    {
    {
#line 459
    __cil_tmp73 = strlen((char const   *)(outb));
#line 459
    tmp___21 = __cil_tmp73;
    }
    {
#line 459
    __cil_tmp74 = send(fd, (void const   *)(outb), tmp___21, 0);
#line 459
    tmp___22 = __cil_tmp74;
    }
    }
#line 459
    if (tmp___22 == -1) {
      {
      {
#line 460
      warn((char *)"Error sending response to client.");
      }
      }
#line 460
      return;
    }
#line 462
    if (method == 0) {
      {
      {
#line 463
      __cil_tmp75 = strlen((char const   *)file->content);
#line 463
      tmp___23 = __cil_tmp75;
      }
      {
#line 463
      __cil_tmp76 = send(fd, (void const   *)file->content, tmp___23, 0);
#line 463
      tmp___24 = __cil_tmp76;
      }
      }
#line 463
      if (tmp___24 == -1) {
        {
        {
#line 464
        warn((char *)"Error sending response to client.");
        }
        }
#line 464
        return;
      }
    }
  }
#line 468
  return;
}
}
#line 89 "/usr/include/string.h"
extern char *strcat(char *__dest , char const   *__src ) ;
#line 207 "/usr/include/sys/stat.h"
extern int stat(char const   *__file , struct stat *__buf ) ;
#line 567 "/usr/include/stdlib.h"
extern void *realloc(void *__ptr , size_t __size ) ;
#line 690 "/usr/include/unistd.h"
extern __pid_t fork(void) ;
#line 218 "/usr/include/sys/socket.h"
extern int shutdown(int __fd , int __how ) ;
#line 544 "cheetah.c"
static int safesend_new(int fd , char *out ) 
{ int rv ;
  size_t tmp ;
  size_t __cil_tmp5 ;
  ssize_t __cil_tmp6 ;

  if (__DSU_updated == 0)
    NEW1: assert(0);

  {
  {
  {
#line 547
  __cil_tmp5 = strlen((char const   *)out);
#line 547
  tmp = __cil_tmp5;
  }
  {
#line 547
  __cil_tmp6 = send(fd, (void const   *)out, tmp, 0);
#line 547
  rv = __cil_tmp6;
  }
  }
#line 547
  if (rv == -1) {
    {
    {
#line 548
    warn((char *)"Error sending data to client.");
    }
    }
  }
#line 551
  return (rv);
}
}
#line 315 "cheetah.c"
static void handle_request_new(int fd , struct sockaddr_in *remote ) 
{ int method ;
  struct stat curstat ;
  int rv ;
  int c ;
  int infd ;
  int h ;
  char inbuffer[2048] ;
  char *out ;
  char *lastmod ;
  char outb[1024] ;
  char *referrer ;
  char *ua ;
  char *request ;
  char *header ;
  int content_length ;
  servable *file ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  ssize_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  ssize_t __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  servable *__cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  size_t __cil_tmp49 ;
  int __cil_tmp50 ;
  size_t __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  char *__cil_tmp56 ;
  int __cil_tmp57 ;
  char *__cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int *__cil_tmp63 ;
  ssize_t __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;

  if (__DSU_updated == 0)
    NEW2: assert(0);

  printf("new code request.");
  {
  {
  {
#line 319
  h = 0;
  }
  {
#line 324
  referrer = (char *)"-";
  }
  {
#line 324
  ua = (char *)"";
  }
  {
#line 324
  request = (char *)((void *)0);
  }
  {
#line 326
  content_length = 0;
  }
  {
#line 329
  __cil_tmp41 = recv(fd, (void *)(inbuffer), sizeof(inbuffer), 0);
#line 329
  rv = __cil_tmp41;
  }
  }
#line 330
  if (rv == -1) {
    {
    {
#line 331
    warn((char *)"Error receiving request from client.");
    }
    }
#line 332
    return;
  }
  {
#line 336
  c = 0;
  }
  {
#line 336
  while (1) {
    original_while_11_continue: /* CIL Label */ ;
#line 336
    if (! (c < rv)) {
      goto original_while_11_break;
    }
#line 337
    if ((int )inbuffer[c] == 10) {
      {
#line 338
      inbuffer[c] = (char )'\000';
      }
#line 339
      if (c > 1) {
#line 339
        if ((int )inbuffer[c - 1] == 13) {
          {
#line 339
          inbuffer[c - 1] = (char )'\000';
          }
        }
      }
#line 340
      if (h != 0) {
        {
#line 341
        header = inbuffer + h;
        }
#line 342
        if (print_headers) {
          {
          {
#line 342
          printf("%s\n", header);
          }
          }
        }
        {
        {
#line 343
        __cil_tmp42 = strncmp((char const   *)header, "Referer:", 8U);
#line 343
        tmp = __cil_tmp42;
        }
        }
#line 343
        if (tmp == 0) {
          {
#line 343
          referrer = header;
          }
        }
        {
        {
#line 344
        __cil_tmp43 = strncmp((char const   *)header, "User-Agent:", 11U);
#line 344
        tmp___0 = __cil_tmp43;
        }
        }
#line 344
        if (tmp___0 == 0) {
          {
#line 344
          ua = header;
          }
        }
      } else {
        {
#line 346
        request = inbuffer;
        }
#line 347
        if (print_headers) {
          {
          {
#line 347
          printf("%s\n", request);
          }
          }
        }
      }
      {
#line 350
      h = c + 1;
      }
    }
    {
#line 336
    c = c + 1;
    }
  }
  original_while_11_break: /* CIL Label */ ;
  }
#line 354
  if ((unsigned int )request == (unsigned int )((void *)0)) {
#line 354
    return;
  }
#line 355
  if (verbose) {
    {
    {
#line 355
    printf("REQ: %s\n", request);
    }
    }
  }
  {
  {
#line 356
  __cil_tmp44 = get_method(request);
#line 356
  method = __cil_tmp44;
  }
  {
#line 359
  __cil_tmp45 = match_request(request);
#line 359
  file = __cil_tmp45;
  }
  }
#line 361
  if ((unsigned int )file == (unsigned int )((void *)0)) {
    {
    {
#line 362
    out = (char *)"HTTP/1.0 404 Not Found\r\n";
    }
    {
    __cil_tmp46 = safesend_new(fd, out);
    tmp___1 = __cil_tmp46;
    }
    }
#line 363
    if (tmp___1 == -1) {
#line 363
      return;
    }
    {
    {
#line 365
    snprintf(outb, sizeof(outb), "Server: %s/%s\r\n", "Cheetah", "1.8");
    }
    {
    __cil_tmp47 = safesend_new(fd, outb);
    tmp___2 = __cil_tmp47;
    }
    }
#line 367
    if (tmp___2 == -1) {
#line 367
      return;
    }
    {
#line 369
    method = 0;
    }
#line 369
    if (method) {
      {
      {
#line 370
      out = (char *)"Content-Type: text/html; charset=iso-8859-1\r\n";
      }
      {
      __cil_tmp48 = safesend_new(fd, out);
      tmp___3 = __cil_tmp48;
      }
      }
#line 371
      if (tmp___3 == -1) {
#line 371
        return;
      }
      {
      {
#line 373
      __cil_tmp49 = strlen((char const   *)msg404);
#line 373
      tmp___4 = __cil_tmp49;
      }
      {
#line 373
      snprintf(outb, sizeof(outb), "Content-Length: %d\r\n", tmp___4);
      }
      {
      __cil_tmp50 = safesend_new(fd, outb);
      tmp___5 = __cil_tmp50;
      }
      }
#line 375
      if (tmp___5 == -1) {
#line 375
        return;
      }
      {
      {
#line 378
      __cil_tmp51 = strlen((char const   *)msg404);
#line 378
      c = (int )__cil_tmp51;
      }
      {
      __cil_tmp52 = safesend_new(fd, msg404);
      tmp___6 = __cil_tmp52;
      }
      }
#line 379
      if (tmp___6 == -1) {
#line 379
        return;
      }
    }
    {
    {
#line 382
    snprintf(outb, sizeof(outb), "\r\n");
    }
    {
    __cil_tmp53 = safesend_new(fd, outb);
    tmp___7 = __cil_tmp53;
    }
    }
#line 383
    if (tmp___7 == -1) {
#line 383
      return;
    }
#line 385
    if (loglevel) {
      {
      {
#line 385
      loghit(request, referrer, ua, 404, c, remote);
      }
      }
    }
#line 386
    return;
  }
  {
  {
#line 390
  out = (char *)"HTTP/1.0 200 OK\r\n";
  }
  {
  __cil_tmp54 = safesend_new(fd, out);
  tmp___8 = __cil_tmp54;
  }
  }
#line 391
  if (tmp___8 == -1) {
#line 391
    return;
  }
#line 393
  if ((unsigned int )file->filename != (unsigned int )((void *)0)) {
    {
    {
#line 395
    __cil_tmp55 = lstat((char const   *)file->fullpath, & curstat);
#line 395
    tmp___9 = __cil_tmp55;
    }
    }
#line 395
    if (tmp___9 == -1) {
      {
      {
#line 396
      warn((char *)"Error checking file.");
      }
      }
#line 396
      return;
    }
    {
    {
#line 400
    __cil_tmp56 = get_mimetype(file->filename);
#line 400
    tmp___10 = __cil_tmp56;
    }
    {
#line 400
    snprintf(outb, sizeof(outb), "Content-Type: %s\r\n", tmp___10);
    }
    {
    __cil_tmp57 = safesend_new(fd, outb);
    tmp___11 = __cil_tmp57;
    }
    }
#line 401
    if (tmp___11 == -1) {
#line 401
      return;
    }
    {
    {
#line 403
    __cil_tmp58 = last_modified(& curstat.st_mtim.tv_sec);
#line 403
    lastmod = __cil_tmp58;
    }
    }
#line 404
    if ((unsigned int )lastmod != (unsigned int )((void *)0)) {
      {
      {
#line 405
      snprintf(outb, sizeof(outb), "Last-modified: %s\r\n", lastmod);
      }
      {
      __cil_tmp59 = safesend_new(fd, outb);
      tmp___12 = __cil_tmp59;
      }
      }
#line 406
      if (tmp___12 == -1) {
#line 406
        return;
      }
      {
      {
#line 407
      free((void *)lastmod);
      }
      }
    }
#line 410
    if (method == 0) {
      {
      {
#line 411
      snprintf(outb, sizeof(outb), "Content-Length: %d\r\n", (int )curstat.st_size);
      }
      {
      __cil_tmp60 = safesend_new(fd, outb);
      tmp___13 = __cil_tmp60;
      }
      }
#line 413
      if (tmp___13 == -1) {
#line 413
        return;
      }
    }
    {
    {
#line 416
    snprintf(outb, sizeof(outb), "Server: %s/%s\r\n\r\n", "Cheetah", "1.8");
    }
    {
    __cil_tmp61 = safesend_new(fd, outb);
    tmp___14 = __cil_tmp61;
    }
    }
#line 418
    if (tmp___14 == -1) {
#line 418
      return;
    }
#line 421
    if (method == 0) {
      {
      {
#line 422
      __cil_tmp62 = open((char const   *)file->fullpath, 0);
#line 422
      infd = __cil_tmp62;
      }
      }
#line 423
      if (infd == -1) {
        {
        {
#line 424
        __cil_tmp63 = __errno_location();
#line 424
        tmp___15 = __cil_tmp63;
        }
        {
#line 424
        printf("Couldn\'t open %s, error %d\n", file->fullpath, (*tmp___15));
        }
        }
#line 426
        return;
      }
      {
      {
#line 429
      __cil_tmp64 = sendfile(fd, infd, (off_t *)0, (unsigned int )curstat.st_size);
#line 429
      tmp___16 = __cil_tmp64;
      }
      }
#line 429
      if (tmp___16 == -1) {
        {
        {
#line 430
        warn((char *)"Error sending response to client.");
        }
        }
#line 430
        return;
      }
      {
      {
#line 439
      close(infd);
      }
      }
    }
#line 442
    if (loglevel) {
      {
      {
#line 442
      loghit(request, referrer, ua, 200, (int )curstat.st_size, remote);
      }
      }
    }
  } else {
    {
#line 445
    content_length = 0;
    }
#line 446
    if (method == 0) {
      {
#line 447
      content_length = file->content_length;
      }
    }
#line 450
    if ((unsigned int )file->last_modified != (unsigned int )((char *)0)) {
      {
      {
#line 451
      snprintf(outb, sizeof(outb), "Last-Modified: %s\r\n", file->last_modified);
      }
      {
      __cil_tmp65 = safesend_new(fd, outb);
      tmp___17 = __cil_tmp65;
      }
      }
#line 453
      if (tmp___17 == -1) {
#line 453
        return;
      }
    }
    {
    {
#line 456
    snprintf(outb, sizeof(outb), "Content-Type: %s\r\nContent-Length: %d\r\n\r\n",
             file->content_type, content_length);
    }
    {
    __cil_tmp66 = safesend_new(fd, outb);
    tmp___18 = __cil_tmp66;
    }
    }
#line 458
    if (tmp___18 == -1) {
#line 458
      return;
    }
#line 460
    if (loglevel) {
      {
      {
#line 460
      loghit(request, referrer, ua, 200, file->content_length, remote);
      }
      }
    }
#line 461
    if (method == 0) {
      {
      {
      __cil_tmp67 = safesend_new(fd, file->content);
      tmp___19 = __cil_tmp67;
      }
      }
#line 462
      if (tmp___19 == -1) {
#line 462
        return;
      }
    }
  }
#line 465
  return;
}
}



#line 291 "cheetah.c"
static void handle_connection(int fd , struct sockaddr_in *remote ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
  {
  if (__DSU_updated) {
    {
    handle_request_new(fd, remote);
    }
  } else {
    {
    handle_request_old(fd, remote);
    }
  }
  }
  {
#line 295
  tmp = shutdown(fd, 2);
  }
  }
#line 295
  if (tmp == -1) {
    {
    {
#line 296
    warn((char *)"Error shutting down client socket.");
    }
    }
#line 297
    return;
  }
  {
  {
#line 300
  tmp___0 = close(fd);
  }
  }
#line 300
  if (tmp___0 == -1) {
    {
    {
#line 300
    warn((char *)"Error closing client socket.");
    }
    }
  }
#line 301
  return;
}
}
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
int __DSU_updateCount  =    0;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 155 "/usr/include/dirent.h"
extern struct dirent *readdir(DIR *__dirp ) ;
#line 51 "cheetah.c"
int background  =    0;
#line 55 "cheetah.c"
int links  =    0;
#line 52 "cheetah.c"
int sockfd  =    -1;
#line 554 "cheetah.c"
static void sigcatch(int signal___0 ) 
{ 

  {
#line 555
  if (verbose) {
    {
    {
#line 555
    printf("Signal caught, exiting.\n");
    }
    }
  }
#line 556
  if (sockfd != -1) {
    {
    {
#line 557
    close(sockfd);
    }
    {
#line 558
    exit(0);
    }
    }
  }
#line 560
  return;
}
}
#line 194 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 243 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 110 "/usr/include/sys/socket.h"
extern int bind(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 112 "/usr/include/sys/wait.h"
extern __pid_t wait(void *__stat_loc ) ;
#line 209 "/usr/include/sys/socket.h"
extern int accept(int __fd , struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 267 "/usr/include/netinet/in.h"
extern uint16_t htons(uint16_t __hostshort ) ;
#line 519 "/usr/include/unistd.h"
extern void _exit(int __status ) ;
#line 199 "/usr/include/sys/socket.h"
extern int listen(int __fd , int __n ) ;
#line 260 "/usr/include/string.h"
extern void bzero(void *__s , size_t __n ) ;
#line 100 "/usr/include/sys/socket.h"
extern int socket(int __domain , int __type , int __protocol ) ;
#line 92 "/usr/include/signal.h"
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 473 "cheetah.c"
static servable *gen_index(void) 
{ servable *myi ;
  servable *ptr ;
  char *content ;
  char *st ;
  char *en ;
  int sz ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
  {
#line 474
  myi = (servable *)((void *)0);
  }
  {
#line 475
  ptr = files;
  }
  {
#line 476
  content = (char *)((void *)0);
  }
  {
#line 479
  st = (char *)"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\r\n\r\n<html><head><title>Index of /</title></head><body><h2>Index of /</h2><ul>\n";
  }
  {
#line 480
  en = (char *)"</ul><p><i>Powered by <a href=\"http://www.neuro-tech.net/cheetah\">Cheetah</a></i>.</body></html>\n";
  }
  {
#line 481
  sz = 0;
  }
  {
#line 482
  myi = (servable *)smalloc(sizeof(servable ) + 2U);
  }
  {
#line 483
  myi->filename = (char *)((void *)0);
  }
  {
#line 484
  myi->fullpath = (char *)((void *)0);
  }
  {
#line 486
  tmp = strlen((char const   *)st);
  }
  {
#line 486
  tmp___0 = strlen((char const   *)en);
  }
  {
#line 486
  sz = (int )(tmp + tmp___0);
  }
  {
#line 487
  content = (char *)smalloc((unsigned int )(sz + 2));
  }
  {
#line 489
  strncpy(content, (char const   *)st, (unsigned int )(sz + 1));
  }
  }
  {
#line 492
  while (1) {
    original_while_12_continue: /* CIL Label */ ;
#line 492
    if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
      goto original_while_12_break;
    }
    {
    {
#line 493
    tmp___1 = strlen((char const   *)ptr->filename);
    }
    {
#line 493
    sz = (int )((size_t )sz + tmp___1 * 2U);
    }
    {
#line 494
    sz = sz + 40;
    }
    {
#line 495
    tmp___2 = realloc((void *)content, (unsigned int )sz);
    }
    }
#line 495
    if (! tmp___2) {
      {
      {
#line 495
      printf("Memory allocation error.\n");
      }
      {
#line 495
      exit(0);
      }
      }
    }
    {
    {
#line 496
    strcat(content, "<li><a href=\"");
    }
    {
#line 497
    strcat(content, (char const   *)ptr->filename);
    }
    {
#line 498
    strcat(content, "\">");
    }
    {
#line 499
    strcat(content, (char const   *)ptr->filename);
    }
    {
#line 500
    strcat(content, "</a></li>\n");
    }
    {
#line 501
    ptr = (servable *)ptr->next;
    }
    }
  }
  original_while_12_break: /* CIL Label */ ;
  }
  {
  {
#line 504
  strcat(content, (char const   *)en);
  }
  {
#line 505
  myi->content = content;
  }
  {
#line 506
  myi->content_length = (int )strlen((char const   *)content);
  }
  {
#line 507
  myi->content_type = (char *)"text/html";
  }
  {
#line 508
  myi->last_modified = (char *)((void *)0);
  }
  }
#line 510
  return (myi);
}
}
#line 74 "cheetah.c"
static void help_new(void) 
{ 
  if (__DSU_updated == 0)
    NEW3: assert(0);

  {
  {
  {
#line 75
  printf("Usage: cheetah [OPTIONS] [DIRECTORY]\n");
  }
  {
#line 76
  printf("Serves up the files listed in the specified directory using HTTP.\n");
  }
  {
#line 77
  printf("Note that the list of files is scanned on startup only - to rescan the files\n");
  }
  {
#line 78
  printf("for additions, you must restart cheetah.\n\n");
  }
  {
#line 79
  printf("-d, --default-type   default mime-type if file isn\'t found in the database,\n");
  }
  {
#line 80
  printf("                       defaults to text/plain\n");
  }
  {
#line 81
  printf("-b                   background mode (disables console output, and allows\n");
  }
  {
#line 82
  printf("                       multiple requests to be served simultaneously)\n");
  }
  {
#line 83
  printf("-g                   generate indices for the root directory when no index.html\n");
  }
  {
#line 84
  printf("                       is found\n");
  }
  {
#line 85
  printf("    --headers        print out all client request headers\n");
  }
  {
#line 86
  printf("-l, --log            log (in combined log format) all requests to standard\n");
  }
  {
#line 87
  printf("                       output\n");
  }
  {
#line 88
  printf("-p, --port           port to listen for requests on, defaults to 8000\n");
  }
  {
#line 89
  printf("-s                   follow symbolic links\n");
  }
  {
#line 90
  printf("-v                   verbose output\n");
  }
  {
#line 91
  printf("-V                   print version and exit\n");
  }
  {
#line 92
  printf("-h, --help           display this message and exit\n");
  }
  {
#line 93
  printf("\n");
  }
  {
#line 94
  printf("Please see http://www.neuro-tech.net/cheetah for updates and bug reporting.\n");
  }
  }
#line 95
  return;
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 144 "/usr/include/stdlib.h"
extern int atoi(char const   *__nptr ) ;
#line 115 "cheetah.c"
int main_new(int argc , char **argv ) 
{ int port ;
  struct sockaddr_in my_addr ;
  struct sockaddr_in remote_addr ;
  int sin_size ;
  int flength ;
  char *fullpath ;
  char *dir ;
  DIR *dirpnt ;
  struct dirent *curdir ;
  struct stat curstat ;
  servable *curfile ;
  servable *lastfile ;
  int newfd ;
  int i ;
  int fr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  __pid_t tmp___14 ;
  __sighandler_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  __sighandler_t tmp___25 ;
  __sighandler_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  DIR *__cil_tmp66 ;
  __pid_t __cil_tmp67 ;
  __pid_t __cil_tmp68 ;
  __sighandler_t __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  struct dirent *__cil_tmp73 ;
  size_t __cil_tmp74 ;
  size_t __cil_tmp75 ;
  void *__cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  size_t __cil_tmp81 ;
  void *__cil_tmp82 ;
  servable *__cil_tmp83 ;
  __sighandler_t __cil_tmp84 ;
  __sighandler_t __cil_tmp85 ;
  int __cil_tmp86 ;
  uint16_t __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  __pid_t __cil_tmp91 ;

  if (__DSU_updated == 0)
    NEW4: assert(0);


  {
  {
#line 116
  port = 8000;
#line 121
  fullpath = (char *)((void *)0);
#line 122
  dir = (char *)((void *)0);
#line 124
  curdir = (struct dirent *)((void *)0);
#line 126
  curfile = (servable *)((void *)0);
#line 127
  lastfile = (servable *)((void *)0);
  }
#line 132
  if (argc < 2) {
    {
    {
    help_new();
    }
    {
#line 132
    exit(0);
    }
    }
  }
  {
#line 134
  i = 1;
  }
  {
#line 134
  while (1) {
    original_while_8_continue: /* CIL Label */ ;
#line 134
    if (! (i < argc)) {
      goto original_while_8_break;
    }
    {
    {
#line 135
    __cil_tmp49 = strcmp((char const   *)(*(argv + i)), "-V");
#line 135
    tmp___13 = __cil_tmp49;
    }
    }
#line 135
    if (tmp___13 == 0) {
      {
      {
#line 136
      printf("You are using %s.\n", "Cheetah");
      }
      {
#line 137
      exit(0);
      }
      }
    } else {
      {
      {
#line 138
      __cil_tmp50 = strcmp((char const   *)(*(argv + i)), "--help");
#line 138
      tmp___11 = __cil_tmp50;
      }
      }
#line 138
      if (tmp___11 == 0) {
        {
        {
        help_new();
        }
        {
#line 140
        exit(0);
        }
        }
      } else {
        {
        {
#line 138
        __cil_tmp51 = strcmp((char const   *)(*(argv + i)), "-h");
#line 138
        tmp___12 = __cil_tmp51;
        }
        }
#line 138
        if (tmp___12 == 0) {
          {
          {
          help_new();
          }
          {
#line 140
          exit(0);
          }
          }
        } else {
          {
          {
#line 141
          __cil_tmp52 = strcmp((char const   *)(*(argv + i)), "--default-type");
#line 141
          tmp___9 = __cil_tmp52;
          }
          }
#line 141
          if (tmp___9 == 0) {
            {
#line 142
            default_type = (*(argv + (i + 1)));
#line 142
            i = i + 1;
            }
          } else {
            {
            {
#line 141
            __cil_tmp53 = strcmp((char const   *)(*(argv + i)), "-d");
#line 141
            tmp___10 = __cil_tmp53;
            }
            }
#line 141
            if (tmp___10 == 0) {
              {
#line 142
              default_type = (*(argv + (i + 1)));
#line 142
              i = i + 1;
              }
            } else {
              {
              {
#line 143
              __cil_tmp54 = strcmp((char const   *)(*(argv + i)), "--headers");
#line 143
              tmp___7 = __cil_tmp54;
              }
              }
#line 143
              if (tmp___7 == 0) {
                {
#line 144
                print_headers = 1;
                }
              } else {
                {
                {
#line 143
                __cil_tmp55 = strcmp((char const   *)(*(argv + i)), "-h");
#line 143
                tmp___8 = __cil_tmp55;
                }
                }
#line 143
                if (tmp___8 == 0) {
                  {
#line 144
                  print_headers = 1;
                  }
                } else {
                  {
                  {
#line 145
                  __cil_tmp56 = strcmp((char const   *)(*(argv + i)), "-p");
#line 145
                  tmp___5 = __cil_tmp56;
                  }
                  }
#line 145
                  if (tmp___5 == 0) {
                    {
                    {
#line 146
                    __cil_tmp57 = atoi((char const   *)(*(argv + (i + 1))));
#line 146
                    port = __cil_tmp57;
                    }
                    {
#line 146
                    i = i + 1;
                    }
                    }
                  } else {
                    {
                    {
#line 145
                    __cil_tmp58 = strcmp((char const   *)(*(argv + i)), "--port");
#line 145
                    tmp___6 = __cil_tmp58;
                    }
                    }
#line 145
                    if (tmp___6 == 0) {
                      {
                      {
#line 146
                      __cil_tmp59 = atoi((char const   *)(*(argv + (i + 1))));
#line 146
                      port = __cil_tmp59;
                      }
                      {
#line 146
                      i = i + 1;
                      }
                      }
                    } else {
                      {
                      {
#line 147
                      __cil_tmp60 = strcmp((char const   *)(*(argv + i)), "-l");
#line 147
                      tmp___3 = __cil_tmp60;
                      }
                      }
#line 147
                      if (tmp___3 == 0) {
                        {
#line 148
                        loglevel = 1;
                        }
                      } else {
                        {
                        {
#line 147
                        __cil_tmp61 = strcmp((char const   *)(*(argv + i)), "--log");
#line 147
                        tmp___4 = __cil_tmp61;
                        }
                        }
#line 147
                        if (tmp___4 == 0) {
                          {
#line 148
                          loglevel = 1;
                          }
                        } else {
                          {
                          {
#line 149
                          __cil_tmp62 = strcmp((char const   *)(*(argv + i)), "-v");
#line 149
                          tmp___2 = __cil_tmp62;
                          }
                          }
#line 149
                          if (tmp___2 == 0) {
                            {
#line 149
                            verbose = verbose + 1;
                            }
                          } else {
                            {
                            {
#line 150
                            __cil_tmp63 = strcmp((char const   *)(*(argv + i)), "-g");
#line 150
                            tmp___1 = __cil_tmp63;
                            }
                            }
#line 150
                            if (tmp___1 == 0) {
                              {
#line 150
                              generate_index = 1;
                              }
                            } else {
                              {
                              {
#line 151
                              __cil_tmp64 = strcmp((char const   *)(*(argv + i)),
                                                   "-s");
#line 151
                              tmp___0 = __cil_tmp64;
                              }
                              }
#line 151
                              if (tmp___0 == 0) {
                                {
#line 151
                                links = 1;
                                }
                              } else {
                                {
                                {
#line 152
                                __cil_tmp65 = strcmp((char const   *)(*(argv + i)),
                                                     "-b");
#line 152
                                tmp = __cil_tmp65;
                                }
                                }
#line 152
                                if (tmp == 0) {
                                  {
#line 152
                                  background = 1;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 134
    i = i + 1;
    }
  }
  original_while_8_break: /* CIL Label */ ;
  }
  {
  {
#line 155
  dir = (*(argv + (argc - 1)));
  }
  {
#line 156
  __cil_tmp66 = opendir((char const   *)dir);
#line 156
  dirpnt = __cil_tmp66;
  }
  }
#line 157
  if ((unsigned int )dirpnt == (unsigned int )((void *)0)) {
    {
    {
#line 158
    printf("Invalid directory - %s.\n", dir);
    }
    {
    help_new();
    }
    {
#line 158
    exit(1);
    }
    }
  }
#line 161
  if (background) {
    {
    {
#line 162
    verbose = 0;
    }
    {
#line 163
    __cil_tmp67 = fork();
#line 163
    rv = __cil_tmp67;
    }
    }
#line 164
    if (rv == -1) {
      {
      {
#line 165
      crit((char *)"Error forking");
      }
      }
    } else {
#line 166
      if (rv > 0) {
        {
        {
#line 168
        _exit(0);
        }
        }
      }
    }
    {
    {
#line 170
    __cil_tmp68 = setsid();
#line 170
    tmp___14 = __cil_tmp68;
    }
    }
#line 170
    if (tmp___14 == -1) {
      {
      {
#line 170
      crit((char *)"Couldn\'t create SID session.");
      }
      }
    }
    {
    {
#line 171
    __cil_tmp69 = signal(17, (void (*)(int  ))1);
#line 171
    tmp___15 = __cil_tmp69;
    }
    }
#line 171
    if ((unsigned int )tmp___15 == (unsigned int )((void (*)(int  ))-1)) {
      {
      {
#line 172
      crit((char *)"Couldn\'t initialize signal handlers.");
      }
      }
    }
    {
    {
#line 174
    __cil_tmp70 = close(0);
#line 174
    tmp___16 = __cil_tmp70;
    }
    }
#line 174
    if (tmp___16 == -1) {
      {
      {
#line 175
      crit((char *)"Couldn\'t close streams.");
      }
      }
    } else {
      {
      {
#line 174
      __cil_tmp71 = close(1);
#line 174
      tmp___17 = __cil_tmp71;
      }
      }
#line 174
      if (tmp___17 == -1) {
        {
        {
#line 175
        crit((char *)"Couldn\'t close streams.");
        }
        }
      } else {
        {
        {
#line 174
        __cil_tmp72 = close(2);
#line 174
        tmp___18 = __cil_tmp72;
        }
        }
#line 174
        if (tmp___18 == -1) {
          {
          {
#line 175
          crit((char *)"Couldn\'t close streams.");
          }
          }
        }
      }
    }
  }
  {
#line 179
  while (1) {
    original_while_9_continue: /* CIL Label */ ;
    {
    {
#line 179
    __cil_tmp73 = readdir(dirpnt);
#line 179
    curdir = __cil_tmp73;
    }
    }
#line 179
    if (! curdir) {
      goto original_while_9_break;
    }
    {
    {
#line 180
    __cil_tmp74 = strlen((char const   *)(curdir->d_name));
#line 180
    tmp___19 = __cil_tmp74;
    }
    {
#line 180
    __cil_tmp75 = strlen((char const   *)dir);
#line 180
    tmp___20 = __cil_tmp75;
    }
    {
#line 180
    flength = (int )((tmp___19 + tmp___20) + 4U);
    }
    {
#line 181
    __cil_tmp76 = smalloc((unsigned int )flength);
#line 181
    fullpath = (char *)__cil_tmp76;
    }
    {
#line 182
    snprintf(fullpath, (unsigned int )(flength + 2), "%s/%s", dir, curdir->d_name);
    }
    }
#line 183
    if (links == 1) {
      {
      {
#line 184
      __cil_tmp77 = lstat((char const   *)fullpath, & curstat);
#line 184
      rv = __cil_tmp77;
      }
      }
    } else {
      {
      {
#line 186
      __cil_tmp78 = stat((char const   *)fullpath, & curstat);
#line 186
      rv = __cil_tmp78;
      }
      }
    }
#line 189
    if (rv != 0) {
      {
      {
#line 190
      fprintf(stderr, "Error statting file %s/%s\n", dir, curdir->d_name);
      }
      }
      goto original_while_9_continue;
    }
#line 195
    if ((curstat.st_mode & 61440U) == 32768U) {
#line 195
      if ((int )curdir->d_name[0] != 46) {
#line 196
        if ((unsigned int )files == (unsigned int )((void *)0)) {
          {
          {
#line 197
          __cil_tmp79 = smalloc(sizeof(servable ) + 2U);
#line 197
          files = (servable *)__cil_tmp79;
          }
          {
#line 197
          curfile = files;
          }
          }
        } else {
          {
          {
#line 199
          __cil_tmp80 = smalloc(sizeof(servable ) + 2U);
#line 199
          curfile = (servable *)__cil_tmp80;
          }
          }
        }
        {
        {
#line 202
        __cil_tmp81 = strlen((char const   *)(curdir->d_name));
#line 202
        flength = (int )__cil_tmp81;
        }
        {
#line 203
        __cil_tmp82 = smalloc((unsigned int )(flength + 2));
#line 203
        curfile->filename = (char *)__cil_tmp82;
        }
        {
#line 204
        strncpy(curfile->filename, (char const   *)(curdir->d_name), (unsigned int )(flength +
                                                                                     1));
        }
        {
#line 205
        curfile->fullpath = fullpath;
        }
        {
#line 206
        curfile->next = (void *)0;
        }
        {
#line 207
        curfile->content = (char *)((void *)0);
        }
        }
#line 209
        if ((unsigned int )lastfile == (unsigned int )((void *)0)) {
          {
#line 210
          lastfile = curfile;
          }
        } else {
          {
#line 212
          lastfile->next = (void *)curfile;
#line 213
          lastfile = curfile;
          }
        }
#line 216
        if (verbose) {
          {
          {
#line 216
          printf("Parsed %s as %s.\n", fullpath, curfile->filename);
          }
          }
        }
      } else {
        {
        {
#line 218
        free((void *)fullpath);
        }
        }
      }
    } else {
      {
      {
#line 218
      free((void *)fullpath);
      }
      }
    }
  }
  original_while_9_break: /* CIL Label */ ;
  }
#line 223
  if (generate_index == 1) {
    {
    {
#line 223
    __cil_tmp83 = gen_index();
#line 223
    index_page = __cil_tmp83;
    }
    }
  }
#line 226
  if (verbose) {
    {
    {
#line 226
    printf("Using system\'s sendfile functionality.\n");
    }
    }
  }
  {
  {
#line 230
  __cil_tmp84 = signal(15, & sigcatch);
#line 230
  tmp___25 = __cil_tmp84;
  }
  }
#line 230
  if ((unsigned int )tmp___25 == (unsigned int )((void (*)(int  ))-1)) {
    {
    {
#line 231
    crit((char *)"Couldn\'t setup signal traps.");
    }
    }
  } else {
    {
    {
#line 230
    __cil_tmp85 = signal(2, & sigcatch);
#line 230
    tmp___26 = __cil_tmp85;
    }
    }
#line 230
    if ((unsigned int )tmp___26 == (unsigned int )((void (*)(int  ))-1)) {
      {
      {
#line 231
      crit((char *)"Couldn\'t setup signal traps.");
      }
      }
    }
  }
  {
  {
#line 234
  __cil_tmp86 = socket(2, 1, 0);
#line 234
  sockfd = __cil_tmp86;
  }
  }
#line 235
  if (sockfd == -1) {
    {
    {
#line 235
    crit((char *)"Couldn\'t create socket.");
    }
    }
  }
  {
  {
#line 237
  my_addr.sin_family = 2;
  }
  {
#line 238
  __cil_tmp87 = htons((unsigned short )port);
#line 238
  my_addr.sin_port = __cil_tmp87;
  }
  {
#line 239
  my_addr.sin_addr.s_addr = 0U;
  }
  {
#line 240
  bzero((void *)(& my_addr.sin_zero), 8U);
  }
  {
#line 242
  __cil_tmp88 = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& my_addr)),
                     sizeof(struct sockaddr ));
#line 242
  tmp___27 = __cil_tmp88;
  }
  }
#line 242
  if (tmp___27 == -1) {
    {
    {
#line 243
    crit((char *)"Couldn\'t bind to specified port.");
    }
    }
  }
  {
  {
#line 245
  sin_size = (int )sizeof(struct sockaddr_in );
  }
  {
#line 247
  __cil_tmp89 = listen(sockfd, 25);
#line 247
  tmp___28 = __cil_tmp89;
  }
  }
#line 247
  if (tmp___28 == -1) {
    {
    {
#line 247
    crit((char *)"Couldn\'t listen on specified port.");
    }
    }
  }
#line 249
  if (verbose) {
    {
    {
#line 249
    printf("Listening for connections on port %d...\n", port);
    }
    }
  }
  {
#line 250
  while (1) {
    original_while_10_continue: /* CIL Label */ ;
    {
    {
#line 251
    __cil_tmp90 = accept(sockfd, (struct sockaddr *)(& remote_addr), (socklen_t *)(& sin_size));
#line 251
    newfd = __cil_tmp90;
    }
    }
#line 252
    if (newfd == -1) {
      {
      {
#line 252
      crit((char *)"Couldn\'t accept connection!");
      }
      }
    }
#line 254
    if (verbose) {
      {
      {
#line 254
      printf("Connected, handling request.\n");
      }
      }
    }
#line 256
    if (background) {
      {
      {
#line 257
      __cil_tmp91 = fork();
#line 257
      fr = __cil_tmp91;
      }
      }
#line 258
      if (fr != 0) {
        goto original_while_10_continue;
      }
      {
      {
#line 259
      handle_connection(newfd, & remote_addr);
      }
      {
#line 260
      _exit(0);
      }
      }
    }
    {
    {
#line 262
    handle_connection(newfd, & remote_addr);
    }
    }
  }
  original_while_10_break: /* CIL Label */ ;
  }
#line 264
  return (0);
}
}

#line 53 "cheetah.c"
int usefork_old  =    0;
#line 75 "cheetah.c"
static void help_old(void) 
{ 

  if (__DSU_updated == 1) {
  OLD2: assert(0);
  }

  {
  {
  {
#line 76
  printf("Usage: cheetah [OPTIONS] [DIRECTORY]\n");
  }
  {
#line 77
  printf("Serves up the files listed in the specified directory using HTTP.\n");
  }
  {
#line 78
  printf("Note that the list of files is scanned on startup only - to rescan the files\n");
  }
  {
#line 79
  printf("for additions, you must restart cheetah.\n\n");
  }
  {
#line 80
  printf("-d, --default-type   default mime-type if file isn\'t found in the database,\n");
  }
  {
#line 81
  printf("                       defaults to text/plain\n");
  }
  {
#line 83
  printf("-b                   background mode (also disables console output)\n");
  }
  {
#line 84
  printf("-f                   fork for each request\n");
  }
  {
#line 86
  printf("-g                   generate indices for the root directory when no index.html\n");
  }
  {
#line 87
  printf("                       is found\n");
  }
  {
#line 88
  printf("    --headers        print out all client request headers\n");
  }
  {
#line 89
  printf("-l, --log            log (in combined log format) all requests to standard\n");
  }
  {
#line 90
  printf("                       output\n");
  }
  {
#line 91
  printf("-p, --port           port to listen for requests on, defaults to 8000\n");
  }
  {
#line 92
  printf("-s                   follow symbolic links\n");
  }
  {
#line 93
  printf("-v                   verbose output\n");
  }
  {
#line 94
  printf("-V                   print version and exit\n");
  }
  {
#line 95
  printf("-h, --help           display this message and exit\n");
  }
  {
#line 96
  printf("\n");
  }
  {
#line 97
  printf("Please see http://www.neuro-tech.net/cheetah for updates and bug reporting.\n");
  }
  }
#line 98
  return;
}
}
#line 117 "cheetah.c"
int main_old(int argc , char **argv ) 
{ int port ;
  struct sockaddr_in my_addr ;
  struct sockaddr_in remote_addr ;
  int sin_size ;
  int flength ;
  char *fullpath ;
  char *dir ;
  DIR *dirpnt ;
  struct dirent *curdir ;
  struct stat curstat ;
  servable *curfile ;
  servable *lastfile ;
  int newfd ;
  int i ;
  int fr ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  __pid_t tmp___15 ;
  __pid_t tmp___16 ;
  __sighandler_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  __sighandler_t tmp___27 ;
  __sighandler_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  __pid_t tmp___31 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  DIR *__cil_tmp70 ;
  __pid_t __cil_tmp71 ;
  __pid_t __cil_tmp72 ;
  __sighandler_t __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  struct dirent *__cil_tmp77 ;
  size_t __cil_tmp78 ;
  size_t __cil_tmp79 ;
  void *__cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  void *__cil_tmp83 ;
  void *__cil_tmp84 ;
  size_t __cil_tmp85 ;
  void *__cil_tmp86 ;
  servable *__cil_tmp87 ;
  __sighandler_t __cil_tmp88 ;
  __sighandler_t __cil_tmp89 ;
  int __cil_tmp90 ;
  uint16_t __cil_tmp91 ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  __pid_t __cil_tmp94 ;
  int __cil_tmp95 ;
  __pid_t __cil_tmp96 ;

  if (__DSU_updated == 1) {
  OLD3: assert(0);
  }

  {
  {
#line 118
  port = 8000;
#line 123
  fullpath = (char *)((void *)0);
#line 124
  dir = (char *)((void *)0);
#line 126
  curdir = (struct dirent *)((void *)0);
#line 128
  curfile = (servable *)((void *)0);
#line 129
  lastfile = (servable *)((void *)0);
  }
#line 134
  if (argc < 2) {
    {
    {
    if (__DSU_updated) {
      {
      help_new();
      }
    } else {
      {
      help_old();
      }
    }
    }
    {
#line 134
    exit(0);
    }
    }
  }
  {
#line 136
  i = 1;
  }
  {
#line 136
  while (1) {
    original_while_0_continue: /* CIL Label */ ;
#line 136
    if (! (i < argc)) {
      goto original_while_0_break;
    }
    {
    {
#line 137
    __cil_tmp52 = strcmp((char const   *)(*(argv + i)), "-V");
#line 137
    tmp___14 = __cil_tmp52;
    }
    }
#line 137
    if (tmp___14 == 0) {
      {
      {
#line 138
      printf("You are using %s.\n", "Cheetah");
      }
      {
#line 139
      exit(0);
      }
      }
    } else {
      {
      {
#line 140
      __cil_tmp53 = strcmp((char const   *)(*(argv + i)), "--help");
#line 140
      tmp___12 = __cil_tmp53;
      }
      }
#line 140
      if (tmp___12 == 0) {
        {
        {
        if (__DSU_updated) {
          {
          help_new();
          }
        } else {
          {
          help_old();
          }
        }
        }
        {
#line 142
        exit(0);
        }
        }
      } else {
        {
        {
#line 140
        __cil_tmp54 = strcmp((char const   *)(*(argv + i)), "-h");
#line 140
        tmp___13 = __cil_tmp54;
        }
        }
#line 140
        if (tmp___13 == 0) {
          {
          {
          if (__DSU_updated) {
            {
            help_new();
            }
          } else {
            {
            help_old();
            }
          }
          }
          {
#line 142
          exit(0);
          }
          }
        } else {
          {
          {
#line 143
          __cil_tmp55 = strcmp((char const   *)(*(argv + i)), "--default-type");
#line 143
          tmp___10 = __cil_tmp55;
          }
          }
#line 143
          if (tmp___10 == 0) {
            {
#line 144
            default_type = (*(argv + (i + 1)));
#line 144
            i = i + 1;
            }
          } else {
            {
            {
#line 143
            __cil_tmp56 = strcmp((char const   *)(*(argv + i)), "-d");
#line 143
            tmp___11 = __cil_tmp56;
            }
            }
#line 143
            if (tmp___11 == 0) {
              {
#line 144
              default_type = (*(argv + (i + 1)));
#line 144
              i = i + 1;
              }
            } else {
              {
              {
#line 145
              __cil_tmp57 = strcmp((char const   *)(*(argv + i)), "--headers");
#line 145
              tmp___8 = __cil_tmp57;
              }
              }
#line 145
              if (tmp___8 == 0) {
                {
#line 146
                print_headers = 1;
                }
              } else {
                {
                {
#line 145
                __cil_tmp58 = strcmp((char const   *)(*(argv + i)), "-h");
#line 145
                tmp___9 = __cil_tmp58;
                }
                }
#line 145
                if (tmp___9 == 0) {
                  {
#line 146
                  print_headers = 1;
                  }
                } else {
                  {
                  {
#line 147
                  __cil_tmp59 = strcmp((char const   *)(*(argv + i)), "-p");
#line 147
                  tmp___6 = __cil_tmp59;
                  }
                  }
#line 147
                  if (tmp___6 == 0) {
                    {
                    {
#line 148
                    __cil_tmp60 = atoi((char const   *)(*(argv + (i + 1))));
#line 148
                    port = __cil_tmp60;
                    }
                    {
#line 148
                    i = i + 1;
                    }
                    }
                  } else {
                    {
                    {
#line 147
                    __cil_tmp61 = strcmp((char const   *)(*(argv + i)), "--port");
#line 147
                    tmp___7 = __cil_tmp61;
                    }
                    }
#line 147
                    if (tmp___7 == 0) {
                      {
                      {
#line 148
                      __cil_tmp62 = atoi((char const   *)(*(argv + (i + 1))));
#line 148
                      port = __cil_tmp62;
                      }
                      {
#line 148
                      i = i + 1;
                      }
                      }
                    } else {
                      {
                      {
#line 149
                      __cil_tmp63 = strcmp((char const   *)(*(argv + i)), "-l");
#line 149
                      tmp___4 = __cil_tmp63;
                      }
                      }
#line 149
                      if (tmp___4 == 0) {
                        {
#line 150
                        loglevel = 1;
                        }
                      } else {
                        {
                        {
#line 149
                        __cil_tmp64 = strcmp((char const   *)(*(argv + i)), "--log");
#line 149
                        tmp___5 = __cil_tmp64;
                        }
                        }
#line 149
                        if (tmp___5 == 0) {
                          {
#line 150
                          loglevel = 1;
                          }
                        } else {
                          {
                          {
#line 151
                          __cil_tmp65 = strcmp((char const   *)(*(argv + i)), "-v");
#line 151
                          tmp___3 = __cil_tmp65;
                          }
                          }
#line 151
                          if (tmp___3 == 0) {
                            {
#line 151
                            verbose = verbose + 1;
                            }
                          } else {
                            {
                            {
#line 152
                            __cil_tmp66 = strcmp((char const   *)(*(argv + i)), "-g");
#line 152
                            tmp___2 = __cil_tmp66;
                            }
                            }
#line 152
                            if (tmp___2 == 0) {
                              {
#line 152
                              generate_index = 1;
                              }
                            } else {
                              {
                              {
#line 153
                              __cil_tmp67 = strcmp((char const   *)(*(argv + i)),
                                                   "-f");
#line 153
                              tmp___1 = __cil_tmp67;
                              }
                              }
#line 153
                              if (tmp___1 == 0) {
                                {
#line 153
                                usefork_old = 1;
                                }
                              } else {
                                {
                                {
#line 154
                                __cil_tmp68 = strcmp((char const   *)(*(argv + i)),
                                                     "-s");
#line 154
                                tmp___0 = __cil_tmp68;
                                }
                                }
#line 154
                                if (tmp___0 == 0) {
                                  {
#line 154
                                  links = 1;
                                  }
                                } else {
                                  {
                                  {
#line 155
                                  __cil_tmp69 = strcmp((char const   *)(*(argv + i)),
                                                       "-b");
#line 155
                                  tmp = __cil_tmp69;
                                  }
                                  }
#line 155
                                  if (tmp == 0) {
                                    {
#line 155
                                    background = 1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 136
    i = i + 1;
    }
  }
  original_while_0_break: /* CIL Label */ ;
  }
  {
  {
#line 158
  dir = (*(argv + (argc - 1)));
  }
  {
#line 159
  __cil_tmp70 = opendir((char const   *)dir);
#line 159
  dirpnt = __cil_tmp70;
  }
  }
#line 160
  if ((unsigned int )dirpnt == (unsigned int )((void *)0)) {
    {
    {
#line 161
    printf("Invalid directory - %s.\n", dir);
    }
    {
    if (__DSU_updated) {
      {
      help_new();
      }
    } else {
      {
      help_old();
      }
    }
    }
    {
#line 161
    exit(1);
    }
    }
  }
#line 165
  if (background) {
    {
    {
#line 166
    verbose = 0;
    }
    {
#line 167
    __cil_tmp71 = fork();
#line 167
    tmp___15 = __cil_tmp71;
    }
    }
#line 167
    if (tmp___15 != 0) {
      {
      {
#line 167
      _exit(0);
      }
      }
    }
    {
    {
#line 168
    __cil_tmp72 = setsid();
#line 168
    tmp___16 = __cil_tmp72;
    }
    }
#line 168
    if (tmp___16 == -1) {
      {
      {
#line 168
      crit((char *)"Couldn\'t create SID session.");
      }
      }
    }
    {
    {
#line 169
    __cil_tmp73 = signal(17, (void (*)(int  ))1);
#line 169
    tmp___17 = __cil_tmp73;
    }
    }
#line 169
    if ((unsigned int )tmp___17 == (unsigned int )((void (*)(int  ))-1)) {
      {
      {
#line 170
      crit((char *)"Couldn\'t initialize signal handlers.");
      }
      }
    }
    {
    {
#line 172
    __cil_tmp74 = close(0);
#line 172
    tmp___18 = __cil_tmp74;
    }
    }
#line 172
    if (tmp___18 == -1) {
      {
      {
#line 173
      crit((char *)"Couldn\'t close streams.");
      }
      }
    } else {
      {
      {
#line 172
      __cil_tmp75 = close(1);
#line 172
      tmp___19 = __cil_tmp75;
      }
      }
#line 172
      if (tmp___19 == -1) {
        {
        {
#line 173
        crit((char *)"Couldn\'t close streams.");
        }
        }
      } else {
        {
        {
#line 172
        __cil_tmp76 = close(2);
#line 172
        tmp___20 = __cil_tmp76;
        }
        }
#line 172
        if (tmp___20 == -1) {
          {
          {
#line 173
          crit((char *)"Couldn\'t close streams.");
          }
          }
        }
      }
    }
  }
  {
#line 178
  while (1) {
    original_while_1_continue: /* CIL Label */ ;
    {
    {
#line 178
    __cil_tmp77 = readdir(dirpnt);
#line 178
    curdir = __cil_tmp77;
    }
    }
#line 178
    if (! curdir) {
      goto original_while_1_break;
    }
    {
    {
#line 179
    __cil_tmp78 = strlen((char const   *)(curdir->d_name));
#line 179
    tmp___21 = __cil_tmp78;
    }
    {
#line 179
    __cil_tmp79 = strlen((char const   *)dir);
#line 179
    tmp___22 = __cil_tmp79;
    }
    {
#line 179
    flength = (int )((tmp___21 + tmp___22) + 4U);
    }
    {
#line 180
    __cil_tmp80 = smalloc((unsigned int )flength);
#line 180
    fullpath = (char *)__cil_tmp80;
    }
    {
#line 181
    snprintf(fullpath, (unsigned int )(flength + 2), "%s/%s", dir, curdir->d_name);
    }
    }
#line 182
    if (links == 1) {
      {
      {
#line 183
      __cil_tmp81 = lstat((char const   *)fullpath, & curstat);
#line 183
      rv = __cil_tmp81;
      }
      }
    } else {
      {
      {
#line 185
      __cil_tmp82 = stat((char const   *)fullpath, & curstat);
#line 185
      rv = __cil_tmp82;
      }
      }
    }
#line 188
    if (rv != 0) {
      {
      {
#line 189
      fprintf(stderr, "Error statting file %s/%s\n", dir, curdir->d_name);
      }
      }
      goto original_while_1_continue;
    }
#line 194
    if ((curstat.st_mode & 61440U) == 32768U) {
#line 194
      if ((int )curdir->d_name[0] != 46) {
#line 195
        if ((unsigned int )files == (unsigned int )((void *)0)) {
          {
          {
#line 196
          __cil_tmp83 = smalloc(sizeof(servable ) + 2U);
#line 196
          files = (servable *)__cil_tmp83;
          }
          {
#line 196
          curfile = files;
          }
          }
        } else {
          {
          {
#line 198
          __cil_tmp84 = smalloc(sizeof(servable ) + 2U);
#line 198
          curfile = (servable *)__cil_tmp84;
          }
          }
        }
        {
        {
#line 201
        __cil_tmp85 = strlen((char const   *)(curdir->d_name));
#line 201
        flength = (int )__cil_tmp85;
        }
        {
#line 202
        __cil_tmp86 = smalloc((unsigned int )(flength + 2));
#line 202
        curfile->filename = (char *)__cil_tmp86;
        }
        {
#line 203
        strncpy(curfile->filename, (char const   *)(curdir->d_name), (unsigned int )(flength +
                                                                                     1));
        }
        {
#line 204
        curfile->fullpath = fullpath;
        }
        {
#line 205
        curfile->next = (void *)0;
        }
        {
#line 206
        curfile->content = (char *)((void *)0);
        }
        }
#line 208
        if ((unsigned int )lastfile == (unsigned int )((void *)0)) {
          {
#line 209
          lastfile = curfile;
          }
        } else {
          {
#line 211
          lastfile->next = (void *)curfile;
#line 212
          lastfile = curfile;
          }
        }
#line 215
        if (verbose) {
          {
          {
#line 215
          printf("Parsed %s as %s.\n", fullpath, curfile->filename);
          }
          }
        }
      } else {
        {
        {
#line 217
        free((void *)fullpath);
        }
        }
      }
    } else {
      {
      {
#line 217
      free((void *)fullpath);
      }
      }
    }
  }
  original_while_1_break: /* CIL Label */ ;
  }
#line 222
  if (generate_index == 1) {
    {
    {
#line 222
    __cil_tmp87 = gen_index();
#line 222
    index_page = __cil_tmp87;
    }
    }
  }
#line 225
  if (verbose) {
    {
    {
#line 225
    printf("Using system\'s sendfile functionality.\n");
    }
    }
  }
  {
  {
#line 229
  __cil_tmp88 = signal(15, & sigcatch);
#line 229
  tmp___27 = __cil_tmp88;
  }
  }
#line 229
  if ((unsigned int )tmp___27 == (unsigned int )((void (*)(int  ))-1)) {
    {
    {
#line 230
    crit((char *)"Couldn\'t setup signal traps.");
    }
    }
  } else {
    {
    {
#line 229
    __cil_tmp89 = signal(2, & sigcatch);
#line 229
    tmp___28 = __cil_tmp89;
    }
    }
#line 229
    if ((unsigned int )tmp___28 == (unsigned int )((void (*)(int  ))-1)) {
      {
      {
#line 230
      crit((char *)"Couldn\'t setup signal traps.");
      }
      }
    }
  }
  {
  {
#line 233
  __cil_tmp90 = socket(2, 1, 0);
#line 233
  sockfd = __cil_tmp90;
  }
  }
#line 234
  if (sockfd == -1) {
    {
    {
#line 234
    crit((char *)"Couldn\'t create socket.");
    }
    }
  }
  {
  {
#line 236
  my_addr.sin_family = 2;
  }
  {
#line 237
  __cil_tmp91 = htons((unsigned short )port);
#line 237
  my_addr.sin_port = __cil_tmp91;
  }
  {
#line 238
  my_addr.sin_addr.s_addr = 0U;
  }
  {
#line 239
  bzero((void *)(& my_addr.sin_zero), 8U);
  }
  {
#line 241
  __cil_tmp92 = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& my_addr)),
                     sizeof(struct sockaddr ));
#line 241
  tmp___29 = __cil_tmp92;
  }
  }
#line 241
  if (tmp___29 == -1) {
    {
    {
#line 242
    crit((char *)"Couldn\'t bind to specified port.");
    }
    }
  }
  {
  {
#line 244
  sin_size = (int )sizeof(struct sockaddr_in );
  }
  {
#line 246
  __cil_tmp93 = listen(sockfd, 25);
#line 246
  tmp___30 = __cil_tmp93;
  }
  }
#line 246
  if (tmp___30 == -1) {
    {
    {
#line 246
    crit((char *)"Couldn\'t listen on specified port.");
    }
    }
  }
#line 248
  if (verbose) {
    {
    {
#line 248
    printf("Listening for connections on port %d...\n", port);
    }
    }
  }
  {
#line 249
  while (1) {
    original_while_2_continue: /* CIL Label */ ;
#line 250
    if (usefork_old) {
      {
      {
#line 251
      __cil_tmp94 = wait((void *)0);
#line 251
      tmp___31 = __cil_tmp94;
      }
      }
#line 251
      if (tmp___31 == -1) {
        {
        {
#line 251
        crit((char *)"Error in wait call.");
        }
        }
      }
    }
    {
    {
#line 253
    __cil_tmp95 = accept(sockfd, (struct sockaddr *)(& remote_addr), (socklen_t *)(& sin_size));
#line 253
    newfd = __cil_tmp95;
    }
    }
#line 254
    if (newfd == -1) {
      {
      {
#line 254
      crit((char *)"Couldn\'t accept connection!");
      }
      }
    }
#line 256
    if (verbose) {
      {
      {
#line 256
      printf("Connected, handling request.\n");
      }
      }
    }
#line 258
    if (usefork_old) {
      {
      {
#line 259
      __cil_tmp96 = fork();
#line 259
      fr = __cil_tmp96;
      }
      }
#line 260
      if (fr != 0) {
        goto original_while_2_continue;
      }
      {
      {
#line 261
      handle_connection(newfd, & remote_addr);
      }
      {
#line 262
      _exit(0);
      }
      }
    }
    {
    {
#line 265
    handle_connection(newfd, & remote_addr);
    }
    {
    {
    __DSU_updateCount = __DSU_updateCount + 1;
    if (__DSU_updateCount == 5) {
      {
      __DSU_updated = 1;
      }
    }
    }
    }
    }
  }
  original_while_2_break: /* CIL Label */ ;
  }
#line 269
  return (0);
}
}


int main(int argc , char **argv ) {
  return main_old(argc, argv);
}
 
